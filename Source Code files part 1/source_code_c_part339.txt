troller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));



    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }

    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }

    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }

    //
    // Save extended sequencer registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_EXT_SEQUENCER_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        //
        // No extended sequencer registers for the CL64xx
        //

        for (i = CL542x_SEQUENCER_EXT_START;
             i <= CL542x_SEQUENCER_EXT_END;
             i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  SEQ_DATA_PORT);

        }
    }

#endif

    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
            }
        else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
            }

       }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Save extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_CRTC_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        //
        // No CRTC Extensions in CL64xx chipset
        //

        for (i = CL542x_CRTC_EXT_START; i <= CL542x_CRTC_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_COLOR);

            } else {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_MONO);
            }
        }
    }

/* myf2, crus
    if (HwDeviceExtension->ChipType &  CL755x)
    {
        for (i = 0x81; i <= 0x91; i++)
        {
            if (bIsColor)
            {
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_COLOR);

            } else {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_MONO);
            }
        }
    }
crus, myf2 */

    //if ((HwDeviceExtension->ChipType &  CL754x) ||    //myf32
    //    (HwDeviceExtension->ChipType &  CL755x) ||    //myf32
    //    (HwDeviceExtension->ChipType == CL756x)) {
    //   {
    //   NordicSaveRegs(HwDeviceExtension,
    //      (PUSHORT)hardwareStateHeader + sizeof(NORDIC_REG_SAVE_BUF));
    //   }

#endif

    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

        }

    //
    // Save extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_GRAPH_CONT_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        for (i = CL542x_GRAPH_EXT_START; i <= CL542x_GRAPH_EXT_END; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  GRAPH_DATA_PORT);

        }

    } else {         // must be a CL64xx

        for (i = CL64xx_GRAPH_EXT_START; i <= CL64xx_GRAPH_EXT_END; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  GRAPH_DATA_PORT);
        }
    }

#endif

    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    portIO = MISC_OUTPUT_REG_WRITE_PORT ;
    value = (UCHAR) (hardwareStateHeader->
                PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] |
                0x02) ;
    IOWaitDisplEnableThenWrite ( HwDeviceExtension,
                                 portIO,
                                 value ) ;

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_NON_STANDARD_VGA;

#endif

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the seuencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //
        // Some cirrus cards have a bug where DWORD reads from
        // the frame buffer fail.  When we restore the video
        // memory, fonts are corrupted.
        //

#if 1
        {
            int c;

            for (c = 0; c < VGA_PLANE_SIZE / 2; c++)
            {
                ((PUSHORT)bufferPointer)[c] =
                    ((PUSHORT)(HwDeviceExtension->VideoMemoryAddress))[c];
            }
        }
#else
        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
#endif

        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    return NO_ERROR;

} // end VgaSaveHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode selection

--*/

{

#ifdef _X86_

    ULONG codeSize;
    ULONG codePlanarSize;
    ULONG codeEnablePlanarSize;
    ULONG codeDisablePlanarSize;
    PUCHAR pCodeDest;
    PUCHAR pCodeBank;
    PUCHAR pCodePlanarBank;
    PUCHAR pCodeEnablePlanar;
    PUCHAR pCodeDisablePlanar;

    ULONG AdapterType = HwDeviceExtension->ChipType;
    PVIDEOMODE pMode = HwDeviceExtension->CurrentMode;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Determine the banking type, and set whether any banking is actually
    // supported in this mode.
    //

    BankSelect->BankingFlags = 0;
    codeSize = 0;
    codePlanarSize = 0;
	codeEnablePlanarSize = 0;
	codeDisablePlanarSize = 0;
    pCodeBank = NULL;

    switch(pMode->banktype) {

    case NoBanking:

        BankSelect->BankingType = VideoNotBanked;
        BankSelect->Granularity = 0;

        break;

    case PlanarHCBanking:

        BankSelect->BankingFlags = PLANAR_HC; // planar mode supported

#if ONE_64K_BANK
        //
        // The Cirrus Logic VGA's support one 64K read/write bank.
        //

        BankSelect->PlanarHCBankingType = VideoBanked1RW;
        BankSelect->PlanarHCGranularity = 0x10000; // 64K bank start adjustment
                                                   //  in planar HC mode as well
#endif
#if TWO_32K_BANKS
        //
        // The Cirrus Logic VGA's support two 32K read/write banks.
        //

        BankSelect->PlanarHCBankingType = VideoBanked2RW;
        BankSelect->PlanarHCGranularity = 0x8000; // 32K bank start adjustment
                                                  //  in planar HC mode as well
#endif

        // 64K bank start adjustment in planar HC mode as well

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            if ((HwDeviceExtension->ChipType != CL542x) &&
                (HwDeviceExtension->ChipType != CL6245))
            {
                codePlanarSize =  ((ULONG)&CL543xPlanarHCBankSwitchEnd) -
                                 ((ULONG)&CL543xPlanarHCBankSwitchStart);

                pCodePlanarBank = &CL543xPlanarHCBankSwitchStart;
            }
            else
            {
                codePlanarSize =  ((ULONG)&CL542xPlanarHCBankSwitchEnd) -
                                  ((ULONG)&CL542xPlanarHCBankSwitchStart);

                pCodePlanarBank = &CL542xPlanarHCBankSwitchStart;
            }

            codeEnablePlanarSize = ((ULONG)&CL542xEnablePlanarHCEnd) -
                                   ((ULONG)&CL542xEnablePlanarHCStart);

            codeDisablePlanarSize = ((ULONG)&CL542xDisablePlanarHCEnd) -
                                    ((ULONG)&CL542xDisablePlanarHCStart);
            pCodeEnablePlanar = &CL542xEnablePlanarHCStart;
            pCodeDisablePlanar = &CL542xDisablePlanarHCStart;

        }
        else
        {   // must be a CL64xx product

            codePlanarSize =  ((ULONG)&CL64xxPlanarHCBankSwitchEnd) -
                              ((ULONG)&CL64xxPlanarHCBankSwitchStart);

            codeEnablePlanarSize = ((ULONG)&CL64xxEnablePlanarHCEnd) -
                                   ((ULONG)&CL64xxEnablePlanarHCStart);

            codeDisablePlanarSize = ((ULONG)&CL64xxDisablePlanarHCEnd) -
                                    ((ULONG)&CL64xxDisablePlanarHCStart);

            pCodePlanarBank = &CL64xxPlanarHCBankSwitchStart;
            pCodeEnablePlanar = &CL64xxEnablePlanarHCStart;
            pCodeDisablePlanar = &CL64xxDisablePlanarHCStart;
        }

    //
    // Fall through to the normal banking case
    //

    case NormalBanking:

#if ONE_64K_BANK
        //
        // The Cirrus Logic VGA's support one 64K read/write bank.
        //

        BankSelect->BankingType = VideoBanked1RW;
        BankSelect->Granularity = 0x10000;
#endif
#if TWO_32K_BANKS
        //
        // The Cirrus Logic VGA's support two 32K read/write banks.
        //

        BankSelect->BankingType = VideoBanked2RW;
        BankSelect->Granularity = 0x8000;
#endif

        if ((AdapterType == CL542x) ||
            (AdapterType == CL6245))
        {

            codeSize = ((ULONG)&CL542xBankSwitchEnd) -
                       ((ULONG)&CL542xBankSwitchStart);

            pCodeBank = &CL542xBankSwitchStart;

        }
        else if  ((AdapterType == CL6410) ||
                  (AdapterType == CL6420))
        {
            codeSize = ((ULONG)&CL64xxBankSwitchEnd) -
                       ((ULONG)&CL64xxBankSwitchStart);

            pCodeBank = &CL64xxBankSwitchStart;
        }
        else
        {
            codeSize = ((ULONG)&CL543xBankSwitchEnd) -
                       ((ULONG)&CL543xBankSwitchStart);

            pCodeBank = &CL543xBankSwitchStart;

        }

        break;
    }

    //
    // Size of banking info.
    //

    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    if (BankSelect->BankingFlags & PLANAR_HC) {

        BankSelect->Size += codePlanarSize + codeEnablePlanarSize +
            codeDisablePlanarSize;

    }

    //
    // This serves an a ID for the version of the structure we're using.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // There's room enough for everything, so fill in all fields in
    // VIDEO_BANK_SELECT. (All fields are always returned; the caller can
    // just choose to ignore them, based on BankingFlags and BankingType.)
    //

    BankSelect->BitmapWidthInBytes = pMode->wbytes;
    BankSelect->BitmapSize = pMode->sbytes;

    //
    // Copy all banking code into the output buffer.
    //

    pCodeDest = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    if (pCodeBank != NULL) {

        BankSelect->CodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeBank,
                            codeSize);

        pCodeDest += codeSize;
    }

    if (BankSelect->BankingFlags & PLANAR_HC) {

        //
        // Copy appropriate high-color planar Bank Switch code:
        //

        BankSelect->PlanarHCBankCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodePlanarBank,
                            codePlanarSize);

        pCodeDest += codePlanarSize;

        //
        // Copy high-color planar bank mode Enable code:
        //

        BankSelect->PlanarHCEnableCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeEnablePlanar,
                            codeEnablePlanarSize);

        pCodeDest += codeEnablePlanarSize;

        //
        // Copy high-color planar bank mode Disable code:
        //

        BankSelect->PlanarHCDisableCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeDisablePlanar,
                            codeDisablePlanarSize);

    }

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

#else

    //
    // This function is only defined for x86
    //

    return ERROR_INVALID_FUNCTION;

#endif
} // end VgaGetBankSelectCode()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUcharEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;
    UCHAR tempB ;
    ULONG portIO ;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                tempB = (UCHAR) (*Data & 0xF7) ;
                portIO = Port ;
                IOWaitDisplEnableThenWrite ( hwDeviceExtension,
                                            portIO,
                                            tempB ) ;

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUshortEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;
    UCHAR tempB ;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }
                endEmulation = 0;
            }
        }
        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);
        //
        // Write back the real value of the sequencer address port.
        //
        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);
        //
        // If we are in a READ path, read the data
        //
        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));
            endEmulation = 0;
        }
        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //
        if (endEmulation) {
            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);
            return NO_ERROR;
        }
        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //
        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));
    } else {
        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                             (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);
                return NO_ERROR;
            }
            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                             FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;
                //
                // Start keeping track of the state of the sequencer port.
                //
                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;
            } else {
                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);
            }
        } else {
            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));
        }
    }
    return NO_ERROR;

} // end VgaValidatorUshortEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUlongEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    if (hwDeviceExtension->TrappedValidatorCount) {
        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {
                *Data &= 0xFFFFFFF7;
            }
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;
            hwDeviceExtension->TrappedValidatorCount++;
            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //
            if (Port == SEQ_ADDRESS_PORT) {
                //
                // If we are accessing the seq address port, keep track of its
                // value
                //
                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);
            }
            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {
                endEmulation = 1;
            } else {
                //
                // If the buffer is not full, then just return right away.
                //
                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {
                    return NO_ERROR;
                }
                endEmulation = 0;
            }
        }
        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));
        hwDeviceExtension->TrappedValidatorCount++;
        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);
        //
        // Write back the real value of the sequencer address port.
        //
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);
        //
        // If we are in a READ path, read the data
        //
        if (AccessMode & EMULATOR_READ_ACCESS) {
            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));
            endEmulation = 0;
        }
        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //
        if (endEmulation) {
            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);
            return NO_ERROR;
        }
        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //
        hwDeviceExtension->TrappedValidatorCount = 1;
        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;
        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;
        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {
        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {
                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);
                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));
                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                             (ULONG) (*Data & 0xFFFFFFF7) );
                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);
                return NO_ERROR;
            }
            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {
                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);
                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;
                //
                // Start keeping track of the state of the sequencer port.
                //
                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {
                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }
        } else {
            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                           Port));
        }
    }
    return NO_ERROR;

} // end VgaValidatorUlongEntry()

//---------------------------------------------------------------------------
BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )
/*++
Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.
--*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = Context;
    ULONG_PTR ioBaseAddress = PtrToUlong(hwDeviceExtension->IOAddress);
    UCHAR i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;
    //
    // Loop through the array of data and do instructions one by one.
    //
    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {
        //
        // Calculate base address first
        //
        ioBaseAddress = PtrToUlong(hwDeviceExtension->IOAddress) +
                            validatorData->Port;
        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((1, "InvalidValidatorAccessType\n" ));
        }
    }
    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

//---------------------------------------------------------------------------
BOOLEAN
CirrusLogicIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine returns TRUE if an CL6410, 6420, 542x, or 543x is present.
    It assumes that it's already been established that a VGA is present.
    It performs the Cirrus Logic recommended ID test for each chip type:

    6410: we try to enable the extension registers and read back a 1, then
    disable the extensions are read back a 0 in GR0A.

    6420: same as above

    54xx: Enable extended registers by writing 0x12 to the extensions
          enable register, and reading back 0x12.  Then read from the
          ID register and make sure it specifies a 542x, 543x.
          Finally, disable the extensions and make sure the
          extensions enable register reads back 0x0F.

    If this function fails to find an Cirrus Logic VGA, it attempts to undo any
    damage it may have inadvertently done while testing.

    If a Cirrus Logic VGA is found, the adapter is returned to its original
    state after testing is finished, except that extensions are left enabled.

Arguments:

    None.

Return Value:

    TRUE if an CL6410/6420/542x/543x is present, FALSE if not.

--*/

{
    #define MAX_ROM_SCAN 4096

    UCHAR   *pRomAddr;
    PHYSICAL_ADDRESS paRom = {0x000C0000,0x00000000};

    UCHAR originalGRIndex;
    UCHAR originalGR0A;
    UCHAR originalCRTCIndex;
    UCHAR originalSeqIndex;
    UCHAR originalExtsEnb;
    UCHAR SystemBusSelect;
    PUCHAR CRTCAddressPort, CRTCDataPort;
    UCHAR temp1, temp2, temp3;
    UCHAR revision;
    ULONG rev10bit;

    BOOLEAN retvalue = FALSE;    // default return value

    // Set default value, assuming it is not CL-GD5480.

    HwDeviceExtension->BitBLTEnhance = FALSE ;

    //
    // first, save the Graphics controller index
    //

    originalGRIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Then save the value of GR0A
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, CL64xx_EXTENSION_ENABLE_INDEX);
    originalGR0A = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // then, Unlock the CL6410 extended registers., GR0A = 0ECH
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, CL64xx_EXTENSION_ENABLE_VALUE);

    //
    // read back GR0A, it should be a 1
    //

    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // then, Lock the CL6410 extended registers., GR0A = 0CEH
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, CL64xx_EXTENSION_DISABLE_VALUE);

    //
    // read back GR0A, it should be a 0
    //

    temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // restore the GR0A value
    // this will not have any effect if the chip IS a CL6410 or 6420
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalGR0A);

    //
    // now restore the graphics index
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGRIndex);

    //
    // now test to see if the returned values were correct!
    //

    if ((temp1 == 1) && (temp2 == 0))
    {
        //
        // By golly, it *is* a CL6410 or CL6420!
        //
        // but now we have to determine the chip type, and which display is
        // active.
        // reenable the extension registers first
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), CL64xx_EXTENSION_ENABLE_INDEX +
            (CL64xx_EXTENSION_ENABLE_VALUE << 8));

        //
        // now get the chip type at ERAA
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0xaa);

        revision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
             GRAPH_DATA_PORT);

        //
        // now restore the graphics index
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
         GRAPH_ADDRESS_PORT, originalGRIndex);

        if ((revision & 0xf0) == 0x80)      // 6410 rev code
        {
            VideoDebugPrint((1, "CL 6410 found\n"));

            //
            // we don't support 6340 in this driver, so force it not to be
            // installed.
            //

            if (!CirrusFind6340(HwDeviceExtension))
            {
                HwDeviceExtension->ChipType = CL6410;
                HwDeviceExtension->AdapterMemorySize = 0x00040000; // 256K
                HwDeviceExtension->DisplayType =
                                 CirrusFind6410DisplayType(HwDeviceExtension);
                retvalue = TRUE;
            }
        }
        else if ((revision & 0xf0) == 0x70)           // 6420 rev code
        {
            VideoDebugPrint((1, "CL 6420 found\n"));

            //
            // we don't support 6340 in this driver, so force it not to be
            // installed.
            //

            if (!CirrusFind6340(HwDeviceExtension))
            {
                HwDeviceExtension->ChipType = CL6420;
                HwDeviceExtension->ChipRevision = (USHORT) revision;
                HwDeviceExtension->DisplayType =
                                 CirrusFind6410DisplayType(HwDeviceExtension);

                VideoDebugPrint((2, "CL 64xxx Adapter Memory size = %08lx\n",
                                 HwDeviceExtension->AdapterMemorySize));


                retvalue = TRUE;
            }
        }
        else  // we dont support 5410 at this time
        {
            VideoDebugPrint((1, "Unsupported CL VGA chip found\n"));
        }
    }

    if (retvalue == FALSE)         // Did not detect a 64x0, see if it's a 542x
    {
        //
        // Determine where the CRTC registers are addressed (color or mono).
        //
        CRTCAddressPort = HwDeviceExtension->IOAddress;
        CRTCDataPort = HwDeviceExtension->IOAddress;

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01)
        {

            CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
            CRTCDataPort += CRTC_DATA_PORT_COLOR;

        }
        else
        {
            CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
            CRTCDataPort += CRTC_DATA_PORT_MONO;
        }

        //
        // Save the original state of the CRTC and Sequencer Indices.
        //

        originalCRTCIndex = VideoPortReadPortUchar(CRTCAddressPort);
        originalSeqIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                          SEQ_ADDRESS_PORT);
        //
        // Try to enable all extensions:
        // a) Set the Sequencer Index to IND_CL_EXTS_ENB.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                IND_CL_EXTS_ENB);

        //
        // b) Save the original state of Sequencer register IND_CL_EXTS_ENB.
        //

        originalExtsEnb = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                          SEQ_DATA_PORT);

        //
        // c) Write enabling value (0x12) to extension enable register
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),(USHORT)((0x12 << 8) + IND_CL_EXTS_ENB));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                IND_CL_EXTS_ENB);
        temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        //
        // Read Chip ID Value from CRTC Register (Ignoring revision bits)
        //

        VideoPortWritePortUchar(CRTCAddressPort, IND_CL_ID_REG);
        temp3 = VideoPortReadPortUchar(CRTCDataPort);

        //
        // Detect if CL-GD6245 chips ID=0x16
        //
        if (temp3 != 0x16)
        {
            rev10bit = (ULONG)temp3 & 0x3;  // lo bits of ID are high bits of rev code
            temp3 = temp3 >> 2;   // shift off revision bits
        }

        //
        // Write another value (!= 0x12) to IND_CL_EXTS_ENB to disable extensions
        // Should read back as 0x0F
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),(USHORT)((0 << 8) + IND_CL_EXTS_ENB));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                IND_CL_EXTS_ENB);
        temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        //
        // Restore the original IND_CL_EXTS_ENB state.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress
              + SEQ_ADDRESS_PORT),
                (USHORT)((originalExtsEnb << 8) + IND_CL_EXTS_ENB));

        //
        // Check values read from IND_CL_EXTS_ENB and IND_CL_ID_REG to be correct
        //

        if ((temp1 != (UCHAR) (0x12)) ||
            (temp2 != (UCHAR) (0x0F)) ||
            (temp3 >  (UCHAR) (0x2F)) ||        // 2F is 5480
            (temp3 <  (UCHAR) (0x0B)) )         // 0B is Nordic (7542)
        {
            //
            // Did not find appropriate CL VGA Chip.
            //

            VideoDebugPrint((1, "CL VGA chip not found\n"));

            retvalue = FALSE;
        }

        //
        // Detect if CL-GD6245 chips
        //
        else if ((temp1 == (UCHAR) (0x12)) &&
                 (temp2 == (UCHAR) (0x0F)) &&
                 (temp3 == (UCHAR) (0x16)))     //6245
        {
            VideoDebugPrint((1, "CL 6245 found\n"));
            HwDeviceExtension->ChipType = CL6245;
            HwDeviceExtension->DisplayType =
                    CirrusFind6245DisplayType(HwDeviceExtension,
                                              CRTCAddressPort,
                                              CRTCDataPort);
            retvalue = TRUE;
        }
        else
        {

            //
            // It's a supported CL adapter.
            //
            // Save actual Chip ID in ChipRevision field of HwDeviceExtension
            //

            HwDeviceExtension->ChipRevision = temp3;
            if ((temp3 > (UCHAR) (0x27)) ||       // 27 is 5429
                (temp3 < (UCHAR) (0x22) ) )       // 22 is 5422
            {
                if ((temp3 >= (UCHAR) (0x0B)) &&  // Nordic
                    (temp3 <= (UCHAR) (0x0E)) )   // Everest

                {
                    if (temp3 == (UCHAR)0x0B)
                    {
                        VideoDebugPrint((1, "CL 7542 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7542;
                    }
                    if (temp3 == (UCHAR)0x0C)
                    {
                        VideoDebugPrint((1, "CL 7543 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7543;
                    }
                    if (temp3 == (UCHAR)0x0D)
                    {
                        VideoDebugPrint((1, "CL 7541 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7541;
                    }
                    if (temp3 == (UCHAR)0x0E)
                    {
                        VideoDebugPrint((1, "CL 7548 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7548;
                    }
                    HwDeviceExtension->DisplayType =
                        CirrusFind754xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort);
                } else if ((temp3 == (UCHAR) (0x10)) ||
                           (temp3 == (UCHAR) (0x13))) {  //myf17, CF
                    if (temp3 == (UCHAR)0x10)
                    {
                        VideoDebugPrint((1, "CL 7555 found\n")) ;
                        HwDeviceExtension->ChipType = CL7555;
                    }
                    if (temp3 == (UCHAR)0x13)
                    {
                        VideoDebugPrint((1, "CL 7556 found\n")) ;
                        HwDeviceExtension->ChipType = CL7556;
                    }
                    HwDeviceExtension -> DisplayType =
                      CirrusFind755xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort) ;
                     } else if (temp3 == (UCHAR) (0x11)) {
                         VideoDebugPrint((1, "CL 756x found\n")) ;
                         HwDeviceExtension->ChipType = CL756x ;
                         HwDeviceExtension->DisplayType =
                        CirrusFind755xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort) ;
                } else {
                    VideoDebugPrint((1, "CL 543x found\n"));
                    HwDeviceExtension->ChipType = CL543x;
                    HwDeviceExtension->DisplayType = crt;

                                                                                // jl03  Read CR27(b1 & b0) + CR25 for chip revision
                    VideoPortWritePortUchar(CRTCAddressPort, IND_CL_REV_REG);
                    revision = (VideoPortReadPortUchar(CRTCDataPort));
                    rev10bit = (ULONG)(rev10bit << 8) | revision;

                                                                                if (temp3 == (UCHAR) (0x2A))      // or a 5434?
                    {
                        VideoDebugPrint((1, "CL 5434 found\n"));

                        //
                        //Default to .8u 5434
                        //

                        HwDeviceExtension->ChipType = CL5434;

                        //
                        // Read the revision code from CR25&27 and compare to
                        // lowest rev that we know to be .6u
                        //
/* jl03
                        VideoPortWritePortUchar(CRTCAddressPort, IND_CL_REV_REG);
                        revision = (VideoPortReadPortUchar(CRTCDataPort));
                        rev10bit = (ULONG)(rev10bit << 8) | revision;
*/
                        if ((rev10bit >= 0xB0) ||  // B0 is rev "EP", first .6u 5434
                            (rev10bit == 0x28) )   // 28 is rev "AH" also .6u 5434
                        {
                            VideoDebugPrint((1, "CL 5434.6 found\n"));
                            HwDeviceExtension->ChipType = CL5434_6;
                        }
                    } else if (temp3 == (UCHAR) (0x2B)) {           // 5436
                        HwDeviceExtension->ChipType = CL5436 ;
                    } else if (temp3 == (UCHAR) (0x2E)) {           // 5446
                        HwDeviceExtension->ChipType = CL5446 ;
                        if (rev10bit == 0x45)
                           HwDeviceExtension->ChipType = CL5446BE ; // jl02  5446-BE
                    } else if (temp3 == (UCHAR) (0x2F)) {           // 5480
                        HwDeviceExtension->ChipType = CL5480;
                        HwDeviceExtension->BitBLTEnhance = TRUE ;
                    } else if (temp3 == (UCHAR) (0x3A)) {           // 54UM36 ?
                        HwDeviceExtension->ChipType = CL54UM36 ;
                    }
                }
            }
            else
            {
                VideoDebugPrint((1, "CL 542x found\n"));
                HwDeviceExtension->ChipType = CL542x;
                HwDeviceExtension->DisplayType = crt;
            }

            retvalue = TRUE;
        }

        //
        // Restore modified index registers
        //

        VideoPortWritePortUchar(
             (HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT),
             originalSeqIndex);

        VideoPortWritePortUchar(CRTCAddressPort, originalCRTCIndex);
    }

    if (retvalue)
    {
         //
         // Restore the original Sequencer and CRTC Indices.
         //

         HwDeviceExtension->AutoFeature = FALSE ;

         if ((HwDeviceExtension->ChipType == CL5436) ||
             (HwDeviceExtension->ChipType == CL5446) ||
             (HwDeviceExtension->ChipType == CL5446BE) ||
             (HwDeviceExtension->ChipType == CL5480) ||
             (HwDeviceExtension->ChipType &  CL754x) ||
             (HwDeviceExtension->ChipType &  CL755x) ||
             (HwDeviceExtension->ChipType == CL54UM36))
         {
             HwDeviceExtension->AutoFeature = TRUE;
         }
    }

   return retvalue;

} // CirrusLogicIsPresent()


//---------------------------------------------------------------------------
#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   )
{

    PUCHAR CRTCAddressPort, CRTCDataPort;
    USHORT RequestedPitchInBytes =  PanningMode.wbytes;
    USHORT PitchInQuadWords = RequestedPitchInBytes >> 3;
    UCHAR   savSEQidx, Panel_Type, LCD, ChipID;

    //
    // Determine where the CRTC registers are addressed (color or mono).
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        CRTCAddressPort = CRTC_ADDRESS_PORT_COLOR;
        CRTCDataPort = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        CRTCAddressPort = CRTC_ADDRESS_PORT_MONO;
        CRTCDataPort = CRTC_DATA_PORT_MONO;
    }


    //
    // Write out the requested pitch in quad words to CR13
    //

    VideoPortWritePortUchar(CRTCAddressPort, 0x13);
    VideoPortWritePortUchar(CRTCDataPort,
                            (UCHAR) (PitchInQuadWords & 0xFF) );
    //
    // See if requested pitch overflows to bit 4 in CR1B
    // NOTE: In either case we must either set or reset the bit.
    //

    VideoPortWritePortUchar(CRTCAddressPort, 0x1B);
    if (PitchInQuadWords & 0x100)
    {
       VideoPortWritePortUchar(CRTCDataPort,
          (UCHAR)(VideoPortReadPortUchar(CRTCDataPort) | 0x10) );
    }
    else
    {
       VideoPortWritePortUchar(CRTCDataPort,
          (UCHAR)(VideoPortReadPortUchar(CRTCDataPort) & ~0x10) );
    }

    VideoDebugPrint((1,"CirrusSetDisplayPitch - Exit (not error)\n"));

    return NO_ERROR;
}

#endif // PANNING_SCROLL

//---------------------------------------------------------------------------
//
// The memory manager needs a "C" interface to the banking functions
//

/*++

Routine Description:

    Each of these functions is a "C" callable interface to the ASM banking
    functions.  They are NON paged because they are called from the
    Memory Manager during some page faults.

Arguments:

    iBankRead -     Index of bank we want mapped in to read from.
    iBankWrite -    Index of bank we want mapped in to write to.

Return Value:

    None.

--*/


VOID
vBankMap_CL64xx(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL64xx(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL64xxBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL64xx - exit\n"));
}


VOID
vBankMap_CL543x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL543x(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL543xBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL543x - exit\n"));
}

VOID
vBankMap_CL542x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL542x(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL542xBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL542x - exit\n"));
}


//---------------------------------------------------------------------------
ULONG
CirrusFindVmemSize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns the amount of vram detected for the
    Cirrus Logic 6420 and 542x ONLY. It assumes that it is already known that
    a Cirrus Logic VGA is in the system.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Number of butes of VRAM.

--*/
{

    UCHAR temp;
    ULONG memsize=0;
    UCHAR originalSeqIndex;
    UCHAR originalGraphicsIndex;
    UCHAR PostScratchPad;

    if (HwDeviceExtension->ChipType == CL6420) {

#ifdef _X86_

        originalGraphicsIndex =
            VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                GRAPH_ADDRESS_PORT, 0x9a); // Video memory config register

        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                      GRAPH_DATA_PORT);    // get the data

        if ((temp & 0x07) == 0) { // 0 is accurate always

             memsize = 0x00040000;

        } else {

            //
            // We know now that the amount of vram is >256k. But we don't
            // know if it is 512k or 1meg.
            // They tell us to actually go out and see if memory is there by
            // writing into it and reading it back.
            //

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                     SEQ_ADDRESS_PORT),0x0f02);

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                     GRAPH_ADDRESS_PORT),0x0506);

            //
            // now pick a bank, and do the write
            //

            SetCirrusBanking(HwDeviceExtension,1);        // start of 2nd 256k

            VideoPortWriteRegisterUchar(HwDeviceExtension->VideoMemoryAddress,
                                        0x55);

            SetCirrusBanking(HwDeviceExtension,3);    // 3*256k is 768k

            VideoPortWriteRegisterUchar(HwDeviceExtension->VideoMemoryAddress,
                                        0xaa);

            SetCirrusBanking(HwDeviceExtension,1);        // start of 2nd 256k

            if (VideoPortReadRegisterUchar(HwDeviceExtension->VideoMemoryAddress)
                    == 0x55)  {

                memsize = 0x00100000; // 1 MEG

            } else {

                memsize = 0x00080000; // 512K
            }

            SetCirrusBanking(HwDeviceExtension,0);    // reset the memory value

            VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

            VideoPortWritePortUchar((HwDeviceExtension->IOAddress
                                    + GRAPH_ADDRESS_PORT),
                                    originalGraphicsIndex);
        }

        VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT), originalGraphicsIndex);

#endif
        return memsize;


   } else {   // its 542x or 543x

        originalSeqIndex = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT));

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT),
                                 (USHORT)((0x12 << 8) + IND_CL_EXTS_ENB));

        //
        // Read the POST scratch pad reg to determine amount of Video
        // memory
        //

        if (HwDeviceExtension->ChipType == CL542x) {
           VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_CL_SCRATCH_PAD);

           PostScratchPad = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                   SEQ_DATA_PORT);
           PostScratchPad = ((PostScratchPad & 0x18) >> 3);  // in bits 3 and 4
        }
        else if (HwDeviceExtension->ChipType == CL6245) {
           VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT),originalSeqIndex);
           memsize = 0x00080000; // 512K
           return memsize;
        }

        else
         {    // its 543x or 754x
           if ((HwDeviceExtension->ChipType &  CL754x) ||
               (HwDeviceExtension->ChipType &  CL755x) ||
               (HwDeviceExtension->ChipType == CL756x))
            {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_NORD_SCRATCH_PAD);
            }
           else // it's 543x, 5434, or 5434_6 by default
            {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_ALP_SCRATCH_PAD);
            }
           // Nordic family uses same bits as 543x, but in different register
           PostScratchPad = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                   SEQ_DATA_PORT);
           PostScratchPad &= 0x0F; // It's in bits 0-3
        }
        VideoPortWritePortUchar((HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT),
                                originalSeqIndex);

        //
        // Installed video memory is stored in scratch pad register by POST.
        //

        switch (PostScratchPad) {

        case 0x00:

            memsize = 0x00040000; // 256K
            break;

        case 0x01:

            memsize = 0x00080000; // 512K
            break;

        case 0x02:

            memsize = 0x00100000; // 1 MEG
            break;

        case 0x03:

            memsize = 0x00200000; // 2 MEG
            break;

        case 0x04:

            memsize = 0x00400000; // 4 MEG
            break;

        case 0x05:

            memsize = 0x00300000; // 3 MEG
            break;

        }

        //
        // The 542x cards don't properly address more than 1MB of
        // video memory, so lie and limit these cards to 1MB.
        //

        if ((HwDeviceExtension->ChipType == CL542x) &&
            (memsize > 0x00100000)) {

            memsize = 0x00100000; // 1 MEG

        }

        //
        // The memory size should not be zero!
        //

        ASSERT(memsize != 0);

        return memsize;
    }

} // CirrusFindVmemSize()

//---------------------------------------------------------------------------
VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT BankNumber
    )
/*++

Routine Description:

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankNumber - the 256k bank number to set in 1RW mode(we will set this mode).

Return Value:

    vmem256k, vmem512k, or vmem1Meg ONLY ( these are defined in cirrus.h).

--*/
{

    if ((HwDeviceExtension->ChipType == CL542x) ||
        (HwDeviceExtension->ChipType == CL6245)) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x1206);

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x010b);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x0009 + (BankNumber << (8+4))) );

    } else if ((HwDeviceExtension->ChipType == CL543x) ||
               (HwDeviceExtension->ChipType &  CL755x) ||       //myf15, crus
               (HwDeviceExtension->ChipType &  CL754x) ) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x1206);

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x210b);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x0009 + (BankNumber << (8+2))) );

    } else { // 6410 or 6420

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0xec0a);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x030d);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x000e + (BankNumber << (8+4))) );

    }

} // SetCirrusBanking()

//---------------------------------------------------------------------------
USHORT
CirrusFind6410DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

   Determines the display type for CL6410 or CL6420 crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    crt, panel as defined in cirrus.h

--*/
{
    UCHAR originalGraphicsIndex;
    UCHAR temp1;

    //
    // now we need to check to see which display we are on...
    //

    originalGraphicsIndex =
        VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                               GRAPH_ADDRESS_PORT));

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT, 0xd6);

    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                   GRAPH_DATA_PORT);

    VideoPortWritePortUchar((HwDeviceExtension->IOAddress
                            + GRAPH_ADDRESS_PORT), originalGraphicsIndex);


    if (temp1 & 0x02) {  // display is LCD Panel

        return panel;

    } else {              // the display is a crt

        return crt;

    }

} // CirrusFind6410DisplayType()

// crus
//---------------------------------------------------------------------------
USHORT
CirrusFind6245DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL6245 crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    crt, panel as defined in cirrus.h

--*/
{

    UCHAR originalCRTCIndex, originalLCDControl;
    UCHAR originalSEQIndex;
    USHORT temp2, temp4;
    USHORT temp1, temp3;

    //
    // we need to check to see which display we are on...
    //

    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);
    VideoPortWritePortUchar(CRTCAddrPort, 0x20);
    temp1 = VideoPortReadPortUchar(CRTCDataPort);
    temp3 = 0;
    temp4 = 0;

    if (temp1 & 0x40) temp3 = 1;
    if (temp1 & 0x20)
    {
       originalSEQIndex =
                  VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           SEQ_ADDRESS_PORT);
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, 0x1A);
       temp4 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                 SEQ_DATA_PORT) & 0x40;
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, originalSEQIndex);

      // Allow access to extended CRTC regs and read R8X[5], must CR1D[7]=1
      //
      VideoPortWritePortUchar(CRTCAddrPort, 0x1D);
      originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);
      VideoPortWritePortUchar(CRTCDataPort,
                              (UCHAR) (originalLCDControl | 0x80));
      VideoPortWritePortUchar(CRTCAddrPort, 0x08);
      temp1 = (VideoPortReadPortUchar(CRTCDataPort) & 0x20);
      VideoPortWritePortUchar (CRTCAddrPort, 0x1D);
      VideoPortWritePortUchar (CRTCDataPort, originalLCDControl);

      // CR1C bit 6,7 set indicate LCD type, TFT, STN color or STN mono
      // STN mono, R8X bit 5 set Single or Dual
      // STN color, CR1C bit 7,6 must 10 & SR1A bit 6 set Dual or Single

      VideoPortWritePortUchar (CRTCAddrPort, 0x1C);
      temp2 = VideoPortReadPortUchar(CRTCDataPort) & 0xC0;
      if (temp2 == 0)           //STN mono LCD
      {
         if (temp1 == 0)
            temp3 |= (USHORT)Dual_LCD | Mono_LCD | STN_LCD;
         else
            temp3 |= (USHORT)Single_LCD | Mono_LCD | STN_LCD;
      }
      else if (temp2 == 0x80)           //STN color LCD
      {
         if (temp4)
         {
            temp3 |= (USHORT)Dual_LCD | Color_LCD | STN_LCD;
         }
         else
         {
            temp3 |= (USHORT)Single_LCD | Color_LCD | STN_LCD;
         }
      }
      else if (temp2 == 0xC0)           //TFT LCD
      {
         temp3 |= (USHORT)TFT_LCD;      //myf28
      }

      // Restore LCD Display Controls register and CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      return (temp3 | panel);
   }
   else              // the display is a crt
   {
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
      return (temp3);
   }


} // CirrusFind6245DisplayType()
// end crus

//---------------------------------------------------------------------------
USHORT
CirrusFind754xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL754x crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    CRTCAddrPort, CRTCDataPort - Index of CRTC registers for current mode.

Return Value:

    crt, panel, or panel8x6 as defined in cirrus.h

--*/
{
// crus
//
// update 754X Display Type Detect code
//
    UCHAR originalCRTCIndex, originalLCDControl; // temp1;
    UCHAR originalSEQIndex;
    USHORT temp1, temp2, temp4;
    USHORT temp3, temp5;        // crus

    // we need to check to see which display we are on...
    //
    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);
    VideoPortWritePortUchar(CRTCAddrPort, 0x20);
    temp1 = VideoPortReadPortUchar(CRTCDataPort);
    temp3 = 0;          temp4 = 0;      //myf28
    if (temp1 & 0x40) temp3 = 1;

    if (!(temp1 & 0x20)) temp3 |= Jump_type;    //myf27
    else temp3 &= (~Jump_type);                 //myf27,myf28
//myf27    if (temp1 & 0x20)
    {
       originalSEQIndex =
                  VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           SEQ_ADDRESS_PORT);
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, 0x21);
       temp4 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                 SEQ_DATA_PORT) & 0x40;
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, originalSEQIndex);

      // bit 5 set indicates that display is on LCD Panel
      // Check extended reg to see if panel supports 800x600 display
      //
      VideoPortWritePortUchar(CRTCAddrPort, 0x2D);
      originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);

      // Allow access to extended CRTC regs and read R9X[3:2]
      //
      VideoPortWritePortUchar(CRTCDataPort,
                              (UCHAR) (originalLCDControl | 0x80));
      VideoPortWritePortUchar(CRTCAddrPort, 0x09);
      temp1 = (VideoPortReadPortUchar(CRTCDataPort) & 0x0C) >> 2;
      VideoPortWritePortUchar (CRTCAddrPort, 0x08);
      temp5 = VideoPortReadPortUchar(CRTCDataPort) & 0x20;
      VideoPortWritePortUchar (CRTCAddrPort, 0x2D);
      VideoPortWritePortUchar (CRTCDataPort, originalLCDControl);

      // CR2C bit 6,7 set indicate LCD type, TFT, STN color or STN mono
      // STN mono, R8X bit 5 set Single or Dual
      // STN color, CR2C bit 7,6 must 10 & SR21 bit 6 set Dual or Single

      VideoPortWritePortUchar (CRTCAddrPort, 0x2C);
      temp2 = VideoPortReadPortUchar(CRTCDataPort) & 0xC0;
      if (temp2 == 0)           //STN mono LCD
      {
         if (temp5 == 0)
            temp3 |= (USHORT)Dual_LCD | Mono_LCD | STN_LCD;
         else
            temp3 |= (USHORT)Single_LCD | Mono_LCD | STN_LCD;
      }
      else if (temp2 == 0x80)           //STN color LCD
      {
         if (temp4)
         {
            temp3 |= (USHORT)Dual_LCD | Color_LCD | STN_LCD;
         }
         else
         {
            temp3 |= (USHORT)Single_LCD | Color_LCD | STN_LCD;
         }
      }
      else if (temp2 == 0xC0)           //TFT LCD
      {
         temp3 |= (USHORT)TFT_LCD;      //myf28
      }

      // Restore LCD Display Controls register and CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      if (temp1 == 1)   // this means panel connected is 800x600
      {
          // will support either 800x600 or 640x480
          // return panel type
          return (temp3 | panel8x6);
      }
      else if (temp1 == 2)
      {
          return (temp3 | panel10x7);
      }
      else if (temp1 == 0)
      {
          return (temp3 | panel);
      }
      else              //temp1 =4 :reserve
      {
          return (temp3);
      }
   }
//myf27   else              // the display is a crt
//myf27   {
//myf27      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
//myf27      return (temp3);
//myf27   }

} // CirrusFind754xDisplayType()

//---------------------------------------------------------------------------
USHORT
CirrusFind755xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL754x crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    CRTCAddrPort, CRTCDataPort - Index of CRTC registers for current mode.

Return Value:

    crt, panel, or panel8x6 LCD_type as defined in cirrus.h

--*/
{
    UCHAR originalCRTCIndex, originalLCDControl;
    USHORT temp1, temp2, temp3;

    // we need to check to see which display we are on...
    //
    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x80);
    temp3 = 0;
    if (VideoPortReadPortUchar(CRTCDataPort) & 0x02) temp3 = crt;

    if (!(VideoPortReadPortUchar(CRTCDataPort) & 0x01))         //myf27
        temp3 |= Jump_type;                                     //myf27
    else temp3 &= (~Jump_type);                 //myf27, myf28

//myf27    if (VideoPortReadPortUchar(CRTCDataPort) & 0x01)
    {
      // bit 0 set indicates that display is on LCD Panel
      // Check extended reg to see panel data format
      //
        VideoPortWritePortUchar (CRTCAddrPort, 0x83);
        originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);
        temp1 = originalLCDControl & 0x03;

      // check LCD support mode
      // CR83 bit 6:4 set indicate LCD type, TFT, DSTN color

      temp2 =  originalLCDControl & 0x70;
//    temp3 = crt;              //myf7, crus
      if (temp2 == 0)           //DSTN color LCD
      {
         temp3 |= Dual_LCD | Color_LCD | STN_LCD;
      }
      else if (temp2 == 0x20)           //TFT color LCD
         temp3 |= (USHORT)TFT_LCD;

      // Restore CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      if (temp1 == 1)   // this means panel connected is 800x600
      {
          // will support either 800x600 or 640x480
         return (temp3 | panel8x6);
      }
      else if (temp1 == 2)
      {
         return (temp3 | panel10x7);
      }
      else
      {
         return (temp3 | panel);
      }
   }
//myf27   else              // the display is a crt
//myf27   {
//myf27      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
//myf27      return crt;
//myf27   }
} // CirrusFind755xDisplayType()
//---------------------------------------------------------------------------
BOOLEAN
CirrusFind6340(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

   Determines if a CL6340 (Peacock) Color LCD controller is in the system
   along with a 6410 or 6420.

   Assumes that a 6410 or 6420 is already in the system.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    TRUE,   6340 detected
    FALSE,  6340 not detected

--*/
{
UCHAR originalGraphicsIndex;
UCHAR originalSRIndex;
UCHAR GRA1value;
UCHAR temp1,temp2;

   originalGraphicsIndex =
      VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT));

   originalSRIndex =
      VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT));

   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT, CL64xx_TRISTATE_CONTROL_REG);

   GRA1value = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT);

   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT, (UCHAR) (0x80 | GRA1value));

   VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), (USHORT) CL6340_ENABLE_READBACK_REGISTER +
      (CL6340_ENABLE_READBACK_ALLSEL_VALUE << 8));

   VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), CL6340_IDENTIFICATION_REGISTER);

   temp1 = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_DATA_PORT));

   temp2 = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_DATA_PORT));

   VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), (USHORT) CL6340_ENABLE_READBACK_REGISTER +
      (CL6340_ENABLE_READBACK_OFF_VALUE << 8));

// Graphics index still points to CL64xx_TRISTATE_CONTROL_REG
   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT, (UCHAR) (0x7f & GRA1value));

// now restore the Graphics and Sequencer indexes
      VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT),originalGraphicsIndex);

      VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT),originalSRIndex);

// check the values for value peacock data
   if ( ((temp1 & 0xf0) == 0x70 && (temp2 & 0xf0) == 0x80) ||
        ((temp1 & 0xf0) == 0x80 && (temp2 & 0xf0) == 0x70)  )
      return TRUE;
   else
      return FALSE;

} // CirrusFind6410DisplayType()

BOOLEAN
CirrusConfigurePCI(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PULONG NumPCIAccessRanges,
   PVIDEO_ACCESS_RANGE PCIAccessRanges
   )
{
    USHORT      VendorId = 0x1013;     // Vender Id for Cirrus Logic

    //
    // The device id order is important.  We want "most powerful"
    // first on the assumption that someone might want to plug
    // in a "more powerful" adapter into a system that has a "less
    // powerful" on-board device.
    //

    USHORT      DeviceId[] = {0x00BC,  // 5480
                              0x00B8,  // 5446
                              0x00AC,  // 5436
                              0x00E8,  // UM36
                              0x00A8,  // 5434
                              0x00A0,  // 5430/5440
                              0x1200,  // Nordic
                              0x1202,  // Viking
                              0x1204,  // Nordic Light
                              0x0038,  // Everest, myf14, crus
                              0x0040,  // Matterhorn
                              0x004C,  // Matterhorn, LV, myf17
                              0};

    ULONG       Slot;
    ULONG       ulRet;
    PUSHORT     pDeviceId;
    VP_STATUS   status;
    UCHAR       Command;
    PCI_COMMON_CONFIG   pciBuffer;     // jl02
    PPCI_COMMON_CONFIG  pciData;       // jl02

    VIDEO_ACCESS_RANGE AccessRanges[3];

    VideoPortZeroMemory(AccessRanges, 3 * sizeof(VIDEO_ACCESS_RANGE));

    pDeviceId = DeviceId;

    while (*pDeviceId != 0)
    {
        Slot = 0;

        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          0,
                                          NULL,
                                          3,
                                          AccessRanges,
                                          &VendorId,
                                          pDeviceId,
                                          &Slot);

        if (status == NO_ERROR)
        {
            VideoDebugPrint((2, "\t Found Cirrus chip in Slot[0x%02.2x]\n",
                             Slot));

            PCIAccessRanges[3].RangeStart  = AccessRanges[0].RangeStart;
            PCIAccessRanges[3].RangeLength = AccessRanges[0].RangeLength;

            VideoDebugPrint((1, "VideoMemoryAddress %x , length %x\n",
                                             PCIAccessRanges[3].RangeStart.LowPart,
                                             PCIAccessRanges[3].RangeLength));
            // sge01 begin
            //
            // checking CL5480 or CL5446BE
            //
            pciData = (PPCI_COMMON_CONFIG) &pciBuffer;
            VideoPortGetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                Slot,
                                (PVOID) pciData,
                                0,
                                PCI_COMMON_HDR_LENGTH);

#if (_WIN32_WINNT >= 0x0400)
            if ((pciData->DeviceID == 0x00B8 && pciData->RevisionID == 0x45)
                || (pciData->DeviceID == 0x00BC))
            {
                HwDeviceExtension->bMMAddress = TRUE;
                HwDeviceExtension->bSecondAperture = TRUE;
                PCIAccessRanges[4].RangeStart  = AccessRanges[1].RangeStart;
                PCIAccessRanges[4].RangeLength = AccessRanges[1].RangeLength;
                VideoDebugPrint((1, "MMIOMemoryAddress %x , length %x\n",
                                             PCIAccessRanges[2].RangeStart.LowPart,
                                             PCIAccessRanges[2].RangeLength));
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadRegisterUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadRegisterUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadRegisterUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWriteRegisterUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWriteRegisterUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWriteRegisterUlong;
            }
#else // else of NT 4.0
            if ((pciData->DeviceID == 0x00BC) ||
                ((pciData->DeviceID == 0x00B8) && (pciData->RevisionID == 0x45)))
            {
                HwDeviceExtension->bMMAddress = FALSE;
                HwDeviceExtension->bSecondAperture = TRUE;
                //
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadPortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadPortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadPortUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWritePortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWritePortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWritePortUlong;

            }
#endif // end of NT 4.0
            else
            {
                HwDeviceExtension->bMMAddress = FALSE;
                HwDeviceExtension->bSecondAperture = FALSE;
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadPortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadPortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadPortUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWritePortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWritePortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWritePortUlong;
            }
            VideoDebugPrint((1, "Read Write Functions are mapped"));
//sge01 end

            return TRUE;

        }
        else
        {
            //
            // We did not find the device.  Use the next device ID.
            //

            VideoDebugPrint((1, "Check for DeviceID = %x failed.\n", *pDeviceId));

            pDeviceId++;
        }
    }

    VideoDebugPrint((1, "Returning a false from CirrusConfigurePCI\n"));

    return FALSE;
}

VOID
WriteRegistryInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    PWSTR pwszChipType;
    ULONG cbString;
    PWSTR pnpId;

    //
    // Store Memory Size
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));




    //
    // Store chip Type
    //

    switch (hwDeviceExtension->ChipType)
    {
        case CL6410: pwszChipType =    L"Cirrus Logic 6410";
                     cbString = sizeof(L"Cirrus Logic 6410");
                     pnpId =           L"*PNP0904";
                     break;

        case CL6420: pwszChipType =    L"Cirrus Logic 6420";
                     cbString = sizeof(L"Cirrus Logic 6420");
                     pnpId =           L"*PNP0904";
                     break;

        case CL542x: if (hwDeviceExtension->ChipRevision >= 0x22 &&
                         hwDeviceExtension->ChipRevision <= 0x27)
                     {
                         static PWSTR RevTable[] = { L"Cirrus Logic 5420",
                                                     L"Cirrus Logic 5422",
                                                     L"Cirrus Logic 5426",  // yes, the 26
                                                     L"Cirrus Logic 5424",  // is before
                                                     L"Cirrus Logic 5428",  // the 24
                                                     L"Cirrus Logic 5429" };

                         pwszChipType =
                             RevTable[hwDeviceExtension->ChipRevision - 0x22];
                     }
                     else
                     {
                         pwszChipType =    L"Cirrus Logic 542x";
                     }

                     cbString = sizeof(L"Cirrus Logic 542x");
                     pnpId =           L"*PNP0904";
                     break;

        case CL543x: if (hwDeviceExtension->ChipRevision == CL5430_ID)
                     {
                         pwszChipType =    L"Cirrus Logic 5430/40";  // chu04
                         cbString = sizeof(L"Cirrus Logic 5430/40"); // chu04
                     }
                     else
                     {
                         pwszChipType =    L"Cirrus Logic 543x";
                         cbString = sizeof(L"Cirrus Logic 543x");
                     }

                     pnpId =           L"*PNP0905";
                     break;

        case CL5434_6:
                     pwszChipType =    L"Cirrus Logic 5434 (.6 micron)";
                     cbString = sizeof(L"Cirrus Logic 5434 (.6 micron)");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5434: pwszChipType =    L"Cirrus Logic 5434";
                     cbString = sizeof(L"Cirrus Logic 5434");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5436: pwszChipType =    L"Cirrus Logic 5436";
                     cbString = sizeof(L"Cirrus Logic 5436");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5446: pwszChipType =    L"Cirrus Logic 5446";
                     cbString = sizeof(L"Cirrus Logic 5446");
                     pnpId =           L"*PNP0905";
                     break;
#if 1   // jl02
        case CL5446BE:
                     pwszChipType =    L"Cirrus Logic 5446BE";
                     cbString = sizeof(L"Cirrus Logic 5446BE");
                     pnpId =           L"*PNP0905";
                     break;
#endif  // jl02

        case CL5480: pwszChipType =    L"Cirrus Logic 5480";
                     cbString = sizeof(L"Cirrus Logic 5480");
                     pnpId =           L"*PNP0905";
                     break;

//myf32 begin
        case CL7541: pwszChipType =    L"Cirrus Logic 7541";
                     cbString = sizeof(L"Cirrus Logic 7541");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7542: pwszChipType =    L"Cirrus Logic 7542";
                     cbString = sizeof(L"Cirrus Logic 7542");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7543: pwszChipType =    L"Cirrus Logic 7543";
                     cbString = sizeof(L"Cirrus Logic 7543");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7548: pwszChipType =    L"Cirrus Logic 7548";
                     cbString = sizeof(L"Cirrus Logic 7548");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7555: pwszChipType =    L"Cirrus Logic 7555";
                     cbString = sizeof(L"Cirrus Logic 7555");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7556: pwszChipType =    L"Cirrus Logic 7556";
                     cbString = sizeof(L"Cirrus Logic 7556");
                     pnpId =           L"*PNP0914";
                     break;
//myf32


        case CL756x: pwszChipType =     L"Cirrus Logic 756x";
                     cbString = sizeof(L"Cirrus Logic 756x");
                     pnpId =           L"*PNP0914";
                     break;

// crus
        case CL6245: pwszChipType =     L"Cirrus Logic 6245";
                     cbString = sizeof(L"Cirrus Logic 6245");
                     pnpId =           L"*PNP0904";
                     break;

        default:
                     //
                     // we should never get here
                     //

                     ASSERT(FALSE);

                     pwszChipType = NULL;
                     cbString = 0;
                     pnpId = NULL;
    }

    if (pnpId)
    {
        memcpy(hwDeviceExtension->LegacyPnPId, pnpId, 8*sizeof(WCHAR));
    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChipType,
                                   cbString);

    //
    // Store Adapter String
    //
    // the only interesting adapter string is
    // for the speedstar pro
    //

#pragma prefast(suppress: 209, "Byte count is correct here (PREfast bug 611168)")
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   L"Integrated RAMDAC",
                                   sizeof(L"Integrated RAMDAC") );

    if( hwDeviceExtension->BoardType == SPEEDSTARPRO )
    {
#pragma prefast(suppress: 209, "Byte count is correct here (PREfast bug 611168)")
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                       L"SpeedStar PRO",
                                       sizeof(L"SpeedStar PRO"));
    }
    else
    {
#pragma prefast(suppress: 209, "Byte count is correct here (PREfast bug 611168)")
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                       L"Cirrus Logic Compatible",
                                       sizeof (L"Cirrus Logic Compatible") );
    }


}

VOID
IOWaitDisplEnableThenWrite(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG portIO,
    UCHAR value
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = hwDeviceExtension;
    USHORT FCReg ;                     // feature control register
    UCHAR PSReg  ;                     // 3?4.25
    UCHAR DeviceID ;                   // 3?4.27
    UCHAR bIsColor ;                   // 1 : Color, 0 : Mono
    UCHAR tempB, tempB1 ;
    ULONG port ;
    PUCHAR CRTCAddrPort, CRTCDataPort;

    // Figure out if color/mono switchable registers are at 3BX or 3DX.

    port = PtrToUlong(hwDeviceExtension->IOAddress) + portIO ;
    tempB = VideoPortReadPortUchar (hwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) ;
    tempB &= 0x01 ;

    if (tempB)
    {
        bIsColor = TRUE ;
        FCReg = FEAT_CTRL_WRITE_PORT_COLOR ;
        CRTCAddrPort = hwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_COLOR;
    }
    else
    {
        bIsColor = FALSE ;
        FCReg = FEAT_CTRL_WRITE_PORT_MONO ;
        CRTCAddrPort = hwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_MONO;
    }

    CRTCDataPort = CRTCAddrPort + 1;

    tempB = VideoPortReadPortUchar(CRTCAddrPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x27);
    DeviceID = VideoPortReadPortUchar(CRTCDataPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x25);
    PSReg = VideoPortReadPortUchar(CRTCDataPort);

    VideoPortWritePortUchar (CRTCAddrPort, tempB);

    if ((DeviceID == 0xAC) &&                                     // 5436
        ((PSReg == 0x45) || (PSReg == 0x47)))                     // BG or BE
    {

        hwDeviceExtension->DEPort = portIO;
        hwDeviceExtension->DEValue = value;

        while (!(0x1 & VideoPortReadPortUchar(hwDeviceExtension->IOAddress + FCReg)));
        while ( (0x1 & VideoPortReadPortUchar(hwDeviceExtension->IOAddress + FCReg)));

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE) IOCallback,
                                      hwDeviceExtension);
    }
    else
    {
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress + portIO, value);
    }

} // IOWaitDisplEnableThenWrite


//sge08
VOID
CirrusUpdate440FX(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Check and Update 440FX PCI[53] bit 1 if necessary.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    The routine has no return.

--*/

{
    USHORT  chipRevisionId ;
    UCHAR   chipId ;
    PUCHAR  pBuffer;
    ULONG   Slot;

    USHORT  VendorId = 0x8086;                         // Vender Id for Intel
    USHORT  DeviceId = 0x1237;                         // VS440FX

    VP_STATUS   status;
    PCI_COMMON_CONFIG   pciBuffer;
    PPCI_COMMON_CONFIG  pciData;

    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu06
    chipRevisionId = GetCirrusChipRevisionId(HwDeviceExtension) ;    // chu06

    if ((chipId == 0xB8) &&                                          // 5446
        (chipRevisionId == 0x0023))                                  // AC
    {
        //
        // We got it's 5446AC, then to find 440FX
        //
        pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

        for (Slot = 0; Slot < 32; Slot++)
        {
            // chu05
            // For 5436 checked build NT, system always crashes when you
            // access the whole 256-byte PCI configuration registers.
            // Since we only care index 53h bit 1, we access 4 bytes, rather
            // than whole 256 bytes.

            VideoPortGetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                Slot,
                                (PVOID) pciData,
                                0,
                                sizeof(PCI_COMMON_HDR_LENGTH));      // chu05

            if ((pciData->VendorID == VendorId) &&
                (pciData->DeviceID == DeviceId))
            {
                //
                // Access a double word, which contains index 53h.
                //

                VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pciData,
                                    0x53,
                                    0x04);                           // chu05

                // We borrow the space which is the first 4 bytes of PCI
                // configuration register. Please be aware that, at this
                // moment, the content is index 53h, rather than
                // vendor ID.

                pciBuffer.DeviceSpecific[19] =
                    (UCHAR) pciData->VendorID ;                      // chu05

                //
                // Found the Intel VS440FX motherboard.
                //
                //
                // Clear bit 1 of Register 0x53
                //

                pciBuffer.DeviceSpecific[19] &= 0xFD;

                //
                // Write Register 0x53 back.
                //

                pBuffer = (PUCHAR)&pciBuffer;
                pBuffer += 0x53;
                VideoPortSetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pBuffer,
                                    0x53,
                                    1);
                //
                // Read back only 4 bytes to verify it.
                //

                VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pciData,
                                    0x53,
                                    0x04);                           // chu05

                break;  // we have already modify it
            }
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\cirrus.h ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation
Copyright (c) 1996-1997 Cirrus Logic, Inc.,

Module Name:

    C    I    R    R    U    S  .  H

Abstract:

    This module contains the definitions for the code that implements the
    Cirrus Logic VGA 6410/6420/542x device driver.

Environment:

    Kernel mode

Revision History:
*  chu01   08-26-96 : Distinguish CL-5480 and CL-5436/46 because the former
*                     has new fratures such as XY-clipping, XY-position and
*                     BLT command list that the others do not have.
*  sge01  10-14-96 : Add PC97 Compliant support.
*
*  sge02  10-24-96 : Add second aperture flag.
*
*  sge03  10-29-96 : Merge port access and register access for VGA relocatable and MMIO registers.
*  chu02  12-16-96 : Enable color correct.
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : added CAPS_IS_7555 flag for direct draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* myf20 :11-12-96 : Fixed DSTN panel initial reserved 128K memoru
* myf21 :11-15-96 : fixed #7495 during change resolution, screen appear garbage
*                   image, because not clear video memory.
* myf22 :11-19-96 : Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23 :11-21-96 : Added fixed NT 3.51 S/W cursor panning problem
* myf24 :11-22-96 : Added fixed NT 4.0 Japanese dos full screen problem
* myf25 :12-03-96 : Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                   fixed pre-install microsoft requested
* myf26 :12-11-96 : Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27 :01-09-96 : Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                   windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                   Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                   screen when boot up XGA panel.
* sge04  01-23-96 : Add CL5446_ID and CL5480_ID.
* myf33 :03-21-97 : Support TV ON/OFF
* chu03  03-26-97 : Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
*
--*/



#define INT10_MODE_SET

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// Banking ifdefs to enable banking
// the banking type MUST match the type in clhard.asm
//

#define ONE_64K_BANK             0
#define TWO_32K_BANKS            1
#define MULTIPLE_REFRESH_TABLES  0

//crus
//myf17  #define PANNING_SCROLL          //myf1

//
// Treat CL-GD5434_6 (rev 0xHH) as CL-GD5434 if requested.
//

#define CL5434_6_SPECIAL_REQUEST 0

//---------------------------------------------------------------------------
//
// only one banking variable must be defined
//
#if TWO_32K_BANKS
#if ONE_64K_BANK
#error !!ERROR: two types of banking defined!
#endif
#elif ONE_64K_BANK
#else
#error !!ERROR: banking type must be defined!
#endif

//
// Enable P6 Cache support
//

#define P6CACHE 1

//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

#define MEM_LINEAR      0x0
#define MEM_LINEAR_SIZE 0x0

// #ifdef _ALPHA_
//
//     #define PHY_AD_20_23 0x060       // Value for SR7 to map video memory
//     #define PHY_VGA      0x0600000   // put it at 6 megabytes for Alpha (for now)
//     #define PHY_VGA_SIZE 0x0100000   // allocate a megabyte of space there
//
// #endif
//

//
// For memory mapped IO
//

#define MEMORY_MAPPED_IO_OFFSET (0xB8000 - 0xA0000)
#define RELOCATABLE_MEMORY_MAPPED_IO_OFFSET 0x100

//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//

#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode

#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

                                            // toggle in color mode
//
// VGA indexed register indexes.
//

// CL-GD542x specific registers:
//
#define IND_CL_EXTS_ENB         0x06    // index in Sequencer to enable exts
#define IND_NORD_SCRATCH_PAD    0x09    // index in Seq of Nordic scratch pad
#define IND_CL_SCRATCH_PAD      0x0A    // index in Seq of 542x scratch pad
#define IND_ALP_SCRATCH_PAD     0x15    // index in Seq of Alpine scratch pad
#define IND_CL_REV_REG          0x25    // index in CRTC of ID Register
#define IND_CL_ID_REG           0x27    // index in CRTC of ID Register
//
#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_CR2C                0x2C    // Nordic LCD Interface Register
#define IND_CR2D                0x2D    // Nordic LCD Display Control
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_PERF_TUNING         0x16    // index of performance tuning in Seq
#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Value to write to Extensions Control register values extensions.
//

#define CL64xx_EXTENSION_ENABLE_INDEX     0x0A     // GR0A to be exact!
#define CL64xx_EXTENSION_ENABLE_VALUE     0xEC
#define CL64xx_EXTENSION_DISABLE_VALUE    0xCE
#define CL64xx_TRISTATE_CONTROL_REG       0xA1

#define CL6340_ENABLE_READBACK_REGISTER   0xE0
#define CL6340_ENABLE_READBACK_ALLSEL_VALUE 0xF0
#define CL6340_ENABLE_READBACK_OFF_VALUE  0x00
#define CL6340_IDENTIFICATION_REGISTER    0xE9
//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define INDEX_ENABLE_AUTO_START 0x31

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00


//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F


//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Offset;         // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Define type of cirrus boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPRO = 1,
    SIEMENS_ONBOARD_CIRRUS,
    NEC_ONBOARD_CIRRUS,
    OTHER
} BOARD_TYPE;


//
// The chip ID is returned to the display driver in the
// DriverSpecificAttributeFlags field during processing of
// the IOCTL_VIDEO_QUERY_CURRENT_MODE.
//

#define  CL6410       0x0001
#define  CL6420       0x0002
#define  CL542x       0x0004
#define  CL543x       0x0008
#define  CL5434       0x0010
#define  CL5434_6     0x0020
#define  CL5446BE     0x0040

#define  CL5436       0x0100
#define  CL5446       0x0200
#define  CL54UM36     0x0400
//crus
#define  CL5480       0x0800

//myf32 begin
//#define  CL754x       0x1000
//#define  CL755x       0x2000
#define  CL7541       0x1000
#define  CL7542       0x2000
#define  CL7543       0x4000
#define  CL7548       0x8000
#define  CL754x       (CL7541 | CL7542 | CL7543 | CL7548)
#define  CL7555       0x10000
#define  CL7556       0x20000
#define  CL755x       (CL7555 | CL7556)
#define  CL756x       0x40000
// crus
#define  CL6245       0x80000
//myf32 end
//
// Actual Revision IDs for certain cirrus chips
//

#define  CL5429_ID    0x27
#define  CL5428_ID    0x26
#define  CL5430_ID    0x28
#define  CL5434_ID    0x2A
#define  CL5436_ID    0x2B
//sge04
#define  CL5446_ID    0x2E
#define  CL5480_ID    0x2F
//myf32 begin
#define  CL7542_ID    0x2C
#define  CL7541_ID    0x34
#define  CL7543_ID    0x30
#define  CL7548_ID    0x38
#define  CL7555_ID    0x40
#define  CL7556_ID    0x4C

//#define  CHIP754X     (CL7541_ID | CL7542_ID | CL7543_ID | CL7548_ID)
//#define  CHIP755X     (CL7555_ID | CL7556_ID)
//myf32 end

//
// Driver Specific Attribute Flags
//

#define CAPS_NO_HOST_XFER       0x00000002   // Do not use host xfers to
                                             //   the blt engine.
#define CAPS_SW_POINTER         0x00000004   // Use software pointer.
#define CAPS_TRUE_COLOR         0x00000008   // Set upper color registers.
#define CAPS_MM_IO              0x00000010   // Use memory mapped IO.
#define CAPS_BLT_SUPPORT        0x00000020   // BLTs are supported
#define CAPS_IS_542x            0x00000040   // This is a 542x
#define CAPS_AUTOSTART          0x00000080   // Autostart feature support.
#define CAPS_CURSOR_VERT_EXP    0x00000100   // Flag set if 8x6 panel,
#define CAPS_DSTN_PANEL         0x00000200   // DSTN panel in use, ms0809.
#define CAPS_VIDEO              0x00000400   // Video support.
#define CAPS_SECOND_APERTURE    0x00000800   // Second aperture support.
#define CAPS_COMMAND_LIST       0x00001000   // Command List support.
#define CAPS_GAMMA_CORRECT      0x00002000   // Color correction
#define CAPS_VGA_PANEL          0x00004000   // use 6x4 VGA PANEL.
#define CAPS_SVGA_PANEL         0x00008000   // use 8x6 SVGA PANEL.
#define CAPS_XGA_PANEL          0x00010000   // use 10x7 XGA PANEL.
#define CAPS_PANNING            0x00020000   // Panning scrolling supported.
#define CAPS_TV_ON              0x00040000   // TV turn on supported., myf33
#define CAPS_TRANSPARENCY       0x00080000   // Transparency is supported
#define CAPS_ENGINEMANAGED      0x00100000   // Engine managed surface
//myf16, end
//crus end


// bitfields for the DisplayType
#define  crt      0x0001
#define  panel    0x0002

#define  panel8x6  0x0004
#define  panel10x7 0x0008

#define  TFT_LCD   0x0100
#define  STN_LCD   0x0200
#define  Mono_LCD   0x0400
#define  Color_LCD   0x0800
#define  Single_LCD   0x1000
#define  Dual_LCD   0x2000
#define  Jump_type   0x8000    //myf27

//crus
#define DefaultMode 0x9         //myf19: 11-07-96 if panel can't support mode,
                                //      use 640x480x256c(0x5F) replace.
//
// Indexes into array of mode table pointers
//

#define pCL6410_crt   0
#define pCL6410_panel 1
#define pCL6420_crt   2
#define pCL6420_panel 3
#define pCL542x       4
#define pCL543x       5
#define pStretchScan  6
#define pNEC_CL543x   7
#define NUM_CHIPTYPES 8

typedef struct {
    USHORT BiosModeCL6410;       // bios modes are different across the
    USHORT BiosModeCL6420;       // products. that's why we need multiple
    USHORT BiosModeCL542x;       // values.
} CLMODE, *PCLMODE;

//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType; // color or monochrome, text or graphics, via
                    //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;    // # of video memory planes
    USHORT  bitsPerPlane; // # of bits of color in each plane
    SHORT   col;    // # of text columns across screen with default font
    SHORT   row;    // # of text rows down screen with default font
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
    USHORT  wbytes; // # of bytes from start of one scan line to start of next
    ULONG   sbytes; // total size of addressable display memory in bytes
    ULONG   Frequency;         // Vertical Frequency
    ULONG   Interlaced;        // Determines if the mode is interlaced or not
    ULONG   MonitorType;       // Sets the desired vertical freq in an int10
    ULONG   MonTypeAX;         // Sets the desired horizontal freq in an int10
    ULONG   MonTypeBX;
    ULONG   MonTypeCX;
    BOOLEAN HWCursorEnable;    // Flag to disable cursor if necessary
    BANK_TYPE banktype;        // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP   MemMap; // index from VIDEO_MEMORY_MAP of memory
                               //  mapping used by this mode
    ULONG      ChipType;       // flags that say which chipset runs this mode
                               //myf32 change USHORT to ULONG
    USHORT     DisplayType;    // display type this mode runs on(crt or panel)
    BOOLEAN    ValidMode;      // TRUE if mode valid, FALSE if not
    BOOLEAN    LinearSupport;  // TRUE if this mode can have its memory
                               //  mapped in linearly.

    CLMODE     BiosModes;

//
// the mode will be TRUE if there is enough video memory to support the
// mode, and the display type(it could be a panel), will support the mode.
// PANELS only support 640x480 for now.
//
    PUSHORT CmdStrings[NUM_CHIPTYPES];   // pointer to array of register-setting commands to
                                         //  set up mode
} VIDEOMODE, *PVIDEOMODE;

//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0

//crus, begin
//myf1, begin
#ifdef  PANNING_SCROLL
typedef struct {
    USHORT  Hres;
    USHORT  Vres;
    USHORT  BitsPerPlane;
    USHORT  ModesVgaStart;
    USHORT  Mode;
} RESTABLE, *PRESTABLE;

typedef struct {
    USHORT  hres;
    USHORT  vres;
    USHORT  wbytes;
    USHORT  bpp;
     SHORT  flag;
} PANNMODE;

USHORT ViewPoint_Mode = 0x5F;
#endif


UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11
//myf1, end
//crus, end


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA             100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define CL64xx_GRAPH_EXT_START          0x0b  // does not include ext. enable
#define CL64xx_GRAPH_EXT_END            0xFF

#define CL542x_GRAPH_EXT_START          0x09
#define CL542x_GRAPH_EXT_END            0x39
#define CL542x_SEQUENCER_EXT_START      0x07  // does not include ext. enable
#define CL542x_SEQUENCER_EXT_END        0x1F
#define CL542x_CRTC_EXT_START           0x19
#define CL542x_CRTC_EXT_END             0x1B

//
// Number of extended regs for both chip types
//

#define CL64xx_NUM_GRAPH_EXT_PORTS     (CL64xx_GRAPH_EXT_END - CL64xx_GRAPH_EXT_START + 1)

#define CL542x_NUM_GRAPH_EXT_PORTS     (CL542x_GRAPH_EXT_END - CL542x_GRAPH_EXT_START + 1)
#define CL542x_NUM_SEQUENCER_EXT_PORTS (CL542x_SEQUENCER_EXT_END - CL542x_SEQUENCER_EXT_START + 1)
#define CL542x_NUM_CRTC_EXT_PORTS      (CL542x_CRTC_EXT_END - CL542x_CRTC_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    ((CL64xx_NUM_GRAPH_EXT_PORTS >   \
                                     CL542x_NUM_GRAPH_EXT_PORTS) ?   \
                                     CL64xx_NUM_GRAPH_EXT_PORTS :    \
                                     CL542x_NUM_GRAPH_EXT_PORTS)
#define EXT_NUM_SEQUENCER_PORTS     CL542x_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          CL542x_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

//
// Merge port and register access for VGA relocatable and MMIO registers
//
// sge03
typedef VIDEOPORT_API UCHAR     (*FnVideoPortReadPortUchar)(PUCHAR Port);
typedef VIDEOPORT_API USHORT    (*FnVideoPortReadPortUshort)(PUSHORT Port);
typedef VIDEOPORT_API ULONG     (*FnVideoPortReadPortUlong)(PULONG Port);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUchar)(PUCHAR Port, UCHAR Value);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUshort)(PUSHORT Port, USHORT Value);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUlong)(PULONG Port, ULONG Value);

typedef struct  _PORT_READ_WRITE_FUNTION_TABLE
{
    FnVideoPortReadPortUchar     pfnVideoPortReadPortUchar;
    FnVideoPortReadPortUshort    pfnVideoPortReadPortUshort;
    FnVideoPortReadPortUlong     pfnVideoPortReadPortUlong;
    FnVideoPortWritePortUchar    pfnVideoPortWritePortUchar;
    FnVideoPortWritePortUshort   pfnVideoPortWritePortUshort;
    FnVideoPortWritePortUlong    pfnVideoPortWritePortUlong;
} PORT_READ_WRITE_FUNTION_TABLE;



//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    PHYSICAL_ADDRESS PhysicalFrameOffset;     // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    ULONG PhysicalFrameLength;                // length of display memory for
                                              // the current mode.

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PUCHAR  VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   NumAvailableModes;    // number of available modes this session
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    PVIDEOMODE  CurrentMode;      // pointer to VIDEOMODE structure for
                                  // current mode

    USHORT  FontPelColumns;          // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    USHORT  cursor_vert_exp_flag;

    VIDEO_CURSOR_POSITION CursorPosition;  // current cursor position


    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

// add HW cursor data here
    BOOLEAN VideoPointerEnabled;  // Whether HW Cursor is supported

    ULONG  ChipType;              // CL6410, CL6420, CL542x, or CL543x
                               //myf32 change USHORT to ULONG
    USHORT ChipRevision;                  // chip revision value
    INTERFACE_TYPE BusType;               // isa, pci, etc.
    USHORT DisplayType;                   // crt, panel or panel8x6
    USHORT BoardType;                     // Diamond, etc ...
    WCHAR LegacyPnPId[8];                 // legacy PnP ID
    ULONG AdapterMemorySize;              // amount of installed video ram
    BOOLEAN LinearMode;                   // TRUE if memory is mapped linear
    BOOLEAN BiosGT130;                    // Do we have a 1.30 or higher bios
    BOOLEAN BIOSPresent;                  // Indicates whether a bios is present
    BOOLEAN AutoFeature;                  // Autostart on 54x6

// crus
    BOOLEAN BitBLTEnhance;                // BitBLT enhancement includes
                                          //  XY-position, XY-clipping and
                                          //  command list in off-screen memory
                                          //  For CL-GD5480, it is TRUE,
                                          //  otherwise, it is FALSE.

    //
    // The following two values are used to pass information to the
    // IO Callback called by IOWaitDisplEnableThenWrite.
    //

    ULONG DEPort;                         // stores the port address to write to
    UCHAR DEValue;                        // stores the value to write

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM
//  sge01 PC97 Compliant
    ULONG ulBIOSVersionNumber;                 // BIOS version number.

    BOOLEAN bMMAddress;                        // VGA register MMIO

    BOOLEAN bSecondAperture;                   // TRUE if chips have second apterture
                                               // else FALSE, sge02
//crus, begin
//myf12, for hoy-key support
    SHORT       bBlockSwitch;   //display switch block flag     //myf12
    SHORT       bDisplaytype;   //display type, 0:LCD, 1:CRT, 2:SIM  //myf12
    ULONG       bCurrentMode;   //Current Mode
//crus end

    PORT_READ_WRITE_FUNTION_TABLE gPortRWfn;

    ULONG       PMCapability;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

#ifdef _X86_

//
// Bank switch code start and end labels, defined in CLHARD.ASM
//
// three versions for Cirrus Logic products
//

extern UCHAR CL64xxBankSwitchStart;
extern UCHAR CL64xxBankSwitchEnd;
extern UCHAR CL64xxPlanarHCBankSwitchStart;
extern UCHAR CL64xxPlanarHCBankSwitchEnd;
extern UCHAR CL64xxEnablePlanarHCStart;
extern UCHAR CL64xxEnablePlanarHCEnd;
extern UCHAR CL64xxDisablePlanarHCStart;
extern UCHAR CL64xxDisablePlanarHCEnd;

extern UCHAR CL542xBankSwitchStart;
extern UCHAR CL542xBankSwitchEnd;
extern UCHAR CL542xPlanarHCBankSwitchStart;
extern UCHAR CL542xPlanarHCBankSwitchEnd;
extern UCHAR CL542xEnablePlanarHCStart;
extern UCHAR CL542xEnablePlanarHCEnd;
extern UCHAR CL542xDisablePlanarHCStart;
extern UCHAR CL542xDisablePlanarHCEnd;

extern UCHAR CL543xBankSwitchStart;
extern UCHAR CL543xBankSwitchEnd;
extern UCHAR CL543xPlanarHCBankSwitchStart;
extern UCHAR CL543xPlanarHCBankSwitchEnd;

#endif

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

//
// Mode Information
//

extern MEMORYMAPS MemoryMaps[];
extern ULONG NumVideoModes;
extern VIDEOMODE ModesVGA[];

//crus, begin
//myf1, begin
#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

#endif

extern SHORT    Panning_flag;
//myf1, end
//crus, end

#define NUM_VGA_ACCESS_RANGES  5
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];

//
// sr754x (NORDIC) prototypes
//

VP_STATUS
NordicSaveRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT NordicSaveArea
    );

VP_STATUS
NordicRestoreRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT NordicSaveArea
    );

#define VideoPortReadPortUchar(Port)            HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar(Port)
#define VideoPortReadPortUshort(Port)           HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort(Port)
#define VideoPortReadPortUlong(Port)            HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong(Port)
#define VideoPortWritePortUchar(Port, Value)    HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar(Port, Value)
#define VideoPortWritePortUshort(Port, Value)   HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort(Port, Value)
#define VideoPortWritePortUlong(Port, Value)    HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong(Port, Value)

typedef struct _PGAMMA_VALUE                                         // chu02
{
    UCHAR value[4] ;

} GAMMA_VALUE, *PGAMMA_VALUE, *PCONTRAST_VALUE ;

ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
);

typedef struct _POEMMODE_EXCLUDE                                     // chu03
{
    UCHAR    mode          ;
    UCHAR    refresh       ;
    BOOLEAN  NeverAccessed ;

} OEMMODE_EXCLUDE, *PMODE_EXCLUDE ;


//
// New NT 5.0 Functions
//

ULONG
CirrusGetChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

VP_STATUS
CirrusGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
CirrusSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\callback.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C    A    L    L    B    A    C    K  .  C

Abstract:

    This routine contains various callback routines. e.g.,

    -  Gamma correction information from the following NT 4.0 registry.
         Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
         Keys                  : "G Gamma", and "G Contrast"

    -  Callback routines for the DDC and Non-DDC monitors.

    -  IBM specific callback routine to get rid of 1024x768x16bpp 85Hz.
         Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
         Keys                  : "OemModeOff"

Environment:

    Kernel mode only

Notes:
*
*    chu01  12-16-96 : Color correction start coding.
*    chu02  03-26-97 : Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>  // I added
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

extern UCHAR EDIDBuffer[]   ;

//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    ) ;

VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS
CirrusGetDeviceDataCallback(
   PVOID HwDeviceExtension,
   PVOID Context,
   VIDEO_DEVICE_DATA_TYPE DeviceDataType,
   PVOID Identifier,
   ULONG IdentifierLength,
   PVOID ConfigurationData,
   ULONG ConfigurationDataLength,
   PVOID ComponentInformation,
   ULONG ComponentInformationLength
   );

// chu02
VP_STATUS
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetGammaKeyInfoFromReg)
#pragma alloc_text(PAGE,GetContrastKeyInfoFromReg)
#pragma alloc_text(PAGE,GetGammaCorrectInfoCallBack)
#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)
#pragma alloc_text(PAGE,CirrusDDC2BRegistryCallback)
#pragma alloc_text(PAGE,CirrusNonDDCRegistryCallback)
#pragma alloc_text(PAGE,CirrusGetDeviceDataCallback)
#pragma alloc_text(PAGE,GetOemModeOffInfoCallBack)                   // chu02
#endif

UCHAR GammaInfo[4] ;
UCHAR ModesExclude[4] ;                                              // chu02

OEMMODE_EXCLUDE ModeExclude = { 0, 0, 1 } ;                          // chu02


//---------------------------------------------------------------------------
//
// Function: Get Gamma factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetGammaFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PGAMMA_VALUE)) )
        return ERROR_INSUFFICIENT_BUFFER;

    status = GetGammaKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x7f ; 
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Gamma value = %lx\n", *value)) ;

    return status ;

} // VgaGetGammaFactor


//---------------------------------------------------------------------------
//
// Function: Get Contrast factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetContrastFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PCONTRAST_VALUE)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    status = GetContrastKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x80 ;
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Contrast value = %lx\n", *value)) ;
    return status ;


} // VgaGetContrastFactor


//---------------------------------------------------------------------------
//
// Function: Get Gamma Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    VP_STATUS status ;

    VideoDebugPrint((2, "GetGammaKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Gamma",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Gamma key info from registry\n"));
    }

    return status ;


} // GetGammaKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Contrast Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VP_STATUS status ;
    VideoDebugPrint((2, "GetContrastKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Contrast",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
    }
    return status ;

} // GetContrastKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Gamma coorrection information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetGammaCorrectInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (GammaInfo, ValueData, ValueLength) ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetGammaCorrectInfoCallBack


//---------------------------------------------------------------------------
//
// Function:
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    PULONG  pManuID = (PULONG)&EDIDBuffer[8];

    if (ValueLength &&
        ((*((PULONG)ValueData)) == *pManuID)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // CirrusDDC2BRegistryCallback


//---------------------------------------------------------------------------
//
// Function:
//     CirrusNonDDCRegistryCallback
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    if(ValueLength && 
       ValueLength == 128 )
    {
        VideoPortMoveMemory(EDIDBuffer, ValueData, ValueLength);
        return NO_ERROR;
    }
    else
        return ERROR_INVALID_PARAMETER;

} // CirrusNonDDCRegistryCallback


//---------------------------------------------------------------------------
//
// Function:
//     Perform an IO operation during display enable.
//
// Input:
//     HwDeviceExtension - Pointer to the miniport driver's device extension.         
//
// Output: 
//     The routine always returns TRUE. 
//
//---------------------------------------------------------------------------
BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    ULONG InputStatusReg;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    //

    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                MISC_OUTPUT_REG_READ_PORT) & 0x01)
        InputStatusReg = INPUT_STATUS_1_COLOR;
    else
        InputStatusReg = INPUT_STATUS_1_MONO;

    //
    // Guarantee that the display is in display mode
    //

    while (0x1 & VideoPortReadPortUchar(HwDeviceExtension->IOAddress
                                        + InputStatusReg));

    //
    // Perform the IO operation
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                             HwDeviceExtension->DEPort,
                             HwDeviceExtension->DEValue);

    return TRUE;

} // IOCallback


// chu02
//---------------------------------------------------------------------------
//
// Function: Get rid of one mode, specific to IBM only
//             - 1024x768x16bpp, 85Hz ( mode 0x74 )
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetOemModeOffInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (ModesExclude, ValueData, ValueLength) ;
        ModeExclude.refresh = (UCHAR)ModesExclude[0] ;
        ModeExclude.mode    = (UCHAR)ModesExclude[1] ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetOemModeOffInfoCallBack


//---------------------------------------------------------------------------
//
// Function:
//     Callback routine for the VideoPortGetDeviceData function.
//
// Input:
//    HwDeviceExtension - Pointer to the miniport drivers device extension.
//    Context - Context value passed to the VideoPortGetDeviceData function.
//    DeviceDataType - The type of data that was requested in
//        VideoPortGetDeviceData.
//    Identifier - Pointer to a string that contains the name of the device,
//        as setup by the ROM or ntdetect.
//    IdentifierLength - Length of the Identifier string.
//    ConfigurationData - Pointer to the configuration data for the device or
//        BUS.
//    ConfigurationDataLength - Length of the data in the configurationData
//        field.
//    ComponentInformation - Undefined.
//    ComponentInformationLength - Undefined.
//
// Output: 
//    Returns NO_ERROR if the function completed properly.
//    Returns ERROR_DEV_NOT_EXIST if we did not find the device.
//    Returns ERROR_INVALID_PARAMETER otherwise.
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusGetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )

/*++

Routine Description:

    

Arguments:

    HwDeviceExtension - Pointer to the miniport drivers device extension.

    Context - Context value passed to the VideoPortGetDeviceData function.

    DeviceDataType - The type of data that was requested in
        VideoPortGetDeviceData.

    Identifier - Pointer to a string that contains the name of the device,
        as setup by the ROM or ntdetect.

    IdentifierLength - Length of the Identifier string.

    ConfigurationData - Pointer to the configuration data for the device or
        BUS.

    ConfigurationDataLength - Length of the data in the configurationData
        field.

    ComponentInformation - Undefined.

    ComponentInformationLength - Undefined.

Return Value:

    Returns NO_ERROR if the function completed properly.
    Returns ERROR_DEV_NOT_EXIST if we did not find the device.
    Returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    PWCHAR identifier = Identifier;
    PVIDEO_PORT_CONFIG_INFO ConfigInfo = (PVIDEO_PORT_CONFIG_INFO) Context;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    switch (DeviceDataType) {

        case VpMachineData:

            //
            // The caller assumes no-error mean that this machine was found, and
            // then memory mapped IO will be disabled.
            //
            // All other machine types must return an error.
            //

            if (VideoPortCompareMemory(L"TRICORDES",
                                       Identifier,
                                       sizeof(L"TRICORDES")) ==
                                       sizeof(L"TRICORDES"))
            {
                return NO_ERROR;
            }

            break;

        default:

            VideoDebugPrint((2, "Cirrus: callback has bad device type\n"));
    }

    return ERROR_INVALID_PARAMETER;

} // CirrusGetDeviceDataCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clddc2b.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clddc2b.c

Abstract:
    
    This module checks for a DDC monitor, and returns the 
    established Timings value from the EDID if found.

Environment:

    Kernel mode only

Notes:

Revision History:

  * plc3  10-23-95  VESA DDC2B support.
  *
  * sge01 09-25-96  Non DDC Moniotr table support
  *
  * sge02 10-14-96  Detailed timing calculation in EDID
  *
  * sge03 12-05-96  Only check active pixel clock in detailed timing.
  *
--*/
//---------------------------------------------------------------------------
                                                       
#include <dderror.h>
#include <devioctl.h>                           
#include <miniport.h>
                                                        
#include <ntddvdeo.h>                        
#include <video.h>
#include "cirrus.h"

#define ERROR              0

#define OFF                0
#define ON                 1

#define SDA_BIT            2
#define SCL_BIT            1
#define SCL_BIT_ON         1
#define SCL_BIT_OFF        0

#define DELAY_COUNT            255

UCHAR Err ;

VOID ReadVESATiming(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   

VOID EnableDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN IsDDC2(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID DisableDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID StartDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID StopDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID ProcessDDC2(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );     
                                               
BOOLEAN ReadSDA(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN ReadSCL(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN ReadBit(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN ReadByte(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
                                                    
VOID SetSCL(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR status
    );
                                                   
VOID SetData(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN SetClock(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
                                                    
VOID WaitVerticalRetrace(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR count
    );                                                   

VOID WaitDelay(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID ClearData(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN SendByte(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    );                                                   

BOOLEAN SendDDCCommand(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

ULONG
CalculateMaxinumTiming(
    );

VOID ProcessNonDDC(
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    );

VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

#if defined(ALLOC_PRAGMA)               
#pragma alloc_text (PAGE,ReadVESATiming)
#pragma alloc_text (PAGE,EnableDDC)
#pragma alloc_text (PAGE,IsDDC2)
#pragma alloc_text (PAGE,DisableDDC)
#pragma alloc_text (PAGE,StartDDC)
#pragma alloc_text (PAGE,StopDDC)
#pragma alloc_text (PAGE,ProcessDDC2)
#pragma alloc_text (PAGE,ReadSDA)
#pragma alloc_text (PAGE,ReadSCL)
#pragma alloc_text (PAGE,ReadBit)
#pragma alloc_text (PAGE,ReadByte)
#pragma alloc_text (PAGE,SetSCL)
#pragma alloc_text (PAGE,SetData)
#pragma alloc_text (PAGE,SetClock)
#pragma alloc_text (PAGE,WaitVerticalRetrace)
#pragma alloc_text (PAGE,WaitDelay)
#pragma alloc_text (PAGE,ClearData)
#pragma alloc_text (PAGE,SendByte)
#pragma alloc_text (PAGE,SendDDCCommand)
#pragma alloc_text (PAGE,CheckDDC2BMonitor)
#pragma alloc_text (PAGE,CalculateMaxinumTiming)
#pragma alloc_text (PAGE,ProcessNonDDC)
#pragma alloc_text (PAGE,CirrusNonDDCRegistryCallback)
#endif                                               

UCHAR EDIDBuffer[128] ;
UCHAR EDIDTiming_I    ;
UCHAR EDIDTiming_II   ;
UCHAR EDIDTiming_III  ;
UCHAR DDC2BFlag       ;
UCHAR NonDDCTable     ;
ULONG ulEDIDMaxTiming ;

UCHAR SDAValue ;

/*-------------------------------------------------------------------------*/
VOID EnableDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSR08      ;
    UCHAR WaitCount = 2 ;

    VideoDebugPrint((1, "CLDDC2B!EnableDDC\n"));

    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                 0x08) ;

    ReadSR08 = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                           SEQ_DATA_PORT) ;
    // Enable DDC2B Configuration 
    ReadSR08 |= 0x43 ;

    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSR08) ;

    WaitVerticalRetrace (HwDeviceExtension, WaitCount) ;
    
} /*-----  EnableDDC  -----*/ 


/*-------------------------------------------------------------------------*/
VOID DisableDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;
    UCHAR DDCStatus ;

    VideoDebugPrint((1, "CLDDC2B!DisableDDC\n"));

    if ((DDCStatus = SendDDCCommand ( HwDeviceExtension )) == 1)
        goto DDC_ERROR ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar ( HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT ) ;
    // Disable DDC2B Configuration 
    ReadSEQDATA &= 0xBC ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar ( HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA ) ;

DDC_ERROR:
    return ;

}  /*-------  DisableDDC  -------*/ 


/*-------------------------------------------------------------------------*/
VOID ProcessDDC2 (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{                      
    UCHAR DDCStatus, i ;
    UCHAR checksum, header ;

    VideoDebugPrint((1, "CLDDC2B!ProcessDDC2\n"));

    DDC2BFlag = 0 ;

    if ((DDCStatus = SendDDCCommand ( HwDeviceExtension )) == 1) {
        VideoDebugPrint((0, "CLDDC2B!ProcessDDC2: Infinite wait state ...\n"));
        goto PROCESSDDC_EXIT ;
    }

    for (i = 0; i < 128; i++) {
        EDIDBuffer[i] = ReadByte (HwDeviceExtension) ;
	if (Err) {
            VideoDebugPrint((0, "CLDDC2B!ProcessDDC2: Infinite wait state ...\n"));
            goto PROCESSDDC_EXIT ;
        }
    }

    //
    // Check EDID table 8-byte header
    // The correct first 8 bytes of EDID table is 0x00, 0xFF, 0xFF, 0xFF, 
    //                                            0xFF, 0xFF, 0xFF, 0x00
    //

    if ((EDIDBuffer[0] != 0) ||
        (EDIDBuffer[7] != 0)) {
        VideoDebugPrint((1, "CLDDC2B: Invalid EDID header table\n"));
        StopDDC (HwDeviceExtension) ;
        return ;
    }
    for (i = 1; i < 7; i++) {
         if (EDIDBuffer[i] != 0xFF) {
            VideoDebugPrint((1, "CLDDC2B: Invalid EDID header table\n"));
            StopDDC (HwDeviceExtension) ;
            return ;
        }
    }

    //
    // Calculate checksum of 128-byte EDID table.
    // 
    checksum = 0x00 ;

    for (i = 0; i < 128; i++) {
        checksum += EDIDBuffer[i] ;
    }

    VideoDebugPrint((1, "CLDDC2B: EDID Table check sum = %d\n", checksum));

    //
    // EDID table checksum must be zero.
    // 
    if (checksum) {
        VideoDebugPrint((1, "CLDDC2B: Invalid checksum of EDID table\n"));
    }
    else
    {
        //
        // Set DDC2B Flag and find timing values.
        // 
        DDC2BFlag      = 1 ;
        EDIDTiming_I   = EDIDBuffer[35] ; 
        EDIDTiming_II  = EDIDBuffer[36] ;
        EDIDTiming_III = EDIDBuffer[37] ;
        ulEDIDMaxTiming= CalculateMaxinumTiming();
        VideoDebugPrint((1, "CLDDC2B: DDC2B is supported\n"));
    }

PROCESSDDC_EXIT:
    StopDDC (HwDeviceExtension) ;
    return ;

}  /*-------  ProcessDDC2  -------*/ 


/*-------------------------------------------------------------------------*/
VOID StartDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{

    VideoDebugPrint((1, "DDC2B!StartDDC\n"));

    SetSCL (HwDeviceExtension, ON)  ;
    ClearData (HwDeviceExtension) ;
    SetSCL (HwDeviceExtension, OFF) ;

}  /*-------  StartDDC  -------*/ 


/*-------------------------------------------------------------------------*/
VOID StopDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{

    VideoDebugPrint((1, "DDC2B!StopDDC\n"));

    SetSCL (HwDeviceExtension, ON) ;
    SetData (HwDeviceExtension) ;

}  /*-------  StopDDC  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadSCL (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQDATA, status ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar ( HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT ) ;

    // Read SR08.B2
    ReadSEQDATA = ( (ReadSEQDATA) & 0x04 ) >> 2 ;

    return (ReadSEQDATA) ;

}  /*-------  ReadSCL  -------*/ 


/*-------------------------------------------------------------------------*/
VOID SetSCL(                        
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR status
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA = ( ( ReadSEQDATA & 0xFE ) | status ) ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  SetSCL  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadSDA (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA = ( ReadSEQDATA & 0x80 ) >> 7 ;

    return ( ReadSEQDATA ) ;

}  /*-------  ReadSDA  -------*/ 


/*-------------------------------------------------------------------------*/
VOID ClearData
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;


    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA &= 0xFD ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  ClearData  -------*/ 


/*-------------------------------------------------------------------------*/
VOID SetData 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA |= 0x02 ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  SetData  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SetClock 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    ULONG i ;
    UCHAR status ;

    SetSCL (HwDeviceExtension, ON) ;

    for (i = 0; i < DELAY_COUNT; i++)
        status = ReadSCL (HwDeviceExtension) ;

    SetSCL (HwDeviceExtension, OFF) ;

    if (!status)
        VideoDebugPrint((0, "DDC2B!SetClock: Infinite wait state ...\n"));
    
    if (status == 1)
        return ( FALSE ) ; // retuern 0 -> OK
    else 
        return ( TRUE ) ;  // retuern 1 -> Infinite wait state
                         

}  /*-------  SetClock  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadBit 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    USHORT i ; 
    UCHAR  bit ;

    SetSCL (HwDeviceExtension, ON) ;
    for (i = 0; i < DELAY_COUNT; i++)
        ReadSCL (HwDeviceExtension) ;

    bit = ReadSDA (HwDeviceExtension) ;

    SetSCL (HwDeviceExtension, OFF) ;
   
    return ( bit ) ;

}  /*-------  ReadBit  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadByte 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    UCHAR ReadByteValue, bit, i ;

    SetData ( HwDeviceExtension ) ;

    ReadByteValue = 0 ;

    for (i = 0; i < 8; i++) {
        ReadByteValue <<= 1  ;
        bit = ReadBit ( HwDeviceExtension ) ;
        ReadByteValue |= bit ;
    }

    if ((bit & 0x02) != 0) {
        SetData ( HwDeviceExtension ) ;
    } else {
        ClearData ( HwDeviceExtension ) ;
    }

    SetClock ( HwDeviceExtension ) ;

     SetData ( HwDeviceExtension ) ;

    return (ReadByteValue) ;

} /*-----  ReadByte  -----*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SendByte ( 
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    )
{
    UCHAR i ;

    UCHAR Mask[8] = { 0x80, 0x40, 0x20, 0x10, 
                      0x08, 0x04, 0x02, 0x01 } ; 

    for (i = 0; i < 8; i++)
    {
        if (data & Mask[i]) {
            SetData ( HwDeviceExtension ) ;
        } else { 
            ClearData ( HwDeviceExtension ) ;
        }
	Err = SetClock ( HwDeviceExtension ) ;
    }

    if (Err) {
        SetSCL ( HwDeviceExtension, OFF )  ;
        ClearData (HwDeviceExtension) ;
    } else {
        SetData ( HwDeviceExtension ) ;
        SetSCL ( HwDeviceExtension, ON )  ;
        ReadBit ( HwDeviceExtension ) ;  // Discard acknowledge bit
    }

    return (Err) ;

}  /*-------  SendByte  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN IsDDC2
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    UCHAR DDCStatus, SCLStatus ;

    VideoDebugPrint((1, "DDC2B!IsDDC2\n"));

    SetSCL (HwDeviceExtension, OFF) ;
    SCLStatus = ReadSCL(HwDeviceExtension) ;
    if (SCLStatus != 0) {
        return ( FALSE ) ;
    }

    SetSCL (HwDeviceExtension, ON) ;
    SCLStatus = ReadSCL (HwDeviceExtension) ;
    if (SCLStatus != 1) {
        return ( FALSE ) ;
    } 

    return ( TRUE ) ; 

}  /*-------  IsDDC2  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SendDDCCommand
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ClockStatus ;

    VideoDebugPrint((1, "DDC2B!SendDDCCommand\n"));

    StartDDC ( HwDeviceExtension ) ;

    ClockStatus = SendByte ( HwDeviceExtension, 0xA0 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));
 
    ClockStatus = SendByte ( HwDeviceExtension, 0x00 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));

    StopDDC  ( HwDeviceExtension ) ;


    StartDDC ( HwDeviceExtension ) ;

    ClockStatus = SendByte ( HwDeviceExtension, 0xA1 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));

    SetData  ( HwDeviceExtension ) ;

    return (ClockStatus) ;  

}  /*-------  SendDDCCommand  -------*/ 


/*-------------------------------------------------------------------------*/
VOID WaitDelay 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    PUCHAR InStatPort ;

    //
    // Set up port addresses for color/mono
    //
    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        InStatPort = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR ;
    } else {
        InStatPort = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO ;
    }

    while ((VideoPortReadPortUchar (InStatPort) & 0x01) != 0) ;
    while ((VideoPortReadPortUchar (InStatPort) & 0x01) == 0) ;
    while ((VideoPortReadPortUchar (InStatPort) & 0x01) != 0) ;

}  /*-------  wait_delay  -------*/ 


/*-------------------------------------------------------------------------*/
VOID WaitVerticalRetrace
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR waitcount
    )
{ 
    PUCHAR InStatPort ;
    ULONG i ;
    
    //
    // Set up port addresses for color/mono
    //
    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        InStatPort = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        InStatPort = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }
        
    for (i = 0; i < waitcount; i++) 
    {
        while ((VideoPortReadPortUchar (InStatPort) & 0x08) != 0) ;
        while ((VideoPortReadPortUchar (InStatPort) & 0x08) == 0) ;
    }  

}  /*-------  WaitVerticalRetrace  -------*/

    

/*-------------------------------------------------------------------------*/
VOID ReadVESATiming
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    UCHAR status ; 

    VideoDebugPrint((1, "DDC2B!ReadVESATiming\n"));
#if 1 // NonDDC #sge
    //
    // clear flag.
    //
    NonDDCTable = 0;
    DDC2BFlag   = 0;
#endif
    EnableDDC (HwDeviceExtension) ;

    if ((status = IsDDC2 (HwDeviceExtension)) != 0x00) {
        ProcessDDC2 (HwDeviceExtension) ;
    }
#if 1 // NonDDC #sge
    if(!DDC2BFlag)
        ProcessNonDDC(HwDeviceExtension);
#endif

    DisableDDC (HwDeviceExtension) ;

    return ;

}  /*-----  ReadVESATiming  -----*/

BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if refresh rate support according to DDC2B standard.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{

    ULONG ulCurrTiming ;
#if 1 // NonDDC #sge
    if (!DDC2BFlag && !NonDDCTable)
        return TRUE ;
#else
    if (!DDC2BFlag)
        return TRUE ;
#endif

    VideoDebugPrint((4, "CheckDDC2B\n"));
    VideoDebugPrint((4, "refresh rate   = %ld\n", ModesVGA[i].Frequency));
    VideoDebugPrint((4, "hres           = %d\n", ModesVGA[i].hres));
    VideoDebugPrint((4, "vres           = %d\n", ModesVGA[i].vres));

    ulCurrTiming = ModesVGA[i].Frequency *
                   ModesVGA[i].hres *
                   ModesVGA[i].vres ;

    VideoDebugPrint((4, "ulCurrTiming = %d\n", ulCurrTiming)) ;

    VideoDebugPrint((4, "ulEDIDMaxTiming = %d\n", ulEDIDMaxTiming)) ;

    if ( ulCurrTiming > ulEDIDMaxTiming ) 
        return FALSE ;
    else
        return TRUE ;

}  // end of CheckDDC2bMonitor


ULONG
CalculateMaxinumTiming(
    )

/*++

Routine Description:
    Determines maximum allowablt VESA timing value.

Arguments:
    None.

Return Value:
    None.

--*/
{

    ULONG    current_timing_value ;
    ULONG    freq ;
    SHORT    i ;
    USHORT    usHzActive, usHzBlanking, usVtActive, usVtBlanking;
    ULONG    maximum_allowable_timing_value = ulEDIDMaxTiming;

    VideoDebugPrint((1, "CLDDC2B: CalculateMaxinumTiming\n")) ;

    //
    // Calculate established timing values
    // 
    /* 720 * 400 * 70 = 20160000 */
    if ( EDIDTiming_I & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 720 * 400 * 70\n")) ;
        if (maximum_allowable_timing_value < ((ULONG) 20160000)) {
            maximum_allowable_timing_value = ((ULONG) 20160000) ;
        }
    }

    /* 720 * 400 * 88 = 25344000 */
    if ( EDIDTiming_I & 0x40 ) {
        VideoDebugPrint((1, "CLDDC2B: 720 * 400 * 88\n")) ;
        if (maximum_allowable_timing_value < ((ULONG) 25344000)) {
            maximum_allowable_timing_value = ((ULONG) 25344000) ;
        }
    }

    /* 640 * 480 * 60 = 18432000 */
    if ( EDIDTiming_I & 0x20 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 18432000)) {
            maximum_allowable_timing_value = ((ULONG) 18432000) ;
        }
    }

    /* 640 * 480 * 67 = 20582400 */
    if ( EDIDTiming_I & 0x10 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 67\n"));
        if (maximum_allowable_timing_value < ((ULONG) 20582400)) {
            maximum_allowable_timing_value = ((ULONG) 20582400) ;
        }
    }
         
    /* 640 * 480 * 72 = 22118400 */
    if ( EDIDTiming_I & 0x08 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 72\n"));
        if (maximum_allowable_timing_value < ((ULONG) 22118400)) {
            maximum_allowable_timing_value = ((ULONG) 22118400) ;
        }
    }

    /* 640 * 480 * 75 = 23040000 */
    if ( EDIDTiming_I & 0x04 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 23040000)) {
            maximum_allowable_timing_value = ((ULONG) 23040000) ;
        }
    }

    /* 800 * 600 * 56 = 26880000 */
    if ( EDIDTiming_I & 0x02 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 56\n"));
        if (maximum_allowable_timing_value < ((ULONG) 26880000)) {
            maximum_allowable_timing_value = ((ULONG) 26880000) ;
        }
    }

    /* 800 * 600 * 60 = 28800000 */
    if ( EDIDTiming_I & 0x01 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 28800000)) {
            maximum_allowable_timing_value = ((ULONG) 28800000) ;
        }
    }   

    /* 800 * 600 * 72 = 34560000 */
    if ( EDIDTiming_II & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 72\n"));
        if (maximum_allowable_timing_value < ((ULONG) 34560000)) {
            maximum_allowable_timing_value = ((ULONG) 34560000) ;
        } 
    }

    /* 800 * 600 * 75 = 36000000 */
    if ( EDIDTiming_II & 0x40 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 36000000)) {
            maximum_allowable_timing_value = ((ULONG) 36000000) ; 
        }
    }

    /* 832 * 624 * 75 = 38937600 */
    if ( EDIDTiming_II & 0x20 ) {
        VideoDebugPrint((1, "CLDDC2B: 832 * 624 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 38937600)) {
            maximum_allowable_timing_value = ((ULONG) 38937600) ; 
        }
    }

    /* 1024 * 768 * 43 = 33816576 */
    if ( EDIDTiming_II & 0x10 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 43\n"));
        if (maximum_allowable_timing_value < ((ULONG) 33816576)) {
            maximum_allowable_timing_value = ((ULONG) 33816576) ;
        }
    }

    /* 1024 * 768 * 60 = 47185920 */
    if ( EDIDTiming_II & 0x08 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 47185920)) {
            maximum_allowable_timing_value = ((ULONG) 47185920) ;
        }
    }

    /* 1024 * 768 * 70 = 55050240 */
    if ( EDIDTiming_II & 0x04 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 70\n"));
        if (maximum_allowable_timing_value < ((ULONG) 55050240)) {
            maximum_allowable_timing_value = ((ULONG) 55050240) ;
        }
    }

    /* 1024 * 768 * 75 = 58982400 */
    if ( EDIDTiming_II & 0x02 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 58982400)) {
            maximum_allowable_timing_value = ((ULONG) 58982400) ;
        }
    }

    /* 1280 * 1024 * 75 = 98304000 */
    if ( EDIDTiming_II & 0x01 ) {
        VideoDebugPrint((1, "CLDDC2B: 1280 * 1024 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 98304000)) {
            maximum_allowable_timing_value = ((ULONG) 98304000) ;
        }
    }

    /* 1152 * 870 * 75 = 75168000 */
    if ( EDIDTiming_III & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 1152 * 870 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 75168000)) {
            maximum_allowable_timing_value = ((ULONG) 75168000) ;
        }
    }

    //
    // Calculate standard timing values
    // 

    for ( i = 0x26 ; i <= 0x35 ; i+=2 ) {
        current_timing_value = 0L ;
        freq = ( EDIDBuffer[i+1] & 0x3F ) + 60 ;
        switch ( EDIDBuffer[i] ) {
            case 0x31 :                                 // 640 * 480 = 307200 
                current_timing_value = ((ULONG) freq) * 307200 ;
                VideoDebugPrint((1, "CLDDC2B: 640 * 480 * %d\n", freq));
                break ;   
            case 0x3B :                                 // 720 * 400 = 288000
                current_timing_value = ((ULONG) freq) * 288000 ;
                VideoDebugPrint((1, "CLDDC2B: 640 * 480 * %d\n", freq));
                break ;   
            case 0x45 :                                 // 800 * 600 = 480000
                current_timing_value = ((ULONG) freq) * 480000 ;
                VideoDebugPrint((1, "CLDDC2B: 800 * 600 * %d\n", freq));
                break ;   
            case 0x61 :                                // 1024 * 768 = 786432
                current_timing_value = ((ULONG) freq) * 786432 ;
                VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * %d\n", freq));
                break ;   
            case 0x71 :                               // 1152 * 870 = 1002240
                current_timing_value = ((ULONG) freq) * 1002240 ;
                VideoDebugPrint((1, "CLDDC2B: 1152 * 870 * %d\n", freq));
                break ;   
            case 0x81 :                              // 1280 * 1024 = 1310720
                current_timing_value = ((ULONG) freq) * 1310720 ;
                VideoDebugPrint((1, "CLDDC2B: 1280 * 1024 * %d\n", freq));
                break ;   
            case 0xA9 :                              // 1600 * 1200 = 1920000
                current_timing_value = ((ULONG) freq) * 1920000 ;
                VideoDebugPrint((1, "CLDDC2B: 1600 * 1200 * %d\n", freq));
                break ;   
            default :
                ;
        }

        if (maximum_allowable_timing_value < current_timing_value) 
            maximum_allowable_timing_value = current_timing_value ;

    }

// sge02
    //
    // Calculate detailed timing values
    // 

    for ( i = 0x36 ; i <= 0x7D; i+=18 ) 
    {
        current_timing_value = EDIDBuffer[i] ;
        current_timing_value += EDIDBuffer[i+1] * 256;
        //
        // Validation.
        //
        // sge03
        if (current_timing_value <= 0x0101 )
            continue;
        current_timing_value *= 10000;
        //
        // Calculate Horizontal Active and Blanking
        //
        usHzActive    = (EDIDBuffer[i+4] & 0xf0);
        usHzActive    <<= 4;
        usHzActive    |= EDIDBuffer[i+2];
        usHzBlanking = (EDIDBuffer[i+4] & 0x0f);
        usHzBlanking <<= 8;
        usHzBlanking |= EDIDBuffer[i+3];
        //
        // Calculate Vertical Active and Blanking
        //
        usVtActive    = (EDIDBuffer[i+7] & 0xf0);
        usVtActive    <<= 4;
        usVtActive    |= EDIDBuffer[i+5];
        usVtBlanking = (EDIDBuffer[i+7] & 0x0f);
        usVtBlanking <<= 8;
        usVtBlanking |= EDIDBuffer[i+6];

        current_timing_value = (current_timing_value + usHzActive + usHzBlanking - 1) / (usHzActive + usHzBlanking);
        current_timing_value = (current_timing_value + usVtActive + usVtBlanking - 1) / (usVtActive + usVtBlanking);
        current_timing_value *= usHzActive; 
        current_timing_value *= usVtActive; 

        if (maximum_allowable_timing_value < current_timing_value) 
            maximum_allowable_timing_value = current_timing_value ;

    }

    return (maximum_allowable_timing_value);

}  // end of CalculateMaxinumTiming 

//---------------------------------------------------------------------------
//
// Function:
//     Read NonDDC Table from Registry and Set NonDDCTable Flag.
//
// Input:
//     HwDeviceExtension - Pointer to the miniport driver's device extension.         
//
// Output: 
//     None
//
//---------------------------------------------------------------------------
VOID ProcessNonDDC(
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{                      
    ULONG i ;

    VideoDebugPrint((1, "NonDDC!ProcessNonDDC\n"));

    NonDDCTable = 0 ;

    if (NO_ERROR == VideoPortGetRegistryParameters(HwDeviceExtension,
                                                   L"NonDDCMonitor.Data",
                                                   FALSE,
                                                   CirrusNonDDCRegistryCallback,
                                                   NULL)) 
    {
        // 
        // We got the table 
        //
        //
        // Check EDID table 8-byte header
        // The correct first 8 bytes of EDID table is 0x00, 0xFF, 0xFF, 0xFF, 
        //                                            0xFF, 0xFF, 0xFF, 0x00
        //

        if ((EDIDBuffer[0] != 0) ||
            (EDIDBuffer[7] != 0)) 
        {
            VideoDebugPrint((1, "CLNonDDC: Invalid EDID header table\n"));
            return ;
        }
        for (i = 1; i < 7; i++) 
        {
            if (EDIDBuffer[i] != 0xFF) 
            {
                VideoDebugPrint((1, "CLNonDDC: Invalid EDID header table\n"));
                return ;
            }
        }

        //
        // Set NonDDCTable Flag and find timing values.
        // 
        NonDDCTable    = 1 ;
        EDIDTiming_I   = EDIDBuffer[35] ; 
        EDIDTiming_II  = EDIDBuffer[36] ;
        EDIDTiming_III = EDIDBuffer[37] ;
        ulEDIDMaxTiming= CalculateMaxinumTiming();
        VideoDebugPrint((1, "NonDDC: NonDDC is supported\n"));
    }
} // end of ProcessNonDDC  



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\cldata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cldata.c

Abstract:

    This module contains all the global data used by the cirrus driver.

Environment:

    Kernel mode

Revision History:

* jl01   09-24-96  For 1280x1024x256, refresh 71Hz is replaced by 72Hz
*                  Refer to PDR#5373.
* chu01  10-06-96  Correst miscellaneous for CL-GD5480 refresh rate setting
* sge01  10-06-96  Fix PDR #6794: Correct Monitor refresh rate for 100Hz
*                  file changed: cldata.c modeset.c
* jl02   10-15-96  Add CL5446-BE support to the Mode Table; also newly support
*                  1152x864x64K@70Hz/75Hz and 1280x1024x64K@60Hz
* jl03   11-18-96  The mode 0x12 needs to be set up in Full DOS Screen ( Japanese
*                  Version).  Refer to PDR#7170.
* jl04   11-26-96  1024x768x16M@70Hz is corrected.  Refer to PDR#7629.
*                                                                                                                                               1600x1200x64K and 1280x1024x16M missing for 5480.  PDR#7616
* jl05   12-06-96  1152x864x16M only for 5480.
*
* myf0 : 08-19-96  added 85hz supported, and delete 6x4x16M for CL754x
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate select
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : Added 7555 flag for Direct Draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* myf20 :11-12-96 : Fixed DSTN panel initial reserved 128K memoru
* myf21 :11-15-96 : fixed #7495 during change resolution, screen appear garbage
*                   image, because not clear video memory.
* myf22 :11-19-96 : Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23 :11-21-96 : Added fixed NT 3.51 S/W cursor panning problem
* myf24 :11-22-96 : Added fixed NT 4.0 Japanese dos full screen problem
* myf25 :12-03-96 : Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                   fixed pre-install microsoft requested
* myf26 :12-11-96 : Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27 :01-09-97 : Fixed jumper set 8x6 DSTN panel, select 8x6x64K mode,
*                   boot up CRT garbage appear PDR#7986

--*/

#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//---------------------------------------------------------------------------
//
//        The actual register values for the supported modes are in chipset-specific
//        include files:
//
//                mode64xx.h has values for CL6410 and CL6420
//                mode542x.h has values for CL5422, CL5424, and CL5426
//                mode543x.h has values for CL5430-CL5439 (Alpine chips)
//
#include "mode6410.h"
#include "mode6420.h"
#include "mode542x.h"
#include "mode543x.h"

//crus begin
#ifdef PANNING_SCROLL                  //myf1
//myf1, begin
#ifdef INT10_MODE_SET
RESTABLE ResolutionTable[] = {
// {1280, 1024, 1,  16, 0x6C},
// {1024,  768, 1,  11, 0x5D},
// { 800,  600, 1,  8,  0x6A},
 { 640,  480, 1,  4,  0x12},    //myf26

 {1280, 1024, 8,  32, 0x6D},  //31,27
 {1024,  768, 8,  21, 0x60},  //20,16
 { 800,  600, 8,  15, 0x5C},  //14,10
 { 640,  480, 8,   9, 0x5F},  //08,04

 {1280, 1024, 16, 62, 0x75},  //61,56
 {1024,  768, 16, 52, 0x74},  //51,47
 { 800,  600, 16, 45, 0x65},  //44,40
 { 640,  480, 16, 40, 0x64},  //39,35

 {1280, 1024, 24, NULL, NULL},
 {1024,  768, 24, 82, 0x79},  //81,77
 { 800,  600, 24, 76, 0x78},  //75,71
 { 640,  480, 24, 70, 0x71},  //69,65

 {1280, 1024, 32, NULL, 0},
 {1024,  768, 32, NULL, 0},
 { 800,  600, 32, NULL, 0},
 { 640,  480, 32, NULL, 0},

 {   0,    0,  0, 0},
};
#endif
//myf1, end
#endif
//crus end


//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0           //myf25                          // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0   //myf25
},

//
// This next region also includes Memory mapped IO.  In MMIO, the ports are
// repeated every 256 bytes from b8000 to bff00.
//

{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    0   //myf25
},

//
// Region reserved for when linear mode is enabled.
//

{
    MEM_LINEAR, 0x00000000,
    MEM_LINEAR_SIZE,
    0,
    0,
    0
},


//
// This next region is for relocatable VGA register and MMIO register.
//

{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    0
}

};

//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0x0C,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    }

};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT MODESET_MODEX_320_200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT MODESET_MODEX_320_240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT MODESET_MODEX_320_400[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    3,
    0xe317,
    0x0014,
    0x4009,

    EOD
};

USHORT MODESET_MODEX_320_480[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4009,

    EOD
};



USHORT MODESET_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

USHORT MODESET_2K_WIDE[] = {
    OWM,                            // stretch scans to 2k
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x0013,
    0x021B, // CR1B[5]=0, 0x321b for 64kc bug

    EOD
};

USHORT MODESET_75[] = {
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x4013,
    0x321B,
    EOD
};


USHORT CL543x_640x480x16M[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions
/*
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xF013, 0x221B,
*/
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0xF013,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x221B,

    EOD
};

USHORT CL543x_800x600x16M[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions
/*
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x2C13, 0x321B,
*/
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x2C13,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x321B,

    EOD
};

//myf25
USHORT CL543x_800x600x16M_1[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4013,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x321B,

    EOD
};

//---------------------------------------------------------------------------
//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0x10000},   // all mono text modes (7)
    {           0x08000,    0x18000},   // all color text modes (0, 1, 2, 3,
    {           0x10000,    0x00000}    // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {
//
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//
{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  0,                 // montype is 'dont care' for text modes
  0, 0, 0,           // montype is 'dont care' for text modes
  TRUE,              // hardware cursor enabled for this mode
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,              // ModeValid default is always off
  FALSE,              // This mode cannot be mapped linearly
  { 3,3,3},          // int10 BIOS modes
  { CL6410_80x25Text_crt, CL6410_80x25Text_panel,
   CL6420_80x25Text_crt, CL6420_80x25Text_panel,
   CL542x_80x25Text, CL543x_80x25Text, 0 },
},      //myf1, 0

//
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//
{  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  640, 350,          // 640x350 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  0,                 // montype is 'dont care' for text modes
  0, 0, 0,           // montype is 'dont care' for text modes
  TRUE,              // hardware cursor enabled for this mode
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,              // ModeValid default is always off
  FALSE,
  { 3,3,3},             // int10 BIOS modes
    { CL6410_80x25_14_Text_crt, CL6410_80x25_14_Text_panel,
     CL6420_80x25_14_Text_crt, CL6420_80x25_14_Text_panel,
     CL542x_80x25_14_Text, CL543x_80x25_14_Text, 0 },
},      //myf1, 1

//
//
// Monochrome text mode 7, 720x400, 9x16 char cell (VGA).
//
{ 0,                            // flags that this mode is a monochrome text mode
  4,                // four planes
  1,                // one bit of colour per plane
  80, 25,           // 80x25 text resolution
  720, 400,         // 720x400 pixels on screen
  160, 0x10000,     // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,             // only support one frequency, non-interlaced
  0,                // montype is 'dont care' for text modes
  0, 0, 0,          // montype is 'dont care' for text modes
  TRUE,             // hardware cursor enabled for this mode
  NoBanking,        // no banking supported or needed in this mode
  MemMap_Mono,      // the memory mapping is the standard monochrome memory
                    //  mapping of 32K at B0000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,            // ModeValid default is always off
  FALSE,            // This mode cannot be mapped linearly
  { 7,7,7 },        // int10 BIOS modes
  { CL6410_80x25Text_crt, CL6410_80x25Text_panel,
   CL6420_80x25Text_crt, CL6420_80x25Text_panel,
   CL542x_80x25Text, CL543x_80x25Text, 0 },
},      //myf1, 2

//
//
// Monochrome text mode 7, 640x350, 8x14 char cell (EGA).
//
{ 0,                            // flags that this mode is a monochrome text mode
  4,                // four planes
  1,                // one bit of colour per plane
  80, 25,           // 80x25 text resolution
  640, 350,         // 640x350 pixels on screen
  160, 0x10000,     // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,             // only support one frequency, non-interlaced
  0,                // montype is 'dont care' for text modes
  0, 0, 0,          // montype is 'dont care' for text modes
  TRUE,             // hardware cursor enabled for this mode
  NoBanking,        // no banking supported or needed in this mode
  MemMap_Mono,          // the memory mapping is the standard monochrome memory
                    //  mapping of 32K at B0000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,            // ModeValid default is always off
  FALSE,
  { 7,7,7 },            // int10 BIOS modes
    { CL6410_80x25_14_Text_crt, CL6410_80x25_14_Text_panel,
     CL6420_80x25_14_Text_crt, CL6420_80x25_14_Text_panel,
     CL542x_80x25_14_Text, CL543x_80x25_14_Text, 0 },
},      //myf1, 3

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x12,0x12,0x12},          // int10 BIOS modes
  { CL6410_640x480_crt, CL6410_640x480_panel,
   CL6420_640x480_crt, CL6420_640x480_panel,
   CL542x_640x480_16, CL543x_640x480_16, 0 },
},      //myf1, 4

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  72, 0,              // 72hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL754x | CL5436 | CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   CL542x_640x480_16, NULL, 0 },
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  75, 0,              // 75hz, non-interlaced
  4,                  // montype
  0x1230, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   NULL, CL543x_640x480_16, 0 },
},

//
// Standard VGA Color graphics mode 0x12
// 640x480 16 colors, 85 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  85, 0,              // 85hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
                                //myf0
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   NULL, CL543x_640x480_16, 0 },
},

// We make ModeX modes available only on x86 because our IO-mapping IOCTL,
// QUERY_PUBLIC_ACCESS_RANGES doesn't currently support the ModeX request
// format:

#if defined(_X86_)

// Standard ModeX mode
// 320x200 256 colors, 70 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 200, 80, 0x10000,
  70, 0,              // 70hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_200, MODESET_MODEX_320_200,
    MODESET_MODEX_320_200, MODESET_MODEX_320_200,
    MODESET_MODEX_320_200, MODESET_MODEX_320_200, 0 },
},      //myf1, 5

// Standard ModeX mode
// 320x240 256 colors, 60 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 240, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_240, MODESET_MODEX_320_240,
    MODESET_MODEX_320_240, MODESET_MODEX_320_240,
    MODESET_MODEX_320_240, MODESET_MODEX_320_240, 0 },
},      //myf1, 6

// Standard ModeX mode
// 320x400 256 colors, 70 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 400, 80, 0x10000,
  70, 0,              // 70hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_400, MODESET_MODEX_320_400,
    MODESET_MODEX_320_400, MODESET_MODEX_320_400,
    MODESET_MODEX_320_400, MODESET_MODEX_320_400, 0 },
},      //myf1, 7

// Standard ModeX mode
// 320x480 256 colors, 60 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 480, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_480, MODESET_MODEX_320_480,
    MODESET_MODEX_320_480, MODESET_MODEX_320_480,
    MODESET_MODEX_320_480, MODESET_MODEX_320_480, 0 },
},      //myf1, 8

#endif // #defined(_X86_)


//
// Beginning of SVGA modes
//

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  56, 0,              // 56hz, non-interlaced
  3,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0x6a,0x6a,0x6a},       // int10 BIOS modes
  { CL6410_800x600_crt, NULL,
   CL6420_800x600_crt, NULL,
   CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  60, 0,              // 60hz, non-interlaced
  4,                  // montype
  0x1203, 0x01A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel8x6 | panel10x7,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0x6a,0x6a},          // int10 BIOS modes
  { NULL, NULL,
   CL6420_800x600_crt, NULL,
   CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  72, 0,              // 72hz, non-interlaced
  5,                  // montype
  0x1203, 0x02A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0,0x6a},             // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  75, 0,              // 75hz, non-interlaced
  5,                  // montype
  0x1203, 0x03A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0,0x6a},             // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  60, 0,              // 60hz, non-interlaced
  5,                  // montype
  0x1203, 0x10A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel10x7,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  70, 0,              // 70hz, non-interlaced
  6,                  // montype
  0x1203, 0x20A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
   CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  72, 0,              // 72hz, non-interlaced
  7,                  // montype
  0x1203, 0x30A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  75, 0,              // 75hz, non-interlaced
  7,                  // montype
  0x1203, 0x40A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},

//
// 1024x768 interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  43, 1,              // 43hz, interlaced
  4,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
// crus
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0x37,0x5d},       // int10 BIOS modes
  { NULL, NULL,
   CL6420_1024x768_crt, NULL,
   CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1280x1024 interlaced 16 colors.
// Assumes 1meg required. 1K scan line
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 160, 64,
  1280, 1024, 256, 0x40000,
  43, 1,              // 43Hz, interlaced
  5,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x6c},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1280x1024_16, CL543x_1280x1024_16, MODESET_1K_WIDE},
},

//
//
// VGA Color graphics,
//
// 640x480 256 colors.
//
// For each mode which we have a broken raster version of the mode,
// followed by a stretched version of the mode.  This is ok because
// the vga display drivers will reject modes with broken rasters.
//

// ----- 640x480x256@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x2e,0x5f},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_640x480_256color_crt, CL6420_640x480_256color_panel,
    CL542x_640x480_256, CL543x_640x480_256, NULL},
},      //myf1, 9


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x2e,0x5f},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_640x480_256color_crt, CL6420_640x480_256color_panel,
    CL542x_640x480_256, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_256, CL543x_640x480_256, NULL },
},      //myf1, 10


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_256, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 11


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  75, 0,              // 75hz, non-interlaced
  4,                  // montype
  0x1230, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  85, 0,              // 85 Hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 12


// ----- 640x480x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  100, 0,                     // 100 Hz, non-interlaced
  4,                          // montype
  0x1213, 0x00A4, 0,          // montype
  TRUE,                       // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  TRUE,
  { 0,0,0x5F},                // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 13



// ----- 800x600x256@56Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 14



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},


// ----- 800x600x256@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 15



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},


// ----- 800x600x256@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 16



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 17



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 18


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  100, 0,                            // 100Hz, non-interlaced
  5,                                 // montype
  0x1203, 0x05A4, 0, // sge01        // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5C},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 19



// ----- 1024x768x256@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  43, 1,                             // 43Hz, interlaced
  4,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x38,0x60},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_1024x768_256color_crt, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 20



// ----- 1024x768x256@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  5,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,                              // what should we do for this mode?  vga will accept this!
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 21



// ----- 1024x768x256@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  70, 0,                             // 70hz, non-interlaced
  6,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 22



// ----- 1024x768x256@72Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  7,                                 // montype
  0x1203, 0x30A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5436 | CL5446 | CL5446BE | CL54UM36,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 23



// ----- 1024x768x256@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 24



// ----- 1024x768x256@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  7,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 25


// ----- 1024x768x256@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 26



/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  43, 1,                             // 43Hz, interlaced
  4,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x38,0x60},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_1024x768_256color_crt, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

<----- */



// ----- 1152x864x256@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  70, 0,                             // 70hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x7c },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 27


// ----- 1152x864x256@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0100,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7c },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 28


// ----- 1152x864x256@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  85, 0,                             // 85Hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0200,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7C },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 29


// ----- 1152x864x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0300,  // sge01    // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7C },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 30



// ----- 1280x1024x256@43i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  43, 1,                             // 43Hz, interlaced
  5,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 31


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  43, 1,                             // 43Hz, interlaced
  5,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */



// ----- 1280x1024x256@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 32


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@72Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  72, 0,                             // 72Hz, non-interlaced, jl01
  0,                                 // montype
  0x1203, 0xA4, 0x2000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5446BE,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 33


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  71, 0,                             // 71Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x2000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5446BE | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 34


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5446 | CL5480,   //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@85Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  85, 0,                             // 85Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x4000,    // sge01  // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 35



// ----- 1280x1024x256@100Hz ------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x5000,    // sge01  // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 36



// (This mode doesn't seem to work!  ????? )
//
// ----- 1600x1200x256@48i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  48, 1,                            // 96Hz, interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0000,             // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 37


// ----- 1600x1200x256@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  60, 0,                            // 60Hz, non-interlaced
  7,                                // montype
  0x1204, 0x00A4, 0x0400, // chu01  // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 38


// ----- 1600x1200x256@70Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  70, 0,                            // 70Hz, non-interlaced
  7,                                // montype
  0x1204, 0x00A4, 0x0800, // chu01  // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 39



//
// The Cirrus Display Driver now supports broken rasters,
// so I have enabled support for broken rasters in the
// miniport.
//
// Eventually we will probably want to add additional
// (equivalent) modes which don't require broken rasters.
//
// To get back to these modes, make the wbytes field
// equal to 2048, set the memory requirements field
// appropriately (1 meg for 640x480x64k, 2 meg for
// 800x600x64).
//
// Finally for non broken rasters we need to the
// stretch from NULL to MODESET_2K_WIDE.
//



// ----- 640x480x64K@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_64k, CL543x_640x480_64k, NULL},
},      //myf1, 40




//
// The Compaq storm (754x 800x600 LCD) has a problem with the stretch
// code under 64k color modes.  The last pixel on a line is wrapped
// around to the start of the next line.  The problem is solved if we
// use a non-stretched broken raster mode.
//
// I've expanded our 640x480x64k color modes such that we have both
// a broken raster mode (on all platforms) and a stretched mode for
// x86 machines.  (In case cirrus.dll does not load, and vga64k
// loads instead.  Vga64k does not support broken rasters.)
//

//
// VGA Color graphics,        640x480 64k colors. 2K scan line
// Non-Broken Raster version
//


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_64k, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */



//
//
// VGA Color graphics,        640x480 64k colors. 2K scan line
//

// ----- 640x480x64K@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 41


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},

<----- */


//
// VGA Color graphics,        640x480 64k colors. 2K scan line
//

// ----- 640x480x64K@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 42


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */


// 640x480 64k colors.  85hz non-interlaced
//
// ----- 640x480x64K@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0, myf22
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 43


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */


// ----- 640x480x64K@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 44


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@56Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  56, 0,                             // 56hz, non-interlaced
  4,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 45


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  56, 0,                             // 56hz, non-interlaced
  4,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 46




/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 47


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 48


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */

// ----- 800x600x64K@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 49


// ----- 800x600x64K@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  5,                                 // montype
  0x1203, 0x05A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 50



//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  43, 1,                             // 43hz, interlaced
  5,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 51

//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  5,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 52


//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  70, 0,                             // 70hz, non-interlaced
  6,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 53


//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 54


// 1024x768 64k colors. 85Hz non-interlaced
//
// ----- 1024x768x64K@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  85, 0,                             // 85hz, non-interlaced
  7,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0,
    NULL},
},      //myf1, 55


// ----- 1024x768x64K@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  100, 0,                            // 100hz, non-interlaced
  7,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0,
    NULL},
},      //myf1, 56


// crus
// 1152x864 64k colors. 70Hz non-interlaced
//
// ----- 1152x864x64K@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  70, 0,                             // 70Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0000,            // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480,        // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 57

// crus
// 1152x864 64k colors. 75Hz non-interlaced
//
// ----- 1152x864x64K@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0100,            // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480,        // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 58


// ----- 1152x864x64K@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  85, 0,                             // 85Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0200,   // sge01 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 59


// ----- 1152x864x64K@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0300,   // sge01 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 60


// crus
//
// 1280x1024 interlaced 64k colors, 43Hz interleaced
// Assumes 3 MB required.
//
// ----- 1280x1024x64K@43i --------------------------------------------------

#if 1
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x300000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 61
#endif


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 62


// ----- 1280x1024x64K@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480 | CL7556,                 // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 63


// ----- 1280x1024x64K@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  75,   0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 64


// ----- 1280x1024x64K@85Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  85, 0,                             // 85Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x4000,    //sge01   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 65


// ----- 1280x1024x64K@100Hz ------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  100, 0,                            // 100Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x5000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 66


//
// 1600x1200 64K colors.  (This mode doesn't seem to work!  ????? )
//
// ----- 1600x1200x64K@48i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  48, 1,                            // 96Hz, interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0000,             // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 67


// ----- 1600x1200x64K@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  60, 0,                            // 60Hz, non-interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0400,    // sge01 // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 68


// ----- 1600x1200x64K@70Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  70, 0,                            // 70Hz, non-interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0800,    // sge01 // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 69


#if 1
// added 24bpp mode tables

// ----- 640x480x16M@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//myf0  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,  //myf0
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
// crus
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 70


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
// crus
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */



// ----- 640x480x16M@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 71


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */


// ----- 640x480x16M@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 72


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */



// ----- 640x480x16M@85Hz ---------------------------------------------------


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 73



/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */


// ----- 640x480x16M@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 74



// ----- 800x600x16M@56Hz ------------------- MYF TEST ----------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                    // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 75



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                    // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@60Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 76



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@72Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 77



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@75Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 78



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@85Hz ---------------------- MYF TEST -------------------


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 79



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@100Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x05A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 80



// ----- 1024x768x16M@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 3072, 0x300000,
  43, 1,                             // 43Hz, interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 81


// ----- 1024x768x16M@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  60, 0,                             // 60Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 82




// ----- 1024x768x16M@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  70, 0,                             // 70Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480 | CL7556,        // jl04
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},


// ----- 1024x768x16M@72Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  72, 0,                             // 72Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x30A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436,                            // jl04
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 83


// ----- 1024x768x16M@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  75, 0,                             // 75Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 84


// ----- 1024x768x16M@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 85


// ----- 1024x768x16M@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  100, 0,                            // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 86



// ----- 1152x864x16M@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  70, 0,                             // 70hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 87


// ----- 1152x864x16M@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0100,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 88


// ----- 1152x864x16M@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  85, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0200,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 89



// ----- 1280x1024x16M@43i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 90


// ----- 1280x1024x16M@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 91


// ----- 1280x1024x16M@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 92

#endif // added 24bpp mode tables





//
// VGA Color graphics,        640x480, 32 bpp, broken rasters
//
// ----- 640x480x16M --------------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 32, 80, 30,
  640, 480, 640*4, 0x200000,
  60, 0,              // 60hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
//myf9  CL754x | CL755x | CL5434 | CL5434_6,
  CL5434 | CL5434_6,
//myf9  crt | panel | panel8x6 | panel10x7,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x76},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0,
    NULL },
},      //myf1, 93

};

ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);


//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clddk.h ===
//
// This contains declarations from ntddk.h that we need.  Unfortunately,
// we can't easily include ntddk.h since it conflicts with other
// header files.  So, we'll include the needed support here.  Hopefully,
// we'll find a better solution soon.
//

typedef LONG NTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;

//
// Subroutines for dealing with the Registry
//

typedef NTSTATUS (*PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

#define REG_DWORD                   ( 4 )   // 32-bit number

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

__declspec(dllimport)
NTSTATUS
__stdcall
RtlQueryRegistryValues(
     ULONG RelativeTo,
     PWSTR Path,
     PRTL_QUERY_REGISTRY_TABLE QueryTable,
     PVOID Context,
     PVOID Environment
    );

__declspec(dllimport)
NTSTATUS
__stdcall
RtlWriteRegistryValue(
     ULONG RelativeTo,
     PWSTR Path,
     PWSTR ValueName,
     ULONG ValueType,
     PVOID ValueData,
     ULONG ValueLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clgamma.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C    L    G    A    M    M    A  .  C

Abstract:

    This routine accesses Gamma correction information from the following 
    NT 4.0 registry.

    Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
    Keys                  : "G Gamma", and "G Contrast"

Environment:

    Kernel mode only

Notes:
*
*    chu01  12-16-96 : Color correction start coding.
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>  // I added
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"


//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    ) ;

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetGammaKeyInfoFromReg)
#pragma alloc_text(PAGE,GetContrastKeyInfoFromReg)
#pragma alloc_text(PAGE,GetGammaCorrectInfoCallBack)
#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)
#endif

UCHAR GammaInfo[4] ;

//---------------------------------------------------------------------------
//
// Function: Get Gamma factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetGammaFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PGAMMA_VALUE)) )
        return ERROR_INSUFFICIENT_BUFFER;

    status = GetGammaKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x7f ; 
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Gamma value = %lx\n", *value)) ;

    return status ;

} // VgaGetGammaFactor


//---------------------------------------------------------------------------
//
// Function: Get Contrast factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetContrastFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PCONTRAST_VALUE)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    status = GetContrastKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x80 ;
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Contrast value = %lx\n", *value)) ;
    return status ;


} // VgaGetContrastFactor

//---------------------------------------------------------------------------
//
// Function: Get Gamma Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    VP_STATUS status ;

    VideoDebugPrint((2, "GetGammaKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Gamma",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Gamma key info from registry\n"));
    }

    return status ;


} // GetGammaKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Contrast Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VP_STATUS status ;
    VideoDebugPrint((2, "GetContrastKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Contrast",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
    }
    return status ;

} // GetContrastKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Gamma coorrection information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetGammaCorrectInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (GammaInfo, ValueData, ValueLength) ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetGammaCorrectInfoCallBack
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clmini.h ===
/*++

Copyright (c005289-1994  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Author:

    Mike Glass  27-April-1992

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

//#define ASSERT( exp )

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

// end_winnt

//
// Void
//

typedef void *PVOID;    // winnt


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote

#else   /* UNICODE */

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define __TEXT(quote) quote

#endif /* UNICODE */
#define TEXT(quote) __TEXT(quote)


// end_winnt

typedef double DOUBLE;


//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// end_winnt

//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;





//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! (defined(lint) || defined(_lint))
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint or _lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this.  line +e530 turns that checking back on.  Error 527 has to do with
// unreachable code.

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint +e527 +e530 */

#endif // lint or _lint



#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#pragma warning(default:4164)   // reenable C4164 warning

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//






//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;



#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2



#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000


//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );


//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

//#define CM_RESOURCE_PORT_MEMORY 0
//#define CM_RESOURCE_PORT_IO 1


#include "pshpack1.h"











#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08



#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clioctl.h ===
//---------------------------------------------------------------------------
//
//  file: CLIOCTL.H
//
// (c) Copyright 1993, Cirrus Logic, Inc.
// Copyright (c) 1996-1997  Microsoft Corporation
// Copyright (c) 1996-1997  Cirrus Logic, Inc.,
// All rights reserved.
//
//  date: 1 July 1993
//---------------------------------------------------------------------------
// The maximum GDI ESCAPE value defined in WINGDI.H is 4110(decimal). So here
// we pick an arbitrary value of...
//
// *chu01 : 12-16-96   Enable color correction
// *myf17 : 10-29-96 supported special Escape call
// *myf28 : 01-23-96 supported 755x gamma correction
// *

#define CIRRUS_PRIVATE_ESCAPE   0x5000

//myf17 begin
#define CLESCAPE_CRT_CONNECTION 0x5001
#define CLESCAPE_SET_VGA_OUTPUT 0x5002
#define CLESCAPE_GET_VGA_OUTPUT 0x5003
#define CLESCAPE_GET_PANEL_SIZE 0x5004
#define CLESCAPE_PANEL_MODE     0x5005
//myf17 end

//
// chu01 : GAMMACORRECT
//
#define CLESCAPE_GAMMA_CORRECT      0x2328                            // 9000
#define CLESCAPE_GET_CHIPID         0x2329                            // 9001
//myf28 : 755x gamma correction
#define CLESCAPE_WRITE_VIDEOLUT     0x2332      //myf28, 9010

//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an
// arbitrary value of 0x900=2304.
//
#define IOCTL_CIRRUS_GET_CAPABILITIES  \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_SET_DISPLAY_PITCH \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// chu01 : GAMMACORRECT
//
#define IOCTL_CIRRUS_GET_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_GET_CONTRAST_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)

//myf28
#define IOCTL_CIRRUS_GET_755x_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)


//---------------------------------------------------------------------------
// Structure for miniport to indicate to display driver the capabilities
// of the chip.  The flag currently indicates HW Cursor and BLT Engine
// support.
//
// Also included is the size of memory, and the top of available offscreen
// memory. (Actually it's top+1).
//
typedef struct {
   ULONG size;              // size of this structure
   ULONG fl;                // see bit description below
   ULONG ulChipId;          // Chip ID read from CR27[7:2] - e.g CL5434 = 0x2A
   ULONG ulMemSize;         // Size of memory in bytes=end of HW cursor buffers
   ULONG ulOffscreenMemTop; // Offset of 1st byte of unusable video memory
                            // [1st byte of cursor buffers on all but 754x]
                            // [1st byte of split screen buffer on 754x]
} CIRRUS_CAPABILITIES, *PCIRRUS_CAPABILITIES;

//#define CL_ALLOW_HW_CURSOR 0x01     // Flag to enable HW Cursor in
//capabilities
//#define CL_BLT_SUPPORT 0x02         // Flag set if chip has BLT Engine
//support
//#define CL_ALLOW_OPAQUE_TEXT 0x04   // Flag to enable HW Cursor in
//capabilities
//#define CL_LINEAR_MODE 0x08         // Flag set if addressing mode is linear
//#define CL_CURSOR_VERT_EXP 0x10     // Flag set if 8x6 panel, 6x4 resolution
//#define CL_DSTN_PANEL      0x20     // Flag set if DSTN panel connect

//---------------------------------------------------------------------------
//
// this is the structure used to pass arguments to the CIRRUS_PRIVATE_ESCAPE
// call done in DrvEscape(). The size of this struct limits the size of the
// returned arguments also. See the DrvEscape() function in enable.c (in the
// display driver DLL) for more information.
//
// NOTE: to enable the definition of these parameters, the following sequence
//       is recommended!
//
// #define ENABLE_BIOS_ARGUMENTS    // put this before the include
// #include "clioctl.h"


#ifdef ENABLE_BIOS_ARGUMENTS

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\ddc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This module contains the code that support DDC querying..

Environment:

    Kernel mode

Revision History:

--*/

#include <dderror.h>
#include <devioctl.h>                           
#include <miniport.h>
                                                        
#include <ntddvdeo.h>                        
#include <video.h>

#include <cirrus.h>

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);

VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);

/****************************************************************
;       DDC register
;
;       Controls the individual toggling of bits in Sr8 to produce
;       clock and data pulses.
;
;       Sr8 is defined as follows:
;
;       7  ...  2   1   0    SCW = CLK  Write
;     |---|---|---|---|---|  SDW = DATA Write
;     |SDR ...|SCR|SDW|SCW|  SCR = CLK  Read
;     ---------------------  SDR = DATA Read
;
;****************************************************************/

#define DDC_PORT    (HwDeviceExtension->IOAddress + SEQ_DATA_PORT)
#define STATUS_PORT (HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR)

#define VSYNC_ACTIVE    0x08

VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the clock line.
    //

    ucPortData = (VideoPortReadPortUchar(DDC_PORT) & 0xFE) | ucData;

    VideoPortWritePortUchar(DDC_PORT, ucPortData);
}

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the data line.
    //

    ucPortData = (VideoPortReadPortUchar(DDC_PORT) & 0xFD) | (ucData << 1);

    VideoPortWritePortUchar(DDC_PORT, ucPortData);
}

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR uc;

    uc = VideoPortReadPortUchar(DDC_PORT);

    //VideoDebugPrint((0, "Read = 0x%x\n", uc));

    return ((VideoPortReadPortUchar(DDC_PORT) & 0x04) >> 2);
}


BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR uc;

    uc = VideoPortReadPortUchar(DDC_PORT);

    //VideoDebugPrint((0, "Read = 0x%x\n", uc));

    return ((VideoPortReadPortUchar(DDC_PORT) & 0x80) >> 7);
}

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    while ((VideoPortReadPortUchar(STATUS_PORT) & VSYNC_ACTIVE) != 0);
    while ((VideoPortReadPortUchar(STATUS_PORT) & VSYNC_ACTIVE) == 0);
}


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize)

/*++

Routine Description:

    Reads the basic EDID structure from the monitor using DDC2.

Arguments:

    HwDeviceExtension - Points to per-adapter device extension.

    QueryBuffer       - Buffer where information will be stored.

    BufferSize        - Size of the buffer to fill.

Return Value:

    Whether the call succeeded or not.

--*/

{
    UCHAR ucData;

    BOOLEAN       bRet = FALSE;
    I2C_FNC_TABLE i2c;
    ULONG         i;

    UCHAR OldSeqIdx;
    UCHAR ucSr6;
    UCHAR ucSr8;

	// workaround for Cirrus HW problem (part 1/2)
	static UCHAR onceQueryBuffer [512]; // EDID length is expected to be 128 or 256 bytes
	static UCHAR onceReadAttempt = FALSE;
	static UCHAR onceReturnedValue;
	
	if (onceReadAttempt) {
		VideoDebugPrint((1, "CIRRUS: ONCE READ => returning previously obtained data\n"));
        if (BufferSize > 512) {
            return FALSE;
        }
		memcpy (QueryBuffer, onceQueryBuffer, BufferSize);
		return onceReturnedValue;
	}
	// end of the workaround (part 1/2)

    OldSeqIdx = VideoPortReadPortUchar(HwDeviceExtension->IOAddress
                    + SEQ_ADDRESS_PORT);

    //
    // Make sure the extension registers are unlocked.
    //

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x6);

    ucSr6 = VideoPortReadPortUchar(
                HwDeviceExtension->IOAddress + SEQ_DATA_PORT);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        0x12);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x08);

    ucSr8 = VideoPortReadPortUchar(
                HwDeviceExtension->IOAddress + SEQ_DATA_PORT);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        (UCHAR)(ucSr8 | 0x40));

    i2c.WriteClockLine = WriteClockLine;
    i2c.WriteDataLine  = WriteDataLine;
    i2c.ReadClockLine  = ReadClockLine;
    i2c.ReadDataLine   = ReadDataLine;
    i2c.WaitVsync      = WaitForVsyncActive;

    i2c.Size = sizeof(I2C_FNC_TABLE);

    // 5430/5440 has a problem doing DDC unless we wait for vsync first.
                                                                        
    if (HwDeviceExtension->ChipType == CL543x && HwDeviceExtension->ChipRevision == CL5430_ID)
    {
         WaitForVsyncActive(HwDeviceExtension);
	}

    bRet = VideoPortDDCMonitorHelper(HwDeviceExtension,
                                     &i2c,
                                     QueryBuffer,
                                     BufferSize);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x08);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        ucSr8);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x6);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        ucSr6);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        OldSeqIdx);

	// workaround for Cirrus HW problem (part 2/2)
	onceReadAttempt = TRUE;
	onceReturnedValue = bRet;

	VideoDebugPrint((1, "CIRRUS: first EDID reading attempt "));
	if (onceReturnedValue)
		VideoDebugPrint((1, "succeeded"));
	else
		VideoDebugPrint((1, "failed"));
	VideoDebugPrint((1, " - the result saved\n"));
	memcpy (onceQueryBuffer, QueryBuffer, BufferSize);
	// end of the workaround (part 1/2)

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\clpanel.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    CLPANEL.C

Abstract:

    This routine accesses panning scrolling information from the following
    NT 4.0 laptop.

Environment:

    Kernel mode only

Notes:
*
* myf28 :02-03-97 : Fixed NT3.51 PDR#8357, mode 3, 12, panning scrolling bug,
*                   and move 4 routine from modeset.c to clpanel.c
* myf29 :02-12-97 : Support Gamma correction graphic/video LUT for 755x
* myf30 :02-10-97 : Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
* myf31 :03-12-97 : XGA DSTN panel can't support 24bpp mode for 7556
* myf32 :03-11-97 : check expension on, disable HW cursor fot 755x
* myf33 :03-21-97 : check TV on, disable HW video & HW cursor, PDR #9006
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"


// crus
#define DSTN       (Dual_LCD | STN_LCD)
#define DSTN10     (DSTN | panel10x7)
#define DSTN8      (DSTN | panel8x6)
#define DSTN6      (DSTN | panel)
#define PanelType  (panel | panel8x6 | panel10x7)
#define ScreenType (DSTN | PanelType)

SHORT Panning_flag = 0;
//myf1, begin
//#define PANNING_SCROLL

#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

PANNMODE PanningMode = {1024, 768, 1024, 8, -1 };

#endif
extern UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11

//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------
//myf28   VP_STATUS
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
//  VIDEOMODE* RequestedMode,
    ULONG RequestedModeNum
    );

VOID                                    //myf11
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );

ULONG
GetPanelFlags(                                 //myf17
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

// LCD Support
USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,SetLaptopMode)
#pragma alloc_text(PAGE,AccessHWiconcursor)          //myf11, crus
#pragma alloc_text(PAGE,GetPanelFlags)          //myf17
#pragma alloc_text(PAGE,CheckLCDSupportMode)
#endif




//myf28  VP_STATUS
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
//  VIDEOMODE* RequestedMode,
    ULONG RequestedModeNum
    )

/*++

Routine Description:

    This routine sets the laptop mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{
//  PVIDEOMODE pRequestedMode;
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    USHORT Int10ModeNumber;
//  ULONG RequestedModeNum;

    UCHAR originalGRIndex, tempB ;
    UCHAR SEQIndex ;
    SHORT i;    //myf1

    VideoDebugPrint((1, "Miniport - SetLaptopMode\n")); //myfr

//  pRequestedMode = (PVIDEOMODE) RequestedMode;
    // Set SR14 bit 2 to lock panel, Panel will not be turned on if setting
    // this bit.  For laptop products only.
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    if ((HwDeviceExtension->ChipType == CL756x) ||
        (HwDeviceExtension->ChipType & CL755x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType & CL754x))
    {
//myf33: check TV on, disable HW video & HW cursor, PDR #9006
        biosArguments.Eax = 0x12FF;
        biosArguments.Ebx = 0xB0;     // set/get TV Output
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
        if ((biosArguments.Eax & 0x0003) &&
            (biosArguments.Ebx & 0x0100))
        {
            HwDeviceExtension->CursorEnable = FALSE;
            HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
        }
//myf33: check TV on, disable HW video & HW cursor, PDR #9006

        biosArguments.Eax = pRequestedMode->BiosModes.BiosModeCL542x;
        biosArguments.Eax |= 0x1200;
        biosArguments.Eax &= 0xFF7F;    //myf1
        biosArguments.Ebx = 0xA0;     // query video mode availability
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

#ifdef PANNING_SCROLL
        if (PanningMode.flag == -1)
        {
            PanningMode.hres = pRequestedMode->hres;
            PanningMode.vres = pRequestedMode->vres;
            PanningMode.wbytes = pRequestedMode->wbytes;
            PanningMode.bpp = pRequestedMode->bitsPerPlane;
            PanningMode.flag = 0;
            Panning_flag = 0;
        }
#endif  //PAANNING_SCROLL

//crus
        // bit0=1:video mode support
        if ((HwDeviceExtension->ChipType == CL6245) &&
            !(biosArguments.Eax & 0x0100))
        {
            return ERROR_INVALID_PARAMETER;
        }

        // fix CL6245 bug -- In 640x480x256C mode, with DSTN panel,
        // 512K bytes memory is not enought

        else if ((HwDeviceExtension->ChipType == CL6245) &&
                 (biosArguments.Eax & 0x0500) &&
                 (pRequestedMode->BiosModes.BiosModeCL542x == 0x5F) &&
//myf28          (pRequestedMode->DisplayType & DSTN))
                 (HwDeviceExtension->DisplayType & DSTN))       //myf28
        {
            return ERROR_INVALID_PARAMETER;
        }

//myf27: 1-9-97 fixed connect XGA panel, set 64K color mode for 754x, begin
        else if ((HwDeviceExtension->ChipType & CL754x) &&
                 (biosArguments.Eax & 0x0400) &&
//myf27          (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x64) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x65) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x74)) &&
//myf28          (pRequestedMode->DisplayType & (TFT_LCD | panel10x7)) )
                 ((HwDeviceExtension->DisplayType & (TFT_LCD | panel10x7)) ==
                     (TFT_LCD | panel10x7)) )//myf28
        {
            return ERROR_INVALID_PARAMETER;
        }
        else if ((HwDeviceExtension->ChipType & CL754x) &&
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x64) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x65) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x74)) &&
                 (biosArguments.Eax & 0x0400) &&
//myf27          (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
//myf28          ((pRequestedMode->DisplayType & DSTN8) ||
//myf28           (pRequestedMode->DisplayType & DSTN10)) )
                 (((HwDeviceExtension->DisplayType & DSTN8) ==DSTN8) || //myf28
                  ((HwDeviceExtension->DisplayType & DSTN10)==DSTN10))) //myf28
        {
            return ERROR_INVALID_PARAMETER;
        }
//myf28 begin
        else if ((pRequestedMode->BiosModes.BiosModeCL542x == 0x03) ||
                 (pRequestedMode->BiosModes.BiosModeCL542x == 0x12))
        {
            goto PANNING_OVER;
        }
//myf31:3-12-97, XGA DSTN panel can't support 24bpp mode for 7556
        else if ((HwDeviceExtension->ChipType & CL755x) &&
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x71) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x78) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x79) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x77)) &&
                 (biosArguments.Eax & 0x0400) &&
                  ((HwDeviceExtension->DisplayType & DSTN10)==DSTN10))
        {
            return ERROR_INVALID_PARAMETER;
        }
//myf31 end

//myf28 end
//myf27: 1-9-97 fixed connect DSTN panel, set 64K color mode for 754x, end


        //
        // bit3=1:panel support, bit2=1:panel enable,
        // bit1=1:crt enable(in AH)
        //
        //panel turn on, mode not support (1)

        else if ((biosArguments.Eax & 0x0400) &&
            (HwDeviceExtension->ChipType != CL6245) &&
            !(biosArguments.Eax & 0x0800))
        {
#ifndef PANNING_SCROLL                  //myf1
            return ERROR_INVALID_PARAMETER;
#else
//myf1, begin
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&    //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];       //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((PanningMode.bpp != pRequestedMode->bitsPerPlane) &&
                           (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
//myf30 begin
                           PanningMode.flag = 1;
                           Panning_flag = 1;
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
//myf30 end
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
#if 1   //myf18 add
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
#endif
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       break;
                   }
                   i ++;
               }
            }

#endif
//myf1, end
        }
        //panel turn off, mode not support (2)
        else if (!(biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 !(biosArguments.Eax & 0x0400))
        {
//myf1, begin
#ifdef PANNING_SCROLL
            PanningMode.flag = 0;
            Panning_flag = 0;
#if 0
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&             //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];        //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((PanningMode.bpp != pRequestedMode->bitsPerPlane) &&
                           (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                           break;
                   }
                   i ++;
               }
            }

#endif  //0
#else
//myf1, end

            //
            // Lock turn on panel
            //

            SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, 0x14);
            tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT) | 0x04;
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT,tempB);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, SEQIndex);

#endif  //myf1, ifdef PANNING_SCROLL
        }

//myf1, begin
        //panel turn on, mode support (3)
        else if ((biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 (biosArguments.Eax & 0x0400))
        {
#ifdef PANNING_SCROLL
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&    //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];        //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
//myf26, begin
            else if ((pRequestedMode->hres == 640) &&
                (pRequestedMode->vres == 480) &&
                (pRequestedMode->bitsPerPlane == 1) &&
                ((HwDeviceExtension->ChipType & CL754x) ||
                (HwDeviceExtension->ChipType & CL755x) ||       //myf32
                (HwDeviceExtension->ChipType == CL756x)))
            {
                pRequestedMode->Frequency = 60;
                PanningMode.hres = pRequestedMode->hres;
                PanningMode.vres = pRequestedMode->vres;
                PanningMode.wbytes = pRequestedMode->wbytes;
                PanningMode.bpp = pRequestedMode->bitsPerPlane;
                PanningMode.flag = 0;
                Panning_flag = 0;

                pRequestedMode =
                      &ModesVGA[ResolutionTable[0].ModesVgaStart];
                RequestedModeNum =
                      ResolutionTable[0].ModesVgaStart;
                                         //myf12
                pRequestedMode->Frequency = 60;
                ViewPoint_Mode = ResolutionTable[0].Mode;
            }
//myf26, end
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((pRequestedMode->hres < biosArguments.Ebx) &&
                           (pRequestedMode->vres < biosArguments.Eax))
                       {
#if 1   //myf18 add
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
#endif//myf18
                            Panning_flag = 0;
                            PanningMode.flag = 0;
                       }
                       else if ((PanningMode.bpp !=
                                     pRequestedMode->bitsPerPlane) &&
                                (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
                           if ((pRequestedMode->hres<ResolutionTable[i].Hres)||
                               (pRequestedMode->vres <ResolutionTable[i].Vres))
                           {
                                while ((ResolutionTable[i].Hres !=
                                                  pRequestedMode->hres) &&
                                       (ResolutionTable[i].Vres !=
                                                  pRequestedMode->vres))
                                {
                                    if ((pRequestedMode->bitsPerPlane ==
                                           ResolutionTable[i].BitsPerPlane) &&
                                        (ResolutionTable[i].Hres ==
                                                  pRequestedMode->hres) &&
                                        (ResolutionTable[i].Vres ==
                                                  pRequestedMode->vres))
                                    {
#if 1   //myf18 add
                                       PanningMode.hres = pRequestedMode->hres;
                                       PanningMode.vres = pRequestedMode->vres;
                                       PanningMode.wbytes = pRequestedMode->wbytes;
                                       PanningMode.bpp = pRequestedMode->bitsPerPlane;
                                       PanningMode.flag = 1;
#endif

                                        pRequestedMode =
                                             &ModesVGA[ResolutionTable[i].ModesVgaStart];
                                        RequestedModeNum =
                                             ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                                        pRequestedMode->Frequency = 60;
                                        ViewPoint_Mode = ResolutionTable[i].Mode;
                                        break;
                                    }
                                    i ++;
                                }
                           }
                           else
                           {
#if 1   //myf18 add
                              PanningMode.hres = pRequestedMode->hres;
                              PanningMode.vres = pRequestedMode->vres;
                              PanningMode.wbytes = pRequestedMode->wbytes;
                              PanningMode.bpp = pRequestedMode->bitsPerPlane;
                              PanningMode.flag = 1;
#endif
                               pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                               pRequestedMode->Frequency = 60;
                               ViewPoint_Mode = ResolutionTable[i].Mode;
                           }
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       break;
                   }
                   i ++;
               }
            }

#endif
//myf1, end
        }

//myf1, begin
        //panel turn off, mode support (4)
        else if ((biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 !(biosArguments.Eax & 0x0400))
        {
#ifdef PANNING_SCROLL
#if 1
//myf18     if (PanningMode.flag == -1)
            {
                PanningMode.hres = pRequestedMode->hres;
                PanningMode.vres = pRequestedMode->vres;
                PanningMode.wbytes = pRequestedMode->wbytes;
                PanningMode.bpp = pRequestedMode->bitsPerPlane;
                PanningMode.flag = 0;
                Panning_flag = 0;
            }
#endif
#else
//myf18
            //
            // UnLock turn on panel
            //

            SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, 0x14);
            tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT) & 0xFB;
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT,tempB);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, SEQIndex);
//myf18 end

#endif
        }
//myf1, end

//myf4: patch Viking BIOS bug, PDR #4287, begin
/*
        else if ((biosArguments.Eax & 0x0800) && !(biosArguments.Eax & 0x0400)
                  && (HwDeviceExtension->ChipType & CL754x))
        {
        //by self check panel if or not supported
//myf16, begin
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // query panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if (status == NO_ERROR)
            {
                if ( (((biosArguments.Ebx & 0x0000FFFF) == 640) &&
                      (pRequestedMode->vres > 480)) ||  //6x4 VGA
                     (((biosArguments.Ebx & 0x0000FFFF) == 800) &&
                      (pRequestedMode->vres > 600)) ||  //8x6 SVGA
                     (((biosArguments.Ebx & 0x0000FFFF) == 1024) &&
                      (pRequestedMode->vres > 768)) )   //10x7 XGA
                {

//myf16, end
                SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress+
                            SEQ_ADDRESS_PORT);
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x14);
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                         SEQ_DATA_PORT,
                         (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         SEQ_DATA_PORT) | 0x04));
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                         SEQ_ADDRESS_PORT, SEQIndex);
                }
            }
        }
 */
//myf4: patch Viking BIOS bug, PDR #4287, end
    }

#ifdef PANNING_SCROLL
     VideoDebugPrint((1, "Info on Panning Mode:\n"
                        "\tResolution: %dx%dx%d (%d bytes) -- %x\n",
                        PanningMode.hres,
                        PanningMode.vres,
                        PanningMode.bpp,
                        PanningMode.wbytes,
                        ViewPoint_Mode ));
#endif

    //
    // Set the Vertical Monitor type, if BIOS supports it
    //

    if ((pRequestedMode->MonTypeAX) &&
        ((HwDeviceExtension->ChipType & CL754x) ||
         (HwDeviceExtension->ChipType == CL756x) ||
         (HwDeviceExtension->ChipType == CL6245) ||
         (HwDeviceExtension->ChipType & CL755x)) )
    {

        //
        // Re-write this part.
        //

        biosArguments.Eax = 0x1200;
        biosArguments.Ebx = 0x9A;
        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR)
        {
            return status;
        }
        else
        {
            biosArguments.Eax = ((biosArguments.Ecx >> 4) & 0x000F);

//myf5 : 9-01-96, PDR #4365 keep all default refresh rate, begin

            biosArguments.Eax |= (biosArguments.Ebx >> 8) & 0x0030; //VGA
            biosArguments.Ebx = 0x00A4;
            biosArguments.Ebx |= (biosArguments.Ecx & 0xFF00); //XGA, SVGA
            biosArguments.Ecx = (biosArguments.Ecx & 0x000E) << 11; //12x10
//myf5 : 9-01-96, PDR #4365, end

            if (pRequestedMode->vres == 480)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Eax &= 0xFFCF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Eax |= 0x30;          //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Eax |= 0x20;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Eax |= 0x10;
            }
            else if (pRequestedMode->vres == 600)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ebx &= 0xF0FF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ebx |= 0x0400;        //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Ebx |= 0x0300;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Ebx |= 0x0200;
                else if (pRequestedMode->Frequency == 60)
                    biosArguments.Ebx |= 0x0100;
            }
            else if (pRequestedMode->vres == 768)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ebx &= 0x0FFF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ebx |= 0x5000;        //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Ebx |= 0x4000;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Ebx |= 0x3000;
                else if (pRequestedMode->Frequency == 70)
                    biosArguments.Ebx |= 0x2000;
                else if (pRequestedMode->Frequency == 60)
                    biosArguments.Ebx |= 0x1000;
            }
            else if (pRequestedMode->vres == 1024)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ecx &= 0x0FFF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 45)
                    biosArguments.Ecx |= 0x0000;
                else if (pRequestedMode->Frequency == 60)    //myf0
                    biosArguments.Ecx |= 0x1000;        //myf0
                else if (pRequestedMode->Frequency == 72)    //myf0
                    biosArguments.Ecx |= 0x2000;        //myf0
                else if (pRequestedMode->Frequency == 75)    //myf0
                    biosArguments.Ecx |= 0x3000;        //myf0
                else if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ecx |= 0x4000;        //myf0
            }
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if (status != NO_ERROR)
            {
                return status;
            }
        }
    }

    HwDeviceExtension->bCurrentMode = RequestedModeNum;   //myf12
    //VideoDebugPrint((0, "SetMode Info :\n"
    //                    "\tMode : %x, CurrentModeNum : %x, ( %d)\n",
    //                    Int10ModeNumber,
    //                    RequestedModeNum,
    //                    RequestedModeNum));
PANNING_OVER:

    return NO_ERROR;
    //return(pRequestedMode);

} //end SetLaptopMode()

//myf11 : begin
VOID
AccessHWiconcursor(
//  PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    )

/*++

Routine Description:

    This routine determines disable/enable HW icon & HW cursor

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Access_flag - equal 0: Disable, equal 1: Enable.

Return Value:

    none

--*/

{
    UCHAR  savSEQidx;

    savSEQidx = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       SEQ_ADDRESS_PORT);
    if (Access_flag)            //Enable hw icon/cursor
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x12);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWcur);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2A);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon0);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2B);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon1);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2C);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon2);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2D);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon3);
    }
    else                        //Disable HW cursor, icons
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x12);
        HWcur = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWcur & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2A);
        HWicon0 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon0 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2B);
        HWicon1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon1 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2C);
        HWicon2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon2 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2D);
        HWicon3 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon3 & 0xFE));


    }
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, savSEQidx);

} // end AccessHWiconcursor()
//myf11 : end


//crus begin
//myf10, begin
ULONG
GetPanelFlags (
    PHW_DEVICE_EXTENSION HwDeviceExtension
 )
{
    ULONG ChipType = HwDeviceExtension->ChipType;
    ULONG ulFlags  = 0;
    UCHAR  savSEQidx, Panel_Type =0, LCD;
    ULONG  ulCRTCAddress, ulCRTCData;
//myf16, begin
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1280;
    biosArguments.Ebx = 0x9C;     // query panel information
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if (status == NO_ERROR)
    {
        if ((biosArguments.Eax & 0x00000002) == 2)
            Panel_Type = (UCHAR)1;      //DSTN panel
        if (((biosArguments.Ebx & 0x0000FFFF) == 640) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 480))
            ulFlags |= CAPS_VGA_PANEL;
        else if (((biosArguments.Ebx & 0x0000FFFF) == 800) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 600))
            ulFlags |= CAPS_SVGA_PANEL;
        else if (((biosArguments.Ebx & 0x0000FFFF) == 1024) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 768))
            ulFlags |= CAPS_XGA_PANEL;
    }

//myf33: check TV on, disable HW video & HW cursor, PDR #9006
    biosArguments.Eax = 0x12FF;
    biosArguments.Ebx = 0xB0;     // set/get TV Output
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if ((biosArguments.Eax & 0x0003) &&
        (biosArguments.Ebx & 0x0100))
    {
        ulFlags |= CAPS_TV_ON;
        ulFlags |= CAPS_SW_POINTER;
    }
    else
        ulFlags &= ~CAPS_TV_ON;

//myf33: check TV on, disable HW video & HW cursor, PDR #9006


#if 0
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    savSEQidx = VideoPortReadPortUchar(ulCRTCAddress);

    if ((ChipType & CL754x))  //7548/7543/7541
    {
        VideoPortWritePortUchar(ulCRTCAddress, 0x20);
        LCD = VideoPortReadPortUchar(ulCRTCData) & 0x20;
    }
    else if (ChipType & CL755x)         //7555
    {
        VideoPortWritePortUchar(ulCRTCAddress, 0x80);
        LCD = VideoPortReadPortUchar(ulCRTCData) & 0x01;
    }
    VideoPortWritePortUchar(ulCRTCAddress, savSEQidx);
#endif

    if (((ChipType & CL754x) || (ChipType & CL755x)) &&
        (Panel_Type == 1))      //myf20
    {
        ulFlags |= CAPS_DSTN_PANEL;
    }
//myf16, end

//ms1016, begin
//  if (HwDeviceExtension->DisplayType & (STN_LCD | TFT_LCD))
//  {
//      ulFlags |= CAPS_DSTN_PANEL;
//  }
//ms1016, end

    if ((Panning_flag) && ((ChipType & CL754x) || (ChipType & CL755x)))
    {
        ulFlags |= CAPS_PANNING;       //myf15
    }

   return(ulFlags);
}
//myf10, end

USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if LCD support the modes.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

//  DbgBreakPoint();
//  biosArguments.Eax = 0x1202;
//  biosArguments.Ebx = 0x92;     // set LCD & CRT turn on
//  status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
//  VideoDebugPrint((1, "LCD & CRT all Turn ON\n"));

// crus
#ifdef INT10_MODE_SET

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1200 | ModesVGA[i].BiosModes.BiosModeCL542x;
    biosArguments.Ebx = 0xA0;     // query video mode availability
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if (status == NO_ERROR)
    {
// crus
       if ((biosArguments.Eax & 0x00000800) &&         //bit3=1:support
           (HwDeviceExtension->ChipType != CL6245))
          return TRUE ;
// crus
       else if ((biosArguments.Eax & 0x00000100) &&     //bit0=1:video support
                (HwDeviceExtension->ChipType == CL6245))
          return TRUE ;
// end crus
       else
       {
          return FALSE ;
       }
    }
    else
       return FALSE ;
// crus
#endif

} // end CheckLCDSupportMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\mode6420.h ===
/*++

Copyright (c) 1992  Cirrus Logic, Inc.

Module Name:

    Mode6420.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
    CL-6420 driver.

Environment:

    Kernel mode

Revision History:

--*/

//---------------------------------------------------------------------------
// The next set of tables are for the CL6420
// Note: all resolutions supported
//
USHORT CL6420_640x480_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

 
    EOD
};
USHORT CL6420_640x480_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
// 800x600 16-color (60Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
#ifndef INT10_MODE_SET

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7F,0x63,0x64,0x82,
    0x6b,0x1d,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xac,0x57,0x32,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x1b64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 6420.
// Requires 512K minimum.
//
USHORT CL6420_1024x768_crt[] = {

// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0bc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2b,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7f,0x80,0x9c,
    0x83,0x19,0x2f,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x00,0xa4,0xff,0x3f,
    0x00,0x00,0x2f,0xe3,
    0xFF,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x1c62,               // ER62 horz. display end extension
        0x1964,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x4c7a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x8391,               // ER91 CRT-circular buffer policy select
        0x0295,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
  
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

USHORT CL6420_80x25_14_Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
USHORT CL6420_80x25_14_Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
                            
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//


USHORT CL6420_80x25Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x00,0x00,
    0x9c,0x8e,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x8082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x00,0x0F,0x8,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6420_80x25Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x00,0x00,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x00,0x0F,0x8,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//---------------------------------------------------------------------------
// 256 color tables
//---------------------------------------------------------------------------
//
// 800x600 256-color (60Hz refresh) mode set command string for CL 6420.
// requires 512k minimum
//
USHORT CL6420_640x480_256color_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xc3,0x9F,0xa0,0x86,
    0xa4,0x10,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x50,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x2662,               // ER62 horz. display end extension
        0x1064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0a82,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0x05c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x06,0x07,0x08,0x09,
    0x0A,0x0B,0x0C,0x0D,0x0E,
    0x0F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6420_640x480_256color_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xc3,0x9F,0xa0,0x86,
    0xa4,0x10,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x50,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x2662,               // ER62 horz. display end extension
        0x1064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8a82,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0xa5c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x06,0x07,0x08,0x09,
    0x0A,0x0B,0x0C,0x0D,0x0E,
    0x0F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 800x600 256-color (60Hz refresh) mode set command string for CL 6420.
// requires 512k minimum
//
USHORT CL6420_800x600_256color_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2f,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x03,0xc7,0xc8,0x86,
    0xdc,0x0c,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x5a,0xac,0x57,0x64,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x2662,                   // ER62 horz. display end extension
    0x2c64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0a82,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0895,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x20a1,                   // ERa1 three-state and test control
    0x05c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif

// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

     EOD
};

//
// 1024x768 256-color (60Hz refresh) mode set command string for CL 6420.
// Requires 1Meg minimum.
//
USHORT CL6420_1024x768_256color_crt[] = {

// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x23,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x39,0xff,0x00,0x9c,
    0x06,0x91,0x26,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x04,0xa6,0xff,0x7f,
    0x00,0x00,0x26,0xe3,
    0xFF,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0xbc62,               // ER62 horz. display end extension
        0xf164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x997a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0a82,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0x05c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

#if MULTIPLE_REFRESH_TABLES
//
// 800x600 16-color (56Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_56Hz_crt[] = {
#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,
    0x69,0x92,0x6f,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xaa,0x57,0x32,
    0x00,0x58,0x6f,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x8c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x8391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};

//
// 800x600 16-color (72Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_72Hz_crt[] = {
#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7f,0x63,0x64,0x82,
    0x6b,0x1b,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xac,0x57,0x32,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x1b64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x8391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};
//
// 1024x768 16-color (43.5Hz refresh interlaced) mode set command string 
// for CL 6420.
// Requires 512K minimum.
//
USHORT CL6420_1024x768_I43Hz_crt[] = {

#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0bc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2b,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7f,0x80,0x9c,
    0x83,0x19,0x2f,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x00,0xa4,0xff,0x3f,
    0x00,0x00,0x2f,0xe3,
    0xff,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x1c62,               // ER62 horz. display end extension
        0x1964,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x4c7a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0295,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\mode6410.h ===
/*++

Copyright (c) 1992  Cirrus Logic, Inc.

Module Name:

    Mode6410.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
    CL-6410 driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The first set of tables are for the CL6410
// Note that only 640x480 and 800x600 are supported.
//
// Color graphics mode 0x12, 640x480 16 colors.
//
USHORT CL6410_640x480_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6410_640x480_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0xa684,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa0c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};



//
// Cirrus color graphics mode 0x64, 800x600 16 colors.
//
USHORT CL6410_800x600_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2f,

    OWM,                
    GRAPH_ADDRESS_PORT,
    3,
    0x0506,
    0x0f07,
    0xff08,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,
    0x69,0x92,0x6f,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xaa,0x57,0x32,
    0x00,0x58,0x6f,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//-----------------------------
// standard VGA text modes here
//-----------------------------

USHORT CL6410_80x25_14_Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x8164,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x1084,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0095,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
// 80x25 and 720 x 400
//

USHORT CL6410_80x25_14_Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
USHORT CL6410_80x25Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x8164,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x1084,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0095,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
// 80x25 and 720 x 400
//

USHORT CL6410_80x25Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\modeset.c ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation.
Copyright (c) 1996-1997 Cirrus Logic, Inc.

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the CL6410/20 miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:
*
* jl01   09-24-96  Fix Alt+Tab switching between "Introducing Windows NT"
*                  and "Main".  Refer to PDR#5409.
* chu01  08-26-96  CL-GD5480 BitBlt enhancement.
* chu02  10-06-96  Refresh rate setting for CL-GD5480 mode 7B
*                  ( 1600 x 1200 x 8 bpp )
* sge01  10-06-96  Fix PDR #6794: Correct Monitor refresh rate for 100Hz
*                  file changed: cldata.c modeset.c
* sge02  10-18-96  Add Monitor.Type Value name in registry
* chu03  10-31-96  Set Mode through registry.
* jl02   12-05-96  Comment out 5446 checking.
* chu04  12-16-96  Enable color correct.
*
* myf0   08-19-96  added 85hz supported
* myf1   08-20-96  supported panning scrolling
* myf2   08-20-96  fixed hardware save/restore state bug for matterhorn
* myf3   09-01-96  Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4   09-01-96  patch Viking BIOS bug, PDR #4287, begin
* myf5   09-01-96  Fixed PDR #4365 keep all default refresh rate
* myf6   09-17-96  Merged Desktop SRC1001 & MINI102
* myf7   09-19-96  Fixed exclude 60Hz refresh rate selected
* myf8  *09-21-96* May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9   09-21-96  8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809 09-25-96  fixed dstn panel icon corrupted
* ms923  09-25-96  merge MS-923 Disp.zip code
* myf10  09-26-96  Fixed DSTN reserved half-frame buffer bug.
* myf11  09-26-96  Fixed 755x CE chip HW bug, access ramdac before disable HW
*                  icons and cursor
* myf12  10-01-96  Supported Hot Key switch display
* myf13  10-05-96  Fixed /w panning scrolling, vertical expension on bug
* myf14  10-15-96  Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15  10-16-96  Fixed disable memory mapped IO for 754x, 755x
* myf16  10-22-96  Fixed PDR #6933,panel type set different demo board setting
* tao1   10-21-96  Added 7555 flag for Direct Draw support.
* smith  10-22-96  Disable Timer event, because sometimes creat PAGE_FAULT or
*                  IRQ level can't handle
* myf17  11-04-96  Added special escape code must be use 11/5/96 later NTCTRL,
*                  and added Matterhorn LF Device ID==0x4C
* myf18  11-04-96  Fixed PDR #7075,
* myf19  11-06-96  Fixed Vinking can't work problem, because DEVICEID = 0x30
*                  is different from data book (CR27=0x2C)
* myf20  11-12-96  Fixed DSTN panel initial reserved 128K memoru
* myf21  11-15-96  fixed #7495 during change resolution, screen appear garbage
*                  image, because not clear video memory.
* myf22  11-19-96  Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23  11-21-96  Added fixed NT 3.51 S/W cursor panning problem
* myf24  11-22-96  Added fixed NT 4.0 Japanese dos full screen problem
* myf25  12-03-96  Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                  fixed pre-install microsoft requested
* myf26  12-11-96  Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27  01-09-97  Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                  windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                  Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                  screen when boot up XGA panel.
*
* pat08            Previous changes that didn't make into drv1.11
* sge03  01-23-97  Fix 1280x1024x8 clock mismatch problem for video.
* myf28  02-03-97  Fixed NT dos full screen bug, and add new clpanel.c file
*                  PDR #8357,mode 3, 12, panning scrolling bug
* myf29  02-12-97  Support Gamma correction graphic/video LUT for 755x
* myf30  02-10-97  Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
* chu05  02-19-97  MMIO internal error.
* chu06  03-12-96  Remove SR16 overwrite for 5436 or later. This is requested
*                  by Siemens Europe.
* myf31  03-12-97  Fixed 755x vertical expension on(CR82), HW cursor bug
* myf33 :03-21-97  check TV on, disable HW video & HW cursor, PDR #9006
* chu07  03-26-97  Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
* chu08  03-26-97  Common routine to get Cirrus chip and revision IDs.
* myf34 :04-08-97  if Internal TV on, change Vres to 452 (480-28) lines.
* myf35 :05-08-97  fIXED 7548 vl-BUS bug for panning scrolling enable
*
--*/
//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
//#include <clmini.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "cmdcnst.h"

//
// Temporarily include defines from NTDDK.H which we can't
// currently include due to header file conflicts.
//

#include "clddk.h"

//crus
#ifndef VIDEO_MODE_MAP_MEM_LINEAR
#define VIDEO_MODE_MAP_MEM_LINEAR 0x40000000
#endif

// crus
#define DSTN       (Dual_LCD | STN_LCD)
#define DSTN10     (DSTN | panel10x7)
#define DSTN8      (DSTN | panel8x6)
#define DSTN6      (DSTN | panel)
#define PanelType  (panel | panel8x6 | panel10x7)
#define ScreenType (DSTN | PanelType)

extern UCHAR EDIDBuffer[]   ;
extern UCHAR EDIDTiming_I   ;
extern UCHAR EDIDTiming_II  ;
extern UCHAR EDIDTiming_III ;
extern UCHAR DDC2BFlag      ;
extern OEMMODE_EXCLUDE ModeExclude ;                                 // chu07

//crus begin
#if 0           //myf28
extern SHORT    Panning_flag;
//myf1, begin
//#define PANNING_SCROLL

#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

PANNMODE PanningMode = {1024, 768, 1024, 8, -1 };

#endif

extern UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11
#endif          //0,myf28

VOID                                    //myf11
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );

#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   );
#endif

ULONG
GetPanelFlags(                                 //myf17
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//myf28
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
    ULONG RequestedModeNum
    );
//myf1, end
//crus end

VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//crus
ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//crus
// LCD Support
USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

// DDC2B support
BOOLEAN
CheckDDC2B(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

VOID
AdjFastPgMdOperOnCL5424(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode
    );

// crus
// jl02 BOOLEAN
// jl02 CheckGD5446Rev(
// jl02     PHW_DEVICE_EXTENSION HwDeviceExtension
// jl02     );


//crus
VOID CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

//crus
BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

// chu03
BOOLEAN
VgaSetModeThroughRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode,
    USHORT hres,
    USHORT vres
    );

// chu07
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

// chu08
UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

// chu08
USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#if 0           //myf28
#ifdef PANNING_SCROLL
#pragma alloc_text(PAGE,CirrusSetDisplayPitch)       //myf1, crus
#endif
#pragma alloc_text(PAGE,SetLaptopMode)          //myf28
#pragma alloc_text(PAGE,AccessHWiconcursor)          //myf11, crus
#pragma alloc_text(PAGE,GetPanelFlags)          //myf17
#endif          //myf28
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#pragma alloc_text(PAGE,CirrusValidateModes)
#pragma alloc_text(PAGE,GetAttributeFlags)
//myf28 #pragma alloc_text(PAGE,CheckLCDSupportMode)
#pragma alloc_text(PAGE,CheckDDC2B)
#pragma alloc_text(PAGE,AdjFastPgMdOperOnCL5424)
// jl02 #pragma alloc_text(PAGE,CheckGD5446Rev)
//crus
#pragma alloc_text(PAGE,CheckAndUpdateDDC2BMonitor)
#pragma alloc_text(PAGE,CirrusDDC2BRegistryCallback)
#pragma alloc_text(PAGE,GetOemModeOffInfoCallBack)                   // chu07
#pragma alloc_text(PAGE,GetCirrusChipId)                             // chu08
#pragma alloc_text(PAGE,GetCirrusChipRevisionId)                     // chu08
#endif


// the following is defined in cirrus.c
VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG BankNumber
    );

//---------------------------------------------------------------------------
VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG  ulCmd;
    ULONG  ulPort;
    UCHAR  jValue;
    USHORT usValue;
    ULONG  culCount;
    ULONG  ulIndex;
    ULONG  ulBase;
// chu05
    UCHAR  i;
    USHORT tempW;


//  VideoDebugPrint((0, "Miniport - VgaInterpretCmdStream\n")); //myfr
    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = PtrToUlong(HwDeviceExtension->IOAddress);

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ULONG_PTR)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;

// chu05
                            if (!HwDeviceExtension->bMMAddress)
                            {
                                VideoPortWritePortBufferUshort((PUSHORT)(ULONG_PTR)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                                pusCmdStream += culCount;
                            }
                            else
                            {
                                for (i = 0; i < culCount; i++)
                                {
                                    tempW = *pusCmdStream ;
                                    VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort),
                                                            (UCHAR)tempW) ;
                                    VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort + 1),
                                                            (UCHAR)(tempW >> 8)) ;
                                    pusCmdStream++ ;
                                }
                            }

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort));

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)(ULONG_PTR)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)(ULONG_PTR)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort));
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort),
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()


VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )

/*++

Routine Description:

    This routine sets the vga into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEOMODE pRequestedMode;
    PUSHORT pusCmdStream;
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    USHORT Int10ModeNumber;
    ULONG RequestedModeNum;

// crus
    UCHAR originalGRIndex, tempB ;
    UCHAR SEQIndex ;
//crus
//myf28    SHORT i;    //myf1

// crus chu02
    ULONG ulFlags = 0 ;

// chu03, begin
    BOOLEAN result = 0 ;
    USHORT  hres, vres ;
//chu03 end

    //
    // Check if the size of the data in the input buffer is large enough.
    //
//  VideoDebugPrint((0, "Miniport - VgaSetMode\n")); //myfr

    if (ModeSize < sizeof(VIDEO_MODE))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Extract the clear memory, and map linear bits.
    //

    RequestedModeNum = Mode->RequestedMode &
        ~(VIDEO_MODE_NO_ZERO_MEMORY | VIDEO_MODE_MAP_MEM_LINEAR);


    if (!(Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY))
    {
#if defined(_X86_)
  #if (_WIN32_WINNT >= 0x0400)          //pat08
       //
       // Don't do the operation.  Some Intel servers mysteriously RESET them selves because of this
       //
       if ((HwDeviceExtension->ChipType & CL754x) == 0) //myf35, fix VL-bus bug
       {
          //VgaZeroVideoMemory(HwDeviceExtension);
       }
  #else                                                 //pat08
       if (((HwDeviceExtension->ChipType & CL754x) == 0) &&     //pat08
           ((HwDeviceExtension->ChipType & CL755x) == 0) )      //pat08
       {
           //VgaZeroVideoMemory(HwDeviceExtension);
       }
  #endif        //pat08
#endif
    }

    //
    // Check to see if we are requesting a valid mode
    //

    if ( (RequestedModeNum >= NumVideoModes) ||
         (!ModesVGA[RequestedModeNum].ValidMode) )
    {
        VideoDebugPrint((1, "Invalide Mode Number = %d!\n", RequestedModeNum));

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check to see if we are trying to map a non linear
    // mode linearly.
    //
    // We will fail early if we are trying to set a mode
    // with a linearly mapped frame buffer, and either of the
    // following two conditions are true:
    //
    // 1) The mode can not be mapped linearly because it is
    //    a vga mode, etc.
    //
    //    or,
    //
    // 2) We did not find the card in a PCI slot, and thus
    //    can not do linear mappings period.
    //

    VideoDebugPrint((1, "Linear Mode Requested: %x\n"
                        "Linear Mode Supported: %x\n",
                        Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR,
                        ModesVGA[RequestedModeNum].LinearSupport));

#if defined(_ALPHA_)

    //
    // For some reason if we map a linear frame buffer
    // for the 5434 and older chips on the alpha, we
    // die when we touch the memory.  However, if we map
    // a banked 64k frame buffer all works fine.  So,
    // lets always fail the linear frame buffer mode set
    // on alpha for older chips.
    //
    // For some reason which is also a mystery to me, we
    // can map the memory linearly for the 5446 and
    // newer chips.
    //

    if (Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) {

        if ((HwDeviceExtension->ChipRevision != CL5436_ID) &&
            (HwDeviceExtension->ChipRevision != CL5446_ID) &&
            (HwDeviceExtension->ChipRevision != CL5480_ID)) {

            return ERROR_INVALID_PARAMETER;
        }
    }

#endif

    if ((Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) &&
        ((!ModesVGA[RequestedModeNum].LinearSupport) ||
         (!VgaAccessRange[3].RangeLength)))
    {
        VideoDebugPrint((1, "Cannot set linear mode!\n"));

        return ERROR_INVALID_PARAMETER;
    }
    else
    {

#if defined(_X86_) || defined(_ALPHA_)

        HwDeviceExtension->LinearMode =
            (Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) ?
            TRUE : FALSE;

#else

        HwDeviceExtension->LinearMode = TRUE;

#endif

        VideoDebugPrint((1, "Linear Mode = %s\n",
                            Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR ?
                            "TRUE" : "FALSE"));         //myfr, 1
    }

    VideoDebugPrint((1, "Attempting to set mode %d\n",
                        RequestedModeNum));

    pRequestedMode = &ModesVGA[RequestedModeNum];

    VideoDebugPrint((1, "Info on Requested Mode:\n"
                        "\tResolution: %dx%dx%d\n",
                        pRequestedMode->hres,
                        pRequestedMode->vres,
                        pRequestedMode->bitsPerPlane ));        //myfr, 2


#ifdef INT10_MODE_SET
    //
    // Set SR14 bit 2 to lock panel, Panel will not be turned on if setting
    // this bit.  For laptop products only.
    //

//myf28 begin
    if ((HwDeviceExtension->ChipType == CL756x) ||
        (HwDeviceExtension->ChipType &  CL755x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType &  CL754x))
    {
        status = SetLaptopMode(HwDeviceExtension,pRequestedMode,
                               RequestedModeNum);
#if 0
        if ((status == ERROR_INVALID_PARAMETER) ||
            (status == ERROR_INSUFFICIENT_BUFFER))
            return status;
        else
            pRequestedMode = (PVIDEOMODE)status;
#endif

        if (status != NO_ERROR) {
            return status;
        }
    }
//myf28 end

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    //
    // first, set the montype, if valid
    //

    if ((pRequestedMode->MonitorType) &&
        !(HwDeviceExtension->ChipType &  CL754x) &&
        (HwDeviceExtension->ChipType != CL756x) &&
// crus
        (HwDeviceExtension->ChipType != CL6245) &&
        !(HwDeviceExtension->ChipType & CL755x) )
    {

       biosArguments.Eax = 0x1200 | pRequestedMode->MonitorType;
       biosArguments.Ebx = 0xA2;     // set monitor type command

       status = VideoPortInt10(HwDeviceExtension, &biosArguments);

       if (status != NO_ERROR)
           return status;

    }

    //
    // Set the Vertical Monitor type, if BIOS supports it
    //

    if ((pRequestedMode->MonTypeAX) &&
        !(HwDeviceExtension->ChipType & CL754x) &&
        (HwDeviceExtension->ChipType != CL756x) &&
// crus
        (HwDeviceExtension->ChipType != CL6245) &&
        !(HwDeviceExtension->ChipType & CL755x) )
    {
        biosArguments.Eax = pRequestedMode->MonTypeAX;
        biosArguments.Ebx = pRequestedMode->MonTypeBX;  // set monitor type
        biosArguments.Ecx = pRequestedMode->MonTypeCX;
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR)
        {
            return status;
        }
// crus
// chu02
#if 0
        ulFlags = GetAttributeFlags(HwDeviceExtension) ;
        if ((ulFlags & CAPS_COMMAND_LIST) &&
            (pRequestedMode->hres == 1600) &&
            (pRequestedMode->bitsPerPlane == 8))
        {
            switch (pRequestedMode->Frequency)
            {
                UCHAR tempB ;

                case 60 :
                    // o 3c4 14
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x14) ;
                    // i 3c5 tempB
                    tempB = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
                    tempB &= 0x1F ;
                    tempB |= 0x20 ;
                    // o 3c5 tempB
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, tempB) ;
                    break ;

                case 70 :
                    // o 3c4 14
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x14) ;
                    // i 3c5 tempB
                    tempB = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
                    tempB &= 0x1F ;
                    tempB |= 0x40 ;
                    // o 3c5 tempB
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, tempB) ;
                    break ;
            }
        }
#endif // 0

    }

   //
   // for 640x480 modes, determine the refresh type
   //

   if (pRequestedMode->hres == 640)
   {
       if (!(HwDeviceExtension->ChipType & CL754x) &&
           (HwDeviceExtension->ChipType != CL756x) &&
//crus
           (HwDeviceExtension->ChipType != CL6245) &&
           !(HwDeviceExtension->ChipType & CL755x) )
       {
           if (HwDeviceExtension->ChipType == CL543x)
           {

               switch (pRequestedMode->Frequency) {

                   case 72 :
                       biosArguments.Eax = 0x1200;     // set HIGH refresh to 72hz
                       break;

                   case 75:
                       biosArguments.Eax = 0x1201;     // set HIGH refresh to 75hz
                       break;

                   case 85:
                       biosArguments.Eax = 0x1202;     // set HIGH refresh to 85hz
                       break;
// crus
// sge01
                   case 100:
                       biosArguments.Eax = 0x1203;     // set HIGH refresh to 100hz
                       break;
               }
               biosArguments.Ebx = 0xAF;         // set refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

               biosArguments.Eax = 0x1200;
               biosArguments.Ebx = 0xAE;         // get refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

           } else {

               if (pRequestedMode->Frequency == 72)
               {
                   // 72 hz refresh setup only takes effect in 640x480
                   biosArguments.Eax = 0x1201;   // enable HIGH refresh
               }
               else
               {
                   // set low refresh rate
                   biosArguments.Eax = 0x1200;   // enable LOW refresh, 640x480 only
               }
               biosArguments.Ebx = 0xA3;         // set refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

           }
           if (status != NO_ERROR)
           {
               return status;
           }
       }

    }

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    //
    // then, set the mode
    //

    switch (HwDeviceExtension->ChipType)
    {
       case CL6410:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL6410;
           break;

       case CL6420:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL6420;
           break;

       case CL542x:
       case CL543x:     //myf1
//crus
           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL542x;
           break;

       case CL754x:
       case CL755x:
       case CL7541:
       case CL7542:
       case CL7543:
       case CL7548:
       case CL7555:
       case CL7556:
       case CL756x:
// crus
       case CL6245:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL542x;
//crus
//myf1, begin
#ifdef PANNING_SCROLL
              Int10ModeNumber |= 0x80;
#endif
//myf1, end
           break;

    }

    biosArguments.Eax = Int10ModeNumber;

//crus
//myf11: 9-26-96 fixed 755x-CE chip bug
    if (HwDeviceExtension->ChipType == CL7555)
    {
        AccessHWiconcursor(HwDeviceExtension, 0);   //disable HW icon, cursor
    }


//myf21 : 11-15-96 fixed #7495 during change resolution, screen appear garbage
//                 image, because not clear video memory.

//    SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_ADDRESS_PORT, 0x01);
//  tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT,(tempB | 0x20));
//    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT, SEQIndex);


    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

//myf21 : 11-15-96 fixed #7495 during change resolution, screen appear garbage
//                 image, because not clear video memory.

//    SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_ADDRESS_PORT, 0x01);
//  tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT,(tempB & ~0x20));
//    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT, SEQIndex);

//crus
    if (HwDeviceExtension->ChipType == CL7555)
    {
        AccessHWiconcursor(HwDeviceExtension, 1);   //Enable HW icon, cursor
    }

//crus
#if 0           //jl01
    if (HwDeviceExtension->AutoFeature)
    {
        // i 3ce originalGRIndex
        originalGRIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                              GRAPH_ADDRESS_PORT);

        // o 3ce 31
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, INDEX_ENABLE_AUTO_START);

        // i 3cf tempB
        tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT);

        tempB |= (UCHAR) 0x80;                  //enable auto start bit 7

        // o 3cf tempB
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, tempB);

        // o 3ce originalGRIndex
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGRIndex);
    }
#endif          //jl01

    //
    // Lets check to see that we actually went into the mode
    // we just tried to set.  If not, then return failure.
    //

    biosArguments.Eax = 0x0f00;
    VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((biosArguments.Eax & 0xff) != Int10ModeNumber)
    {
        //
        // The int10 modeset failed.  Return the failure back to
        // the system.
        //

        VideoDebugPrint((1, "The INT 10 modeset didn't set the mode.\n"));

        return ERROR_INVALID_PARAMETER;
    }
//crus begin
#if 0           //myf28
    HwDeviceExtension->bCurrentMode = RequestedModeNum;   //myf12
    VideoDebugPrint((1, "SetMode Info :\n"
                        "\tMode : %x, CurrentModeNum : %x, ( %d)\n",
                        Int10ModeNumber,
                        RequestedModeNum,
                        RequestedModeNum));
#endif          //myf28
//crus end

    AdjFastPgMdOperOnCL5424 (HwDeviceExtension, pRequestedMode) ;

    //
    // this code fixes a bug for color TFT panels only
    // when on the 6420 and in 640x480 8bpp only
    //

    if ( (HwDeviceExtension->ChipType == CL6420) &&
         (pRequestedMode->bitsPerPlane == 8)     &&
         (pRequestedMode->hres == 640) )
    {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                GRAPH_ADDRESS_PORT, 0xDC); // color LCD config reg.

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                  GRAPH_DATA_PORT) & 01)  // if TFT panel
        {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, 0xD6); // greyscale offset LCD reg.

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_DATA_PORT,

            (UCHAR)((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                             GRAPH_DATA_PORT) & 0x3f) | 0x40));

        }
    }

#endif          //INT10_MODE_SET

// chu03
//MODESET_OK:

    //
    // Select proper command array for adapter type
    //

    switch (HwDeviceExtension->ChipType)
       {

       case CL6410:

           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6410\n"));
           if (HwDeviceExtension->DisplayType == crt)
              pusCmdStream = pRequestedMode->CmdStrings[pCL6410_crt];
           else
              pusCmdStream = pRequestedMode->CmdStrings[pCL6410_panel];
           break;

       case CL6420:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6420\n"));
           if (HwDeviceExtension->DisplayType == crt)
              pusCmdStream = pRequestedMode->CmdStrings[pCL6420_crt];
           else
              pusCmdStream = pRequestedMode->CmdStrings[pCL6420_panel];
           break;

       case CL542x:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 542x\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL542x];
           break;

       case CL543x:

           if (HwDeviceExtension->BoardType == NEC_ONBOARD_CIRRUS)
           {
               VideoDebugPrint((1, "VgaSetMode - Setting mode for NEC 543x\n"));
               pusCmdStream = pRequestedMode->CmdStrings[pNEC_CL543x];
           }
           else
           {
               VideoDebugPrint((1, "VgaSetMode - Setting mode for 543x\n"));
               pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
           }
           break;

       case CL7541:
       case CL7542:
       case CL7543:
       case CL7548:
       case CL754x:        // Use 543x cmd strs (16k granularity, >1M modes)
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 754x\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL543x];

//crus
#if 0           //myf10
            if ( (pRequestedMode->bitsPerPlane == 16) &&
                 (pRequestedMode->hres == 640) )
            {
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, 0x2E); //expension_reg.

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR,
                    (UCHAR)((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR) & 0xF0)));
            }
#endif

           break;

        case CL7555:
        case CL7556:
        case CL755x:       // Use 543x cmd strs (16k granularity, >1M modes)
            VideoDebugPrint((1, "VgaSetMode - Setting mode for 755x\n"));
            pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
            break;

        case CL756x:       // Use 543x cmd strs (16k granularity, >1M modes)
            VideoDebugPrint((1, "VgaSetMode - Setting mode for 756x\n"));
            pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
            break;

// crus
       case CL6245:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6245\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL542x];
           break;
// end crus

       default:

           VideoDebugPrint((1, "HwDeviceExtension->ChipType is INVALID.\n"));
           return ERROR_INVALID_PARAMETER;
       }

    VgaInterpretCmdStream(HwDeviceExtension, pusCmdStream);

    //
    // Set linear mode on X86 systems w/PCI bus
    //

    if (HwDeviceExtension->LinearMode)
    {
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT, 0x07);
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
           (UCHAR) (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
           SEQ_DATA_PORT) | 0x10));
    }
    else
    {
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT, 0x07);
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
           (UCHAR) (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
           SEQ_DATA_PORT) & ~0x10));
    }

    //
    // Support 256 color modes by stretching the scan lines.
    //
    if (pRequestedMode->CmdStrings[pStretchScan])
                  {
        VgaInterpretCmdStream(HwDeviceExtension,
                              pRequestedMode->CmdStrings[pStretchScan]);
    }

    {
        UCHAR temp;
        UCHAR dummy;
        UCHAR bIsColor;

        if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS))
        {

            //
            // Fix to make sure we always set the colors in text mode to be
            // intensity, and not flashing
            // For this zero out the Mode Control Regsiter bit 3 (index 0x10
            // of the Attribute controller).
            //

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01)
            {
                bIsColor = TRUE;
            }
            else
            {
                bIsColor = FALSE;
            }

            if (bIsColor)
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_COLOR);
            }
            else
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_READ_PORT);

            temp &= 0xF7;

            if (bIsColor)
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_COLOR);
            }
            else
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_WRITE_PORT, temp);
        }
    }

    //
    // Update the location of the physical frame buffer within video memory.
    //

    if (HwDeviceExtension->LinearMode)
    {
        HwDeviceExtension->PhysicalVideoMemoryBase   = VgaAccessRange[3].RangeStart;
        HwDeviceExtension->PhysicalVideoMemoryLength = HwDeviceExtension->AdapterMemorySize;

        HwDeviceExtension->PhysicalFrameLength = 0;
        HwDeviceExtension->PhysicalFrameOffset.LowPart = 0;
    }
    else
    {
        HwDeviceExtension->PhysicalVideoMemoryBase   = VgaAccessRange[2].RangeStart;
        HwDeviceExtension->PhysicalVideoMemoryLength = VgaAccessRange[2].RangeLength;

        HwDeviceExtension->PhysicalFrameLength =
                MemoryMaps[pRequestedMode->MemMap].MaxSize;

        HwDeviceExtension->PhysicalFrameOffset.LowPart =
                MemoryMaps[pRequestedMode->MemMap].Offset;
    }

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    if ((HwDeviceExtension->ChipRevision < CL5434_ID) // we saved chip ID here
         && (pRequestedMode->numPlanes != 4) )
    {
        if ((HwDeviceExtension->ChipRevision >= 0x0B) && //Nordic(Lite,Viking)
            (HwDeviceExtension->ChipRevision <= 0x0E) && //and Everest
            (HwDeviceExtension->DisplayType & (panel8x6)) &&
            (pRequestedMode->hres == 640) &&
            ((pRequestedMode->bitsPerPlane == 8) ||     //myf33
             (pRequestedMode->bitsPerPlane == 16) ||    //myf33
             (pRequestedMode->bitsPerPlane == 24)) )    //myf33
       {    // For 754x on 800x600 panel, disable HW cursor in 640x480 mode
           HwDeviceExtension->VideoPointerEnabled = FALSE; // disable HW Cursor

           VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
               CRTC_ADDRESS_PORT_COLOR, 0x2E);

           HwDeviceExtension->cursor_vert_exp_flag =
               VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                   CRTC_DATA_PORT_COLOR) & 0x02;

           if (HwDeviceExtension->cursor_vert_exp_flag)
           {
               HwDeviceExtension->CursorEnable = FALSE;
           }
       }
// crus
        else if (HwDeviceExtension->ChipType == CL6245)
        {
            pRequestedMode->HWCursorEnable = FALSE;
            HwDeviceExtension->VideoPointerEnabled = FALSE;
        }
// end crus
//myf31 begin, 3-12-97, 755x expension on, HW cursor bug
        else if (HwDeviceExtension->ChipType & CL755x)      //CL755x
        {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 0x82);

            HwDeviceExtension->cursor_vert_exp_flag =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR) & 0x60;

            if (HwDeviceExtension->cursor_vert_exp_flag)
            {
                HwDeviceExtension->CursorEnable = FALSE;
                HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
            }
        //myf33
            if ((pRequestedMode->hres == 640) &&
                ((pRequestedMode->bitsPerPlane == 8) ||
                 (pRequestedMode->bitsPerPlane == 16) ||
                 (pRequestedMode->bitsPerPlane == 24)) )
            {
                HwDeviceExtension->CursorEnable = FALSE;
                HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
            }
        //myf33 end

        }
//myf31 end
       else
       {
           HwDeviceExtension->VideoPointerEnabled = TRUE; // enable HW Cursor
       }
    }
    else
    {    // For 5434 and 4-bit modes, use value from VideoMode structure
        HwDeviceExtension->VideoPointerEnabled = pRequestedMode->HWCursorEnable;
    }

    //
    // Adjust the FIFO Demand Threshold value for the 5436+.
    // The 5434 values work for all of the other registers
    // except this one.
    //

    // chu06
    //
    // Siemens reports this might cause undesired "yellow" screen on some
    // 5436 16bpp modes. There's no reason to change it after BIOS sets it up
    //
#if 0
    if (HwDeviceExtension->ChipRevision >= CL5436_ID)
    {
        UCHAR  PerfTuningReg, FifoDemandThreshold;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, IND_PERF_TUNING);

        PerfTuningReg = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_DATA_PORT);

        //
        // Add an offset to the threshold that makes the 5434 values work
        // for the 5436+.  We do this rather than building a whole new set
        // of 5436-specific structures.
        //

        if ((FifoDemandThreshold = (PerfTuningReg & 0x0F) + 4) > 15)
        {
            FifoDemandThreshold = 15;
        }

        PerfTuningReg = (PerfTuningReg & ~0x0F) | FifoDemandThreshold;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, PerfTuningReg);
    }
#endif // 0

//crus
//myf1, begin
#ifdef PANNING_SCROLL
{
    VP_STATUS status;
    if (Panning_flag && (((Int10ModeNumber & 0x7f) != 3) &&
                         ((Int10ModeNumber & 0x7f) != 0x12)))   //myf30
        status = CirrusSetDisplayPitch(HwDeviceExtension, PanningMode);
}
#endif
//myf1, end

    //
    // Adjust the GR18[5] for 5446.
    //
        // sge03

    if (HwDeviceExtension->ChipRevision == CL5446_ID)
    {
                UCHAR   bTemp;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, 0x18);
        bTemp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);
                bTemp &= 0xDF;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, bTemp);

        }

    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;
    ULONG ulFlags;

    // chu07
    UCHAR            chipId ;
    USHORT           chipRevisionId ;
    static VP_STATUS status ;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // The driver specific attribute flags for each mode remains
    // constant, so only calculate them once.
    //

    ulFlags = GetAttributeFlags(HwDeviceExtension);

    //
    // chu07
    // IBM does not favor 1024x768x16bpp 85 Hz for 5446 AC.
    // We access registry to know if there is a key OemModeOff, if there
    // is, we bypass it.
    //

    chipId         = GetCirrusChipId(HwDeviceExtension) ;
    chipRevisionId = GetCirrusChipRevisionId(HwDeviceExtension) ;

    //
    // IBM specific
    //
    if ((chipId == 0xB8) &&
        (chipRevisionId != 0x0045) &&
        (ModeExclude.NeverAccessed == TRUE)
       )
    {
        //
        // Access registry
        //
        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                L"OemModeOff",
                                                FALSE,
                                                GetOemModeOffInfoCallBack,
                                                NULL) ;

        if (status != NO_ERROR)
        {
            VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
        }
        else
        {
            VideoDebugPrint((2, "ModeExclude.mode = %x\n", ModeExclude.mode));
            VideoDebugPrint((2, "ModeExclude.refresh = %x\n", ModeExclude.refresh));
        }

        ModeExclude.NeverAccessed = FALSE ;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++)
    {

        //
        // chu07 : Get rid of modes 0x74, 85Hz if required by IBM.
        //
        if ((status == NO_ERROR) &&
            (ModeExclude.mode == ModesVGA[i].BiosModes.BiosModeCL542x) &&
            (ModeExclude.refresh == ModesVGA[i].Frequency))
            continue ;

        if (ModesVGA[i].ValidMode)
        {
            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModesVGA[i].hres;
            videoModes->ScreenStride = ModesVGA[i].wbytes;
            videoModes->VisScreenHeight = ModesVGA[i].vres;
            videoModes->NumberOfPlanes = ModesVGA[i].numPlanes;
            videoModes->BitsPerPlane = ModesVGA[i].bitsPerPlane;
            videoModes->Frequency = ModesVGA[i].Frequency;
            videoModes->XMillimeter = 320;        // temporary hardcoded constant
            videoModes->YMillimeter = 240;        // temporary hardcoded constant
            videoModes->AttributeFlags = ModesVGA[i].fbType;
            videoModes->AttributeFlags |= ModesVGA[i].Interlaced ?
                 VIDEO_MODE_INTERLACED : 0;

            videoModes->DriverSpecificAttributeFlags = ulFlags;

            //
            // The 5434 has a hardware cursor problem at 1280x1024
            // resolution.  Use a software cursor on these chips.
            //

            if ((videoModes->VisScreenWidth == 1280) &&
                (HwDeviceExtension->ChipRevision == 0x2A))
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }

// crus
            if (HwDeviceExtension->ChipType == CL6245)
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }
// end crus

            //
            // Account for vertical expansion on laptops
            //

            if ((HwDeviceExtension->ChipType &  CL754x)   &&
                (videoModes->VisScreenHeight == 480) &&
                (videoModes->BitsPerPlane == 8))
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }

            //
            // Calculate the VideoMemoryBitmapWidth
            //

            {
                LONG x;

                x = videoModes->BitsPerPlane;

                if( x == 15 ) x = 16;

                videoModes->VideoMemoryBitmapWidth =
                    (videoModes->ScreenStride * 8 ) / x;
            }

            videoModes->VideoMemoryBitmapHeight =
                     HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;
//crus
//myf15, begin
            if ((HwDeviceExtension->ChipType &  CL754x) ||
                (HwDeviceExtension->ChipType == CL6245) ||
                (HwDeviceExtension->ChipType &  CL755x))
                 videoModes->VideoMemoryBitmapHeight =
                             (HwDeviceExtension->AdapterMemorySize - 0x4000) /
                                         videoModes->ScreenStride;
//myf15, end

            if ((ModesVGA[i].bitsPerPlane == 32) ||
                (ModesVGA[i].bitsPerPlane == 24))
            {

                videoModes->NumberRedBits = 8;
                videoModes->NumberGreenBits = 8;
                videoModes->NumberBlueBits = 8;
                videoModes->RedMask = 0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask = 0x0000ff;

            }
            else if (ModesVGA[i].bitsPerPlane == 16)
            {

                videoModes->NumberRedBits = 6;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 6;
                videoModes->RedMask = 0x1F << 11;
                videoModes->GreenMask = 0x3F << 5;
                videoModes->BlueMask = 0x1F;

            }
            else
            {

                videoModes->NumberRedBits = 6;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 6;
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                     VIDEO_MODE_MANAGED_PALETTE;

            }

            videoModes++;

        }
    }

    return NO_ERROR;

} // end VgaQueryAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //
//  VideoDebugPrint((0, "Miniport - VgaQueryNumberofAvailableModes\n")); //myfr

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // check if a mode has been set
    //
//  VideoDebugPrint((0, "Miniport - VgaQueryCurrentMode\n")); //myfr

    if (HwDeviceExtension->CurrentMode == NULL ) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    ModeInformation->DriverSpecificAttributeFlags =
        GetAttributeFlags(HwDeviceExtension);           //myf17 move to this

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
    if (Panning_flag)
    {
        ModeInformation->VisScreenWidth = PanningMode.hres;
        ModeInformation->ScreenStride = PanningMode.wbytes;
        ModeInformation->VisScreenHeight = PanningMode.vres;
        ModeInformation->BitsPerPlane = PanningMode.bpp;
       ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType
             & ~(HwDeviceExtension->CurrentMode->Interlaced ?
                VIDEO_MODE_INTERLACED : 0);     //myf22

    }
    else
#endif
//myf1, end
//crus end
    {
        ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
        ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
        ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
              CRTC_ADDRESS_PORT_COLOR, 0x30);           //myf34

        if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
            (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                   CRTC_DATA_PORT_COLOR) & 0x40) &&     //myf34, Internal TV
            (ModeInformation->VisScreenHeight == 480) &&
            (ModeInformation->VisScreenWidth == 640))
        {
            ModeInformation->VisScreenHeight =
                HwDeviceExtension->CurrentMode->vres - 28;  //myf33
        }
        else if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
                 (!(VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     CRTC_DATA_PORT_COLOR) & 0x40)) &&     //myf34, External TV
                 (ModeInformation->VisScreenHeight == 480) &&
                 (ModeInformation->VisScreenWidth == 640))
        {
             ModeInformation->VisScreenHeight =
                      HwDeviceExtension->CurrentMode->vres - 68;  //AI Tech.
             VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                      CRTC_ADDRESS_PORT_COLOR, 0x12);
             VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                      CRTC_DATA_PORT_COLOR,
                      (UCHAR)ModeInformation->VisScreenHeight);
        }

        ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
        ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType
             | (HwDeviceExtension->CurrentMode->Interlaced ?
                VIDEO_MODE_INTERLACED : 0);     //myf22
    }

    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
//crus
//    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->Frequency;
    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant

//  ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
//      (HwDeviceExtension->CurrentMode->Interlaced ?
//       VIDEO_MODE_INTERLACED : 0);

    ModeInformation->DriverSpecificAttributeFlags =
        GetAttributeFlags(HwDeviceExtension);   //original, myf17

    //
    // The 5434 has a hardware cursor problem at 1280x1024
    // resolution.  Use a software cursor on these chips.
    //

    if ((ModeInformation->VisScreenWidth == 1280) &&
        (HwDeviceExtension->ChipRevision == 0x2A))
    {
        ModeInformation->DriverSpecificAttributeFlags
            |= CAPS_SW_POINTER;
    }
// crus
    if(HwDeviceExtension->ChipType == CL6245)
    {
        ModeInformation->DriverSpecificAttributeFlags
            |= CAPS_SW_POINTER;
    }
// end crus

//crus begin
//myf13, expension on with panning scrolling bug
    if ((HwDeviceExtension->ChipType &  CL754x)   &&
        (ModeInformation->VisScreenHeight == 640) &&    //myf15, myf33
        (ModeInformation->BitsPerPlane == 8))           //myf15
    {
         ModeInformation->DriverSpecificAttributeFlags
                 |= CAPS_SW_POINTER;
    }
/*
    if (((HwDeviceExtension->ChipType &  CL754x) ||
         (HwDeviceExtension->ChipType &  CL755x))  &&
        (Panning_flag))
    {
         ModeInformation->DriverSpecificAttributeFlags
                |= GCAPS_PANNING;       //myf15
    }
*/

//myf13, end
//crus end


    //
    // Account for vertical expansion on laptops
    //

//crus
    if (((HwDeviceExtension->ChipType &  CL754x)  ||
        (HwDeviceExtension->ChipType &  CL755x))  &&    //myf9, crus
        (ModeInformation->VisScreenWidth == 640) &&
        ((ModeInformation->BitsPerPlane == 8) ||
         (ModeInformation->BitsPerPlane == 16) ||
         (ModeInformation->BitsPerPlane == 24)) )
    {
        ModeInformation->DriverSpecificAttributeFlags
             |= CAPS_SW_POINTER;

        if (HwDeviceExtension->cursor_vert_exp_flag)
        {
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_CURSOR_VERT_EXP;
        }

        //myf33 begin
        if (ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON)
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;
        //myf33 end

    }
//myf31 begin:3-12-97 755x expension on, HW cursor bug
    if ((HwDeviceExtension->ChipType & CL755x))
    {
        //myf33
        if (ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON)
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;
        //myf33 end

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             CRTC_ADDRESS_PORT_COLOR, 0x82);

        HwDeviceExtension->cursor_vert_exp_flag =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                  CRTC_DATA_PORT_COLOR) & 0x60;

        if (HwDeviceExtension->cursor_vert_exp_flag)
        {
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;

            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_CURSOR_VERT_EXP;
        }
    }
//myf31 end

    if ((ModeInformation->BitsPerPlane == 24) ||
        (ModeInformation->BitsPerPlane == 32)) {

        ModeInformation->NumberRedBits = 8;
        ModeInformation->NumberGreenBits = 8;
        ModeInformation->NumberBlueBits = 8;
        ModeInformation->RedMask = 0xff0000;
        ModeInformation->GreenMask = 0x00ff00;
        ModeInformation->BlueMask = 0x0000ff;

    } else if (ModeInformation->BitsPerPlane == 16) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;
        ModeInformation->RedMask = 0x1F << 11;
        ModeInformation->GreenMask = 0x3F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;
        ModeInformation->RedMask = 0;
        ModeInformation->GreenMask = 0;
        ModeInformation->BlueMask = 0;
        ModeInformation->AttributeFlags |=
            VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    }

    //
    // Calculate the VideoMemoryBitmapWidth
    //

    {
        LONG x;

        x = ModeInformation->BitsPerPlane;

        if( x == 15 ) x = 16;

        ModeInformation->VideoMemoryBitmapWidth =
            (ModeInformation->ScreenStride * 8 ) / x;
    }

    ModeInformation->VideoMemoryBitmapHeight =
          HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;
//crus begin
//myf15, begin
    if ((HwDeviceExtension->ChipType &  CL754x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType &  CL755x))
         ModeInformation->VideoMemoryBitmapHeight =
                          (HwDeviceExtension->AdapterMemorySize - 0x4000) /
                                 ModeInformation->ScreenStride;
//myf15, end
//crus end

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
    UCHAR temp;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Enable all planes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
            IND_MAP_MASK);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) | (UCHAR)0x0F;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
            temp);

    VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

}


VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Determines which modes are valid and which are not.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    ULONG i;
    USHORT usChipIndex;
//  VideoDebugPrint((0, "Miniport - CirrusValidateMode\n")); //myfr

    switch (HwDeviceExtension->ChipType)
    {
        case CL6410: if (HwDeviceExtension->DisplayType == crt)
                     {
                         usChipIndex = pCL6410_crt;
                     }
                     else
                     {
                         usChipIndex = pCL6410_panel;
                     }
                     break;

        case CL6420: if (HwDeviceExtension->DisplayType == crt)
                     {
                         usChipIndex = pCL6420_crt;
                     }
                     else
                     {
                         usChipIndex = pCL6420_panel;
                     }
                     break;

// crus
        case CL6245:
        case CL542x: usChipIndex = pCL542x; break;

        case CL543x:
        case CL5434:
        case CL5434_6:
        case CL5436:
        case CL5446:
        case CL5446BE:
        case CL5480:
        case CL754x:
        case CL7541:
        case CL7543:
        case CL7542:
        case CL7548:
        case CL756x:
        case CL755x:
        case CL7555:
        case CL7556:
                     if (HwDeviceExtension->BoardType == NEC_ONBOARD_CIRRUS)
                     {
                         usChipIndex = pNEC_CL543x;
                     }
                     else
                     {
                         usChipIndex = pCL543x;
                     }
                     break;

        default:     usChipIndex = 0xffff; break;
    }

    HwDeviceExtension->NumAvailableModes = 0;

    VideoDebugPrint((2, "Checking for available modes:\n"));

    VideoDebugPrint((2, "\tMemory Size = %x\n"
                        "\tChipType = %x\n"
                        "\tDisplayType = %x\n",
                        HwDeviceExtension->AdapterMemorySize,
                        HwDeviceExtension->ChipType,
                        HwDeviceExtension->DisplayType));

    for (i = 0; i < NumVideoModes; i++) {

        //
        // The SpeedStarPRO does not support refresh rates.
        // we must return hardware default for all of the modes.
        // clean out the mode tables of duplicates ...
        //

        if (HwDeviceExtension->BoardType == SPEEDSTARPRO)
        {
            ModesVGA[i].Frequency = 1;
            ModesVGA[i].Interlaced = 0;

            if (i &&
                (ModesVGA[i].numPlanes == ModesVGA[i-1].numPlanes) &&
                (ModesVGA[i].bitsPerPlane == ModesVGA[i-1].bitsPerPlane) &&
                (ModesVGA[i].hres == ModesVGA[i-1].hres) &&
                (ModesVGA[i].vres == ModesVGA[i-1].vres))
            {
                //
                // duplicate mode - skip it.
                //

                continue;

            }
        }

        VideoDebugPrint((2, "Mode #%ld %dx%d at %d bpp\n"
                            "\tAdapterMemoryRequired: %x\n"
                            "\tChipType:              %x\n"
                            "\tDisplayType:           %x\n",
                            i, ModesVGA[i].hres, ModesVGA[i].vres,
                            ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes,
                            ModesVGA[i].numPlanes * ModesVGA[i].sbytes,
                            ModesVGA[i].ChipType,
                            ModesVGA[i].DisplayType));

        if ( (HwDeviceExtension->AdapterMemorySize >=
              ModesVGA[i].numPlanes * ModesVGA[i].sbytes) &&
             (HwDeviceExtension->ChipType & ModesVGA[i].ChipType) &&
             (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType) &&
// crus
             (!(HwDeviceExtension->ChipType &  CL754x) &&
              !(HwDeviceExtension->ChipType & CL755x) &&
              (HwDeviceExtension->ChipType != CL6245) &&
              (HwDeviceExtension->ChipType != CL756x)) &&
// end crus
             CheckDDC2BMonitor(HwDeviceExtension, i) &&
             ((ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes == 24)
               ? VgaAccessRange[3].RangeLength : TRUE))
        {
            ModesVGA[i].ValidMode = TRUE;
            HwDeviceExtension->NumAvailableModes++;

            VideoDebugPrint((2, "This mode is valid.\n"));
        }

        // check if panel type is DSTN panel, must be used 128K frame buffer
        // for Half-Frame Accelerator
// crus
#if 1
        else if ((HwDeviceExtension->AdapterMemorySize >=
                  ModesVGA[i].numPlanes * ModesVGA[i].sbytes) &&
                 ((HwDeviceExtension->ChipType &  CL754x) ||
                 (HwDeviceExtension->ChipType &  CL755x) ||
                 (HwDeviceExtension->ChipType == CL6245) ||
                 (HwDeviceExtension->ChipType == CL756x)) &&
                 (HwDeviceExtension->ChipType & ModesVGA[i].ChipType) &&
                 (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType) &&
                 ((ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes == 24)
                       ? VgaAccessRange[3].RangeLength : TRUE))
        {
        //DSTN panel must be turn on
           if ((((HwDeviceExtension->DisplayType & ScreenType)==DSTN10) ||
                ((HwDeviceExtension->DisplayType & ScreenType)==DSTN8 ) ||
                ((HwDeviceExtension->DisplayType & ScreenType)==DSTN6 )) &&
               ((LONG)HwDeviceExtension->AdapterMemorySize >=
               (LONG)((ModesVGA[i].wbytes * ModesVGA[i].vres) +0x24000)) )
           {

//myf27, begin
               if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (ModesVGA[i].hres > 640) &&
                   ((HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                     - crt) >= panel8x6))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "***This mode is not valid.***\n"));
               }
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (HwDeviceExtension->ChipType &  CL754x) &&         //myf27
                   (ModesVGA[i].bitsPerPlane >= 16) &&
//                 (ModesVGA[i].hres > 640) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel8x6))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf27, end
//myf32 begin :fixed DSTN XGA panel not supported 24bpp mode
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (HwDeviceExtension->ChipType & CL755x) &&         //myf27
                   (ModesVGA[i].bitsPerPlane >= 24) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf32 end

               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) &&  //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType) >= panel))
               {
                   ModesVGA[i].ValidMode = TRUE ;
                   HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf7, begin
//myf7         else if (!(HwDeviceExtension->DisplayType & PanelType))
               else if ((HwDeviceExtension->DisplayType & crt) &&
                        (HwDeviceExtension->DisplayType & Jump_type) )//myf27
                {
                    ModesVGA[i].ValidMode = TRUE ;
                    HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
                }
//myf7, end
//crus end
           }
           else if (((HwDeviceExtension->DisplayType & ScreenType)!=DSTN10) &&
                    ((HwDeviceExtension->DisplayType & ScreenType)!=DSTN8) &&
                    ((HwDeviceExtension->DisplayType & ScreenType)!=DSTN6) &&
                    ((LONG)HwDeviceExtension->AdapterMemorySize >=
                     (LONG)((ModesVGA[i].wbytes * ModesVGA[i].vres))))
           {

//myf27, begin
               if ((HwDeviceExtension->DisplayType & (panel10x7 | TFT_LCD)) &&
                   (ModesVGA[i].DisplayType & panel10x7) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "===This mode is not valid.===\n"));
               }
/*
               else if ((HwDeviceExtension->DisplayType &
                           (panel10x7 | TFT_LCD)) &&
                   (ModesVGA[i].DisplayType & panel10x7) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "===This mode is not valid.===\n"));
               }
*/
//myf27, end
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                        (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType) >= panel) )
               {
                   ModesVGA[i].ValidMode = TRUE ;
                   HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf7, this is fixed crt only can't display exclude 60Hz refresh rate
//myf7         else if (!(HwDeviceExtension->DisplayType & PanelType))
               else if ((HwDeviceExtension->DisplayType & crt) && //myf7
                        (HwDeviceExtension->DisplayType & Jump_type) )//myf27
                {
                    ModesVGA[i].ValidMode = TRUE ;
                    HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
                }
           }

        }
#endif
// end crus

        else
        {
            VideoDebugPrint((1, "This mode is not valid.\n"));  //2
        }

#if 0
        if (HwDeviceExtension->ChipRevision == 0x3A) {
            if (((ModesVGA[i].numPlanes * ModesVGA[i].sbytes) <= 0x200000) &&
                 (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType)) {
                if (CheckDDC2B(HwDeviceExtension, i)) {
                    ModesVGA[i].ValidMode = TRUE ;
                     HwDeviceExtension->NumAvailableModes++ ;
                    continue ;
                }
            }
        }
#endif

/*  jl02
        if (CheckGD5446Rev(HwDeviceExtension)) {

            // Block 1152x864, 16-bpp
            if ((ModesVGA[i].hres == 1152) &&
                (ModesVGA[i].vres == 864) &&
                (ModesVGA[i].bitsPerPlane == 16))
            {
                continue ;
            }

        }
*/

    }

#if 0           //myf28
//myf27, begin
    if ((HwDeviceExtension->DisplayType & Jump_type) &&
        ((HwDeviceExtension->ChipType &  CL754x) ||
         (HwDeviceExtension->ChipType &  CL755x) ||
//       (HwDeviceExtension->ChipType == CL6245) ||
         (HwDeviceExtension->ChipType == CL756x)))
         HwDeviceExtension->DisplayType &= crt;
//myf27, end
#endif          //myf28

    VideoDebugPrint((1, "NumAvailableModes = %ld\n",
                         HwDeviceExtension->NumAvailableModes));        //2
}

ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine determines whether or not the detected
    cirrus chip supports Blt's.

    NOTE: This device should not be called until after
          CirrusLogicIsPresent has been called.

Arguments:

    HwDeviceExtension - Pointer to the device extension.

Return Value:

    TRUE - If the device supports Blt's
    FALSE - otherwise

--*/

{
    ULONG ChipId   = HwDeviceExtension->ChipRevision;
    ULONG ChipType = HwDeviceExtension->ChipType;
    ULONG ulFlags  = 0;

    //
    // Check for BLT support
    //
    // All 543x & 754x/755x/756x do BLTs
    //
//myfr  VideoDebugPrint((0, "Miniport - VgaAttributeFlags\n"));

    if ((ChipType == CL543x) || (ChipType &  CL754x) ||
        (ChipType &  CL755x) || (ChipType == CL756x))
    {
        ulFlags |= CAPS_BLT_SUPPORT;

    }
    else if ((ChipType == CL542x) &&      // 5426-5429 have BLT engines
             (ChipId >= 0x26) ||          // 26 is CL5428
             (ChipId == 0x24) )           // 24 is CL5426
    {
        ulFlags |= CAPS_BLT_SUPPORT;
    }
// crus
    else if (ChipType == CL6245)
    {
        ulFlags &= ~CAPS_BLT_SUPPORT;
    }
// end crus

    //
    // Check for true color support
    //

    if ((ChipType == CL543x) || (ChipType &  CL755x) || (ChipType == CL756x))
    {
        ulFlags |= CAPS_TRUE_COLOR;

// crus
// Added CL-GD7555 for direct draw support.//tao1
//      if ((ChipType &  CL755x))
//      {
//         ulFlags |= CAPS_IS_7555;
//      }
// end crus

// crus
// Set CL-GD5436, CL-GD54UM36 and CL-GD5446 for autostart routine
// in display driver
//tso   else if (HwDeviceExtension->AutoFeature)
        if (HwDeviceExtension->AutoFeature)
        {
           //ulFlags |= CAPS_AUTOSTART;
           ulFlags |= CAPS_ENGINEMANAGED;
        }

// D5480 chu01
// chu04: GAMMACORRECT
        //
        // Specify BLT enhancement flag for later use.
        //
        if (HwDeviceExtension->BitBLTEnhance)
            ulFlags |= ( CAPS_COMMAND_LIST | CAPS_GAMMA_CORRECT) ;
//myf29
        if (ChipType &  CL755x)
           ulFlags |= CAPS_GAMMA_CORRECT;

    }

    //
    // don't do host transfer and avoid hardware problem on fast machines
    //

    ulFlags |= CAPS_NO_HOST_XFER;

    //
    // Can't do host transfers on ISA 5434s
    //

    if ((HwDeviceExtension->BusType == Isa) &&
        (ChipType == CL543x))
    {
        ulFlags |= CAPS_NO_HOST_XFER;
    }

    //
    // Is this a 542x
    //

    if (ChipType == CL542x)
    {
        ulFlags |= CAPS_IS_542x;

        if (ChipId == CL5429_ID)
        {
            //
            // Some 5429s have a problem doing host transfers.
            //

            ulFlags |= CAPS_NO_HOST_XFER;
        }

        //
        // 5428's have problems with HOST_TRANSFERS on MicroChannel bus.
        //

        if ((HwDeviceExtension->BusType == MicroChannel) &&
            (ChipId == CL5428_ID))
        {
            //
            // this is a 5428.  We've noticed that some of these have mono
            // expand problems on MCA IBM machines.
            //

            ulFlags |= CAPS_NO_HOST_XFER;
        }
    }

    //
    // The display driver needs to know if a Dual STN panel is
    // in use, so that it can reserve part of the frame buffer for
    // the half frame accelerator.
    //
    // Unfortunately we have found at least one machine with a DSTN
    // panel that reports itself as having a TFT panel. (Dell Latitude
    // XPi 90D).  Therefore, we will have to reserve the space for
    // any machine with a LCD panel!
    //

//crus begin
//myf10
        if ((ChipType &  CL755x) || (ChipType &  CL754x))
        {
            ulFlags |= GetPanelFlags(HwDeviceExtension);
        }
//crus end

    //
    // The cirrus 543x chips don't support transparency.
    //

    ulFlags |= CAPS_TRANSPARENCY;

    if ((ChipType & CL543x) &&
        (ChipType != CL5446) &&
        (ChipType != CL5446BE) &&
        (ChipType != CL5480))
    {
        ulFlags &= ~CAPS_TRANSPARENCY;
    }

    return ulFlags;
}


BOOLEAN
CheckDDC2B(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if refresh rate support according to DDC2B standard.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{

    VideoDebugPrint((1, "Miniport -- CheckDDC2B\n"));       //2
    VideoDebugPrint((2, "refresh rate   = %ld\n", ModesVGA[i].Frequency));
    VideoDebugPrint((2, "hres           = %d\n", ModesVGA[i].hres));
    VideoDebugPrint((2, "vres           = %d\n", ModesVGA[i].vres));
    VideoDebugPrint((2, "EDIDTiming_I   = %d\n", EDIDTiming_I));
    VideoDebugPrint((2, "EDIDTiming_II  = %d\n", EDIDTiming_II));
    VideoDebugPrint((2, "EDIDTiming_III = %d\n", EDIDTiming_III));


    if (!DDC2BFlag)
        return TRUE ;

    if (ModesVGA[i].Frequency == 85) {

       if (ModesVGA[i].vres == 1200) {  // 1600x1200

//        if (!(EDIDTiming_III & 0x02))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 1024) {  // 1280x1024

//        if (!(EDIDTiming_III & 0x10))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 864) {  // 1152x864

          ;

       } else if (ModesVGA[i].vres == 768) {  // 1024x768

//        if (!(EDIDTiming_III & 0x08))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

//        if (!(EDIDTiming_III & 0x20))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

//        if (!(EDIDTiming_III & 0x40))
//            return FALSE ;
          ;

       }


    } else if (ModesVGA[i].Frequency == 75) {

       if (ModesVGA[i].vres == 1200) {  // 1600x1200

//        if (!(EDIDTiming_III & 0x04))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 1024) {  // 1280x1024

          if (!(EDIDTiming_II & 0x01))
              return FALSE ;

       } else if (ModesVGA[i].vres == 864) {  // 1152x864

          if (!(EDIDTiming_III & 0x80))
              return FALSE ;

       } else if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x02))
              return FALSE ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_II & 0x40))
              return FALSE ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

          if (!(EDIDTiming_I & 0x04))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 72) {

       if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_II & 0x80))
              return FALSE ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

          if (!(EDIDTiming_I & 0x08))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 70) {

       if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x04))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 60) {

       if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x08))
              return FALSE ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_I & 0x01))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 56) {

       if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_I & 0x02))
              return FALSE ;

       }
    }

    return TRUE ;

} // end CheckDDC2B ()



VOID
AdjFastPgMdOperOnCL5424(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode
    )

/*++

Routine Description:
    Undesired bars happen on CL5424 800x600x16 color, 512Kb, 56, 60 and 72 Hz
    Compaq Prosignia 300 machine.  This can be solved by setting SRF(6) to 1.
    This bit restricts the write buffer to one level, disabling fast page
    mode operation;  The faulty control logic is therefore disabled.  The
    downside is that the performance will take a hit, since we are dealing
    with a 5424, so we make a slow chip slower.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pRequestedMode

Return Value:
    None.

--*/
{

    UCHAR uc, chipId ;


    /*---  CL5424 : ID = 100101xx  ---*/

    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu08
    if (chipId != 0x94)
        return ;


    /*---  800x600x16 color, 60 or 72 Hz  ---*/

    if (pRequestedMode->hres != 800)
        return ;

    if (pRequestedMode->vres != 600)
        return ;

    if (pRequestedMode->bitsPerPlane != 1)
        return ;

         if (!((pRequestedMode->Frequency == 56) ||
               (pRequestedMode->Frequency == 60) ||
               (pRequestedMode->Frequency == 72)))
        return ;


    /*---  512k  ---*/
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x0A) ;
    uc = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
    if ((uc & 0x38) != 0x08)
        return ;


    /*---  SRF(6)=1 --- */
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x0F) ;
    uc = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
    uc &= 0xBF ;
    uc |= 0x40 ;
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_DATA_PORT, uc) ;


} // end AdjFastPgMdOperOnCL5424 ()



// crus
BOOLEAN
CheckGD5446Rev(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Check if it is CL-GD5446

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    FALSE : It isn't CL-GD5446
    TRUE  : It is    CL-GD5446
--*/
{

    UCHAR chipId ;

    //
    // Get Chip ID
    //
    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu08


    // For CL-GD5446, Chip ID = 101110xx

    if (chipId != 0xB8)
        return FALSE ;
    else
        return TRUE ;

} // end CheckGD5446Rev ()


#if (_WIN32_WINNT <= 0x0400)
#pragma message("NOTICE: We want to remove DDC update code before 5.0 ships")

VOID CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  paramPath;
    ULONG           i;
    BOOLEAN         bRefreshChanged;
#if (_WIN32_WINNT < 0x0400)
    WCHAR   KeyString[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Cl54xx35\\Device0";
#else
    WCHAR   KeyString[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\cirrus\\Device0";
#endif
    RTL_QUERY_REGISTRY_TABLE    paramTable[5];
    ULONG                       ulZero = 0;
    ULONG                       ulBitsPerPel = 8;
    ULONG                       ulVRefresh   = 60;
    ULONG                       ulXResolution= 640;
    ULONG                       ulYResolution= 480;

    //
    // Update the Monitor.Type Valuename
    //
    // sge02
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"Monitor.Type",
                                   &DDC2BFlag,
                                   sizeof(BOOLEAN));
    //
    // First check whether it is a DDC2B monitor
    //

    if(!DDC2BFlag)
        return;

    //
    // Query the registry about the Manufacture and Product ID
    //

    if (NO_ERROR == VideoPortGetRegistryParameters(hwDeviceExtension,
                                                   L"Monitor.ID",
                                                   FALSE,
                                                   CirrusDDC2BRegistryCallback,
                                                   NULL))
    {
        //
        // Same DDC2B Monitor, do nothing
        //
    }
    else
    {
        //
        // Set the Manufacture of the Monitor.
        //

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"Monitor.ID",
                                       &EDIDBuffer[8],
                                       sizeof(ULONG));
        //
        // Set the EDID data of the Monitor.
        //
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"Monitor.Data",
                                       EDIDBuffer,
                                       128);

        //
        // Change to the highest refresh rate for the new
        // DDC2B monitor.
        //

        paramPath.MaximumLength = sizeof(KeyString);
        paramPath.Buffer = KeyString;

        //
        // We use this to query into the registry as to whether we
        // should break at driver entry.
        //


        VideoPortZeroMemory(&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"DefaultSettings.BitsPerPel";
        paramTable[0].EntryContext  = &ulBitsPerPel;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &ulZero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = L"DefaultSettings.VRefresh";
        paramTable[1].EntryContext  = &ulVRefresh;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &ulZero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name          = L"DefaultSettings.XResolution";
        paramTable[2].EntryContext  = &ulXResolution;
        paramTable[2].DefaultType   = REG_DWORD;
        paramTable[2].DefaultData   = &ulZero;
        paramTable[2].DefaultLength = sizeof(ULONG);

        paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name          = L"DefaultSettings.YResolution";
        paramTable[3].EntryContext  = &ulYResolution;
        paramTable[3].DefaultType   = REG_DWORD;
        paramTable[3].DefaultData   = &ulZero;
        paramTable[3].DefaultLength = sizeof(ULONG);

        if (NT_SUCCESS(RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            paramPath.Buffer, &paramTable[0], NULL, NULL)))
        {
            bRefreshChanged = FALSE;
            //
            // Get the highest refresh rate from the mode
            //
            for (i = 0; i < NumVideoModes; i++)
            {
                if (ModesVGA[i].ValidMode &&
                    (ModesVGA[i].hres == ulXResolution) &&
                    (ModesVGA[i].vres == ulYResolution) &&
                    (ModesVGA[i].numPlanes == 1 ) &&
                    (ModesVGA[i].bitsPerPlane == ulBitsPerPel))
                {
                    if(ulVRefresh < ModesVGA[i].Frequency)
                        ulVRefresh = ModesVGA[i].Frequency;
                    bRefreshChanged = TRUE;
                }
            }
            //
            // Write to the registry
            //
            if (bRefreshChanged)
                RtlWriteRegistryValue(
                    RTL_REGISTRY_ABSOLUTE,
                    paramPath.Buffer,
                    L"DefaultSettings.VRefresh",
                    REG_DWORD,
                    &ulVRefresh,
                    sizeof(ULONG)
                    );
        }
    }

}
#endif // (_WIN32_WINNT <= 0x0400)

//
// chu08
//
UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Get Cirrus Logic chip identifying value.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    Cirrus Logic chip ID.

--*/
{
    UCHAR  chipId ;

    VideoDebugPrint((4, "GetCirrusChipId\n")) ;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR) ;
    } else {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_MONO) ;
    }
    chipId &= 0xFC ;

    return chipId ;

} // end GetCirrusChipId




//
// chu08
//
USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Get Cirrus Logic chip revision identifying value.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    e.g.,    Rev AB = xxxx xx00 0010 0010
             Rev AC = xxxx xx00 0010 0011

    Cirrus Logic chip revision ID.

--*/
{
    UCHAR  chipId, chipRevision ;
    USHORT chipRevisionId = 0   ;

    VideoDebugPrint((4, "GetCirrusChipRevisionId\n")) ;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR) ;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x25) ;
        chipRevision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              CRTC_DATA_PORT_COLOR) ;
    } else {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_MONO) ;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x25) ;
        chipRevision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              CRTC_DATA_PORT_MONO) ;
    }

    //
    // Chip revision
    //

    chipRevisionId += (chipId & 0x03) ;
    chipRevisionId <<= 8              ;
    chipRevisionId += chipRevision    ;

    return chipRevisionId ;


} // end GetCirrusChipRevisionId
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\mode543x.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Mode543x.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
   CL-542x driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The next set of tables are for the CL543x
// Note: all resolutions supported
//

//
// 640x480 16-color mode (BIOS mode 12) set command string for CL 543x.
//

USHORT CL543x_640x480_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 640x480 mode

    EOD
};

//
// 800x600 16-color (60Hz refresh) mode set command string for CL 543x.
//

USHORT CL543x_800x600_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 800x600 mode

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 543x.
//

USHORT CL543x_1024x768_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

//
// 80x25 text mode set command string for CL 543x.
// (720x400 pixel resolution; 9x16 character cell.)
//

USHORT CL543x_80x25Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in text mode

    EOD
};

//
// 80x25 text mode set command string for CL 543x.
// (640x350 pixel resolution; 8x14 character cell.)
//

USHORT CL543x_80x25_14_Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,         // no banking in text mode

    EOD
};

//
// 1280x1024 16-color mode (BIOS mode 0x6C) set command string for CL 543x.
//

USHORT CL543x_1280x1024_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 640x480 256-color mode (BIOS mode 0x5F) set command string for CL 543x.
//

USHORT CL543x_640x480_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 800x600 256-color mode (BIOS mode 0x5C) set command string for CL 543x.
//

USHORT CL543x_800x600_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 640x480 64k-color mode (BIOS mode 0x64) set command string for CL 543x.
//

USHORT CL543x_640x480_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 800x600 64k-color mode (BIOS mode 0x65) set command string for CL 543x.
//

USHORT CL543x_800x600_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 1024x768 64k-color mode set command string for CL 543x.
//

USHORT CL543x_1024x768_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // some BIOS's set Chain Odd Maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 640x480 16M-color mode (BIOS mode 0x64) set command string for CL 543x.
//

USHORT CL543x_640x480_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    EOD                   
};

//
// 800x600 16M-color mode (BIOS mode 0x65) set command string for CL 543x.
//

USHORT CL543x_800x600_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    EOD                   
};

//
// 1024x768 16M-color mode set command string for CL 543x.
//

USHORT CL543x_1024x768_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\sr754x.h ===
#define CL754x_NUM_VSHADOW              6
#define CL754x_NUM_YSHADOW              5
#define CL754x_NUM_ZSHADOW              5
#define CL754x_NUM_XSHADOW              12

#define CL754x_CRTC_EXT_START           0x19
#define CL754x_CRTC_EXT_END             0x30
#define CL754x_NUM_CRTC_EXT_PORTS (CL754x_CRTC_EXT_END-CL754x_CRTC_EXT_START+1)

#define CL754x_HRZ_TIME_START           0x40
#define CL754x_HRZ_TIME_END             0x4F
#define CL754x_NUM_HRZ_TIME_PORTS (CL754x_HRZ_TIME_END-CL754x_HRZ_TIME_START+1)

//
// 
typedef struct _NORDIC_REG_SAVE_BUF
{
   USHORT saveVshadow[CL754x_NUM_VSHADOW];
   USHORT saveCrtcExts[CL754x_NUM_CRTC_EXT_PORTS];
   USHORT saveHrzTime[CL754x_NUM_HRZ_TIME_PORTS];
   USHORT saveYshadow[CL754x_NUM_YSHADOW];
   USHORT saveZshadow[CL754x_NUM_ZSHADOW];
   USHORT saveXshadow[CL754x_NUM_XSHADOW];
} NORDIC_REG_SAVE_BUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\sr754x.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1994  Cirrus Logic, Inc.

Module Name:

    sr754x.c

Abstract:

    This module performs the save/restore operations specific to the
    CL-GD754x chipset (aka Nordic).

Environment:

    kernel mode only

Notes:

Revision History:
   13Oct94  mrh   Initial version

--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"


#include "ntddvdeo.h"
#include "video.h"
#include "cirrus.h"
#include "sr754x.h"



#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NordicSaveRegs)
#pragma alloc_text(PAGE,NordicRestoreRegs)
#endif

VP_STATUS NordicSaveRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pNordicSaveArea
    )
{
   UCHAR i;
   UCHAR PortVal, Save2C, Save2D;
   PUCHAR CRTCAddressPort, CRTCDataPort;
   PUSHORT pSaveBuf;
   UCHAR vShadowIndex[CL754x_NUM_VSHADOW] = {0x06,0x07,0x10,0x11,0x15,0x16};
   UCHAR zShadowIndex[CL754x_NUM_ZSHADOW] = {0,2,3,4,5};
   UCHAR yShadowIndex[CL754x_NUM_YSHADOW] = {0,2,3,4,5};
   UCHAR xShadowIndex[CL754x_NUM_XSHADOW] = {2,3,4,5,6,7,8,9,0x0B,0x0C,0x0D,0x0E};


   //
   // Determine where the CRTC registers are addressed (color or mono).
   //
   CRTCAddressPort = HwDeviceExtension->IOAddress;
   CRTCDataPort = HwDeviceExtension->IOAddress;

   if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
               MISC_OUTPUT_REG_READ_PORT) & 0x01)
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
      CRTCDataPort += CRTC_DATA_PORT_COLOR;
      }
   else
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
      CRTCDataPort += CRTC_DATA_PORT_MONO;
      }

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   Save2D = (VideoPortReadPortUchar(CRTCDataPort));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   Save2C = (VideoPortReadPortUchar(CRTCDataPort));

   pSaveBuf = pNordicSaveArea;

   //Initialize the control registers to access shadowed vertical regs:
   // CR2C[3] = {0} Allows access to Vert regs (CR6,CR7,CR10,CR11,CR15,CR16)
   // CR2D[7] = {0} Blocks access to LCD timing regs (R2X-REX)
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2C & ~0x08) << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2D & ~0x80) << 8) | IND_CR2D));

   for (i = 0; i < CL754x_NUM_VSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, vShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     vShadowIndex[i];
      }
   for (i = CL754x_CRTC_EXT_START; i <= CL754x_CRTC_EXT_END; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, i);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) | i;
      }

   for (i = CL754x_HRZ_TIME_START; i <= CL754x_HRZ_TIME_END; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, i);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) | i;
      }

   // Set CR2D [7] to {0} and CR2C[5,4] to {1,0}
   // These values provide access to Y shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((Save2D & ~0x80) << 8) | IND_CR2D));
   PortVal = Save2C & ~0x30;              // We'll use PortVal again below
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x20) << 8) | IND_CR2C));

   for (i = 0; i < CL754x_NUM_YSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, yShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     yShadowIndex[i];
      }

   // Set CR2C[5,4] to {1,1}
   // This will provide access to Z shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x30) << 8 )| IND_CR2C));
   for (i = 0; i < CL754x_NUM_ZSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, zShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     zShadowIndex[i];
      }

   // Set CR2C[5,4] to {0,0} and CR2D[7] to {1}
   // This will provide access to X shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,  // PortVal=Save2C & ~0x30
                            (USHORT)((PortVal << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((Save2D | 0x80) << 8) | IND_CR2D));

   for (i = 0; i < CL754x_NUM_XSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, xShadowIndex[i]);
      *pSaveBuf++ = ((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     xShadowIndex[i];
      }

   //Restore the original values for CR2C and CR2D
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)((Save2D << 8) | IND_CR2D));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)((Save2C << 8) | IND_CR2C));

   return NO_ERROR;
}

VP_STATUS NordicRestoreRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pNordicSaveArea
    )
{
   ULONG i;
   UCHAR PortVal, Save2C, Save2D;
   PUSHORT pSaveBuf;
   PUCHAR CRTCAddressPort, CRTCDataPort;

   //
   // Determine where the CRTC registers are addressed (color or mono).
   //
   CRTCAddressPort = HwDeviceExtension->IOAddress;
   CRTCDataPort = HwDeviceExtension->IOAddress;

   if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
               MISC_OUTPUT_REG_READ_PORT) & 0x01)
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
      CRTCDataPort += CRTC_DATA_PORT_COLOR;
      }
   else
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
      CRTCDataPort += CRTC_DATA_PORT_MONO;
      }

   //Initialize the control registers to access shadowed vertical regs
   // CR11[7] = {0} Allows access to CR0-7
   // CR2C[3] = {0} Allows access to Vertical regs (CR6,CR7,CR10,CR11,CR15,CR16
   // CR2D[7] = {0} Blocks access to LCD timing regs (R2X-REX)
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CRTC_PROTECT);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x08));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   pSaveBuf = pNordicSaveArea;
   for (i = 0; i < CL754x_NUM_VSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Make sure we didn't lock CR0-CR7
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CRTC_PROTECT);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   for (i=0; i < (CL754x_NUM_CRTC_EXT_PORTS + CL754x_NUM_HRZ_TIME_PORTS); i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2D [7] to {0} and CR2C[5,4] to {1,0}; save current contents
   // These values provide access to Y shadow registers
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   Save2D = (VideoPortReadPortUchar(CRTCDataPort));
   VideoPortWritePortUchar(CRTCDataPort, (UCHAR)(Save2D & ~0x80));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   PortVal = Save2C = (VideoPortReadPortUchar(CRTCDataPort));
   PortVal &= ~0x30;
   PortVal |= 0x20;
   VideoPortWritePortUchar(CRTCDataPort, PortVal);

   for (i = 0; i < CL754x_NUM_YSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2C[5,4] to {1,1}
   // This will provide access to Z shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x30) << 8) | IND_CR2C) );
   for (i = 0; i < CL754x_NUM_ZSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2C[5,4] to {0,0} and CR2D[7] to {1}
   // This will provide access to X shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal & ~0x30) << 8) | IND_CR2C) );

   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2D | 0x80) << 8) | IND_CR2D) );

   for (i = 0; i < CL754x_NUM_XSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Reset the Blitter, in case it's busy
   //
   VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x0430);
   VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x0030);

   VideoPortWritePortUshort((PUSHORT) CRTCAddressPort,
                            (USHORT)((Save2C << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT) CRTCAddressPort,
                            (USHORT)((Save2D << 8) | IND_CR2D));

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\mode542x.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Mode542x.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
   CL-542x driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The next set of tables are for the CL542x
// Note: all resolutions supported
//

//
// 640x480 16-color mode (BIOS mode 12) set command string for CL 542x.
//

USHORT CL542x_640x480_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 640x480 mode

    EOD                   
};

//
// 800x600 16-color (60Hz refresh) mode set command string for CL 542x.
//

USHORT CL542x_800x600_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 800x600 mode

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 542x.
//

USHORT CL542x_1024x768_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

//
// 80x25 text mode set command string for CL 542x.
// (720x400 pixel resolution; 9x16 character cell.)
//

USHORT CL542x_80x25Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in text mode

    EOD
};

//
// 80x25 text mode set command string for CL 542x.
// (640x350 pixel resolution; 8x14 character cell.)
//

USHORT CL542x_80x25_14_Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,         // no banking in text mode

    EOD
};

//
// 1280x1024 16-color mode (BIOS mode 0x6C) set command string for CL 542x.
//

USHORT CL542x_1280x1024_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD
};

//
// 640x480 64k-color mode (BIOS mode 0x64) set command string for CL 542x.
//

USHORT CL542x_640x480_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};

//
// 640x480 256-color mode (BIOS mode 0x5F) set command string for CL 542x.
//

USHORT CL542x_640x480_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};

//
// 800x600 256-color mode (BIOS mode 0x5C) set command string for CL 542x.
//

USHORT CL542x_800x600_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\i386\clcursor.asm ===
title  "Cirrus hardware pointer routines"

;-----------------------------Module-Header-----------------------------;
; Module Name:  CLCURSOR.ASM
;
; This file contains the pointer shape routines to support the Cirrus
; Logic hardware pointer.
;
; Copyright (c) 1983-1992 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        .386p
        .model  small,c

        include i386\egavga.inc
        include i386\clvga.inc
        include callconv.inc

; Mirrors structure in Cirrus.H.

HW_POINTER_SHIFT_INFO struc
ulXShift        dd      ?
ulYShift        dd      ?
ulShiftedFlag   dd      ?
HW_POINTER_SHIFT_INFO ends

        .code

page
;--------------------------Public-Routine-------------------------------;
; draw_pointer
;
;   Draw a cursor based at (ulVptlX,ulVptlY) (upper left corner).
;
;   The currently defined cursor/icon is drawn.  If the old
;   cursor/icon is currently on the screen, it is removed.
;
; Note: restores all standard VGA registers used to original state.
;
; Entry:
;       Passed parameters on stack:
;               (vptlX,vptlY) = location to which to move pointer
;               pointerLoadAddress -> virtual address of Cirrus display memory into
;                       which to load pointer masks
;               pointerLoadAddress -> Cirrus bank into which to load pointer masks
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       EBX,ESI,EDI,EBP,DS,ES
; Registers Destroyed:
;       EAX,ECX,EDX,flags
; Calls:
;       load_cursor
;-----------------------------------------------------------------------;

cPublicProc CirrusDrawPointer,6,<   \
        uses esi edi ebx,       \
        lVptlX:         dword,  \
        lVptlY:         dword,  \
        pVideoMem:      dword,  \
        pLoadAddress:   dword,  \
        pAndMask:       ptr,    \
        pShiftInfo:     ptr     >

	local	SavedSeqMode :byte
	local	SavedProA    :byte
	local	SavedExtReg  :byte
	local	SaveGRFIndex :byte
	local	SaveEnableSR :byte
	local	SaveMapMask  :byte
	local	SaveSetReset :byte
	local	SaveGR5      :byte
        local   SaveGR3      :byte
        local   SaveSR7      :byte

; Save the state of the banking and set the read and write banks to access the
; pointer bitmap.

        mov     edx,EGA_BASE + SEQ_ADDR
	cli
        mov     al,SEQ_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SavedSeqMode,al
        or      al,SM_CHAIN4
        out     dx,al
        dec     dx
	mov	al,SEQ_MAP_MASK
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveMapMask,al				;8 bit map mask

        mov     edx,EGA_BASE + GRAF_ADDR
	in	al,dx					;Read graphics index reg
	mov	SaveGRFIndex,al				;save it

	mov	al,AVGA_PROA
	out	dx,al					;Set for OFFSET 0 reg
	inc	dx
	in	al,dx
	mov	SavedProA,al				;Save OFFSET 0 reg
	dec	dx

	mov	al,AVGA_MODE_EXTENSIONS
	out	dx,al					;Set for extensions reg
	inc	dx
	in	al,dx
	sti
	dec	dx
	mov	SavedExtReg,al				;Save extensions

	test	al,1110b				;Are extensionsETC enabled?
	jz	@F					;no...

	cli
	mov	al,GRAF_ENAB_SR
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveEnableSR,al				;8 bit enable set reset
	mov	al,0
	out	dx,al					;set to 0!
	dec	dx

	mov	al,GRAF_SET_RESET
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveSetReset,al				;8 bit set reset

        mov     edx,EGA_BASE + SEQ_ADDR
;??do we need this
	mov	al,0FFh
	out	dx,al

        mov     edx,EGA_BASE + GRAF_ADDR
	mov	al,GRAF_MODE
	out	dx,al
	inc	dx
	in	al,dx					;save VGA mode
	mov	SaveGR5,al
	mov	al,01000000b
	out	dx,al
	dec	dx
        mov     al,GRAF_DATA_ROT
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveGR3,al
        mov     al,0
        out     dx,al
        dec     dx
	sti
@@:
        mov     eax,pLoadAddress        ; calculate bank from pointer pat addr
        shr     eax,6                   ; ah = bank to select
@@:
        mov     al,AVGA_PROA            ; al = bank select register
        out     dx,ax
	mov	ax,EXT_WR_MODES shl 8 + AVGA_MODE_EXTENSIONS
	out	dx,ax					;packed pel mode

; See if the masks need to be shifted; if they do, shift and
; load them. If the default masks can be used but the last masks
; loaded were shifted, load the default masks.

        mov     eax,lVptlX
        mov     ebx,lVptlY
        mov     ecx,ebx
        or      ecx,eax                 ;is either coordinate negative?
        jns     draw_cursor_unshifted   ;no-make sure the unshifted masks
                                        ; are loaded
                                        ;yes-make sure the right shift
                                        ; pattern is loaded

;  Determine the extent of the needed adjustment to the masks.

; If X is positive, no X shift is needed; if it is negative,
; then its absolute value is the X shift amount.

        and     eax,eax
        jns     short dcs_p1
        neg     eax                     ;required X shift
        jmp     short dcs_p2

        align   4
dcs_p1:
        sub     eax,eax                 ;no X shift required
dcs_p2:

; If Y is positive, no Y shift is needed; if it is negative,
; then its absolute value is the Y shift amount.

        and     ebx,ebx
        jns     short dcs_p3
        neg     ebx                     ;required Y shift
        jmp     short dcs_p4

        align   4
dcs_p3:
        sub     ebx,ebx
dcs_p4:
        cmp     ebx,PTR_HEIGHT          ;keep Y in the range 1-PTR_HEIGHT
        jbe     short ck_x_overflow
        mov     ebx,PTR_HEIGHT
ck_x_overflow:
        cmp     eax,(PTR_WIDTH * 8)     ;keep X in the range
                                        ; 0 through ( PTR_WIDTH * 8 )
        jb      short ck_current_shift
        mov     ebx,PTR_HEIGHT          ;if X is fully off the screen,
                                        ; simply move Y off the screen, which
                                        ; is simpler to implement below

; Shifted masks are required. If the currently loaded masks are shifted in the
; same way as the new masks, don't need to do anything; otherwise, the shifted
; masks have to be generated and loaded.

ck_current_shift:
        mov     edi,pShiftInfo
        cmp     [edi].ulShiftedFlag,1   ;if there are no currently loaded
                                        ; masks or the currently loaded masks
                                        ; are unshifted, must load shifted
                                        ; masks
        mov     edi,pShiftInfo
        jnz     short generate_shifted_masks ;no currently loaded shifted masks
        cmp     eax,[edi].ulXShift           ;if X and Y shifts are both the
        jnz     short generate_shifted_masks ; same as what's already loaded
        cmp     ebx,[edi].ulYShift      ; memory, then there's no need
                                        ; to do anything
        jz      draw_cursor_set_location ;Don't need to do anything

; Load the Cirrus cursor with the masks, shifted as required by
; the current X and Y.

generate_shifted_masks:

        mov     [edi].ulXShift,eax
        mov     [edi].ulYShift,ebx

        mov     edi,eax                 ;preserve X shift value

; Set the Map Mask to enable all planes.

        call    wait4VertRetrace
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     eax,SEQ_MAP_MASK + 00f00h
        out     dx,ax
        mov     al,SEQ_EXT_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveSR7,al
        or      al,SEQ_HIRES_MODE
        out     dx,al

        mov     eax,edi                 ;retrieve X shift value

; Load the masks.

        xchg    al,bl                   ;BL=X shift value, AL=Y shift value
        cbw
        cwde
        neg     eax
        add     eax,PTR_HEIGHT          ;unpadded length of cursor
        and     bl,31                   ;X partial byte portion (bit shift)

        mov     edi,pLoadAddress        ;start of cursor load area
        and     edi,3FFFh               ; mask to 16K granularity
        add     edi,pVideoMem           ; move into protected mode space
        mov     esi,pAndMask            ;ESI points to start of AND mask
                                        
        call    shift_mask              ;generate shifted masks

; Restore default Bit Mask setting.

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_EXT_MODE
        mov     ah,SaveSR7
        out     dx,ax
        mov     edx,EGA_BASE + GRAF_ADDR
        mov     eax,GRAF_BIT_MASK + 0ff00h
        out     dx,ax

        mov     esi,pShiftInfo
        mov     [esi].ulShiftedFlag,1   ;mark that the currently loaded
                                        ; masks are shifted
        jmp     draw_cursor_set_location


; Default masks can be used. See if any masks are loaded into memory; if so
; see if they were shifted: if they were, load unshifted masks; if they
; weren't, the masks are already properly loaded into Cirrus memory.
        align   4
draw_cursor_unshifted:
        mov     esi,pShiftInfo
        cmp     [esi].ulShiftedFlag,0 ;are there any currently loaded masks,
                                      ; and if so, are they shifted?
        jz      draw_cursor_set_location  ;no-all set
                                                ;yes-load unshifted masks
        call    wait4VertRetrace
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_EXT_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveSR7,al
        or      al,SEQ_HIRES_MODE
        out     dx,al

        mov     esi,pAndMask    ;ESI points to default masks

; Copy the cursor patterns into Cirrus mask memory, one mask at a time.

        mov     ecx,PTR_HEIGHT*4        ;move 4 bytes per scanline of each mask
        mov     edi,pLoadAddress        ;start of cursor load area
        and     edi,3FFFh               ; mask to 16K granularity
        add     edi,pVideoMem           ; move into protected mode spaced
        add     esi,128
        rep     movsb
        mov     ecx,PTR_HEIGHT*4
        sub     esi,256
load_and_mask_loop:
        lodsb
        not     eax                     ; cirrus and mask is backwards
        stosb
        loop    load_and_mask_loop

; Restore the default Map Mask.

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     eax,SEQ_MAP_MASK + 00f00h
        out     dx,ax
        mov     al,SEQ_EXT_MODE
        mov     ah,SaveSR7
        out     dx,ax

        mov     esi,pShiftInfo
        mov     [esi].ulShiftedFlag,0   ;mark that the currently loaded masks
                                        ; are unrotated
; Set the new cursor location.

draw_cursor_set_location:
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     ecx,lVptlX        ;set X coordinate
        and     ecx,ecx
        jns     short set_x_coord ;if negative, force to 0 (the masks in
        sub     ecx,ecx           ; Cirrus memory have already been shifted
                                  ; to compensate)
set_x_coord:

        mov     ebx,lVptlY        ;set Y coordinate
        and     ebx,ebx
        jns     short set_y_coord ;if negative, force to 0 (the masks in
        sub     ebx,ebx           ; Cirrus memory have already been shifted
                                  ; to compensate)
set_y_coord:

        mov     ax,cx
        shl     ax,5            ; move x-coord into position
        or      al,SEQ_PX       ; generate reg addr based on x-coordinate
        out     dx,ax           ; (10,30,...,D0,F0)

        mov     ax,bx
        shl     ax,5            ; move y-coord into position
        or      al,SEQ_PY       ; generate reg addr based on y-coordinate
        out     dx,ax           ; (10,30,...,D0,F0)

; Restore Cirrus registers to their original states.

        mov     edx,EGA_BASE + GRAF_ADDR
	mov	al,AVGA_PROA
	mov	ah,SavedProA
	out	dx,ax
	mov	al,AVGA_MODE_EXTENSIONS
	mov	ah,SavedExtReg
	out	dx,ax

	test	ah,1110b				;Are any exts enabled?
	jz	@F					;no...

	mov	al,GRAF_SET_RESET
	mov	ah,SaveSetReset
	out	dx,ax
	mov	al,GRAF_ENAB_SR
	mov	ah,SaveEnableSR
	out	dx,ax
	mov	al,GRAF_MODE
	mov	ah,SaveGR5
	out	dx,ax
        mov     al,GRAF_DATA_ROT
        mov     ah,SaveGR3
        out     dx,ax
@@:

	mov	al,SaveGRFIndex
	out	dx,al

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_MODE
        mov     ah,SavedSeqMode
        out     dx,ax

	mov	al,SEQ_MAP_MASK
	mov	ah,SaveMapMask
	out	dx,ax           ;restore default sequencer index and map mask

        stdRET  CirrusDrawPointer

stdENDP CirrusDrawPointer

page
;--------------------------------------------------------------------;
; wait4VertRetrace
;
;       Returns when the vertical retrace bit has switched from 0 to 1
;
;--------------------------------------------------------------------;
wait4VertRetrace        proc    near
        mov     edx,EGA_BASE + IN_STAT_1
@@:
        in      al,dx
        and     al,08h          ; wait for vertical retrace to be clear
        jnz     @b
@@:
        in      al,dx
        and     al,08h          ; now wait for it to be set
        jz      @b
        ret                     ; vertical retrace just started
wait4VertRetrace        endp

page
;--------------------------------------------------------------------;
; shift_mask
;
;       Loads a shifted cursor mask.
;
;       Input:  EAX = unpadded mask height (vertical shift)
;               BL = amount of shift to left (horizontal shift)
;               DS:ESI = --> to unshifted masks to load
;               ES:EDI = --> to Cirrus mask memory to load
;
;       Output: DS:ESI = --> byte after unshifted masks
;               ES:EDI = --> to byte after Cirrus mask memory loaded
;
;       BH, CH destroyed.
;       Map Mask must enable all planes.
;--------------------------------------------------------------------;

        align   4
shift_mask      proc    near

        push    ebp                     ; use ebp for mask
	cmp	bl,0
	je	UPCFast
        mov     ecx,32
        sub     ecx,eax
        shl     ecx,2                   ; 4 bytes per scanline
        add     esi,ecx
        push    esi
        push    eax                     ; assumed non-zero, use as 1st time flag
        add	esi,128                 ; do XOR mask first
        xor     ebp,ebp
UPCSlow:
        mov     bh,al
        mov     ecx,32
        sub     ecx,eax
        push    ecx                     ; number of scanlines to pad at bottom
UPCLoop1:
	lodsw				;Fetch 32 bits
	mov	dx,[esi]
        xor     eax,ebp
        xor     edx,ebp
	inc	esi
	inc	esi
        xor     ecx,ecx                 ; clear high bytes of ecx
	mov	cl,bl                   ; shift count in ecx
UPCLoop2:				;Shift loop
	shl	dh,1
	adc	dl,dl
	adc	ah,ah
	adc	al,al
	loop	UPCLoop2
	stosw				;write shifted data
	mov	ax,dx
	stosw
	dec	bh			;done one scan
	jnz	UPCLoop1		;do the rest
	
        pop     ecx                     ; # of dwords to pad after visible mask
	xor	eax,eax
	rep	stosd			;write 0's for transparent

        pop     eax
        and     ax,ax
	jz	end_shift_mask          ;already 0, done...

        pop     esi
        xor     ecx,ecx
        push    ecx
        dec     ebp
	jmp	UPCSlow			;second pass..

UPCFast:
        mov     ebx,eax                 ; number of visible scans in ebx
        mov     ecx,ebx                 ; 1 dword per scan
	mov	edx,32                  ; total dwords in a mask
	sub	edx,ecx			; no. transparent dwords to add at end
        push    esi                     ; remember where the mask starts
        add     esi,128
; First do the XOR mask - just move the visible part, then pad with zeroes
        shl     edx,2
        add     esi,edx
        shr     edx,2
	mov	ecx,ebx
	rep	movsd			; Move opaque plane
	mov	ecx,edx
	xor	eax,eax                 ; pad with zeroes
	rep	stosd			; transparent

        pop     esi
        shl     edx,2
        add     esi,edx
        shr     edx,2
        mov     ecx,ebx
; Then handle the AND mask - remember that our hardware is backwards here	
@@:                     
        lodsd
        not     eax
        stosd
        loop    @b
	mov	ecx,edx
	xor	eax,eax                 ; pad with zeroes
	rep	stosd			; transparent
end_shift_mask:
        pop     ebp
        ret
shift_mask      endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\i386\clvga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  EGA.INC
;
; This file contains the definitions of the EGA registers used by
; the driver.
;
; Copyright (c) 1988-1993 Microsoft Corporation
;
; General Description:
;
;-----------------------------------------------------------------------;

HW_POINTER_LEN equ 100h            ;# of VGA addresses used by hardware

SEQ_EXT_MODE     equ     007h           ; Extended Sequencer Mode index
SEQ_HIRES_MODE   equ     001h           ; select true packed pixel addressing
SEQ_PX           equ     010h           ; X start index
SEQ_PY           equ     011h           ; Y start index
SEQ_PPA          equ     013h           ;pointer pattern address index

AVGA_PROA               equ     009h    ;banking control register
AVGA_MODE_EXTENSIONS    equ     00Bh
EXT_WR_MODES    equ     24h             ; enable extended write modes in GRB

SEQ_EXT_WRITE_CONTROL equ 0f3h

PTR_HEIGHT      equ     32              ;height of hardware pointer in scans
PTR_WIDTH       equ     4               ;width of hardware pointer in bytes
PTR_WIDTH_IN_PIXELS equ     32          ;width of hardware pointer in pixels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) Microsoft Corporation 1989 - 1993
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

;       Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT     EQU     0C2h            ;Miscellaneous Output Register
CRTC_ADDR       EQU     0D4h            ;CRTC Address Register for color mode
CRTC_DATA       EQU     0D5h            ;CRTC Data    Register for color mode
GRAF_1_POS      EQU     0CCh            ;Graphics 1 Address Register
GRAF_2_POS      EQU     0CAh            ;Graphics 2 Address Register
ATTR_READ       EQU     0DAh            ;Attribute Controler Read  Address
ATTR_WRITE      EQU     0C0h            ;Attribute Controler Write Address
IN_STAT_0       EQU     0C2h            ;Input Status Register 0
IN_STAT_1       EQU     0DAh            ;Input Status Register 1



;       EGA/VGA Register Definitions.
;
;       The following definitions are the EGA/VGA registers and values
;       used by this driver.  All other registers are set up at
;       when the EGA/VGA is placed into graphics mode and never altered
;       afterwards.
;
;       All unspecified bits in the following registers must be 0.


EGA_BASE        EQU     300h            ;Base address of the EGA (3xx)
VGA_BASE        EQU     300h            ;Base address of the VGA (3xx)



;       EGA/VGA Register Definitions.

EGA_BASE        EQU     300h            ;Base address of the EGA (3xx)
VGA_BASE        EQU     300h            ;Base address of the VGA (3xx)

;       SEQUencer Registers Used

SEQ_ADDR        EQU     0C4h            ;SEQUencer Address Register
SEQ_DATA        EQU     0C5h            ;SEQUencer Data    Register

SEQ_MAP_MASK    EQU     02h             ;Write Plane Enable Mask
MM_C0           EQU     00000001b       ;  C0 plane enable
MM_C1           EQU     00000010b       ;  C1 plane enable
MM_C2           EQU     00000100b       ;  C2 plane enable
MM_C3           EQU     00001000b       ;  C3 plane enable
MM_ALL          EQU     00001111b       ;  All planes

SEQ_MODE        EQU     04h             ;Memory Mode
SM_ALPHA        EQU     00000001b       ;  Char map select enable
SM_EXTENDED     EQU     00000010b       ;  Extended memory present
SM_ODD_PLANE    EQU     00000100b       ;  Odd/even bytes to same plane
SM_CHAIN4       EQU     00001000b       ;  Chain4 mode

;       Graphics Controller Registers Used

GRAF_ADDR       EQU     0CEh            ;Graphics Controller Address Register
GRAF_DATA       EQU     0CFh            ;Graphics Controller Data    Register

GRAF_SET_RESET  EQU     00h             ;  Set/Reset Plane Color
GRAF_ENAB_SR    EQU     01h             ;  Set/Reset Enable
GRAF_COL_COMP   EQU     02h             ;  Color Compare Register

GRAF_DATA_ROT   EQU     03h             ;  Data Rotate Register
DR_ROT_CNT      EQU     00000111b       ;    Data Rotate Count
DR_SET          EQU     00000000b       ;    Data Unmodified
DR_AND          EQU     00001000b       ;    Data ANDed with latches
DR_OR           EQU     00010000b       ;    Data ORed  with latches
DR_XOR          EQU     00011000b       ;    Data XORed with latches

GRAF_READ_MAP   EQU     04h             ;  Read Map Select Register
RM_C0           EQU     00000000b       ;    Read C0 plane
RM_C1           EQU     00000001b       ;    Read C1 plane
RM_C2           EQU     00000010b       ;    Read C2 plane
RM_C3           EQU     00000011b       ;    Read C3 plane

GRAF_MODE       EQU     05h             ;  Mode Register
M_PROC_WRITE    EQU     00000000b       ;    Write processor data rotated
M_LATCH_WRITE   EQU     00000001b       ;    Write latched data
M_COLOR_WRITE   EQU     00000010b       ;    Write processor data as color
M_AND_WRITE     EQU     00000011b       ;    Write (procdata AND bitmask)
M_DATA_READ     EQU     00000000b       ;    Read selected plane
M_COLOR_READ    EQU     00001000b       ;    Read color compare

GRAF_MISC       EQU     06h             ;  Miscellaneous Register
MS_NON_ALPHA    EQU     00000001b       ;    Char generator disabled
MS_ODD_EVEN     EQU     00000010b       ;    Map odd addresses to even
MS_A0000_128K   EQU     00000000b       ;    Memory present at A0000, 128kb
MS_A0000_64K    EQU     00000100b       ;    Memory present at A0000, 64kb
MS_B0000_32K    EQU     00001000b       ;    Memory present at B0000, 32kb
MS_B8000_32K    EQU     00001100b       ;    Memory present at B8000, 32kb
MS_ADDR_MASK    EQU     00001100b

GRAF_CDC        EQU     07h             ;  Color Don't Care Register
GRAF_BIT_MASK   EQU     08h             ;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT      EQU     32
PTR_WIDTH       EQU     4                       ;Width in bytes of pointer
PTR_WIDTH_BITS  EQU     PTR_WIDTH*8             ;Width in bits of pointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\color.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\driver.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* contains prototypes for the frame buffer driver.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "stddef.h"
#include <stdarg.h>
#include "windef.h"
#include "wingdi.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"
#include "debug.h"

typedef struct  _PDEV
{
    HANDLE  hDriver;                    // Handle to \Device\Screen
    HDEV    hdevEng;                    // Engine's handle to PDEV
    HSURF   hsurfEng;                   // Engine's handle to surface
    HPALETTE hpalDefault;               // Handle to the default palette for device.
    PBYTE   pjScreen;                   // This is pointer to base screen address
    ULONG   cxScreen;                   // Visible screen width
    ULONG   cyScreen;                   // Visible screen height
    POINTL  ptlOrg;                     // Where this display is anchored in
                                        //   the virtual desktop.
    ULONG   ulMode;                     // Mode the mini-port driver is in.
    LONG    lDeltaScreen;               // Distance from one scan to the next.
    ULONG   cScreenSize;                // size of video memory, including
                                        // offscreen memory.
    PVOID   pOffscreenList;             // linked list of DCI offscreen surfaces.
    FLONG   flRed;                      // For bitfields device, Red Mask
    FLONG   flGreen;                    // For bitfields device, Green Mask
    FLONG   flBlue;                     // For bitfields device, Blue Mask
    ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
    POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
    VIDEO_POINTER_CAPABILITIES PointerCapabilities; // HW pointer abilities
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes; // hardware pointer attributes
    DWORD   cjPointerAttributes;        // Size of buffer allocated
    BOOL    fHwCursorActive;            // Are we currently using the hw cursor
    PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal
    BOOL    bSupportDCI;                // Does the miniport support DCI?
    FLONG   flHooks;
} PDEV, *PPDEV;

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInitPointer(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisableSURF(PPDEV);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"framebuf"   // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "FRAMEBUF: "  // All debug output is prefixed
#define ALLOC_TAG               'bfDD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\cirrus\mini\i386\clhard.asm ===
title  "Cirrus Logic ASM routines"
;

;ONE_64K_BANK    equ     1
TWO_32K_BANKS   equ     1

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;     vgahard.asm
;
; Abstract:
;
;     This module implements the banding code for the Cirrus Logic 6410,6420
;       and 542x VGA's.
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;
;--

.386p
        .xlist
include callconv.inc
        .list

;----------------------------------------------------------------------------
;
; Cirrus Logic banking control ports.
;
GRAPHICS_ADDRESS_PORT equ   03ceh      ;banking control here
CL6420_BANKING_INDEX_PORT_A equ   0eh        ;banking index register A is GR0E
CL6420_BANKING_INDEX_PORT_B equ   0fh        ;banking index register B is GR0F
CL542x_BANKING_INDEX_PORT_A equ   09h        ;banking index register A is GR09
CL542x_BANKING_INDEX_PORT_B equ   0ah        ;banking index register B is GR0A

SEQ_ADDRESS_PORT equ        03C4h      ;Sequencer Address register
IND_MEMORY_MODE  equ        04h        ;Memory Mode reg. index in Sequencer
CHAIN4_MASK      equ        08h        ;Chain4 bit in Memory Mode register

;----------------------------------------------------------------------------

;_TEXT   SEGMENT DWORD USE32 PUBLIC 'CODE'
;        ASSUME  CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
;    Bank switching code. This is a 1-64K-read/1-64K-write bank adapter
;    (VideoBanked1R1W).
;
;    Input:
;          EAX = desired read bank mapping
;          EDX = desired write bank mapping
;
;    Note: values must be correct, with no stray bits set; no error
;       checking is performed.
;
        public _CL64xxBankSwitchStart
        public _CL64xxBankSwitchEnd
        public _CL64xxPlanarHCBankSwitchStart
        public _CL64xxPlanarHCBankSwitchEnd
        public _CL64xxEnablePlanarHCStart
        public _CL64xxEnablePlanarHCEnd
        public _CL64xxDisablePlanarHCStart
        public _CL64xxDisablePlanarHCEnd

        public _CL542xBankSwitchStart
        public _CL542xBankSwitchEnd
        public _CL542xPlanarHCBankSwitchStart
        public _CL542xPlanarHCBankSwitchEnd
        public _CL542xEnablePlanarHCStart
        public _CL542xEnablePlanarHCEnd
        public _CL542xDisablePlanarHCStart
        public _CL542xDisablePlanarHCEnd

        public _CL543xBankSwitchStart
        public _CL543xBankSwitchEnd
        public _CL543xPlanarHCBankSwitchStart
        public _CL543xPlanarHCBankSwitchEnd

        align 4

;----------------------------------------------------------------------------
_CL64xxBankSwitchStart proc                   ;start of bank switch code
_CL64xxPlanarHCBankSwitchStart:               ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,3                   ;shift them to bits 7-4
        shl     edx,3                   ;shift them to bits 7-4
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                     ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx                    ; save graphics index
        push    eax
        mov     al,CL6420_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank
        rol     edx,16
        mov     ah,dl
        mov     al,CL6420_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL64xxBankSwitchEnd:
_CL64xxPlanarHCBankSwitchEnd:

        align 4
_CL64xxEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

ERA1_INDEX            equ 0A1h

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h              ; turn off the shift bits
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_CL64xxEnablePlanarHCEnd:

        align 4
_CL64xxDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h
        or      al,20h
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_CL64xxDisablePlanarHCEnd:

_CL64xxBankSwitchStart endp


_CL542xBankSwitchStart proc                   ;start of bank switch code
_CL542xPlanarHCBankSwitchStart:               ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,3                   ;shift them to bits 7-4
        shl     edx,3                   ;shift them to bits 7-4
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                  ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx
        push    eax
        mov     al,CL542x_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank

        rol     edx,16                          ; restore write value
        mov     ah,dl
        mov     al,CL542x_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL542xBankSwitchEnd:
_CL542xPlanarHCBankSwitchEnd:

        align 4
_CL542xEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

_CL542xEnablePlanarHCEnd:

        align 4
_CL542xDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

_CL542xDisablePlanarHCEnd:


_CL542xBankSwitchStart endp

;
;       543x banking assumes 16k granularity to allow up to 4-meg modes
;
_CL543xBankSwitchStart proc             ;start of bank switch code
_CL543xPlanarHCBankSwitchStart:         ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,1                   ;shift them to bits 4-1
        shl     edx,1                   ;shift them to bits 4-1
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                  ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx
        push    eax
        mov     al,CL542x_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank

        rol     edx,16                          ; restore write value
        mov     ah,dl
        mov     al,CL542x_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL543xBankSwitchEnd:
_CL543xPlanarHCBankSwitchEnd:

_CL543xBankSwitchStart endp


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\debug.h ===
/***************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}

#else

#define DISPDBG(arg)
#define RIP(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\debug.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\enable.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvOffset,                (PFN) DrvOffset             },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};

// Define the functions you want to hook for 8/16/24/32 pel formats

#define HOOKS_BMF8BPP 0

#define HOOKS_BMF16BPP 0

#define HOOKS_BMF24BPP 0

#define HOOKS_BMF32BPP 0

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        DISPDBG((0, "DISP DrvEnablePDEV failed EngAllocMem\n"));
        return((DHPDEV) 0);
    }

    memset(ppdev, 0, sizeof(PDEV));

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"DISP DrvEnablePDEV failed\n"));
        goto error_free;
    }

    // Initialize the cursor information.

    if (!bInitPointer(ppdev, &DevInfo))
    {
        // Not a fatal error...
        DISPDBG((0, "DrvEnablePDEV failed bInitPointer\n"));
    }

    // Initialize palette information.

    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        DISPDBG((0, "DrvEnablePDEV failed bInitPalette\n"));
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    EngFreeMem(ppdev);
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
    vDisablePalette((PPDEV) dhpdev);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvOffset
*
* DescriptionText
*
\**************************************************************************/

BOOL DrvOffset(
SURFOBJ*    pso,
LONG        x,
LONG        y,
FLONG       flReserved)
{
    PDEV*   ppdev = (PDEV*) pso->dhpdev;

    // Add back last offset that we subtracted.  I could combine the next
    // two statements, but I thought this was more clear.  It's not
    // performance critical anyway.

    ppdev->pjScreen += ((ppdev->ptlOrg.y * ppdev->lDeltaScreen) +
                        (ppdev->ptlOrg.x * ((ppdev->ulBitCount+1) >> 3)));

    // Subtract out new offset

    ppdev->pjScreen -= ((y * ppdev->lDeltaScreen) +
                        (x * ((ppdev->ulBitCount+1) >> 3)));

    ppdev->ptlOrg.x = x;
    ppdev->ptlOrg.y = y;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    ppdev->ptlOrg.x = 0;
    ppdev->ptlOrg.y = 0;

    if (!bInitSURF(ppdev, TRUE))
    {
        DISPDBG((0, "DISP DrvEnableSurface failed bInitSURF\n"));
        return(FALSE);
    }

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 8)
    {
        if (!bInit256ColorPalette(ppdev)) {
            DISPDBG((0, "DISP DrvEnableSurface failed to init the 8bpp palette\n"));
            return(FALSE);
        }
        ulBitmapType = BMF_8BPP;
        flHooks = HOOKS_BMF8BPP;
    }
    else if (ppdev->ulBitCount == 16)
    {
        ulBitmapType = BMF_16BPP;
        flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
        ulBitmapType = BMF_24BPP;
        flHooks = HOOKS_BMF24BPP;
    }
    else
    {
        ulBitmapType = BMF_32BPP;
        flHooks = HOOKS_BMF32BPP;
    }

    ppdev->flHooks = flHooks;

    hsurf = (HSURF)EngCreateDeviceSurface((DHSURF)ppdev, 
                                           sizl,
                                           ulBitmapType);

    if (hsurf == (HSURF) 0)
    {
        DISPDBG((0, "DISP DrvEnableSurface failed EngCreateDeviceSurface\n"));
        return(FALSE);
    }

    if ( !EngModifySurface(hsurf,
                           ppdev->hdevEng,
                           ppdev->flHooks | HOOK_SYNCHRONIZE,
                           MS_NOTSYSTEMMEMORY,
                           (DHSURF)ppdev,
                           ppdev->pjScreen,
                           ppdev->lDeltaScreen,
                           NULL))
    {
        DISPDBG((0, "DISP DrvEnableSurface failed EngModifySurface\n"));
        return(FALSE);
    }

    ppdev->hsurfEng = hsurf;

    return(hsurf);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;
    PBYTE   pjScreen;

    if (bEnable)
    {

        //
        // The screen must be reenabled, reinitialize the device to clean state.
        //

        pjScreen = ppdev->pjScreen;

        if (!bInitSURF(ppdev, FALSE))
        {
            DISPDBG((0, "DISP DrvAssertMode failed bInitSURF\n"));
            return (FALSE);
        }

        if (pjScreen != ppdev->pjScreen) {

            if ( !EngModifySurface(ppdev->hsurfEng,
                                   ppdev->hdevEng,
                                   ppdev->flHooks | HOOK_SYNCHRONIZE,
                                   MS_NOTSYSTEMMEMORY,
                                   (DHSURF)ppdev,
                                   ppdev->pjScreen,
                                   ppdev->lDeltaScreen,
                                   NULL))
            {
                DISPDBG((0, "DISP DrvAssertMode failed EngModifySurface\n"));
                return (FALSE);
            }
        }

        return (TRUE);
    }
    else
    {
        //
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
        {
            DISPDBG((0, "DISP DrvAssertMode failed IOCTL\n"));
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((3, "DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW)
                                                     + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}

VOID DrvSynchronize(
IN DHPDEV dhpdev,
IN RECTL *prcl)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\pointer.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c                                                   *
*                                                                          *
* This module contains the hardware Pointer support for the framebuffer    *
*                                                                          *
* Copyright (c) 1992-1998 Microsoft Corporation                            *
\**************************************************************************/

#include "driver.h"

BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo);

BOOL bCopyMonoPointer(
PPDEV ppdev,
SURFOBJ *psoMask);

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl);

/******************************Public*Routine******************************\
* DrvMovePointer
*
* Moves the hardware pointer to a new position.
*
\**************************************************************************/

VOID DrvMovePointer
(
    SURFOBJ *pso,
    LONG     x,
    LONG     y,
    RECTL   *prcl
)
{
    PPDEV ppdev = (PPDEV) pso->dhpdev;
    DWORD returnedDataLength;
    VIDEO_POINTER_POSITION NewPointerPosition;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.

    UNREFERENCED_PARAMETER(prcl);

    // Convert the pointer's position from relative to absolute
    // coordinates (this is only significant for multiple board
    // support).

    x -= ppdev->ptlOrg.x;
    y -= ppdev->ptlOrg.y;

    // If x is -1 after the offset then take down the cursor.

    if (x == -1)
    {
        //
        // A new position of (-1,-1) means hide the pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }
    }
    else
    {
        NewPointerPosition.Column = (SHORT) x - (SHORT) (ppdev->ptlHotSpot.x);
        NewPointerPosition.Row    = (SHORT) y - (SHORT) (ppdev->ptlHotSpot.y);

        //
        // Call miniport driver to move Pointer.
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_POINTER_POSITION,
                               &NewPointerPosition,
                               sizeof(VIDEO_POINTER_POSITION),
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // Not the end of the world, print warning in checked build.
            //

            DISPDBG((1, "DISP vMoveHardwarePointer failed IOCTL_VIDEO_SET_POINTER_POSITION\n"));
        }
    }
}

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape
(
    SURFOBJ  *pso,
    SURFOBJ  *psoMask,
    SURFOBJ  *psoColor,
    XLATEOBJ *pxlo,
    LONG      xHot,
    LONG      yHot,
    LONG      x,
    LONG      y,
    RECTL    *prcl,
    FLONG     fl
)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    DWORD   returnedDataLength;

    // We don't use the exclusion rectangle because we only support
    // hardware Pointers. If we were doing our own Pointer simulations
    // we would want to update prcl so that the engine would call us
    // to exclude out pointer before drawing to the pixels in prcl.
    UNREFERENCED_PARAMETER(prcl);

    if (ppdev->pPointerAttributes == (PVIDEO_POINTER_ATTRIBUTES) NULL)
    {
        // Mini-port has no hardware Pointer support.
        return(SPS_ERROR);
    }

    // See if we are being asked to hide the pointer

    if (psoMask == (SURFOBJ *) NULL)
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_DISABLE_POINTER,
                               NULL,
                               0,
                               NULL,
                               0,
                               &returnedDataLength))
        {
            //
            // It should never be possible to fail.
            // Message supplied for debugging.
            //

            DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
        }

        return(TRUE);
    }

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    if (!bSetHardwarePointerShape(pso,psoMask,psoColor,pxlo,x,y,fl))
    {
            if (ppdev->fHwCursorActive) {
                ppdev->fHwCursorActive = FALSE;

                if (EngDeviceIoControl(ppdev->hDriver,
                                       IOCTL_VIDEO_DISABLE_POINTER,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       &returnedDataLength)) {

                    DISPDBG((1, "DISP bSetHardwarePointerShape failed IOCTL_VIDEO_DISABLE_POINTER\n"));
                }
            }

            //
            // Mini-port declines to realize this Pointer
            //

            return(SPS_DECLINE);
    }
    else
    {
        ppdev->fHwCursorActive = TRUE;
    }

    return(SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* bSetHardwarePointerShape
*
* Changes the shape of the Hardware Pointer.
*
* Returns: True if successful, False if Pointer shape can't be hardware.
*
\**************************************************************************/

BOOL bSetHardwarePointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      x,
LONG      y,
FLONG     fl)
{
    PPDEV     ppdev = (PPDEV) pso->dhpdev;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    DWORD     returnedDataLength;

    if (psoColor != (SURFOBJ *) NULL)
    {
        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER) &&
                bCopyColorPointer(ppdev, psoMask, psoColor, pxlo))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_COLOR_POINTER;
        } else {
            return(FALSE);
        }

    } else {

        if ((ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER) &&
                bCopyMonoPointer(ppdev, psoMask))
        {
            pPointerAttributes->Flags |= VIDEO_MODE_MONO_POINTER;
        } else {
            return(FALSE);
        }
    }

    //
    // Initialize Pointer attributes and position
    //

    pPointerAttributes->Enable = 1;

    //
    // if x,y = -1,-1 then pass them directly to the miniport so that
    // the cursor will be disabled

    pPointerAttributes->Column = (SHORT)(x);
    pPointerAttributes->Row    = (SHORT)(y);

    if ((x != -1) || (y != -1)) {
        pPointerAttributes->Column -= (SHORT)(ppdev->ptlHotSpot.x);
        pPointerAttributes->Row    -= (SHORT)(ppdev->ptlHotSpot.y);
    }

    //
    // set animate flags
    //

    if (fl & SPS_ANIMATESTART) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_START;
    } else if (fl & SPS_ANIMATEUPDATE) {
        pPointerAttributes->Flags |= VIDEO_MODE_ANIMATE_UPDATE;
    }

    //
    // Set the new Pointer shape.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_POINTER_ATTR,
                           pPointerAttributes,
                           ppdev->cjPointerAttributes,
                           NULL,
                           0,
                           &returnedDataLength)) {

        DISPDBG((1, "DISP:Failed IOCTL_VIDEO_SET_POINTER_ATTR call\n"));
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyMonoPointer
*
* Copies two monochrome masks into a buffer of the maximum size handled by the
* miniport, with any extra bits set to 0.  The masks are converted to topdown
* form if they aren't already.  Returns TRUE if we can handle this pointer in
* hardware, FALSE if not.
*
\**************************************************************************/

BOOL bCopyMonoPointer(
    PPDEV    ppdev,
    SURFOBJ *pso)
{
    ULONG cy;
    PBYTE pjSrcAnd, pjSrcXor;
    LONG  lDeltaSrc, lDeltaDst;
    LONG  lSrcWidthInBytes;
    ULONG cxSrc = pso->sizlBitmap.cx;
    ULONG cySrc = pso->sizlBitmap.cy;
    ULONG cxSrcBytes;
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes = ppdev->pPointerAttributes;
    PBYTE pjDstAnd = pPointerAttributes->Pixels;
    PBYTE pjDstXor = pPointerAttributes->Pixels;

    // Make sure the new pointer isn't too big to handle
    // (*2 because both masks are in there)
    if ((cxSrc > ppdev->PointerCapabilities.MaxWidth) ||
        (cySrc > (ppdev->PointerCapabilities.MaxHeight * 2)))
    {
        return(FALSE);
    }

    pjDstXor += ((ppdev->PointerCapabilities.MaxWidth + 7) / 8) *
            ppdev->pPointerAttributes->Height;

    // set the desk and mask to 0xff
    RtlFillMemory(pjDstAnd, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height, 0xFF);

    // Zero the dest XOR mask
    RtlZeroMemory(pjDstXor, ppdev->pPointerAttributes->WidthInBytes *
            ppdev->pPointerAttributes->Height);

    cxSrcBytes = (cxSrc + 7) / 8;

    if ((lDeltaSrc = pso->lDelta) < 0)
    {
        lSrcWidthInBytes = -lDeltaSrc;
    } else {
        lSrcWidthInBytes = lDeltaSrc;
    }

    pjSrcAnd = (PBYTE) pso->pvBits;

    // If the incoming pointer bitmap is bottomup, we'll flip it to topdown to
    // save the miniport some work
    if (!(pso->fjBitmap & BMF_TOPDOWN))
    {
        // Copy from the bottom
        pjSrcAnd += lSrcWidthInBytes * (cySrc - 1);
    }

    // Height of just AND mask
    cySrc = cySrc / 2;

    // Point to XOR mask
    pjSrcXor = pjSrcAnd + (cySrc * lDeltaSrc);

    // Offset from end of one dest scan to start of next
    lDeltaDst = ppdev->pPointerAttributes->WidthInBytes;

    for (cy = 0; cy < cySrc; ++cy)
    {
        RtlCopyMemory(pjDstAnd, pjSrcAnd, cxSrcBytes);
        RtlCopyMemory(pjDstXor, pjSrcXor, cxSrcBytes);

        // Point to next source and dest scans
        pjSrcAnd += lDeltaSrc;
        pjSrcXor += lDeltaSrc;
        pjDstAnd += lDeltaDst;
        pjDstXor += lDeltaDst;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bCopyColorPointer
*
* Copies the mono and color masks into the buffer of maximum size
* handled by the miniport with any extra bits set to 0. Color translation
* is handled at this time. The masks are converted to topdown form if they
* aren't already.  Returns TRUE if we can handle this pointer in  hardware,
* FALSE if not.
*
\**************************************************************************/
BOOL bCopyColorPointer(
PPDEV ppdev,
SURFOBJ *psoMask,
SURFOBJ *psoColor,
XLATEOBJ *pxlo)
{
    return(FALSE);
}


/******************************Public*Routine******************************\
* bInitPointer
*
* Initialize the Pointer attributes.
*
\**************************************************************************/

BOOL bInitPointer(PPDEV ppdev, DEVINFO *pdevinfo)
{
    DWORD    returnedDataLength;

    ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES) NULL;
    ppdev->cjPointerAttributes = 0; // initialized in screen.c

    //
    // Ask the miniport whether it provides pointer support.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES,
                           &ppdev->ulMode,
                           sizeof(PVIDEO_MODE),
                           &ppdev->PointerCapabilities,
                           sizeof(ppdev->PointerCapabilities),
                           &returnedDataLength))
    {
         return(FALSE);
    }

    //
    // If neither mono nor color hardware pointer is supported, there's no
    // hardware pointer support and we're done.
    //

    if ((!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_MONO_POINTER)) &&
        (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER)))
    {
        return(TRUE);
    }

    //
    // Note: The buffer itself is allocated after we set the
    // mode. At that time we know the pixel depth and we can
    // allocate the correct size for the color pointer if supported.
    //

    //
    // Set the asynchronous support status (async means miniport is capable of
    // drawing the Pointer at any time, with no interference with any ongoing
    // drawing operation)
    //

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_ASYNC_POINTER)
    {
       pdevinfo->flGraphicsCaps |= GCAPS_ASYNCMOVE;
    }
    else
    {
       pdevinfo->flGraphicsCaps &= ~GCAPS_ASYNCMOVE;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\screen.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    ( GCAPS_OPAQUERECT
    | GCAPS_MONO_DITHER
                   ), /* Graphics capabilities         */
    SYSTM_LOGFONT,    /* Default font description */
    HELVE_LOGFONT,    /* ANSI variable font description   */
    COURI_LOGFONT,    /* ANSI fixed font description          */
    0,                /* Count of device fonts          */
    0,                /* Preferred DIB format          */
    8,                /* Width of color dither          */
    8,                /* Height of color dither   */
    0                 /* Default palette to use for this device */
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.        Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;
    ULONG RemappingNeeded = 0;  

    //
    // Set the current mode into the hardware.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_CURRENT_MODE,
                           &(ppdev->ulMode),
                           sizeof(ULONG),
                           &RemappingNeeded,
                           sizeof(ULONG),
                           &returnedDataLength))
    {
        DISPDBG((1, "DISP bInitSURF failed IOCTL_SET_MODE\n"));
        return(FALSE);
    }

    //
    // If this is the first time we enable the surface we need to map in the
    // memory also.
    //

    if (bFirst || RemappingNeeded)
    {
        videoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            DISPDBG((1, "DISP bInitSURF failed IOCTL_VIDEO_MAP\n"));
            return(FALSE);
        }

        ppdev->pjScreen = (PBYTE)(videoMemoryInformation.FrameBufferBase);

        if (videoMemoryInformation.FrameBufferBase !=
            videoMemoryInformation.VideoRamBase)
        {
            DISPDBG((0, "VideoRamBase does not correspond to FrameBufferBase\n"));
        }

        //
        // Make sure we can access this video memory
        //

        *(PULONG)(ppdev->pjScreen) = 0xaa55aa55;

        if (*(PULONG)(ppdev->pjScreen) != 0xaa55aa55) {

            DISPDBG((1, "Frame buffer memory is not accessible.\n"));
            return(FALSE);
        }

        ppdev->cScreenSize = videoMemoryInformation.VideoRamLength;

        //
        // Initialize the head of the offscreen list to NULL.
        //

        ppdev->pOffscreenList = NULL;

        // It's a hardware pointer; set up pointer attributes.

        MaxHeight = ppdev->PointerCapabilities.MaxHeight;

        // Allocate space for two DIBs (data/mask) for the pointer. If this
        // device supports a color Pointer, we will allocate a larger bitmap.
        // If this is a color bitmap we allocate for the largest possible
        // bitmap because we have no idea of what the pixel depth might be.

        // Width rounded up to nearest byte multiple

        if (!(ppdev->PointerCapabilities.Flags & VIDEO_MODE_COLOR_POINTER))
        {
            MaxWidth = (ppdev->PointerCapabilities.MaxWidth + 7) / 8;
        }
        else
        {
            MaxWidth = ppdev->PointerCapabilities.MaxWidth * sizeof(DWORD);
        }

        ppdev->cjPointerAttributes =
                sizeof(VIDEO_POINTER_ATTRIBUTES) +
                ((sizeof(UCHAR) * MaxWidth * MaxHeight) * 2);

        ppdev->pPointerAttributes = (PVIDEO_POINTER_ATTRIBUTES)
                EngAllocMem(0, ppdev->cjPointerAttributes, ALLOC_TAG);

        if (ppdev->pPointerAttributes == NULL) {

            DISPDBG((0, "bInitPointer EngAllocMem failed\n"));
            return(FALSE);
        }

        ppdev->pPointerAttributes->Flags = ppdev->PointerCapabilities.Flags;
        ppdev->pPointerAttributes->WidthInBytes = MaxWidth;
        ppdev->pPointerAttributes->Width = ppdev->PointerCapabilities.MaxWidth;
        ppdev->pPointerAttributes->Height = MaxHeight;
        ppdev->pPointerAttributes->Column = 0;
        ppdev->pPointerAttributes->Row = 0;
        ppdev->pPointerAttributes->Enable = 0;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           &videoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &returnedDataLength))
    {
        DISPDBG((0, "DISP vDisableSURF failed IOCTL_VIDEO_UNMAP\n"));
    }
}


/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        return(FALSE);
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pDevMode->dmPelsWidth        == 0) &&
        (pDevMode->dmPelsHeight       == 0) &&
        (pDevMode->dmBitsPerPel       == 0) &&
        (pDevMode->dmDisplayFrequency == 0))
    {
        DISPDBG((2, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((2, "Requested mode...\n"));
        DISPDBG((2, "   Screen width  -- %li\n", pDevMode->dmPelsWidth));
        DISPDBG((2, "   Screen height -- %li\n", pDevMode->dmPelsHeight));
        DISPDBG((2, "   Bits per pel  -- %li\n", pDevMode->dmBitsPerPel));
        DISPDBG((2, "   Frequency     -- %li\n", pDevMode->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((3, "Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        EngFreeMem(pVideoBuffer);
        DISPDBG((0,"DISP bInitPDEV failed - no valid modes\n"));
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;


    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 1;     // We don't have accelerated screen-
                                        //   to-screen blts, and any
                                        //   window alignment is okay

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

#ifdef MIPS
    if (ppdev->ulBitCount == 8)
        pGdiInfo->flTextCaps = (TC_RA_ABLE | TC_SCROLLBLT);
    else
#endif
    pGdiInfo->flTextCaps = TC_RA_ABLE;

    pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

    pGdiInfo->ulDACRed   = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue  = pVideoModeSelected->NumberBlueBits;

    pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    //
    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                           NULL,
                           0,
                           &colorCapabilities,
                           sizeof(VIDEO_COLOR_CAPABILITIES),
                           &ulTemp))
    {

        DISPDBG((2, "getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {
        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

    // Note: this should be modified later to take into account the size
    // of the display and the resolution.

    pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

    pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    // Fill in the rest of the devinfo and GdiInfo structures.

    if (ppdev->ulBitCount == 8)
    {
        // It is Palette Managed.

        pGdiInfo->ulNumColors = 20;
        pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

        pDevInfo->flGraphicsCaps |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
        pDevInfo->iDitherFormat = BMF_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
    }
    else
    {
        pGdiInfo->ulNumColors = (ULONG) (-1);
        pGdiInfo->ulNumPalReg = 0;

        if (ppdev->ulBitCount == 16)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
            pDevInfo->iDitherFormat = BMF_16BPP;
        }
        else if (ppdev->ulBitCount == 24)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
            pDevInfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
            pDevInfo->iDitherFormat = BMF_32BPP;
        }
    }

    EngFreeMem(pVideoBuffer);

    return(TRUE);
}


/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(0, modes.NumModes *
                                    modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_BANKED) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\framebuf\disp\palette.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// Global Table defining the 20 Window Default Colors.        For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        EngFreeMem((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (ppdev->ulBitCount == 8)
    {
        ULONG ulLoop;
        BYTE jRed,jGre,jBlu;

        //
        // Allocate our palette
        //

        ppdev->pPal = (PPALETTEENTRY)EngAllocMem(0, sizeof(PALETTEENTRY) * 256,
                                                 ALLOC_TAG);

        if ((ppdev->pPal) == NULL) {
            DISPDBG((0, "DISP bInitDefaultPalette() failed EngAllocMem\n"));
            return(FALSE);
        }

        //
        // Generate 256 (8*4*4) RGB combinations to fill the palette
        //

        jRed = jGre = jBlu = 0;

        for (ulLoop = 0; ulLoop < 256; ulLoop++)
        {
            ppdev->pPal[ulLoop].peRed   = jRed;
            ppdev->pPal[ulLoop].peGreen = jGre;
            ppdev->pPal[ulLoop].peBlue  = jBlu;
            ppdev->pPal[ulLoop].peFlags = (BYTE)0;

            if (!(jRed += 32))
            if (!(jGre += 32))
            jBlu += 64;
        }

        //
        // Fill in Windows Reserved Colors from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colors for
        // painting windows borders and for non-palette managed applications.
        //

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            //
            // First 10
            //

            ppdev->pPal[ulLoop] = BASEPALETTE[ulLoop];

            //
            // Last 10
            //

            ppdev->pPal[246 + ulLoop] = BASEPALETTE[ulLoop+10];
        }

        //
        // Create handle for palette.
        //

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                                   256,
                                                   (PULONG) ppdev->pPal,
                                                   0,0,0);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            DISPDBG((0, "DISP bInitDefaultPalette failed EngCreatePalette\n"));
            EngFreeMem(ppdev->pPal);
            return(FALSE);
        }

        //
        // Initialize the hardware with the initial palette.
        //

        return(TRUE);

    } else {

        ppdev->hpalDefault =
        pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                                   0,(PULONG) NULL,
                                                   ppdev->flRed,
                                                   ppdev->flGreen,
                                                   ppdev->flBlue);

        if (ppdev->hpalDefault == (HPALETTE) 0)
        {
            DISPDBG((0, "DISP bInitDefaultPalette failed EngCreatePalette\n"));
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        //
        // Fill in pScreenClut header info:
        //

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        //
        // Copy colours in:
        //

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        //
        // Set palette registers:
        //

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    //
    // Fill in pScreenClut header info:
    //

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    //
    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.
    //

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    //
    // Set palette registers
    //

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\drawscrn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    drawscrn.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

#define COMMON_LVB_MASK (COMMON_LVB_GRID_HORIZONTAL |  \
                         COMMON_LVB_GRID_LVERTICAL  |  \
                         COMMON_LVB_GRID_RVERTICAL  |  \
                         COMMON_LVB_REVERSE_VIDEO   |  \
                         COMMON_LVB_UNDERSCORE      )

/* ----- Macros -----*/
/*++
    Macro Description:
        This Macro calcurate a scan line in graphics buffer.

    Arguments:
        WindowY        - Coord to Y.
        FontSizeY      - Font size of Y.

    Return Value:
        Returen to graphics buffer offset.
--*/
#define CalcGRAMScanLine(WindowY,FontSizeY) \
    (WindowY * FontSizeY)

/*++
    Macro Description:
        This Macro calcurate a graphics buffer offset.

    Arguments:
        WindowSize - Coord of window size.
        DeviceExtension - Pointer to the miniport driver's device extension.

    Return Value:
        Returen to graphics buffer offset.
--*/
#define CalcGRAMOffs(WindowSize,ScreenIfno,EmulateInfo) \
    (EmulateInfo->StartAddress + \
     CalcGRAMSize(WindowSize,ScreenInfo,EmulateInfo) \
    )

/*++
    Macro Description:
        This Macro gets the byte per one scan line.

    Arguments:
        EmulateInfo - Pointer to screen emualte information structure.

    Return Value:
        Byte pre line number.
--*/
#define GetBytePerLine(HardwareScroll) \
    ((HardwareScroll & OFFSET_128_TO_NEXT_SLICE) ? \
     (1024 / 8) : \
     (640 / 8) \
    )



ULONG
CalcGRAMSize(
    IN COORD WindowSize,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This Macro calcurate a graphics buffer size.

Arguments:

    WindowSize - Coord of window size.

    DeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Returen to graphics buffer offset.

--*/

{
    return WindowSize.X +
           CalcGRAMScanLine(WindowSize.Y, ScreenInfo->FontSize.Y) *
           EmulateInfo->BytePerLine;
}


PUCHAR
CalcGRAMAddress(
    IN COORD WindowSize,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine calcurate a graphics buffer address.

Arguments:

    WindowSize - Coord of window size.

    DeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Returen to graphics buffer address.

--*/
{
    PUCHAR BufPtr = (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase;

    BufPtr += CalcGRAMOffs(WindowSize, ScreenInfo, EmulateInfo);
    if ((ULONG)(BufPtr -
                (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
           >= EmulateInfo->LimitGRAM)
        return (BufPtr - EmulateInfo->LimitGRAM);
    else
        return BufPtr;
}


#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
BOOLEAN
IsGRAMRowOver(
    PUCHAR BufPtr,
    BOOLEAN fDbcs,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This Routine check ROW overflow as GRAM limit line.

Arguments:

    BufPtr - Pointer to graphics buffer.

    fDbcs - Flag of DBCS(true) or SBCS(false).

Return Value:
    TRUE:  if font box is overflow as GRAMlimit line.
    FALSE: not overflow.

--*/

{
    if (fDbcs)
    {
        if ((ULONG)(BufPtr + 1 +
                    EmulateInfo->DeltaNextFontRow -
                    (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
             >= EmulateInfo->LimitGRAM)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        if ((ULONG)(BufPtr +
                    EmulateInfo->DeltaNextFontRow -
                    (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
             >= EmulateInfo->LimitGRAM)
            return TRUE;
        else
            return FALSE;
    }
}
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum

PUCHAR
NextGRAMRow(
    PUCHAR BufPtr,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:
    This Routine add next row a graphics buffer address.

Arguments:

    BufPtr - Pointer to graphics buffer.

Return Value:

    Returen to graphics buffer address.

--*/

{
    if ((ULONG)(BufPtr +
                EmulateInfo->BytePerLine -
                (PUCHAR)VideoModeInfo->VideoMemory.FrameBufferBase)
           >= EmulateInfo->LimitGRAM)
        return (BufPtr +
                EmulateInfo->BytePerLine -
                EmulateInfo->LimitGRAM);
    else
        return (BufPtr + EmulateInfo->BytePerLine);
}

VOID
memcpyGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine is a memory copy for byte order.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

--*/

{
    while (Length--)
        *TargetPtr++ = *SourcePtr++;
}

VOID
memcpyGRAMOver(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine move a graphics buffer.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

--*/

{
    ULONG tmpLen;

    if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
        tmpLen = EmulateInfo->LimitGRAM - (SourcePtr - FrameBufPtr);
        memcpyGRAM(TargetPtr, SourcePtr, tmpLen);
        TargetPtr += tmpLen;
        Length -= tmpLen;
        SourcePtr = FrameBufPtr;
    }

    if ((ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
        tmpLen = EmulateInfo->LimitGRAM - (TargetPtr - FrameBufPtr);
        memcpyGRAM(TargetPtr, SourcePtr, tmpLen);
        SourcePtr += tmpLen;
        Length -= tmpLen;
        TargetPtr = FrameBufPtr;
    }

    if (Length) {
        memcpyGRAM(TargetPtr, SourcePtr, Length);
    }
}

VOID
MoveGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PFSVGA_RESOURCE_INFORMATION ResourceInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine move a graphics buffer.

Arguments:

    TargetPtr - Pointer to target graphics buffer.

    SourcePtr - Pointer to source graphics buffer.

    Length - Fill length.

Return Value:

    none.

--*/
{
    PCHAR tmpSrc;
    PCHAR tmpTrg;
    ULONG tmpLen;

    //
    // Set copy mode of graphics register
    //

    SetGRAMCopyMode(ResourceInfo->PortList);

    if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM ||
        (ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM    ) {
        if (SourcePtr > TargetPtr) {
            memcpyGRAMOver(TargetPtr,SourcePtr,Length,FrameBufPtr,EmulateInfo);
        }
        else if ((ULONG)(TargetPtr - SourcePtr) >= Length) {
            memcpyGRAMOver(TargetPtr,SourcePtr,Length,FrameBufPtr,EmulateInfo);
        }
        else {
            if ((ULONG)(SourcePtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
                tmpLen = SourcePtr + Length - FrameBufPtr - EmulateInfo->LimitGRAM;
                tmpTrg = TargetPtr + Length - tmpLen - EmulateInfo->LimitGRAM;
                memcpyGRAM(tmpTrg, FrameBufPtr, tmpLen);
                Length -= tmpLen;
            }
            if ((ULONG)(TargetPtr + Length - FrameBufPtr) >= EmulateInfo->LimitGRAM) {
                tmpLen = TargetPtr + Length - FrameBufPtr - EmulateInfo->LimitGRAM;
                tmpSrc = SourcePtr + Length - tmpLen;
                memcpyGRAM(FrameBufPtr, tmpSrc, tmpLen);
                Length -= tmpLen;
            }
            if (Length) {
                memcpyGRAM(TargetPtr, SourcePtr, Length);
            }
        }
    }
    else {
        memcpyGRAM(TargetPtr, SourcePtr, Length);
    }

    SetGRAMWriteMode(ResourceInfo->PortList);
}


NTSTATUS
FsgVgaInitializeHWFlags(
    PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine initialize the hardware scrolls flag and any values.

Arguments:

    EmulateInfo - Pointer to screen emulate information structure.

Return Value:

--*/

{
    ULONG Index;

    GetHardwareScrollReg(DeviceExtension->Resource.PortList,
                         &DeviceExtension->EmulateInfo);
    DeviceExtension->EmulateInfo.BytePerLine =
        (USHORT)GetBytePerLine(Globals.Configuration.HardwareScroll);
    DeviceExtension->EmulateInfo.MaxScanLine =
        (USHORT)CalcGRAMScanLine(DeviceExtension->ScreenAndFont.ScreenSize.Y,
                               DeviceExtension->ScreenAndFont.FontSize.Y);
    DeviceExtension->EmulateInfo.DeltaNextFontRow =
        DeviceExtension->EmulateInfo.BytePerLine * DeviceExtension->ScreenAndFont.FontSize.Y;

    if (Globals.Configuration.HardwareScroll & USE_LINE_COMPARE) {
        DeviceExtension->EmulateInfo.LimitGRAM =
            DeviceExtension->EmulateInfo.MaxScanLine * DeviceExtension->EmulateInfo.BytePerLine;
    }
    else {
        DeviceExtension->EmulateInfo.LimitGRAM = LIMIT_64K;
    }

    DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
    DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    DeviceExtension->EmulateInfo.CursorAttributes.Enable = 0;
    DeviceExtension->EmulateInfo.ShowCursor = FALSE;

    SetGRAMWriteMode(DeviceExtension->Resource.PortList);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine copy the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CopyFrameBuffer - Pointer to the structure containing the information about the copy frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PUCHAR SourcePtr, TargetPtr;

    FsgInvertCursor(DeviceExtension,FALSE);

    SourcePtr = CalcGRAMAddress (CopyFrameBuffer->SrcScreen.Position,
                                 &DeviceExtension->CurrentMode,
                                 &DeviceExtension->ScreenAndFont,
                                 &DeviceExtension->EmulateInfo);
    TargetPtr = CalcGRAMAddress (CopyFrameBuffer->DestScreen.Position,
                                 &DeviceExtension->CurrentMode,
                                 &DeviceExtension->ScreenAndFont,
                                 &DeviceExtension->EmulateInfo);
    MoveGRAM (TargetPtr,
              SourcePtr,
              CopyFrameBuffer->SrcScreen.nNumberOfChars *
                  DeviceExtension->ScreenAndFont.FontSize.Y,
              DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase,
              &DeviceExtension->Resource,
              &DeviceExtension->EmulateInfo
             );

    FsgInvertCursor(DeviceExtension,TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine write the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    WriteFrameBuffer - Pointer to the structure containing the information about the write frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PCHAR_IMAGE_INFO pCharInfoUni = WriteFrameBuffer->SrcBuffer;
    PUCHAR TargetPtr;
    COORD Position = WriteFrameBuffer->DestScreen.Position;
    ULONG Length = WriteFrameBuffer->DestScreen.nNumberOfChars;
    COORD FontSize1 = DeviceExtension->ScreenAndFont.FontSize;
    COORD FontSize2;
    PVOID pCapBuffer = NULL;
    ULONG cCapBuffer = 0;
    BOOLEAN  fDbcs = FALSE;
    NTSTATUS Status;

    FsgInvertCursor(DeviceExtension,FALSE);

    DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
    DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    FontSize2 = FontSize1;
    FontSize2.X *= 2;
    cCapBuffer = CalcBitmapBufferSize(FontSize2,BYTE_ALIGN);
    pCapBuffer = ExAllocatePool(PagedPool, cCapBuffer);

    while (Length--)
    {
        if (pCharInfoUni->FontImageInfo.ImageBits != NULL)
        {
            try
            {
                fDbcs = (BOOLEAN)(!!(pCharInfoUni->CharInfo.Attributes & COMMON_LVB_SBCSDBCS));
                AlignCopyMemory((PVOID)pCapBuffer,                    // pDestBits
                                BYTE_ALIGN,                           // dwDestAlign
                                pCharInfoUni->FontImageInfo.ImageBits,// pSrcBits
                                WORD_ALIGN,                           // dwSrcAlign
                                fDbcs ? FontSize2 : FontSize1);

                TargetPtr = CalcGRAMAddress (Position,
                                             &DeviceExtension->CurrentMode,
                                             &DeviceExtension->ScreenAndFont,
                                             &DeviceExtension->EmulateInfo);
                if (fDbcs)
                {
                    if (Length)
                    {
                        FsgWriteToScreen(TargetPtr, pCapBuffer, 2, fDbcs,
                                         pCharInfoUni->CharInfo.Attributes,
                                         (pCharInfoUni+1)->CharInfo.Attributes,
                                         DeviceExtension);
                    }
                    else
                    {
                        FsgWriteToScreen(TargetPtr, pCapBuffer, 2, FALSE,
                                         pCharInfoUni->CharInfo.Attributes,
                                         (USHORT)-1,
                                         DeviceExtension);
                    }
                }
                else
                {
                    FsgWriteToScreen(TargetPtr, pCapBuffer, 1, fDbcs,
                                     pCharInfoUni->CharInfo.Attributes,
                                     (USHORT)-1,
                                     DeviceExtension);
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
            }

        }

        if (fDbcs && Length)
        {
            Length--;
            Position.X += 2;
            pCharInfoUni += 2;
        }
        else
        {
            Position.X++;
            pCharInfoUni++;
        }
    }

    FsgInvertCursor(DeviceExtension,TRUE);

    if (pCapBuffer != NULL)
        ExFreePool(pCapBuffer);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine reverse the frame buffer for mouse pointer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    MouseBuffer - Pointer to the structure containing the information about the mouse frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{

    PUCHAR CurFrameBufPtr;
    COORD  CursorPosition;
    COORD  FontSize;
    SHORT  i;
    BOOLEAN   fOneMore = FALSE;

    FsgInvertCursor(DeviceExtension,FALSE);

    FontSize = DeviceExtension->ScreenAndFont.FontSize;

    CursorPosition.X = MouseBuffer->Screen.Position.X;
    CursorPosition.Y = MouseBuffer->Screen.Position.Y;
    if ( (0 <= CursorPosition.X &&
               CursorPosition.X < MouseBuffer->Screen.ScreenSize.X) &&
         (0 <= CursorPosition.Y &&
               CursorPosition.Y < MouseBuffer->Screen.ScreenSize.Y)    )
    {
        switch (MouseBuffer->dwType)
        {
            case CHAR_TYPE_LEADING:
                if (CursorPosition.X != MouseBuffer->Screen.ScreenSize.X-1)
                {
                    fOneMore = TRUE;
                }
                break;
            case CHAR_TYPE_TRAILING:
                if (CursorPosition.X != 0)
                {
                    fOneMore = TRUE;
                    CursorPosition.X--;
                }
                break;
        }

        CurFrameBufPtr = CalcGRAMAddress (CursorPosition,
                                          &DeviceExtension->CurrentMode,
                                          &DeviceExtension->ScreenAndFont,
                                          &DeviceExtension->EmulateInfo);

        //
        // Set invert mode of graphics register
        //
        SetGRAMInvertMode(DeviceExtension->Resource.PortList);

        /*
         * CursorAttributes.Width is bottom scan lines.
         */
        for (i=0 ; i < FontSize.Y; i++)
        {
            AccessGRAM_AND(CurFrameBufPtr, (UCHAR)-1);
            if (fOneMore)
                AccessGRAM_AND(CurFrameBufPtr+1, (UCHAR)-1);
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        SetGRAMWriteMode(DeviceExtension->Resource.PortList);
    }

    FsgInvertCursor(DeviceExtension,TRUE);

    return STATUS_SUCCESS;
}

NTSTATUS
FsgInvertCursor(
    PDEVICE_EXTENSION DeviceExtension,
    BOOLEAN Invert
    )

/*++

Routine Description:

    This routine inverts the cursor.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    Invert - 

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    PUCHAR CurFrameBufPtr;
    COORD  CursorPosition;
    COORD  FontSize;
    SHORT  i;
    SHORT  TopScanLine;
    BOOLEAN   fOneMore = FALSE;

    if (DeviceExtension->EmulateInfo.ShowCursor == Invert)
        return STATUS_SUCCESS;

    DeviceExtension->EmulateInfo.ShowCursor = Invert;

    if (!(DeviceExtension->EmulateInfo.CursorAttributes.Enable))
        return STATUS_SUCCESS;

    FontSize = DeviceExtension->ScreenAndFont.FontSize;
    if (DeviceExtension->ScreenAndFont.ScreenSize.Y > 25)
    {
        TopScanLine = ((DeviceExtension->EmulateInfo.CursorAttributes.Height + 8) * 100 / 8) - 100;
    }
    else
    {
        TopScanLine = ((DeviceExtension->EmulateInfo.CursorAttributes.Height + 16) * 100 / 16) - 100;
    }
    TopScanLine = (FontSize.Y * TopScanLine) / 100;

    CursorPosition.X = DeviceExtension->EmulateInfo.CursorPosition.Coord.Column;
    CursorPosition.Y = DeviceExtension->EmulateInfo.CursorPosition.Coord.Row;
    if ( (0 <= CursorPosition.X &&
               CursorPosition.X < DeviceExtension->ScreenAndFont.ScreenSize.X) &&
         (0 <= CursorPosition.Y &&
               CursorPosition.Y < DeviceExtension->ScreenAndFont.ScreenSize.Y)    )
    {
        switch (DeviceExtension->EmulateInfo.CursorPosition.dwType)
        {
            case CHAR_TYPE_LEADING:
                if (CursorPosition.X != DeviceExtension->ScreenAndFont.ScreenSize.X-1)
                {
                    fOneMore = TRUE;
                }
                break;
            case CHAR_TYPE_TRAILING:
                if (CursorPosition.X != 0)
                {
                    fOneMore = TRUE;
                    CursorPosition.X--;
                }
                break;
        }

        CurFrameBufPtr = CalcGRAMAddress (CursorPosition,
                                          &DeviceExtension->CurrentMode,
                                          &DeviceExtension->ScreenAndFont,
                                          &DeviceExtension->EmulateInfo);

        /*
         * CursorAttributes.Height is top scan lines.
         */
        for (i = 0; i < TopScanLine; i++)
        {
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        //
        // Set invert mode of graphics register
        //
        SetGRAMInvertMode(DeviceExtension->Resource.PortList);

        /*
         * CursorAttributes.Width is bottom scan lines.
         */
        for ( ; i < FontSize.Y; i++)
        {
            AccessGRAM_AND(CurFrameBufPtr, (UCHAR)-1);
            if (fOneMore) {
                AccessGRAM_AND(CurFrameBufPtr+1, (UCHAR)-1);
            }
            CurFrameBufPtr = NextGRAMRow(CurFrameBufPtr,
                                         &DeviceExtension->CurrentMode,
                                         &DeviceExtension->EmulateInfo);
        }

        SetGRAMWriteMode(DeviceExtension->Resource.PortList);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToScreen(
    PUCHAR FrameBuffer,
    PUCHAR BitmapBuffer,
    ULONG cjBytes,
    BOOLEAN fDbcs,
    USHORT Attributes1,
    USHORT Attributes2,
    PDEVICE_EXTENSION DeviceExtension
    )
{
    USHORT  Index;
    PCHAR CurFrameBufPtrTmp;
    PCHAR CurFrameBufPtr2nd;
    PUSHORT CurFrameBufPtrWord;
    PUCHAR BitmapBufferTmp;

#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
    if (! IsGRAMRowOver(FrameBuffer,fDBCS,DeviceExtension)) {
        if (!fDbcs) {
            if (cjBytes == 2)
                BitmapBuffer++;
            (*WriteGramInfo->pfnWriteFontToByteGRAM)(WriteGramInfo);
        }
        else if (cjBytes == 2 && fDBCS) {
            if (DeviceExtension->Configuration.EmulationMode & ENABLE_WORD_WRITE_VRAM) {
                (*WriteGramInfo->pfnWriteFontToFirstWordGRAM)(WriteGramInfo);
            }
            else {
               (*WriteGramInfo->pfnWriteFontToWordGRAM)(WriteGramInfo);
            }
        }
    }
    else
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
    try
    {
        set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                              &DeviceExtension->EmulateInfo,
                              FrameBuffer,Attributes1);

        if (!fDbcs) {
            CurFrameBufPtrTmp = FrameBuffer;
            if (cjBytes == 2)
                BitmapBuffer++;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                *CurFrameBufPtrTmp = *BitmapBuffer;
                BitmapBuffer += cjBytes;
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }
        }
        else if (cjBytes == 2 && fDbcs) {
            if ((Globals.Configuration.EmulationMode & ENABLE_WORD_WRITE_VRAM) &&
                !((ULONG)FrameBuffer & 1) &&
                (Attributes2 != -1) &&
                (Attributes1 == Attributes2)
               ) {
                CurFrameBufPtrWord = (PUSHORT)FrameBuffer;
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtrWord = *((PUSHORT)BitmapBuffer);
                    BitmapBuffer += cjBytes;
                    CurFrameBufPtrWord=(PUSHORT)NextGRAMRow((PCHAR)CurFrameBufPtrWord,
                                                            &DeviceExtension->CurrentMode,
                                                            &DeviceExtension->EmulateInfo);
                }
            }
            else {
                CurFrameBufPtrTmp = FrameBuffer;
                CurFrameBufPtr2nd = FrameBuffer + 1;
                BitmapBufferTmp = BitmapBuffer + 1;
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtrTmp = *BitmapBuffer;
                    BitmapBuffer += cjBytes;
                    CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                                  &DeviceExtension->CurrentMode,
                                                  &DeviceExtension->EmulateInfo);
                }
                if (Attributes2 != -1 &&
                    Attributes1 != Attributes2) {
                    set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                                          &DeviceExtension->EmulateInfo,
                                          FrameBuffer,Attributes2);
                }
                for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                    *CurFrameBufPtr2nd = *BitmapBufferTmp;
                    BitmapBufferTmp += cjBytes;
                    CurFrameBufPtr2nd=NextGRAMRow(CurFrameBufPtr2nd,
                                                  &DeviceExtension->CurrentMode,
                                                  &DeviceExtension->EmulateInfo);
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (Attributes1 & COMMON_LVB_MASK)
    {
        FsgWriteToScreenCommonLVB(FrameBuffer,
                                  Attributes1,
                                  DeviceExtension);
    }
    if ((Attributes2 != (USHORT)-1) && (Attributes2 & COMMON_LVB_MASK))
    {
        FsgWriteToScreenCommonLVB(FrameBuffer+1,
                                  Attributes2,
                                  DeviceExtension);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsgWriteToScreenCommonLVB(
    PUCHAR FrameBuffer,
    USHORT Attributes,
    PDEVICE_EXTENSION DeviceExtension
    )
{
    USHORT Index;
    PUCHAR CurFrameBufPtrTmp;

    try
    {
        if (Attributes & COMMON_LVB_UNDERSCORE)
        {
            set_opaque_bkgnd_proc(DeviceExtension->Resource.PortList,
                                  &DeviceExtension->EmulateInfo,
                                  FrameBuffer,Attributes);
            CurFrameBufPtrTmp = FrameBuffer;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y - 1; Index++) {
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }
            *CurFrameBufPtrTmp = 0xff;
        }

        if (Attributes & COMMON_LVB_GRID_HORIZONTAL)
        {
            ColorSetDirect(DeviceExtension->Resource.PortList,
                           FrameBuffer,
                           FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED,
                           0);
            *FrameBuffer = 0xff;
        }

        if ( (Attributes & COMMON_LVB_GRID_LVERTICAL) ||
             (Attributes & COMMON_LVB_GRID_RVERTICAL)   )
        {
            UCHAR mask = ((Attributes & COMMON_LVB_GRID_LVERTICAL) ? 0x80 : 0) +
                         ((Attributes & COMMON_LVB_GRID_RVERTICAL) ? 0x01 : 0);
            ColorSetGridMask(DeviceExtension->Resource.PortList,
                             mask
                            );
            CurFrameBufPtrTmp = FrameBuffer;
            for (Index=0; Index < DeviceExtension->ScreenAndFont.FontSize.Y; Index++) {
                AccessGRAM_RW(CurFrameBufPtrTmp, mask);
                CurFrameBufPtrTmp=NextGRAMRow(CurFrameBufPtrTmp,
                                              &DeviceExtension->CurrentMode,
                                              &DeviceExtension->EmulateInfo);
            }

            SetGRAMWriteMode(DeviceExtension->Resource.PortList);
        }

        DeviceExtension->EmulateInfo.ColorFg = (UCHAR)-1;
        DeviceExtension->EmulateInfo.ColorBg = (UCHAR)-1;

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return STATUS_SUCCESS;
}

#pragma optimize("",off)
    /*
     * because, frame buffer memory access is need by write/read.
     */
UCHAR
AccessGRAM_WR(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    *FrameBuffer = write;
    return *FrameBuffer;
}

UCHAR
AccessGRAM_RW(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    UCHAR tmp;
    tmp = *FrameBuffer;
    *FrameBuffer = write;
    return tmp;
}

UCHAR
AccessGRAM_AND(
    PUCHAR FrameBuffer,
    UCHAR  write
    )
{
    return *FrameBuffer &= write;
}
#pragma optimize("",on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsvga.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fsvga.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,FsVgaQueryDevice)
#pragma alloc_text(INIT,FsVgaPeripheralCallout)
#pragma alloc_text(INIT,FsVgaServiceParameters)
#endif


GLOBALS Globals;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((1,
                "\n\nFSVGA-FSVGAInitialize: enter\n"));

    //
    // Zero-initialize various structures.
    //
    RtlZeroMemory(&Globals, sizeof(GLOBALS));

    Globals.FsVgaDebug = DEFAULT_DEBUG_LEVEL;

    //
    // Query the device resource information for this driver.
    //
    FsVgaQueryDevice(&Globals.Resource);

    if (!(Globals.Resource.HardwarePresent & FSVGA_HARDWARE_PRESENT)) {
        //
        // There is neither a Full Screen Video attached.  Free
        // resources and return with unsuccessful status.
        //

        FsVgaPrint((1,
                    "FSVGA-FsVgaInitialize: No Full Screen Video attached.\n"));
        status = STATUS_NO_SUCH_DEVICE;
        errorCode = FSVGA_NO_SUCH_DEVICE;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 4;
        goto FsVgaInitializeExit;

    }
    else
    {
        //
        // Need to ensure that the registry path is null-terminated.
        // Allocate pool to hold a null-terminated copy of the path.
        //

        Globals.RegistryPath.Length = RegistryPath->Length;
        Globals.RegistryPath.MaximumLength = RegistryPath->Length
                                           + sizeof (UNICODE_NULL);

        Globals.RegistryPath.Buffer = ExAllocatePool(
                                          NonPagedPool,
                                          Globals.RegistryPath.MaximumLength);

        if (!Globals.RegistryPath.Buffer) {
            FsVgaPrint((
                1,
                "FSVGA-FsVgaInitialize: Couldn't allocate pool for registry path\n"
                ));

            status = STATUS_UNSUCCESSFUL;
            errorCode = FSVGA_INSUFFICIENT_RESOURCES;
            uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
            dumpData[0] = 0;
            dumpCount = 1;
            goto FsVgaInitializeExit;

        }

        RtlMoveMemory(Globals.RegistryPath.Buffer,
                      RegistryPath->Buffer,
                      RegistryPath->Length);
        Globals.RegistryPath.Buffer [RegistryPath->Length / sizeof (WCHAR)] = L'\0';

        //
        // Get the service parameters (e.g., user-configurable number
        // of resends, polling iterations, etc.).
        //

        FsVgaServiceParameters(&Globals.Configuration,
                               &Globals.RegistryPath);
    }

    //
    // Once initialization is finished, load the device map information
    // into the registry so that setup can determine which full screen
    // port are active.
    //

    if (Globals.Resource.HardwarePresent & FSVGA_HARDWARE_PRESENT) {

        status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                       L"FullScreenVideo",
                                       DD_FULLSCREEN_VIDEO_DEVICE_NAME,
                                       REG_SZ,
                                       Globals.RegistryPath.Buffer,
                                       Globals.RegistryPath.Length);

        if (!NT_SUCCESS(status))
        {
            FsVgaPrint((1,
                       "FSVGA-FSVGAInitialize: Could not store keyboard name in DeviceMap\n"));
            errorCode = FSVGA_NO_DEVICEMAP_CREATED;
            uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 90;
            dumpCount = 0;
            goto FsVgaInitializeExit;
        }
        else
        {
            FsVgaPrint((1,
                       "FSVGA-FSVGAInitialize: Stored pointer name in DeviceMap\n"));
        }
    }

    ASSERT(status == STATUS_SUCCESS);

    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = FsVgaOpenCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = FsVgaOpenCloseDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FsVgaDeviceControl;

    DriverObject->DriverUnload                         = FsVgaDriverUnload;
    DriverObject->DriverExtension->AddDevice           = FsVgaAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = FsVgaDevicePnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = FsVgaDevicePower;

FsVgaInitializeExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError(DriverObject,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    FsVgaPrint((1,
                "FSVGA-FsVgaInitialize: exit\n"));

    return(status);
}

VOID
FsVgaQueryDevice(
    IN PFSVGA_RESOURCE_INFORMATION Resource
    )

/*++

Routine Description:

    This routine retrieves the resource information for the video.

Arguments:

    Resource - Pointer to the resource information.

Return Value:

--*/
{
    INTERFACE_TYPE interfaceType;
    ULONG i;

    for (i = 0; i < MaximumInterfaceType; i++)
    {

        //
        // Get the registry information for this device.
        //

        interfaceType = i;
        IoQueryDeviceDescription(&interfaceType,      // Bus type
                                 NULL,                // Bus number
                                 NULL,                // Controller type
                                 NULL,                // Controller number
                                 NULL,                // Peripheral type
                                 NULL,                // Peripheral number
                                 FsVgaPeripheralCallout,
                                 (PVOID) Resource);

        if (Resource->HardwarePresent & FSVGA_HARDWARE_PRESENT)
        {
            break;
        }
        else
        {
            FsVgaPrint((1,
                        "FSVGA-FsVgaConfiguration: IoQueryDeviceDescription for bus type %d failed\n",
                        interfaceType));
        }
    }
}

NTSTATUS
FsVgaPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the Display controller
    configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be DisplayController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be MonitorPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/

{
    PFSVGA_RESOURCE_INFORMATION resource;
    NTSTATUS status = STATUS_SUCCESS;

    FsVgaPrint((1,
                "FSVGA-FsVgaPeripheralCallout: Path @ 0x%x, Bus Type 0x%x, Bus Number 0x%x\n",
                PathName, BusType, BusNumber));
    FsVgaPrint((1,
                "    Controller Type 0x%x, Controller Number 0x%x, Controller info @ 0x%x\n",
                ControllerType, ControllerNumber, ControllerInformation));
    FsVgaPrint((1,
                "    Peripheral Type 0x%x, Peripheral Number 0x%x, Peripheral info @ 0x%x\n",
                PeripheralType, PeripheralNumber, PeripheralInformation));

    //
    // If we already have the configuration information for the
    // keyboard peripheral, or if the peripheral identifier is missing,
    // just return.
    //

    resource = (PFSVGA_RESOURCE_INFORMATION) Context;
    if (resource->HardwarePresent & FSVGA_HARDWARE_PRESENT)
    {
        return (status);
    }


    resource->HardwarePresent |= FSVGA_HARDWARE_PRESENT;

#ifdef RESOURCE_REQUIREMENTS
    //
    // Get the bus information.
    //

    resource->InterfaceType = BusType;
    resource->BusNumber     = BusNumber;
#endif

    return(status);
}

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaQueryAperture(
    OUT PIO_RESOURCE_LIST *pApertureRequirements
//    OUT PFSVGA_RESOURCE_INFORMATION Resource
    )

/*++

Routine Description:

    Queries the possible FsVga settings.

Arguments:

    ApertureRequirements - returns the possible FsVga settings

Return Value:

    NTSTATUS

--*/

{
    PIO_RESOURCE_LIST Requirements;
    ULONG PortLength;
    ULONG RangeStart;
    ULONG i;

    Requirements = ExAllocatePool(PagedPool,
                                  sizeof(IO_RESOURCE_LIST) + (MaximumPortCount-1) * sizeof(IO_RESOURCE_DESCRIPTOR));
    if (Requirements == NULL) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaQueryAperture: Could not allocate resource list\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Requirements->Version  =
    Requirements->Revision = 1;
    Requirements->Count    = MaximumPortCount;
    for (i = 0; i < MaximumPortCount; i++) {
        Requirements->Descriptors[i].Option           = IO_RESOURCE_PREFERRED;
        Requirements->Descriptors[i].Type             = CmResourceTypePort;
        Requirements->Descriptors[i].ShareDisposition = CmResourceShareShared;
        Requirements->Descriptors[i].Flags            = CM_RESOURCE_PORT_IO;
        switch (i) {
            case CRTCAddressPortColor:
                PortLength = 1;
                RangeStart = VGA_BASE_IO_PORT + CRTC_ADDRESS_PORT_COLOR;
                break;
            case CRTCDataPortColor:
                PortLength = 1;
                RangeStart = VGA_BASE_IO_PORT + CRTC_DATA_PORT_COLOR;
                break;
            case GRAPHAddressPort:
                PortLength = 2;
                RangeStart = VGA_BASE_IO_PORT + GRAPH_ADDRESS_PORT;
                break;
            case SEQAddressPort:
                PortLength = 2;
                RangeStart = VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT;
                break;
        }
        Requirements->Descriptors[i].u.Port.MinimumAddress.QuadPart = RangeStart;
        Requirements->Descriptors[i].u.Port.MaximumAddress.QuadPart = RangeStart +
                                                                      (PortLength - 1);
        Requirements->Descriptors[i].u.Port.Alignment               = 1;
        Requirements->Descriptors[i].u.Port.Length                  = PortLength;

    }

    *pApertureRequirements = Requirements;

    return STATUS_SUCCESS;
}
#endif

NTSTATUS
FsVgaCreateResource(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    OUT PCM_PARTIAL_RESOURCE_LIST *pResourceList
    )

/*++

Routine Description:

    Create the possible FsVga resousrce settings.

Arguments:

    ResourceList - returns the possible FsVga settings

Return Value:

    NTSTATUS

--*/

{
    PCM_PARTIAL_RESOURCE_LIST Requirements;
    ULONG PortLength;
    ULONG RangeStart;
    ULONG i;
    USHORT IOPort = configuration->IOPort;

    Requirements = ExAllocatePool(PagedPool,
                                  sizeof(CM_PARTIAL_RESOURCE_LIST) + (MaximumPortCount-1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
    if (Requirements == NULL) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaCreateResoursce: Could not allocate resource list\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Requirements->Version  =
    Requirements->Revision = 1;
    Requirements->Count    = MaximumPortCount;
    for (i = 0; i < MaximumPortCount; i++) {
        Requirements->PartialDescriptors[i].Type             = CmResourceTypePort;
        Requirements->PartialDescriptors[i].ShareDisposition = CmResourceShareShared;
        Requirements->PartialDescriptors[i].Flags            = CM_RESOURCE_PORT_IO;
        switch (i) {
            case CRTCAddressPortColor:
                PortLength = 1;
                RangeStart = IOPort + CRTC_ADDRESS_PORT_COLOR;
                break;
            case CRTCDataPortColor:
                PortLength = 1;
                RangeStart = IOPort + CRTC_DATA_PORT_COLOR;
                break;
            case GRAPHAddressPort:
                PortLength = 2;
                RangeStart = IOPort + GRAPH_ADDRESS_PORT;
                break;
            case SEQAddressPort:
                PortLength = 2;
                RangeStart = IOPort + SEQ_ADDRESS_PORT;
                break;
        }
        Requirements->PartialDescriptors[i].u.Port.Start.QuadPart = RangeStart;
        Requirements->PartialDescriptors[i].u.Port.Length         = PortLength;

    }

    *pResourceList = Requirements;

    return STATUS_SUCCESS;
}

VOID
FsVgaServiceParameters(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    configuration - Pointer to the configuration information.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

--*/

{
    UNICODE_STRING parametersPath;
    PWSTR path;
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    USHORT queriesPlusOne = 5;
    NTSTATUS status = STATUS_SUCCESS;
#define PARAMETER_MAX 256
    ULONG EmulationMode;
    ULONG HardwareCursor;
    ULONG HardwareScroll;
    ULONG IOPort;
    USHORT defaultEmulationMode = 0;
    USHORT defaultHardwareCursor = NO_HARDWARE_CURSOR;
    USHORT defaultHardwareScroll = NO_HARDWARE_SCROLL;
    USHORT defaultIOPort         = VGA_BASE_IO_PORT;

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    //
    // Allocate the Rtl query table.
    //

    parameters = ExAllocatePool(PagedPool,
                                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne);
    if (!parameters)
    {
        FsVgaPrint((1,
                    "FSVGA-FsVgaServiceParameters: Couldn't allocate table for Rtl query to parameters for %ws\n",
                    path));
        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        RtlZeroMemory(parameters,
                      sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne);

        //
        // Form a path to this driver's Parameters subkey.
        //

        RtlInitUnicodeString(&parametersPath,
                             NULL);

        parametersPath.MaximumLength = RegistryPath->Length +
                                       sizeof(L"\\Parameters");
        parametersPath.Buffer = ExAllocatePool(PagedPool,
                                               parametersPath.MaximumLength);
        if (!parametersPath.Buffer)
        {
            FsVgaPrint((1,
                        "FSVGA-FsVgaServiceParameters: Couldn't allocate string for path to parameters for %ws\n",
                        path));
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status))
    {
        //
        // Form the parameters path.
        //
        RtlZeroMemory(parametersPath.Buffer,
                      parametersPath.MaximumLength);
        RtlAppendUnicodeToString(&parametersPath,
                                 path);
        RtlAppendUnicodeToString(&parametersPath,
                                 L"\\Parameters");

        FsVgaPrint((1,
                    "FsVga-FsVgaServiceParameters: parameters path is %ws\n",
                    parametersPath.Buffer));

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"ConsoleFullScreen.EmulationMode";
        parameters[0].EntryContext = &EmulationMode;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultEmulationMode;
        parameters[0].DefaultLength = sizeof(USHORT);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"ConsoleFullScreen.HardwareCursor";
        parameters[1].EntryContext = &HardwareCursor;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultHardwareCursor;
        parameters[1].DefaultLength = sizeof(USHORT);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"ConsoleFullScreen.HardwareScroll";
        parameters[2].EntryContext = &HardwareScroll;
        parameters[2].DefaultType = REG_DWORD;
        parameters[2].DefaultData = &defaultHardwareScroll;
        parameters[2].DefaultLength = sizeof(USHORT);

        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"IO Port";
        parameters[3].EntryContext = &IOPort;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &defaultIOPort;
        parameters[3].DefaultLength = sizeof(USHORT);

        status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                        parametersPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status))
        {
            FsVgaPrint((1,
                        "FsVga-FsVgaServiceParameters: RtlQueryRegistryValues failed with 0x%x\n",
                        status));
        }
    }

    if (!NT_SUCCESS(status))
    {
        //
        // Go ahead and assign driver defaults.
        //
        configuration->EmulationMode = defaultEmulationMode;
        configuration->HardwareCursor = defaultHardwareCursor;
        configuration->HardwareScroll = defaultHardwareScroll;
        configuration->IOPort         = defaultIOPort;
    }
    else
    {
        configuration->EmulationMode = (USHORT)EmulationMode;
        configuration->HardwareCursor = (USHORT)HardwareCursor;
        configuration->HardwareScroll = (USHORT)HardwareScroll;
        configuration->IOPort         = (USHORT)IOPort;
    }

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Emulation Mode = %d\n",
                configuration->EmulationMode));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Hardware Cursor = %d\n",
                configuration->HardwareCursor));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: Hardware Scroll = %d\n",
                configuration->HardwareScroll));

    FsVgaPrint((1,
                "FsVga-FsVgaServiceParameters: IO Port = %x\n",
                configuration->IOPort));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}

NTSTATUS
FsVgaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);

    FsVgaPrint((3,"FSVGA-FsVgaOpenCloseDispatch: enter\n"));

    PAGED_CODE();

    //
    // Complete the request with successful status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    FsVgaPrint((3,"FSVGA-FsVgaOpenCloseDispatch: exit\n"));

    return(STATUS_SUCCESS);

}

NTSTATUS
FsVgaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;

    FsVgaPrint((2,"FSVGA-FsVgaDeviceControl: enter\n"));

    PAGED_CODE();

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_FSVIDEO_COPY_FRAME_BUFFER:
            FsVgaPrint((2, "FsVgaDeviceControl - CopyFrameBuffer\n"));
            status = FsVgaCopyFrameBuffer(deviceExtension,
                                          (PFSVIDEO_COPY_FRAME_BUFFER) ioBuffer,
                                          inputBufferLength);
            break;

        case IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER:
            FsVgaPrint((2, "FsVgaDeviceControl - WriteToFrameBuffer\n"));
            status = FsVgaWriteToFrameBuffer(deviceExtension,
                                             (PFSVIDEO_WRITE_TO_FRAME_BUFFER) ioBuffer,
                                             inputBufferLength);
            break;

        case IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER:
            FsVgaPrint((2, "FsVgaDeviceControl - ReverseMousePointer\n"));
            status = FsVgaReverseMousePointer(deviceExtension,
                                              (PFSVIDEO_REVERSE_MOUSE_POINTER) ioBuffer,
                                              inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_CURRENT_MODE:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCurrentModes\n"));
            status = FsVgaSetMode(deviceExtension,
                                  (PFSVIDEO_MODE_INFORMATION) ioBuffer,
                                  inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_SCREEN_INFORMATION:
            FsVgaPrint((2, "FsVgaDeviceControl - SetScreenInformation\n"));
            status = FsVgaSetScreenInformation(deviceExtension,
                                               (PFSVIDEO_SCREEN_INFORMATION) ioBuffer,
                                               inputBufferLength);
            break;

        case IOCTL_FSVIDEO_SET_CURSOR_POSITION:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCursorPosition\n"));
            status = FsVgaSetCursorPosition(deviceExtension,
                                            (PFSVIDEO_CURSOR_POSITION) ioBuffer,
                                            inputBufferLength);
            break;

        case IOCTL_VIDEO_SET_CURSOR_ATTR:
            FsVgaPrint((2, "FsVgaDeviceControl - SetCursorAttribute\n"));
            status = FsVgaSetCursorAttribute(deviceExtension,
                                             (PVIDEO_CURSOR_ATTRIBUTES) ioBuffer,
                                             inputBufferLength);
            break;

        default:
            FsVgaPrint((1,
                        "FSVGA-FsVgaDeviceControl: INVALID REQUEST (0x%x)\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode));

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    FsVgaPrint((2,"FSVGA-FsVgaDeviceControl: exit\n"));

    return(status);
}

NTSTATUS
FsVgaCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine copy the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CopyFrameBuffer - Pointer to the structure containing the information about the copy frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_COPY_FRAME_BUFFER)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (CopyFrameBuffer->SrcScreen.nNumberOfChars != CopyFrameBuffer->DestScreen.nNumberOfChars) {
        return STATUS_INVALID_PARAMETER;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG OffsSrc;
        ULONG OffsDest;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        COORD ScreenSize ;
        COORD SrcScrnSize ;
        COORD SrcScrnPos ;
        COORD DstScrnSize ;
        COORD DstScrnPos ;

        ScreenSize = DeviceExtension->ScreenAndFont.ScreenSize ;
        SrcScrnSize = CopyFrameBuffer->SrcScreen.ScreenSize ;
        DstScrnSize = CopyFrameBuffer->DestScreen.ScreenSize ;
        SrcScrnPos = CopyFrameBuffer->SrcScreen.Position ;
        DstScrnPos = CopyFrameBuffer->DestScreen.Position ;

        if ((SrcScrnPos.X  > ScreenSize.X) ||
            (SrcScrnPos.Y  > ScreenSize.Y) ||
            (SrcScrnSize.X > ScreenSize.X) ||
            (DstScrnPos.X  > ScreenSize.X) ||
            (DstScrnPos.Y  > ScreenSize.Y) ||
            (DstScrnSize.X > ScreenSize.X) ||
            (SrcScrnPos.Y * SrcScrnSize.X + SrcScrnPos.X + CopyFrameBuffer->SrcScreen.nNumberOfChars 
                                                                   > (ULONG)ScreenSize.X * ScreenSize.Y) ||
            (DstScrnPos.Y * DstScrnSize.X + DstScrnPos.X + CopyFrameBuffer->DestScreen.nNumberOfChars 
                                                                   > (ULONG)ScreenSize.X * ScreenSize.Y)
              )
        {
            return STATUS_INVALID_BUFFER_SIZE;
        }

        OffsSrc = SCREEN_BUFFER_POINTER(CopyFrameBuffer->SrcScreen.Position.X,
                                        CopyFrameBuffer->SrcScreen.Position.Y,
                                        CopyFrameBuffer->SrcScreen.ScreenSize.X,
                                        sizeof(VGA_CHAR));

        OffsDest = SCREEN_BUFFER_POINTER(CopyFrameBuffer->DestScreen.Position.X,
                                         CopyFrameBuffer->DestScreen.Position.Y,
                                         CopyFrameBuffer->DestScreen.ScreenSize.X,
                                         sizeof(VGA_CHAR));

        RtlMoveMemory(pFrameBuf + OffsDest,
                      pFrameBuf + OffsSrc,
                      CopyFrameBuffer->SrcScreen.nNumberOfChars * sizeof(VGA_CHAR));
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgCopyFrameBuffer(DeviceExtension,
                                  CopyFrameBuffer,
                                  inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine write the frame buffer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    WriteFrameBuffer - Pointer to the structure containing the information about the write frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_WRITE_TO_FRAME_BUFFER)) {
        FsVgaPrint((1, "FsVgaWriteToFrameBuffer: Fail of STATUS_INVALID_BUFFER_SIZE\n"));
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (WriteFrameBuffer->DestScreen.Position.X < 0 ||
        WriteFrameBuffer->DestScreen.Position.X > DeviceExtension->ScreenAndFont.ScreenSize.X ||
        (SHORT)(WriteFrameBuffer->DestScreen.Position.X +
                WriteFrameBuffer->DestScreen.nNumberOfChars)
                                                > DeviceExtension->ScreenAndFont.ScreenSize.X ||
        WriteFrameBuffer->DestScreen.Position.Y < 0 ||
        WriteFrameBuffer->DestScreen.Position.Y > DeviceExtension->ScreenAndFont.ScreenSize.Y) {

        FsVgaPrint((1, "FsVgaWriteToFrameBuffer: Fail of STATUS_INVALID_BUFFER_SIZE\n"));

        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG Offs;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        PCHAR_IMAGE_INFO pCharInfoUni = WriteFrameBuffer->SrcBuffer;
        PCHAR_IMAGE_INFO pCharInfoAsc;
        ULONG Length = WriteFrameBuffer->DestScreen.nNumberOfChars;
        PVOID pCapBuffer = NULL;
        ULONG cCapBuffer = 0;

        Offs = SCREEN_BUFFER_POINTER(WriteFrameBuffer->DestScreen.Position.X,
                                     WriteFrameBuffer->DestScreen.Position.Y,
                                     WriteFrameBuffer->DestScreen.ScreenSize.X,
                                     sizeof(VGA_CHAR));

        cCapBuffer = Length * sizeof(CHAR_IMAGE_INFO);
        pCapBuffer = ExAllocatePool(PagedPool, cCapBuffer);

        if (!pCapBuffer) {
            ULONG dumpData[DUMP_COUNT];

            FsVgaPrint((1,
                        "FSVGA-FsVgaWriteToFrameBuffer: Could not allocate resource list\n"));
            //
            // Log an error.
            //
            dumpData[0] = cCapBuffer;
            FsVgaLogError(DeviceExtension->DeviceObject,
                          FSVGA_INSUFFICIENT_RESOURCES,
                          FSVGA_ERROR_VALUE_BASE + 200,
                          STATUS_INSUFFICIENT_RESOURCES,
                          dumpData,
                          1
                         );
            return STATUS_UNSUCCESSFUL;
        }

        TranslateOutputToOem(pCapBuffer, pCharInfoUni, Length);

        pCharInfoAsc = pCapBuffer;
        pFrameBuf += Offs;
        while (Length--)
        {
            *pFrameBuf++ = pCharInfoAsc->CharInfo.Char.AsciiChar;
            *pFrameBuf++ = (UCHAR) (pCharInfoAsc->CharInfo.Attributes);
            pCharInfoAsc++;
        }

        ExFreePool(pCapBuffer);
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgWriteToFrameBuffer(DeviceExtension,
                                     WriteFrameBuffer,
                                     inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine reverse the frame buffer for mouse pointer.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    MouseBuffer - Pointer to the structure containing the information about the mouse frame buffer.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_REVERSE_MOUSE_POINTER)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (! (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS))
    {
        /*
         * This is the TEXT frame buffer.
         */

        ULONG Offs;
        PUCHAR pFrameBuf = DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase;
        UCHAR Attribute;

        Offs = SCREEN_BUFFER_POINTER(MouseBuffer->Screen.Position.X,
                                     MouseBuffer->Screen.Position.Y,
                                     MouseBuffer->Screen.ScreenSize.X,
                                     sizeof(VGA_CHAR));
        pFrameBuf += Offs;

        Attribute =  (*(pFrameBuf + 1) & 0xF0) >> 4;
        Attribute |= (*(pFrameBuf + 1) & 0x0F) << 4;
        *(pFrameBuf + 1) = Attribute;
    }
    else
    {
        /*
         * This is the GRAPHICS frame buffer.
         */
        return FsgReverseMousePointer(DeviceExtension,
                                      MouseBuffer,
                                      inputBufferLength);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetMode(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_MODE_INFORMATION ModeInformation,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the current video information.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the structure containing the information about the
                      full screen video.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_MODE_INFORMATION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    DeviceExtension->CurrentMode = *ModeInformation;

    FsVgaPrint((3, "FsVgaSetMode: Video Mode:\n"));
    FsVgaPrint((3, "    ModeIndex = %x\n", DeviceExtension->CurrentMode.VideoMode.ModeIndex));
    FsVgaPrint((3, "    VisScreenWidth = %d\n", DeviceExtension->CurrentMode.VideoMode.VisScreenWidth));
    FsVgaPrint((3, "    VisScreenHeight = %d\n", DeviceExtension->CurrentMode.VideoMode.VisScreenHeight));
    FsVgaPrint((3, "    NumberOfPlanes = %d\n", DeviceExtension->CurrentMode.VideoMode.NumberOfPlanes));
    FsVgaPrint((3, "    BitsPerPlane = %d\n", DeviceExtension->CurrentMode.VideoMode.BitsPerPlane));

    FsVgaPrint((3, "FsVgaSetMode: Video Memory:\n"));
    FsVgaPrint((3, "    VideoRamBase = %x\n", DeviceExtension->CurrentMode.VideoMemory.VideoRamBase));
    FsVgaPrint((3, "    VideoRamLength = %x\n", DeviceExtension->CurrentMode.VideoMemory.VideoRamLength));
    FsVgaPrint((3, "    FrameBufferBase = %x\n", DeviceExtension->CurrentMode.VideoMemory.FrameBufferBase));
    FsVgaPrint((3, "    FrameBufferLength = %x\n", DeviceExtension->CurrentMode.VideoMemory.FrameBufferLength));

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetScreenInformation(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_SCREEN_INFORMATION ScreenInformation,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the screen and font information.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    ScreenInformation - Pointer to the structure containing the information about the
                        screen anf font.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(FSVIDEO_SCREEN_INFORMATION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    DeviceExtension->ScreenAndFont = *ScreenInformation;

    FsVgaPrint((3, "FsVgaSetScreenInformation:\n"));
    FsVgaPrint((3, "    ScreenSize.X = %d, Y = %d\n",
                   DeviceExtension->ScreenAndFont.ScreenSize.X,
                   DeviceExtension->ScreenAndFont.ScreenSize.Y));
    FsVgaPrint((3, "    FontSize.X = %d, Y = %d\n",
                   DeviceExtension->ScreenAndFont.FontSize.X,
                   DeviceExtension->ScreenAndFont.FontSize.Y));

    FsgVgaInitializeHWFlags(DeviceExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
FsVgaSetCursorPosition(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_CURSOR_POSITION CursorPosition,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the cursor position.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the information about the
                     cursor position.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(VIDEO_CURSOR_POSITION)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,FALSE);
    }

    DeviceExtension->EmulateInfo.CursorPosition = *CursorPosition;

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,TRUE);
        return STATUS_SUCCESS;
    }
    else
    {
        /*
         * If current video mode is a TEXT MODE.
         * FSVGA.SYS didn't handling hardware cursor
         * because I don't know device of VGA.SYS or others.
         *
         * In this case, by returns STATUS_UNSUCCESSFUL, caller 
         * do DeviceIoControl to VGA miniport driver.
         */
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
FsVgaSetCursorAttribute(
    PDEVICE_EXTENSION DeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG inputBufferLength
    )

/*++

Routine Description:

    This routine sets the cursor attributes.

Arguments:

    DeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the structure containing the information about the
                       cursor attributes.

    inputBufferLength - Length of the input buffer supplied by the user.

Return Value:

    STATUS_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    STATUS_SUCCESS if the operation completed successfully.

--*/

{
    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (inputBufferLength < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,FALSE);
    }

    DeviceExtension->EmulateInfo.CursorAttributes = *CursorAttributes;

    if (DeviceExtension->CurrentMode.VideoMode.AttributeFlags & VIDEO_MODE_GRAPHICS)
    {
        FsgInvertCursor(DeviceExtension,TRUE);
        return STATUS_SUCCESS;
    }
    else
    {
        /*
         * If current video mode is a TEXT MODE.
         * FSVGA.SYS didn't handling hardware cursor
         * because I don't know device of VGA.SYS or others.
         *
         * In this case, by returns STATUS_UNSUCCESSFUL, caller 
         * do DeviceIoControl to VGA miniport driver.
         */
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
FsVgaLogError(
    IN PVOID Object,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines, especially FsVgaInitialize, to avoid
    duplication of code.  Note that some routines continue to have their
    own error logging code (especially in the case where the error logging
    can be localized and/or the routine has more data because there is
    and IRP).

Arguments:

    Object - Pointer to the device or driver object.

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.


Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                (PVOID) Object,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (DumpCount * sizeof(ULONG)))
                );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }
}


#if DBG
VOID
FsVgaDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= Globals.FsVgaDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsvga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fsvga.h

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#ifndef _FSVGA_
#define _FSVGA_

#include "stdarg.h"
#include "stdio.h"

#include "ntddk.h"
#include "ntddvdeo.h"
#include "vga.h"

#include "fsvgalog.h"

#define FSVGA_POOL_TAG 'gVsF'
#undef ExAllocatePool
#define ExAllocatePool(Type, Bytes) ExAllocatePoolWithTag(Type, Bytes, FSVGA_POOL_TAG)

//
// Define the default number of elements in the class input data queue.
//
#define DUMP_COUNT 4
#define DEFAULT_DEBUG_LEVEL 0

//
// Define the i8042 controller input/output ports.
//

typedef enum _VGA_IO_PORT_TYPE {
    CRTCAddressPortColor = 0,
    CRTCDataPortColor,
    GRAPHAddressPort,
    SEQAddressPort,
    MaximumPortCount
} VGA_IO_PORT_TYPE;

typedef struct _PORT_LIST {
    PVOID   Port;
    ULONG   Length;
    BOOLEAN MapRegistersRequired;
} PORT_LIST, *PPORT_LIST;

//
// FSVGA configuration information.
//

typedef struct _FSVGA_CONFIGURATION_INFORMATION {

    USHORT    EmulationMode;
        #define ENABLE_WORD_WRITE_VRAM   0x01

    USHORT    HardwareCursor;
        #define NO_HARDWARE_CURSOR          0
        #define HARDWARE_CURSOR          0x01

    USHORT    HardwareScroll;
        #define NO_HARDWARE_SCROLL          0
        #define HARDWARE_SCROLL          0x01
        #define USE_LINE_COMPARE         0x02
        #define OFFSET_128_TO_NEXT_SLICE 0x04

    USHORT    IOPort;

} FSVGA_CONFIGURATION_INFORMATION, *PFSVGA_CONFIGURATION_INFORMATION;

//
// FSVGA resource information.
//

typedef struct _FSVGA_RESOURCE_INFORMATION {

    //
    // Indicate which hardware is actually present (display).
    //

    ULONG HardwarePresent;

#ifdef RESOURCE_REQUIREMENTS
    //
    // Bus interface type.
    //

    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //

    ULONG BusNumber;
#endif

    //
    // The mapped addresses for this device's registers.
    //

    PORT_LIST PortList[MaximumPortCount];

} FSVGA_RESOURCE_INFORMATION, *PFSVGA_RESOURCE_INFORMATION;

//
// EMULATE_BUFFER_INFORMATION structure
//
typedef struct _EMULATE_BUFFER_INFORMATION {
    //
    // Hardware scroll
    //
    USHORT StartAddress;
    USHORT LineCompare;
    USHORT PrevLineCompare;
    USHORT BytePerLine;
    USHORT MaxScanLine;
    ULONG LimitGRAM;
        #define LIMIT_64K 0x10000L
    USHORT DeltaNextFontRow;
    //
    // Color Attributes for last access.
    //
    UCHAR ColorFg;
    UCHAR ColorBg;
    //
    // Cursor position and attributes for last access.
    VIDEO_CURSOR_ATTRIBUTES CursorAttributes;
    FSVIDEO_CURSOR_POSITION CursorPosition;
    BOOLEAN ShowCursor;
} EMULATE_BUFFER_INFORMATION, *PEMULATE_BUFFER_INFORMATION;

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Next lower driver in same stack.
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Use count on this device.
    //

    LONG usage;

    //
    // Set when okay to remove this device.
    //

    KEVENT evRemove;

    //
    // TRUE if we're trying to remove this device.
    //

    BOOLEAN removing;

    //
    // TRUE if device has been started.
    //

    BOOLEAN started;

    //
    // Port resource information.
    //

    FSVGA_RESOURCE_INFORMATION Resource;

    //
    // FSVIDEO_MODE_INFORMATION structure for the current mode
    //
    FSVIDEO_MODE_INFORMATION CurrentMode;

    //
    // FSVIDEO_SCREEN_INFORMATION structure
    //
    FSVIDEO_SCREEN_INFORMATION ScreenAndFont;

    //
    // EMULATE_BUFFER_INFORMATION structure
    //
    EMULATE_BUFFER_INFORMATION EmulateInfo;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Global shared data
//

typedef struct _GLOBALS {
    //
    // Declare the global debug flag for this driver.
    //
    ULONG               FsVgaDebug;

    //
    // A list of the registry path to the service parameters.
    //
    UNICODE_STRING      RegistryPath;

    //
    // Port configuration information.
    //
    FSVGA_CONFIGURATION_INFORMATION Configuration;

    //
    // Resource list and size
    //
    FSVGA_RESOURCE_INFORMATION      Resource;

} GLOBALS, *PGLOBALS;

extern GLOBALS Globals;


//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define FSVGA_ERROR_VALUE_BASE        1000

//
// Defines for DeviceExtension->HardwarePresent.
//

#define FSVGA_HARDWARE_PRESENT  1


//
// Function prototypes.
//


//
// fsvga.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FsVgaQueryDevice(
    IN PFSVGA_RESOURCE_INFORMATION Resource
    );

NTSTATUS
FsVgaPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaQueryAperture(
    OUT PIO_RESOURCE_LIST *pApertureRequirements
    );
#endif

NTSTATUS
FsVgaCreateResource(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    OUT PCM_PARTIAL_RESOURCE_LIST *pResourceList
    );

VOID
FsVgaServiceParameters(
    IN PFSVGA_CONFIGURATION_INFORMATION configuration,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FsVgaOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsVgaDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsVgaCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetMode(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_MODE_INFORMATION ModeInformation,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetScreenInformation(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_SCREEN_INFORMATION ScreenInformation,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetCursorPosition(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_CURSOR_POSITION CursorPosition,
    ULONG inputBufferLength
    );

NTSTATUS
FsVgaSetCursorAttribute(
    PDEVICE_EXTENSION DeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG inputBufferLength
    );

VOID
FsVgaLogError(
    IN PVOID Object,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    );

#if DBG
VOID
FsVgaDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

extern ULONG FsVgaDebug;
#define FsVgaPrint(x) FsVgaDebugPrint x
#else
#define FsVgaPrint(x)
#endif

//
// drawscrn.c
//
ULONG
CalcGRAMSize(
    IN COORD WindowSize,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

PUCHAR
CalcGRAMAddress(
    IN COORD WindowSize,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PFSVIDEO_SCREEN_INFORMATION ScreenInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

#ifdef LATER_HIGH_SPPED_VRAM_ACCESS  // kazum
BOOLEAN
IsGRAMRowOver(
    PUCHAR BufPtr,
    BOOLEAN fDbcs,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );
#endif // LATER_HIGH_SPPED_VRAM_ACCESS  // kazum

PUCHAR
NextGRAMRow(
    PUCHAR BufPtr,
    IN PFSVIDEO_MODE_INFORMATION VideoModeInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
memcpyGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length
    );

VOID
memcpyGRAMOver(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
MoveGRAM(
    IN PCHAR TargetPtr,
    IN PCHAR SourcePtr,
    IN ULONG Length,
    IN PUCHAR FrameBufPtr,
    IN PFSVGA_RESOURCE_INFORMATION ResourceInfo,
    IN PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

NTSTATUS
FsgVgaInitializeHWFlags(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FsgCopyFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_COPY_FRAME_BUFFER CopyFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgWriteToFrameBuffer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_WRITE_TO_FRAME_BUFFER WriteFrameBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgReverseMousePointer(
    PDEVICE_EXTENSION DeviceExtension,
    PFSVIDEO_REVERSE_MOUSE_POINTER MouseBuffer,
    ULONG inputBufferLength
    );

NTSTATUS
FsgInvertCursor(
    PDEVICE_EXTENSION DeviceExtension,
    BOOLEAN Invert
    );

NTSTATUS
FsgWriteToScreen(
    PUCHAR FrameBuffer,
    PUCHAR BitmapBuffer,
    ULONG cjBytes,
    BOOLEAN fDbcs,
    USHORT Attributes1,
    USHORT Attributes2,
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FsgWriteToScreenCommonLVB(
    PUCHAR FrameBuffer,
    USHORT Attributes,
    PDEVICE_EXTENSION DeviceExtension
    );

UCHAR
AccessGRAM_WR(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

UCHAR
AccessGRAM_RW(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

UCHAR
AccessGRAM_AND(
    PUCHAR FrameBuffer,
    UCHAR  write
    );

//
// foncache.c
//
ULONG
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN ULONG dwAlign
    );

VOID
AlignCopyMemory(
    OUT PUCHAR pDestBits,
    IN ULONG dwDestAlign,
    IN PUCHAR pSrcBits,
    IN ULONG dwSrcAlign,
    IN COORD FontSize
    );

//
// misc.c
//
int
ConvertOutputToOem(
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    );

NTSTATUS
TranslateOutputToOem(
    OUT PCHAR_IMAGE_INFO OutputBuffer,
    IN  PCHAR_IMAGE_INFO InputBuffer,
    IN  ULONG Length
    );

//
// port.c
//
VOID
GetHardwareScrollReg(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo
    );

VOID
SetGRAMWriteMode(
    PPORT_LIST PortList
    );

VOID
SetGRAMCopyMode(
    PPORT_LIST PortList
    );

VOID
SetGRAMInvertMode(
    PPORT_LIST PortList
    );

VOID
set_opaque_bkgnd_proc(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo,
    PUCHAR FrameBuffer,
    USHORT Attributes
    );

VOID
ColorSetGridMask(
    PPORT_LIST PortList,
    UCHAR BitMask
    );

VOID
ColorSetDirect(
    PPORT_LIST PortList,
    PUCHAR FrameBuffer,
    UCHAR ColorFg,
    UCHAR ColorBg
    );

//
// pnp.c
//
VOID
FsVgaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FsVgaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    );

NTSTATUS
FsVgaDevicePnp(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaDefaultPnpHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpRemoveDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpStartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
FsVgaPnpStopDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaFilterResourceRequirements(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );
#endif

NTSTATUS
FsVgaDevicePower(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS 
FsVgaDefaultPowerHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
CompleteRequest(
    IN PIRP Irp,
    IN NTSTATUS status,
    IN ULONG info
    );

NTSTATUS
ForwardAndWait(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    );

NTSTATUS
OnRequestComplete(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp,
    IN PKEVENT pev
    );

VOID
RemoveDevice(
    IN PDEVICE_OBJECT fdo
    );

BOOLEAN
LockDevice(
    IN PDEVICE_EXTENSION pdx
    );

VOID
UnlockDevice(
    IN PDEVICE_EXTENSION pdx
    );

NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PCM_PARTIAL_RESOURCE_LIST list
    );

VOID
StopDevice(
    IN PDEVICE_OBJECT fdo
    );

#endif // _FSVGA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\foncache.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    foncache.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"



#define ADD_IMAGE     1
#define REPLACE_IMAGE 2


#define CALC_BITMAP_BITS_FOR_X( FontSizeX, dwAlign ) \
    ( ( ( FontSizeX * BITMAP_BITS_PIXEL + (dwAlign-1) ) & ~(dwAlign-1)) >> BITMAP_ARRAY_BYTE )



ULONG
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN ULONG dwAlign
    )
{
    ULONG uiCount;

    uiCount = CALC_BITMAP_BITS_FOR_X(FontSize.X,
                                     (dwAlign==BYTE_ALIGN ? BITMAP_BITS_BYTE_ALIGN : BITMAP_BITS_WORD_ALIGN));
    uiCount = uiCount * BITMAP_PLANES * FontSize.Y;
    return uiCount;
}


VOID
AlignCopyMemory(
    OUT PUCHAR pDestBits,
    IN ULONG  dwDestAlign,
    IN PUCHAR pSrcBits,
    IN ULONG  dwSrcAlign,
    IN COORD  FontSize
    )
{
    ULONG dwDestBufferSize;
    COORD coord;

    try
    {

        if (dwDestAlign == dwSrcAlign) {
            dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
            return;
        }

        switch (dwDestAlign) {
            default:
            case WORD_ALIGN:
                switch (dwSrcAlign) {
                    default:
                    //
                    // pDest = WORD, pSrc = WORD
                    //
                    case WORD_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        break;
                    //
                    // pDest = WORD, pSrc = BYTE
                    //
                    case BYTE_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                            ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        }
                        else {
                            RtlZeroMemory(pDestBits, dwDestBufferSize);
                            for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                                for (coord.X=0;
                                     coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                     coord.X++) {
                                    *pDestBits++ = *pSrcBits++;
                                }
                                if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                    pDestBits++;
                            }
                        }
                        break;
                }
                break;
            case BYTE_ALIGN:
                switch (dwSrcAlign) {
                    //
                    // pDest = BYTE, pSrc = BYTE
                    //
                    case BYTE_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        break;
                    default:
                    //
                    // pDest = BYTE, pSrc = WORD
                    //
                    case WORD_ALIGN:
                        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                        if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                            ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                            RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                        }
                        else {
                            RtlZeroMemory(pDestBits, dwDestBufferSize);
                            for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                                for (coord.X=0;
                                     coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                     coord.X++) {
                                    *pDestBits++ = *pSrcBits++;
                                }
                                if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                    pSrcBits++;
                            }
                        }
                        break;
                }
                break;
        }

    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\port.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

#define MAKEWORD(a, b) (USHORT)((((USHORT)a) & 0xFF) | ((((USHORT)(b)) << 8) & 0xFF00))

VOID
GetHardwareScrollReg(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo
    )

/*++

Routine Description:

    This routine gets the hardware scrolls register value.

Arguments:

Return Value:

--*/

{
    UCHAR low;
    UCHAR high;
    UCHAR mid;

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_START_ADRS_L);
    low = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_START_ADRS_H);
    high = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    EmulateInfo->StartAddress = MAKEWORD(low, high);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE);
    low = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE8);
    mid = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);
    mid = (mid >> 4) & 1;

    WRITE_PORT_UCHAR(PortList[CRTCAddressPortColor].Port,
                      IND_LINE_COMPARE9);
    high = READ_PORT_UCHAR(PortList[CRTCDataPortColor].Port);
    high = (high >> 5) & 2;

    high |= mid;
    EmulateInfo->LineCompare = MAKEWORD(low, high);
}

VOID
SetGRAMWriteMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the write mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_PROC_WRITE+M_DATA_READ));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    //
    // Enable all the available EGA planes.
    //
    WRITE_PORT_USHORT(PortList[SEQAddressPort].Port,
                      MAKEWORD(IND_MAP_MASK, GRAPH_ADDR_MASK));
    //
    // Use all pixel positions.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BIT_MASK_DEFAULT));

}

VOID
SetGRAMCopyMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the copy mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_LATCH_WRITE+M_COLOR_READ));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_COLOR_DONT_CARE, 0));
}

VOID
SetGRAMInvertMode(
    PPORT_LIST PortList
    )

/*++

Routine Description:

    This routine sets the invert mode of graphics register.

Arguments:

Return Value:

--*/

{
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_GRAPH_MODE, M_AND_WRITE+M_COLOR_READ));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_XOR));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BIT_MASK_DEFAULT));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_COLOR_DONT_CARE, 0));

    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0xff));
}

VOID
set_opaque_bkgnd_proc(
    PPORT_LIST PortList,
    PEMULATE_BUFFER_INFORMATION EmulateInfo,
    PUCHAR FrameBuffer,
    USHORT Attributes
    )

/*++

set_opaque_bkgnd

  Set the VGA registers for drawing a full screen byte with opaque
  font and opaque background.

Created.

--*/

{
    UCHAR ColorFg = Attributes & 0x0f;
    UCHAR ColorBg = (Attributes & 0xf0) >> 4;

    if (Attributes & COMMON_LVB_REVERSE_VIDEO)
    {
        Attributes = ColorBg;
        ColorBg = ColorFg;
        ColorFg = (UCHAR)Attributes;
    }

    if (EmulateInfo->ColorFg == ColorFg &&
        EmulateInfo->ColorBg == ColorBg)
        return;

    EmulateInfo->ColorFg = ColorFg;
    EmulateInfo->ColorBg = ColorBg;

    ColorSetDirect(PortList, FrameBuffer, ColorFg, ColorBg);
}

VOID
ColorSetGridMask(
    PPORT_LIST PortList,
    UCHAR BitMask
    )
{

    //
    // That color is used for all planes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, GRAPH_ADDR_MASK));

    //
    // Change the Set/Reset register to be all set.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0x07));

    //
    // Use specified pixel positions.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_BIT_MASK, BitMask));

    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));
}

VOID
ColorSetDirect(
    PPORT_LIST PortList,
    PUCHAR FrameBuffer,
    UCHAR ColorFg,
    UCHAR ColorBg
    )

/*++

ColorSetDirect

  Set the VGA registers for drawing a full screen byte with opaque
  font and opaque background.

Created.

--*/

{
    //
    // Set up to write data without interacting with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_SET));

    //
    // Put the background color in the Set/Reset register.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, ColorBg));

    //
    // That color is used for all planes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, GRAPH_ADDR_MASK));

    //
    // This gets our background color into the latches.
    //
    AccessGRAM_WR(FrameBuffer, GRAPH_ADDR_MASK);

    //
    // Change the Set/Reset register to be all zeroes.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET, 0));

    //
    // The Set/Reset enable register now flags where the foreground/background colors are the same.
    //
    ColorFg = ~(ColorFg ^ ColorBg);
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_SET_RESET_ENABLE, ColorFg));

    //
    // Color differences will be xor'd with the latches.
    //
    WRITE_PORT_USHORT(PortList[GRAPHAddressPort].Port,
                      MAKEWORD(IND_DATA_ROTATE, DR_XOR));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\vga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.h

Abstract:

    This module contains the definitions for the code that implements the
    VGA device driver.

Author:

Environment:

    Kernel mode

Revision History:


--*/




//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Index in the access range sturture for video memory
// !!! This must match the VgaAccessRange structure    !!!
// !!! Memory is in the structure, index 2 (3rd entry) !!!

#define VGA_MEMORY  2


//
// VGA port-related definitions.
//
//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode


//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_START_ADRS_H        0x0C    // index in CRTC of Start Address (high)
#define IND_START_ADRS_L        0x0D    // index in CRTC of Start Address (low)
#define IND_LINE_COMPARE        0x18    // index in CRTC of Line Compare (bit7-0)
#define IND_LINE_COMPARE8       0x07    // index in CRTC of Line Compare (bit8)
#define IND_LINE_COMPARE9       0x09    // index in CRTC of Line Compare (bit9)
#define IND_SET_RESET           0x00    // index of Set/Reset Plane Color Register in Graph Ctrl
#define IND_COLOR_DONT_CARE     0x07    // index of Color Don't Care Register in Graph Ctrl

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// IND_DATA_ROTATE : index of Data Rotate reg in GC
//
#define DR_ROT_CNT      0x07   // Data Rotate Count
#define DR_SET          0x00   // Data Unmodified
#define DR_AND          0x08   // Data ANDed with latches
#define DR_OR           0x10   // Data ORed    with latches
#define DR_XOR          0x18   // Data XORed with latches

//
// IND_GRAPH_MODE : index of Mode reg in Graph Ctlr
//
#define M_PROC_WRITE    0x00   // Write processor data rotated
#define M_LATCH_WRITE   0x01   // Write latched data
#define M_COLOR_WRITE   0x02   // Write processor data as color
#define M_AND_WRITE     0x03   // Write (procdata AND bitmask)
#define M_DATA_READ     0x00   // Read selected plane
#define M_COLOR_READ    0x08   // Read color compare

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\misc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This is the console fullscreen driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"


int
ConvertOutputToOem(
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
/*
    Converts SourceLength Unicode characters from Source into
    not more than TargetLength Codepage characters at Target.
    Returns the number characters put in Target. (0 if failure)

    [ntcon\server\misc.c]
*/

{
    NTSTATUS Status;
    int Length;
    UNICODE_STRING SourceUni;
    ANSI_STRING TargetAns;
    CHAR AnsBuf[256];

    SourceUni.MaximumLength =
    SourceUni.Length = SourceLength * sizeof(WCHAR);
    SourceUni.Buffer = Source;

    TargetAns.Length = 0;
    TargetAns.MaximumLength = sizeof(AnsBuf);
    TargetAns.Buffer = AnsBuf;

    // Can do this in place
    Status = RtlUnicodeStringToAnsiString(&TargetAns,
                                          &SourceUni,
                                          FALSE);
    if (NT_SUCCESS(Status)) {
        Length = strlen(AnsBuf);
        if (Length <= TargetLength) {
            RtlMoveMemory(Target, AnsBuf, Length);
            return Length;
        }
        else {
            return 0;
        }
    } else {
        return 0;
    }
}

/***************************************************************************\
* TranslateOutputToOem
*
* routine to translate console PCHAR_INFO to the ASCII from Unicode
*
* [ntcon\server\fe\direct2.c]
\***************************************************************************/
NTSTATUS
TranslateOutputToOem(
    OUT PCHAR_IMAGE_INFO OutputBuffer,
    IN  PCHAR_IMAGE_INFO InputBuffer,
    IN  ULONG Length
    )
{
    CHAR AsciiDbcs[2];
    ULONG NumBytes;

    while (Length--)
    {
        if (InputBuffer->CharInfo.Attributes & COMMON_LVB_LEADING_BYTE)
        {
            if (Length >= 2)    // Safe DBCS in buffer ?
            {
                Length--;
                NumBytes = sizeof(AsciiDbcs);
                NumBytes = ConvertOutputToOem(&InputBuffer->CharInfo.Char.UnicodeChar,
                                              1,
                                              &AsciiDbcs[0],
                                              NumBytes);
                OutputBuffer->CharInfo.Char.AsciiChar = AsciiDbcs[0];
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
                OutputBuffer++;
                InputBuffer++;
                OutputBuffer->CharInfo.Char.AsciiChar = AsciiDbcs[1];
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
                OutputBuffer++;
                InputBuffer++;
            }
            else
            {
                OutputBuffer->CharInfo.Char.AsciiChar = ' ';
                OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes & ~COMMON_LVB_SBCSDBCS;
                OutputBuffer++;
                InputBuffer++;
            }
        }
        else if (! (InputBuffer->CharInfo.Attributes & COMMON_LVB_SBCSDBCS))
        {
            ConvertOutputToOem(&InputBuffer->CharInfo.Char.UnicodeChar,
                               1,
                               &OutputBuffer->CharInfo.Char.AsciiChar,
                               1);
            OutputBuffer->CharInfo.Attributes = InputBuffer->CharInfo.Attributes;
            OutputBuffer++;
            InputBuffer++;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\driver\makefile.inc ===
fsvgalog.h fsvgalog.rc msg00001.bin: ..\fsvgalog.mc
    mc fsvgalog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\sources.inc ===
TARGETNAME=fsvga
TARGETPATH=obj
TARGETTYPE=DRIVER

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=$(DDK_INC_PATH)

SOURCES=

i386_SOURCES=..\fsvga.rc   \
             ..\fsvga.c    \
             ..\drawscrn.c \
             ..\foncache.c \
             ..\misc.c     \
             ..\port.c     \
             ..\pnp.c      \
             ..\fsvgalog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsconins\fsconins.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      fsconins.h
 *
 *  Abstract:
 *
 *      This file defines FsConInstall class
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _FSCONINS_H_
 #error "fsconins.h already included!"
#else
 #define _FSCONINS_H_
#endif


/*-[ types and defines ]-----------------------------------*/

class FsConInstall {

private:
    PPER_COMPONENT_DATA m_cd;

    DWORD
    GetPnPID(
        OUT LPTSTR pszPnPID,
        IN  DWORD  dwSize
    );

public:
    FsConInstall();

    FsConInstall(
        IN PPER_COMPONENT_DATA cd
    );


    BOOL
    GUIModeSetupInstall(
        IN HWND hwndParent = NULL
    );

    BOOL
    GUIModeSetupUninstall(
        IN HWND hwndParent = NULL
    );

    BOOL
    InfSectionRegistryAndFiles(
        IN LPCTSTR SubcomponentId,
        IN LPCTSTR Key
    );

    BOOL
    QueryStateInfo(
        IN LPCTSTR SubcomponentId
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\pnp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains general PnP and Power code for the console fullscreen driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "fsvga.h"

VOID
FsVgaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine called when this driver is about to be unloaded. In
    previous versions of NT, this function would have gone through the list of
    DEV)CEOBJECTS belonging to this driver in order to delete each one. That
    function now happens (if it needs to) in response to IRP_MN_REMOVE_DEVICE
    PnP IRP's.

++*/

{
    FsVgaPrint((2,"FSVGA-FsVgaDriverUnload:\n"));

    ExFreePool(Globals.RegistryPath.Buffer);
}

NTSTATUS
FsVgaAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT pdo
    )

/*++

Routine Description:

    This routine called when the Configuration Manager detects (or gets told about
    via the New Hardware Wizard) a new device for which this module is the driver.
    Its main purpose is to create a functional device object (FDO) and to layer the
    FDO into the stack of device objects.

++*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT fdo;
    PDEVICE_EXTENSION pdx;

    UNICODE_STRING DeviceName;

    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((2,"FSVGA-FsVgaAddDevice: enter\n"));

    //
    // Create a functional device object to represent the hardware we're managing.
    //
    RtlInitUnicodeString(&DeviceName, DD_FULLSCREEN_VIDEO_DEVICE_NAME);

    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &DeviceName,
                            FILE_DEVICE_FULLSCREEN_VIDEO,
                            0,
                            TRUE,
                            &fdo);
    if (!NT_SUCCESS(status)) {
        FsVgaPrint((1,
                    "FSVGA-FsVgaAddDevice: Couldn't create device object\n"));
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaAddDeviceExit;
    }

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    pdx->DeviceObject = fdo;
    pdx->usage = 1;            // locked until RemoveDevice
    KeInitializeEvent(&pdx->evRemove, NotificationEvent, FALSE); // set when use count drops to zero

    //
    // Since we must pass PNP requests down to the next device object in the chain
    // (namely the physical device object created by the bus enumerator), we have
    // to remember what that device is. That's why we defined the LowerDeviceObject
    // member in our deviceextension.
    //
    pdx->LowerDeviceObject = IoAttachDeviceToDeviceStack(fdo, pdo);

    //
    // Monolithic kernel-mode drivers usually create device objects during DriverEntry,
    // and the I/O manager automatically clears the INITIALIZING flag. Since we're
    // creating the object later (namely in response to PnP START_DEVICE request),
    // we need to clear the flag manually.
    //
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

FsVgaAddDeviceExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError((fdo == NULL) ? (PVOID) DriverObject : (PVOID) fdo,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    FsVgaPrint((2,"FSVGA-FsVgaAddDevice: exit\n"));

    return status;
}

NTSTATUS
FsVgaDevicePnp(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine uses the IRP's minor function code to dispatch a handler
    function (like HandleStartDevice for IRP_MN_START_DEVICE) that actually
    handles the request. It calls DefaultPnpHandler for requests that we don't
    specifically need to handle.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;
    UCHAR MinorFunction;

    if (!LockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension)) {
        return CompleteRequest(Irp, STATUS_DELETE_PENDING, 0);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(stack->MajorFunction == IRP_MJ_PNP);

    switch (MinorFunction = stack->MinorFunction) {
        case IRP_MN_START_DEVICE:
            status = FsVgaPnpStartDevice(fdo, Irp);
            break;
        case IRP_MN_REMOVE_DEVICE:
            status = FsVgaPnpRemoveDevice(fdo, Irp);
            break;
        case IRP_MN_STOP_DEVICE:
            status = FsVgaPnpStopDevice(fdo, Irp);
            break;
#ifdef RESOURCE_REQUIREMENTS
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            status = FsVgaFilterResourceRequirements(fdo, Irp);
            break;
#endif
        default:
            FsVgaPrint((2,"FSVGA-FsVgaDevicePnp: MinorFunction:%x\n",stack->MinorFunction));
            status = FsVgaDefaultPnpHandler(fdo, Irp);
            break;
    }

    if (MinorFunction != IRP_MN_REMOVE_DEVICE) {
        UnlockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension);
    }

    return status;
}

NTSTATUS
FsVgaDefaultPnpHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function sends the request down to the next lower layer and
    returns whatever status that generates.

++*/

{
    PDEVICE_EXTENSION pdx;

    IoSkipCurrentIrpStackLocation(Irp);
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    return IoCallDriver(pdx->LowerDeviceObject, Irp);
}

NTSTATUS
FsVgaPnpRemoveDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls StopDevice to shut the device down, DefaultPnpHandler
    to pass the request down the stack, and RemoveDevice to cleanup the FDO.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    FsVgaPrint((2,"FSVGA-FsVgaPnpRemoveDevice: enter\n"));

    //
    // Wait for any pending I/O operations to complete
    //
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    pdx->removing = TRUE;
    UnlockDevice(pdx);        // once for LockDevice at start of dispatch
    UnlockDevice(pdx);        // once for initialization during AddDevice
    KeWaitForSingleObject(&pdx->evRemove, Executive, KernelMode, FALSE, NULL);

    //
    // Do any processing required for *us* to remove the device. This
    // would include completing any outstanding requests, etc.
    //
    StopDevice(fdo);

    //
    // Let lower-level drivers handle this request. Ignore whatever
    // result eventuates.
    //
    status = FsVgaDefaultPnpHandler(fdo, Irp);

    //
    // Remove the device object
    //
    RemoveDevice(fdo);

    FsVgaPrint((2,"FSVGA-FsVgaPnpRemoveDevice: exit\n"));

    return status;
}

NTSTATUS
FsVgaPnpStartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine calls ForwardAndWait to pass the IRP down the stack and
    StartDevice to configure the device and this driver. Then it completes the
    IRP.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;

    FsVgaPrint((2,"FSVGA-FsVgaPnpStartDevice: enter\n"));

    //
    // First let all lower-level drivers handle this request. In this particular
    // sample, the only lower-level driver should be the physical device created
    // by the bus driver, but there could theoretically be any number of intervening
    // bus filter devices. Those drivers may need to do some setup at this point
    // in time before they'll be ready to handle non-PnP IRP's.
    //
    status = ForwardAndWait(fdo, Irp);
    if (!NT_SUCCESS(status)) {
        return CompleteRequest(Irp, status, Irp->IoStatus.Information);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    {
        VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list);

        if (stack->Parameters.StartDevice.AllocatedResources != NULL) {
            KdPrint(("  Resources:\n"));
            ShowResources(&stack->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList);
        }

        if (stack->Parameters.StartDevice.AllocatedResourcesTranslated != NULL) {
            KdPrint(("  Translated Resources:\n"));
            ShowResources(&stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);
        }
    }
#endif // DBG

    if (stack->Parameters.StartDevice.AllocatedResourcesTranslated != NULL) {
        status = StartDevice(fdo,
                             &stack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0].PartialResourceList);
    }
    else {
        PCM_PARTIAL_RESOURCE_LIST list;

        FsVgaPrint((1,
                    "FSVGA-FsVgaPnpStartDevice: AllocatedResourcesTranslated is NULL\n" \
                    "*\n* Create hardware depended IO port list.\n*\n"
                  ));

        //
        // Create the current FsVga resource.
        //
        status = FsVgaCreateResource(&Globals.Configuration,&list);
        if (!NT_SUCCESS(status)) {
            return CompleteRequest(Irp, status, Irp->IoStatus.Information);
        }

#if DBG
        {
            VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list);

            if (list != NULL) {
                KdPrint(("  Resources:\n"));
                ShowResources(list);
            }
        }
#endif // DBG

        status = StartDevice(fdo, list);
    }

    FsVgaPrint((2,"FSVGA-FsVgaPnpStartDevice: exit\n"));

    return CompleteRequest(Irp, status, 0);
}

NTSTATUS
FsVgaPnpStopDevice(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    We will sometimes, but not always, get a STOP_DEVICE before getting a
    REMOVE_DEVICE.

++*/

{
    NTSTATUS status;

    FsVgaPrint((2,"FSVGA-FsVgaPnpStopDevice: enter\n"));

    status = FsVgaDefaultPnpHandler(fdo, Irp);
    StopDevice(fdo);

    FsVgaPrint((2,"FSVGA-FsVgaPnpStopDevice: exit\n"));

    return status;
}


#ifdef RESOURCE_REQUIREMENTS
NTSTATUS
FsVgaFilterResourceRequirements(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS. This adds on the
    FsVga resource requirements.

Arguments:

    fdo - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements = NULL;
    ULONG NewSize;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements = NULL;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    PIO_STACK_LOCATION stack;

    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    ULONG dumpData[DUMP_COUNT];

    FsVgaPrint((2,"FSVGA-FsVgaFilterResourceRequirements: enter\n"));

    stack = IoGetCurrentIrpStackLocation(Irp);

    OldRequirements = stack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //
        // PNP helpfully passes us a NULL pointer instead of an empty resource list
        // when the bridge is disabled. In this case we will ignore this irp and not
        // add on our requirements since they are not going to be used anyway.
        //
        FsVgaPrint((3,"FSVGA-FsVgaFilterResourceRequirements: OldRequirements is NULL\n"));
    }

    //
    // Get the current FsVga aperture.
    //
    status = FsVgaQueryAperture(&ApertureRequirements);  /* , &Globals.Resource); */
    if (!NT_SUCCESS(status)) {
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaFilterResourceRequirementsExit;
    }

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative.
    //
    // Following this is the requirements returned from FsVgaQueryAperture. These
    // get marked as alternatives.
    //
    if (OldRequirements) {
        NewSize = OldRequirements->ListSize +
              ApertureRequirements->Count * OldRequirements->AlternativeLists * sizeof(IO_RESOURCE_DESCRIPTOR);
    }
    else {
        NewSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
              (ApertureRequirements->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
    }

    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        status = STATUS_UNSUCCESSFUL;
        errorCode = FSVGA_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = FSVGA_ERROR_VALUE_BASE + 2;
        dumpData[0] = 0;
        dumpCount = 1;
        goto FsVgaFilterResourceRequirementsExit;
    }

    RtlZeroMemory(NewRequirements, NewSize);

    NewRequirements->ListSize         = NewSize;
    if (OldRequirements) {
        NewRequirements->InterfaceType    = OldRequirements->InterfaceType;
        NewRequirements->BusNumber        = OldRequirements->BusNumber;
        NewRequirements->SlotNumber       = OldRequirements->SlotNumber;
        NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;
    }
    else {
        NewRequirements->InterfaceType    = Globals.Resource.InterfaceType;
        NewRequirements->BusNumber        = Globals.Resource.BusNumber;
        NewRequirements->SlotNumber       = 0;
        NewRequirements->AlternativeLists = 1;
    }

    //
    // Append our requirement to each alternative resource list.
    //
    if (OldRequirements) {
        PIO_RESOURCE_LIST OldResourceList;
        PIO_RESOURCE_LIST NewResourceList;
        ULONG Alternative;

        OldResourceList = &OldRequirements->List[0];
        NewResourceList = &NewRequirements->List[0];

        for (Alternative = 0; Alternative < OldRequirements->AlternativeLists; Alternative++) {
            PIO_RESOURCE_DESCRIPTOR Descriptor;
            ULONG i;

            //
            // Copy the old resource list into the new one.
            //
            NewResourceList->Version  = OldResourceList->Version;
            NewResourceList->Revision = OldResourceList->Revision;
            NewResourceList->Count    = OldResourceList->Count + ApertureRequirements->Count;
            RtlCopyMemory(&NewResourceList->Descriptors[0],
                          &OldResourceList->Descriptors[0],
                          OldResourceList->Count * sizeof(IO_RESOURCE_DESCRIPTOR));

            Descriptor = &NewResourceList->Descriptors[OldResourceList->Count];

            //
            // Append the alternatives
            //
            for (i = 0; i < ApertureRequirements->Count; i++) {
                //
                // Make sure this descriptor makes sense
                //
                ASSERT(ApertureRequirements->Descriptors[i].Flags == (CM_RESOURCE_PORT_IO));
                ASSERT(ApertureRequirements->Descriptors[i].Type  == CmResourceTypePort);
                ASSERT(ApertureRequirements->Descriptors[i].ShareDisposition == CmResourceShareShared);

                *Descriptor = ApertureRequirements->Descriptors[i];
                Descriptor->Option = IO_RESOURCE_ALTERNATIVE;

                ++Descriptor;
            }

            //
            // Advance to next resource list
            //
            NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors + NewResourceList->Count);
            OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors + OldResourceList->Count);
        }
    }
    else {
        PIO_RESOURCE_LIST NewResourceList;

        NewResourceList = &NewRequirements->List[0];
        NewResourceList->Version  = 1;
        NewResourceList->Revision = 1;
        NewResourceList->Count    = ApertureRequirements->Count;

        RtlCopyMemory(&NewResourceList->Descriptors[0],
                      &ApertureRequirements->Descriptors[0],
                      ApertureRequirements->Count * sizeof(IO_RESOURCE_DESCRIPTOR));
    }

    stack->Parameters.FilterResourceRequirements.IoResourceRequirementList = NewRequirements;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;

FsVgaFilterResourceRequirementsExit:

    if (errorCode != STATUS_SUCCESS)
    {
        //
        // Log an error/warning message.
        //
        FsVgaLogError(fdo,
                      errorCode,
                      uniqueErrorValue,
                      status,
                      dumpData,
                      dumpCount
                     );
    }

    if (NT_SUCCESS(status)) {
        status = FsVgaDefaultPnpHandler(fdo, Irp);
    }
    else {
        status = CompleteRequest(Irp, status, 0);
    }

    if (OldRequirements)
        ExFreePool(OldRequirements);
    if (ApertureRequirements)
        ExFreePool(ApertureRequirements);

    FsVgaPrint((2,"FSVGA-FsVgaFilterResourceRequirements: exit (status=%x)\n", status));

    return status;
}
#endif


NTSTATUS
FsVgaDevicePower(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine uses the IRP's minor function code to dispatch a handler
    function (such as HandleSetPower for IRP_MN_SET_POWER). It calls DefaultPowerHandler
    for any function we don't specifically need to handle.

++*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION stack;

    if (!LockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension)) {
        return CompleteRequest(Irp, STATUS_DELETE_PENDING, 0);
    }

    stack = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(stack->MajorFunction = IRP_MJ_POWER);

    switch (stack->MinorFunction) {
        default:
            status = FsVgaDefaultPowerHandler(fdo, Irp);
            break;
    }

    UnlockDevice((PDEVICE_EXTENSION)fdo->DeviceExtension);
    return status;
}

NTSTATUS 
FsVgaDefaultPowerHandler(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function forwards a POWER IRP to the next driver using the
    special PoCallDriver function

++*/

{
    PDEVICE_EXTENSION pdx;

    FsVgaPrint((2,"FSVGA-FsVgaDefaultPowerHandler: enter\n"));

    PoStartNextPowerIrp(Irp);        // must be done while we own the IRP
    IoSkipCurrentIrpStackLocation(Irp);
    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    FsVgaPrint((2,"FSVGA-FsVgaDefaultPowerHandler: exit\n"));

    return PoCallDriver(pdx->LowerDeviceObject, Irp);
}

NTSTATUS
CompleteRequest(
    IN PIRP Irp,
    IN NTSTATUS status,
    IN ULONG info
    )

/*++

Routine Description:

++*/

{
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = info;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
ForwardAndWait(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp
    )

/*++

Routine Description:

    The processor must be at PASSIVE IRQL because this function initializes
    and waits for non-zero time on a kernel event object.
    The only purpose of this routine in this particular driver is to pass down
    IRP_MN_START_DEVICE requests and wait for the PDO to handle them.

++*/

{
    KEVENT event;
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // Initialize a kernel event object to use in waiting for the lower-level
    // driver to finish processing the object. It's a little known fact that the
    // kernel stack *can* be paged, but only while someone is waiting in user mode
    // for an event to finish. Since neither we nor a completion routine can be in
    // the forbidden state, it's okay to put the event object on the stack.

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, (PIO_COMPLETION_ROUTINE)OnRequestComplete,
                           (PVOID)&event, TRUE, TRUE, TRUE);

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    status = IoCallDriver(pdx->LowerDeviceObject, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
OnRequestComplete(
    IN PDEVICE_OBJECT fdo,
    IN PIRP Irp,
    IN PKEVENT pev
    )

/*++

Routine Description:

    This is the completion routine used for requests forwarded by ForwardAndWait. It
    sets the event object and thereby awakens ForwardAndWait.
    Note that it's *not* necessary for this particular completion routine to test
    the PendingReturned flag in the IRP and then call IoMarkIrpPending. You do that in many
    completion routines because the dispatch routine can't know soon enough that the
    lower layer has returned STATUS_PENDING. In our case, we're never going to pass a
    STATUS_PENDING back up the driver chain, so we don't need to worry about this.

++*/

{
    KeSetEvent(pev, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
RemoveDevice(
    IN PDEVICE_OBJECT fdo
    )

/*++

Routine Description:

    Whereas AddDevice gets called by the I/O manager directly, this
    function is called in response to a PnP request with the minor function code
    of IRP_MN_REMOVE_DEVICE.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;
    if (pdx->LowerDeviceObject) {
        IoDetachDevice(pdx->LowerDeviceObject);
    }

    IoDeleteDevice(fdo);
}

BOOLEAN
LockDevice(
    IN PDEVICE_EXTENSION pdx
    )

/*++

Routine Description:

    A FALSE return value indicates that we're in the process of deleting
    the device object, so all new requests should be failed

++*/

{
    LONG usage;

    //
    // Increment use count on our device object
    //
    usage = InterlockedIncrement(&pdx->usage);

    //
    // AddDevice initialized the use count to 1, so it ought to be bigger than
    // one now. HandleRemoveDevice sets the "removing" flag and decrements the
    // use count, possibly to zero. So if we find a use count of "1" now, we
    // should also find the "removing" flag set.
    //
    ASSERT(usage > 1 || pdx->removing);

    //
    // If device is about to be removed, restore the use count and return FALSE.
    // If we're in a race with HandleRemoveDevice (maybe running on another CPU),
    // the sequence we've followed is guaranteed to avoid a mistaken deletion of
    // the device object. If we test "removing" after HandleRemoveDevice sets it,
    // we'll restore the use count and return FALSE. In the meantime, if
    // HandleRemoveDevice decremented the count to 0 before we did our increment,
    // its thread will have set the remove event. Otherwise, we'll decrement to 0
    // and set the event. Either way, HandleRemoveDevice will wake up to finish
    // removing the device, and we'll return FALSE to our caller.
    //
    // If, on the other hand, we test "removing" before HandleRemoveDevice sets it,
    // we'll have already incremented the use count past 1 and will return TRUE.
    // Our caller will eventually call UnlockDevice, which will decrement the use
    // count and might set the event HandleRemoveDevice is waiting on at that point.
    //
    if (pdx->removing) {
        if (InterlockedDecrement(&pdx->usage) == 0) {
                KeSetEvent(&pdx->evRemove, 0, FALSE);
        }
        return FALSE;
    }

    return TRUE;
}

VOID
UnlockDevice(
    IN PDEVICE_EXTENSION pdx
    )

/*++

Routine Description:

    If the use count drops to zero, set the evRemove event because we're
    about to remove this device object.

++*/

{
    LONG usage;

    usage = InterlockedDecrement(&pdx->usage);
    ASSERT(usage >= 0);
    if (usage == 0) {
        ASSERT(pdx->removing);    // HandleRemoveDevice should already have set this
        KeSetEvent(&pdx->evRemove, 0, FALSE);
    }
}

NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT fdo,
    IN PCM_PARTIAL_RESOURCE_LIST list
    )

/*++

Routine Description:

    This function is called by the dispatch routine for IRP_MN_START_DEVICE
    in order to determine the configuration for the device and to prepare the driver
    and the device for subsequent operation.

++*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION pdx;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    ULONG i;

    FsVgaPrint((2,"FSVGA-StartDevice: enter\n"));

    pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    ASSERT(!pdx->started);

    RtlZeroMemory(&pdx->Resource.PortList, sizeof(pdx->Resource.PortList));

    // Identify the I/O resources we're supposed to use. In previous versions
    // of NT, this required nearly heroic efforts that were highly bus dependent.

    resource = list->PartialDescriptors;

    for (i = 0; i < list->Count; ++i, ++resource) {
        ULONG port;

        switch (resource->Type) {
            case CmResourceTypePort:
                switch (resource->u.Port.Start.QuadPart) {
                    case VGA_BASE_IO_PORT + CRTC_ADDRESS_PORT_COLOR:
                        port = CRTCAddressPortColor; break;
                    case VGA_BASE_IO_PORT + CRTC_DATA_PORT_COLOR:
                        port = CRTCDataPortColor;    break;
                    case VGA_BASE_IO_PORT + GRAPH_ADDRESS_PORT:
                        port = GRAPHAddressPort;     break;
                    case  VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT:
                        port = SEQAddressPort;       break;
                    default:
                        port = -1;
                        FsVgaPrint((1,"FSVGA-StartDevice: CmResourceTypePort: Unknown port address %x\n", resource->u.Port.Start.LowPart));
                        break;
                }
                if (port != -1) {
                    if (resource->Flags & CM_RESOURCE_PORT_IO) {
                        pdx->Resource.PortList[port].Port =
                            (PUCHAR)resource->u.Port.Start.LowPart;
                        pdx->Resource.PortList[port].MapRegistersRequired = FALSE;
                    }
                    else {
                        pdx->Resource.PortList[port].Port =
                            (PUCHAR)MmMapIoSpace(resource->u.Port.Start,
                                                 resource->u.Port.Length,
                                                 MmNonCached);
                        pdx->Resource.PortList[port].Length = resource->u.Port.Length;
                        pdx->Resource.PortList[port].MapRegistersRequired = TRUE;
                    }
                }
                break;
            default:
                FsVgaPrint((1,"FSVGA-StartDevice: Unknown resource type %x\n", resource->Type));
                break;
        }
    }

    pdx->started = TRUE;

    FsVgaPrint((2,"FSVGA-StartDevice: exit\n"));

    return STATUS_SUCCESS;
}

VOID
StopDevice(
    IN PDEVICE_OBJECT fdo
    )

/*++

Routine Description:

    This function is called by the dispatch routine for IRP_MN_STOP_DEVICE
    in order to undo everything that was done inside StartDevice.

++*/

{
    ULONG i;
    PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)fdo->DeviceExtension;

    if (!pdx->started)
        return;

    pdx->started = FALSE;

    for (i=0; i < MaximumPortCount; i++) {
        if (pdx->Resource.PortList[i].MapRegistersRequired) {
            MmUnmapIoSpace(pdx->Resource.PortList[i].Port,
                           pdx->Resource.PortList[i].Length);
        }
    }
}

#if DBG

// @func List PnP resources assigned to our device
// @parm List of resource descriptors to display
// @comm Used only in the checked build of the driver

#define arraysize(p) (sizeof(p)/sizeof((p)[0]))

VOID ShowResources(IN PCM_PARTIAL_RESOURCE_LIST list)
        {                                                       // ShowResources
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
        ULONG nres;
        ULONG i;

        if (list == NULL)
            return;

        resource = list->PartialDescriptors;
        if (resource == NULL)
            return;

        nres = list->Count;

        for (i = 0; i < nres; ++i, ++resource)
                {                                               // for each resource
                ULONG type = resource->Type;

                static char* name[] = {
                        "CmResourceTypeNull",
                        "CmResourceTypePort",
                        "CmResourceTypeInterrupt",
                        "CmResourceTypeMemory",
                        "CmResourceTypeDma",
                        "CmResourceTypeDeviceSpecific",
                        "CmResourceTypeBusNumber",
                        "CmResourceTypeDevicePrivate",
                        "CmResourceTypeAssignedResource",
                        "CmResourceTypeSubAllocateFrom",
                        };

                KdPrint(("    type %s", type < arraysize(name) ? name[type] : "unknown"));

                switch (type)
                        {                                       // select on resource type
                case CmResourceTypePort:
                case CmResourceTypeMemory:
                        KdPrint((" start %8X%8.8lX length %X\n",
                                resource->u.Port.Start.HighPart, resource->u.Port.Start.LowPart,
                                resource->u.Port.Length));
                        break;

                case CmResourceTypeInterrupt:
                        KdPrint(("  level %X, vector %X, affinity %X\n",
                                resource->u.Interrupt.Level, resource->u.Interrupt.Vector,
                                resource->u.Interrupt.Affinity));
                        break;

                case CmResourceTypeDma:
                        KdPrint(("  channel %d, port %X\n",
                                resource->u.Dma.Channel, resource->u.Dma.Port));
                        }                                       // select on resource type
                }                                               // for each resource
        }                                                       // ShowResources

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsconins\fsconins.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      fsconins.cpp
 *
 *  Abstract:
 *
 *      This file contain FsConInstall class
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#define _FSCONINS_CPP_
#include <stdlib.h>
#include "oc.h"
#include "fsconins.h"

#include <initguid.h>
#include <devguid.h>
#include <cfgmgr32.h>
#pragma hdrstop


FsConInstall::FsConInstall()
{
    m_cd = NULL;
}

FsConInstall::FsConInstall(
    IN PPER_COMPONENT_DATA cd
    )
{
    m_cd = cd;
}

BOOL
FsConInstall::GUIModeSetupInstall(
    IN HWND hwndParent
)

/*++

Routine Description:

    This is the single entry point for Full Screen Console Driver
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for FSVGA/FSNEC to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/

{
    HINSTANCE hndl = NULL;

    //
    // Create the deviceinfo list.
    //
    HDEVINFO devInfoSet;

    devInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_DISPLAY, hwndParent);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Get the "offical" display class name.
    //
    SP_DEVINFO_DATA deviceInfoData;
    TCHAR className[MAX_CLASS_NAME_LEN];

    ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (! SetupDiClassNameFromGuid(&GUID_DEVCLASS_DISPLAY,
                                   className,
                                   sizeof(className)/sizeof(TCHAR),
                                   NULL)) {
        return FALSE;
    }

    //
    // Create the dev node.
    //
    if (! SetupDiCreateDeviceInfo(devInfoSet,
                                  TEXT("Root\\DISPLAY\\0000"),
                                  &GUID_DEVCLASS_DISPLAY,
                                  NULL,
                                  hwndParent,
                                  NULL,              // No flags.
                                  &deviceInfoData)) {
        // If it already exists, then we are done ... because this was an upgrade.
        if (GetLastError() == ERROR_DEVINST_ALREADY_EXISTS) {
            return TRUE;
        }
        else {
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return FALSE;
        }
    }
    else if (! SetupDiSetSelectedDevice(devInfoSet,
                                        &deviceInfoData)) {
        goto InstallError;
    }

    //
    // Add the FSVGA/FSNEC PnP ID.
    //

    // Create the PnP ID string.
    TCHAR pnpID[256];
    DWORD len;

    len = GetPnPID(pnpID, sizeof(pnpID)/sizeof(TCHAR));
    if (len == 0) {
        goto InstallError;
    }

    // Add it to the registry entry for the dev node.
    if (! SetupDiSetDeviceRegistryProperty(devInfoSet,
                                           &deviceInfoData,
                                           SPDRP_HARDWAREID,
                                           (CONST BYTE*)pnpID,
                                           (len + 1) * sizeof(TCHAR))) {
        goto InstallError;
    }

    //
    // Register the, as of yet, phantom dev node with PnP to turn it into a real dev node.
    //
    if (! SetupDiRegisterDeviceInfo(devInfoSet,
                                    &deviceInfoData,
                                    0,
                                    NULL,
                                    NULL,
                                    NULL)) {
        goto InstallError;
    }

    //
    // Get the device instance ID.
    //
    TCHAR devInstanceID[MAX_PATH];

    if (! SetupDiGetDeviceInstanceId(devInfoSet,
                                     &deviceInfoData,
                                     devInstanceID,
                                     sizeof(devInstanceID)/sizeof(TCHAR),
                                     NULL)) {
        goto InstallError;
    }

    //
    // Use newdev.dll to install FSVGA/FSNEC as the driver for this new dev node.
    //
    hndl = LoadLibrary(TEXT("newdev.dll"));
    if (hndl == NULL) {
        goto InstallError;
    }

    typedef BOOL (InstallDevInstFuncType)(
                        HWND hwndParent,
                        LPCWSTR DeviceInstanceId,
                        BOOL UpdateDriver,
                        PDWORD pReboot,
                        BOOL silentInstall);
    InstallDevInstFuncType *pInstallDevInst;

    pInstallDevInst = (InstallDevInstFuncType*)GetProcAddress(hndl, "InstallDevInstEx");
    if (pInstallDevInst == NULL) {
        goto InstallError;
    }

    if ((*pInstallDevInst)(hwndParent,
                           devInstanceID,
                           FALSE,
                           NULL,
                           TRUE)) {
        // Clean up and return success!
        SetupDiDestroyDeviceInfoList(devInfoSet);
        FreeLibrary(hndl);
        return TRUE;
    }

InstallError:
    SetupDiCallClassInstaller(DIF_REMOVE,
                              devInfoSet,
                              &deviceInfoData);
    SetupDiDestroyDeviceInfoList(devInfoSet);
    if (hndl != NULL) {
        FreeLibrary(hndl);
    }
    return FALSE;
}

BOOL
FsConInstall::GUIModeSetupUninstall(
    IN HWND hwndParent
)

/*++

Routine Description:

    This is the single entry point for Full Screen Console Driver
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that FSVGA/FSNEC can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/

{
    //
    // Get the set of all devices with the FSVGA/FSNEC PnP ID.
    //
    HDEVINFO devInfoSet;
    GUID *pGuid = (GUID*)&GUID_DEVCLASS_DISPLAY;

    devInfoSet = SetupDiGetClassDevs(pGuid,
                                     NULL,
                                     hwndParent,
                                     DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Get FSVGA/FSNEC PnPID
    TCHAR FsConPnPID[256];
    DWORD len;

    len = GetPnPID(FsConPnPID, sizeof(FsConPnPID)/sizeof(TCHAR));
    if (len == 0) {
        return FALSE;
    }

    // Assume that we will be successful.
    BOOL result = TRUE;

    // Get the first device.
    DWORD iLoop = 0;
    BOOL bMoreDevices;
    SP_DEVINFO_DATA deviceInfoData;

    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    //
    // Get the details for all matching device interfaces.
    //
    while (bMoreDevices = SetupDiEnumDeviceInfo(devInfoSet,
                                                iLoop++,
                                                &deviceInfoData)) {
        //
        // Get the PnP ID for the device.
        //
        TCHAR pnpID[256];

        if (SetupDiGetDeviceRegistryProperty(devInfoSet,
                                             &deviceInfoData,
                                             SPDRP_HARDWAREID,
                                             NULL,
                                             (BYTE*)pnpID,
                                             sizeof(pnpID),
                                             NULL)) {
            // If the current device matchs FSVGA/FSNEC, then remove it.
            if (! _tcscmp(pnpID, FsConPnPID)) {
                if (! SetupDiCallClassInstaller(DIF_REMOVE,
                                                devInfoSet,
                                                &deviceInfoData)) {
                    // If we failed here, set the return status to indicate failure,
                    // but don't give up on any other FSVGA/FSNEC dev nodes.
                    result = FALSE;
                }
            }
        }
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return result;
}

DWORD
FsConInstall::GetPnPID(
    OUT LPTSTR pszPnPID,
    IN  DWORD  dwSize
)
{
    INFCONTEXT context;

    if (! SetupFindFirstLine(m_cd->hinf,
                             TEXT("Manufacturer"),    // Section
                             NULL,                    // Key
                             &context)) {
        return 0;
    }

    TCHAR Manufacture[256];
    DWORD nSize;

    if (! SetupGetStringField(&context,
                              1,                      // Index
                              Manufacture,
                              sizeof(Manufacture)/sizeof(TCHAR),
                              &nSize)) {
        return 0;
    }

    if (! SetupFindFirstLine(m_cd->hinf,
                             Manufacture,             // Section
                             NULL,                    // Key
                             &context)) {
        return 0;
    }

    if (! SetupGetStringField(&context,
                              2,                      // Index 2 is PnP-ID
                              pszPnPID,
                              dwSize,
                              &nSize)) {
        return 0;
    }

    return _tcslen(pszPnPID);
}

BOOL
FsConInstall::InfSectionRegistryAndFiles(
    IN LPCTSTR SubcomponentId,
    IN LPCTSTR Key
    )
{
    INFCONTEXT context;
    TCHAR      section[256];
    BOOL       rc;

    rc = SetupFindFirstLine(m_cd->hinf,
                            SubcomponentId,
                            Key,
                            &context);
    if (rc) {
        rc = SetupGetStringField(&context,
                                 1,
                                 section,
                                 sizeof(section)/sizeof(TCHAR),
                                 NULL);
        if (rc) {
            rc = SetupInstallFromInfSection(NULL,            // hwndOwner
                                            m_cd->hinf,      // inf handle
                                            section,         //
                                            SPINST_ALL & ~SPINST_FILES,
                                                             // operation flags
                                            NULL,            // relative key root
                                            NULL,            // source root path
                                            0,               // copy flags
                                            NULL,            // callback routine
                                            NULL,            // callback routine context
                                            NULL,            // device info set
                                            NULL);           // device info struct
        }
    }

    return rc;
}


// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
FsConInstall::QueryStateInfo(
    LPCTSTR SubcomponentId
    )
{
    return m_cd->HelperRoutines.QuerySelectionState(m_cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\sources.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

SYNCHRONIZE_BLOCK=1

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsconins\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for fsvgains.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsconins\oc.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      oc.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OC_CPP_
#include <stdlib.h>
#include "oc.h"
#include "fsconins.h"

#pragma hdrstop


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    UNREFERENCED_PARAMETER(reserved);

    if (reason == DLL_PROCESS_ATTACH) {
        ghinst = hinstance;
    }

    return TRUE;
}


DWORD_PTR
FsConInstallProc(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OCFLAG_UNICODE;
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUERY_STEP_COUNT:
        rc = 0;
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_QUERY_STATE:
        rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/



/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD
OnInitComponent(
    LPCTSTR ComponentId,
    PSETUP_INIT_COMPONENT psc
    )
{
    PPER_COMPONENT_DATA cd;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

    // add component to linked list

    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle

    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf

    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags

    cd->HelperRoutines = psc->HelperRoutines;

    cd->Flags = psc->SetupData.OperationFlags;

    cd->SourcePath = NULL;

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD
OnExtraRoutines(
    LPCTSTR ComponentId,
    PEXTRA_ROUTINES per
    )
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD
OnQuerySelStateChange(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state,
    UINT    flags
    )
{
    return TRUE;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD
OnCalcDiskSpace(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    DWORD   addComponent,
    HDSKSPC dspace
    )
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    _tcsncpy(section, SubcomponentId, S_SIZE - 1);
    section[S_SIZE - 1] = L'\0';

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD
OnCompleteInstallation(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId
    )
{
    PPER_COMPONENT_DATA cd;
    BOOL                rc;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    rc = TRUE;

    FsConInstall* pFsCon = new FsConInstall(cd);
    if (pFsCon == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (pFsCon->QueryStateInfo(SubcomponentId)) {
        //
        // installation
        //
        rc = pFsCon->GUIModeSetupInstall();
    }
    else {
        //
        // uninstallation
        //
        rc = pFsCon->GUIModeSetupUninstall();
        //
        // Remove any registry settings and files by Uninstall section on OC INF file.
        //
        if (rc) {
            rc = pFsCon->InfSectionRegistryAndFiles(SubcomponentId, TEXT("Uninstall"));
        }
    }

    delete pFsCon;

    if (rc) {
        return NO_ERROR;
    }
    else {
        return GetLastError();
    }
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD
OnQueryState(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state
    )
{
    return SubcompUseOcManagerDefault;
}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA
AddNewComponent(
    LPCTSTR ComponentId
    )
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        _tcscpy((TCHAR *)data->ComponentId, ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA
LocateComponent(
    LPCTSTR ComponentId
    )
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\makefile.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

STAMP=stampinf -f $@

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
_INF=obj\$(TARGET_DIRECTORY)


make_infs:$(_INF)\fsvga.inf    \
          $(_INF)\fsvgaadd.inf \
          $(_INF)\fsvgadel.inf

$(_INF)\fsvga.inf: $(_INX)\fsvga.inx $(_LNG)\fsvga.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\fsvgaadd.inf: $(_INX)\fsvgaadd.inf
    copy $(_INX)\$(@B).inf $@
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\fsvgadel.inf: $(_INX)\fsvgadel.inf
    copy $(_INX)\$(@B).inf $@
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\chsinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\fsconins\oc.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      oc.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Kazuhiko Matsubara (kazum) June-16-1999
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OC_H_
 #error "oc.h already included!"
#else
 #define _OC_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA* Next;
    LPCTSTR                     ComponentId;
    HINF                        hinf;
    DWORDLONG                   Flags;
    TCHAR*                      SourcePath;
    OCMANAGER_ROUTINES          HelperRoutines;
    EXTRA_ROUTINES              ExtraRoutines;
    HSPFILEQ                    queue;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

//
// oc.cpp
//

DWORD
OnInitComponent(
    LPCTSTR ComponentId,
    PSETUP_INIT_COMPONENT psc
    );

DWORD
OnQuerySelStateChange(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT    state,
    UINT    flags
    );

DWORD
OnCalcDiskSpace(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    DWORD addComponent,
    HDSKSPC dspace
    );

DWORD
OnCompleteInstallation(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId
    );

DWORD
OnQueryState(
    LPCTSTR ComponentId,
    LPCTSTR SubcomponentId,
    UINT state
    );

DWORD
OnExtraRoutines(
    LPCTSTR ComponentId,
    PEXTRA_ROUTINES per
    );

PPER_COMPONENT_DATA
AddNewComponent(
    LPCTSTR ComponentId
    );

PPER_COMPONENT_DATA
LocateComponent(
    LPCTSTR ComponentId
    );

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR SubcomponentId,
    BOOL *state
    );

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif



/*-[ global data ]-----------------------------------------*/

#ifndef _OC_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\jpninf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\chtinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\gerinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\korinf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 2000 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\fsvga\inf\daytona\usainf\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration
//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"headlessd"          // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "HEADLESS: "    // All debug output is prefixed
                                                //   by this string
#define ALLOC_TAG               'rgvD'          // Dvgr	//	Hdls
                                                // Four byte tag (characters in
                                                // reverse order) used for
                                                // memory allocations

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    SURFOBJ*    pso;                    // DIB copy of our surface to which we
                                        //   have GDI draw everything

} PDEV, *PPDEV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>

#include "driver.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\mini\headdata.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headdata.c

Abstract:

    This module contains all the global data used by the headless driver.

Environment:

    Kernel mode

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//
// Video mode table - contains information and commands for initializing each
// mode.
//

VIDEOMODE ModesHeadless[] = {

{
    640, 480
},

{
    800, 600
},

{
    1024, 768
}

};

ULONG NumVideoModes = sizeof(ModesHeadless) / sizeof(VIDEOMODE);

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* The initialization guts of the Headless driver.
*
* The drawing guts of a portable Headless driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended for decent
*               driver performance.
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

static DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               }
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

GDIINFO ggdiDefault = {
     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     4,                     // cBitsPixel
     1,                     // cPlanes
     16,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE,            // flTextCaps

     6,                     // ulDACRed
     6,                     // ulDACGree
     6,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     0,                     // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_4BPP_IRGB,                       // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     1,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault =
{
    (GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER), // Graphics capabilities
    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_4BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};

/******************************Public*Data*Struct*************************\
* VGALOGPALETTE logPalVGA
*
* This is the palette for the VGA.
*
\**************************************************************************/

typedef struct _VGALOGPALETTE
{
    USHORT          ident;
    USHORT          NumEntries;
    PALETTEENTRY    palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{
	0x500,  // Driver version
    16,     // Number of entries
    {
        { 0,   0,   0,   0 },       // 0
        { 0x80,0,   0,   0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0x80,0x80,0,   0 },       // 3
        { 0,   0,   0x80,0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0x80,0x80,0 },       // 6
        { 0x80,0x80,0x80,0 },       // 7

        { 0xC0,0xC0,0xC0,0 },       // 8
        { 0xFF,0,   0,   0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0xFF,0xFF,0,   0 },       // 11
        { 0,   0,   0xFF,0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0,   0xFF,0xFF,0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    DWORD status;

    //
    // Get the number of modes supported by the mini-port
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem"));
        return(0);
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    return(modes.NumModes);
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    // Fill in the GDIINFO data structure with the default 4bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 4bpp values:

    *pdi = gdevinfoDefault;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    HPALETTE    hpal;

    hpal = EngCreatePalette(PAL_INDEXED, 16, (ULONG*) (logPalVGA.palPalEntry),
                            0, 0, 0);

    if (hpal == 0)
        goto ReturnFalse;

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurfShadow;
    SIZEL   sizl;
    DWORD status;
    ULONG ulTemp;

    ppdev = (PDEV*) dhpdev;

    // Create the 4bpp DIB on which we'll have GDI do all the drawing.
    // We'll merely occasionally blt portions to the screen to update.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfShadow = (HSURF) EngCreateBitmap(sizl, 0, BMF_4BPP, 0, NULL);
    if (hsurfShadow == 0)
        goto ReturnFailure;

    if (!EngAssociateSurface(hsurfShadow, ppdev->hdevEng, 0))
    {
        DISPDBG((0, "DrvEnableSurface - Failed second EngAssociateSurface"));
        goto ReturnFailure;
    }

    ppdev->pso = EngLockSurface(hsurfShadow);
    if (ppdev->pso == NULL)
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    DISPDBG((5, "Passed DrvEnableSurface"));

    return hsurfShadow;

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    DWORD status;
    ULONG ulTemp;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    hsurf = ppdev->pso->hsurf;
    EngUnlockSurface(ppdev->pso);
    EngDeleteSurface(hsurf);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    return TRUE;
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\5465bw.c ===
/**********************************************************
* Copyright Cirrus Logic, 1997. All rights reserved.
***********************************************************
*
*  5465BW.C - Bandwidth functions for CL-GD5465
*
***********************************************************
*
*  Author: Rick Tillery
*  Date:   03/20/97
*
*  Revision History:
*  -----------------
*  WHO             WHEN            WHAT/WHY/HOW
*  ---             ----            ------------
*
***********************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#else

#ifndef WINNT_VER40
#include "5465BW.h"
#endif

/**********************************************************
*
* ScaleMultiply()
*
* Calculates product of two DWORD factors supplied.  If the
*  result would overflow a DWORD, the larger of the two factors
*  is divided by 2 (shifted right) until the overflow will
*  not occur.
*
* Returns: Number of right shifts applied to the product.
*          Product of the factors shifted by the value above.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
static int ScaleMultiply(DWORD   dw1,
                         DWORD   dw2,
                         LPDWORD pdwResult)
{
  int   iShift = 0;   // Start with no shifts
  DWORD dwLimit;

//  ODS("ScaleMultiply() called.\n");

  // Either factor 0 will be a zero result and also cause a problem
  //  in our divide below.
  if((0 == dw1) || (0 == dw2))
  {
    *pdwResult = 0;
  }
  else
  {
    // Determine which factor is larger
    if(dw1 > dw2)
    {
      // Determine largest number by with dw2 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw2;
      // Shift dw1, keeping track of how many times, until it won't
      //  overflow when multiplied by dw2.
      while(dw1 > dwLimit)
      {
        dw1 >>= 1;
        iShift++;
      }
    }
    else
    {
      // Determine largest number by with dw1 can be multiplied without
      //  overflowing a DWORD.
      dwLimit = 0xFFFFFFFFul / dw1;
      // Shift dw2, keeping track of how many times, until it won't
      //  overflow when multiplied by dw1.
      while(dw2 > dwLimit)
      {
        dw2 >>= 1;
        iShift++;
      }
    }
    // Calculate (scaled) product
    *pdwResult = dw1 * dw2;
  }
  // Return the number of shifts we had to use
  return(iShift);
}

/**********************************************************
*
* ChipCalcMCLK()
*
* Determines currently set memory clock (MCLK) based on
*  register values provided.
*
* Returns: Success and current MCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/21/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcMCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwMCLK)
{
  BOOL  fSuccess = FALSE;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL / 4) : REF_XTAL;

  ODS("ChipCalcMCLK() called.\n");

  *pdwMCLK = (dwRefXtal * (DWORD)pBWRegs->BCLK_Mult) >> 2;

  ODS("ChipCalcMCLK(): MCLK = %ld\n", *pdwMCLK);

  if(0 == *pdwMCLK)
  {
    ODS("ChipCalcMCLK(): Calculated invalid MCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipCalcVCLK()
*
* Determines currently set pixel clock (VCLK) based on
*  register values provided.
*
* Returns: Success and current VCLK in Hz.
*
***********************************************************
* Author: Rick Tillery
* Date:   11/18/95
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipCalcVCLK(LPBWREGS pBWRegs,
                  LPDWORD  pdwVCLK)
{
  BOOL fSuccess = FALSE;
  BYTE bNum, bDenom;
  int  iShift;
  // We make the assumption that if the BCLK_Denom /4 is set, the reference
  //  xtal is 27MHz.  If it is not set, we assume the ref xtal is 14.31818MHz.
  //  This means that 1/2 the 27MHz (13.5MHz) should not be used.
  //  Add 20000000ul to increas Bandwidth.
  DWORD dwRefXtal = (pBWRegs->BCLK_Denom & 0x02) ? (TVO_XTAL + 2000000ul)  : REF_XTAL;

  ODS("ChipCalcVCLK() called dwRef= %ld\n",dwRefXtal);

  if(pBWRegs->VCLK3Num & 0x80)
  {
    fSuccess = ChipCalcMCLK(pBWRegs, pdwVCLK);
    goto Error;
  }

  /*
   * VCLK is normally based on one of 4 sets of numerator and
   *  denominator pairs.  However, the CL-GD5465 can only access
   *  VCLK 3 through the MMI/O.
   */
  if((pBWRegs->MISCOutput & 0x0C) != 0x0C)
  {
    ODS("ChipCalcVCLK(): VCLK %d in use.  MMI/O can only access VCLK 3.\n",
        (int)((pBWRegs->MISCOutput & 0x0C) >> 2));
//    goto Error;
  }

  bNum = pBWRegs->VCLK3Num & 0x7F;
  bDenom = (pBWRegs->VCLK3Denom & 0xFE) >> 1;

  if(pBWRegs->VCLK3Denom & 0x01)
  {
    // Apply post scalar
    bDenom <<= 1;
  }

  if(0 == bDenom)
  {
    ODS("ChipCalcVCLK(): Invalid VCLK denominator (0).\n");
    goto Error;
  }

  // Calculate actual VCLK frequency (Hz)
  iShift = ScaleMultiply(dwRefXtal, (DWORD)bNum, pdwVCLK);
  *pdwVCLK /= (DWORD)bDenom;
  *pdwVCLK >>= iShift;


  //Check PLL output Frequency  
  iShift = ( pBWRegs->GfVdFormat >> 14 );
  *pdwVCLK >>= iShift;

  ODS("ChipCalcVCLK(): VCLK = %ld\n", *pdwVCLK);

  if(0 == *pdwVCLK)
  {
    ODS("ChipCalcVCLK(): Calculated invalid VCLK (0).\n");
    goto Error;
  }

  fSuccess = TRUE;
Error:
  return(fSuccess);
}


/**********************************************************
*
* ChipIsEnoughBandwidth()
*
* Determines whether their is enough bandwidth for the video
*  configuration specified in the VIDCONFIG structure with
*  the system configuration specified in the BWREGS structure
*  and returns the values that need to be programmed into the
*  bandwidth related registers.  The pProgRegs parameter
*  may be NULL to allow checking a configuration only.  This
*  function gets the register values and passes them to
*  ChipCheckBW() to check the bandwidth.
*  
*
* Returns: BOOLean indicating whether there is sufficient
*           bandwidth for the configuration specified.
*          Values to program into bandwidth related registers
*           if the pProgRegs parameter is not NULL.
*
***********************************************************
* Author: Rick Tillery
* Date:   03/20/97
*
* Revision History:
* -----------------
* WHO WHEN     WHAT/WHY/HOW
* --- ----     ------------
*********************************************************/
BOOL ChipIsEnoughBandwidth(LPPROGREGS  pProgRegs,
                           LPVIDCONFIG pConfig,
                           LPBWREGS    pBWRegs )
{
  BOOL   fSuccess = FALSE;
  DWORD  dwMCLK, dwVCLK;
  DWORD dwDenom;
  int iNumShift, iDenomShift;
  DWORD dwGfxFetch, dwBLTFetch;
  DWORD dwGfxFill, dwBLTFill;
  DWORD dwMaxGfxThresh, dwMinGfxThresh;
  DWORD dwMaxVidThresh, dwMinVidThresh;
  DWORD dwHitLatency, dwRandom;
  BOOL  f500MHZ,fConCurrent;  
  DWORD dwTemp;
  BOOL  f585MHZ = TRUE;  			//PDR#11521

// There are some modes that have the same bandwidth parameters
//  like MCLK, VCLK, but have different dwScreenWidht. The bandwidth
//  related register settings have major differences for these mode.
//  For this reason, dwScreenWidth need to be passed for this function. 
   DWORD dwScreenWidth;
 
//  ODS("ChipIsEnoughBandwidth() called.\n");

  if(!ChipCalcMCLK(pBWRegs, &dwMCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate MCLK.\n");
    goto Error;
  }

  if(!ChipCalcVCLK(pBWRegs, &dwVCLK))
  {
    ODS("ChipIsEnoughBandwidth(): Unable to calculate VCLK.\n");
    goto Error;
  }

  if( dwMCLK > 70000000 )
        f500MHZ = FALSE;
   else
        f500MHZ = TRUE;

  if ((dwMCLK > 70000000) && ( dwMCLK < 72000000))	  //PDR#11521
	  f585MHZ = TRUE;
	else
	  f585MHZ = FALSE;


  dwScreenWidth = (pBWRegs->CR1 + 1 ) << 3;
  if( pBWRegs->CR1E & 0x40 )
    dwScreenWidth += 0x1000;
  
  ODS("ChipIsEnoughBandwidth(): dwScreenWidth = %ld\n",dwScreenWidth);

  dwBLTFetch = (pBWRegs->Control2 & 0x0010) ? 256ul : 128ul;

  dwGfxFetch = (pBWRegs->DispThrsTiming & 0x0040) ? 256ul : 128ul;

ODS("GraphicDepth%ld,VideoDepth=%ld",pConfig->uGfxDepth,pConfig->uSrcDepth);

  if(pBWRegs->RIFControl & 0xC000)
  {
    ODS("ChipIsEnoughBandwidth(): Concurrent RDRAM detected!\n");
    dwHitLatency = CONC_HIT_LATENCY;
    dwRandom = CONC_RANDOM;
    fConCurrent = TRUE;
  }
  else
  {
    ODS("ChipIsEnoughBandwidth(): Normal RDRAM detected.\n");
    dwHitLatency = NORM_HIT_LATENCY;
    dwRandom = NORM_RANDOM;
    fConCurrent = FALSE;
  }
  
  // Determine the number of MCLKs to transfer to the graphics FIFO.
  dwGfxFill = (dwGfxFetch * 8ul) / FIFOWIDTH;
  // And BLTer FIFO.
  dwBLTFill = (dwBLTFetch * 8ul) / FIFOWIDTH;

  //
  // Determine maximum graphics threshold
  //

  dwMaxGfxThresh = dwHitLatency + dwGfxFill + (GFXFIFOSIZE / 2ul) -10ul;

  //    ( K * VCLK * GfxDepth )   GFXFIFOSIZE
  // INT( ------------------- ) + ----------- - 1
  //    ( FIFOWIDTH * MCLK    )        2
  iNumShift = ScaleMultiply(dwMaxGfxThresh, dwVCLK, &dwMaxGfxThresh);
  iNumShift += ScaleMultiply(dwMaxGfxThresh, (DWORD)pConfig->uGfxDepth,
                             &dwMaxGfxThresh);

  iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

  if(iNumShift > iDenomShift)
  {
    dwDenom >>= (iNumShift - iDenomShift);
  }
  else
  {
    dwMaxGfxThresh >>= (iDenomShift - iNumShift);
  }

  dwMaxGfxThresh /= dwDenom;

  dwMaxGfxThresh += (GFXFIFOSIZE / 2ul) - 1ul;
  
  if(dwMaxGfxThresh > GFXFIFOSIZE -1 )
        dwMaxGfxThresh = GFXFIFOSIZE -1;
  ODS("ChipIsEnoughBandwidth(): Max graphics thresh = %ld.\n", dwMaxGfxThresh);

  /*
   * Determine minimum graphics threshold
   */
  if(pConfig->dwFlags & VCFLG_DISP)
  {
    // Video enabled

    DWORD dwMinGfxThresh1, dwMinGfxThresh2;

    if(pConfig->dwFlags & VCFLG_420)
    {
      // 4:2:0

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + VID420FILL
                        + dwRandom - RIF_SAVINGS + 1ul;

    }
    else
    {
      // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

      dwMinGfxThresh1 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;

      dwMinGfxThresh2 = DISP_LATENCY + dwRandom + dwBLTFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + dwGfxFill
                        + dwRandom - RIF_SAVINGS + dwBLTFill
                        + dwRandom - RIF_SAVINGS + VIDFILL
                        + dwRandom - RIF_SAVINGS + 1ul;
    }

    //
    // Finish dwMinGfxThresh1
    //
    //    ( K * VCLK * GfxDepth   FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + --------------------- ) + 1
    //    (  FIFOWIDTH * MCLK       FIFOWIDTH * MCLK    )
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh1, dwVCLK, &dwMinGfxThresh1);
    iNumShift += ScaleMultiply(dwMinGfxThresh1, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh1);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh1 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh1 + dwDenom - 1ul) < dwMinGfxThresh1)
    {
      dwMinGfxThresh1 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh1 += dwDenom - 1ul;

    dwMinGfxThresh1 /= dwDenom;

    dwMinGfxThresh1++;  // Compensate for decrement by 2

    //
    // Finish dwMinGfxThresh2
    //
    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )   GfxFetch * 8
    // INT( ------------------- + ---------------------- ) - ------------ + 1
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )    FIFOWIDTH
    //
    iNumShift = ScaleMultiply(dwMinGfxThresh2, dwVCLK, &dwMinGfxThresh2);
    iNumShift += ScaleMultiply(dwMinGfxThresh2, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh2);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh2 >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh2 + dwDenom - 1ul) < dwMinGfxThresh2)
    {
      dwMinGfxThresh2 >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh2 += dwDenom - 1ul;

    dwMinGfxThresh2 /= dwDenom;

    // Adjust for second transfer
    dwMinGfxThresh2 -= ((dwGfxFetch * 8ul) / FIFOWIDTH);

    // Adjust for decrement by 2
    dwMinGfxThresh2++;

    if( fConCurrent)
    {
        if( f500MHZ)
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK >= 64982518ul ))
            {
                 dwTemp = ( dwVCLK - 64982518ul) /1083333ul  + 1ul;
                 dwMinGfxThresh2 -= dwTemp;
                 dwMinGfxThresh1 -= 10;
            }
            else if( (pConfig->uGfxDepth == 24) && (dwVCLK > 94500000ul))
                dwMinGfxThresh2 -=5;        //Adjust again for 24 bit #xc
        }
        else        //600MHZ
        {
            if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 156000000ul))
                dwMinGfxThresh2 -= 4;
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 104000000ul))
            {
                dwMinGfxThresh2 -= (5ul+ 8ul * (dwVCLK - 104000000ul) / 17000000ul);
            }
            else if( (pConfig->uGfxDepth == 32) )
            {  
                if( dwVCLK > 94000000ul)
                    dwMinGfxThresh2 -= 16;
               if( dwVCLK > 70000000ul)
                    dwMinGfxThresh2 -= 4;
					 else
						  dwMinGfxThresh2 +=6; //#PDR#11506 10x7x32bit could not
													  //support YUV420.
            }

        }

        if( (pConfig->uGfxDepth == 8) && (dwVCLK > 18000000ul))
                dwMinGfxThresh2 += 6;
    } 
    else    //Normal RDRam
    {   
        if( f500MHZ )
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49500000ul ))
            {
                dwMinGfxThresh1 -= 4;
                dwMinGfxThresh2 -= (( dwVCLK - 49715909ul) / 726981ul + 3ul);
            }
            else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ) 
                &&  (dwVCLK < 95000000ul))
            {
                dwTemp= ((dwVCLK - 64982518ul) / 1135287ul + 3ul);

                dwMinGfxThresh2 -=dwTemp;
                dwMinGfxThresh1 -= 10;
             }

        }
        else        //600MHZ case
        {
            if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 49700000ul ))
            {
                dwTemp= ((dwVCLK - 49700000ul) / 1252185ul + 5ul);
                dwMinGfxThresh2 -= dwTemp;
                dwMinGfxThresh1 -= 4ul;
            }
            else  if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 60000000ul ))
            {  
                dwTemp= ((dwVCLK - 64982518ul) / 2270575ul + 4ul);

               dwMinGfxThresh2 -=dwTemp;
               dwMinGfxThresh1 -= 8;

            }
            else  if( pConfig->uGfxDepth == 16) 
            {
                  dwMinGfxThresh2 -= 4;
            }
            else  if( pConfig->uGfxDepth == 8)
            {
               if(dwVCLK >170000000)
                  dwMinGfxThresh1 += 10;
               else
                  dwMinGfxThresh1 += 4;
                  
            }
        }
    }

    ODS("ChipIsEnoughBandwidth(): Min graphics thresh1 2 = %ld,%ld.\n",
          dwMinGfxThresh1, dwMinGfxThresh2);
    // Adjust for unsigned overflow
    if(dwMinGfxThresh2 > GFXFIFOSIZE + 20ul)
    {
      dwMinGfxThresh2 = 0ul;
    }

    //
    // Whichever is higher should be the right one
    //
    dwMinGfxThresh = __max(dwMinGfxThresh1, dwMinGfxThresh2);
  }
  else
  {
    // No video enabled

    dwMinGfxThresh = DISP_LATENCY + dwRandom + dwBLTFill
                     + dwRandom - RIF_SAVINGS + 1ul;

    //    ( K * VCLK * GfxDepth   (FIFOWIDTH * MCLK) - 1 )
    // INT( ------------------- + ---------------------- )
    //    (  FIFOWIDTH * MCLK        FIFOWIDTH * MCLK    )
    iNumShift = ScaleMultiply(dwMinGfxThresh, dwVCLK, &dwMinGfxThresh);
    iNumShift += ScaleMultiply(dwMinGfxThresh, (DWORD)pConfig->uGfxDepth,
                               &dwMinGfxThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMinGfxThresh >>= (iDenomShift - iNumShift);
    }

    // Be sure rounding below doesn't overflow.
    while((dwMinGfxThresh + dwDenom - 1ul) < dwMinGfxThresh)
    {
      dwMinGfxThresh >>= 1;
      dwDenom >>= 1;
    }
    // Round up
    dwMinGfxThresh += dwDenom - 1ul;

    dwMinGfxThresh /= dwDenom;

    dwMinGfxThresh++; // Compensate for decrement by 2
  }

  ODS("ChipIsEnoughBandwidth(): Min graphics thresh = %ld.\n", dwMinGfxThresh);

  if(dwMaxGfxThresh < dwMinGfxThresh)
  {
    ODS("ChipIsEnoughBandwidth(): Minimum graphics threshold exceeds maximum.\n");
    goto Error;
  }
 
  if(pProgRegs)
  {
    pProgRegs->DispThrsTiming = (WORD)dwMinGfxThresh;
  }
ODS("xfer=%x,cap=%x,src=%x,dsp=%x\n",pConfig->sizXfer.cx,pConfig->sizCap.cx,
    pConfig->sizSrc.cx,pConfig->sizDisp.cx);
  // Start-of-line check is only for capture
  if(pConfig->dwFlags & VCFLG_CAP)
  {
    DWORD dwNonCapMCLKs, dwCapMCLKs;

    // Do start-of-line check to be sure capture FIFO does not overflow.

    // First determine the number of MCLK cycles at the start of the line.
    //  We'll compare this to the number of levels of the capture FIFO
    //  filled during the same time to make sure the capture FIFO doesn't
    //  overflow.

    // Start of line:  BLT + HC + V + G + V + G
    dwNonCapMCLKs = dwRandom + dwBLTFill;
    // Hardware cursor is only necessary if it is on, however, since it can
    //  be enabled or disabled, and VPM has no way of knowing when this
    //  occurs, we must always assume it is on.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + CURSORFILL;

    if(pConfig->dwFlags & VCFLG_DISP)
    {
      // Only one video fill is required, however if the video FIFO threshold
      //  is greater than 1/2, the second fill will be done.  Also, because of
      //  the tiled architecture, even though the video might not be aligned,
      //  the transfer will occur on a tile boundary.  If the transfer of a
      //  single tile cannot fulfill the FIFO request, the second fill will be
      //  done.  Since the pitch will vary, and the client can move the source
      //  around, we must always assume that the second video FIFO fill will
      //  be done.
      if(pConfig->dwFlags & VCFLG_420)
      {
        dwNonCapMCLKs += 4ul * (dwRandom - RIF_SAVINGS + VID420FILL);
      }
      else
      {
        dwNonCapMCLKs += 2ul * (dwRandom - RIF_SAVINGS + VIDFILL);
      }
    }
    // The graphics FIFO fill depends on the fetch size.  We also assume that
    //  the pitch is a multiple of the fetch width.
    dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    // The second graphics FIFO fill will be done if:
    //  1. The graphics is not aligned on a fetch boundary (panning).
    //  2. The FIFO threshold is over 1/2 the FIFO (the fill size).
    if((dwMinGfxThresh >= dwGfxFill) || (pConfig->dwFlags & VCFLG_PAN))
    {
      dwNonCapMCLKs += dwRandom - RIF_SAVINGS + dwGfxFill;
    }

    dwNonCapMCLKs += 3; // Magic number that seems to work for now.

    ODS("ChipIsEnoughBandwidth(): dwNonCapMCLKs = %ld\n", dwNonCapMCLKs);

    // sizXfer.cx * FIFOWIDTH * (CAPFIFOSIZE / 2) * dwMCLK
    // ---------------------------------------------------
    //         dwXferRate * uCapDepth * sizCap.cx

    iNumShift = ScaleMultiply((DWORD)pConfig->sizXfer.cx, FIFOWIDTH,
                              &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, (CAPFIFOSIZE / 2), &dwCapMCLKs);
    iNumShift += ScaleMultiply(dwCapMCLKs, dwMCLK, &dwCapMCLKs);

    iDenomShift = ScaleMultiply(pConfig->dwXferRate, (DWORD)pConfig->uCapDepth,
                                &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, (DWORD)pConfig->sizCap.cx, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwCapMCLKs >>= (iDenomShift - iNumShift);
    }

    dwCapMCLKs /= dwDenom;

    ODS("ChipIsEnoughBandwidth(): dwCapMCLKs = %ld\n", dwCapMCLKs);
    if(fConCurrent)
    {
        if( pConfig->uGfxDepth == 32) 
            dwCapMCLKs -= 44;     //adjust 32 bit 
    }

    if(dwNonCapMCLKs > dwCapMCLKs)
    {
      ODS("ChipIsEnoughBandwidth(): Capture overflow at start of line.\n");
      goto Error;
    }
  }

  if(pConfig->dwFlags & VCFLG_DISP)
  {
    /*
     * Determine maximum video threshold
     */
    dwMaxVidThresh = dwHitLatency;
    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
      if( !f500MHZ && fConCurrent )
         dwMaxVidThresh += 5;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
    }

    //    ( K * VCLK * VidDepth * SrcWidth )
    // INT( ------------------------------ ) + VidFill (/ 2) - 1
    //    ( FIFOWIDTH * MCLK * DispWidth   )             ^non-4:2:0 only
    iNumShift = ScaleMultiply(dwMaxVidThresh, dwVCLK, &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->uSrcDepth,
                                &dwMaxVidThresh);
    iNumShift += ScaleMultiply(dwMaxVidThresh, (DWORD)pConfig->sizSrc.cx,
                                &dwMaxVidThresh);

    iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx, &dwDenom);
    iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

    if(iNumShift > iDenomShift)
    {
      dwDenom >>= (iNumShift - iDenomShift);
    }
    else
    {
      dwMaxVidThresh >>= (iDenomShift - iNumShift);
    }

    dwMaxVidThresh /= dwDenom;

    if(pConfig->dwFlags & VCFLG_420)
    {
      dwMaxVidThresh += VID420FILL;
    }
    else
    {
      dwMaxVidThresh += VIDFILL;
      // Threshold is programmed in DQWORDS for non-4:2:0
      dwMaxVidThresh /= 2ul;
    }
    dwMaxVidThresh--;

    ODS("ChipIsEnoughBandwidth(): Max video thresh = %ld.\n", dwMaxVidThresh);

     if( fConCurrent && f500MHZ && ( dwVCLK < 66000000ul))
         dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
    /*
     * Determine minimum video threshold
     */
    {
      DWORD dwMinVidThresh1, dwMinVidThresh2;

      if(pConfig->dwFlags & VCFLG_420)
      {
        // 4:2:0

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + VID420FILL
                          + dwRandom - RIF_SAVINGS + 1;
      }
      else
      {
        // 4:2:2, 5:5:5, 5:6:5, or X:8:8:8

        dwMinVidThresh1 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2;

        dwMinVidThresh2 = DISP_LATENCY + dwRandom + dwGfxFill
                          + dwRandom - RIF_SAVINGS + VIDFILL
                          + 15ul        //#xc
  //                        + 10ul
                          + dwRandom - RIF_SAVINGS + dwGfxFill
                          + dwRandom - RIF_SAVINGS + 2ul;
        if(fConCurrent)
        {
           if(f500MHZ )
           { 
               if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
               {
                    if( dwVCLK > 94000000ul)
                        dwMinVidThresh1 += 105;
                    else if( dwVCLK > 74000000ul)
                        dwMinVidThresh1 += 90;
                     else
                        dwMinVidThresh1 += 65;
                    if(pConfig->dwFlags & VCFLG_CAP) 
                    {
                        if(dwVCLK > 78000000ul)
                            dwMinVidThresh1 += 260; //disable video
                        else if( dwVCLK > 74000000ul)
                            dwMinVidThresh1 += 70;
                    }                
               }  
               else if( pConfig->uGfxDepth == 24)
               {
                      if( dwVCLK > 94500000ul)
                      {
                        if(dwScreenWidth == 1024)
                           dwMinVidThresh2 += 50ul;
                        else
                           dwMinVidThresh2 += 90ul; 
                      }
                      else if( dwVCLK < 41000000ul)
                      {
                        dwMinVidThresh2 += 4;
                      }    
                      else  if(dwVCLK < 80000000ul)
                      {
                         if( (dwVCLK > 74000000ul) && (dwVCLK < 76000000ul))
                         {
                              dwMinVidThresh2 -= 1;
                         }
                         else
                            dwMinVidThresh2 -= 8;
                         dwMinVidThresh1 -= 4;
    
                      }   
                    
                    if(pConfig->dwFlags & VCFLG_CAP) 
                      if( dwVCLK > 94000000ul)
                      { 
                            if((dwVCLK < 95000000ul) && ( dwGfxFetch == 256 ))
                                dwMinVidThresh2 += 60; 
                            else
                                dwMinVidThresh2 += 120; 
                      }                 
                }
               else if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul ))
               {                    
                   if( dwVCLK < 94000000ul)
                   {  
                        dwMinVidThresh2 -= 10;
                        dwMinVidThresh1 -= 6;
                   }
                   else if( dwVCLK > 105000000ul)
                        dwMinVidThresh2 += 50;
                } 
               else if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 60000000ul ))
               {
                  if( dwVCLK > 216000000ul)
                  {
                    dwMinVidThresh2 += 50;
                    dwMinVidThresh1 += 20;
                   }   
                  else if( (dwVCLK < 95000000ul) && ( dwScreenWidth <= 1024))
                  {  
                    dwMinVidThresh2 -= 12;
                    dwMinVidThresh1 -= 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 9); 
                  }
                  else if(dwVCLK < 109000000ul)
                  {
                    dwMinVidThresh2 += ( 14 -  4 * ( dwVCLK - 94000000ul ) / 14000000ul );
                    dwMinVidThresh1 += 10;
                    dwMaxVidThresh = __min(dwMaxVidThresh, 8); 
                  }  
                  else
                  {
                     dwMinVidThresh2 += 7;
                     dwMinVidThresh1 += 4;
                  }
               }
            }
#if 1//PDR#11521
	        else if (f585MHZ)       //585MHZ
   	     {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }

                    if( dwVCLK > 189000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if( dwVCLK > 126000000ul)     //PDR11521
                            dwMaxVidThresh ++;   

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;

                    if( dwVCLK > 94000000ul)     //PDR11521
                            dwMaxVidThresh ++;   
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

      	  }
#endif
            else        //600MZH concurrent
            {
                if( (pConfig->uGfxDepth == 8) && ( dwVCLK > 56000000ul))
                {
                    if( dwVCLK > 200000000ul)
                    {
//PDR#11541                        dwMaxVidThresh++;
                        dwMinVidThresh1 += 7;
                        dwMinVidThresh2 += 14;    

                    }
                    else if( dwVCLK  < 60000000ul)
                    {
                     dwMinVidThresh2 += 8;
                    }
                    else if( dwVCLK < 160000000ul)
                    {
                        dwMinVidThresh1 -=20;
                        dwMinVidThresh2 -=10;    
                    }
 
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                        if( dwVCLK < 76000000ul)
                           dwMinVidThresh2 +=8; 
                        else if( dwVCLK < 140000000ul)    
                           dwMinVidThresh2 +=25;     
                        else                        
                           dwMinVidThresh2 +=32;     
                    }
                }
                else  if( (pConfig->uGfxDepth == 16) && ( dwVCLK > 60000000ul))
                {
                        if( dwVCLK > 157000000ul)
                        {
                            dwMinVidThresh1 += 27;    
//PDR#11541                            dwMaxVidThresh ++;
                        }
                        if( dwVCLK > 125000000ul)
                        {
                          dwMinVidThresh1 += 40;
                        }    
                        else if( dwVCLK > 107000000ul)
                        {
                          dwMinVidThresh1 += 34;
                        }
                        else 
                        if( dwVCLK > 74000000ul)
                        {
                          dwMinVidThresh1 += 18;
                        }


                       if(pConfig->dwFlags & VCFLG_CAP)
                       {
                            if( dwVCLK > 74000000ul)
                               dwMinVidThresh1 +=2; 
                        }
                }
                else  if( pConfig->uGfxDepth == 24)
                {
                    if( dwVCLK < 60000000ul)
                    {
                        dwMinVidThresh1 -= 8;
                        dwMinVidThresh2 -= 16;
                    }
                    else if( dwVCLK  > 107000000ul )
                          dwMinVidThresh2 += 84;
                    else if( (dwVCLK > 94000000ul) && (dwScreenWidth >= 1152))
                    {
                        dwMinVidThresh2 += 40;
                    }

                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                         if( dwVCLK > 74000000ul)
                            dwMinVidThresh2 +=12; 
                    }

                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul))
                {
                    if( dwVCLK > 74000000ul)
                    {
                        if( (dwVCLK > 77000000ul) && ( dwVCLK < 80000000ul))
                            dwMinVidThresh2 += 120;
                        else
                            dwMinVidThresh2 += 83;       
                    }
                    else                
                        dwMinVidThresh2 += 30;        
    
                    if(pConfig->dwFlags & VCFLG_CAP)
                    {
                          if( dwVCLK > 94000000ul)
                            dwMinVidThresh2 +=2; 
                    }
                }
                else  if(( pConfig->uGfxDepth == 32) && ( dwVCLK > 49000000ul))
                {
                    
                    if(pConfig->dwFlags & VCFLG_CAP)
                            dwMinVidThresh2 +=2; 
                }

            }
        }
        else     //Normal RDRam case
        {  
           if(f500MHZ )
           { 
             if( (pConfig->uGfxDepth == 32) && ( dwVCLK > 60000000ul ))
             {
                 dwMinVidThresh1 += 75;
                 if(pConfig->dwFlags & VCFLG_CAP)
                    dwMinVidThresh1 +=20;
             }
             else if( (pConfig->uGfxDepth == 24) && ( dwVCLK > 7800000ul ))
             {
                 dwMinVidThresh2 += 52;
                 if(pConfig->dwFlags & VCFLG_CAP)
                 {
                     dwMinVidThresh2 += 50;
                  }
             }   
             else if(pConfig->uGfxDepth == 16)
             {
                 if((dwVCLK > 36000000 ) && ( dwVCLK < 57000000))
                 {
                      dwMinVidThresh2 += 22 - ( dwVCLK - 36000000) * 3L /
                                 4000000; 
                 } 
                 else
                 {
                    dwMinVidThresh2 -= 18;
                    dwMinVidThresh1 -= 8;
                 }   
                if(pConfig->dwFlags & VCFLG_CAP)
                {
                     dwMinVidThresh2 += 5;
                }
              }
              else if((pConfig->uGfxDepth == 8) && ( dwVCLK > 36000000ul )) 
              { 
                if(dwVCLK > 160000000ul)
                    dwMinVidThresh2 -= 6;
                else if( (dwVCLK > 94000000 ) && (dwVCLK < 109000000) && (dwScreenWidth == 1152))
                {
                    dwMinVidThresh2 -=  2 + 4 * ( dwVCLK - 94000000 ) / 13500000;
                }
                else if( (dwVCLK < 109000000) && (dwScreenWidth == 1280))
                {
                     dwMinVidThresh2 -= 5;   
                }
                else if( dwVCLK > 60000000ul)
                {
                     dwMinVidThresh2 -= 18;
                     if(pConfig->dwFlags & VCFLG_CAP)
                     {
                         dwMinVidThresh2 += 5;
                     }
                }
                else 
                    dwMinVidThresh2 += 6;
                dwMinVidThresh1 -= 8;
             } 

           }
           else     //600 MHZ
           { 
                if(pConfig->uGfxDepth == 32)
                { 
                   if( dwVCLK > 60000000ul )
                   {
                        dwTemp = ( dwVCLK - 60000000ul ) /300000ul + 38ul;
                        dwMinVidThresh1 +=  dwTemp;
                   }
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 40000000ul))
                   {
                        if(dwVCLK > 94000000ul)
                            dwTemp = 120;           //disable capture;
                        else
                            dwTemp = ( dwVCLK - 40006685ul) /1085905ul + 5;
                        dwMinVidThresh1 +=dwTemp;
                    }
                }
                else if( pConfig->uGfxDepth == 24) 
                {
                   if( dwVCLK < 50000000ul)
                       dwMinVidThresh2 -= 5;
                   else      
                       dwMinVidThresh2 -= 18;
                   dwMinVidThresh1 -= 8;
                   if((pConfig->dwFlags & VCFLG_CAP) && (dwVCLK > 94000000ul))
                       dwMinVidThresh2 += 8;

                }
                else  if(pConfig->uGfxDepth == 16)
                {
                   if( (dwVCLK < 100000000ul ) && (dwVCLK > 66000000ul))
                   { 
                        dwTemp =   31ul -  (dwVCLK -60000000ul) / 1968750ul;
                    }
                    else  if( dwVCLK <= 66000000ul)  //after 1024X768 only adjust constantly
                    {  
                       if( dwVCLK < 57000000ul) 
                       { 
                          dwTemp = 0ul;
                          dwMinVidThresh2 += 10ul;
                        }
                        else
                          dwTemp = 5ul;  
                    }
                    if(dwVCLK > 100000000ul)
                    {
                        dwMinVidThresh2 += 40ul;
                        dwMinVidThresh1 += 20ul;
                    }
                    else
                    {
                        dwMinVidThresh2 -= dwTemp;
                        dwMinVidThresh1 -= 8ul;
                    }
                }
                else if(pConfig->uGfxDepth == 8) 
                {
                    if((dwVCLK > 94000000ul) && ( dwScreenWidth >=1152))
                    {
                       if(dwVCLK > 108000000ul) 
                           dwMinVidThresh2 += 10;
                       else
                           dwMinVidThresh2 += 20;
                       dwMinVidThresh1 += 1;
                    }
                    else if( dwVCLK > 64000000ul )
                    {
                        if( dwVCLK > 70000000ul)
                            dwTemp = 25;  
                        else
                            dwTemp = 5;

                        if(pConfig->dwFlags & VCFLG_CAP)
                        {
                            if(dwVCLK < 760000000ul )
                                dwTemp = 0;
                            else if(dwVCLK < 950000000ul)
                                dwTemp -= 10;
                        }
                        dwMinVidThresh2 -= dwTemp;

                        dwMinVidThresh1 -= 15;
                    }
                }
           }
        }    
      }

      //
      // Finish dwMinVidThresh1
      //
      //    ( K * VidDepth * SrcWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1 )
      // INT( ------------------------------ + ---------------------------------- ) (/ 2) + 1
      //    ( FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK    )
      iNumShift = ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh1);
      iNumShift += ScaleMultiply(dwMinVidThresh1, dwVCLK, &dwMinVidThresh1);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh1 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh1 + dwDenom - 1ul) < dwMinVidThresh1)
      {
        dwMinVidThresh1 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh1 += dwDenom - 1ul;

      dwMinVidThresh1 /= dwDenom;

      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh1 /= 2ul;
      }

      dwMinVidThresh1++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.

      //
      // Finish dwMinVidThresh2
      //
      // K * VidDepth * VidWidth * VCLK   (FIFOWIDTH * DispWidth * MCLK) - 1
      // ------------------------------ + ----------------------------------
      // FIFOWIDTH * DispWidth * MCLK        FIFOWIDTH * DispWidth * MCLK
      //
      //   VIDFIFOSIZE
      // - ----------- (/ 2) + 1
      //        2        ^non-4:2:0 only
      iNumShift = ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->uSrcDepth,
                                &dwMinVidThresh2);
      iNumShift += ScaleMultiply(dwMinVidThresh2, (DWORD)pConfig->sizSrc.cx,
                                &dwMinVidThresh2);

      iNumShift += ScaleMultiply(dwMinVidThresh2, dwVCLK, &dwMinVidThresh2);

      iDenomShift = ScaleMultiply(FIFOWIDTH, (DWORD)pConfig->sizDisp.cx,
                                  &dwDenom);
      iDenomShift += ScaleMultiply(dwDenom, dwMCLK, &dwDenom);

      if(iNumShift > iDenomShift)
      {
        dwDenom >>= (iNumShift - iDenomShift);
      }
      else
      {
        dwMinVidThresh2 >>= (iDenomShift - iNumShift);
      }

      // Be sure rounding below doesn't overflow (it happened!)
      while((dwMinVidThresh2 + dwDenom - 1ul) < dwMinVidThresh2)
      {
        dwMinVidThresh2 >>= 1;
        dwDenom >>= 1;
      }
      dwMinVidThresh2 += dwDenom - 1ul;

      dwMinVidThresh2 /= dwDenom;

      if(dwMinVidThresh2 > (VIDFIFOSIZE /2ul) )
          dwMinVidThresh2 -= (VIDFIFOSIZE / 2ul);
      else
          dwMinVidThresh2 = 0;
        
      if(!(pConfig->dwFlags & VCFLG_420))
      {
        // Threshold is programmed in DQWORDS for non-4:2:0
        dwMinVidThresh2 /= 2ul;
      }

      dwMinVidThresh2++;  // Adjust for -2 decrement of FIFO count done to
                          //  synchronize MCLK with faster VCLK.


    ODS("ChipIsEnoughBandwidth(): Min video thresh1 and 2 = %ld %ld.\n", 
                dwMinVidThresh1, dwMinVidThresh2);

      if(dwMinVidThresh2 > VIDFIFOSIZE -1)
      {
        dwMinVidThresh2 = VIDFIFOSIZE -1;
      }
      //
      // Whichever is higher should be the right one
      //
      dwMinVidThresh = __max(dwMinVidThresh1, dwMinVidThresh2);
    }

    ODS("ChipIsEnoughBandwidth(): Min video thresh = %ld.\n", dwMinVidThresh);

    if(dwMaxVidThresh < dwMinVidThresh)
    {
      ODS("ChipIsEnoughBandwidth(): Minimum video threshold exceeds maximum.\n");
      goto Error;
    }
    //I don't know why, but it need checked for capture. #xc
    if((pConfig->dwFlags & VCFLG_CAP) && (dwMaxVidThresh > 8) 
        && ((pConfig->uGfxDepth != 8) || fConCurrent) && ( f500MHZ || !fConCurrent))
    {
      ODS("ChipIsEnoughBandwidth(): Video threshold exceeds non-aligned safe value.\n");
      goto Error;
    }
    if(pProgRegs)
    {
      if((((pConfig->uGfxDepth == 8) && (dwVCLK > 60000000)) || 
          ((pConfig->uGfxDepth != 8)  && ( dwVCLK > 56000000)) ||
         ( !f500MHZ && fConCurrent)) && !(pConfig->dwFlags & VCFLG_CAP))
        pProgRegs->VW0_FIFO_THRSH = (WORD)dwMaxVidThresh;
      else 
        pProgRegs->VW0_FIFO_THRSH = (WORD)__min( 8, dwMaxVidThresh);
    ODS("ChipIsEnoughBandwidth(): thresh = %ld.\n", pProgRegs->VW0_FIFO_THRSH);
    }
  }
  fSuccess = TRUE;
Error:
  return(fSuccess);
}

#endif // WINNT_VER35




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\mini\headless.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headless.h

Abstract:

    This module contains the definitions for the code that implements the
    Headless device driver.

Author:

Environment:

    Kernel mode

--*/

#ifndef _HEADLESS_
#define _HEADLESS_

typedef struct {
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
} VIDEOMODE, *PVIDEOMODE;

//
// Function prototypes.
//

VP_STATUS
HeadlessFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
HeadlessInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
HeadlessStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
HeadlessQueryAvailableModes(
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
HeadlessQueryNumberOfAvailableModes(
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

extern VIDEOMODE ModesHeadless[];
extern ULONG NumVideoModes;

#endif // _HEADLESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\mini\modeset.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the headless miniport driver.

Environment:

    kernel mode only

Notes:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,HeadlessQueryAvailableModes)
#pragma alloc_text(PAGE,HeadlessQueryNumberOfAvailableModes)
#endif

VP_STATUS
HeadlessQueryAvailableModes(
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            NumVideoModes * sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++, videoModes++) {

        videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
        videoModes->ModeIndex  = i;
        videoModes->VisScreenWidth = ModesHeadless[i].hres;
        videoModes->VisScreenHeight = ModesHeadless[i].vres;
        videoModes->NumberOfPlanes = 1;
        videoModes->BitsPerPlane = 4;
        videoModes->Frequency = 60;
        videoModes->XMillimeter = 320;        // temporary hardcoded constant
        videoModes->YMillimeter = 240;        // temporary hardcoded constant
        videoModes->NumberRedBits = 6;
        videoModes->NumberGreenBits = 6;
        videoModes->NumberBlueBits = 6;
        videoModes->RedMask = 0;
        videoModes->GreenMask = 0;
        videoModes->BlueMask = 0;
        videoModes->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS |
               VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;
    }

    return NO_ERROR;

}

VP_STATUS
HeadlessQueryNumberOfAvailableModes(
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = NumVideoModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\5465over.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         5465over.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   \\uinac\log\log\laguna\ddraw\src\5465over.c  $
* 
*    Rev 1.75   19 May 1998 09:54:36   xcong
* Assign GfVdFormat in ChipIOReadBWRegs() for TV-Out support.
* 
*    Rev 1.74   07 Apr 1998 17:28:58   xcong
* Get CR1 and CR1E in ChipIOBWRead()
* 
*    Rev 1.73   Mar 30 1998 13:06:52   frido
* Changed some parenthesis so the Codewright source parser can find the
* functions.
* 
*    Rev 1.72   08 Jan 1998 10:45:28   xcong
* Don't pass lpDDHALData in ComputeVWPositionData() for NT.
* 
*    Rev 1.71   07 Jan 1998 17:55:32   xcong
* Delete *lpDDHALData in SetPostion() for NT only.
* 
* 
*    Rev 1.70   06 Jan 1998 14:43:54   xcong
* Pass lpDDHALData in CurrentVLine().
* 
*    Rev 1.69   06 Jan 1998 11:42:06   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.68   Dec 11 1997 14:03:28   frido
* PDR#11011: A workaround has been added to convert a "dummy"
* update into a SHOW update when certain criteria are met.
* 
*    Rev 1.67   Dec 10 1997 13:41:32   frido
* Merged from 1.62 branch.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.66   Dec 10 1997 13:32:08   frido
* Merged from 1.62 branch.
* 
*    Rev 1.65   14 Nov 1997 13:04:18   XCONG
* Undo the modification for dwOverlayOffset for NT.
* 
*    Rev 1.64   06 Nov 1997 15:46:14   XCONG
* When update dwOverlayOffset, update this variable for all the attached surf
* too.
* 
*    Rev 1.63.2.0   Dec 03 1997 14:44:54   frido
* PDR#11017. The hardware is broken when shrinking videos horizontally with
* RGB32 format. A software workaround has been added to disable overlay in
* this case.
* 
*    Rev 1.63   04 Nov 1997 13:41:34   RUSSL
* Fix for PDR #10815
*
*    Rev 1.62   04 Nov 1997 12:57:02   RUSSL
* Removed forcing of min stretch in 24bpp to start at 1000 (for new bweq code)
*
*    Rev 1.61   30 Oct 1997 14:34:18   RUSSL
* Mods to support new interface to bweqn code
* Moved KillOverlay function here from 5465bw.c
* ChipIOReadBWRegs reads additional regs that are new to the BWREGS struct
* Added code in ChipIOReadBWRegs to clear bits 4 & 7 (the 256 byte fetch
*   related bits) of the BWREGS Control2 value.  The bweqn should use
*   256 byte fetch off values, since we are disabling 256 byte fetch
*   when overlay or videoport surfaces are created.
*
*    Rev 1.60   08 Oct 1997 11:15:02   RUSSL
* Fix for NT40 build without overlay support
*
*    Rev 1.59   25 Sep 1997 17:33:40   RUSSL
* Modified HeapAlloc calls to use HEAP_ALLOC macro
*      and HeapFree calls to use HEAP_FREE macro
*
*    Rev 1.58   19 Sep 1997 14:35:04   bennyn
* Fixed NT4.0 5462/64 build problem
*
*    Rev 1.57   17 Sep 1997 16:27:20   RUSSL
* Looks like setting the HardwareOwner is FlipOverlayStatus is an NT only
* thing.
*
*    Rev 1.56   16 Sep 1997 15:28:38   bennyn
* Modified for NT DD overlay
*
*    Rev 1.55   04 Sep 1997 09:43:26   RUSSL
* Fixed up Xing's changes so they compile for NT
*
*    Rev 1.54   04 Sep 1997 10:07:52   XCONG
* Delete f256Fetch, since the code to disable 256 byte fetch is moved to
* surface.c, nobody use this variable anymore.
*
*    Rev 1.53   03 Sep 1997 18:40:12   XCONG
* Disable overlay in 640*480*32 at 85Hz by calling KillOverlay().
* This is temporary fix for PDR#10381.
*
*    Rev 1.52   03 Sep 1997 16:35:02   RUSSL
*
*    Rev 1.51   02 Sep 1997 12:35:48   RUSSL
* Added GET_SURFACE_DATA_PTR macro and modified relevant code to get ptr
* using macro.  This will minimize the remaining changes needed for NT.
*
*    Rev 1.50   29 Aug 1997 16:47:26   RUSSL
* Added support for NT
* It's not quite complete, we need to allocate a LP_SURFACE_DATA structure
*   for each overlay surface and store it somewhere in the DD_SURFACE_LOCAL
*   structure (this needs to be done by CreateSurface).  And then add code
*   in here to get access to that struct when necessary.  #pragma message's
*   indicate where.
* Removed code to disable 256 byte fetch, its done by CreateSurface32
*
*    Rev 1.49   15 Aug 1997 16:38:30   XCONG
* Put overlay source alignment back to 1.  This is screen alignment instead o
*
*    Rev 1.48   14 Aug 1997 16:47:42   XCONG
* If overlay window is created, disable 256 byte fetch.
* Move gwNormalDTTR initialization into CreateSurface function.
*
*    Rev 1.47   29 Jul 1997 15:29:14   XCONG
* For autoflip overlay make sure dwNumAutoFlip == 2
*
*    Rev 1.46   28 Jul 1997 09:19:46   RUSSL
* Modified GetOverlayFlipStatus to check arm bit in hw rather than determine
*  elapsed time since previous flip
* Added video window index argument to GetOverlayFlipStatus function
* Made dwNumVideoWindows a global var rather than static
* Moved GetVideoWindowIndex inline function to overlay.h
*
*    Rev 1.45   24 Jul 1997 17:50:14   RUSSL
* modified src alignment values reported in ddhalinfo
* fixed error with disabling dst colorkey at 24bpp, I was turning off
* src colorkey related caps bits
*
*    Rev 1.44   16 Jul 1997 17:15:32   XCONG
* Add and use dwOverlayOffset and more in SURFACE_DATA structure in order
* to eliminate global variables.
*
*    Rev 1.43   14 Jul 1997 13:11:50   RUSSL
* added ChipIOReadBWRegs (moved here from 5465bw.c)
*
*    Rev 1.42   11 Jul 1997 11:57:26   XCONG
* Fix ptich problem in FlipOverlay for interleaved surface.
*
*    Rev 1.41   11 Jul 1997 08:57:02   RUSSL
* Fixed y clipping of CLPL surfaces in FlipOverlaySurface and
*   ComputeVWPositionData
*
*    Rev 1.40   09 Jul 1997 15:27:44   RUSSL
* Implemented CLPL lobotomy mode
*   allocates a block of system memory for the app to write the UV data to,
*   when the app locks the surface the system memory addresses are returned
*   so the app writes to system memory, and when the app unlocks the surface,
*   the data is copied into the frame buffer.  The copy is done from left to
*   right a scanline at a time.  There appears to be a hw bug when writing
*   to aperture 3 from right to left.  Roughly every other 4 dwords is
*   dropped.  This bug showed up when allowing the Compcore MPEG player to
*   write directly to aperture 3.  (also see comments in SysToFBCopy)
* Added GetUserSettings to read user controllable options from registry
* Current user controllable settings are:
*   OverlayBW   - enables/disables use of bandwidth equation (default=enabled)
*   OverlayCLPL - enables/disables support for CLPL format (default=enabled)
* 	OverlayCLPLLobotomyMode - enables/disables above described CLPL
*                             lobotomy mode (default=enabled)
* For forward compatibility, assume future chips have one video window
*
*    Rev 1.39   30 Jun 1997 10:37:20   RUSSL
* Added global var to control whether or not CLPL is supported
* CLPL support is based on a registry key "OverlayCLPL", set to "on" to
*   enable CLPL, default is "off"
*
*    Rev 1.38   23 Jun 1997 10:50:10   RUSSL
* Modified for reduced size of CLPL surfaces
*
*    Rev 1.37   20 Jun 1997 13:47:44   RUSSL
* Enabled CLPL overlay surface support (aka YUV420 & YUVPLANAR)
* Enabled 32 bit overlay surface support
* Removed REQUIREs and HW_(UN)LOCK_SEMAPHOREs (they didn't do anything anyway)
* CreateSurface now returns an HRESULT
*
*    Rev 1.36   09 Jun 1997 13:46:22   XCONG
* In FlipOverlaySurface(), Update VW_CONTROL0 too for DDFLIP_EVEN.
*
*    Rev 1.35   03 Jun 1997 09:52:50   RUSSL
* Added setting of VWEnable bit in CONTROL0 register in SetPosition and
* FlipOverlaySurface functions
*
*    Rev 1.34   22 May 1997 16:27:46   RUSSL
* Disable overlay shrink at 24bpp
*
*    Rev 1.33   15 May 1997 17:36:38   RUSSL
* Set ddCaps.dwAlignStrideAlign to bytes per pixel in Init5465Overlay
* Set bNoOverlayInThisMode to TRUE if in interlaced mode
*
*    Rev 1.32   15 May 1997 15:48:20   XCONG
* Change all the BWE flags back (in bw.h).
*
*    Rev 1.31   15 May 1997 10:56:54   RUSSL
* Changed IsFormatValid to return an HRESULT rather than a BOOL so
* CanCreateSurface32 can return a reasonable error code if the surface
* can't be created
*
*    Rev 1.30   13 May 1997 09:53:04   RUSSL
* Removed code in Init5465Info that was initializing the VW0_TEST0 register
*
*    Rev 1.29   12 May 1997 17:22:32   XCONG
* Change wVPortCreated in VideoPortEx into wNotify
*
*    Rev 1.28   10 May 1997 12:51:02   EDWINW
* Fix PDR 9574.  DestroySurface trashes tile size when trying to restore the
* DTTR's FIFO threshold.
*
*    Rev 1.27   09 May 1997 16:26:36   XCONG
* Only check VPE_ON and OVERLAY_ON flags in DX5
*
*    Rev 1.26   09 May 1997 11:10:22   XCONG
* Uses the flags in overlay.h for BWE flags. Befor save and restore
* gwNormIDTTR check VPE is still running or not, because VPE will do the same
* thing.
*
*    Rev 1.25   08 May 1997 17:57:40   XCONG
* Make the BWE variables global.  Set uDispDepth as the same as
* sourc depth instead of graphic depth.
*
*    Rev 1.24   24 Apr 1997 14:36:46   XCONG
* For SW playback only use smooth-interlaced mode when BOB and INTERLEAVE
* flags are both set.
*
*    Rev 1.23   24 Apr 1997 12:02:54   RUSSL
* Reenabled writing 0x52 to TEST0 reg on 5465AC if bw eqn is in use.
* 800x600x16 @ 85Hz looks like it's running on the hairy edge of
* stability with this.  All other modes (at all resolutions, colordepths
* and refresh rates) with sufficient bandwidth to use overlay looked
* stable although there is still some static in some modes.
*
*    Rev 1.22   17 Apr 1997 09:38:22   RUSSL
* Fix for PDR #9339, disable destination colorkeying support at 24bpp.
*   This looks like its a HWBUG.  This code can be disabled by defining
*   HWBUG_24BPP_DST_COLORKEY as zero.
* Write DTTR FIFO value returned by ChipIsEnoughBandwidth, original DTTR
*   setting is saved in a global var which is restored when final overlay
*   surface is destroyed
*
*    Rev 1.21   16 Apr 1997 10:19:28   RUSSL
* Had to update list of parms passed to GetBooleanSetting
*
*    Rev 1.20   15 Apr 1997 17:46:46   RUSSL
* Added use of PDC's bandwidth equation
* Added use of registry key/system.ini entry to disable use of BWEqn
* Removed IsSufficientBandwidth functions
* Modified Init5465Info to determine min & max zoom factors in current
*   mode by calling BWEqn
* ComputeVWFifoThreshold sets VW fifo threshold to value returned previously
*   by bandwidth equation (or it uses 8 if use of BWEqn is disabled)
*
*    Rev 1.19   04 Apr 1997 16:11:56   XCONG
* Add support for SW double-buffer and BOB palyback. Change the way to
* calculate VACCUM_STP for interleaved BOB.
*
*    Rev 1.18   03 Apr 1997 09:58:42   RUSSL
* Disable writing 0x42 or 0x52 to TEST0 reg, it's more grief than it's worth
*   Wait until we get a real bandwidth equation
* Made IsFormatValid always return FALSE when we're in an interlaced mode,
*   this essentially disables use of overlay in interlaced modes
*
*    Rev 1.17   28 Mar 1997 14:57:26   RUSSL
* Need to write 0x42 to TEST0 in 24bpp modes
* Display driver now puts 32bit linear address of pDevice in
*   pDriverData->lpPDevice, so don't need to call MapSLFix
*
*    Rev 1.16   24 Mar 1997 22:54:58   XCONG
* Add auto-flip overlay support. Include SSD_STRT_ADDR in tagVWDATA for
* all the version of DDRAW.
*
*    Rev 1.15   24 Mar 1997 16:44:56   RUSSL
* Changed CreateSurface so that CreateSurface32 fills in the blocksize, etc.
*
*    Rev 1.14   24 Mar 1997 12:12:40   RUSSL
* Added write of 0x52 to TEST0 reg on 5465AC, this enables some hw fixes
*
*    Rev 1.13   19 Mar 1997 11:47:40   cjl
* Simply added line to include new ddshared.h file.
*
*    Rev 1.12   12 Mar 1997 14:59:00   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
* Removed unneeded pragma message related to mapping in YUY2 aperture
*
*    Rev 1.11   07 Mar 1997 12:43:22   RUSSL
* Modified DDRAW_COMPAT usage
* Merged in PDC's VPE code for DX5
* Made IsSufficientBandwidth5465 global rather than static
*
*    Rev 1.10   24 Feb 1997 13:49:52   RUSSL
* Enabled YUY2 format
* Added RBGtoYCbCr function
* Modified DetermineVWColorKeyData to handle source color keying of UYVY
*   and YUY2 surfaces
*
*    Rev 1.9   14 Feb 1997 10:01:14   RUSSL
* Added more conditional compilation flags to enable/disable horizontal
*   mirroring, use of REQUIRE for qfree checking and use of HW_IN_USE
*   driver semaphore.
* If building debug version, change inline functions to not be inline.
*   WINICE can't deal with inline functions, so source code doesn't line
*   up correctly.
* Added ASSERT to make sure post immediately bit is clear in TEST0 reg
*   before updating video window registers
* Ignore DDOVER_DDFX flag in UpdateSurface because Microsoft's WHQL Overfly
*   test program sets this flag but fills overlayFX.dwDDFX with junk.
*   In some cases they set the DDOVERFX_MIRRORLEFTRIGHT bit even though
*   we don't even say we support that capability!  In order to get Overfly
*   to work, we need to ignore the overlayFX.dwDDFX flags that we don't
*   support (which is currently all of them)  This fixes BPR #8528
*
*    Rev 1.8   04 Feb 1997 14:15:48   RUSSL
* Added check in IsFormatValid to see if VPM is using the hardware
* Added SaveRectangles to reduce duplicate code in UpdateSurface
* Adjusted zoom code calculation for x shrink so don't go past end of src
*
*    Rev 1.7   31 Jan 1997 08:59:30   RUSSL
* Added better video window support checking based on chip id in
*   Init5465Overlay
* Adjusted init code alignment requirements reported to ddraw
* Addressed most of pragma message statements
* Fixed bug in FlipOverlaySurface when surface is clipped
* Enabled overlay shrink caps and added shrink zoom code calculations
*
*    Rev 1.6   29 Jan 1997 18:00:30   RUSSL
* Added use of require macro before register writes
* Modified zoom code calculations
*
*    Rev 1.5   28 Jan 1997 17:34:58   RUSSL
* VEND is the last line shown by the overlay
* Karl and I figured out how to make source color key work (at least at 16bpp)
*   hopefully the code matches what we did manually.  We need an app
*   that uses source color keying to really test it.
*
*    Rev 1.4   28 Jan 1997 15:29:42   RUSSL
* destination color keying is actually done using the hardware CLRKEY
*   registers and setting OCCLUDE in CONTROL0 to 1 (the documentation
*   appears to have the source color key settings & the destination color
*   key settings swapped)
* source color keying doesn't appear to work
*
*    Rev 1.3   27 Jan 1997 19:10:26   RUSSL
* Use a variable dwNumVideoWindows rather than a hardcoded define
* Added WaitForArmToClear, Set5465FlipDuration & PanOverlay1_Init
* Made IsFormatValid return TRUE only for UYVY overlay surfaces for now
* Made CreateSurface use rectangular allocation, specify block size for
*   rgb surfaces if we are managing surface creation, let CreateSurface
*   return NOTHANDLED so DDraw will fill in the surface ptr
* Added error checking for dwReserved1 of local surface struct in case
*   it's NULL
* Added additional debug output
* Put code in ComputeVWZoomCodes, ComputeVWPosData, DetermineColorKeyData,
*   ComputeVWFifoThreshold
* Added programming of the hw registers in RegInitVideoVW & RegMoveVideoVW
*
*    Rev 1.2   21 Jan 1997 15:44:40   RUSSL
* Okay this didn't compile and link last time
*
*    Rev 1.1   21 Jan 1997 14:55:14   RUSSL
* Port of 5480 overlay code from CirrusMM driver to 5465
*
*    Rev 1.0   15 Jan 1997 10:36:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

#if defined WINNT_VER35      // WINNT_VER35
// If WinNT 3.5 skip all the source code
#elif defined (NTDRIVER_546x)
// If WinNT 4.0 and 5462/64 build skip all the source code
#elif defined(WINNT_VER40) && !defined(OVERLAY)
// if nt40 without overlay, skip all the source code
#else

#ifndef WINNT_VER40
#include "ddshared.h"
#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "overlay.h"

#if DDRAW_COMPAT >= 50
#include "vp.h"
#endif

#include "settings.h"
#include "5465bw.h"
#include "swat.inc"
#endif

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifdef WINNT_VER40
#define ENABLE_YUY2                 0
#define ENABLE_YUVPLANAR            0
#define DISABLE_MOST_MODES          0
#else
#define ENABLE_YUY2                 1
#define ENABLE_YUVPLANAR            1
#define DISABLE_MOST_MODES          0
#endif

#define ENABLE_SD_RGB32             1

#define ENABLE_MIRRORING            0

#define HWBUG_24BPP_DST_COLORKEY    1

#ifdef DEBUG
#define INLINE
#else
#define INLINE  __inline
#endif

// VW_CAP0 bits
#define VWCAP_VW_PRESENT      0x00000001

// VW_CONTROL1 bits
#define VW_ByPassClrSpc       0x00000002
#define VW_YShrinkEn          0x00000001

// VW_CONTROL0 bits
#define VW_XShrinkBy2         0x80000000
#define VW_ClkMode2x          0x40000000
#define VW_FIFO_THRSH_EN      0x20000000
#define VW_ALPHA_KEYCMP_EN    0x10000000

#define VW_DB_VPORT_ID_MASK   0x0F000000
#define VW_DB_VSM_ID_MASK     0x00F00000
#define VW_DB_CTL_MASK        0x000F0000

#define VW_SD_FRMT_MASK       0x0000FF00
#define VW_OCCLUDE_MASK       0x000000F0

#define VW_SMTH_INT           0x00000008
#define VW_HMIRR_EN           0x00000004
#define VW_VWE                0x00000002
#define VW_ARM                0x00000001

// Source Data Formats for SD_FRMT
#define SD_YUV422             0x00    // ITU 601 compliant YUV data
#define SD_YUV420             0x03    // ITU 601 compliant YUV data
#define SD_YUV422_FS          0x04    // Full Scale YUV data
#define SD_YVU420_FS          0x07    // Full Scale YUV data
#define SD_RGB16_555          0x08    // 5:5:5
#define SD_RGB16_565          0x09    // 5:6:5
#define SD_RGB32              0x0B    // ARGB

#define SD_FRMT_SHIFT         8

// Occlude types for OCCLUDE
#define NO_OCCLUSION          0       // video window always displayed
#define COLOR_KEY             1       // destination color keying
#define CHROMA_KEY            2       // source color keying

#define OCCLUDE_SHIFT         4

// VW_TEST0 bits
#define VW_PostImed           1
#define VWVRepEnable          0x4

// defines used in Init5465Info()
#define SRC_WIDTH              160
#define SRC_HEIGHT             120
#define MAX_ZOOM              8000
#define MIN_ZOOM               500
#define ZOOM_STEP              100

#ifdef WINNT_VER40
#define lpDDHALData       ((DRIVERDATA *)(&(ppdev->DriverData)))
#define ASSERT(x)
#define DRAW_ENGINE_BUSY  DrawEngineBusy(lpDDHALData)
#endif

#ifdef WINNT_VER40
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#else
#define GET_SURFACE_DATA_PTR(lpSurface)   (LP_SURFACE_DATA)((lpSurface)->dwReserved1)
#endif

#if ENABLE_256_BYTE_FETCH
// bit defs for PERFORMANCE register
#define ECO_256_BYTES_FIX_EN      0x4000
// bit defs for CONTROL2 register
#define MONO_SAFETY_256           0x0080
#define BYTE_REQ_256              0x0010
#endif

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

typedef struct tagVWDATA
{
  WORD  HSTRT;
  WORD  HSDSZ;
  WORD  HEND;
  DWORD HACCUM_STP;
  DWORD HACCUM_SD;
  WORD  VSTRT;
  WORD  VEND;
  DWORD VACCUM_STP;
  DWORD VACCUM_SDA;
  DWORD VACCUM_SDB;
  DWORD PSD_STRT_ADDR;
  DWORD SSD_STRT_ADDR;
#if ENABLE_YUVPLANAR
  DWORD PSD_UVSTRT_ADDR;
  DWORD SSD_UVSTRT_ADDR;
#endif
  WORD  SD_PITCH;
  DWORD CLRKEY_MIN;
  DWORD CLRKEY_MAX;
  DWORD CHRMKEY_MIN;
  DWORD CHRMKEY_MAX;
//  WORD  BRIGHT_ADJ;
//  BYTE  Z_ORDER;
  WORD  FIFO_THRSH;
  DWORD CONTROL1;
  DWORD CONTROL0;
//  DWORD CAP1;
//  DWORD CAP0;
//  DWORD TEST0;
} VWDATA;

typedef struct tagUSERSETTINGS
{
  BOOL  *pVar;
  char  *pRegKey;
  BOOL  defaultVal;
} USERSETTINGS;

#if ENABLE_YUVPLANAR
// structure for CLPL (YUV planar) surface
typedef struct tagCLPLInfo
{
  LPVOID  fpYSurface;     // Y data in first aperture
  LPVOID  fpUSurface;     // U data in 0-2M of fourth aperture
  LPVOID  fpVSurface;     // V data in 2-4M of fourth aperture

  // pointers for CLPLLobotomyMode
  LPVOID  fpUSystemSurface;
  LPVOID  fpVSystemSurface;
  LPVOID  fpRealUSurface; // U data in 0-2M of fourth aperture
  LPVOID  fpRealVSurface; // V data in 2-4M of fourth aperture
} CLPLInfo;

typedef CLPLInfo  *LPCLPLSURFACE;
#endif

/***************************************************************************
* E X T E R N A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
#if DDRAW_COMPAT >= 50
 extern WORD gwNotify;       //#xc
#endif
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define bUseBWEqn               ppdev->DriverData.bUseBWEqn
#define bNoOverlayInThisMode    ppdev->DriverData.bNoOverlayInThisMode

#define lpHardwareOwner         ppdev->DriverData.lpHardwareOwner
#define lpColorSurfaceVW        ppdev->DriverData.lpColorSurfaceVW
#define lpSrcColorSurfaceVW     ppdev->DriverData.lpSrcColorSurfaceVW

#define grOverlaySrc            ppdev->DriverData.grOverlaySrc
#define grOverlayDest           ppdev->DriverData.grOverlayDest
#define gdwFourccVW             ppdev->DriverData.gdwFourccVW
#if ENABLE_MIRRORING
#define bIsVWMirrored           ppdev->DriverData.bIsVWMirrored
#endif

#define gdwAvailVW              ppdev->DriverData.gdwAvailVW              // Next available video window
//#define gwZOrder                ppdev->DriverData.gwZOrder                // default primary on top.
#define gdwColorKey             ppdev->DriverData.gdwColorKey
#define gdwSrcColorKeyLow       ppdev->DriverData.gdwSrcColorKeyLow
#define gdwSrcColorKeyHigh      ppdev->DriverData.gdwSrcColorKeyHigh
#define gdwDestColorKeyOwnerVW  ppdev->DriverData.gdwDestColorKeyOwnerVW  // DstColorKey owner (NULL or FLG_VWX)
#define gdwSrcColorKeyOwnerVW   ppdev->DriverData.gdwSrcColorKeyOwnerVW   // SrcColorKey owner (NULL or FLG_VWX)

#define giOvlyCnt               ppdev->DriverData.giOvlyCnt
#if ENABLE_YUVPLANAR                                            // YUV Planar surfaces cannot exist
#define giPlanarCnt             ppdev->DriverData.giPlanarCnt   // with other overlay surfaces
#define bCLPLLobotomyMode       ppdev->DriverData.bCLPLLobotomyMode
#endif
//#define gbDoubleClock           ppdev->DriverData.gbDoubleClock

#if DISABLE_MOST_MODES
#define bDisableMostModes       ppdev->DriverData.bDisableMostModes
#endif

#else   // Win95

ASSERTFILE("5465over.c");

STATIC DIBENGINE  *pPDevice;
STATIC BOOL       bUseBWEqn;
STATIC BOOL       bNoOverlayInThisMode;

STATIC LPDDRAWI_DDRAWSURFACE_LCL lpHardwareOwner[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpColorSurfaceVW[MAX_VIDEO_WINDOWS];
STATIC LPDDRAWI_DDRAWSURFACE_LCL lpSrcColorSurfaceVW[MAX_VIDEO_WINDOWS];

STATIC RECTL      grOverlaySrc[MAX_VIDEO_WINDOWS];
STATIC RECTL      grOverlayDest[MAX_VIDEO_WINDOWS];
STATIC DWORD      gdwFourccVW[MAX_VIDEO_WINDOWS];
#if ENABLE_MIRRORING
STATIC BOOL       bIsVWMirrored[MAX_VIDEO_WINDOWS];
#endif

STATIC DWORD      gdwAvailVW;    // Next available video window
//STATIC WORD       gwZOrder = OVERLAYZ_PRIMARY_ON_TOP; // default primary on top.
STATIC DWORD      gdwColorKey;
STATIC DWORD      gdwSrcColorKeyLow;
STATIC DWORD      gdwSrcColorKeyHigh;
STATIC DWORD      gdwDestColorKeyOwnerVW = 0; // DstColorKey owner (NULL or FLG_VWX)
STATIC DWORD      gdwSrcColorKeyOwnerVW = 0;  // SrcColorKey owner (NULL or FLG_VWX)

STATIC int        giOvlyCnt[MAX_VIDEO_WINDOWS];
#if ENABLE_YUVPLANAR                          // YUV Planar surfaces cannot exist
STATIC int        giPlanarCnt = 0;            // with other overlay surfaces
STATIC BOOL       bCLPLLobotomyMode;
#endif
//STATIC BOOL       gbDoubleClock;

#if DISABLE_MOST_MODES
STATIC BOOL       bDisableMostModes;
#endif

#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifdef WINNT_VER40

// For NT these are in ppdev->DriverData
#define gsOverlayFlip       ppdev->DriverData.gsOverlayFlip
#define gsProgRegs          ppdev->DriverData.gsProgRegs
#define gvidConfig          ppdev->DriverData.gvidConfig
#define gwNormalDTTR        ppdev->DriverData.gwNormalDTTR
#define dwNumVideoWindows   ppdev->DriverData.dwNumVideoWindows

#if ENABLE_YUVPLANAR
#define bEnableCLPL         ppdev->DriverData.bEnableCLPL
#endif

#else

OVERLAYFLIPRECORD gsOverlayFlip;

PROGREGS    gsProgRegs = {0};  //Make them global so VPE can use the same ones
VIDCONFIG   gvidConfig = {0};
WORD        gwNormalDTTR;
DWORD       dwNumVideoWindows;

#if ENABLE_YUVPLANAR
BOOL        bEnableCLPL;
#endif

#endif

/***************************************************************************
* S T A T I C   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#ifdef WINNT_VER40

static void    GetUserSettings      ( PDEV * );

STATIC HRESULT IsFormatValid        ( PDEV*, DWORD, DWORD );
STATIC HRESULT CreateOverlaySurface ( PDEV*, PDD_SURFACE_LOCAL, DWORD );
STATIC VOID    DestroyOverlaySurface( PDEV*, PDD_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( PDEV*, PDD_FLIPDATA );
STATIC DWORD   LockSurface          ( PDEV*, PDD_LOCKDATA );
STATIC VOID    UnlockSurface        ( PDEV*, PDD_UNLOCKDATA );
STATIC VOID    SetColorKey          ( PDEV*, PDD_SETCOLORKEYDATA );
STATIC DWORD   UpdateSurface        ( PDEV*, PDD_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( PDEV*, PDD_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus ( PDEV*, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );
STATIC VOID    RegMoveVideoVW ( PDEV*, DWORD, PDD_SURFACE_LOCAL );

#else

static void    GetUserSettings      ( void );

STATIC HRESULT IsFormatValid        ( LPGLOBALDATA, DWORD, DWORD );
STATIC HRESULT CreateSurface        ( LPDDRAWI_DDRAWSURFACE_LCL, DWORD,LPGLOBALDATA );
STATIC VOID    DestroySurface       ( LPDDHAL_DESTROYSURFACEDATA );
STATIC DWORD   FlipOverlaySurface   ( LPDDHAL_FLIPDATA );
STATIC DWORD   LockSurface          ( LPDDHAL_LOCKDATA );
STATIC VOID    UnlockSurface        ( LPDDHAL_UNLOCKDATA );
STATIC VOID    SetColorKey          ( LPDDHAL_SETCOLORKEYDATA);
STATIC DWORD   UpdateSurface        ( LPDDHAL_UPDATEOVERLAYDATA );
STATIC DWORD   SetPosition          ( LPDDHAL_SETOVERLAYPOSITIONDATA );
STATIC DWORD   GetOverlayFlipStatus (LPGLOBALDATA, FLATPTR, DWORD );

STATIC BOOL    RegInitVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );
STATIC VOID    RegMoveVideoVW ( DWORD, LPDDRAWI_DDRAWSURFACE_LCL,LPGLOBALDATA );

#endif

/***************************************************************************
* E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#if WINNT_VER40
extern int  CurrentVLine  (PDEV *);
extern VOID GetFormatInfo (LPDDPIXELFORMAT, LPDWORD, LPDWORD);
#endif
#ifdef USE_OLD_BWEQ
extern BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD wScreenX,
  UINT uScreenDepth
); //fix PDR#10381
#endif

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
);

/***************************************************************************
*
* FUNCTION:     MakeVideoWindowFlag
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
MakeVideoWindowFlag ( DWORD dwVWIndex )
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  return ((1 << dwVWIndex) << FLG_VW_SHIFT);
}

#if 0
/***************************************************************************
*
* FUNCTION:     GetDoubleClockStatus
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE DWORD
GetDoubleClockStatus ( VOID )
{
#pragma message("GetDoubleClockStatus not implemented!")
  return FALSE;
}
#endif

/***************************************************************************
*
* FUNCTION:     GetDDHALContext
*
* DESCRIPTION:
*               Get shared data structure (SDATA) pointer
****************************************************************************/
#ifndef WINNT_VER40
INLINE LPGLOBALDATA  GetDDHALContext( LPDDRAWI_DIRECTDRAW_GBL lpGb )
{
#if (DDRAW_COMPAT >= 50)
    if(lpGb->dwReserved3)       //the SDATA pointer is passed by dwReserved3
                                //for DX50    
      return (LPGLOBALDATA)lpGb->dwReserved3;
    else
#endif
     return pDriverData;
}
#endif

/***************************************************************************
*
* FUNCTION:     IsHardwareInUseVW
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL IsVWHardwareInUse
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
  if (VW_VWE & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
    return TRUE;
  return FALSE;
}

/***************************************************************************
*
* FUNCTION:     WaitForArmToClear
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID WaitForVWArmToClear
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  // wait for previous register writes to post
  // the hardware clears the ARM bit at that time
  ASSERT(dwNumVideoWindows > dwVWIndex);
  while (((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 & VW_ARM)
    ;
}

/***************************************************************************
*
* FUNCTION:     EnableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID EnableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
}

/***************************************************************************
*
* FUNCTION:     DisableOverlay
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID DisableOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD dwVWIndex
)
{
  ASSERT(dwNumVideoWindows > dwVWIndex);
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 &=
                ~(VW_FIFO_THRSH_EN | VW_VWE);
  ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
}

/***************************************************************************
*
* FUNCTION:     Set5465FlipDuration
*
* DESCRIPTION:
*
****************************************************************************/

VOID Set5465FlipDuration
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  DWORD dwFlipDuration
)
{
  gsOverlayFlip.dwFlipDuration = dwFlipDuration;
}

/***************************************************************************
*
* FUNCTION:     GetUserSettings
*
* DESCRIPTION:
*
****************************************************************************/

VOID GetUserSettings
(
#ifdef WINNT_VER40
  PDEV  *ppdev
#else
  VOID
#endif
)
{
#ifdef WINNT_VER40

#pragma message("GetUserSettings: Where are laguna settings stored in the NT registry?")
  bUseBWEqn = TRUE;

#if ENABLE_YUVPLANAR
  bEnableCLPL = TRUE;
  bCLPLLobotomyMode = TRUE;
#endif

#else  // else Win95
  static const USERSETTINGS   UserSettings[] =
  {
    { &bUseBWEqn,         "OverlayBW",               TRUE },
#if ENABLE_YUVPLANAR
    { &bEnableCLPL,       "OverlayCLPL",             TRUE },
    { &bCLPLLobotomyMode, "OverlayCLPLLobotomyMode", TRUE },
#endif
#if DISABLE_MOST_MODES
    { &bDisableMostModes, "OverlayBWHack",           TRUE },
#endif
  };

  const USERSETTINGS *pUserSetting;


  for (pUserSetting = &UserSettings[0];
       pUserSetting < &UserSettings[sizeof(UserSettings)/sizeof(UserSettings[0])];
       pUserSetting++)
  {
    *(pUserSetting->pVar) = pUserSetting->defaultVal;
    GetBooleanSetting(pUserSetting->pRegKey,
                      pUserSetting->pVar,
                      LOCATION_OF_3D_PERFORMANCE);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Overlay
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Overlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
  DWORD           dwChipType,
  PDD_HALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable
#else
  DWORD           dwChipType,
  LPDDHALINFO     pDDHALInfo,
  LPOVERLAYTABLE  pOverlayTable,
  LPGLOBALDATA    lpDDHALData
#endif
)
{
  DWORD   dwNumFourCCs;


#ifdef WINNT_VER40
  GetUserSettings(ppdev);
#else
  GetUserSettings();
#endif

  if (! bUseBWEqn)
    gsProgRegs.VW0_FIFO_THRSH = 8;

  // We should check the capabilities register on the chip
  // but it's busted
#ifdef WINNT_VER40
  if (CL_GD5465 == dwChipType)
#else
  if (GD5465_PCI_DEVICE_ID == dwChipType)
#endif
    dwNumVideoWindows = 1;
  else
  {
#if 1
    dwNumVideoWindows = 1;
#else
    int     i;
    PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

    dwNumVideoWindows = 0;
    for (i = 0; i < MAX_VIDEO_WINDOWS; i++)
    {
      if (VWCAP_VW_PRESENT & pREG->VideoWindow[i].grVW_CAP0)
        dwNumVideoWindows++;
    }
#endif
  }

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwMaxVisibleOverlays  = dwNumVideoWindows;
    pDDHALInfo->ddCaps.dwCurrVisibleOverlays = 0;

#ifndef WINNT_VER40
    pPDevice = (DIBENGINE *)lpDDHALData->lpPDevice;
#endif

  // Fill in the caps
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                              |  DDCAPS_OVERLAYFOURCC
                              |  DDCAPS_OVERLAYSTRETCH
                              |  DDCAPS_ALIGNSTRIDE
                              |  DDCAPS_OVERLAYCANTCLIP
                              ;

    pDDHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY
                                      ;

    pDDHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYARITHSTRETCHY
                                |  DDFXCAPS_OVERLAYSTRETCHX
                                |  DDFXCAPS_OVERLAYSTRETCHY
                                |  DDFXCAPS_OVERLAYSHRINKX
                                |  DDFXCAPS_OVERLAYSHRINKY
#if ENABLE_MIRRORING
                                |  DDFXCAPS_OVERLAYMIRRORLEFTRIGHT
#endif
                                ;
  }

  /* FOURCCs supported */
#if (MAX_FOURCCS < 3)
#error dwFourCC array too small
#endif
  dwNumFourCCs = 0;
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_UYVY;
#if ENABLE_YUY2
  lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUY2;
#endif
#if ENABLE_YUVPLANAR
  // add CLPL fourcc if registry key set to "on"
  if (bEnableCLPL)
    lpDDHALData->dwFourCC[dwNumFourCCs++] = FOURCC_YUVPLANAR;
#endif

#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
#endif
  {
    pDDHALInfo->ddCaps.dwNumFourCCCodes = dwNumFourCCs;

    // say we can handle byte alignment and any byte width
    pDDHALInfo->ddCaps.dwAlignBoundarySrc  = 1;   // src rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeSrc      = 1;   // src rect x byte size
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;   // dst rect x byte alignment
    pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;   // dst rect x byte size
    // stride alignment
#ifdef WINNT_VER40
    pDDHALInfo->ddCaps.dwAlignStrideAlign = ppdev->cxMemory;
#else
    pDDHALInfo->ddCaps.dwAlignStrideAlign = pPDevice->deWidthBytes;
#endif

    pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;   // min stretch is 0.5:1
    pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;  // max stretch is 8:1
#ifdef WINNT_VER40
    ppdev->DriverData.dwMinOverlayStretch = 500;
    ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif
    pDDHALInfo->vmiData.dwOverlayAlign     = 8 * 8; // qword alignment in bits
  }

  // Initialize OverlayTable function pointers
  pOverlayTable->pfnCanCreateSurface = IsFormatValid;
#ifdef WINNT_VER40
  pOverlayTable->pfnCreateSurface    = CreateOverlaySurface;
  pOverlayTable->pfnDestroySurface   = DestroyOverlaySurface;
#else
  pOverlayTable->pfnCreateSurface    = CreateSurface;
  pOverlayTable->pfnDestroySurface   = DestroySurface;
#endif
  pOverlayTable->pfnLock             = LockSurface;
  pOverlayTable->pfnUnlock           = UnlockSurface;
  pOverlayTable->pfnSetColorKey      = SetColorKey;
  pOverlayTable->pfnFlip             = FlipOverlaySurface;
  pOverlayTable->pfnUpdateOverlay    = UpdateSurface;
  pOverlayTable->pfnSetOverlayPos    = SetPosition;
  pOverlayTable->pfnGetFlipStatus    = GetOverlayFlipStatus;

  // do mode specific initialization
#ifdef WINNT_VER40
  if (NULL != pDDHALInfo)
    Init5465Info(ppdev, pDDHALInfo);
#else
  Init5465Info(pDDHALInfo, lpDDHALData);
#endif
}

/***************************************************************************
*
* FUNCTION:     Init5465Info
*
* DESCRIPTION:
*
****************************************************************************/

VOID Init5465Info
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  PDD_HALINFO pDDHALInfo
#else
  LPDDHALINFO pDDHALInfo,
  LPGLOBALDATA  lpDDHALData  
#endif
)
{
  // assume we can use overlay in this mode
  bNoOverlayInThisMode = FALSE;

  if (! bUseBWEqn)
    gsProgRegs.DispThrsTiming =
    ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling & 0x3F;

  // Are we double clocked?
//  gbDoubleClock = GetDoubleClockStatus();

  // re-init these on mode change, we might tweak them below
  pDDHALInfo->ddCaps.dwAlignBoundaryDest = 1;
  pDDHALInfo->ddCaps.dwAlignSizeDest     = 1;
  pDDHALInfo->ddCaps.dwMinOverlayStretch = 500;
  pDDHALInfo->ddCaps.dwMaxOverlayStretch = 8000;
#ifdef WINNT_VER40
  ppdev->DriverData.dwMinOverlayStretch = 500;
  ppdev->DriverData.dwMaxOverlayStretch = 8000;
#endif

  // tell ddraw we can do colorkeying
  // we might undo this below
  pDDHALInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY
                                |  DDCKEYCAPS_DESTOVERLAYYUV
                                |  DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAY
                                |  DDCKEYCAPS_SRCOVERLAYYUV
                                |  DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                |  DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV
                                ;
  if (bUseBWEqn)
  {
    DWORD     dwZoom;
    VIDCONFIG vidConfig;
    BWREGS    bwregs;


    // initialize vidConfig
    memset(&vidConfig, 0, sizeof(vidConfig));

    vidConfig.uSrcDepth  = 16;
#ifdef WINNT_VER40
    vidConfig.uDispDepth = ppdev->ulBitCount;
    vidConfig.uGfxDepth  = ppdev->ulBitCount;
#else
    vidConfig.uDispDepth = pPDevice->deBitsPixel;
    vidConfig.uGfxDepth  = pPDevice->deBitsPixel;
#endif
    vidConfig.dwFlags    =  VCFLG_COLORKEY | VCFLG_DISP;

    vidConfig.sizSrc.cx = SRC_WIDTH;
    vidConfig.sizSrc.cy = SRC_HEIGHT;
    if(gvidConfig.dwFlags & VCFLG_CAP)
    {
      //if video port is on, includes it for BWE
        vidConfig.dwFlags |= VCFLG_CAP;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.sizCap = gvidConfig.sizCap;
        vidConfig.sizXfer = gvidConfig.sizXfer;
        vidConfig.dwXferRate = gvidConfig.dwXferRate;
        vidConfig.uXferDepth = gvidConfig.uXferDepth;
        vidConfig.uCapDepth = gvidConfig.uCapDepth;
        vidConfig.uSrcDepth = gvidConfig.uSrcDepth;
    }
#ifdef WINNT_VER40
    ChipIOReadBWRegs(ppdev, &bwregs);
#else
    ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
#ifdef USE_OLD_BWEQ
    //Kill overlay for some modes
#ifdef WINNT_VER40
    if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
    if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
      bNoOverlayInThisMode = TRUE;
    else
#endif
    {
        // stupid linear search for min & max zoom factors

        // Check bandwidth to find the maximum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MAX_ZOOM;
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom -= ZOOM_STEP;
        } while (dwZoom > 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
          bNoOverlayInThisMode = TRUE;

        // Check bandwidth to find the minimum zoom factor of 16 bit data
        // with colorkey
        dwZoom = MIN_ZOOM;
#ifdef USE_OLD_BWEQ
        // disable overlay shrink in 24bpp modes
#ifdef WINNT_VER40
        if (24 == ppdev->ulBitCount)
#else
        if (24 == pPDevice->deBitsPixel)
#endif
          dwZoom = 1000;
#endif
        do
        {
          vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
          vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

          if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
          {
    #ifndef WINNT_VER40
            DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

            pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
            ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
            break;
          }
          dwZoom += ZOOM_STEP;
        } while (dwZoom < 4000);
        if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
          bNoOverlayInThisMode = TRUE;
    }
    // I'll leave this code in here but so far I have only seen that if
    // we don't have enough bandwidth to use overlay with colorkey then
    // we don't have enough bandwidth period

    // try to see if there's enough bandwidth to use overlay without colorkey
    if (TRUE == bNoOverlayInThisMode)
    {
      // reset this in case we find enough bandwidth to use overlay
      // without colorkey
      bNoOverlayInThisMode = FALSE;

      // retry without colorkey available
      // tell ddraw we don't do colorkeying
      pDDHALInfo->ddCaps.dwCKeyCaps &= ~(DDCKEYCAPS_DESTOVERLAY
                                    |    DDCKEYCAPS_DESTOVERLAYYUV
                                    |    DDCKEYCAPS_DESTOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAY
                                    |    DDCKEYCAPS_SRCOVERLAYYUV
                                    |    DDCKEYCAPS_SRCOVERLAYONEACTIVE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACE
                                    |    DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV)
                                    ;

#ifdef USE_OLD_BWEQ
#ifdef WINNT_VER40
      if(KillOverlay(ppdev, (WORD)ppdev->cxScreen, (UINT)ppdev->ulBitCount))
#else
      if(KillOverlay( pPDevice->deWidth,pPDevice->deBitsPixel))
#endif
          bNoOverlayInThisMode = TRUE;
      else
#endif
      {
           // Check bandwidth to find the maximum zoom factor of 16 bit data
          dwZoom = MAX_ZOOM;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Maximum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMaxOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMaxOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom -= ZOOM_STEP;
          } while (dwZoom > 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMaxOverlayStretch)
            bNoOverlayInThisMode = TRUE;

          // Check bandwidth to find the minimum zoom factor of 16 bit data
          dwZoom = MIN_ZOOM;
          // disable overlay shrink in 24bpp modes
    #ifdef WINNT_VER40
          if (24 == ppdev->ulBitCount)
    #else
          if (24 == pPDevice->deBitsPixel)
    #endif
            dwZoom = 1000;
          do
          {
            vidConfig.sizDisp.cx = (SRC_WIDTH  * dwZoom) / 1000;
            vidConfig.sizDisp.cy = (SRC_HEIGHT * dwZoom) / 1000;

            if (ChipIsEnoughBandwidth(&gsProgRegs, &vidConfig, &bwregs))
            {
    #ifndef WINNT_VER40
              DBG_MESSAGE(("Minimum zoom factor: %d", dwZoom));
    #endif

              pDDHALInfo->ddCaps.dwMinOverlayStretch = dwZoom;

    #ifdef WINNT_VER40
              ppdev->DriverData.dwMinOverlayStretch = dwZoom;
    #endif
              break;
            }
            dwZoom += ZOOM_STEP;
          } while (dwZoom < 4000);
          if (dwZoom != pDDHALInfo->ddCaps.dwMinOverlayStretch)
            bNoOverlayInThisMode = TRUE;
      }
#ifdef DEBUG
      if (bNoOverlayInThisMode)
      {
        ERRORLOG(("  overlay disabled in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
      else
      {
        ERRORLOG(("  overlay colorkey not supported in %ldx%ldx%ld",
                  (DWORD)pPDevice->deWidth,
                  (DWORD)pPDevice->deHeight,
                  (DWORD)pPDevice->deBitsPixel));
      }
#endif
    }
    // see if we're in interlaced mode, if so disable overlay
    if (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A)
      bNoOverlayInThisMode = TRUE;

#if DISABLE_MOST_MODES
    if (bDisableMostModes)
    {
      PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;

      // disable overlay support for 1024x768 and above
      if ((1024 <= pPDevice->deWidth) && ( 768 <= pPDevice->deHeight))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 640x480x32@85Hz
      if ((640 == pPDevice->deWidth)     &&
          (480 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x33 == pREG->grSRE)          &&
          (0x7E == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
      // disable overlay support for 800x600x32@85Hz
      if ((800 == pPDevice->deWidth)     &&
          (600 == pPDevice->deHeight)    &&
          ( 32 == pPDevice->deBitsPixel) &&
          (0x1C == pREG->grSRE)          &&
          (0x37 == pREG->grSR1E))
        bNoOverlayInThisMode = TRUE;
    }
#endif

#if 0
// TDDRAW.EXE error return from UpdateOverlay in to following cases
    if (ppdev->ulBitCount == 8 && ppdev->cxScreen == 1280)
    {
      if ( (ppdev->cyScreen == 1024 && ppdev->ulFreq >= 72) ||
           (ppdev->cyScreen ==  960 && ppdev->ulFreq >= 85) )
        bNoOverlayInThisMode = TRUE;
    }
    if ( ppdev->cxScreen == 640 &&
         ppdev->cyScreen == 350 )
       bNoOverlayInThisMode = TRUE;
#endif// 0

    // if no overlay in this mode set min & max overlay stretch to 0
    if (TRUE == bNoOverlayInThisMode)
    {
      pDDHALInfo->ddCaps.dwMinOverlayStretch = 0;
      pDDHALInfo->ddCaps.dwMaxOverlayStretch = 0;
#ifdef WINNT_VER40
      ppdev->DriverData.dwMinOverlayStretch = 0;
      ppdev->DriverData.dwMaxOverlayStretch = 0;
#endif
    }
  }

#if HWBUG_24BPP_DST_COLORKEY
#ifdef WINNT_VER40
  if (24 == ppdev->ulBitCount)
#else
  if (24 == pPDevice->deBitsPixel)
#endif
  {
    // disable destination colorkey support at 24bpp
    // the hardware appears to be busted
    pDDHALInfo->ddCaps.dwCKeyCaps &= ~(  DDCKEYCAPS_DESTOVERLAY
                                       | DDCKEYCAPS_DESTOVERLAYYUV
                                       | DDCKEYCAPS_DESTOVERLAYONEACTIVE);
  }
#endif

#if 0
  // When double clocking (i.e. 1280x1024), the minimum
  // zoom is 2X.
  if ((gbDoubleClock) && (pDDHALInfo->ddCaps.dwMinOverlayStretch < 2000))
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 2000;
  }

  // don't use overlay in the 1X case.
  if (pDDHALInfo->ddCaps.dwMinOverlayStretch < 1500)
  {
    pDDHALInfo->ddCaps.dwMinOverlayStretch = 1500;
  }

  // Specify destination requirements.
  if ((BITSPERPIXEL == 24) || gbDoubleClock)
  {
    pDDHALInfo->ddCaps.dwCaps |= DDCAPS_ALIGNBOUNDARYDEST
                              |  DDCAPS_ALIGNSIZEDEST
                              ;
    pDDHALInfo->ddCaps.dwAlignBoundaryDest = 4;
    pDDHALInfo->ddCaps.dwAlignSizeDest = 4;
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     IsFormatValid
*
* DESCRIPTION:  This function verifies that the overlay hardware can
*               support the specified format.
*
****************************************************************************/

STATIC HRESULT IsFormatValid
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD dwFourcc,
  DWORD dwBitCount
)
{
  DWORD i;


#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid (dwFourcc = 0x%08lX, dwBitCount = 0x%08lX)",
               dwFourcc, dwBitCount));
#endif

	// see if we're in interlaced mode
	// if so then don't allow overlay surface to be created
  // also if there isn't enough bandwidth then fail all
  // overlay surface CanCreate requests
  if (bNoOverlayInThisMode || (1 & ((PVGAR)lpDDHALData->RegsAddress)->grCR1A))
    return DDERR_CURRENTLYNOTAVAIL;

  for (i = 0; i < dwNumVideoWindows; i++)
  {
    // see if ddraw thinks the video window is available
    // and make sure VPM isn't using it
    if ((0 == giOvlyCnt[i]) &&
#ifdef WINNT_VER40
        (! IsVWHardwareInUse(ppdev,i))
#else
        (! IsVWHardwareInUse(lpDDHALData,i))
#endif
       )
    {
    #ifndef WINNT_VER40
      DBG_MESSAGE(("Video Window %d available", i));
    #endif

      // I'll say YUCK again!
      // I hate this, what if VPM sneaks in between a CanCreateSurface
      // call and a CreateSurface call and grabs this video window
      // Guess we'll just say the creation succeeded but then fail all use
      // of the video window
      gdwAvailVW = MakeVideoWindowFlag(i);
      break;
    }
  }
  if (dwNumVideoWindows == i)
  {
    DBG_MESSAGE(("All video windows in use, returning FALSE"));
    return DDERR_CURRENTLYNOTAVAIL;
  }

  // only support 5:5:5, 5:6:5 and UYVY overlay surfaces
  if (   ((dwFourcc != BI_RGB) || (dwBitCount != 16))
#if ENABLE_SD_RGB32
      && ((dwFourcc != BI_RGB) || (dwBitCount != 32))
#endif
      && (dwFourcc != BI_BITFIELDS)
      && (dwFourcc != FOURCC_UYVY)
#if ENABLE_YUY2
      && (dwFourcc != FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      && (dwFourcc != FOURCC_YUVPLANAR)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("IsFormatValid5465: returning FALSE, FourCC = %08lX", dwFourcc));
#endif

    return DDERR_INVALIDPIXELFORMAT;
  }

#ifndef WINNT_VER40
  DBG_MESSAGE(("IsFormatValid5465: returning TRUE, FourCC = %08lX", dwFourcc));
#endif

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     CreateSurface
*
* DESCRIPTION:  This function sets various flags depending on what
*               is happening.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC HRESULT CreateOverlaySurface(
#else
STATIC HRESULT CreateSurface(
#endif
#ifdef WINNT_VER40
  PDEV                      *ppdev,
  PDD_SURFACE_LOCAL         lpSurface,
  DWORD                     dwFourcc
#else
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  DWORD                     dwFourcc,
  LPGLOBALDATA               lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  DWORD             dwVWIndex;


  // For non-RGB surfaces, we must always specify the block size.
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay CreateSurface (lpSurface = %08lX, dwFourcc = %08lX)",
               lpSurface, dwFourcc));
#endif

  lpSurfaceData->dwOverlayFlags |= FLG_OVERLAY;

#ifdef WINNT_VER40
	if (gdwAvailVW == 0)
	{
		UINT i;
		for (i = 0; i < dwNumVideoWindows; i++)
		{
			// see if ddraw thinks the video window is available
			// and make sure VPM isn't using it
			if ( (giOvlyCnt[i] == 0) && ! IsVWHardwareInUse(ppdev,i) )
			{
				gdwAvailVW = MakeVideoWindowFlag(i);
				break;
			}
		}
		if (i == dwNumVideoWindows)
		{
			DBG_MESSAGE(("All video windows in use, returning FALSE"));
			return DDERR_CURRENTLYNOTAVAIL;
		}
	}
#endif

  dwVWIndex = GetVideoWindowIndex(gdwAvailVW);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  lpSurfaceData->dwOverlayFlags |= gdwAvailVW;
  gdwFourccVW[dwVWIndex] = dwFourcc;

  if (   (dwFourcc == FOURCC_UYVY)
#if ENABLE_YUY2
      || (dwFourcc == FOURCC_YUY2)
#endif
#if ENABLE_YUVPLANAR
      || (dwFourcc == FOURCC_YUVPLANAR)
#endif
     )
  {
    lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
    lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
    lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;

    if (dwFourcc == FOURCC_UYVY)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_UYVY;
    }
#if ENABLE_YUY2
    else if (dwFourcc == FOURCC_YUY2)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUY2;
    }
#endif
#if ENABLE_YUVPLANAR
    else // if (dwFourcc == FOURCC_YUVPLANAR)
    {
      lpSurfaceData->dwOverlayFlags |= FLG_YUVPLANAR;
      giPlanarCnt++;

      lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 12;

      //allocate a CLPLInfo structure
      lpSurfaceData->lpCLPLData = HEAP_ALLOC(hSharedHeap,
                                             HEAP_ZERO_MEMORY,
                                             sizeof(CLPLInfo),
                                             OWNER_OVERLAY,
                                             (DWORD)lpSurface);
      if (0 == lpSurfaceData->lpCLPLData)
      {
        return DDERR_OUTOFMEMORY;
      }
      if (bCLPLLobotomyMode)
      {
        LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;
        DWORD           dwSize;

        dwSize = (lpSurface->lpGbl->wWidth * lpSurface->lpGbl->wHeight) / 2;
        lpCLPL->fpUSystemSurface = HEAP_ALLOC(hSharedHeap,
                                              HEAP_ZERO_MEMORY,
                                              dwSize,
                                              OWNER_OVERLAY,
                                              (DWORD)lpSurface);
        if (0 == lpCLPL->fpUSystemSurface)
        {
          HEAP_FREE(hSharedHeap, 0, (LPVOID)lpSurfaceData->lpCLPLData);
          lpSurfaceData->lpCLPLData = NULL;
          return DDERR_OUTOFMEMORY;
        }
        lpCLPL->fpVSystemSurface = (LPVOID)((DWORD)(lpCLPL->fpUSystemSurface) + dwSize / 2);

        DBG_MESSAGE(("CLPL lobotomy mode addrs: USys=%08lX, VSys=%08lX, size=%08lX",
                     lpCLPL->fpUSystemSurface, lpCLPL->fpVSystemSurface, dwSize));
      }
    }
#endif
  }

  if(giOvlyCnt[dwVWIndex] == 0 )
  {
    // save copy of current DTTR value
#if DDRAW_COMPAT >= 50
    gwNotify |= OVERLAY_ON;
    //if VPE is created this variable is already initialized
    if(!(gwNotify & VPE_ON))
#endif
    {
      gwNormalDTTR = ((PVGAR)lpDDHALData->RegsAddress)->grDisplay_Threshold_and_Tiling;
    }
  }
  giOvlyCnt[dwVWIndex]++;

  // CreateSurface32 fills in block size
  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     DestroySurface
*
* DESCRIPTION:  This does misc things when an overlay surface is
*               destroyed.
*
****************************************************************************/

#ifdef WINNT_VER40
STATIC VOID DestroyOverlaySurface(
#else
STATIC VOID DestroySurface(
#endif
#ifdef WINNT_VER40
  PDEV                    *ppdev,
  PDD_DESTROYSURFACEDATA  lpInput
#else
  LPDDHAL_DESTROYSURFACEDATA lpInput
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
  LP_SURFACE_DATA lpSurfaceData;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay DestroySurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
  {
    // Turn the video off
#ifndef WINNT_VER40
    DBG_MESSAGE(("Turning off VW %ld in DestroySurface", dwVWIndex));
#endif

#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif

    lpHardwareOwner[dwVWIndex] = NULL;

    // clear show bit if panning of desktop enabled
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    if (giPlanarCnt > 0)
    {
      LPCLPLSURFACE   lpCLPL = lpSurfaceData->lpCLPLData;

      giPlanarCnt--;
      if (0 != lpCLPL)
      {
        if ((bCLPLLobotomyMode) && (0 != lpCLPL->fpUSystemSurface))
          HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL->fpUSystemSurface);
        // Free up the memory for the CLPLInfo structure
        HEAP_FREE(hSharedHeap, 0, (LPVOID)lpCLPL);
      }
    }
  }
#endif
  if (lpSurfaceData->dwOverlayFlags & FLG_VW_MASK)
  {
    if (giOvlyCnt[dwVWIndex] > 0)
    {
      if (0 == --giOvlyCnt[dwVWIndex])
      {
        // get current DTTR, mask off FIFO threshold
        WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling & 0xFFC0;

#if DDRAW_COMPAT >= 50
        gvidConfig.dwFlags    &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                                      VCFLG_DISP | VCFLG_420);

        gwNotify &= ~OVERLAY_ON;
        if(!(gwNotify & VPE_ON))
#endif
        {
        // Fix PDR 9574: Restore FIFO threshold value when overlay surface
        // is destroyed, do not restore the tile size.
        // If tile size has changed, we are likely in the middle of changing
        // video mode.  No need to resotre FIFO in this case.
          if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) ) {  // check tile size
             pREG->grDisplay_Threshold_and_Tiling =
                  CurrentDTTR | (gwNormalDTTR & 0x003F); // reset FIFO Threshold
           }
        }
      }
    }
  }

  // Clear up the ownership of Dest ColorKey.
  gdwDestColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

  // Clear up the ownership of Src ColorKey.
  gdwSrcColorKeyOwnerVW &= ~(lpSurfaceData->dwOverlayFlags & FLG_VW_MASK);

#if 0
  if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
  {
    // Disable Video Capture.
#pragma message("Destroy Surface")
#pragma message("  Who turned on video capture?")
#pragma message("  Shouldn't they shut it off?")
#pragma message("  How do I disable video capture on this fraggin' thing?")
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     FlipOverlaySurface
*
* DESCRIPTION:  This function is called by DDDRV when it wants to flip the
*               overlay surface.
*
****************************************************************************/

STATIC DWORD FlipOverlaySurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_FLIPDATA  lpFlipData
#else
  LPDDHAL_FLIPDATA lpFlipData
#endif
)
{
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpFlipData->lpDD);
#endif
  DWORD           dwOffset,dwOffset2;
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwFourcc;
  DWORD           dwBitCount;
  PVGAR           pREG = (PVGAR)lpDDHALData->RegsAddress;
  DWORD           dwVWIndex;
#if DDRAW_COMPAT >= 50
  DWORD           dwControl0;
  DWORD           dwSrfFlags = FALSE;
#endif
  DWORD           dwSurfBase, dwSurfOffset;


#ifndef WINNT_VER40
  DBG_MESSAGE(("FlipOverlaySurface (lpFlipData = 0x%08lX)", lpFlipData));
#endif

  if (0 == lpFlipData->lpSurfCurr->dwReserved1)
  {
    lpFlipData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpFlipData->lpSurfCurr);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // When TVTap/VPM is used with DirectDraw, things got more twisted.
  // VPM doesn't call UpdateSurface, so lpHardwareOwner
  // won't be set, nevertheless, the HW is grabbed by VPM.
  // In that case, should fail the Flip call to prevent bad VPM.

  // YUCK!!!
  // The VWE bit in the hardware seems to be the semaphore for sharing the
  // overlay with VPM

  if ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
      IsVWHardwareInUse(ppdev, dwVWIndex)
#else
      IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
     )
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("VW %ld already in use, Out of Caps!", dwVWIndex));
#endif

    lpFlipData->ddRVal = DDERR_OUTOFCAPS;
    return (DDHAL_DRIVER_HANDLED);
  }

#ifdef WINNT_VER40
  if(GetOverlayFlipStatus(ppdev, 0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#else
  if(GetOverlayFlipStatus(lpDDHALData,0, dwVWIndex) != DD_OK || DRAW_ENGINE_BUSY || IN_VBLANK)
#endif
  {
    lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

  // Determine the format of the video data
  if (lpFlipData->lpSurfTarg->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpFlipData->lpSurfTarg->lpGbl->ddpfSurface),
                   &dwFourcc,
                   &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
  }

  // Determine the offset to the new area.
#ifdef WINNT_VER40
  dwSurfBase = lpFlipData->lpSurfTarg->lpGbl->fpVidMem;
#else
  dwSurfBase = (lpFlipData->lpSurfTarg->lpGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = lpSurfaceData->dwOverlayOffset;
  dwOffset = dwSurfBase + dwSurfOffset;

#if ENABLE_MIRRORING
  // Flip the overlay surface by changing PSD_STRT_ADDR
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    dwOffset += (DWORD)(grOverlaySrc[dwVWIndex].right -
                        grOverlaySrc[dwVWIndex].left  - 1);
  }
#endif
  dwOffset2 = 0;
#if DDRAW_COMPAT >= 50
  dwControl0 =  pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort != NULL)
  {
     if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
             &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                      &DDVP_AUTOFLIP)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom != NULL)
             && (lpFlipData->lpSurfTarg->lpAttachListFrom->lpAttached != NULL))
     {
        dwSrfFlags = DDOVER_AUTOFLIP;
     }
     else if(( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpFlipData->lpSurfTarg->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
           & DDVP_INTERLEAVE))
     {
        dwSrfFlags = DDOVER_BOB;
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line
     }
  }

  if(dwSrfFlags & DDOVER_BOB)
  {
       //Smooth interlace
       dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch; //point to the next line

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {
    //Auto Flip Overlay
        dwOffset2 = lpSurfaceData->dwAutoBaseAddr2 + dwSurfOffset;
        if(dwOffset2 == dwOffset)
        {
           dwOffset = lpSurfaceData->dwAutoBaseAddr1 + dwSurfOffset;
        }
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
        if(!(lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
        {
           DWORD dwTmp = dwOffset;
           dwOffset = dwOffset2;
           dwOffset2 = dwTmp;
        }
  }
  else if( lpFlipData->lpSurfTarg->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)
  {
    dwControl0 &= ~0x30000;
    if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
    {
        dwOffset2 = dwOffset +
            lpFlipData->lpSurfTarg->lpGbl->lPitch ; //point to the next line
        dwControl0 |= 0x10000;  //use VW_SDD

    }
  }
  else if(lpFlipData->dwFlags & DDFLIP_ODD)    //SW flip
  {
        dwOffset2 = dwOffset;
        dwControl0 &= ~0x30000;
        dwControl0 |= 0x10000;  //use VW_SDD
  }
#endif

  // write new start address to hardware
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev,dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData,dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, dwOffset);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, dwOffset2);
#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // PSD_STRT_ADDR has been set to the start of the Y data in aperture0
    // set PSD_UVSTRT_ADDR to start of UV interleaved data in aperture 0
    // UV data is only half the height of Y data
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR,
         dwSurfBase +
         (((lpFlipData->lpSurfTarg->lpGbl->wHeight * lpFlipData->lpSurfTarg->lpGbl->lPitch) + 7) & ~7) +
         (dwSurfOffset / 2));
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, dwOffset2);
  }
#endif

#if DDRAW_COMPAT >= 50
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = (dwControl0 |VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 = dwControl0 | VW_ARM;
#else
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= (VW_VWE | VW_ARM);
  else
    pREG->VideoWindow[dwVWIndex].grVW_CONTROL0 |= VW_ARM;
#endif

#ifdef WINNT_VER40
  // Update the hardware owner
  lpHardwareOwner[dwVWIndex] = lpFlipData->lpSurfTarg;
#endif

  // remember where/when we were when we did the flip
#ifdef WINNT_VER40
  EngQueryPerformanceCounter(&gsOverlayFlip.liFlipTime);
#else
  QueryPerformanceCounter((LARGE_INTEGER *)&gsOverlayFlip.liFlipTime);
#endif
#ifdef WINNT_VER40
  gsOverlayFlip.dwFlipScanline = CurrentVLine(ppdev);
#else
  gsOverlayFlip.dwFlipScanline = CurrentVLine(lpDDHALData);
#endif
  gsOverlayFlip.bFlipFlag = TRUE;
  gsOverlayFlip.fpFlipFrom = lpFlipData->lpSurfCurr->lpGbl->fpVidMem;
  gsOverlayFlip.bHaveEverCrossedVBlank = FALSE;

  if (IN_VBLANK)
  {
    gsOverlayFlip.bWasEverInDisplay = FALSE;
  }
  else
  {
    gsOverlayFlip.bWasEverInDisplay = TRUE;
  }

  lpFlipData->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     LockSurface
*
* DESCRIPTION:  Checks for flipping before allowing access to the surface.
*
****************************************************************************/

STATIC DWORD LockSurface
(
#ifdef WINNT_VER40
  PDEV          *ppdev,
  PDD_LOCKDATA  lpInput
#else
  LPDDHAL_LOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
  DWORD           dwUVOffset;
#endif
  LP_SURFACE_DATA lpSurfaceData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay LockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Check for flipping
  if ((gsOverlayFlip.bFlipFlag) &&
      (
#ifdef WINNT_VER40
       GetOverlayFlipStatus(ppdev, lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#else
       GetOverlayFlipStatus(lpDDHALData,lpInput->lpDDSurface->lpGbl->fpVidMem, dwVWIndex)
#endif
        == DDERR_WASSTILLDRAWING))
  {
    lpInput->ddRVal = DDERR_WASSTILLDRAWING;
    return DDHAL_DRIVER_HANDLED;
  }

#if ENABLE_YUVPLANAR
  if (lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
  {
    // make sure CLPL aperture is mapped in
    if (! lpDDHALData->dwCLPLAperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    // here's how this YUV420/YUVPLANAR/CLPL stuff works:
    // the CLPL surface consists of all the Y data followed by a region of
    // UV interleaved data.  We are currently supporting only linear surfaces
    // for CLPL so there will be wHeight lines of Y data followed by wHeight/2
    // lines of UV interleaved data.  CreateSurface32 has padded the surface
    // allocation such that the UV interleaved data will start on the first
    // quadword boundary following the Y data.
    //
    // We pass back a pointer to a structure containing the address of a Y
    // region, a U region and a V region to the app.  The app writes to the
    // U and V regions as if they are linear and the hardware converts this
    // data into the UV interleaved data in aperture 0.
    //
    // For the U ptr we give the app an address pointing somewhere in the
    // first four meg of aperture 3 and for the V ptr we give the app an
    // address pointing to the same somewhere but in the second four meg
    // of aperture 3.  When the app writes to these addresses, the data
    // shows up in aperture 0 such that:
    //    the U data is at   ap0_offset = ap3_offset * 2
    //    the V data is at   ap0_offset = (ap3_offset - 4MB) * 2 + 1
    //
    // what we need to do then is give the app the folloing ptrs:
    //   Y ptr = ap0_offset of the Y region (the beginning of the surface)
    //   U ptr = ap3_offset for U data = U_ap0_offset / 2
    //   V ptr = ap3_offset for V data = (V_ap0_offset - 1) / 2 + 4MB
    // where U_ap0_offset = offset we want the U data to start
    //   and V_ap0_offset = offset we want the V data to start
    // we also need V_ap0_offset = U_ap0_offset + 1

    // Compute Y and UV aperture in frame buffer
    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;
    lpInput->lpSurfData = (LPVOID)lpCLPL;

    // Y data starts at beginning of surface in aperture0
    lpCLPL->fpYSurface = (LPVOID)lpInput->lpDDSurface->lpGbl->fpVidMem;

    DBG_MESSAGE(("Aperture0 Y offset = %08lX",
                 (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress)));
    DBG_MESSAGE(("  surface height = %08lX, pitch = %08lX",
                 lpInput->lpDDSurface->lpGbl->wHeight,
                 lpInput->lpDDSurface->lpGbl->lPitch));

    // determine offset of UV data in aperture 0 (and make it qword aligned)
    dwUVOffset = (lpInput->lpDDSurface->lpGbl->fpVidMem - lpDDHALData->ScreenAddress) +
                 (((lpInput->lpDDSurface->lpGbl->wHeight * lpInput->lpDDSurface->lpGbl->lPitch) + 7) & ~7);
    DBG_MESSAGE(("Aperture0 UV offset = %08lX", dwUVOffset));

    // convert UV aperture0 offset to aperture3 offset
    DBG_MESSAGE(("Aperture3 UV offset = %08lX", dwUVOffset / 2));
    dwUVOffset = lpDDHALData->dwCLPLAperture + dwUVOffset / 2;

    if (bCLPLLobotomyMode)
    {
      lpCLPL->fpRealUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpRealVSurface = (LPVOID)(dwUVOffset + 0x400000);
      DBG_MESSAGE(("CLPL lobotomy mode addrs: RealU=%08lX, RealV=%08lX",
                   lpCLPL->fpRealUSurface, lpCLPL->fpRealVSurface));
      lpCLPL->fpUSurface = lpCLPL->fpUSystemSurface;
      lpCLPL->fpVSurface = lpCLPL->fpVSystemSurface;
    }
    else
    {
      lpCLPL->fpUSurface = (LPVOID)(dwUVOffset);
      lpCLPL->fpVSurface = (LPVOID)(dwUVOffset + 0x400000);
    }

    DBG_MESSAGE(("CLPL addrs: Y=%08lX, U=%08lX, V=%08lX",
                 lpCLPL->fpYSurface, lpCLPL->fpUSurface, lpCLPL->fpVSurface));

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#if ENABLE_YUY2
  // Force them to use the byte swap aperture
  if (lpSurfaceData->dwOverlayFlags & FLG_YUY2)
  {
    // make sure the YUY2 aperture is mapped in
    if (! lpDDHALData->dwYUY2Aperture)
    {
      lpInput->ddRVal = DD_OK;
      return DDHAL_DRIVER_NOTHANDLED;
    }

    lpInput->lpSurfData = (LPVOID) ((lpInput->lpDDSurface->lpGbl->fpVidMem -
                                     lpDDHALData->ScreenAddress) +
                                     lpDDHALData->dwYUY2Aperture);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_NOTHANDLED;
}

#if ENABLE_YUVPLANAR
/***************************************************************************
*
* FUNCTION:    SysToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

#if 1
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#else
// writing the scanline from right to left shows the hwbug where roughly
// every other 4 dwords written to aperture3 is dropped
// and the video is generally display with a lovely flourescent green
// checkerboard pattern
//
// This duplicates the problem seen by allowing the Compcore MPEG player
// write directly to aperture3
#pragma optimize("", off)
// the compiler ignores __inline because of the inline assembly
static INLINE VOID
SysToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  _asm    std

  dst += dstPitch - sizeof(DWORD);
  src += srcPitch - sizeof(DWORD);

  while (0 < yext--)
  {
    _asm
    {
          mov   eax,xext
          mov   edi,dst
          mov   esi,src
          mov   ecx,eax
          shr   ecx,2
      rep movsd
          mov   ecx,eax
          and   ecx,3
      rep movsb
    }
    dst += dstPitch;
    src += srcPitch;
  }

  _asm    cld
}
#pragma optimize("", on)
#endif
#endif

/***************************************************************************
*
* FUNCTION:     UnlockSurface
*
* DESCRIPTION:  This function is called by DDHAL when it is finished accessing
*               the frame buffer.
*
****************************************************************************/

STATIC VOID UnlockSurface
(
#ifdef WINNT_VER40
  PDEV            *ppdev,
  PDD_UNLOCKDATA  lpInput
#else
  LPDDHAL_UNLOCKDATA lpInput
#endif
)
{
#if ENABLE_YUVPLANAR
  LPCLPLSURFACE   lpCLPL;         // pointer to our YUV planar
#endif
  LP_SURFACE_DATA lpSurfaceData;


#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UnlockSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

#if ENABLE_YUVPLANAR
  if ((lpSurfaceData->dwOverlayFlags & FLG_YUVPLANAR) && bCLPLLobotomyMode)
  {
    REG32 ext;
    LONG  pitch;

    lpCLPL = (LPCLPLSURFACE)lpSurfaceData->lpCLPLData;

    ext.pt.X = lpInput->lpDDSurface->lpGbl->wWidth / 2;
    ext.pt.Y = lpInput->lpDDSurface->lpGbl->wHeight / 2;
    pitch = lpInput->lpDDSurface->lpGbl->lPitch / 2;

    SysToFBCopy(lpCLPL->fpRealUSurface, pitch, lpCLPL->fpUSystemSurface, pitch, ext, 1);
    SysToFBCopy(lpCLPL->fpRealVSurface, pitch, lpCLPL->fpVSystemSurface, pitch, ext, 1);
  }
#endif
}

/***************************************************************************
*
* FUNCTION:     SetColorKey
*
* DESCRIPTION:  Looks at the color key for changes in the while
*               overlay is active.
*
****************************************************************************/

STATIC VOID SetColorKey
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_SETCOLORKEYDATA   lpInput
#else
  LPDDHAL_SETCOLORKEYDATA lpInput
#endif
)
{
  LP_SURFACE_DATA lpSurfaceData;
  LP_SURFACE_DATA lpHWOwnerData;
  DWORD           dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetColorKey (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return;
  }
  lpSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSurface);

  dwVWIndex = GetVideoWindowIndex(lpSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if ((lpInput->dwFlags & DDCKEY_DESTOVERLAY) &&
      (lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else is already using the colorkey.
    if ((gdwDestColorKeyOwnerVW & FLG_VW_MASK) &&
        (lpInput->lpDDSurface != lpColorSurfaceVW[dwVWIndex]))
    {
      // ColorKey already being used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }

    // You get here only when the call is issued AFTER UpdateOverlay.
    gdwColorKey = lpInput->ckNew.dwColorSpaceLowValue;

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpInput->lpDDSurface == lpColorSurfaceVW[dwVWIndex]) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwDestColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
  else if ((lpInput->dwFlags & DDCKEY_SRCOVERLAY) &&
           (lpInput->lpDDSurface == lpSrcColorSurfaceVW[dwVWIndex]))
  {
    // See if someone else already uses the colorkey.
    if ((gdwSrcColorKeyOwnerVW != 0 ) &&
        !(gdwSrcColorKeyOwnerVW & lpSurfaceData->dwOverlayFlags))
    {
      // ColorKey already been used.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return;
    }
    gdwSrcColorKeyLow = lpInput->ckNew.dwColorSpaceLowValue;
    gdwSrcColorKeyHigh = lpInput->ckNew.dwColorSpaceHighValue;
    if (gdwSrcColorKeyLow > gdwSrcColorKeyHigh)
    {
      gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
    }

    if (0 == lpHardwareOwner[dwVWIndex]->dwReserved1)
    {
      lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
      return;
    }
    lpHWOwnerData = GET_SURFACE_DATA_PTR(lpHardwareOwner[dwVWIndex]);

    if ((lpSurfaceData->dwOverlayFlags & FLG_VW_MASK) &&
        (lpHardwareOwner[dwVWIndex]) &&
        (lpHWOwnerData->dwOverlayFlags & FLG_ENABLED))
    {
      gdwSrcColorKeyOwnerVW = MakeVideoWindowFlag(dwVWIndex);
      lpHWOwnerData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;
#ifdef WINNT_VER40
      RegInitVideoVW(ppdev, dwVWIndex, lpHardwareOwner[dwVWIndex]);
#else
      RegInitVideoVW(dwVWIndex, lpHardwareOwner[dwVWIndex],lpDDHALData);
#endif
    }
  }
}

/***************************************************************************
*
* FUNCTION:     SaveRectangles
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE BOOL SaveRectangles
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
#endif
  DWORD                       dwVWIndex,
  BOOL                        bCheckBandwidth,
  DWORD                       dwBitCount,
#ifdef WINNT_VER40
  PDD_UPDATEOVERLAYDATA       lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA   lpInput,
  LPGLOBALDATA                lpDDHALData
#endif
)
{
  SIZEL       Dst;
  SIZEL       Src;
  BWREGS      bwregs;

  // Is there sufficient bandwidth to work?

  gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
  gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
  gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
  gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
  gvidConfig.uSrcDepth  = dwBitCount;
  gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
  gvidConfig.uGfxDepth  = BITSPERPIXEL;
  gvidConfig.dwFlags    |= VCFLG_DISP;
#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif
  if (bCheckBandwidth && bUseBWEqn &&
      !ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
     )
  {
     gvidConfig.dwFlags    &= ~VCFLG_DISP;
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  // Save the rectangles
#ifndef WINNT_VER40
  DBG_MESSAGE(("rSrc          = %lX,%lX %lX,%lX",
               lpInput->rSrc.left,lpInput->rSrc.top,
               lpInput->rSrc.right,lpInput->rSrc.bottom));

  DBG_MESSAGE(("rcOverlaySrc  = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlaySrc.left,
               lpInput->lpDDSrcSurface->rcOverlaySrc.top,
               lpInput->lpDDSrcSurface->rcOverlaySrc.right,
               lpInput->lpDDSrcSurface->rcOverlaySrc.bottom));
#endif

  grOverlaySrc[dwVWIndex].left    = (int)lpInput->rSrc.left;
  grOverlaySrc[dwVWIndex].right   = (int)lpInput->rSrc.right;
  grOverlaySrc[dwVWIndex].top     = (int)lpInput->rSrc.top;
  grOverlaySrc[dwVWIndex].bottom  = (int)lpInput->rSrc.bottom;

#ifndef WINNT_VER40
  DBG_MESSAGE(("rDest         = %lX,%lX %lX,%lX",
               lpInput->rDest.left,lpInput->rDest.top,
               lpInput->rDest.right,lpInput->rDest.bottom));

  DBG_MESSAGE(("rcOverlayDest = %lX,%lX %lX,%lX",
               lpInput->lpDDSrcSurface->rcOverlayDest.left,
               lpInput->lpDDSrcSurface->rcOverlayDest.top,
               lpInput->lpDDSrcSurface->rcOverlayDest.right,
               lpInput->lpDDSrcSurface->rcOverlayDest.bottom));
#endif

  grOverlayDest[dwVWIndex].left   = (int)lpInput->rDest.left;
  grOverlayDest[dwVWIndex].right  = (int)lpInput->rDest.right;
  grOverlayDest[dwVWIndex].top    = (int)lpInput->rDest.top;
  grOverlayDest[dwVWIndex].bottom = (int)lpInput->rDest.bottom;

  // make sure resize is within hw capabilities
  // x can shrink down to 1/2 and stretch up to 8x
  // y can stretch up to 8x
  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

#ifdef WINNT_VER40
  if (Dst.cx > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cx / 1000))
#else
  if (Dst.cx > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGWIDTH;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cy > (LONG)(lpDDHALData->dwMaxOverlayStretch * Src.cy / 1000))
#else
  else if (Dst.cy > (LONG)(lpDDHALData->HALInfo.ddCaps.dwMaxOverlayStretch * Src.cy / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_TOOBIGHEIGHT;
    return FALSE;
  }
#ifdef WINNT_VER40
  else if (Dst.cx < (LONG)(lpDDHALData->dwMinOverlayStretch * Src.cx / 1000))
#else
  else if (Dst.cx < (LONG)(lpDDHALData->HALInfo.ddCaps.dwMinOverlayStretch * Src.cx / 1000))
#endif
  {
    lpInput->ddRVal = DDERR_UNSUPPORTED;    // too small width
    return FALSE;
  }

  if (MIN_OLAY_WIDTH >= Src.cx)
  {
    lpInput->ddRVal = DDERR_OUTOFCAPS;
    return FALSE;
  }

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     UpdateSurface
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD UpdateSurface
(
#ifdef WINNT_VER40
  PDEV                  *ppdev,
  PDD_UPDATEOVERLAYDATA lpInput
#else
  LPDDHAL_UPDATEOVERLAYDATA lpInput
#endif
)
{
  DWORD             dwOldStatus;
  DWORD             dwFourcc;
  BOOL              bCheckBandwidth;
  DWORD             dwBitCount;
  DWORD             dwDestColorKey;
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
  DWORD             dwVWFlag;
  BWREGS            bwregs;
  BOOL				bShowOverlay = FALSE;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif
#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay UpdateSurface (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  if (lpInput->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpInput->lpDDSrcSurface->lpGbl->ddpfSurface),
                  &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

  gvidConfig.dwFlags &= ~(VCFLG_COLORKEY | VCFLG_CHROMAKEY |
                          VCFLG_DISP | VCFLG_420);
#if ENABLE_YUVPLANAR
  if (lpSrcSurfaceData->dwOverlayFlags & FLG_YUVPLANAR)
    gvidConfig.dwFlags |= VCFLG_420;
#endif

  // Are we color keying?
  bCheckBandwidth = TRUE;
  dwOldStatus = lpSrcSurfaceData->dwOverlayFlags;

  dwVWIndex = GetVideoWindowIndex(dwOldStatus);
  ASSERT(dwNumVideoWindows > dwVWIndex);
  dwVWFlag = MakeVideoWindowFlag(dwVWIndex);

  lpColorSurfaceVW[dwVWIndex] = lpSrcColorSurfaceVW[dwVWIndex] = NULL;
#if ENABLE_MIRRORING
  bIsVWMirrored[dwVWIndex] = FALSE;
#endif

  if ((lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
      (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE)))
  {
    // Cannot perform src colorkey and dest colorkey at the same time
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }

#if HWBUG_24BPP_DST_COLORKEY
  if (
#ifdef WINNT_VER40
      (24 == ppdev->ulBitCount) &&
#else
      (24 == pPDevice->deBitsPixel) &&
#endif
      (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)))
  {
    // destination colorkeying at 24bpp is busted in hardware
    lpInput->ddRVal = DDERR_NOCOLORKEYHW;
    return DDHAL_DRIVER_HANDLED;
  }
#endif

#ifdef WINNT_VER40
  ChipIOReadBWRegs(ppdev, &bwregs);
#else
  ChipIOReadBWRegs(lpDDHALData, &bwregs);
#endif

  lpSrcSurfaceData->dwOverlayFlags &= ~(FLG_COLOR_KEY|FLG_SRC_COLOR_KEY);

#ifndef WINNT_VER40
	if (   (lpInput->dwFlags == 0)
		&& (lpHardwareOwner[dwVWIndex] == NULL)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_OVERLAY) )
	{
		bShowOverlay = TRUE;
	}
#endif

  if (lpInput->dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE))
  {
    dwDestColorKey = (lpInput->dwFlags & DDOVER_KEYDEST)
            ? lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue
            : lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;

    // Allow colorkey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwDestColorKeyOwnerVW == 0)
    {
      gdwDestColorKeyOwnerVW = dwVWFlag;
    }
    else if ((dwDestColorKey != gdwColorKey) &&
	  		     (dwOldStatus & dwVWFlag) &&
	  		     !(gdwDestColorKeyOwnerVW & dwVWFlag))
    {
      // ColorKey already been used by someone else.
      // It's not the original colorkey owner,
      // and the key color is not the same as the other one.
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount; //video window has the same depth as
                                        //the source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_COLORKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_COLOR_KEY;

      if (lpInput->dwFlags & DDOVER_KEYDEST)
      {
        gdwColorKey = lpInput->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        lpColorSurfaceVW[dwVWIndex] = lpInput->lpDDDestSurface;
      }
      else
      {
        gdwColorKey = lpInput->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
      }
    }
    else
    {
      gvidConfig.dwFlags    &=  ~(VCFLG_COLORKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }
  else if (lpInput->dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
  {
    // Allow SrcColorKey override only when it's the original
    // colorkey owner, or no one owns the colorkey so far.
    if (gdwSrcColorKeyOwnerVW == 0)
    {
      gdwSrcColorKeyOwnerVW = dwVWFlag;
    }
    else if (!(dwOldStatus & gdwSrcColorKeyOwnerVW))
    {
      // It's not the original colorkey owner
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }
    // Is there sufficient bandwidth to work?
    gvidConfig.sizSrc.cx  = lpInput->rSrc.right  - lpInput->rSrc.left;
    gvidConfig.sizSrc.cy  = lpInput->rSrc.bottom - lpInput->rSrc.top;
    gvidConfig.sizDisp.cx = lpInput->rDest.right  - lpInput->rDest.left;
    gvidConfig.sizDisp.cy = lpInput->rDest.bottom - lpInput->rDest.top;
    gvidConfig.uSrcDepth  = dwBitCount;
    gvidConfig.uDispDepth = dwBitCount;   //video window has the same as source
    gvidConfig.uGfxDepth  = BITSPERPIXEL;
    gvidConfig.dwFlags   |=  VCFLG_CHROMAKEY | VCFLG_DISP;

    if (!bUseBWEqn ||
        ChipIsEnoughBandwidth(&gsProgRegs, &gvidConfig, &bwregs)
       )
    {
      bCheckBandwidth = FALSE;
      lpSrcSurfaceData->dwOverlayFlags |= FLG_SRC_COLOR_KEY;

      lpSrcColorSurfaceVW[dwVWIndex] = lpInput->lpDDSrcSurface;

      if (lpInput->dwFlags & DDOVER_KEYSRC)
      {
        gdwSrcColorKeyLow = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->lpDDSrcSurface->ddckCKSrcOverlay.dwColorSpaceHighValue;
      }
      else
      {
        gdwSrcColorKeyLow = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceLowValue;
        gdwSrcColorKeyHigh = lpInput->overlayFX.dckSrcColorkey.dwColorSpaceHighValue;
      }
      if (gdwSrcColorKeyHigh < gdwSrcColorKeyHigh)
      {
        gdwSrcColorKeyHigh = gdwSrcColorKeyLow;
      }
    }
    else
    {
      gvidConfig.dwFlags &= ~(VCFLG_CHROMAKEY | VCFLG_DISP);
      lpInput->ddRVal = DDERR_NOCOLORKEYHW;
      return DDHAL_DRIVER_HANDLED;
    }
  }

#ifdef WINNT_VER40
#if 0
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & (FLG_ENABLED | 0x02000000)) )
	{
		if (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED)
		{
			// Turn the video off.
			DisableOverlay(ppdev, dwVWIndex);
			lpHardwareOwner[dwVWIndex] = NULL;
			lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
			lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;
		}

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
#else
	// The hardware is broken when using RGB32 data and ShrinkXBy2.
	if (   (dwFourcc == BI_RGB) && (dwBitCount == 32)
		&& (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		&& (lpSrcSurfaceData->dwOverlayFlags & FLG_ENABLED) )
	{
		// Turn the video off.
		DisableOverlay(ppdev, dwVWIndex);
		lpHardwareOwner[dwVWIndex] = NULL;
		lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
		lpSrcSurfaceData->dwOverlayFlags |= 0x02000000;

		if (lpSrcSurfaceData->dwOverlayFlags & FLG_VW_MASK)
		{
	    	PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

			if (giOvlyCnt[dwVWIndex] > 0)
			{
				if (--giOvlyCnt[dwVWIndex] == 0)
				{
					// Get current DTTR, mask off FIFO threshold.
					WORD CurrentDTTR = pREG->grDisplay_Threshold_and_Tiling
							& 0xFFC0;

					// Fix PDR 9574: Restore FIFO threshold value when overlay
					// surface is destroyed, do not restore the tile size.  If
					// tile size has changed, we are likely in the middle of
					// changing video mode.  No need to restore FIFO in this
					// case.
					if ( CurrentDTTR == (gwNormalDTTR & 0xFFC0) )
					{
						pREG->grDisplay_Threshold_and_Tiling = CurrentDTTR
								| (gwNormalDTTR & 0x003F);
					}
				}
			}
		}
		else if (giOvlyCnt[dwVWIndex] > 0)
		{
			giOvlyCnt[dwVWIndex]--;
		}

		// Clear up the ownership of Dest ColorKey.
		gdwDestColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		// Clear up the ownership of Src ColorKey.
		gdwSrcColorKeyOwnerVW &= ~(lpSrcSurfaceData->dwOverlayFlags
				& FLG_VW_MASK);

		lpInput->ddRVal = DDERR_OUTOFCAPS;
		return(DDHAL_DRIVER_HANDLED);
	}
	else if (lpSrcSurfaceData->dwOverlayFlags & 0x02000000)
	{
		if (gvidConfig.sizSrc.cx > gvidConfig.sizDisp.cx)
		{
			lpInput->ddRVal = DDERR_OUTOFCAPS;
			return(DDHAL_DRIVER_HANDLED);
		}
		lpSrcSurfaceData->dwOverlayFlags &= ~0x02000000;
	}
#endif
#endif /* WINNT_VER40 */

  // Because of Microsoft's Overfly bug we must ignore DDOVER_DDFX completely
  // or Overfly reports DDERR_UNSUPPORTED at least in 1024x768x16
  // So these guys can't even write a test app for WHQL that abides by their
  // own rules?
  if (lpInput->dwFlags & DDOVER_DDFX)
  {
#ifndef WINNT_VER40
    DBG_MESSAGE(("  overlayFX.dwFlags = %08lX", lpInput->overlayFX.dwFlags));
    DBG_MESSAGE(("  overlayFX.dwDDFX  = %08lX", lpInput->overlayFX.dwDDFX));
#endif

#if ENABLE_MIRRORING
    if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
    {
      bIsVWMirrored[dwVWIndex] = TRUE;
    }
    // For some bizarre reason, Microsoft's WHQL Overfly app sets the
    // DDOVER_DDFX flag but sets overlayFX.dwDDFX with complete junk
    // overlayFX.dwFlags also has junk
    // so we must ignore dwDDFX flags we don't support rather than return an
    // error.  Gee that sound like good practice!
#if 0
    else
    {
      lpInput->ddRVal = DDERR_UNSUPPORTED;
      return DDHAL_DRIVER_HANDLED;
    }
#endif
#endif
  }

#if DDRAW_COMPAT >= 50
  if( lpInput->dwFlags & DDOVER_AUTOFLIP)
  {
      if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort)
      {
         if(lpInput->lpDDSrcSurface->lpSurfMore->lpVideoPort->dwNumAutoflip
            != 2)
         {
             //Hardware only support autoflip between 2 surfaces
             lpInput->ddRVal = DDERR_GENERIC;
             return (DDHAL_DRIVER_HANDLED);
         }
      }
      else
      {
           //Autoflip must use vport
           lpInput->ddRVal = DDERR_INVALIDPARAMS;
           return (DDHAL_DRIVER_HANDLED);
      }
  }
#endif

  if ( (lpInput->dwFlags & DDOVER_SHOW) || bShowOverlay)
  {
    // Is somebody else using our hardware?
    if (((lpHardwareOwner[dwVWIndex] != NULL) &&
         (lpHardwareOwner[dwVWIndex] != lpInput->lpDDSrcSurface)) ||
        ((lpHardwareOwner[dwVWIndex] == NULL) &&
#ifdef WINNT_VER40
         IsVWHardwareInUse(ppdev, dwVWIndex)
#else
         IsVWHardwareInUse(lpDDHALData,dwVWIndex)
#endif
        ))
    {
      lpInput->ddRVal = DDERR_OUTOFCAPS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Is a valid destination surface specified?
    if (!(lpInput->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
      lpInput->ddRVal = DDERR_INVALIDPARAMS;
      return DDHAL_DRIVER_HANDLED;
    }

    // Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }

#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

    lpHardwareOwner[dwVWIndex] = lpInput->lpDDSrcSurface;
    lpSrcSurfaceData->dwOverlayFlags |= FLG_ENABLED;
#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }
  else if (lpInput->dwFlags & DDOVER_HIDE)
  {
    if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
    {
      lpHardwareOwner[dwVWIndex] = NULL;
      // clear panning show bit here

      // Turn the video off
      lpSrcSurfaceData->dwOverlayFlags &= ~FLG_ENABLED;
#ifdef WINNT_VER40
      DisableOverlay(ppdev, dwVWIndex);
#else
      DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    }
  }
  else if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    //Save the rectangles
#ifdef WINNT_VER40
    if (! SaveRectangles(ppdev, dwVWIndex, bCheckBandwidth, dwBitCount, lpInput))
#else
    if (! SaveRectangles(dwVWIndex, bCheckBandwidth, dwBitCount,lpInput,lpDDHALData))
#endif
    {
      // SaveRectangles sets lpInput->ddRVal on error
      return DDHAL_DRIVER_HANDLED;
    }
#if DDRAW_COMPAT >= 50
    lpInput->lpDDSrcSurface->lpSurfMore->dwOverlayFlags = lpInput->dwFlags;
#endif

#ifdef WINNT_VER40
    RegInitVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegInitVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     SetPosition
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD SetPosition
(
#ifdef WINNT_VER40
  PDEV                        *ppdev,
  PDD_SETOVERLAYPOSITIONDATA  lpInput
#else
  LPDDHAL_SETOVERLAYPOSITIONDATA lpInput
#endif
)
{
  LP_SURFACE_DATA   lpSrcSurfaceData;
  DWORD             dwVWIndex;
#ifndef WINNT_VER40
  LPGLOBALDATA    lpDDHALData = GetDDHALContext( lpInput->lpDD);
#endif

#ifndef WINNT_VER40
  DBG_MESSAGE(("Overlay SetPosition (lpInput = 0x%08lX)", lpInput));
#endif

  if (0 == lpInput->lpDDSrcSurface->dwReserved1)
  {
    lpInput->ddRVal = DDERR_NOTAOVERLAYSURFACE;
    return DDHAL_DRIVER_HANDLED;
  }
  lpSrcSurfaceData = GET_SURFACE_DATA_PTR(lpInput->lpDDSrcSurface);

  dwVWIndex = GetVideoWindowIndex(lpSrcSurfaceData->dwOverlayFlags);
  ASSERT(dwNumVideoWindows > dwVWIndex);

  if (lpHardwareOwner[dwVWIndex] == lpInput->lpDDSrcSurface)
  {
    // Update the rectangles
    grOverlayDest[dwVWIndex].right =
              (int)(grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left)
                          + (int)lpInput->lXPos;
    grOverlayDest[dwVWIndex].left = (int) lpInput->lXPos;
    grOverlayDest[dwVWIndex].bottom =
              (int)(grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top)
                          + (int)lpInput->lYPos;
    grOverlayDest[dwVWIndex].top = (int) lpInput->lYPos;

#ifdef WINNT_VER40
    RegMoveVideoVW(ppdev, dwVWIndex, lpInput->lpDDSrcSurface);
#else
    RegMoveVideoVW(dwVWIndex, lpInput->lpDDSrcSurface, lpDDHALData);
#endif
  }

  lpInput->ddRVal = DD_OK;
  return DDHAL_DRIVER_HANDLED;
}

/***************************************************************************
*
* FUNCTION:     GetOverlayFlipStatus
*
* DESCRIPTION:
*
****************************************************************************/

STATIC DWORD GetOverlayFlipStatus
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  FLATPTR fpVidMem,
  DWORD   dwVWIndex
)
{
  if (gsOverlayFlip.bFlipFlag &&
      ((fpVidMem == 0) || (fpVidMem == gsOverlayFlip.fpFlipFrom)))
  {
#if 1
    // if arm bit is set then some action is still pending
    // so fail
    ASSERT(dwNumVideoWindows > dwVWIndex);
    if (VW_ARM & ((PVGAR)lpDDHALData->RegsAddress)->VideoWindow[dwVWIndex].grVW_CONTROL0)
      return (DWORD)DDERR_WASSTILLDRAWING;
#else
    __int64 ttime;
    int     iTemp;


    DBG_MESSAGE(("GetOverlayFlipStatus (fpVidMem = 0x%08lX)", fpVidMem));

    // If the current scanline is less than the flip scan line,
    // we know that a VSYNC has occurred.
    iTemp = CurrentVLine(lpDDHALData);
    if (gsOverlayFlip.dwFlipScanline > (DWORD) iTemp)
    {
      // Don't allow access during the vertical retrace
      if (iTemp == 0)
      {
        if (gsOverlayFlip.bWasEverInDisplay)
        {
          gsOverlayFlip.bHaveEverCrossedVBlank = TRUE;
        }
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }

    // Otherwise, we can check to see if 1) we have ever
    // been in a vertical retrace or 2) if a fixed amount of time
    // has expired.
    else if (gsOverlayFlip.bHaveEverCrossedVBlank == FALSE)
    {
      gsOverlayFlip.bWasEverInDisplay = TRUE;
      QueryPerformanceCounter((LARGE_INTEGER *)&ttime);
      if ((ttime-gsOverlayFlip.liFlipTime) <= gsOverlayFlip.dwFlipDuration)
      {
        return (DWORD)DDERR_WASSTILLDRAWING;
      }
    }
#endif
    gsOverlayFlip.bFlipFlag = FALSE;
  }

  return DD_OK;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWZoomCodes
*
* DESCRIPTION:  Computes HACCUM_STP, HACCUM_SD,
*                        VACCUM_STP, VACCUM_SDA and VACCUM_SDB
*
****************************************************************************/

STATIC VOID ComputeVWZoomCodes
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  DWORD   dwVWIndex,
  VWDATA  *pVWData
)
{
  SIZEL Dst;
  SIZEL Src;


  Dst.cx = grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left;
  Src.cx = grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left;

  if (Dst.cx == Src.cx)
  {
    // no horizontal resize
    pVWData->HACCUM_STP = 0x00010000;
  }
  else if (Dst.cx > Src.cx)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cx <= 8 * Src.cx);

    // horizontal stretch
    //
    // ideally zoom code = 256 * (256 * Src.cx / Dst.cx)
    // we always want to truncate (256 * Src.cy / Dst.cx)
    // because truncating will give us back a Src.cx which is less than or
    // equal to the actual width of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->HACCUM_STP = (256 * 256 * Src.cx) / Dst.cx;
  }
  else
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(2 * Dst.cx >= Src.cx);

    // horizontal shrink
    //
    // this is the zoom code for Src.cx/2 be stretched to Dst.cx

    // using 128 seems to give a zoom code one too high
    // then we get the green stripe on the right edge of the video
    pVWData->HACCUM_STP = (256 * 127 * Src.cx) / Dst.cx;
    pVWData->CONTROL0 |= VW_XShrinkBy2;
  }
  // Just set horizontal seeds to zero for now
  pVWData->HACCUM_SD = 0;

  Dst.cy = grOverlayDest[dwVWIndex].bottom - grOverlayDest[dwVWIndex].top;
  Src.cy = grOverlaySrc[dwVWIndex].bottom  - grOverlaySrc[dwVWIndex].top;

  if (Dst.cy == Src.cy)
  {
    pVWData->VACCUM_STP = 0x00010000;
  }
  else if (Dst.cy > Src.cy)
  {
    // make sure we aren't going beyond hw capabilities
    ASSERT(Dst.cy <= 8 * Src.cy);

    // vertical stretch
    //
    // ideally zoom code = 256 * (256 * Src.cy / Dst.cy)
    // we always want to truncate (256 * Src.cy / Dst.cy)
    // because truncating will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)

    // using 256 seems to give a zoom code one too high for full screen
    // then we get garbage on the bottom of the screen
    pVWData->VACCUM_STP = (256 * 255 * Src.cy) / Dst.cy;
  }
  else
  {
    // vertical shrink
    //
    // ideally zoom code = 256 * (256 * Dst.cy / Src.cy)
    // we always want to round up (256 * Dst.cy / Src.cy)
    // because rounding up will give us back a Src.cy which is less than or
    // equal to the actual size of the source and we will never overrun the
    // source extent (and won't get the green stripe)
    pVWData->VACCUM_STP = (256 * 256 * Dst.cy + 256 * (Src.cy - 1)) / Src.cy;
    pVWData->CONTROL1 |= VW_YShrinkEn;
 }
  // Just set vertical seeds to zero for now
  pVWData->VACCUM_SDA = 0;
  pVWData->VACCUM_SDB = 0;
}

/***************************************************************************
*
* FUNCTION:     ComputeVWPositionData
*
* DESCRIPTION:  Computes HSTRT, HEND, HSDSZ, VSTRT, VEND,
*                        PD_STRT_ADDR and SD_PITCH
*
****************************************************************************/

STATIC VOID
ComputeVWPositionData ( PRECTL                      pVideoRect,
                        PRECTL                      pOverlaySrc,
                        PRECTL                      pOverlayDest,
#ifdef WINNT_VER40
                        PDD_SURFACE_GLOBAL          pGbl,
#else
                        LPDDRAWI_DDRAWSURFACE_GBL   pGbl,
                        LPGLOBALDATA                lpDDHALData,
#endif
                        DWORD                       dwBitCount,
                        VWDATA                      *pVWData,
                        BOOL                        bCLPL )
{
  DWORD   dwSurfBase,dwSurfOffset;


  pVWData->HSTRT = LOWORD(pVideoRect->left);
  pVWData->HEND  = LOWORD(pVideoRect->right) - 1;
  pVWData->HSDSZ = (WORD)(pOverlaySrc->right - pOverlaySrc->left);

  pVWData->VSTRT = LOWORD(pVideoRect->top);
  pVWData->VEND  = LOWORD(pVideoRect->bottom) - 1;

#ifdef WINNT_VER40
  dwSurfBase = pGbl->fpVidMem;
#else
  dwSurfBase = (pGbl->fpVidMem - lpDDHALData->ScreenAddress);
#endif
  dwSurfOffset = pOverlaySrc->top * pGbl->lPitch +
                 pOverlaySrc->left * (dwBitCount / 8);
  pVWData->PSD_STRT_ADDR = dwSurfBase + dwSurfOffset;

#if ENABLE_YUVPLANAR
  if (bCLPL)
  {
    // qword aligned offset of UV interleaved data in aperture 0
    // need same offset into UV data as offset into Y data
    // so it's just PSD_STRT_ADDR plus area of Y data
    pVWData->PSD_UVSTRT_ADDR = dwSurfBase +
                               (((pGbl->wHeight * pGbl->lPitch) + 7) & ~7) +
                               (dwSurfOffset / 2);
  }
  else
    pVWData->PSD_UVSTRT_ADDR = 0;
#endif

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
  {
    // for mirroring
    // point to the last byte of the last pixel on the right edge of the source
    pVWData->PSD_STRT_ADDR += (DWORD)(pOverlaySrc->right - pOverlaySrc->left  - 1);
  }
#endif

  pVWData->SD_PITCH = (WORD)(pGbl->lPitch);
}

/***************************************************************************
*
* FUNCTION:     RGBtoYCrCb
*
* DESCRIPTION:  Conversion equations are from page 42 of the second edition
*               of "Video Demystified" by Keith Jack
*
****************************************************************************/

STATIC DWORD INLINE
RGBtoYCbCr ( DWORD dwRGB )
{
  long  Y, Cr, Cb;
  long  r, g, b;


  r = (dwRGB & 0xF800) >> 8;
  g = (dwRGB & 0x07E0) >> 3;
  b = (dwRGB & 0x001F) << 3;

  Y  = ( 77 * r + 150 * g +  29 * b) / 256;
  // max value of Y from this is if r, g & b are all 255 then Y = 255
  // min value of Y from this is if r, g & b are all   0 then Y = 0
  // so don't need to clamp Y

  Cb = (-44 * r -  87 * g + 131 * b) / 256 + 128;
  // max value of Cb is if r & g are 0 and b is 255 then Cb = 258
  // min value of Cb is if r & g are 255 and b is 0 then Cb =  -2
  // so need to clamp Cb between 0 and 255
  if (255 < Cb)
    Cb = 255;
  else if (0 > Cb)
    Cb = 0;

  Cr = (131 * r - 110 * g -  21 * b) / 256 + 128;
  // max value of Cr is if r is 255 and g & b are 0 then Cr = 258
  // min value of Cr is if r is 0 and g & b are 255 then Cr =  -2
  // so need to clamp Cr between 0 and 255
  if (255 < Cr)
    Cr = 255;
  else if (0 > Cr)
    Cr = 0;

  return (((Y & 0xFF) << 16) | ((Cb & 0xFF) << 8) | ((Cr & 0xFF)));
}

/***************************************************************************
*
* FUNCTION:     DetermineVWColorKeyData
*
* DESCRIPTION:  Determines CLRKEY_MIN & CLRKEY_MAX or
*                          CHRMKEY_MIN & CHRMKEY_MAX
*
****************************************************************************/

STATIC VOID DetermineVWColorKeyData
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD   dwOverlayFlags,
  DWORD   dwBitCount,
  VWDATA  *pVWData
)
{
  if (FLG_COLOR_KEY & dwOverlayFlags)
  {
    // destination color key, uses color key on 5465
    pVWData->CLRKEY_MIN = gdwColorKey;
    pVWData->CLRKEY_MAX = gdwColorKey;
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (COLOR_KEY << OCCLUDE_SHIFT);
  }
  else if (FLG_SRC_COLOR_KEY & dwOverlayFlags)
  {
    PVGAR     pREG = (PVGAR)lpDDHALData->RegsAddress;
    BYTE      r,g,b;

    // source color key, uses chroma key on 5465
    switch (dwBitCount)
    {
      case  8:
        // read colors from the DAC
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyLow & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MIN = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        LL8(grPalette_Read_Address,(BYTE)(gdwSrcColorKeyHigh & 0xFF));
        r = pREG->grPalette_Data;
        g = pREG->grPalette_Data;
        b = pREG->grPalette_Data;
        pVWData->CHRMKEY_MAX = ((DWORD)(r) << 16) |
                               ((DWORD)(g) <<  8) |
                               ((DWORD)(b));
        break;

      case 16:

        if ((FLG_UYVY | FLG_YUY2) & dwOverlayFlags)
        {
          // Since we are currently using ITU 601 compliant YUV data
          // convert color key to YCrCb
          pVWData->CHRMKEY_MIN = RGBtoYCbCr(gdwSrcColorKeyLow);
          pVWData->CHRMKEY_MAX = RGBtoYCbCr(gdwSrcColorKeyHigh);
        }
        else
        {
          // convert 5:6:5 to true color
          pVWData->CHRMKEY_MIN = ((gdwSrcColorKeyLow  & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyLow  & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyLow  & 0x001F) << 3);    // blue
          pVWData->CHRMKEY_MAX = ((gdwSrcColorKeyHigh & 0xF800) << 8) |   // red
                                 ((gdwSrcColorKeyHigh & 0x07E0) << 5) |   // green
                                 ((gdwSrcColorKeyHigh & 0x001F) << 3);    // blue
        }
        break;

      case 24:
      case 32:
        pVWData->CHRMKEY_MIN = (gdwSrcColorKeyLow  & 0x00FFFFFF);
        pVWData->CHRMKEY_MAX = (gdwSrcColorKeyHigh & 0x00FFFFFF);
        break;
    }
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (CHROMA_KEY << OCCLUDE_SHIFT);
  }
  else
  {
    pVWData->CONTROL0 &= ~VW_OCCLUDE_MASK;
    pVWData->CONTROL0 |= (NO_OCCLUSION << OCCLUDE_SHIFT);
  }
}

/***************************************************************************
*
* FUNCTION:     ComputeVWFifoThreshold
*
* DESCRIPTION:
*
****************************************************************************/

static INLINE VOID ComputeVWFifoThreshold
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  VWDATA  *pVWData
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


  pREG->grDisplay_Threshold_and_Tiling =
                      (pREG->grDisplay_Threshold_and_Tiling & 0xFFC0) |
                      (gsProgRegs.DispThrsTiming & 0x003F);

  pVWData->FIFO_THRSH = gsProgRegs.VW0_FIFO_THRSH;
}

/***************************************************************************
*
* FUNCTION:     PanOverlay1_Init
*
* DESCRIPTION:  Save data for panning overlay window one.
*               Clip lpVideoRect to panning viewport.
*
****************************************************************************/

static INLINE VOID PanOverlay1_Init
(
#ifdef WINNT_VER40
  PDEV    *ppdev,
#endif
  LPRECTL lpVideoRect,
  LPRECTL lpOverlaySrc,
  LPRECTL lpOverlayDest
)
{
  // This is not necessary on Laguna since we can't pan the screen

  // clip left edge of destination
  if (0 > (lpVideoRect->left = lpOverlayDest->left))
    lpVideoRect->left = 0;

  // clip right edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cxScreen < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)ppdev->cxScreen;
#else
  if ((LONG)pPDevice->deWidth < (lpVideoRect->right = lpOverlayDest->right))
    lpVideoRect->right = (LONG)pPDevice->deWidth;
#endif

  // clip top edge of destination
  if (0 > (lpVideoRect->top = lpOverlayDest->top))
    lpVideoRect->top = 0;

  // clip bottom edge of destination
#ifdef WINNT_VER40
  if ((LONG)ppdev->cyScreen < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)ppdev->cyScreen;
#else
  if ((LONG)pPDevice->deHeight < (lpVideoRect->bottom = lpOverlayDest->bottom))
    lpVideoRect->bottom = (LONG)pPDevice->deHeight;
#endif
}

/***************************************************************************
*
* FUNCTION:     RegInitVideoVW
*
* DESCRIPTION:  This function is called to program the video format and
*               the physical offset of the Video Window video data
*               in the frame buffer.
*
****************************************************************************/

STATIC BOOL RegInitVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  BOOL              bOverlayTooSmall = FALSE;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;
#if DDRAW_COMPAT >= 50
  DWORD             dwSrfFlags = FALSE;
#endif
  DWORD             width;
//////#ifndef WINNT_VER40
  PDD_ATTACHLIST    lpSurfaceAttached;
  LP_SURFACE_DATA   lpSurfaceDataTmp;
//////#endif

  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo(&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData,dwVWIndex);
#endif
    return TRUE;
  }

  memset(&VWData, 0, sizeof(VWData));

  lPitch = lpSurface->lpGbl->lPitch;

#ifdef WINNT_VER40
  ComputeVWZoomCodes(ppdev, dwVWIndex, &VWData);
#else
  ComputeVWZoomCodes(dwVWIndex, &VWData);
#endif

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef     WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

   lpSurfaceData->dwOverlayOffset =  //This offset will be used in FlipOverlay
          VWData.PSD_STRT_ADDR  -  // and VPE
         lpSurface->lpGbl->fpVidMem
#ifndef WINNT_VER40
         + lpDDHALData->ScreenAddress
#endif
         ;

/////////#ifndef WINNT_VER40

 //Update all the attached surfaces
 lpSurfaceAttached = lpSurface->lpAttachListFrom;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachListFrom;
    }
    else
        break;

 }
 
 lpSurfaceAttached = lpSurface->lpAttachList;

 while( lpSurfaceAttached)
 {
    if(lpSurfaceAttached->lpAttached)
    {
       lpSurfaceDataTmp = GET_SURFACE_DATA_PTR(lpSurfaceAttached->lpAttached);
       lpSurfaceDataTmp->dwOverlayOffset = lpSurfaceData->dwOverlayOffset;
       lpSurfaceAttached = lpSurfaceAttached->lpAttached->lpAttachList;
    }
    else
        break;

 }

//////////#endif

#if ENABLE_MIRRORING
  // Mirror Video Windows support.
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0L;
#if DDRAW_COMPAT >= 50
  if (gwNotify & VPE_ON)
  {
    if((lpSurface->lpSurfMore->lpVideoPort != NULL)&&
       (lpSurface->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))
    {
      if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
      {
        dwSrfFlags = DDOVER_BOB;
      }
      else if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                    &DDVP_AUTOFLIP)
            &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
            && (lpSurface->lpAttachListFrom != NULL)
            && (lpSurface->lpAttachListFrom->lpAttached != NULL))
      {
          dwSrfFlags = DDOVER_AUTOFLIP;
      }
    }
  }

  if((dwSrfFlags & DDOVER_BOB)
   ||(!dwSrfFlags
    &&(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_INTERLEAVED)))
  {
      RECTL   rcTemp;
       rcTemp = grOverlaySrc[dwVWIndex];
       grOverlaySrc[dwVWIndex].top >>=1;
       grOverlaySrc[dwVWIndex].bottom >>=1;    //use half source size to
       VWData.CONTROL1 &= ~VW_YShrinkEn;       //find zoom factor
       ComputeVWZoomCodes(dwVWIndex, &VWData);
       grOverlaySrc[dwVWIndex] = rcTemp;

       VWData.SD_PITCH <<= 1;
       VWData.CONTROL0 &= ~0x30000ul;
       if(dwSrfFlags & DDOVER_BOB)
       {
           VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
           VWData.CONTROL0 |= 0x20000ul;        //enable buffer two
       }

  }
  else if(dwSrfFlags & DDOVER_AUTOFLIP)
  {

     VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
     if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
     {
          VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                   lpSurfaceData->dwOverlayOffset;
      }

      VWData.CONTROL0 &= ~0x30000ul;
      VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer
      if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
      {
        //For non-smooth-interlaced auto-flip these two address need
        // to be switched.  HW BUG
         DWORD dwTmp = VWData.PSD_STRT_ADDR;
         VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
         VWData.SSD_STRT_ADDR = dwTmp;
      }
  }

  if(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
  {
     BOOL fSDAHalf = TRUE;
#if ENABLE_MIRRORING
     if (lpInput->overlayFX.dwDDFX & DDOVERFX_MIRRORLEFTRIGHT)
         fSDAHalf = !fSDAHalf;
#endif
     if(VWData.VACCUM_STP >= 0x8000ul)
          fSDAHalf = !fSDAHalf;

     if(fSDAHalf)
     {
            VWData.VACCUM_SDA = 0x8000ul;
            VWData.VACCUM_SDB = 0ul;
     }
     else
     {
            VWData.VACCUM_SDA = 0ul;
            VWData.VACCUM_SDB = 0x8000ul;
     }
     VWData.CONTROL0 |= 0x8ul;
  }
#endif

  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= (VW_VWE | VW_ARM);

  // set source data format
  if (dwFourcc == BI_RGB)
  {
    if (dwBitCount == 16)
    {
      VWData.CONTROL0 |= (SD_RGB16_555 << SD_FRMT_SHIFT);
    }
#if ENABLE_SD_RGB32
    else if (dwBitCount == 32)
    {
      VWData.CONTROL0 |= (SD_RGB32 << SD_FRMT_SHIFT);
    }
#endif
  }
  else if (dwFourcc == BI_BITFIELDS)
  {
    VWData.CONTROL0 |= (SD_RGB16_565 << SD_FRMT_SHIFT);
  }
#if ENABLE_YUVPLANAR
  else if (dwFourcc == FOURCC_YUVPLANAR)
  {
    VWData.CONTROL0 |= (SD_YUV420 << SD_FRMT_SHIFT);
  }
#endif
  else if (FOURCC_UYVY == dwFourcc)
  {
    VWData.CONTROL0 |= (SD_YUV422 << SD_FRMT_SHIFT);
  }

#ifdef WINNT_VER40
  DetermineVWColorKeyData(ppdev, lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#else
  DetermineVWColorKeyData(lpDDHALData,lpSurfaceData->dwOverlayFlags, dwBitCount, &VWData);
#endif

#ifdef WINNT_VER40
  ComputeVWFifoThreshold(ppdev, &VWData);
#else
  ComputeVWFifoThreshold(lpDDHALData,&VWData);
#endif

  // Now start programming the registers
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT,         VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,          VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ,         VWData.HSDSZ);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_STP,    VWData.HACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_HACCUM_SD,     VWData.HACCUM_SD);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT,         VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,          VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_STP,    VWData.VACCUM_STP);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDA,    VWData.VACCUM_SDA);
  LL32(VideoWindow[dwVWIndex].grVW_VACCUM_SDB,    VWData.VACCUM_SDB);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH,      VWData.SD_PITCH);

  if (FLG_SRC_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MIN, VWData.CHRMKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CHRMKEY_MAX, VWData.CHRMKEY_MAX);
  }
  else if (FLG_COLOR_KEY & lpSurfaceData->dwOverlayFlags)
  {
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MIN, VWData.CLRKEY_MIN);
    LL32(VideoWindow[dwVWIndex].grVW_CLRKEY_MAX, VWData.CLRKEY_MAX);
  }

  LL16(VideoWindow[dwVWIndex].grVW_FIFO_THRSH, VWData.FIFO_THRSH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL1,   VWData.CONTROL1);

  // fix for PDR #10815
  // if src width >= 1536 bytes (or 3072 bytes for shrink)
  // disable vertical interpolation
  width = (grOverlaySrc[dwVWIndex].right - grOverlaySrc[dwVWIndex].left) * (dwBitCount / 8);
  if (VW_YShrinkEn & VWData.CONTROL1)
    width /= 2;
  if (width >= 1536)
  {
    // set replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 |= VWVRepEnable;
  }
  else
  {
    // clear replication bit in TEST0 reg
    pREG->VideoWindow[dwVWIndex].grVW_TEST0 &= ~VWVRepEnable;
  }

  // write last to arm
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0,   VWData.CONTROL0);

  return TRUE;
}

/***************************************************************************
*
* FUNCTION:     RegMoveVideoVW
*
* DESCRIPTION:  This function is called to move the video window that has
*               already been programed.
*
****************************************************************************/

STATIC VOID RegMoveVideoVW
(
#ifdef WINNT_VER40
  PDEV              *ppdev,
  DWORD             dwVWIndex,
  PDD_SURFACE_LOCAL lpSurface
#else
  DWORD                     dwVWIndex,
  LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
  LPGLOBALDATA              lpDDHALData
#endif
)
{
  LP_SURFACE_DATA   lpSurfaceData = GET_SURFACE_DATA_PTR(lpSurface);
  VWDATA            VWData;
  DWORD             dwFourcc;
  LONG              lPitch;
  DWORD             dwBitCount;
  RECTL             rVideoRect;
  PVGAR             pREG = (PVGAR)lpDDHALData->RegsAddress;


  ASSERT(dwNumVideoWindows > dwVWIndex);

  // Determine the format of the video data
  if (lpSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT)
  {
    GetFormatInfo (&(lpSurface->lpGbl->ddpfSurface), &dwFourcc, &dwBitCount);
  }
  else
  {
    dwBitCount = BITSPERPIXEL;
    if (16 == dwBitCount)
      dwFourcc = BI_BITFIELDS;    // 5:6:5
    else
      dwFourcc = BI_RGB;          // 8bpp, 5:5:5, 24bpp & 32bpp
  }

#ifdef WINNT_VER40
  PanOverlay1_Init(ppdev,&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#else
  PanOverlay1_Init(&rVideoRect,&grOverlaySrc[dwVWIndex],&grOverlayDest[dwVWIndex]);
#endif

  // rVideoRect is now adjusted and clipped to the panning viewport.
  // Disable overlay if totally clipped by viewport.
  if (((rVideoRect.right - rVideoRect.left) <= 0) ||
      ((rVideoRect.bottom- rVideoRect.top ) <= 0))
  {
#ifdef WINNT_VER40
    DisableOverlay(ppdev, dwVWIndex);
#else
    DisableOverlay(lpDDHALData, dwVWIndex);
#endif
    return;
  }

  memset(&VWData, 0, sizeof(VWData));
  VWData.CONTROL0 = pREG->VideoWindow[dwVWIndex].grVW_CONTROL0;
  if (lpSurfaceData->dwOverlayFlags & FLG_ENABLED)
    VWData.CONTROL0 |= VW_VWE;
  VWData.CONTROL0 |= VW_ARM;

  lPitch = lpSurface->lpGbl->lPitch;

  // if shrink in x, set shrink x by 2 bit in CONTROL0
  // shrink in y is okay, because that bit is in CONTROL1 and
  // we aren't touching CONTROL1 here
  if ((grOverlayDest[dwVWIndex].right - grOverlayDest[dwVWIndex].left) <
      (grOverlaySrc[dwVWIndex].right  - grOverlaySrc[dwVWIndex].left))
  {
    VWData.CONTROL0 |= VW_XShrinkBy2;
  }

  ComputeVWPositionData(&rVideoRect,
                        &grOverlaySrc[dwVWIndex],
                        &grOverlayDest[dwVWIndex],
                        lpSurface->lpGbl,
#ifndef   WINNT_VER40
                        lpDDHALData,
#endif
                        dwBitCount,
                        &VWData,
                        FOURCC_YUVPLANAR == dwFourcc);

#if ENABLE_MIRRORING
  if (bIsVWMirrored[dwVWIndex])
    VWData.CONTROL0 |= VW_HMIRR_EN;
#endif
  // Xing, isn't the memset above enough?
  VWData.SSD_STRT_ADDR = 0;
#if DDRAW_COMPAT >= 50
  if( gwNotify & VPE_ON)
  {
   if(lpSurface->lpSurfMore->lpVideoPort != NULL)
   {
     if((lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                &DDVP_AUTOFLIP)
        && (lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_AUTOFLIP)
        && (lpSurface->lpAttachListFrom != NULL)
        && (lpSurface->lpAttachListFrom->lpAttached != NULL))
     {

         VWData.SSD_STRT_ADDR =  lpSurfaceData->dwAutoBaseAddr2 +
                                  lpSurfaceData->dwOverlayOffset;
         if( VWData.PSD_STRT_ADDR == VWData.SSD_STRT_ADDR )
         {
             VWData.PSD_STRT_ADDR = lpSurfaceData->dwAutoBaseAddr1 +
                                     lpSurfaceData->dwOverlayOffset;
         }
         VWData.CONTROL0 &= ~0x30000ul;
         VWData.CONTROL0 |= 0x20000ul;     //enable the second buffer

         if(!(lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB))
         {
           //For non-smooth-interlaced auto-flip these two address need
           // to be switched.  HW BUG
           DWORD dwTmp = VWData.PSD_STRT_ADDR;
           VWData.PSD_STRT_ADDR = VWData.SSD_STRT_ADDR;
           VWData.SSD_STRT_ADDR = dwTmp;
         }
     }
    else if((lpSurface->lpSurfMore->dwOverlayFlags & DDOVER_BOB)
         &&(lpSurface->lpSurfMore->lpVideoPort->ddvpInfo.dwVPFlags
                & DDVP_INTERLEAVE))
     {
          VWData.SSD_STRT_ADDR = VWData.PSD_STRT_ADDR + lPitch;
     }
    }
  }
#endif

  // Now start programming the registers
  ASSERT(! (pREG->VideoWindow[dwVWIndex].grVW_TEST0 & VW_PostImed));
#ifdef WINNT_VER40
  WaitForVWArmToClear(ppdev, dwVWIndex);
#else
  WaitForVWArmToClear(lpDDHALData, dwVWIndex);
#endif

  LL16(VideoWindow[dwVWIndex].grVW_HSTRT, VWData.HSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_HEND,  VWData.HEND);
  LL16(VideoWindow[dwVWIndex].grVW_HSDSZ, VWData.HSDSZ);
  LL16(VideoWindow[dwVWIndex].grVW_VSTRT, VWData.VSTRT);
  LL16(VideoWindow[dwVWIndex].grVW_VEND,  VWData.VEND);
  LL32(VideoWindow[dwVWIndex].grVW_PSD_STRT_ADDR, VWData.PSD_STRT_ADDR);
  LL32(VideoWindow[dwVWIndex].grVW_SSD_STRT_ADDR, VWData.SSD_STRT_ADDR);
#if ENABLE_YUVPLANAR
  if (dwFourcc == FOURCC_YUVPLANAR)
  {
    LL32(VideoWindow[dwVWIndex].grVW_PSD_UVSTRT_ADDR, VWData.PSD_UVSTRT_ADDR);
    LL32(VideoWindow[dwVWIndex].grVW_SSD_UVSTRT_ADDR, VWData.SSD_UVSTRT_ADDR);
  }
#endif
  LL16(VideoWindow[dwVWIndex].grVW_SD_PITCH, VWData.SD_PITCH);
  LL32(VideoWindow[dwVWIndex].grVW_CONTROL0, VWData.CONTROL0);
}

/***************************************************************************
*
* FUNCTION:     ChipIOReadBWRegs
*
* DESCRIPTION:
*
****************************************************************************/

BOOL ChipIOReadBWRegs
(
#ifdef WINNT_VER40
  PDEV      *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  LPBWREGS  pBWRegs
)
{
  PVGAR   pREG = (PVGAR)lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  pBWRegs->BCLK_Mult      = pREG->grBCLK_Multiplier;
#else
  pBWRegs->BCLK_Mult      = pREG->grBCLK_numerator;
#endif
  pBWRegs->MISCOutput     = pREG->grMISC;
  pBWRegs->VCLK3Denom     = pREG->grSRE;
  pBWRegs->VCLK3Num       = pREG->grSR1E;
  pBWRegs->DispThrsTiming = pREG->grDisplay_Threshold_and_Tiling;
  pBWRegs->RIFControl     = pREG->grRIF_CONTROL;
  pBWRegs->GfVdFormat     = pREG->grFormat;

#ifdef WINNT_VER40
  pBWRegs->BCLK_Denom     = pREG->grBCLK_Denominator;
#else
  pBWRegs->BCLK_Denom     = pREG->grBCLK_denom;
#endif
  pBWRegs->Control2       = pREG->grCONTROL2;
  pBWRegs->CR1            = pREG->grCR1;
  pBWRegs->CR1E           = pREG->grCR1E;

#if ENABLE_256_BYTE_FETCH
  // if we are disabling 256 byte fetch when overlay or videoport
  // surfaces are created, then wipe out the 256 byte fetch related
  // bits in CONTROL2
  // clear MONO_SAFETY_256 & BYTE_REQ_256 bits of CONTROL2 register
  pBWRegs->Control2 &= ~(MONO_SAFETY_256 | BYTE_REQ_256);
#endif

  return TRUE;
}

#ifdef USE_OLD_BWEQ
/***************************************************************************
*
* FUNCTION:     KillOverlay
*
* DESCRIPTION:  Disable overlay in the following cases
*
****************************************************************************/

BOOL KillOverlay
(
#ifdef WINNT_VER40
  PDEV  *ppdev,
#endif
  WORD  wScreenX,
  UINT  uScreenDepth
)
{
  BWREGS bwregs;
  DWORD  dwMCLK, dwVCLK;

#ifdef WINNT_VER40
  if(!ChipIOReadBWRegs(ppdev, &bwregs))
#else
  if(!ChipIOReadBWRegs(&bwregs))
#endif
  {
    return TRUE;
  }

  if(!ChipCalcMCLK(&bwregs, &dwMCLK))
  {
    return TRUE;
  }

  if(!ChipCalcVCLK(&bwregs, &dwVCLK))
  {
    return TRUE;
  }
  if(dwMCLK < 75000000)
  {
     if(uScreenDepth == 32 )
     {
        if(wScreenX == 640 )
        {
            if(dwVCLK > 32000000)
                return TRUE;
         }
     }
  }
  return FALSE;

}
#endif // USE_OLD_BWEQ

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\headless\mini\headless.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    headless.c

Abstract:

    This is the miniport driver for the hardware with no graphic adapter.
    Should work only with display driver for headless environment.

Environment:

    kernel mode only

Notes:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "headless.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,HeadlessFindAdapter)
#pragma alloc_text(PAGE,HeadlessInitialize)
#pragma alloc_text(PAGE,HeadlessStartIO)
#endif

ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = HeadlessFindAdapter;
    hwInitData.HwInitialize  = HeadlessInitialize;
    hwInitData.HwStartIO     = HeadlessStartIO;

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;
}

VP_STATUS
HeadlessFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    VP_STATUS status;
    PHYSICAL_ADDRESS Zero = { 0, 0 };
    VIDEO_PORT_HEADLESS_INTERFACE HeadlessInterface;

    VideoDebugPrint((2, "Headless - FindAdapter\n"));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // We only want this driver to load if no other video miniports
    // loaded successfully.
    //

    HeadlessInterface.Size = sizeof(VIDEO_PORT_HEADLESS_INTERFACE);
    HeadlessInterface.Version = 1;

    status = VideoPortQueryServices(
                 HwDeviceExtension,
                 VideoPortServicesHeadless,
                 (PINTERFACE)&HeadlessInterface);

    if (status == NO_ERROR) {

        ULONG DisplayDeviceCount;

        HeadlessInterface.InterfaceReference(HeadlessInterface.Context);

        DisplayDeviceCount =
            HeadlessInterface.HeadlessGetDeviceCount(HwDeviceExtension);

        HeadlessInterface.InterfaceDereference(HeadlessInterface.Context);

        if (DisplayDeviceCount != 0) {

            return ERROR_DEV_NOT_EXIST;
        }

    } else {

        return ERROR_INVALID_PARAMETER;
    }

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->VdmPhysicalVideoMemoryAddress = Zero;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    return NO_ERROR;

}

BOOLEAN
HeadlessInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    VideoDebugPrint((2, "Headless - Initialize\n"));
    return TRUE;
}

BOOLEAN
HeadlessStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    VP_STATUS status;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "HeadlessStartIO - QueryAvailableModes\n"));

        status = HeadlessQueryAvailableModes(
                    (PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer,
                    RequestPacket->OutputBufferLength,
                    (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "HeadlessStartIO - QueryNumAvailableModes\n"));

        status = HeadlessQueryNumberOfAvailableModes(
                    (PVIDEO_NUM_MODES) RequestPacket->OutputBuffer,
                    RequestPacket->OutputBufferLength,
                    (PULONG)(&RequestPacket->StatusBlock->Information));

        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "HeadlessStartIO - Got reset, perhaps for dummy device\n"));
        status = NO_ERROR;
        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through headless startIO routine - invalid command 0x%08X\n", RequestPacket->IoControlCode));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\bitblt.c ===
/******************************************************************************
* Module Name: BITBLT.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvBitBlt
*
* Copyright (c) 1995,1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BITBLT.C  $
* 
*    Rev 1.45   Mar 04 1998 15:11:56   frido
* Added new shadow macros.
* 
*    Rev 1.44   Feb 24 1998 13:24:40   frido
* Removed some warning messages for NT 5.0 build.
* 
*    Rev 1.43   Jan 22 1998 18:15:58   frido
* Revised the pattern blit filter for Access again.
* 
*    Rev 1.42   Jan 21 1998 17:33:56   frido
* Revised the 24-bpp filter for Access & Excel.
* 
*    Rev 1.41   Jan 20 1998 11:43:56   frido
* Added a filter for 24-bpp PatBlt.
*
*    Rev 1.40   Nov 03 1997 11:35:48   frido
* Added REQUIRE macros.
*
*    Rev 1.39   18 Aug 1997 09:24:04   FRIDO
*
* Changed all SWAT5 labels into MEMMGR (I forgot that during the merge).
* Added dynamic bitmap filter, borrowed from Windows 95.
*
*    Rev 1.38   29 May 1997 10:59:24   noelv
*
* Frido's fix for 9773
* SWAT:
* SWAT:    Rev 1.12   29 May 1997 12:12:20   frido
* SWAT: Changed striping code from 16-bit to 32-bit.
* SWAT:
* SWAT:    Rev 1.10   09 May 1997 12:57:30   frido
* SWAT: Added support for new memory manager.
*
*    Rev 1.37   29 Apr 1997 16:28:12   noelv
*
* Merged in new SWAT code.
* SWAT:
* SWAT:    Rev 1.9   24 Apr 1997 11:45:54   frido
* SWAT: NT140b09 merge.
* SWAT: Revised comments.
* SWAT:
* SWAT:    Rev 1.8   19 Apr 1997 16:42:30   frido
* SWAT: Added SWAT.h include file.
* SWAT:
* SWAT:    Rev 1.7   18 Apr 1997 00:14:58   frido
* SWAT: NT140b07 merge.
* SWAT:
* SWAT:    Rev 1.6   15 Apr 1997 19:13:34   frido
* SWAT: Added SWAT6: striping in PatBlt.
* SWAT:
* SWAT:    Rev 1.5   14 Apr 1997 15:30:12   frido
* SWAT: Enabled SWAT5 (new bitmap allocation scheme).
* SWAT:
* SWAT:    Rev 1.4   10 Apr 1997 17:37:12   frido
* SWAT: Started work on SWAT5 optimizations.
* SWAT:
* SWAT:    Rev 1.3   09 Apr 1997 20:24:18   frido
* SWAT: Revised SWAT1 once again.
* SWAT:
* SWAT:    Rev 1.2   09 Apr 1997 17:36:48   frido
* SWAT: Changed SWAT1 pre-allocation scheme.
* SWAT: Added SWAT1 and SWAT2 switches.
* SWAT:
* SWAT:    Rev 1.1   07 Apr 1997 17:48:06   frido
* SWAT: SWAT1: Added heap pre-allocation during WB97 pause.
*
*    Rev 1.36   08 Apr 1997 11:52:46   einkauf
*
* add SYNC_W_3D to coordination MCD and 2D hw access
*
*    Rev 1.35   21 Mar 1997 10:52:58   noelv
* Combined do_flag and sw_test_flag together into 'pointer_switch'.
*
*    Rev 1.34   04 Feb 1997 10:34:18   SueS
* Added support for hardware clipping for the 5465.
*
*    Rev 1.33   23 Jan 1997 11:03:18   noelv
*
* PuntBitBlt now handles device bitmaps stored on the host.
* bCreateScreenFromDIB now checks the return code from host to screen operati
*
*    Rev 1.32   17 Dec 1996 16:57:04   SueS
* Reject bitmaps of 32x64 or smaller.  This is based on WinBench97
* optimization.  Reject bitmaps that are larger than the visible screen
* width.  Added some things to log file writes.
*
*    Rev 1.31   27 Nov 1996 11:32:46   noelv
* Disabled Magic Bitmap.  Yeah!!!
*
*    Rev 1.30   26 Nov 1996 10:48:40   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.29   13 Nov 1996 17:05:12   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.28   07 Nov 1996 16:07:08   bennyn
*
* Added no offscn mem allocation if DD enabled
*
*    Rev 1.27   18 Sep 1996 13:49:04   noelv
* Opps.  Forgot to unhook STROKEANDFILLPATH.
*
*    Rev 1.26   12 Sep 1996 09:18:42   noelv
* Fixed bug in infinite offscreen memory.
*
*    Rev 1.25   06 Sep 1996 09:03:54   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:10   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 22:48:42   frido
* #lineto - Added DrvLineTo.
*
*    Rev 1.2   17 Aug 1996 19:35:36   frido
* Cleaned source.
* Changed ScreenToMemory bitblt.
*
*    Rev 1.1   15 Aug 1996 11:45:32   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:14   frido
* Initial revision.
*
*    Rev 1.23   07 Aug 1996 09:04:00   noelv
* Sync before punting.
*
*    Rev 1.22   11 Jul 1996 15:52:30   bennyn
* Changed constant 400 and 90 to #define variables
*
*    Rev 1.21   04 Jun 1996 15:56:32   noelv
* Debug code.
*
*    Rev 1.20   28 May 1996 15:11:02   noelv
* Updated data logging.
*
*    Rev 1.19   16 May 1996 15:05:54   bennyn
* Added PIXEL_ALIGN to allocoffscnmem()
*
*    Rev 1.18   16 May 1996 14:54:10   noelv
* Added logging code.
*
*    Rev 1.17   08 May 1996 17:02:46   noelv
*
* Preallocate device bitmap
*
*    Rev 1.16   03 May 1996 14:41:42   noelv
* Modified device bitmap allocation scheme.
*
*    Rev 1.15   01 May 1996 10:57:28   bennyn
*
* Modified for NT4.0
*
*    Rev 1.14   29 Apr 1996 14:16:20   noelv
* Clean up.
*
*    Rev 1.13   10 Apr 1996 14:13:52   NOELV
* Frido release 27
 *
 *    Rev 1.22   08 Apr 1996 16:47:44   frido
 * Added PuntBitBlt.
 *
 *    Rev 1.21   27 Mar 1996 13:06:58   frido
 * Added check for destination in ROP.
 * Masked color expansions.
 * Added return value to clipping routine.
 *
 *    Rev 1.20   25 Mar 1996 11:52:30   frido
 * Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 14:17:30   bennyn
*
*    Rev 1.8   18 Mar 1996 11:42:30   noelv
* Added data loggin stuff.  Code cleanup.
*
*    Rev 1.7   13 Mar 1996 13:21:04   noelv
* Cleanup, documentation, and data logging.
*
*    Rev 1.6   12 Mar 1996 15:43:36   noelv
* Added data logging.
* Cleanup.
*
*    Rev 1.5   12 Mar 1996 11:17:48   noelv
* Code cleanup
*
*    Rev 1.4   08 Mar 1996 11:08:50   noelv
* Code cleanup and comments
*
*    Rev 1.3   05 Mar 1996 11:57:28   noelv
* Frido version 19
*
*    Rev 1.15   04 Mar 1996 20:21:44   frido
* Removed check for monochrome source and brush.
*
*    Rev 1.14   01 Mar 1996 17:47:58   frido
* Added check for destination in BLTDEF.
*
*    Rev 1.13   29 Feb 1996 20:17:32   frido
* Added test for special size device bitmaps.
* Check for bEnable in CreateScreenFromDib.
*
*    Rev 1.12   28 Feb 1996 22:37:12   frido
* Added Optimize.h.
* Added check for brushes with monochrome source.
*
*    Rev 1.11   27 Feb 1996 16:38:04   frido
* Added device bitmap store/restore.
*
*    Rev 1.10   26 Feb 1996 23:37:32   frido
* Fixed several bugs.
*
*    Rev 1.9   24 Feb 1996 01:25:12   frido
* Added device bitmaps.
* Removed old BitBlt code.
*
*    Rev 1.8   10 Feb 1996 21:39:28   frido
* Used SetBrush again for PatternBLT.
*
*    Rev 1.7   08 Feb 1996 00:19:50   frido
* Changed the interpretation of cache_slot.
*
*    Rev 1.6   05 Feb 1996 17:35:58   frido
* Added translation cache.
*
*    Rev 1.5   03 Feb 1996 13:58:28   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.4   31 Jan 1996 12:57:50   frido
* Called EngBitBlt in case of error.
* Changed clipping algorithmns.
*
*    Rev 1.3   25 Jan 1996 22:46:10   frido
* Removed bug in complex clipping.
*
*    Rev 1.2   25 Jan 1996 22:07:54   frido
* Speeded up the pattern blit.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"               // SWAT optimizations.

#define BITBLT_DBG_LEVEL    1
#define CLIP_DBG_LEVEL      1
#define BITMAP_DBG_LEVEL    1
#define PUNT_DBG_LEVEL      1

#define P   1
#define S   2
#define D   4
#define PS  (P|S)
#define DP  (P|D)
#define DPS (P|D|S)
#define DS  (S|D)

//
// Table with ROP flags.
//
BYTE ropFlags[256] =
{
0,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, P,
DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
PS,  DPS, DPS, S,   DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, PS,  DPS, DPS, PS,
DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS, DPS, DPS,
DP,  DPS, DPS, DPS, DPS, DP,  DPS, DPS, DPS, DPS, D,   DPS, DPS, DPS, DPS, DP,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS, DPS, DPS,
PS,  DPS, DPS, PS,  DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, S,   DPS, DPS, PS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS, DPS,
DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DPS, DS,  DPS,
P,   DPS, DPS, PS,  DPS, DP,  DPS, DPS, DPS, DPS, DP,  DPS, PS,  DPS, DPS, 0
};

extern void HostifyAllBitmaps(PPDEV ppdev);

COPYFN DoDeviceToDevice;
BOOL CopyDeviceBitmap(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF,
    COPYFN   *pfn);

BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4);

#if SWAT6
void StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy);
#endif


//
// If data logging is enabled, Prototype the logging files.
//
#if LOG_CALLS
    void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo);

    void LogDrvCreateDevBmp(
        int acc,
        PPDEV  ppdev,
        SIZEL  sizl,
        PDSURF pdsurf);

    void LogDrvDeleteDevBmp(
        PDSURF pdsurf);

    void LogCreateDibFromScreen(
        int    acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

    void LogCreateScreenFromDib(
        int acc,
        PPDEV  ppdev,
        PDSURF pdsurf);

//
// If data logging is not enabled, compile out the calls.
//
#else
    #define LogBitBlt(acc, psoSrc, psoDest, rop4, pco, pbo, pxlo)
    #define LogDrvCreateDevBmp(acc, ppdev, sizl, pdsurf)
    #define LogDrvDeleteDevBmp(pdsurf)
    #define LogCreateDibFromScreen(acc, ppdev, pdsurf)
    #define LogCreateScreenFromDib(acc, ppdev, pdsurf)
#endif


/****************************************************************************\
 * bIntersectTest                                                           *
 * Test for intersection between two rectangles.                            *
\****************************************************************************/
#define bIntersectTest(prcl1, prcl2) \
    (((prcl1)->left   < (prcl2)->right)  && \
     ((prcl1)->right  > (prcl2)->left)   && \
     ((prcl1)->top    < (prcl2)->bottom) && \
     ((prcl1)->bottom > (prcl2)->top))




/*****************************************************************************\
* BOOL DrvBitBlt                                                             *
\*****************************************************************************/
#if (USE_ASM && defined(i386))
BOOL i386BitBlt(
#else
BOOL DrvBitBlt(
#endif
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    PPDEV ppdev;
    ULONG fg_rop, bg_rop;
    ULONG bltdef = 0;
    BOOL  fSrc, fDest;

    #if NULL_BITBLT
    {
        if (pointer_switch)     return(TRUE);
    }
    #endif

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Entry.\n"));
    ASSERTMSG(psoDest != NULL, "DrvBitBlt: No destination.\n");


    //
    // Get the PDEV associated with the destination.
    //
    ppdev = (PPDEV) ((psoDest != NULL) ? psoDest->dhpdev :
                    ((psoSrc != NULL) ? psoSrc->dhpdev : NULL));

    // Bad PDEV?
    if (ppdev == NULL) goto GoToEngine;

    SYNC_W_3D(ppdev);

    //
    // Set a flag to tell us if the source is the frame buffer.
    //
    fSrc = (psoSrc != NULL) &&                      // Is there a source?
            ((psoSrc->iType == STYPE_DEVBITMAP) ||  // Is it a device bmp?
             (psoSrc->hsurf == ppdev->hsurfEng) );  // Is it the screen?

    //
    // Set a flag telling us if the destination is the frame buffer.
    //
    fDest = (psoDest != NULL) &&                    // Is there a dest?
            ((psoDest->iType == STYPE_DEVBITMAP) || // Is it a device bmp?
             (psoDest->hsurf == ppdev->hsurfEng) ); // Is it the screen?

    //
    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    //
    if ( fDest &&                               // If dest is supposed to be
                                                // the frame buffer,
         (psoDest->iType == STYPE_DEVBITMAP) && // and it's a device bitmap,
         ((PDSURF)psoDest->dhsurf)->pso )       // but it's really on the host,
    {
        // try to copy it back into off screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoDest->dhsurf) )
        {
            // If that fails, then the destination is now on the host.
            psoDest = ((PDSURF)psoDest->dhsurf)->pso;   // Host surface.
            fDest   = FALSE;                    // Dest is not frame buffer.
        }
    }

    //
    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    //
    if ( fSrc &&                                // If the source is supposed to
                                                // be the frame buffer,
         (psoSrc->iType == STYPE_DEVBITMAP) &&  // and it's a device bmp,
         ((PDSURF)psoSrc->dhsurf)->pso )        // but it's really on the host,
    {
        // try to copy it back into off-screen memory.
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            // If that fails, then our source is really the host.
           psoSrc = ((PDSURF)psoSrc->dhsurf)->pso;  // Host surface.
           fSrc   = FALSE;                      // Src is not frame buffer.
        }
    }

    if ( fDest )
    {
        BYTE bROP;

        if (psoDest->iType == STYPE_DEVBITMAP)
            ppdev->ptlOffset = ((PDSURF)psoDest->dhsurf)->ptl;
        else
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;

        //
        // Extract the foreground and background ROP from the ROP4
        //
        ASSERTMSG( (rop4>>16) == 0, "DrvBitBlt: Upper word in ROP4 non-zero. \n");
        fg_rop = rop4 & 0x000000FF;
        bg_rop = (rop4>>8) & 0x000000FF;

        // Punt all true 4 op rops.
        // If fg_rop != bg_rop, then this is a true 4 op rop, so punt it.
        // If fg_rop == bg_rop, then it's really a three op rop.
        if ((fg_rop != bg_rop))        // It's a three op rop,
            goto GoToEngine;

        bROP = ropFlags[fg_rop];

        #if !(USE_ASM && defined(i386))
        {
            if (!(bROP & S))
            {
                // It is a PatBLT.  This is very important, so all calls to the
                // support routines are stretched into linear code, except for
                // the caching of the brushes, which should happen only once
                // for each brush.
                ULONG drawbltdef = 0x10000000 | fg_rop;
                if (bROP & D)
                    drawbltdef |= 0x01000000;

                // Do we have a pttern to load?
                if (bROP & P)
                {
                    ULONG color = pbo->iSolidColor;
                    if (color != (ULONG) -1)
                    {
                        // We have a solid color.
                        switch (ppdev->ulBitCount)
                        {
                        case 8:
                            color = (color << 8) | (color & 0xFF);
                        case 16:
                            color = (color << 16) | (color & 0xFFFF);
                        }
                        drawbltdef |= 0x00070000;
                        REQUIRE(2);
                        LL_BGCOLOR(color, 2);
                    }
                    else
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                            goto GoToEngine;

                        drawbltdef |= bltdef << 16;
                    }
                }


                // Test for no clipping.
                if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
                {
#if SWAT6
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);
                                        StripePatBlt(ppdev, prclDest->left + ppdev->ptlOffset.x,
                                                        prclDest->top + ppdev->ptlOffset.y,
                                                        prclDest->right - prclDest->left,
                                                        prclDest->bottom - prclDest->top);
#else
                    REQUIRE(7);
                    LL_DRAWBLTDEF(drawbltdef, 0);
                    LL_OP0(prclDest->left + ppdev->ptlOffset.x,
                           prclDest->top + ppdev->ptlOffset.y);
                    LL_BLTEXT(prclDest->right - prclDest->left,
                              prclDest->bottom - prclDest->top);
#endif
                }

                // Test for rectangle clipping.
                else if (pco->iDComplexity == DC_RECT)
                {
                    LONG x, y, cx, cy;
                    x  = max(prclDest->left,   pco->rclBounds.left);
                    y  = max(prclDest->top,    pco->rclBounds.top);
                    cx = min(prclDest->right,  pco->rclBounds.right)  - x;
                    cy = min(prclDest->bottom, pco->rclBounds.bottom) - y;
                    if ( (cx > 0) && (cy > 0) )
                    {
#if SWAT6
                        REQUIRE(2);
                        LL_DRAWBLTDEF(drawbltdef, 2);
                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                        REQUIRE(7);
                        LL_DRAWBLTDEF(drawbltdef, 0);
                        LL_OP0(x + ppdev->ptlOffset.x, y + ppdev->ptlOffset.y);
                        LL_BLTEXT(cx, cy);
#endif
                    }
                }

                // Complex clipping.
                else
                {
                    BOOL       bMore;
                    ENUMRECTS8 ce;
                    RECTL*     prcl;

                 #if DRIVER_5465 && HW_CLIPPING
                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    // Enable clipping
                    REQUIRE(6);
                    LL_DRAWBLTDEF(drawbltdef | DD_CLIPEN, 0);
                    LL_CLIPULE(prclDest->left + ppdev->ptlOffset.x,
                               prclDest->top + ppdev->ptlOffset.y);
                    LL_CLIPLOR(prclDest->right + ppdev->ptlOffset.x,
                               prclDest->bottom + ppdev->ptlOffset.y);

                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            if ((prcl->right > prcl->left) &&
                                (prcl->bottom > prcl->top))
                            {
#if SWAT6
                                                                StripePatBlt(ppdev,
                                                                                prcl->left + ppdev->ptlOffset.x,
                                                                                prcl->top + ppdev->ptlOffset.y,
                                                                                prcl->right - prcl->left,
                                                                                prcl->bottom - prcl->top);
#else
                                REQUIRE(5);
                                LL_OP0(prcl->left + ppdev->ptlOffset.x,
                                       prcl->top + ppdev->ptlOffset.y);
                                LL_BLTEXT(prcl->right - prcl->left,
                                          prcl->bottom - prcl->top);
#endif
                            }
                        }
                    } while (bMore);
                 #else
                    REQUIRE(2);
                    LL_DRAWBLTDEF(drawbltdef, 2);

                    // Get a chunk of rectangles.
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
                    do
                    {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                            LONG x, y, cx, cy;
                            x  = max(prclDest->left,   prcl->left);
                            y  = max(prclDest->top,    prcl->top);
                            cx = min(prclDest->right,  prcl->right)  - x;
                            cy = min(prclDest->bottom, prcl->bottom) - y;
                            if ( (cx > 0) && (cy > 0) )
                            {
#if SWAT6
                                                                StripePatBlt(ppdev, x + ppdev->ptlOffset.x,
                                                                                y + ppdev->ptlOffset.y, cx, cy);
#else
                                REQUIRE(5);
                                LL_OP0(x + ppdev->ptlOffset.x,
                                       y + ppdev->ptlOffset.y);
                                LL_BLTEXT(cx, cy);
#endif
                            }
                        }
                    }
                    while (bMore);
                 #endif
                }
                LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                return(TRUE);
            }
        }
        #endif // !(USE_ASM && defined(i386))

        // We only support HostToScreen blits where the Host is either
        // 1-bpp, 4-bpp, 8-bpp, or the same format as the screen.
        if ( ((psoSrc->iBitmapFormat > BMF_8BPP) &&
             (psoSrc->iBitmapFormat != psoDest->iBitmapFormat)) )
        {
            goto GoToEngine;
        }

        if (bROP & P)
        {
            // Realize the brush.
            if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
            {
                goto GoToEngine;
            }
        }

        // If the destination is part of the ROP, set the bit.
        if (bROP & D)
        {
            bltdef |= 0x0100;
        }

        // Do the blit.
        if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                             pptlSrc, (bltdef << 16) | fg_rop,
                             fSrc ? DoDeviceToDevice : ppdev->pfnHostToScreen))
        {
            LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
            return(TRUE);
        }
    } // fDest

    else if (fSrc) // Destination is bitmap, source is screen or device bitmap.
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            ppdev->ptlOffset = ((PDSURF) psoSrc->dhsurf)->ptl;
        }
        else
        {
            ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
        }

        #if S2H_USE_ENGINE
        {
            // ROP3?
            fg_rop = (BYTE) rop4;
            if (fg_rop == (rop4 >> 8))
            {
                BYTE bROP = ropFlags[fg_rop];

                // We dont's support ROPs where the destination is part of.
                if ( !(bROP & D) )
                {
                    // If we need a brush, load it.
                    if (bROP & P)
                    {
                        if (!SetBrush(ppdev, &bltdef, pbo, pptlBrush))
                        {
                            goto GoToEngine;
                        }
                    }
                    // Now, call the routine through the clip manager.
                    if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo,
                                         prclDest, pptlSrc,
                                         (bltdef << 16) | fg_rop,
                                         ppdev->pfnScreenToHost))
                    {
                        LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                        return(TRUE);
                    }
                }
            }
        }
        #else
        {
            // We only support SRCCOPY.
            if (rop4 == 0x0000CCCC)
            {
                // Now, call the routine through the clip manager.
                if (CopyDeviceBitmap(psoDest, psoSrc, pco, pxlo, prclDest,
                                     pptlSrc, 0x000000CC,
                                     ppdev->pfnScreenToHost))
                {
                    LogBitBlt(0, psoSrc, psoDest, rop4, pco, pbo, pxlo);
                    return(TRUE);
                }
            }
        }
        #endif
    }

GoToEngine:

    // BLT is too complex. Punt it to GDI.

    DISPDBG((BITBLT_DBG_LEVEL, "DrvBitBlt: Exit (punt). ROP4 = 0x%02X%02X.\n",
             bg_rop,fg_rop));
    LogBitBlt(1, psoSrc, psoDest, rop4, pco, pbo, pxlo);
    return PuntBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                      pptlMask, pbo, pptlBrush, rop4);
}

/*****************************************************************************\
 * DrvCreateDeviceBitmap
 *
 * This routine creates a device bitmap that is allocated off-screen.
 *
 * On entry:    dhpdev      Handle of PDEV structure.
 *      sizl        Size of the device bitmap to create.
 *      iFormat     Bitmap format of the device bitmap to create.
 *
 * Returns: We return the handle of a surface object that holds our device
 *      bitmap or 0 if there is an error.
\*****************************************************************************/
HBITMAP DrvCreateDeviceBitmap(
    DHPDEV dhpdev,
    SIZEL  sizl,
    ULONG  iFormat
)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    POFMHDL pofm;
    HBITMAP hbmDevice;
    PDSURF  pdsurf;
    FLONG   flHooks =   HOOK_SYNCHRONIZEACCESS | HOOK_TEXTOUT
                      | HOOK_BITBLT | HOOK_COPYBITS | HOOK_PAINT
                      | HOOK_STROKEPATH | HOOK_FILLPATH
                          #ifdef WINNT_VER40
                      | HOOK_LINETO
                      #endif
                  ;

    SYNC_W_3D(ppdev);

    #if WINBENCH96
        //
        // We support only device bitmaps that WinBench is going to use.  This
        // to circumvent the limitations of the heap management when there is
        // not so much video memory.
        //
        // Only support bitmaps with a width between 20 and 31, and bitmaps
        // wider than 100.
        if ( (sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)) )
        {
            LogDrvCreateDevBmp(1, ppdev, sizl, NULL);
            return(0);
        }

    #else
        // We don't support anything under or equal to 8x8 (brushes) since
        // these will only slow us down.
        if ((sizl.cx <= 8) || (sizl.cy <= 8))
        {
            LogDrvCreateDevBmp(2, ppdev, sizl, NULL);
            return(0);
        }

                #if MEMMGR
                // New bitmap filter, borrowed from Windows 95.
                if (ppdev->fBitmapFilter)
                {
                        if ((  (sizl.cx <= ppdev->szlBitmapMin.cx)
                                && (sizl.cy <= ppdev->szlBitmapMin.cy)
                                )
                                || (sizl.cx > ppdev->szlBitmapMax.cx)
                                || (sizl.cy > ppdev->szlBitmapMax.cy)
                        )
                        {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Rejected\n"));
                return(0);
                        }
                }
                #else
        // Reject any x<=32, or y<=64, for 16 or 24 bpp.
        // Improves WinBench97 scores.
        if ((iFormat == BMF_16BPP) || (iFormat == BMF_24BPP))
        {
            if ((sizl.cx <= 32) || (sizl.cy <= 64))
            {
                LogDrvCreateDevBmp(8, ppdev, sizl, NULL);
                DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject x<=32||y<=64\n"));
                return(0);
            }
        }
                #endif

    #endif

    // Reject if bigger than current screen size
    if ((ULONG)sizl.cx > ppdev->cxScreen)
    {
       LogDrvCreateDevBmp(9, ppdev, sizl, NULL);
       DISPDBG((BITMAP_DBG_LEVEL, "DrvCreateDeviceBitmap - Reject > cxScreen\n"));
       return(0);
    }

    // If the hardware is not in graphics mode, don't create a device bitmap!
    if (!ppdev->bEnable)
    {
        LogDrvCreateDevBmp(3, ppdev, sizl, NULL);
        return(0);
    }

    // We don't support device bitmaps in any other mode than the hardware.
    if (iFormat != ppdev->iBitmapFormat)
    {
        return(0);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
           return (0);
    #endif
#if SWAT1
        // Is this the very first device bitmap?
        if (ppdev->fPreAllocate == FALSE)
        {
                // Setup step-down counter.
                ppdev->fPreAllocate = TRUE;
                ppdev->nPages = 10;
        }

        // Is this the WinBench 97 pause bitmap?
        else if (sizl.cx == 300 && sizl.cy == 150)
        {
                if (ppdev->nPages == 0)
                {
                        PVOID p;
                        // Allocate 8 full-screen pages from the heap.
                        #ifdef WINNT_VER40
                        p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                        ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                        #else
                        p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                        ppdev->cyScreen);
                        #endif
                        // Free it again.
                        MEMORY_FREE(p);
                }
                else
                {
                        // Decrement step-down counter.
                        ppdev->nPages--;
                }
        }

        // Is this a full-screen device bitmap?
        else if (  (ppdev->nPages == 0)
                        && (sizl.cx == (LONG) ppdev->cxScreen)
                        && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                PVOID p;
                // Allocate 8 full-screen pages from the heap.
                #ifdef WINNT_VER40
                p = MEM_ALLOC(FL_ZERO_MEMORY, 8 * ppdev->cxScreen *
                                ppdev->iBytesPerPixel * ppdev->cyScreen, ALLOC_TAG);
                #else
                p = MEM_ALLOC(LPTR, 8 * ppdev->cxScreen * ppdev->iBytesPerPixel *
                                ppdev->cyScreen);
                #endif
                // Free it again.
                MEMORY_FREE(p);
        }
#endif // SWAT1

#if SWAT2
        // Is this a full-screen device bitmap?
        if (   (sizl.cx == (LONG) ppdev->cxScreen)
                && (sizl.cy == (LONG) ppdev->cyScreen)
        )
        {
                #if MEMMGR
                // Hostify all device bitmaps.
                extern void HostifyAllBitmaps(PPDEV ppdev);
                HostifyAllBitmaps(ppdev);
                #else
                POFMHDL pofm, pofmNext;

                // Hostify all current off-screen device bitmaps.
                for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
                {
                        pofmNext = pofm->nexthdl;

                        if (pofm->pdsurf && pofm->pdsurf->pofm)
                        {
                                bCreateDibFromScreen(ppdev, pofm->pdsurf);
                        }
                        else if (pofm->alignflag & SAVESCREEN_FLAG)
                        {
                                FreeOffScnMem(ppdev, pofm);
                        }
                }
                #endif
        }
#endif // SWAT2

    //
    // Allocate off-screen memory.
    //
    {
       #if INFINITE_OFFSCREEN_MEM
        //
        // This is our "infinite offscreen memory" test.  Here we always
        // succeed in memory allocation.  We do this by always allocating
        // bitmaps at screen 0,0.
        // It looks ugly, but we can use it to tell of our memory management
        // is hurting our benchmark scores.
        // This option is turned off for the retail version of the driver.
        // 'pointer_switch' is turned on and off in POINTER.C by moving the pointer
        // to a special place on the screen.
        //
        if (pointer_switch)
        {
            pofm = ppdev->ScrnHandle;
        }
        else
        #endif // INFINITE_OFFSCREEN_MEM
        {
            #if WINBENCH96
            //
            // This is our Magic Bitmap.
            // Winbench 96 allocates one special bitmap into which it does *lots*
            // of drawing.  If the allocation for this bitmap fails, our WinBench
            // score will be poor.  We ensure that this allocation succeeds
            // by pre-allocating it at boot time.
            //
            // If the size of the requested bitmap matches our magic bitmap, we
            // assume that Winbench is requesting it's special bitmap, and so we
            // use the magic bitmap.
            //
            if ( (sizl.cx == MAGIC_SIZEX) && (sizl.cy == MAGIC_SIZEY) &&
                 ppdev->pofmMagic && !ppdev->bMagicUsed)
            {
                // If fits.  Use pre-allocated bitmap.
                DISPDBG((BITMAP_DBG_LEVEL,
                         "DrvCreateDeviceBitmap - Using the Magic Bitmap.\n"));
                ppdev->bMagicUsed = 1;
                pofm = ppdev->pofmMagic;
            }
            else
            #endif
            {
                DISPDBG((BITMAP_DBG_LEVEL,
                "DrvCreateDeviceBitmap - Allocating a %d x %d device bitmap.\n",
                 sizl.cx, sizl.cy));
                                #if MEMMGR
                                if (ppdev->fBitmapFilter)
                                {
                                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        if (pofm == NULL)
                                        {
                                                HostifyAllBitmaps(ppdev);
                                                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
                                        }
                                }
                                else if (sizl.cx <= ppdev->must_have_width)
                                {
                        pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN | MUST_HAVE,
                                NULL);
                                }
                                else
                                #endif
                pofm = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
        }
    }

    //
    // If we got the offscreen memory we need, then let's do some work.
    //
    if (pofm != NULL)
    {
        // Allocate device bitmap structure.

        #ifdef WINNT_VER40
            pdsurf = MEM_ALLOC(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        #else
            pdsurf = MEM_ALLOC(LPTR, sizeof(DSURF));
        #endif

        if (pdsurf != NULL)
        {
            // Create the device bitmap object.
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                // Associate the device bitmap with the surface.
                if (EngAssociateSurface((HSURF) hbmDevice,
                                                                ppdev->hdevEng,
                                                                                flHooks)
                )
                {
                    // Store a pointer to the surface.
                    {
                        #if INFINITE_OFFSCREEN_MEM
                            //
                            // If we're using screen(0,0) as a device bitmap
                            // then don't walk on ScrnHandle->pdsurf!
                            //
                            if (pofm != ppdev->ScrnHandle)
                        #endif
                        pofm->pdsurf = pdsurf;
                    }

                    // Initialize the device bitmap structure.
                    pdsurf->ppdev = ppdev;
                    pdsurf->pofm = pofm;
                    pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
                    pdsurf->ptl.y = pofm->aligned_y;
                    pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;
                    pdsurf->sizl = sizl;
                    LogDrvCreateDevBmp(0, ppdev, sizl, pdsurf);

                    return(hbmDevice);
                }
                else
                {
                    LogDrvCreateDevBmp(4, ppdev, sizl, NULL);
                }
                // Delete the surface
                EngDeleteSurface((HSURF) hbmDevice);
            }
            else
            {
                LogDrvCreateDevBmp(5, ppdev, sizl, NULL);
            }
            // Free the device bitmap structure.
            MEMORY_FREE(pdsurf);
        }
        else
        {
            LogDrvCreateDevBmp(6, ppdev, sizl, NULL);
        }

        #if WINBENCH96
        // Free the off-screen memory.
        if (pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated memory block.  Don't free it,
            // just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            #if INFINITE_OFFSCREEN_MEM
                // But don't free it if the device bitmap is at screen(0,0)...
                if (pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(ppdev, pofm);
        }
    }
    else
    {
        LogDrvCreateDevBmp(7, ppdev, sizl, NULL);
    }

    return(0);
}

/*****************************************************************************\
 * DrvDeleteDeviceBitmap
 *
 * This routine deletes a device bitmap and frees the off-screen memory.
 *
 * On entry:    pdsurf          Pointer to device bitmap to delete.
\*****************************************************************************/
void DrvDeleteDeviceBitmap(DHSURF dhsurf)
{

        PDSURF pdsurf = (PDSURF) dhsurf;

    //
    // Log this call to a file.
    //
    LogDrvDeleteDevBmp(pdsurf);

    // Is the device bitmap stored in a DIB?
    if (pdsurf->pso)
    {
        // Delete the in-memory DIB.
        HSURF hsurfDib = pdsurf->pso->hsurf;
        EngUnlockSurface(pdsurf->pso);
        EngDeleteSurface(hsurfDib);
    }
    else
    {
        PPDEV ppdev = pdsurf->ppdev;

        #if INFINITE_OFFSCREEN_MEM
            //
            // If we're using screen(0,0) as a device bitmap
            // then don't walk on ScrnHandle->pdsurf!
            //
            if (pdsurf->pofm != ppdev->ScrnHandle)
        #endif

        pdsurf->pofm->pdsurf = NULL;

        #if WINBENCH96
        if ( pdsurf->pofm == ppdev->pofmMagic)
        {
            // We were using the preallocated chunk of memory.  Don't free
            // it, just mark it as unused.
            ppdev->bMagicUsed = 0;
        }
        else
        #endif
        {
            // Free the off-screen memory.
            #if INFINITE_OFFSCREEN_MEM
                // unless our device bitmap is at screen(0,0)...
                if (pdsurf->pofm != ppdev->ScrnHandle)
            #endif
            FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
        }
    }

    // Free the device bitmap structure.
    MEMORY_FREE(pdsurf);
}


/*****************************************************************************\
 * bCreateDibFromScreen
 *
 * This routine copy a device bitmap into a DIB and frees the off-screen
 * memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns: TRUE if the off-screen device bitmap was sucessfully copied
 *      into a memory DIB.
\*****************************************************************************/
BOOL bCreateDibFromScreen(
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    HBITMAP hbmDib;

    // Create a DIB.
    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        // Associate the surface with the driver.
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            // Lock the surface.
            SURFOBJ* pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                SIZEL sizl;
                PBYTE pjScreen, pjBits;

                // Calculate the size of the blit.
                sizl.cx = pdsurf->sizl.cx * ppdev->iBytesPerPixel;
                sizl.cy = pdsurf->sizl.cy;

                // Calculate the destination variables.
                pjBits = (PBYTE) pso->pvScan0;

                // Calculate the screen address.
                pjScreen = ppdev->pjScreen
                         + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                         + (pdsurf->ptl.y * ppdev->lDeltaScreen);

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                while (sizl.cy--)
                {
                    // Copy all pixels from screen to memory.
                    memcpy(pjBits, pjScreen, sizl.cx);

                    // Next line.
                    pjScreen += ppdev->lDeltaScreen;
                    pjBits += pso->lDelta;
                }

                #if WINBENCH96
                    //
                    // If the block we are freeing is our preallocated
                    // piece, then invalidate it's pointer.
                    //
                    if ( pdsurf->pofm == ppdev->pofmMagic)
                        ppdev->pofmMagic = 0;
                #endif

                                #if !MEMMGR
                // Free the off-screen memory handle.
                #if INFINITE_OFFSCREEN_MEM
                    // unless our device bitmap is at screen(0,0)...
                    if (pdsurf->pofm != ppdev->ScrnHandle)
                #endif
                FreeOffScnMem(pdsurf->ppdev, pdsurf->pofm);
                                #endif

                // Mark the device bitmap as DIB.
                pdsurf->pofm = NULL;
                pdsurf->pso = pso;

                // Done.
                LogCreateDibFromScreen(0, ppdev, pdsurf);
                return(TRUE);
            }
            else
            {
                // Failed to lock host surface
                LogCreateDibFromScreen(1, ppdev, pdsurf);
            }
        }
        else
        {
            // Failed to associate host surface
            LogCreateDibFromScreen(2, ppdev, pdsurf);
        }

        // Delete the DIB.
        EngDeleteSurface((HSURF) hbmDib);
    }
    else
    {
        // Failed to create host surface.
        LogCreateDibFromScreen(3, ppdev, pdsurf);
    }

    // Error.
    return(FALSE);
}

/*****************************************************************************\
 * bCreateScreenFromDib
 *
 * This routine copys a DIB into a device bitmap and frees the DIB from memory.
 *
 * On entry:    ppdev           Pointer to physical device.
 *      pdsurf          Pointer to device bitmap to copy.
 *
 * Returns:     TRUE if the DIB was sucessfully copied into an off-screen
 *          device bitmap.
\*****************************************************************************/
BOOL bCreateScreenFromDib(
    PPDEV     ppdev,
    PDSURF    pdsurf
)
{
    POFMHDL  pofm;
    HSURF    hsurf;
    SURFOBJ* pso;

        #if MEMMGR
        // In low memory situations, bitmaps will be hostified very frequently, so
        // don't copy them back to the off-screen...
        if (ppdev->fBitmapFilter)
        {
                return FALSE;
        }
        #endif

    // If the hardware is not in graphics mode, keep the device bitmap in
    // memory.
    if (!ppdev->bEnable)
    {
        LogCreateScreenFromDib (1, ppdev, pdsurf);
        return(FALSE);
    }

    #ifdef ALLOC_IN_CREATESURFACE
        if (ppdev->bDirectDrawInUse)
            return (FALSE);
    #endif

    // Allocate off-screen memory.
    pofm = AllocOffScnMem(ppdev, &pdsurf->sizl, PIXEL_AlIGN, NULL);
    if (pofm != NULL)
    {
        SURFOBJ psoDest;
        RECTL   rclDest;
        POINTL  ptlSrc;

        //
        // Tell the device bitmap where it lives in offscreen memory.
        //
        pdsurf->ptl.x = pofm->aligned_x / ppdev->iBytesPerPixel;
        pdsurf->ptl.y = pofm->aligned_y;
        pdsurf->packedXY = (pdsurf->ptl.y << 16) | pdsurf->ptl.x;

        //
        // Create a two way link between the device bitmap and
        // its offscreen memory block.
        //
        pdsurf->pofm = pofm;   // Attach offscreen memory block to device bitmap
        pofm->pdsurf = pdsurf; // Attach device bitmap to offscreen memory block

        //
        // Disattach the host bitmap from the device bitmap.
        // Save the pointer, because if we fail to move the device bitmap
        // into the frame buffer, it will remain in host memory, and we
        // will have to restore this pointer.
        //
        pso = pdsurf->pso;     // Save pointer to bitmap in host memory.
        pdsurf->pso = NULL;    // disattach host memory

        //
        // Wrap the offscreen memory in a destination surface object.
        // This is so we can use a host to screen BLT to move the bitmap
        // from the host to the offscreen memory.
        //
        psoDest.dhsurf = (DHSURF) pdsurf;
        psoDest.iType = STYPE_DEVBITMAP;

        //
        // Build a destination rectangle that describes where to put the
        // bitmap in offscreen memory.  This rectangle is relative to
        // upper left corner of the allocated block of offscreen memory.
        //
        rclDest.left = 0;
        rclDest.top = 0;
        rclDest.right = pdsurf->sizl.cx;
        rclDest.bottom = pdsurf->sizl.cy;

        //
        // Build a source point.
        // Since we're moving the entire bitmap, its (0,0).
        //
        ptlSrc.x = ptlSrc.y = 0;

        //
        // Use our host to screen code to copy the DIB into off-screen memory.
        //
        if (!ppdev->pfnHostToScreen(&psoDest, pso, NULL, &rclDest, &ptlSrc,
                               0x000000CC))
        {
            //
            // BLT engine couldn't put it back into off screen memory.
            // Maybe the DIB engine can.
            //
            DISPDBG (( 0, "Couldn't BLT device bitmap back into framebuffer.\n"));

            if (! PuntBitBlt(&psoDest, pso, NULL, NULL, NULL,
                             &rclDest, &ptlSrc, NULL, NULL, NULL, 0x0000CCCC))
            {
                // Nope!  We can't move it back to the frame buffer.
                DISPDBG (( 0, "Couldn't punt device bitmap back into framebuffer.\n"));
                DISPDBG (( 0, "Device bitmap will remain in offscreen memory.\n"));

                // Restore the surface object pointers.
                pdsurf->pofm = NULL; // This device bitmap has no offscreen memory.
                pdsurf->pso = pso;   // This device bitmap lives here, on the host.

                // Free the offscreen memory we allocated and fail.
                FreeOffScnMem(ppdev, pofm);
                return FALSE;
            }
        }

        // Delete the DIB.
        hsurf = pso->hsurf;
        EngUnlockSurface(pso);
        EngDeleteSurface(hsurf);

        // Done.
        LogCreateScreenFromDib (0, ppdev, pdsurf);
        return(TRUE);
    }

    // Error.
    LogCreateScreenFromDib (2, ppdev, pdsurf);
    return(FALSE);
}

#if LOG_CALLS
// ============================================================================
//
//    Everything from here down is for data logging and is not used in the
//    production driver.
//
// ============================================================================
extern long lg_i;
extern char lg_buf[256];


// ****************************************************************************
//
// LogBitBlt()
// This routine is called only from DrvBitBlt()
// Dump information to a file about what is going on in BitBlt land.
//
// ****************************************************************************
void LogBitBlt(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        ROP4 rop4,
        CLIPOBJ*  pco,
        BRUSHOBJ* pbo,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DBB: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (acc)
    {
        lg_i = sprintf(lg_buf,"PNT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    fg_rop = (BYTE) (rop4 & 0xff);
    bg_rop = (BYTE) ((rop4>>8) & 0xff);


    //
    // Check the SRC
    //
    if ( (ropFlags[fg_rop] & S) &&
         (psoSrc))
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                lg_i = sprintf(lg_buf,"S=DH ");
            else
                lg_i = sprintf(lg_buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"S=S ");
        else
            lg_i = sprintf(lg_buf,"S=H ");
    }
    else
        lg_i = sprintf(lg_buf,"S=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            lg_i = sprintf(lg_buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                lg_i = sprintf(lg_buf,"D=DH ");
            else
                lg_i = sprintf(lg_buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            lg_i = sprintf(lg_buf,"D=S ");
        else
            lg_i = sprintf(lg_buf,"D=H ");
    }
    else
        lg_i = sprintf(lg_buf,"D=N ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);



    //
    // Check the ROP
    //
    if (fg_rop == bg_rop)
        lg_i = sprintf(lg_buf,"R3=%02X ", fg_rop);
    else
        lg_i = sprintf(lg_buf,"R4=%04X ", rop4&0xFFFF);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    lg_i = sprintf(lg_buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    //
    // Type of pattern.
    //
   if (ropFlags[fg_rop] & P)
   {
      if (pbo->iSolidColor == 0xFFFFFFFF )
      {
        lg_i = sprintf(lg_buf,"BR=P ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
      else
      {
        lg_i = sprintf(lg_buf,"BR=0x%X ",(pbo->iSolidColor));
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
      }
    }
    else
    {
        lg_i = sprintf(lg_buf,"BR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }


    //
    // Type of translation
    //
    if (!pxlo)
    {
        lg_i = sprintf(lg_buf,"TR=N ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        lg_i = sprintf(lg_buf,"TR=T ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf,"TR=NT ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    return;
}



// ****************************************************************************
//
// LogDrvCreateDevBmp()
// This routine is called only from DrvCreateDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvCreateDevBmp(
    int acc,
    PPDEV  ppdev,
    SIZEL  sizl,
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    switch(acc)
    {
    case 0: // Accelerated
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Id: 0x%08X  Loc: %d,%d \r\n",
                sizl.cx, sizl.cy, pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt size.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 2: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 8x8.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 3: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt mode.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 4: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt assoc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 5: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt bitmap.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 6: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt DSURF.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 7: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt FB alloc.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 8: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt 32x64.\r\n",
                sizl.cx, sizl.cy);
        break;

    case 9: // Punted
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt > cxScreen.\r\n",
                sizl.cx, sizl.cy);
        break;

    default:
        lg_i = sprintf(lg_buf,
                "DrvCreateDeviceBitmap:   %4d x %4d  Punt unknown.\r\n",
                sizl.cx, sizl.cy);
        break;

    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
 }



// ****************************************************************************
//
// LogDrvDeleteDevBmp()
// This routine is called only from DrvDeleteDeviceBitmap()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogDrvDeleteDevBmp(
    PDSURF pdsurf)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "DrvDeleteDeviceBitmap:   Id: 0x%08X. ", pdsurf);
    WriteLogFile(pdsurf->ppdev->pmfile, lg_buf,
                 lg_i, pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);

    if (pdsurf->pso)
    {
        lg_i = sprintf(lg_buf, "Loc: HOST\r\n");
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
    else
    {
        lg_i = sprintf(lg_buf, "Loc: %d,%d\r\n", pdsurf->pofm->x, pdsurf->pofm->y);
        WriteLogFile(pdsurf->ppdev->pmfile, lg_buf, lg_i,
                     pdsurf->ppdev->TxtBuff, &pdsurf->ppdev->TxtBuffIndex);
    }
}



// ****************************************************************************
//
// LogCreateDibFromScreen()
// This routine is called only from bCreateDibFromScreen()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateDibFromScreen(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf, "CreateDibFromScreen:     Id: 0x%08X ", pdsurf);
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, " \r\n");
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail lock\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf,  "Fail assoc\r\n");
        break;

    case 3: // Failed
        lg_i = sprintf(lg_buf,   " Fail create\r\n");
        break;

    default:
        lg_i = sprintf(lg_buf,  "Failed unknown\r\n");
        break;
    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}



// ****************************************************************************
//
// LogCreateScreenFromDib()
// This routine is called only from bCreateScreenFromDib()
// Dump information to a file about what is going on in device bitmap land.
//
// ****************************************************************************
void LogCreateScreenFromDib(
    int acc,
    PPDEV  ppdev,
    PDSURF pdsurf
)
{
    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,   "CreateScreenFromDib: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    switch(acc)
    {
    case 0: // Succeeded
        lg_i = sprintf(lg_buf, "Id: 0x%08X  Dest: %d,%d\r\n",
                pdsurf, pdsurf->pofm->x, pdsurf->pofm->y );
        break;

    case 1: // Failed
        lg_i = sprintf(lg_buf, "Fail mode\r\n");
        break;

    case 2: // Failed
        lg_i = sprintf(lg_buf, "Fail alloc\r\n");
        break;

    default: // Failed
        lg_i = sprintf(lg_buf, "Fail unknown\r\n");
        break;

    }

    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif // LOG_CALLS


// ============================================================================
//
// Punt a drawing operation back to GDI.
//      Return TRUE if punt was successful.
//      Return FALSE if punt failed.
//
BOOL PuntBitBlt(
    SURFOBJ*  psoDest,
    SURFOBJ*  psoSrc,
    SURFOBJ*  psoMask,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclDest,
    POINTL*   pptlSrc,
    POINTL*   pptlMask,
    BRUSHOBJ* pbo,
    POINTL*   pptlBrush,
    ROP4      rop4)
{
    HBITMAP hbmDibSrc = 0;
    HBITMAP hbmDibDest = 0;
    PBYTE   pjScreen;
    BOOL    bStatus;
    PDSURF  pdsurf;
    PPDEV   ppdev = 0;

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Entry.\n"));


    //
    // If the source is a device bitmap, build a wrapper around it.
    //
    if ( psoSrc && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        // Source is a device bitmap.
        pdsurf = (PDSURF) psoSrc->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Source is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibSrc = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                        ppdev->iBitmapFormat, BMF_TOPDOWN,
                                        pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibSrc, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoSrc = EngLockSurface((HSURF) hbmDibSrc);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Source is device bitmap on host.\n"));
            psoSrc = pdsurf->pso;   // This is where it lives on the host.
        }
    }


    //
    // If the destination is a device bitmap, build a wrapper around it.
    //
    if ( psoDest && (psoDest->iType == STYPE_DEVBITMAP))
    {
        // Destination is a device bitmap.
        pdsurf = (PDSURF) psoDest->dhsurf;
        ppdev = pdsurf->ppdev;

        if ( pdsurf->pofm )  // If it's in the frame buffer.
        {
            DISPDBG((PUNT_DBG_LEVEL,
                "    Dest is device bitmap at (%d,%d).\n",
                (pdsurf->ptl.x), (pdsurf->ptl.y)));

            // Calculate the off-screen address.
            // This is the upper left pixel in the device bitmap.
            pjScreen = ppdev->pjScreen
                     + (pdsurf->ptl.x * ppdev->iBytesPerPixel)
                     + (pdsurf->ptl.y * ppdev->lDeltaScreen);

            // Create a DIB. Point it's bits at the device bitmap.
            hbmDibDest = EngCreateBitmap(pdsurf->sizl, ppdev->lDeltaScreen,
                                         ppdev->iBitmapFormat, BMF_TOPDOWN,
                                         pjScreen);

            // Associate the DIB surface with the driver.
            EngAssociateSurface((HSURF) hbmDibDest, ppdev->hdevEng, 0);

            // Lock the DIB surface.
            psoDest = EngLockSurface((HSURF) hbmDibDest);
        }

        else // The device bitmap is on the host.
        {
            DISPDBG((PUNT_DBG_LEVEL, "    Dest is device bitmap on host.\n"));
            psoDest = pdsurf->pso;
        }
    }


    //
    // We're fooling GDI into thinking it's drawing to memory, when it's really
    // drawing to the frame buffer.  This means GDI won't call DrvSync() before
    // drawing.
    //
    if (ppdev == 0)
    {
         ppdev = (PPDEV) psoDest->dhpdev;
         if (ppdev == 0)
             ppdev = (PPDEV) psoSrc->dhpdev;
    }
    ASSERTMSG(ppdev,"Panic.  No ppdev in PuntBitBlt()!");
    DrvSynchronize((DHPDEV) ppdev, NULL);

    // Now, call the GDI.
    bStatus = EngBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
                        pptlMask, pbo, pptlBrush, rop4);

    // Delete the wrappers if they are created.
    if (hbmDibSrc)
    {
        EngUnlockSurface(psoSrc);
        EngDeleteSurface((HSURF) hbmDibSrc);
    }
    if (hbmDibDest)
    {
        EngUnlockSurface(psoDest);
        EngDeleteSurface((HSURF) hbmDibDest);
    }

    DISPDBG((PUNT_DBG_LEVEL, "PuntBitBlt: Exit.\n"));

    // Return the status.
    return(bStatus);
}

#if SWAT6
/******************************************************************************\
* FUNCTION:             StripePatBlt
*
* DESCRIPTION:  Perform a PatBlt with striping.
*
* ON ENTRY:             ppdev           Pointer to physical device.
*                               x                       X coordinate of blit.
*                               y                       Y coordinate of blit.
*                               cx                      Width of blit.
*                               cy                      Height of blit.
*
* RETURNS:              void            Nothing.
\******************************************************************************/
void
StripePatBlt(
        PPDEV   ppdev,
        ULONG   x,
        ULONG   y,
        ULONG   cx,
        ULONG   cy
)
{
        ULONG cxWidth;
        ULONG TileWidth;

        // Determine number of pixels per tile.
        switch (ppdev->iBytesPerPixel)
        {
                case 1:
                        // 8-bpp.
                        TileWidth = (ULONG) ppdev->lTileSize;
                        break;

                case 2:
                        // 16-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 2;
                        break;

                case 3:
                        // 24-bpp, perform the PatBlt at once since we don't have a nice
                        // number of pixels per tile.
                        REQUIRE(5);
                        LL_OP0(x, y);
                        LL_BLTEXT(cx, cy);
                        if (cx >= 0x391 && cy >= 0x24B)
                        {
                                ENDREQUIRE();
                        }
                        return;

                case 4:
                        // 32-bpp.
                        TileWidth = (ULONG) (ppdev->lTileSize) / 4;
                        break;
        }

        // Determine number of pixels left in first tile.
        cxWidth = TileWidth - (x & (TileWidth - 1));
        if ( (cxWidth >= cx) || (cy == 1) )
        {
                // PatBlt width fits in a single tile.
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(cx, cy);
                return;
        }

        // Perform the PatBlt in the first tile.
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cxWidth, cy);
        cx -= cxWidth;
        x += cxWidth;

        // Keep looping until we reach the last tile of the PatBlt.
        while (cx > TileWidth)
        {
                // Perform the PatBlt on a complete tile (only x changes).
                REQUIRE(5);
                LL_OP0(x, y);
                LL_BLTEXT(TileWidth, cy);
                cx -= TileWidth;
                x += TileWidth;
        }

        // Perform the PatBlt in the last tile (only x changes).
        REQUIRE(5);
        LL_OP0(x, y);
        LL_BLTEXT(cx, cy);

} // StripePatBlt();
#endif // SWAT6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\blt65.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt65.c
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   //uinac/log/log/laguna/ddraw/src/Blt65.c  $
*
*    Rev 1.47   Jun 21 1998 12:16:46   clang
* Fixed PDR#11507 CK with ConCurrent RAM has the same transparent
* blt problem with AC
*
*    Rev 1.46   May 01 1998 15:47:06   frido
* Fixed the checks for the programmable blitter stride.
*
*    Rev 1.45   May 01 1998 13:37:06   frido
* Copied programmable blitter stride to Windows 95 code as well.
*
*    Rev 1.44   May 01 1998 11:12:38   frido
* Added test for programmable blitter stride.
*
*    Rev 1.43   Feb 24 1998 11:36:56   frido
* The overlay data has been changed in Windows NT 5.0.
*
*    Rev 1.42   Feb 16 1998 16:23:06   frido
* Moved the PFN_UPDATEFLIPSTATUS into Windows 95 specific region.
*
*    Rev 1.41   14 Jan 1998 06:14:02   eleland
*
* added support for display list flipping: calls to UpdateFlipStatus are
* thru function pointer pfnUpdateFlipStatus
*
*    Rev 1.40   06 Jan 1998 15:01:58   xcong
* Pass lpDDHALData into some functions and macros for multi-monitor support.
*
*    Rev 1.39   06 Jan 1998 11:52:16   xcong
* change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.38   28 Oct 1997 15:33:24   RUSSL
* src colorkey blts are faster and less work for the hw if just OP2 is used
* with a rop of F0 rather than using both OP1 & OP2 with a rop of CC
* To get back the old way, set the OP2_ONLY_SRC_COLORKEY define to 0
*
*    Rev 1.37   16 Oct 1997 17:01:34   RUSSL
* In Blt65, if REMOVE_GLOBAL_VARS is nonzero, get pdevice pointer from
*   DDRAWI_DIRECTDRAW_GBL struct.  It's a 16:16 ptr so call an asm function
*   to convert it to a 32 bit linear address and then store this in
*   DDRAWI_DIRECTDRAW_GBL dwReserved1 element.
*
*    Rev 1.36   03 Oct 1997 15:45:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.35   01 Oct 1997 12:57:20   eleland
* added check in blt65() to detect blts to host texture surfaces and
* punt those blts back to the ddraw hel
*
*    Rev 1.34   20 Aug 1997 15:36:30   RUSSL
* Added ColorKeyBlt24 function.
* With 256 byte fetch disabled, SrcColorKey blts seem to be working
* correctly at 24bpp and DstColorKey blts appear to be working correctly
* for the tddraw BLT, single DESTKEY, VMem to Primary case but running
* foxbear in 24bpp modes with only DDCKEYCAPS_DESTBLT set doesn't look
* correct.  The best I've been able to do is run the tddraw DESTKEY case
* and force ColorKeyBlt24 to go though each path and verify that they
* each work correctly.  This leads me to expect that foxbear using
* DstColorKeying wasn't debugged very thoroughly (now that's probably a big
* surprise to everyone).  We need more dest color key blt tests.
* For Win95, this was basically a wasted effort since 256 byte fetch appears
* to break 24bpp colorkey blts in some other way, which would require yet
* another workaround.
*
*    Rev 1.33   18 Aug 1997 15:00:42   bennyn
* For NT, if DDBLTFX dwSize not equal to sizeof(DDBLTFX), set dwColor to 0.
*
*    Rev 1.32   13 Aug 1997 12:20:48   bennyn
* For NT, punt if no scratch buffer and DDBLTFX dwSize is not sizeof(DDBLTFX)
*
*    Rev 1.31   29 Jul 1997 17:18:18   bennyn
* Fixed the Foxbear F8 bug
*
*    Rev 1.30   29 Jul 1997 10:51:40   bennyn
* NT only, punt if it is a host to screen BLT
*
*    Rev 1.29   24 Jul 1997 12:30:36   RUSSL
* Added check for NULL src surface ptr in Blt65 before nonlocal vidmem test
*
*    Rev 1.28   24 Jul 1997 11:17:14   RUSSL
* cover up various wickle crimes against humanity
* which means disabling interpolated stretch blts among other things
*
*    Rev 1.27   18 Jul 1997 10:21:50   RUSSL
* Added check for zero extent blts in TransparentStretch65
*
*    Rev 1.26   14 Jul 1997 13:15:14   RUSSL
* Fix for PDR 9947 - include support for all surface formats for blts
* between overlay surfaces
*
*    Rev 1.25   08 Jul 1997 11:50:48   RUSSL
* Rewrite of TransparentStretch65, similar to TransparentStretch in ddblt.c
* but can blt each scanline's full x extent without striping.
* Modified calls to do stretch blt with source colorkeying in Blt65.
*
*    Rev 1.24   07 Jul 1997 13:43:52   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.23   20 Jun 1997 09:45:32   RUSSL
* Added FBToFBCopy to handle blts to/from a linear surface
*   (currently these can be overlay or videoport surfaces only)
* Fixed one of our seemingly inevitable NT/Win95 collisions
*
*    Rev 1.22   12 Jun 1997 17:30:46   bennyn
* For 24 & 32 BPP use StretchColor() instead of TransparentStretch()
*
*    Rev 1.21   23 May 1997 15:41:28   noelv
* Added nt method for chip revision test.
*
*    Rev 1.20   22 May 1997 16:46:38   RUSSL
* Fix for PDRs 9710 & 9706, remove xext <= 8 check on striping of src
* colorkey blts on 65AC (this is a workaround for a hw bug)
* Add check for 65AC or earlier and do striping of src colorkey blts
* on 65AD striping isn't needed so just do single blt
*
*    Rev 1.19   19 May 1997 13:08:10   noelv
* Put NT4.0 wrapper around DrvSrcMBlt call.
*
*    Rev 1.18   16 May 1997 15:32:02   RUSSL
* Added blt case to handle blts from a UYVY surface to another UYVY surface
* This fixes the VFW bugs, WinBench 97 video bugs and Encarta 97 video bugs
* PDRs 9557, 9604, 9692, 9268 & 9270
* Thanks to Peter Hou
*
*    Rev 1.17   16 Apr 1997 18:40:48   RUSSL
* Fix for PDR #9340, for color conversion and resize blts calculate surface
* offset based on frame buffer pixel format then calculate offset into surface
* based on surface pixel format.  Pass DrvStretch65 byte based coordinates
* rather than pixel based coordinates.
*
*    Rev 1.16   16 Apr 1997 10:50:54   bennyn
* Eliminated the warning due to Win95 DBG_MESSAGE call.
*
*    Rev 1.15   08 Apr 1997 11:50:46   einkauf
* WINNT_VER40 affected only:add SYNC_W_3D to coordinate MCD and 2D hw access
*
*    Rev 1.14   03 Apr 1997 15:25:34   RUSSL
* Modified DDBLT_DEPTHFILL case in Blt65 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.13   02 Apr 1997 15:44:54   RUSSL
* Stripe src color key blts at 24bpp, fixes PDR #9113
* Added TransparentStretch65 but hw doesn't work so it's #if'd out
*
*    Rev 1.12   27 Mar 1997 16:12:36   RUSSL
* Tossed the whole bloody mess in the bit bucket.  Reverted to rev 1.1
* Changed name of DrvStretch to DrvStretch65
* Modified DrvStretch65 to do 65-style resize blts using stretch_cntl
*   rather than lncntl
* Added use of original src & dst rectangle (if available) to compute
*   error terms.  Walk DDA's in DrvStretch65 for clipped rect's.
* Changed Blt65 locals dwDstCoord, dwDstWidth, dwDstHeight and dwSrcCoord,
*   dwSrcWidth, dwSrcHeight to DstDDRect and SrcDDRect DDRECTL structures
* Moved sync with queue manager in front of call to updateFlipStatus since
*   updateFlipStatus might access the hardware
* Added workaround for hw bug for src colorkey blts less than one qword
*   wide that require fetching from two src qwords but writing to only
*   one dst qword.  Fixes white lines on foxbear that used to appear in
*   some modes
*
*    Rev 1.11   21 Mar 1997 18:08:38   RUSSL
* Fixups in StretchRect so Foxbear now runs correctly in a window at
* all 4 colordepths
*
*    Rev 1.10   18 Mar 1997 07:51:44   bennyn
* Resolved NT comiling error by #ifdef queue manager sync call
*
*    Rev 1.9   12 Mar 1997 14:59:50   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.8   07 Mar 1997 12:47:10   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.7   03 Mar 1997 10:31:40   eleland
* inserted queue manager sync call to blt65(), removed #ifdef
* USE_QUEUE_MANAGER
*
*    Rev 1.6   21 Feb 1997 15:40:38   RUSSL
* Anybody know why we were doing every 1:1 blt through the
* resize engine rather than just a normal blt ???????
*
*    Rev 1.5   06 Feb 1997 13:09:36   BENNYN
* Fixed DWORD alignment for DD resizing code
*
*    Rev 1.4   31 Jan 1997 13:44:06   BENNYN
* Added clipping support and no interpolation set for 24BPP & YUV src shrink
*
*    Rev 1.3   27 Jan 1997 17:29:14   BENNYN
* Added Win95 support
*
*    Rev 1.2   23 Jan 1997 17:10:10   bennyn
* Modified to support 5465 DD
*
*    Rev 1.1   21 Jan 1997 15:09:28   RUSSL
* Added include of ddinline.h
*
*    Rev 1.0   15 Jan 1997 10:35:20   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35
#else  // !WinNT 3.51

#ifdef WINNT_VER40     // WINNT_VER40

#define DBGLVL        1

#else  // Win95

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"

#include "bltP.h"
#include "ddinline.h"
#include "qmgr.h"

#include "ddshared.h"
#include "overlay.h"

#endif // WINNT_VER40

/*----------------------------- DEFINES -----------------------------------*/

#define OP2_ONLY_SRC_COLORKEY   1

#ifdef WINNT_VER40
#define UPDATE_FLIP_STATUS(arg)   vUpdateFlipStatus(&ppdev->flipRecord,(arg))
#else   // Win95
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg),lpDDHALData)
#endif  // WINNT_VER40

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)

// defines for STRETCH_CNTL register
#define RGB_8_FMT          0
#define RGB_555_FMT        1
#define RGB_565_FMT        2
#define RGB_24_FMT         3
#define RGB_32_FMT         4
#define YUV_422_FMT        9

#define SRC_FMT_SHIFT     12
#define DST_FMT_SHIFT      8
#define SRC_FMT_MASK      0xF000
#define DST_FMT_MASK      0x0F00

#define YSHRINK_ENABLE    0x8
#define XSHRINK_ENABLE    0x4
#define YINTERP_ENABLE    0x2
#define XINTERP_ENABLE    0x1

// bltdef defines
#define BD_TYPE_RESIZE    (1 << 9)
#define BD_TYPE_NORMAL    0

/*----------------------------- TYPEDEFS ----------------------------------*/

typedef short DDAX;
typedef struct tagAxis
{
  DDAX accum;
  DDAX maj;
  DDAX min;
} AXIS;

#if !ENABLE_CLIPPEDBLTS
typedef struct _DDRECTL
{
  REG32   loc;
  REG32   ext;
} DDRECTL;
#endif

/*------------------------- FUNCTION PROTOTYPES ---------------------------*/

#ifdef DEBUG
extern VOID SaveSurfaceToBmp ( DDRAWI_DDRAWSURFACE_LCL *pSurface );
#endif

/*-------------------------- STATIC VARIABLES -----------------------------*/

#ifndef WINNT_VER40

ASSERTFILE("blt65.c");
extern PFN_UPDATEFLIPSTATUS    pfnUpdateFlipStatus;

#endif

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/***************************************************************************
*
* FUNCTION:    DrvStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void DrvStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DDRECTL     OrigSrcDDRect,
  DDRECTL     OrigDstDDRect
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  bltr;
  AXIS          axis[2];
  int           nDst[2];
  int           nSrc[2];
  int           i;
  int           ext;


#ifndef WINNT_VER40
  DBG_MESSAGE(("DrvStretch65: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));
#endif // WINNT_VER40

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);
#endif

  bltr.DRAWBLTDEF.DW = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                              BD_OP1 * IS_VRAM |
                                              BD_TYPE_RESIZE);

  // dst coords
  bltr.OP0_opMRDRAM.DW = DstDDRect.loc.DW;

  // src coords
  bltr.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;

  // blt extent
  bltr.MBLTEXTR_EX.DW = DstDDRect.ext.DW;
#if 1
  // tddraw agp Case 47 puts the goofy happy face with arms image in the middle
  // of the screen and then expects us to stretch it over the top of itself
  // if we don't handle the overlap somehow, the result is trash at the bottom
  // we blt the original src to the lower right of the dest and then stretch
  // that copy of the src to the dest
  // hack, hack, cough, cough
  bltr.BLTEXT.DW = SrcDDRect.ext.DW;        // stuff this here for overlap check
#endif

  bltr.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  bltr.SHRINKINC.W = 0x0000;

  bltr.SRCX = SrcDDRect.ext.pt.X;

  // convert back to pixels for error term computations
  DstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  OrigDstDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  if ((YUV_422_FMT << SRC_FMT_SHIFT) == (SRC_FMT_MASK & Stretch_Cntl))
  {
    bltr.OP1_opMRDRAM.pt.X &= 0xFFFC;
    SrcDDRect.ext.pt.X /= 2;
    OrigSrcDDRect.ext.pt.X /= 2;
  }
  else
  {
    SrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
    OrigSrcDDRect.ext.pt.X /= (USHORT)nBytesPixel;
  }
  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    bltr.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    bltr.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }
  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    bltr.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    bltr.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    bltr.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms.
  nDst[0] = OrigDstDDRect.ext.pt.X;
  nDst[1] = OrigDstDDRect.ext.pt.Y;
  nSrc[0] = OrigSrcDDRect.ext.pt.X;
  nSrc[1] = OrigSrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

#define DO_SW_CLIPPING
#ifdef DO_SW_CLIPPING
  // walk DDA's to get correct initial ACCUM terms
  ext = DstDDRect.loc.pt.X - OrigDstDDRect.loc.pt.X;
  while (0 < ext--)
  {
    bltr.ACCUM_X += bltr.MIN_X;
    if (0 > (short)bltr.ACCUM_X)
    {
      bltr.ACCUM_X += bltr.MAJ_X;
    }
  }
  ext = DstDDRect.loc.pt.Y - OrigDstDDRect.loc.pt.Y;
  while (0 < ext--)
  {
    bltr.ACCUM_Y += bltr.MIN_Y;
    if (0 > (short)bltr.ACCUM_Y)
    {
      bltr.ACCUM_Y += bltr.MAJ_Y;
    }
  }
#else
#pragma message("Add hw clipping")
#endif

#ifdef WINNT_VER40
  ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
  pfnDrvStrBlt(
                lpDDHALData,
#endif
               &bltr);
}

/***************************************************************************
*
* FUNCTION:    TransparentStretch65()
*
* DESCRIPTION:
*
****************************************************************************/

void TransparentStretch65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DDRECTL     SrcDDRect,
  DDRECTL     DstDDRect,
  DWORD       Stretch_Cntl,
  DWORD       ColorKey
)
{
  const int nBytesPixel = BYTESPERPIXEL;

  autoblt_regs  SrcToScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;


  // currently this only supports same src & dst formats
#ifndef WINNT_VER40
  ASSERT(((SRC_FMT_MASK & Stretch_Cntl) >> SRC_FMT_SHIFT) ==
         ((DST_FMT_MASK & Stretch_Cntl) >> DST_FMT_SHIFT));

  DBG_MESSAGE(("TransparentStretch65: %4X,%4X %4Xx%4X -> %4X,%4X %4Xx%4X",
               SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
               SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
               DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
               DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y));

#endif

  if ((0 == DstDDRect.ext.pt.X) || (0 == DstDDRect.ext.pt.Y) ||
      (0 == SrcDDRect.ext.pt.X) || (0 == SrcDDRect.ext.pt.Y))
  {
    // nothing to do, so get outta here!
    return;
  }

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM |
                                                       BD_OP1 * IS_VRAM |
                                                       BD_TYPE_RESIZE);

  // dst coords in bytes (scratch buffer)
  SrcToScratch.OP0_opMRDRAM.DW = lpDDHALData->ScratchBufferOrg;
  SrcToScratch.OP0_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // src coords in bytes
  SrcToScratch.OP1_opMRDRAM.DW = SrcDDRect.loc.DW;
  SrcToScratch.OP1_opMRDRAM.pt.X *= (USHORT)nBytesPixel;

  // blt extent in bytes (1 scanline at a time)
  SrcToScratch.MBLTEXTR_EX.DW = MAKELONG(DstDDRect.ext.pt.X * nBytesPixel,1);

  SrcToScratch.STRETCH_CNTL.W = (WORD)Stretch_Cntl;

  SrcToScratch.SHRINKINC.W = 0x0000;

  SrcToScratch.SRCX = SrcDDRect.ext.pt.X * nBytesPixel;

  if (DstDDRect.ext.pt.X < SrcDDRect.ext.pt.X)
  {
    SrcToScratch.STRETCH_CNTL.W |= XSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~XINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.X = SrcDDRect.ext.pt.X / DstDDRect.ext.pt.X;
  }

  if (DstDDRect.ext.pt.Y < SrcDDRect.ext.pt.Y)
  {
    SrcToScratch.STRETCH_CNTL.W |= YSHRINK_ENABLE;
    SrcToScratch.STRETCH_CNTL.W &= ~YINTERP_ENABLE;
    SrcToScratch.SHRINKINC.pt.Y = SrcDDRect.ext.pt.Y / DstDDRect.ext.pt.Y;
  }

  // Compute DDA terms

  nDst[0] = DstDDRect.ext.pt.X;
  nDst[1] = DstDDRect.ext.pt.Y;
  nSrc[0] = SrcDDRect.ext.pt.X;
  nSrc[1] = SrcDDRect.ext.pt.Y;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XINTERP_ENABLE : YINTERP_ENABLE))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (SrcToScratch.STRETCH_CNTL.W & ((i==0) ? XSHRINK_ENABLE : YSHRINK_ENABLE))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < DstDDRect.ext.pt.Y)
  {
    // blt one scanline high from src to scratch buffer
#ifdef WINNT_VER40
    ppdev->pfnDrvStrBlt(ppdev, lpDDHALData,
#else
    pfnDrvStrBlt(
                lpDDHALData,
#endif
                 &SrcToScratch);

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opMRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opMRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                 MAKELONG((DD_TRANS | ROP_OP2_copy),
                          ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                 MAKELONG((DD_TRANS | ROP_OP1_copy),
                          ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
#endif
                 DstDDRect.loc.DW,
                 lpDDHALData->ScratchBufferOrg,
                 lpDDHALData->ScratchBufferOrg,
                 ColorKey,
                 MAKELONG(DstDDRect.ext.pt.X,1));
    DstDDRect.loc.pt.Y++;
    DstDDRect.ext.pt.Y--;
  }
}

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:    FBToFBCopy()
*
* DESCRIPTION:
*
****************************************************************************/

VOID
FBToFBCopy ( BYTE *dst, LONG dstPitch, BYTE *src, LONG srcPitch, REG32 ext, LONG bpp )
{
  int yext = ext.pt.Y;
  int xext = ext.pt.X * bpp;

  while (0 < yext--)
  {
    memcpy(dst,src,xext);
    dst += dstPitch;
    src += srcPitch;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:    ColorKeyBlt24()
*
* DESCRIPTION:
*
****************************************************************************/

#define MIN_WIDTH     21    // empirically determined that most widths less than this don't work
#define STRIPE_WIDTH  40    // max is 128 / 3 = 42 pixels, but use 40 to account for phase

STATIC VOID ColorKeyBlt24
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       drawbltdef,
  DDRECTL     DstDDRect,
  DDRECTL     SrcDDRect,
  DDRECTL     KeyDDRect,
  DWORD       dwColorKey
)
{
  short   xStep = 1;
  short   yStep = 1;
  WORD    xExt;


  // check for overlap
  if ((abs(DstDDRect.loc.pt.X - SrcDDRect.loc.pt.X) < DstDDRect.ext.pt.X) &&
      (abs(DstDDRect.loc.pt.Y - SrcDDRect.loc.pt.Y) < DstDDRect.ext.pt.Y))
  {
    // see if we need to blt from bottom to top
    if (DstDDRect.loc.pt.Y > SrcDDRect.loc.pt.Y)
    {
      // point to bottom scanline and update bltdef
      drawbltdef |= MAKELONG(0, BD_YDIR);
      DstDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      SrcDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      KeyDDRect.loc.pt.Y += (DstDDRect.ext.pt.Y - 1);
      yStep = -1;
    }
    // see if we need to blt from right to left
    if (DstDDRect.loc.pt.X > SrcDDRect.loc.pt.X)
    {
      // point to right edge pixel
      DstDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      SrcDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      KeyDDRect.loc.pt.X += (DstDDRect.ext.pt.X - 1);
      xStep = -1;
    }
  }

  // if width is too narrow, do blt a pixel at a time
  // Also blt a pixel at a time for certain overlapping src/dst combinations
  // that won't work correctly otherwise.  While setting BD_YDIR to blt from
  // bottom to top and also bltting in SRAM width stripes from right to left
  // do work at 24bpp, they unfortunately don't work for certain overlap cases.
  // In particular BD_YDIR doesn't work when you need it (period!) and bltting
  // in SRAM width stripes from right to left doesn't work if the src and dst
  // have the same y.  Take out the two || cases and try the tddraw
  // BLT_BltFast, SRCKEY, From/To same surface test and see for yourself.
  if (   (MIN_WIDTH >= DstDDRect.ext.pt.X)
      || (0 > yStep)
      || ((0 > xStep) && (DstDDRect.loc.pt.Y == SrcDDRect.loc.pt.Y))
     )
  {
BltOnePixelAtATime:
    // loop over scanlines
    while (0 < DstDDRect.ext.pt.Y)
    {
      DWORD   dst  = DstDDRect.loc.DW;
      DWORD   src  = SrcDDRect.loc.DW;
      DWORD   key  = KeyDDRect.loc.DW;

      xExt = DstDDRect.ext.pt.X;

      // loop over pixels in scanline
      while (0 < xExt)
      {
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                lpDDHALData,
#endif
                     drawbltdef, dst, src, key, dwColorKey, MAKELONG(1,1));
        // adjust extent and ptrs (x is in low word)
        xExt--;
        dst += xStep;
        src += xStep;
        key += xStep;
      }
      // adjust extent and ptrs (y is in high word)
      DstDDRect.ext.pt.Y--;
      SrcDDRect.loc.pt.Y += yStep;
      DstDDRect.loc.pt.Y += yStep;
      KeyDDRect.loc.pt.Y += yStep;
    }
  }
  // if width is less than SRAM width, just do a single blt
  else if (STRIPE_WIDTH >= DstDDRect.ext.pt.X)
  {
    // except if there's overlap, do it the slow way
    //if ((0 > xStep) || (0 > yStep))
    if (0 > xStep)          // check for (0 > yStep) already handled above
      goto BltOnePixelAtATime;

    // just blt it
#ifdef WINNT_VER40
    ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
    pfnDrvSrcBlt(
                lpDDHALData,
#endif
                 drawbltdef,
                 DstDDRect.loc.DW,
                 SrcDDRect.loc.DW,
                 KeyDDRect.loc.DW,
                 dwColorKey,
                 DstDDRect.ext.DW);
  }
  // stripe the blt into SRAM width blts
  else
  {
    xExt = STRIPE_WIDTH;

    // blt from right to left
    if (0 > xStep)
    {
      DstDDRect.loc.pt.X++;
      SrcDDRect.loc.pt.X++;
      KeyDDRect.loc.pt.X++;

      while (1)
      {
        // adjust ptrs to start of stripe
        DstDDRect.loc.pt.X -= xExt;
        SrcDDRect.loc.pt.X -= xExt;
        KeyDDRect.loc.pt.X -= xExt;

        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 == DstDDRect.ext.pt.X)
          break;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // but first point to x pixel to start with
            SrcDDRect.loc.pt.X--;
            DstDDRect.loc.pt.X--;
            KeyDDRect.loc.pt.X--;
            goto BltOnePixelAtATime;
          }
        }
      }
    }
    // blt from left to right
    else
    {
      while (1)
      {
        // blt the stripe
#ifdef WINNT_VER40
        ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
        pfnDrvSrcBlt(
                    lpDDHALData,
#endif
                     drawbltdef,
                     DstDDRect.loc.DW,
                     SrcDDRect.loc.DW,
                     KeyDDRect.loc.DW,
                     dwColorKey,
                     MAKELONG(xExt,DstDDRect.ext.pt.Y));

        // adjust remaining extent
        DstDDRect.ext.pt.X -= xExt;
        // are we done?
        if (0 >= DstDDRect.ext.pt.X)
          break;

        // adjust ptrs to start of next stripe
        SrcDDRect.loc.pt.X += xExt;
        DstDDRect.loc.pt.X += xExt;
        KeyDDRect.loc.pt.X += xExt;

        // last stripe might not be STRIPE_WIDTH wide
        if (xExt > DstDDRect.ext.pt.X)
        {
          xExt = DstDDRect.ext.pt.X;

          // if the last stripe is too narrow,
          // finish the blt the even slower way
          if (MIN_WIDTH >= xExt)
          {
            // ptrs already set
            goto BltOnePixelAtATime;
          }
        }
      }
    }
  }
}

/***************************************************************************
*
* FUNCTION:    Blt65()
*
* DESCRIPTION:
*
****************************************************************************/

#ifdef WINNT_VER40
DWORD Blt65(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;
#else   // Win95
DWORD __stdcall
Blt65 ( LPDDHAL_BLTDATA pbd)
{
LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif

  HRESULT  ddrval;
  DWORD    dwFlags;

  DDRECTL DstDDRect;
  DDRECTL SrcDDRect;

#ifdef WINNT_VER40

  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - Blt65\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;  //why ?
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // Win95

  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#if defined(REMOVE_GLOBAL_VARS) && (REMOVE_GLOBAL_VARS != 0)
  PDEV  *ppdev;

  ppdev = GetPDevice(pbd->lpDD);
#endif
#endif  // WINNT_VER40

  DD_LOG(("Blt65 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);

  // Punt, we don't support Host memory to Screen BLT
  if ((NULL != pbd->lpDDSrcSurface) &&
      (pbd->lpDDSrcSurface->lpGbl->xHint != 0) &&
      (pbd->lpDDSrcSurface->lpGbl->yHint != 0) &&
      (pbd->lpDDSrcSurface->dwReserved1 == 0))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif

#if 1 // PC98
#ifdef WINNT_VER40
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < ppdev->lDeltaScreen)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#else
	if (   (pbd->lpDDSrcSurface != NULL)
		&& (pbd->lpDDSrcSurface->lpGbl->lPitch < pDriverData->HALInfo.vmiData.lDisplayPitch)
	)
	{
		pbd->ddRVal = DDERR_UNSUPPORTED;
		return DDHAL_DRIVER_NOTHANDLED;
	}
#endif
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

  // is a flip in progress?
#ifdef WINNT_VER40
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpData->fpVidMem,lpDDHALData);
#else
  ddrval = pfnUpdateFlipStatus(pbd->lpDDDestSurface->lpGbl->fpVidMem,lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
    pbd->ddRVal = ddrval;
    DD_LOG(("Blt65 Exit - flip in progress, returning %08lX\r\n", ddrval));
    return (DDHAL_DRIVER_HANDLED);
  }

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

#if 1
  // billy and dah boyz strike again
  // tddraw agp Case 59 asks us to blt between to nonlocal video memory
  // surfaces even though we report that we don't support offscreen
  // plain nonlocal video memory surfaces
  // why is ddraw allocating offscreen plain surfaces in agp memory?
#if DDRAW_COMPAT >= 50
  // see if the dest is in nonlocal video memory
  if (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
  // if there is a src, see if it's in nonlocal video memory
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_NONLOCALVIDMEM & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    pbd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
  }
#endif
#endif

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // get offset, width, and height for destination
#if defined(DDRAW_COMPAT_10)
  dst  = pbd->lpDDDestSurface->lpData;
#else
  dst  = pbd->lpDDDestSurface->lpGbl;
#endif

#ifdef WINNT_VER40
  DstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
  DstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
  DstDDRect.loc.DW  += MAKELONG(pbd->rDest.left,pbd->rDest.top);
  DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right  - pbd->rDest.left);
  DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
#if defined(DDRAW_COMPAT_10)
      src  = pbd->lpDDSrcSurface->lpData;
#else
      src  = pbd->lpDDSrcSurface->lpGbl;
#endif

#ifdef WINNT_VER40
      SrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      SrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif
      SrcDDRect.loc.DW  += MAKELONG(pbd->rSrc.left,pbd->rSrc.top);
      SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right  - pbd->rSrc.left);
      SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDSrcSurface);
#endif

        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
#ifdef WINNT_VER40
           // If there is no scratch buffer allocated then punt the
           // transparent stretch BLT
           if (lpDDHALData->ScratchBufferOrg == 0)
           {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
           };
#endif

          if ( !(pbd->lpDDSrcSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (16 >= BITSPERPIXEL)
            {
              DWORD     StretchCntl;


              if (8 == BITSPERPIXEL)
              {
                StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                              (RGB_8_FMT << DST_FMT_SHIFT) |
                              0;
              }
              else
              {
                // this only works because the src & dst fmt's in stretch control
                // for 565, 24bpp & 32bpp are the same as the bytes/pixel
                StretchCntl = (BYTESPERPIXEL << SRC_FMT_SHIFT) |
                              (BYTESPERPIXEL << DST_FMT_SHIFT) |
                              0;
              }
#ifdef WINNT_VER40
              TransparentStretch65(ppdev, lpDDHALData,
#else
              TransparentStretch65(
                                   lpDDHALData,
#endif
                                   SrcDDRect, DstDDRect, StretchCntl, dwColor);
            }
            else
            {
#ifdef WINNT_VER40
              StretchColor(ppdev, lpDDHALData,
#else
              StretchColor(
                           lpDDHALData,
#endif
                           DstDDRect.loc.pt.X, DstDDRect.loc.pt.Y,
                           DstDDRect.ext.pt.X, DstDDRect.ext.pt.Y,
                           SrcDDRect.loc.pt.X, SrcDDRect.loc.pt.Y,
                           SrcDDRect.ext.pt.X, SrcDDRect.ext.pt.Y,
                           dwColor);
            }
            goto blt_exit;
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

        if (24 != BITSPERPIXEL)
        {
          // if it's 5465AC or earlier, do hw transparency bug workaround
#ifdef WINNT_VER40
          if (1 >= ppdev->dwLgDevRev)
#else
#if 1 //PDR#11507 CK with ConCurrent RAM has the same transparent blt problem with AC.
          if (1 >= lpDDHALData->bLgRevID)
#else
			 if ( ( 1 >= lpDDHALData->bLgRevID ) ||
				 ( (0x25 == lpDDHALData->bLgRevID) &&
					 lpDDHALData->bConCurrentRAM) )
#endif
#endif
          {
            // convert to byte extents and positions
            SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            SrcDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
            DstDDRect.ext.pt.X *= (WORD)BYTESPERPIXEL;

            if (//(8 >= SrcDDRect.ext.pt.X) &&
                ((7 & SrcDDRect.loc.pt.X) > (7 & DstDDRect.loc.pt.X)))
            {
              WORD  x_ext;

              x_ext = 8 - (SrcDDRect.loc.pt.X & 7);
              if (x_ext < SrcDDRect.ext.pt.X)
              {
#ifdef WINNT_VER40
                ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
                pfnDrvSrcMBlt(
                               lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                              MAKELONG((DD_TRANS | ROP_OP2_copy),
                                       ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                              MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                              DstDDRect.loc.DW,
                              SrcDDRect.loc.DW,
                              SrcDDRect.loc.DW,  // Src transparency
                              dwColor,
                              MAKELONG(x_ext,DstDDRect.ext.pt.Y));
                SrcDDRect.loc.pt.X += x_ext;
                DstDDRect.loc.pt.X += x_ext;
                SrcDDRect.ext.pt.X -= x_ext;
                DstDDRect.ext.pt.X -= x_ext;
              }
            }
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcMBlt(
                            lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                          MAKELONG((DD_TRANS | ROP_OP2_copy),
                                   ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                          MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                          DstDDRect.loc.DW,
                          SrcDDRect.loc.DW,
                          SrcDDRect.loc.DW,  // Src transparency
                          dwColor,
                          DstDDRect.ext.DW);
          }
          // 5465AD and later can do it as a single blt
          else
          {
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                         MAKELONG((DD_TRANS | ROP_OP2_copy),
                                  ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                         MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
#endif
                         DstDDRect.loc.DW,
                         SrcDDRect.loc.DW,
                         SrcDDRect.loc.DW,  // Src transparency
                         dwColor,
                         DstDDRect.ext.DW);
          }
        }
        else // 24bpp workaround (needed on 5465AD also)
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
#if OP2_ONLY_SRC_COLORKEY
                        MAKELONG((DD_TRANS | ROP_OP2_copy),
                                 ((BD_RES+BD_OP2)*IS_VRAM)),
#else
                        MAKELONG(rop|DD_TRANS, bdf|BD_OP2),
#endif
                        DstDDRect,
                        SrcDDRect,
                        SrcDDRect,   // src transparency
                        dwColor);
        }
#ifdef DEBUG
        if (FALSE)
          SaveSurfaceToBmp(pbd->lpDDDestSurface);
#endif

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        DWORD dwColor;

        dwColor =
#ifdef WINNT_VER40
                        DupColor(ppdev,
#else
                        DupColor(
                                 lpDDHALData,
#endif
                                 pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
            (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

#ifdef WINNT_VER40
        // If the dwSize not equal to the size of DDBLTFX structure
        // Punt it.
        //
        // For the WHQL TDDRAW test case 29, for some reason, the DDBLTFX
        // structure in DD_BLTDATA is invalid. The dwSize and the
        // ddckDestColorkey fields contain garbage value.
        // In order to pass the test, we force the dwColor to zero if
        // the dwSize of DDBLTFX is invalid.
        if (pbd->bltFX.dwSize != sizeof(DDBLTFX))
        {
//           ddrval = DDERR_UNSUPPORTED;
//           goto blt_exit;
            dwColor = 0;
        };
#endif

        if (24 != BITSPERPIXEL)
        {
#ifdef WINNT_VER40
          ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
          pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                       MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                       DstDDRect.loc.DW,
                       SrcDDRect.loc.DW,
                       DstDDRect.loc.DW,  // Dst transparency
                       dwColor,     //
                       DstDDRect.ext.DW);
        }
        else
        {
#ifdef WINNT_VER40
          ColorKeyBlt24(ppdev,lpDDHALData,
#else
          ColorKeyBlt24(
                        lpDDHALData,
#endif
                        MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf|BD_OP2),
                        DstDDRect,
                        SrcDDRect,
                        DstDDRect,   // dst transparency
                        dwColor);
        }
      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#if _WIN32_WINNT >= 0x0500
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT)
#else
	#define BLAM  (DDRAWISURF_HASPIXELFORMAT | DDRAWISURF_HASOVERLAYDATA)
#endif
        if ((BLAM == (BLAM & pbd->lpDDDestSurface->dwFlags)) &&
            (BLAM == (BLAM & pbd->lpDDSrcSurface->dwFlags))
#if _WIN32_WINNT >= 0x0500
			&& (pbd->lpDDDestSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
			&& (pbd->lpDDSrcSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
		)
        {
          if (//(FOURCC_UYVY == dst->ddpfSurface.dwFourCC) &&
              //(FOURCC_UYVY == src->ddpfSurface.dwFourCC) &&
              (SrcDDRect.ext.pt.X == DstDDRect.ext.pt.X) &&
              (SrcDDRect.ext.pt.Y == DstDDRect.ext.pt.Y))
          {
#ifndef WINNT_VER40
            LP_SURFACE_DATA lpSrcSurfaceData;
            LP_SURFACE_DATA lpDstSurfaceData;
#endif
            DWORD   dstbpp,srcbpp;

            dstbpp = pbd->lpDDDestSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            srcbpp = pbd->lpDDSrcSurface->lpGbl->ddpfSurface.dwRGBBitCount / 8;
            if (dstbpp != srcbpp)
            {
              ddrval = DDERR_UNSUPPORTED;
              goto blt_exit;
            }

#ifndef WINNT_VER40
            // see if either the src or dst is a linear surface
            // if so do a CPU memcpy
            lpSrcSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);
            lpDstSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);
            if ((FLG_LINEAR & lpSrcSurfaceData->dwOverlayFlags) ||
                (FLG_LINEAR & lpDstSurfaceData->dwOverlayFlags))
            {
              if (ROP_OP1_copy == rop)
              {
                // mind numbing fb to fb copy
                FBToFBCopy((BYTE *)(lpDDHALData->ScreenAddress + DstDDRect.loc.pt.Y * PITCH + DstDDRect.loc.pt.X * 2),
                           dst->lPitch,
                           (BYTE *)(lpDDHALData->ScreenAddress + SrcDDRect.loc.pt.Y * PITCH + SrcDDRect.loc.pt.X * 2),
                           src->lPitch,
                           DstDDRect.ext,
                           dstbpp);
              }
              else
              {
                // punt it
                ddrval = DDERR_UNSUPPORTED;
                goto blt_exit;
              }
            }
            else
#endif
            {
              SrcDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              DstDDRect.loc.pt.X *= (WORD)BYTESPERPIXEL;
              SrcDDRect.ext.pt.X *= (WORD)dstbpp;
              DstDDRect.ext.pt.X *= (WORD)dstbpp;
#ifdef WINNT_VER40
              ppdev->pfnDrvSrcMBlt(ppdev, lpDDHALData,
#else
              pfnDrvSrcMBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop, bdf),
                            DstDDRect.loc.DW,
                            SrcDDRect.loc.DW,
                            0UL,         // don't care
                            0UL,
                            DstDDRect.ext.DW);
            }
          }
          else
          {
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }
        else if ((SrcDDRect.ext.pt.X != DstDDRect.ext.pt.X) ||
                 (SrcDDRect.ext.pt.Y != DstDDRect.ext.pt.Y) ||
                 (DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags))
        {
          DWORD     StretchCntl;
          DDRECTL   OrigSrcDDRect;
          DDRECTL   OrigDstDDRect;
          int       nDstBytesPixel = BYTESPERPIXEL;
          int       nSrcBytesPixel = BYTESPERPIXEL;


          if (8 == BITSPERPIXEL)
          {
            StretchCntl = (RGB_8_FMT << SRC_FMT_SHIFT) |
                          (RGB_8_FMT << DST_FMT_SHIFT) |
                          0;
          }
          else if ((DDRAWISURF_HASPIXELFORMAT & pbd->lpDDSrcSurface->dwFlags) &&
                   (DDPF_FOURCC & src->ddpfSurface.dwFlags) &&
                   (FOURCC_UYVY == src->ddpfSurface.dwFourCC))
          {
            StretchCntl =   (YUV_422_FMT << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
                          | XINTERP_ENABLE | YINTERP_ENABLE
                          ;
            nSrcBytesPixel = 2;
          }
          else
          {
            // this only works because the src & dst fmt's in stretch control
            // for 565, 24bpp & 32bpp are the same as the bytes/pixel
            StretchCntl =   (BYTESPERPIXEL << SRC_FMT_SHIFT)
                          | (BYTESPERPIXEL << DST_FMT_SHIFT)
#if 0
            // tddraw agp Cases 21, 23 & 42 do stretch blts with ddraw and
            // the same stretch through gdi, then they expect the results
            // to be identical
            // Since our display driver is not using interpolation on stretch
            // blts then we either need to rewrite StretchBlt in the display
            // driver (lots of days of work) or disable interpolation in
            // ddraw (a one line change)
                          | XINTERP_ENABLE | YINTERP_ENABLE
#endif
                          ;
          }

          // now compute byte coordinates of src and dst
          // upper left of surface is based on frame buffer pixel format
          // offset into surface is based on surface pixel format
#ifdef WINNT_VER40
          OrigDstDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else
          OrigDstDDRect.loc.DW = cvlxy(lpDDHALData,dst->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigDstDDRect.loc.pt.X *= (USHORT)nDstBytesPixel;
          DstDDRect.loc.DW = OrigDstDDRect.loc.DW;

#ifdef WINNT_VER40
          OrigSrcDDRect.loc.DW = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else
          OrigSrcDDRect.loc.DW = cvlxy(lpDDHALData,src->fpVidMem-lpDDHALData->ScreenAddress,
                                       BYTESPERPIXEL);
#endif
          OrigSrcDDRect.loc.pt.X *= (USHORT)nDstBytesPixel; // YES, it's nDstBytesPixel
          SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;

#ifndef WINNT_VER40   // nt doesn't get this info
          if (pbd->IsClipped)
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rOrigDest.left * nDstBytesPixel,
                                             pbd->rOrigDest.top);
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rOrigDest.right - pbd->rOrigDest.left) *
                                            nDstBytesPixel);
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rOrigSrc.left * nSrcBytesPixel,
                                             pbd->rOrigSrc.top);
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rOrigSrc.right - pbd->rOrigSrc.left) *
                                            nSrcBytesPixel);
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            DstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                         pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                        nDstBytesPixel);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            SrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                         pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                        nSrcBytesPixel);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
          }
          else
#endif
          {
            OrigDstDDRect.loc.DW += MAKELONG(pbd->rDest.left * nDstBytesPixel,
                                             pbd->rDest.top);
            DstDDRect.loc.DW = OrigDstDDRect.loc.DW;
            OrigDstDDRect.ext.pt.X = (WORD)((pbd->rDest.right - pbd->rDest.left) *
                                            nDstBytesPixel);
            DstDDRect.ext.pt.X = OrigDstDDRect.ext.pt.X;
            OrigDstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
            DstDDRect.ext.pt.Y = OrigDstDDRect.ext.pt.Y;

            OrigSrcDDRect.loc.DW += MAKELONG(pbd->rSrc.left * nSrcBytesPixel,
                                             pbd->rSrc.top);
            SrcDDRect.loc.DW = OrigSrcDDRect.loc.DW;
            OrigSrcDDRect.ext.pt.X = (WORD)((pbd->rSrc.right - pbd->rSrc.left) *
                                            nSrcBytesPixel);
            SrcDDRect.ext.pt.X = OrigSrcDDRect.ext.pt.X;
            OrigSrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
            SrcDDRect.ext.pt.Y = OrigSrcDDRect.ext.pt.Y;
          }

#ifdef WINNT_VER40
          DrvStretch65(ppdev, lpDDHALData,
#else
          DrvStretch65(
                        lpDDHALData,
#endif
                     SrcDDRect,
                     DstDDRect,
                     StretchCntl,
                     OrigSrcDDRect,
                     OrigDstDDRect);
        }
        else
        {
#if ENABLE_CLIPPEDBLTS
          DWORD   dstBaseXY;
          DWORD   srcBaseXY;

#ifdef WINNT_VER40
          dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
          srcBaseXY = cvlxy(ppdev->lDeltaScreen,src->fpVidMem,BYTESPERPIXEL);
#else   // Win95
          dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
          srcBaseXY = cvlxy(src->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

          if (pbd->IsClipped)
          {
            // compute original dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

            // compute original src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rOrigSrc.left, pbd->rOrigSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rOrigSrc.right - pbd->rOrigSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rOrigSrc.bottom - pbd->rOrigSrc.top);

            // do the blts
#ifdef WINNT_VER40
            ppdev->pfnClippedDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnClippedDrvSrcBlt(
                        lpDDHALData,
#endif
                                MAKELONG(rop|DD_CLIP, bdf),
						                    DstDDRect.loc.DW,
						                    SrcDDRect.loc.DW,
						                    0UL,         // don't care
						                    0UL,
						                    DstDDRect.ext.DW,
                                dstBaseXY,
                                srcBaseXY,
                                pbd->dwRectCnt,
                                pbd->prDestRects);
          }
          else  // just do a single blt
          {
            // compute dst coordinates
            DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
            DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
            DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);

            // compute src coordinates
            SrcDDRect.loc.DW   = srcBaseXY + MAKELONG(pbd->rSrc.left, pbd->rSrc.top);
            SrcDDRect.ext.pt.X = (WORD)(pbd->rSrc.right - pbd->rSrc.left);
            SrcDDRect.ext.pt.Y = (WORD)(pbd->rSrc.bottom - pbd->rSrc.top);
#endif  // ENABLE_CLIPPEDBLTS

            // do the blt
#ifdef WINNT_VER40
            ppdev->pfnDrvSrcBlt(ppdev, lpDDHALData,
#else
            pfnDrvSrcBlt(
                        lpDDHALData,
#endif
                         MAKELONG(rop, bdf),
						             DstDDRect.loc.DW,
						             SrcDDRect.loc.DW,
						             0UL,         // don't care
						             0UL,
						             DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
          }
#endif  // ENABLE_CLIPPEDBLTS
				}
      }
    }
    else // DST ONLY rops
    {
#if ENABLE_CLIPPEDBLTS
      DWORD   dstBaseXY;
#endif  // ENABLE_CLIPPEDBLTS

      DD_LOG(("Dst Only Blt\r\n"));

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
      dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
      dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

      if (pbd->IsClipped)
      {
        // compute original dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

        // do the blts
#ifdef WINNT_VER40
        ppdev->pfnDrvClippedDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                            MAKELONG(rop|DD_CLIP, bdf),
                            DstDDRect.loc.DW,
                            0UL,         // don't care
                            DstDDRect.ext.DW,
                            dstBaseXY,
                            pbd->dwRectCnt,
                            pbd->prDestRects);
      }
      else  // just do a single blt
      {
        // compute dst coordinates
        DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
        DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
        DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
        ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
        pfnDrvDstBlt(
                        lpDDHALData,
#endif
                     MAKELONG(rop, bdf),
                     DstDDRect.loc.DW,
                     0UL,  // don't care
                     DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
      }
#endif  // ENABLE_CLIPPEDBLTS
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor;
#if ENABLE_CLIPPEDBLTS
    DWORD   dstBaseXY;
#endif


    DD_LOG(("Solid Color Fill\r\n"));

#ifdef WINNT_VER40
    dwColor = DupColor(ppdev,pbd->bltFX.dwFillColor);
#else
    dwColor = DupColor(lpDDHALData,pbd->bltFX.dwFillColor);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvClippedDstBlt(
                        lpDDHALData,
#endif
                          MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                          DstDDRect.loc.DW,
                          dwColor,
                          DstDDRect.ext.DW,
                          dstBaseXY,
                          pbd->dwRectCnt,
                          pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

#ifdef WINNT_VER40
      ppdev->pfnDrvDstBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstBlt(
                        lpDDHALData,
#endif
                   MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                   DstDDRect.loc.DW,
                   dwColor,  // fill color
                   DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif
  }
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    DWORD   dwFillDepth;
#if ENABLE_CLIPPEDBLTS      // I don't think we'll ever get a clipped zbuffer but you never know ...
    DWORD   dstBaseXY;
#endif // ENABLE_CLIPPEDBLTS


    DD_LOG(("Depth Fill Blt\r\n"));

#ifdef WINNT_VER40
    dwFillDepth = DupZFill(ppdev,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#else
    dwFillDepth = DupZFill(lpDDHALData,pbd->bltFX.dwFillDepth,dst->ddpfSurface.dwZBufferBitDepth);
#endif

#if ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
    dstBaseXY = cvlxy(ppdev->lDeltaScreen,dst->fpVidMem,BYTESPERPIXEL);
#else   // Win95
    dstBaseXY = cvlxy(dst->fpVidMem-lpDDHALData->ScreenAddress,BYTESPERPIXEL);
#endif

    if (pbd->IsClipped)
    {
      // compute original dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rOrigDest.left, pbd->rOrigDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rOrigDest.right - pbd->rOrigDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rOrigDest.bottom - pbd->rOrigDest.top);

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

      // do the blts
#ifdef WINNT_VER40
      ppdev->pfnClippedDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnClippedDrvDstMBlt(
                        lpDDHALData,
#endif
                           MAKELONG(ROP_OP1_copy | DD_CLIP, BD_RES | (BD_OP1 * IS_SOLID)),
                           DstDDRect.loc.DW,
                           dwFillDepth,
                           DstDDRect.ext.DW,
                           dstBaseXY,
                           pbd->dwRectCnt,
                           pbd->prDestRects);
    }
    else  // just do a single blt
    {
      // compute dst coordinates
      DstDDRect.loc.DW   = dstBaseXY + MAKELONG(pbd->rDest.left, pbd->rDest.top);
      DstDDRect.ext.pt.X = (WORD)(pbd->rDest.right - pbd->rDest.left);
      DstDDRect.ext.pt.Y = (WORD)(pbd->rDest.bottom - pbd->rDest.top);
#endif  // ENABLE_CLIPPEDBLTS

      // convert to byte blt
      // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
      // of zbuffer
      // Fixes PDR #9152
      DstDDRect.loc.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
      DstDDRect.ext.pt.X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);

#ifdef WINNT_VER40
      ppdev->pfnDrvDstMBlt(ppdev, lpDDHALData,
#else
      pfnDrvDstMBlt(
                    lpDDHALData,
#endif
                    MAKELONG(ROP_OP1_copy, BD_RES | (BD_OP1 * IS_SOLID)),
                    DstDDRect.loc.DW,
                    dwFillDepth,
                    DstDDRect.ext.DW);
#if ENABLE_CLIPPEDBLTS
    }
#endif // ENABLE_CLIPPEDBLTS
  }
#endif
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt65 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;
} /* Blt65 */

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\bltmm.c ===
/******************************Module*Header*******************************\
*
* $Workfile:   BLTMM.C  $
*
* Contains the low-level memory-mapped IO blt functions.  This module
* mirrors 'bltio.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BLTMM.C  $
*
*    Rev 1.3   Mar 04 1998 15:11:50   frido
* Added new shadow macros.
*
*    Rev 1.2   Nov 03 1997 11:44:02   frido
* Added REQUIRE macros.
*
\**************************************************************************/

#include "precomp.h"

#define BLTMM_DBG_LEVEL 0

extern BYTE gajRop[];

/******************************Public*Routine******************************\
* VOID vMmFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMmFillSolid(              // Type FNFILL
PDEV*     ppdev,
LONG      c,                    // Can't be zero
RECTL*    prcl,                 // List of rectangles to be filled, in relative
                                                //  coordinates
ULONG     ulHwForeMix,  // Hardware mix mode
ULONG     ulHwBackMix,  // Not used
BRUSHOBJ* pbo,          // Drawing colour is pbo->iSolidColor
POINTL*   pptlBrush)    // Not used
{
        ULONG  ulColor;         // color

        ulColor = pbo->iSolidColor;
    switch (ppdev->ulBitCount)
        {
                case 8:
                        ulColor |= ulColor << 8;

                case 16:
                        ulColor |= ulColor << 16;
        }
        REQUIRE(4);
        LL_BGCOLOR(ulColor, 0);
        LL_DRAWBLTDEF((ppdev->uBLTDEF << 16) | ulHwForeMix, 0);

    do
    {
        REQUIRE(5);
        LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

        prcl++;
    }
        while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmFillPatFast
*
* This routine uses the S3 pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
BRUSHOBJ*                pbo,            // pbo
POINTL*         pptlBrush)      // Pattern alignment
{
        ULONG ulBltDef = ppdev->uBLTDEF;

        if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
        {
                return;
        }

    REQUIRE(2);
    LL_DRAWBLTDEF((ulBltDef << 16) | ulHwForeMix, 2);

    do
    {
                REQUIRE(5);
                LL_OP0(prcl->left + ppdev->ptlOffset.x, prcl->top + ppdev->ptlOffset.y);
                LL_BLTEXT(prcl->right - prcl->left, prcl->bottom - prcl->top);

                prcl++;
    }
    while (--c != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\blt_dir.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dir.c
*
* DESCRIPTION:  Direct blts for the 546x
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/src/blt_dir.c  $
* 
*    Rev 1.21   Mar 04 1998 15:07:10   frido
* Added new shadow macros.
* 
*    Rev 1.20   06 Jan 1998 11:40:56   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
* 
*    Rev 1.19   Nov 04 1997 09:36:16   frido
* Argh! This file is shared with WIndows 95 and it breaks there because I added
* the REQUIRE macro. So I have defined it for non Windows NT as the WaitForRoom
* macro.
* 
*    Rev 1.18   Nov 03 1997 12:48:22   frido
* Added REQUIRE macros.
* Removed redundant WaitForRoom macros.
* 
*    Rev 1.17   03 Oct 1997 14:29:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.16   19 Aug 1997 09:18:42   RUSSL
* Updated require counts in DIR_DrvStrBlt & DIR_DrvStrBlt65
*
*    Rev 1.15   30 Jul 1997 20:55:52   RANDYS
* Added code to check for zero extent blts
*
*    Rev 1.14   24 Jul 1997 12:32:02   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.13   24 Jul 1997 11:19:02   RUSSL
* Added DIR_DrvStrBlt_OverlapCheck & DIR_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.12   14 Jul 1997 14:55:50   RUSSL
* For Win95, split DIR_DrvStrBlt into two versions, one version for 62/64
* and one version for 65+.  BltInit points pfnDrvStrBlt to the appropriate
* version.
*
*    Rev 1.11   08 Jul 1997 11:17:28   RUSSL
* Modified chip check in DIR_DrvStrBlt to a one bit test rather a two dword
* compare (for Win95 only)
*
*    Rev 1.10   19 May 1997 14:02:02   bennyn
* Removed all #ifdef NT for WaitForRoom macro
*
*    Rev 1.9   03 Apr 1997 15:04:48   RUSSL
* Added DIR_DrvDstMBlt function
*
*    Rev 1.8   26 Mar 1997 13:54:24   RUSSL
* Added DIR_DrvSrcMBlt function
* Changed ACCUM_X workaround to just write 0 to LNCNTL
*
*    Rev 1.7   21 Mar 1997 18:05:04   RUSSL
* Added workaround writing ACCUM_X in DIR_DrvStrBlt
*
*    Rev 1.6   12 Mar 1997 15:00:38   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.5   07 Mar 1997 12:49:16   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.4   27 Jan 1997 17:28:34   BENNYN
* Added Win95 support
*
*    Rev 1.3   23 Jan 1997 16:55:56   bennyn
* Added 5465 DD support
*
*    Rev 1.2   25 Nov 1996 16:52:20   RUSSL
* NT change broke Win95 build
*
*    Rev 1.1   25 Nov 1996 16:13:54   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:11:12   RUSSL
* Initial revision.
*
*    Rev 1.3   18 Nov 1996 16:20:12   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.2   10 Nov 1996 12:36:24   CRAIGN
* Frido's 1111 release.
* Minor parenthesis change - bug fix.
*
*    Rev 1.1   01 Nov 1996 13:08:32   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:27:42   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:18   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else

#include "bltP.h"

#endif // !WINNT_VER40

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifndef WINNT_VER40
#define REQUIRE( size ) while ( (volatile)pREG->grQFREE < size )
#endif

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40

ASSERTFILE("blt_dir.c");
#define LL_DRAWBLTDEF(drawbltdef, r)	LL32(grDRAWBLTDEF.DW, drawbltdef)
#define LL_BGCOLOR(color, r)			LL32(grOP_opBGCOLOR.DW, color)
#define LL_FGCOLOR(color, r)			LL32(grOP_opFGCOLOR.DW, color)
#endif

/***************************************************************************
*
* FUNCTION:    DIR_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  REQUIRE(7);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL32(grOP0_opRDRAM.DW, lpDDHALData->PTAGFooPixel);
  LL32(grBLTEXT_EX.DW,   MAKELONG(1,1));
} /* DIR_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DIR_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DIR_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


#ifdef WINNT_VER40
  DISPDBG((DBGLVL, "DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));
#endif
  DD_LOG(("DIR_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opRDRAM.DW,  MAKELONG(xFill,yFill));
  LL32(grBLTEXT_EX.DW,    MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40
  DBG_MESSAGE((" Direct Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DIR_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DIR_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
  PVGAR   pREG  = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  REQUIRE(9);
  if (ninebit_on)
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (DD_PTAG | ROP_OP1_copy), 0);
  }
  else
  {
    LL_DRAWBLTDEF(((BD_RES * IS_VRAM + BD_OP1 * IS_SOLID) << 16) |
                           (ROP_OP1_copy), 0);
  }
  LL_BGCOLOR(FillValue, 0);
  LL32(grOP0_opMRDRAM.DW, MAKELONG(xFill,yFill));
  LL32(grMBLTEXT_EX.DW,   MAKELONG(cxFill,cyFill));

#ifndef WINNT_VER40     // Not WINNT_VER40
  DBG_MESSAGE((" (M) Edge Fill %d,%d %d x %d %08X %s", xFill, yFill, cxFill, cyFill, FillValue, (ninebit_on ? "TRUE" : "FALSE")));
#endif // WINNT_VER40

} /* DIR_MEdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DIR_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  REQUIRE(9);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT_EX.DW,    dwExtents);
} /* DIR_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                     ppdev,
#endif
                     lpDDHALData,
                     dwDrawBlt,
                     dwDstCoord+dwDelta,
                     dwSrcCoord+dwDelta,
                     dwKeyCoord+dwDelta,
                     dwKeyColor,
                     dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // Blt the rest.
  REQUIRE(13);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grOP1_opMRDRAM.DW, dwSrcCoord);
  LL32(grOP2_opMRDRAM.DW, dwKeyCoord);
  LL32(grMBLTEXT_EX.DW,   dwExtents);
} /* DIR_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents (see DrvStretch)

    // blt the src to the lower right of the dest
    DIR_DrvSrcBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                  pblt->OP1_opRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DIR_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DIR_DrvSrcMBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                   pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                   pblt->OP1_opMRDRAM.DW,
						       0UL,         // don't care
						       0UL,
                   pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

#ifdef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  NT version
*
****************************************************************************/

void DIR_DrvStrBlt
(
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  if (ppdev->dwLgDevID >= CL_GD5465)
  {
    // check for overlap
    DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                                ppdev,lpDDHALData,
#endif
                                pblt);
	REQUIRE(19);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
// hw clipping currently not used
//    LL32(grCLIPULE.DW,      pblt->CLIPULE.DW);
//    LL32(grCLIPLOR.DW,      pblt->CLIPLOR.DW);
    LL16(grSRCX,            pblt->SRCX);
    LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
    LL16(grMIN_X,           pblt->MIN_X);
    LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
    LL16(grACCUM_X,         pblt->ACCUM_X);
#else
    // workaround for hw bug when writing to ACCUM_X
    // writing LNCNTL changes STRETCH_CNTL so write
    // STRETCH_CNTL after this
    *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
    LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
    LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
    LL16(grMAJ_Y,           pblt->MAJ_Y);
    LL16(grMIN_Y,           pblt->MIN_Y);
    LL16(grACCUM_Y,         pblt->ACCUM_Y);
    LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
    LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

    LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
  }
  else
  {
#if 0
#pragma message("This needs to be checked out on 62/64")
    // check for overlap
    DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,lpDDHALData,
#endif
                               pblt);
#endif

	REQUIRE(18);
    LL16(grLNCNTL.W,       pblt->LNCNTL.W);
    LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
    LL16(grSRCX,           pblt->SRCX);
    LL16(grMAJ_X,          pblt->MAJ_X);
    LL16(grMIN_X,          pblt->MIN_X);
    LL16(grACCUM_X,        pblt->ACCUM_X);
    LL16(grMAJ_Y,          pblt->MAJ_Y);
    LL16(grMIN_Y,          pblt->MIN_Y);
    LL16(grACCUM_Y,        pblt->ACCUM_Y);
    LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
    LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
    LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
    LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
  }   // endif (ppdev->dwLgDevID >= CL_GD5465)
} /* DIR_DrvStrBlt */
#endif

#ifndef WINNT_VER40
/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt
*
* DESCRIPTION:  Win95 62/64 version
*
****************************************************************************/

void DIR_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#if 0
#pragma message("This needs to be checked out on 62/64")
  // check for overlap
  DIR_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             pblt);
#endif

  REQUIRE(18);
  LL16(grLNCNTL.W,       pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,    pblt->SHRINKINC.W);
  LL16(grSRCX,           pblt->SRCX);
  LL16(grMAJ_X,          pblt->MAJ_X);
  LL16(grMIN_X,          pblt->MIN_X);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL16(grMAJ_Y,          pblt->MAJ_Y);
  LL16(grMIN_Y,          pblt->MIN_Y);
  LL16(grACCUM_Y,        pblt->ACCUM_Y);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBlt65
*
* DESCRIPTION:  Win95 65+ version
*
****************************************************************************/

void DIR_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXT.DW,pblt->OP1_opMRDRAM.DW));

  // check for overlap
  DIR_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,
#endif
                              lpDDHALData,
                              pblt);

  REQUIRE(19);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grMAJ_X,           pblt->MAJ_X);
#if 0
  LL16(grACCUM_X,         pblt->ACCUM_X);
#else
  // workaround for hw bug when writing to ACCUM_X
  // writing LNCNTL changes STRETCH_CNTL so write
  // STRETCH_CNTL after this
  *(DWORD *)((BYTE *)(pREG)+0x50C) = MAKELONG(pblt->ACCUM_X,0);
  LG_LOG(0x50C,MAKELONG(pblt->ACCUM_X,0));
#endif
  LL16(grSTRETCH_CNTL.W,  pblt->STRETCH_CNTL.W);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opMRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opMRDRAM.DW);

	LL32(grMBLTEXTR_EX.DW, pblt->MBLTEXTR_EX.DW);
} /* DIR_DrvStrBlt65 */
#endif

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent blt */

  if ((pblt->BLTEXT.pt.X == 0) || (pblt->BLTEXT.pt.Y == 0))
    return;

  DBG_MESSAGE(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(18);
  LL16(grLNCNTL.W,        pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,     pblt->SHRINKINC.W);
  LL16(grSRCX,            pblt->SRCX);
  LL16(grMAJ_X,           pblt->MAJ_X);
  LL16(grMIN_X,           pblt->MIN_X);
  LL16(grACCUM_X,         pblt->ACCUM_X);
  LL16(grMAJ_Y,           pblt->MAJ_Y);
  LL16(grMIN_Y,           pblt->MIN_Y);
  LL16(grACCUM_Y,         pblt->ACCUM_Y);
  LL32(grOP0_opMRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opMRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);

#ifndef WINNT_VER40
  // MBLTEXTR_EX.pt.Y is broken in the 5464.
  // We can use BLTEXTR_EX.pt.Y instead.
  //pREG->grMBLTEXTR_EX  = pblt->BLTEXT;

  LL16(grMBLTEXTR_EX.pt.X, pblt->BLTEXT.pt.X);
  LL16(grBLTEXTR_EX.pt.Y,  pblt->BLTEXT.pt.Y);
#else
  LL32(grMBLTEXTR_EX.DW, pblt->BLTEXT.DW);
#endif
} /* DIR_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrMBltX
*
****************************************************************************/

void DIR_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif  //!WINNT_VER40

  REQUIRE(12);
  LL16(grLNCNTL.W,          pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,       pblt->SHRINKINC.W);
  LL16(grMAJ_X,             pblt->MAJ_X);
  LL16(grMIN_X,             pblt->MIN_X);
  LL16(grMAJ_Y,             pblt->MAJ_Y);
  LL16(grMIN_Y,             pblt->MIN_Y);
  LL16(grACCUM_Y,           pblt->ACCUM_Y);
  LL16(grOP0_opMRDRAM.pt.Y, pblt->OP0_opRDRAM.pt.Y);
  LL16(grOP1_opMRDRAM.pt.Y, pblt->OP1_opRDRAM.pt.Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
  LL16(grMBLTEXTR_XEX.pt.Y, pblt->BLTEXT.pt.Y);
} /* DIR_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(6);
  LL16(grSRCX,              pblt->SRCX);
  LL16(grACCUM_X,           pblt->ACCUM_X);
  LL16(grOP0_opMRDRAM.pt.X, pblt->OP0_opRDRAM.pt.X);
  LL16(grOP1_opMRDRAM.pt.X, pblt->OP1_opRDRAM.pt.X);
  LL16(grMBLTEXTR_XEX.pt.X, pblt->BLTEXT.pt.X);
} /* DIR_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DIR_DrvStrBltX
*
****************************************************************************/

void DIR_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltY\r\n"));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.Y == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(10);
  LL16(grLNCNTL.W,      pblt->LNCNTL.W);
  LL16(grSHRINKINC.W,   pblt->SHRINKINC.W);
  LL16(grSRCX,          pblt->SRCX);
  LL16(grMAJ_X,         pblt->MAJ_X);
  LL16(grMIN_X,         pblt->MIN_X);
  LL16(grMAJ_Y,         pblt->MAJ_Y);
  LL16(grMIN_Y,         pblt->MIN_Y);
  LL16(grACCUM_Y,       pblt->ACCUM_Y);
  LL_DRAWBLTDEF(pblt->DRAWBLTDEF.DW, 0);
} /* DIR_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DIR_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DIR_DrvStrMBltY
*
****************************************************************************/

void DIR_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

#ifndef WINNT_VER40

  /* Check for a zero extent */

  if (pblt->BLTEXT.pt.X == 0)
    return;

  DBG_MESSAGE(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
  APRINTF(("DIR_DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
           pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
           pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
           pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
           pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));
#endif //!WINNT_VER40

  REQUIRE(8);
  LL16(grACCUM_X,        pblt->ACCUM_X);
  LL32(grOP0_opRDRAM.DW, pblt->OP0_opRDRAM.DW);
  LL32(grOP1_opRDRAM.DW, pblt->OP1_opRDRAM.DW);
  LL32(grBLTEXTR_EX.DW,  pblt->BLTEXT.DW);
} /* DIR_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,  
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLDATA   lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // setup blt, write MBLTEXT reg with extent which doesn't fire off blt
  REQUIRE(8);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);
  LL32(grOP0_opMRDRAM.DW, dwDstCoord);
  LL32(grMBLTEXT.DW,      dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    REQUIRE(5);
    LL32(grMCLIPULE.DW, UpperLeft.DW);
    LL32(grMCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clear dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  REQUIER(12);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);
  LL32(grOP0_opRDRAM.DW,  dwDstCoord);
  LL32(grOP1_opRDRAM.DW,  dwSrcCoord);
  LL32(grOP2_opRDRAM.DW,  dwKeyCoord);
  LL32(grBLTEXT.DW,       dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    REQUIRE(5);
    LL32(grCLIPULE.DW, UpperLeft.DW);
    LL32(grCLIPLOR_EX.DW, LowerRight.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBLADATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  const int nBytesPixel = BYTESPERPIXEL;
  PVGAR     pREG = (PVGAR) lpDDHALData->RegsAddress;


  DD_LOG(("DIR_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwBgColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    REQUIRE(5);
    LL32(grOP0_opMRDRAM.DW, DstDDRect.loc.DW);
    LL32(grMBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DIR_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DIR_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
  PVGAR   pREG = (PVGAR) lpDDHALData->RegsAddress;
  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DIR_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DIR_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                             ppdev,
#endif
                             lpDDHALData,
                             dwDrawBlt,
                             dwDstCoord+dwDelta,
                             dwSrcCoord+dwDelta,
                             dwKeyCoord+dwDelta,
                             dwKeyColor,
                             dwExtents-dwDelta,
                             dwDstBaseXY,
                             dwSrcBaseXY,
                             dwRectCnt,
                             pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  // write regs that don't vary over rectangles
  REQUIRE(4);
  LL_DRAWBLTDEF(dwDrawBlt, 0);
  LL_BGCOLOR(dwKeyColor, 0);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, DstDDRect.loc.DW);
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      REQUIRE(9);
      LL32(grOP2_opRDRAM.DW, SrcDDRect.loc.DW);
    }
    else
    {
      REQUIRE(7);
      //LL32(grOP2_opRDRAM.DW, 0);
    }
    LL32(grOP0_opRDRAM.DW, DstDDRect.loc.DW);
    LL32(grOP1_opRDRAM.DW, SrcDDRect.loc.DW);
    LL32(grBLTEXT_EX.DW,   DstDDRect.ext.DW);

    pDestRects++;
  } while (0 < --dwRectCnt);
} /* DIR_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\brush.c ===
/******************************Module*Header*******************************\
*
* Module Name: Brush.c
* Author: Noel VanHook
* Purpose: Handle calls to DrvRealizeBrush
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/BRUSH.C  $
*
*    Rev 1.29   Mar 04 1998 15:11:18   frido
* Added new shadow macros.
*
*    Rev 1.28   Feb 24 1998 13:19:16   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.27   Nov 03 1997 12:51:52   frido
* Added REQUIRE macros.
*
*    Rev 1.26   25 Aug 1997 16:01:22   FRIDO
* Removed resetting of brush unique ID counters in vInvalidateBrushCache.
*
*    Rev 1.25   08 Aug 1997 15:33:16   FRIDO
* Changed brush cache width to bytes for new memory manager.
*
*    Rev 1.24   06 Aug 1997 17:29:56   noelv
* Don't RIP on brush cache alloc failure.  This failure is normal for modes
* without enough offscreen memory for a cache.
*
*    Rev 1.23   09 Apr 1997 10:48:52   SueS
* Changed sw_test_flag to pointer_switch.
*
*    Rev 1.22   08 Apr 1997 12:12:32   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.21   19 Feb 1997 13:06:20   noelv
* Added vInvalidateBrushCache()
*
*    Rev 1.20   17 Dec 1996 16:51:00   SueS
* Added test for writing to log file based on cursor at (0,0).
*
*    Rev 1.19   26 Nov 1996 10:18:22   SueS
* Changed WriteLogFile parameters for buffering.  Added test for null
* pointer in logging function.
*
*    Rev 1.18   13 Nov 1996 15:57:54   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.17   22 Aug 1996 18:14:18   noelv
* Frido bug fix release 8-22.
*
*    Rev 1.6   22 Aug 1996 19:12:44   frido
* #1308 - Added extra checks for empty cache slots.
*
*    Rev 1.5   18 Aug 1996 15:19:58   frido
* #nbr - Added brush translation.
*
*    Rev 1.4   17 Aug 1996 14:03:10   frido
* Removed extraneous #include directives.
*
*    Rev 1.3   17 Aug 1996 13:12:12   frido
* New release from Bellevue.
* #1244 - Fixed brush rotation for off-screen bitmaps.
*
*    Rev 1.2   15 Aug 1996 12:26:40   frido
* Moved BRUSH_DBG_LEVEL down.
*
*    Rev 1.1   15 Aug 1996 11:45:14   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.14   25 Jul 1996 15:55:24   bennyn
*
* Modified to support DirectDraw
*
*    Rev 1.13   04 Jun 1996 15:57:34   noelv
*
* Added debug code
*
*    Rev 1.12   28 May 1996 15:11:14   noelv
* Updated data logging.
*
*    Rev 1.11   16 May 1996 14:54:20   noelv
* Added logging code.
*
*    Rev 1.10   11 Apr 1996 09:25:16   noelv
* Fided debug messages.
*
*    Rev 1.9   10 Apr 1996 14:14:04   NOELV
*
* Frido release 27
*
*    Rev 1.19   08 Apr 1996 16:45:56   frido
* Added SolidBrush cache.
* Added new check for 32-bpp brushes.
*
*    Rev 1.18   01 Apr 1996 14:00:08   frido
* Added check for valid brush cache.
* Changed layout of brush cache.
*
*    Rev 1.17   30 Mar 1996 22:16:02   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.16   27 Mar 1996 13:07:38   frido
* Added check for undocumented translation flags.
*
*    Rev 1.15   25 Mar 1996 12:03:06   frido
* Changed #ifdef LOG_CALLS into #if LOG_CALLS.
*
*    Rev 1.14   25 Mar 1996 11:50:16   frido
* Bellevue 102B03.
*
*    Rev 1.5   20 Mar 1996 16:20:06   noelv
* 32 bpp color brushes are broken in the chip
*
*    Rev 1.4   20 Mar 1996 16:09:32   noelv
*
* Updated data logging
*
*    Rev 1.3   05 Mar 1996 11:57:38   noelv
* Frido version 19
*
*    Rev 1.13   05 Mar 1996 00:56:30   frido
* Some changes here and there.
*
*    Rev 1.12   04 Mar 1996 23:48:50   frido
* Removed bug in realization of dithered brush.
*
*    Rev 1.11   04 Mar 1996 20:22:30   frido
* Removed bug in BLTDEF register with colored brushes.
*
*    Rev 1.10   28 Feb 1996 22:37:42   frido
* Added Optimize.h.
*
*    Rev 1.9   17 Feb 1996 21:45:28   frido
* Revamped brushing algorithmn.
*
*    Rev 1.8   13 Feb 1996 16:51:18   frido
* Changed the layout of the PDEV structure.
* Changed the layout of all brush caches.
* Changed the number of brush caches.
*
*    Rev 1.7   10 Feb 1996 21:44:32   frido
* Split monochrome and colored translation cache.
*
*    Rev 1.6   08 Feb 1996 00:19:24   frido
* Optimized the entire brushing for non-intel CPU's.
* Removed DrvRealizeBrush for i386 since it is now in assembly.
*
*    Rev 1.5   05 Feb 1996 17:35:32   frido
* Added translation cache.
*
*    Rev 1.4   05 Feb 1996 11:34:02   frido
* Added support for 4-bpp brushes.
*
*    Rev 1.3   03 Feb 1996 14:20:04   frido
* Use the compile switch "-Dfrido=0" to disable my extensions.
*
*    Rev 1.2   20 Jan 1996 22:13:14   frido
* Added dither cache.
* Optimized loading of brush cache bits.
*
\**************************************************************************/

/*

We have two versions of DrvRealizeBrush, a 'C' version and an 'ASM' version.
These must be both be kept up to date.  The ASM version is used for production
drivers. The C version is used for debugging, prototyping, data gathering and
anything else that requires rapid, non-performance-critical changes to the
driver.

Brushes:
=========
Here is a general feel for how brush information flows between NT and the
driver components.

    NT calls DrvBitBlt() with a drawing request.
    DrvBitBlt() determines it needs a brush and calls SetBrush().
    SetBrush() determins the brush has not been realized yet and calls NT
        (BRUSHOBJ_pvGetRbrush()).
    NT calls DrvRealizeBrush().
    DrvRealizeBrush() creates a BrushObject and returns it to NT.
    NT returns brush object to SetBrush().
    SetBrush calls CacheBrush() if the brush is not cached.
    SetBrush() sets up pattern on chip.
    SetBrush() returns DRAWDEF value to BitBlt.


There are 5 seperate brush caches maintained:  A mono cache, a color cache, a
dither cache, a 4bpp cache, and a solid cache.  We do not handle brushes with
masks.  Some of the code for this is in place, but work was stopped on it.

Realizing Brushes:
==================

When we realize a brush we keep a bit of information about it.

  ajPattern[0]   = The bitmap that makes up the pattern.
  nPatSize       = The size of the bitmap.
  iBitmapFormat  = BMF_1BPP, BMF_4BPP, etc.
  ulForeColor    = For mono brushes.
  ulBackColor    = For mono brushes.
  iType          = Type of brush.
  iUniq          = Unique value for brush.
  cache_slot     = Where we cached it last time we used it. It may still be
                   there, or it may have been ejected from the cache since we
                   used it last.
  cache_xy       = The off-screen location of the brush bits.
  cjMask         = Offset to mask bits in ajPattern[].


The memory for the brush data structure is managed by the operating system.
When we realize a brush, we tell NT how much memory we need to hold our brush
data, and NT gives us a pointer.  When NT discards the brush, it frees the
memory it gave us *without* notifing us first!  This means we can't keep lists
of pointers to realized brushes and access them at our leisure, because they
may not exist anymore.  This is a pain when caching brushes.  It would be nice
if we could track cached/not-cached states in the brush itself, but we have no
way of notifing a brush that it has been uncached, because NT way have already
unrealized the brush.

The solution to this is to keep brush ID information in the cache.  The realized
brush tracks where it is in the cache.  The cache tracks which realized brush is
in each slot.



Caching brushes:
================

        We allocate 3 128-byte wide rectangles, side by side. The
        layout of this brush cache region is:

        +----------------+----------------+----------------+
        |                |                |   MONOCHROME   |
        |     COLOR      |      4BPP      +----------------+
        |    BRUSHES     |    BRUSHES     |     DITHER     |
        |                |                |    BRUSHES     |
        |                |                +----------------+
        |                |                | SOLID BRUSHES  |
        +----------------+----------------+----------------+

Mono brushes use 1 bit per pixel (1 byte per scan line, 8 bytes per brush) and
are stored 16 to a line.  Replacement policy is round robin.  We work out way
through the cache table entries, and when the cache is full, we go back to 0 and
start again.

The pdev holds a counter that increments every time we cache a brush. We MOD
this counter with the number of table entries to find the next place to put a
brush.  When we store the brush, we store a unswizzled copy in the cache table
itself, and a swizzled copy in the cache.  After storing the brush, we give it a
'serial number' which is stored in both the cache, and the realized brush.  We
then copy the brushes X,Y address into the realized brush for easy access.  So,
for index I in the cache, things look like this:

Realized Brush
--------------
cache_slot  = I  - tells us which cache table entry to use;
cache_xy         - x,y address of brush in offscreen memory.  Copied from cache
                   table.
iUniq            - matches iUniq in CacheTable[I]

Cache Table [I]
---------------
xy        - x,y address of brush in offscreen memory.  Computed at init time.
ajPattern - brush bits.
iUniq     - matches iUniq in RealizedBrush


Now, in the future, if we are given this brush again, we first check cache_slot
in the realized brush to see where we cached it last time we used it.  Then we
compare iUniq values to see if our brush is *still* cached there.



Dither brushes use 1 byte per pixel (8 bytes per scan line, 64 bytes per brush)
        and are stored 2 to a line.

4bpp brushes use 1 DWORD per pixel (32 bytes per scan line, 256 bytes per brush)
        and use two lines per brush.

Solid brushes use 1 DWORD per pixel (32 bytes  scan line, 256 bytes per brush)
        and use two lines per brush.

Color brushes:
        8 bpp     - 1 byte per pixel, two brushes per scan line.
        16 bpp    - 2 bytes per pixel, 1 brush per scan line.
        24,32 bpp - 4 bytes per pixel, two scan lines per brush.

Brushes are put in the cache using direct frame buffer access.  To make using
cached brushes fast, we maintain a seperate cache table for each cache.  Each
entry in the cache table tracks the (x,y) address of the brush in a format
directly usable by the chip, and the linear address of the brush for storing the
brush quickly.



Initialization:
-----------------
Brush cache initialization is done during surface initialization.
        DrvEnableSurface() => binitSurf() => vInitBrushCache().




*/

#include "precomp.h"
#include "SWAT.h"
#define BRUSH_DBG_LEVEL 1

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush);

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

//
// These are test/debugging/information-gathering functions that
// get compiled out under a free build.
//

#if LOG_CALLS
void LogRealizeBrush(
        ULONG     acc,
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo
    );
#else
    #define LogRealizeBrush(acc, ppdev, psoPattern, psoMask, pxlo)
#endif

//
// These aren't part of the driver.  They are debugging support functions
// that can be inserted where needed.
//

// This dumps useful information about brushes that NT gives us.
void PrintBrush(SURFOBJ  *psoPattern);

// This dumps useful information about brushes we have realized.
void PrintRealizedBrush(PRBRUSH pRbrush);

//
// Mono brushes must be swizzled before they are stored away.
// We do this with this look up table.
//
BYTE Swiz[] = {
0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};






/**************************************************************************\
*                                                                          *
* DrvRealizeBrush                                                          *
*                                                                          *
\**************************************************************************/

//#nbr (begin)
#if USE_ASM && defined(i386)
BOOL i386RealizeBrush(
#else
BOOL DrvRealizeBrush(
#endif
//#nbr (end)
        BRUSHOBJ *pbo,
        SURFOBJ  *psoTarget,
        SURFOBJ  *psoPattern,
        SURFOBJ  *psoMask,
        XLATEOBJ *pxlo,
        ULONG    iHatch)
{
        PPDEV   ppdev;
        INT     cjPattern, // size of the brush pattern (in bytes).
            cjMask;    // size of the brush mask (in bytes).
        PRBRUSH pRbrush;   // Our brush structure.
        PULONG  pulXlate;  // Color translation table.
        FLONG   flXlate;   // Translation flags.
#if 1 //#nbr
        LONG    lDelta;
#endif

        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Entry.\n"));

        //
        // Reality check.
        //
        ASSERTMSG(psoTarget != 0,  "DrvRealizeBrush: No target.\n");

        //
        // Is the screen the target?
        //
        ppdev = (PPDEV) (psoTarget ? psoTarget->dhpdev : 0);

        if (!ppdev)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (no pdev).\n"));
                LogRealizeBrush(1, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

    SYNC_W_3D(ppdev);

    //
    // If we don't have a brush cache (maybe we're low on offscreen memory?)
    // then we can't do brushes.
    //
        if (ppdev->Bcache == NULL)
        {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (iHatch & RB_DITHERCOLOR)
        {
                ULONG rgb = iHatch & 0x00FFFFFF;
                int       i;

                // Allocate the memory.
                pRbrush = (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
                if (pRbrush == NULL)
                {
                        LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Init the brush structure.
                pRbrush->nPatSize = 0;
                pRbrush->iBitmapFormat = BMF_8BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_DITHER;
                pRbrush->iUniq = rgb;

                // Lookup the dither in the dither cache.
                for (i = 0; i < NUM_DITHER_BRUSHES; i++)
                {
                        if (ppdev->Dtable[i].ulColor == rgb)
                        {
                                pRbrush->cache_slot = i * sizeof(ppdev->Dtable[i]);
                                pRbrush->cache_xy = ppdev->Dtable[i].xy;
                                LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Create the dither and cache it.
                LogRealizeBrush(99, ppdev, psoPattern, psoMask, pxlo);
                return(CacheDither(ppdev, pRbrush));
        }

        ASSERTMSG(psoPattern != 0, "DrvRealizeBrush: No pattern.\n");

        // Is it an 8x8 brush?
        if ((psoPattern->sizlBitmap.cx != 8) || (psoPattern->sizlBitmap.cy != 8))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (not 8x8).\n"));
                LogRealizeBrush(3, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Does it have a mask?
        // Some of the mask code is in place, but not all of it.
        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (has a mask).\n"));
                LogRealizeBrush(4, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        // Is it a standard format brush?
        if (psoPattern->iType != STYPE_BITMAP)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (not standard bitmap).\n"));
                LogRealizeBrush(2, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Get the color translation.
        //
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
                pulXlate = XLATEOBJ_piVector(pxlo);
        }
    else
    {
        // Some kind of translation we don't handle.
        return FALSE;
    }


        // The hardware does not support colored bitmaps in 32-bpp.
        if ( (psoPattern->iBitmapFormat > BMF_1BPP) &&
                 (ppdev->iBitmapFormat == BMF_32BPP) )
        {
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        if (psoPattern->iBitmapFormat == BMF_4BPP)
        {
                int i;

                // Check if we support this bitmap.
                if ( (psoPattern->cjBits != XLATE_PATSIZE) ||
                         (pxlo->cEntries != XLATE_COLORS) )
                {
                        // We don't support other bitmaps than 8x8 and 16 translation
                        // entries.
                        LogRealizeBrush(10, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + XLATE_PATSIZE +
                                                                                 XLATE_COLORS * sizeof(ULONG));
                if (pRbrush == NULL)
                {
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize       = XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG);
                pRbrush->iBitmapFormat  = BMF_4BPP;
                pRbrush->cjMask         = 0;
                pRbrush->iType          = BRUSH_4BPP;

                // Copy the 4-bpp pattern and translation palette to the brush.
                if (psoPattern->lDelta == 4)
                {
                        memcpy(pRbrush->ajPattern, psoPattern->pvBits, XLATE_PATSIZE);
                }
                else
                {
                        BYTE *pSrc = psoPattern->pvScan0;
                        for (i = 0; i < 8; i++)
                        {
                                ((DWORD *) pRbrush->ajPattern)[i] = *(DWORD *) pSrc;
                                pSrc += psoPattern->lDelta;
                        }
                }
                memcpy(pRbrush->ajPattern + XLATE_PATSIZE, pulXlate,
                           XLATE_COLORS * sizeof(ULONG));

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_4BPP_BRUSHES; i++)
                {
                        if ((memcmp(ppdev->Xtable[i].ajPattern, pRbrush->ajPattern,
                                            XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG)) == 0)
#if 1 //#1308
                                && (ppdev->Xtable[i].iUniq != 0)
#endif
                        )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Xtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Xtable[i]);
                                pRbrush->cache_xy = ppdev->Xtable[i].xy;
                        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(Cache4BPP(ppdev, pRbrush));
        }

        if (psoPattern->iBitmapFormat == BMF_1BPP)
        {
                int       i;
                PBYTE pSrc;

                // Check if we support this bitmap.
                if (pulXlate == 0)
                {
                    LogRealizeBrush(11, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                // Allocate the brush.
                pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + 8);
                if (pRbrush == NULL)
                {
                    LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                        return(FALSE);
                }

                //
                // Init the brush structure.
                //
                pRbrush->nPatSize = 8;
                pRbrush->iBitmapFormat = BMF_1BPP;
                pRbrush->cjMask = 0;
                pRbrush->iType = BRUSH_MONO;

                // Copy the 4-bpp pattern and translation palette to the brush.
                pRbrush->ulBackColor = ExpandColor(pulXlate[0], ppdev->ulBitCount);
                pRbrush->ulForeColor = ExpandColor(pulXlate[1], ppdev->ulBitCount);
                pSrc = (PBYTE) psoPattern->pvScan0;
                for (i = 0; i < 8; i++)
                {
                        pRbrush->ajPattern[i] = *pSrc;
                        pSrc += psoPattern->lDelta;
                }

                // Lookup the pattern and palette in the translation cache.
                for (i = 0; i < NUM_MONO_BRUSHES; i++)
                {
                        if ((*(DWORD *) &ppdev->Mtable[i].ajPattern[0] ==
                                 *(DWORD *) &pRbrush->ajPattern[0]) &&
#if 1 //#1308
                                (ppdev->Mtable[i].iUniq != 0) &&
#endif
                                (*(DWORD *) &ppdev->Mtable[i].ajPattern[4] ==
                                 *(DWORD *) &pRbrush->ajPattern[4]) )
                        {
                                // We have a match!
                                pRbrush->iUniq = ppdev->Mtable[i].iUniq;
                                pRbrush->cache_slot = i * sizeof(ppdev->Mtable[i]);
                                pRbrush->cache_xy = ppdev->Mtable[i].xy;
                            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                                return(TRUE);
                        }
                }

                // Cache the brush now.
            LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
                return(CacheMono(ppdev, pRbrush));
        }

#if 1 //#nbr
        // How much memory do we need for the pattern?
        lDelta = (ppdev->iBytesPerPixel * 8);
        if (ppdev->iBytesPerPixel == 3)
        {
                lDelta += 8;
        }
        cjPattern = lDelta * 8;

        // Allocate the memory.
        pRbrush = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH) + cjPattern);
        if (pRbrush == NULL)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                 "DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Initialize the brush fields.
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = ppdev->iBitmapFormat;
        pRbrush->cjMask            = 0;
        pRbrush->iType             = BRUSH_COLOR;

        // Can we realize the bits directly?
        if ((psoPattern->iBitmapFormat == ppdev->iBitmapFormat) &&
                (flXlate & XO_TRIVIAL))
        {
                // Realize the brush bits.
                vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                                  pRbrush);
        }
        else
        {
                HBITMAP  hBrush;
                SURFOBJ* psoBrush;
                RECTL    rclDst = {     0, 0, 8, 8 };
                BOOL     bRealized = FALSE;

                DISPDBG((BRUSH_DBG_LEVEL, "DrvRealizeBrush: Translating brush.\n"));

                // Create a bitmap wrapper for the brush bits.
                hBrush = EngCreateBitmap(psoPattern->sizlBitmap, lDelta,
                                                                 ppdev->iBitmapFormat, BMF_TOPDOWN,
                                                                 pRbrush->ajPattern);
                if (hBrush != 0)
                {
                        // Associate the bitmap wrapper with the device.
                        if (EngAssociateSurface((HSURF) hBrush, ppdev->hdevEng, 0))
                        {
                                // Lock the bitmap wrapper.
                                psoBrush = EngLockSurface((HSURF) hBrush);
                                if (psoBrush != NULL)
                                {
                                        // Copy the pattern bits to the bitmap wrapper.
                                        if (EngCopyBits(psoBrush, psoPattern, NULL, pxlo, &rclDst,
                                                                         (POINTL*) &rclDst))
                                        {
                                                // In 24-bpp, the brush bits have a different layout.
                                                if (ppdev->iBytesPerPixel == 3)
                                                {
                                                        INT    y;
                                                        ULONG* pulDst = (ULONG*) pRbrush->ajPattern;

                                                        // Walk through every line.
                                                        for (y = 0; y < 8; y++)
                                                        {
                                                                // Copy bytes 0-7 to bytes 25-31.
                                                                pulDst[6] = pulDst[0];
                                                                pulDst[7] = pulDst[1];
                                                                // Next line.
                                                                pulDst   += 8;
                                                        }
                                                }
                                                // Mark the brush as realized.
                                                bRealized = TRUE;
                                        }
                                        else
                                        {
                                                DISPDBG((BRUSH_DBG_LEVEL, "  EngCopyBits failed.\n"));
                                        }
                                        // Unlock the bitmap wrapper.
                                        EngUnlockSurface(psoBrush);
                                }
                                else
                                {
                                        DISPDBG((BRUSH_DBG_LEVEL, "  EngLockSurface failed.\n"));
                                }
                        }
                        else
                        {
                                DISPDBG((BRUSH_DBG_LEVEL, "  EngAssociateSurface failed.\n"));
                        }
                        // Delete the bitmap wrapper.
                        EngDeleteSurface((HSURF) hBrush);
                }
                else
                {
                        DISPDBG((BRUSH_DBG_LEVEL, "(EngCreateBitmap failed)\n"));
                }

                if (!bRealized)
                {
                        // The brush was not realized.
                        return(FALSE);
                }
        }
#else
        if (flXlate & 0x10)
        {
                // Punt to GDI.
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return(FALSE);
        }

        // Is it a supported color depth?
        if (psoPattern->iBitmapFormat != ppdev->iBitmapFormat)
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                                "DrvRealizeBrush: punted (unsupported color depth).\n"));
                LogRealizeBrush(5, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // We don't handle color xlates yet.
        // If there is an xlate table, punt it.
        //
        if ( pulXlate )
        {
                DISPDBG((BRUSH_DBG_LEVEL,
                         "DrvRealizeBrush: punted (Xlate required).\n"));
                LogRealizeBrush(9, ppdev, psoPattern, psoMask, pxlo);
                return FALSE;
        }

        //
        // Alloc memory from GDI for brush storage.
        //

        // How much memory to we need for the pattern?
        cjPattern = psoPattern->cjBits;
        if (psoPattern->iBitmapFormat == BMF_24BPP)
                cjPattern += 64;

        // We need memory for the mask too.
        // Check for mask bits equal to pattern bits.
        // If psoMask is NULL, the mask is never used, so no memory is needed.

        if ((psoMask != NULL) && (psoMask->pvScan0 != psoPattern->pvScan0))
                cjMask = psoMask->cjBits;
        else
                cjMask = 0;

        // Allocate the memory.
        pRbrush =
           (PRBRUSH) BRUSHOBJ_pvAllocRbrush(pbo,sizeof(RBRUSH)+cjPattern+cjMask);
        if (!pRbrush)
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: punted (Mem alloc failed).\n"));
                LogRealizeBrush(6, ppdev, psoPattern, psoMask, pxlo);
                return (FALSE);
        }

        //
        // Init the brush structure.
        //
        pRbrush->nPatSize          = cjPattern;
        pRbrush->iBitmapFormat = psoPattern->iBitmapFormat;
        pRbrush->cjMask            = (cjMask ? cjPattern : 0);
        pRbrush->iType             = BRUSH_COLOR;

        //
        // Realize the brush and mask.  Actually we punted masks a while ago.
        //
        vRealizeBrushBits(ppdev, psoPattern, &pRbrush->ajPattern[0], pulXlate,
                                          pRbrush);
#endif

        //
        // Cache the brush now.
        //
        CacheBrush(ppdev, pRbrush);

        //
        // Dump brush data to the profiling file.
        // Gets compiled out under a free build.
        //
        LogRealizeBrush(0, ppdev, psoPattern, psoMask, pxlo);
        DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Done.\n"));

        return (TRUE);

}



/***********************************************************************\
*                                                                       *
* vRealizeBrushBits()                                                   *
*                                                                       *
* Copies the brush pattern from GDI to our realized brush.              *
* Called by DrvRealizeBrush()                                           *
*                                                                       *
\***********************************************************************/

void vRealizeBrushBits(
        PPDEV     ppdev,
        SURFOBJ  *psoPattern,
        PBYTE     pbDest,
        PULONG    pulXlate,
        PRBRUSH   pRbrush
)
{
        PBYTE     pbSrc;
        INT i,j;
        LONG lDelta;


        //
        // Find the top scan line in the brush, and it's scan line delta
        // This works for both top down and bottom up brushes.
        //
        pbSrc = psoPattern->pvScan0;
        lDelta = (psoPattern->lDelta);


        //
        // At this point all brushs are 8x8.
        // Currently we only support mono brushes, and brushes with the same
        // color depth as the screen.  Color translations aren't supported.
        //
        // Mono brushes must be swizzled as we copy them.  We do this using
        // a 256 byte lookup table.
        //
        // We store the brushes in host memory as a linear string of bytes.
        // Before we use the brush we will cache it off screen memory in a
        // format that the BLT engine can use.
        //

        switch (psoPattern->iBitmapFormat)
        {
                case BMF_8BPP:
                        //
                        // Store the pattern as 64 consecutive bytes.
                        //

                        if (lDelta == 8)
                        {
                                memcpy(pbDest, pbSrc, 8 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_16BPP:
                        //
                        // Store the pattern as 128 consecutive bytes.
                        //
                        if (lDelta == 16)
                        {
                                memcpy(pbDest, pbSrc, 16 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[8];
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[12];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;

                case BMF_24BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //
                        //
                        // Each row in the pattern needs 24 bytes.  The pattern is stored
                        // with 32 bytes per row though, with the last 8 bytes being a
                        // copy of the first 8 bytes, like so:
                        //
                        // RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RG
                        // 1   2   3   4   5   6   7   8   1   2   3
                        // \___________________________/   \________/
                        //             |                       |
                        //     pattern scan line        copy of first 8
                        //                              bytes of scan line
                        //

                        // For each row in the pattern.
                        for (j = 0; j < 8; j++)
                        {
                                //
                                // Copy the row.
                                //
                                for (i = 0; i < 24; i += sizeof(ULONG))
                                        *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                //
                                // Pad the last 8 bytes with a copy of the first 8 bytes.
                                //
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[0];
                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[4];

                                // Move to next row.
                                pbSrc += lDelta;
                        }
                        return;

                case BMF_32BPP:
                        //
                        // Store the pattern as 256 consecutive bytes.
                        //

                        if (lDelta == 32)
                        {
                                memcpy(pbDest, pbSrc, 32 * 8);
                        }
                        else
                        {
                                // For each row in the pattern.
                                for (j = 0; j < 8; j++)
                                {
                                        // Copy the row.
                                        for (i = 0; i < 32; i += sizeof(ULONG))
                                                *((ULONG *) pbDest)++ = *(ULONG *) &pbSrc[i];

                                        // Move to next row.
                                        pbSrc += lDelta;
                                }
                        }
                        return;
        }
}

// ===========================================================================+
//                                                                           ||
// ExpandColor()                                                             ||
// Expands a color value to 32 bits by replication.                          ||
// Called by vRealizeBrushBits()                                             ||
//                                                                           ||
// ===========================================================================+

ULONG ExpandColor(ULONG iSolidColor, ULONG ulBitCount)
{
        ULONG color;

        //
        // If the color is an 8 or 16 bit color, it needs to be
        // extended (by replication) to fill a 32 bit register.
        //

        switch (ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        color = iSolidColor & 0x00000000FF; // Clear upper 24 bits.
                        return ((color << 24) | (color << 16) | (color << 8) | color);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        color = (iSolidColor) & 0x0000FFFF; // Clear upper 16 bits.
                        return ((color << 16) | color);

                case 24: // For 24 bpp clear the upper 8 bits.
                        return (iSolidColor & 0x00FFFFFF);

                default: // For 32 bpp just use the color supplied by NT.
                        return (iSolidColor); // Color of fill
        }

}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheMono()                                                                                                                       *
 *      Cache a realized monochrome brush.                                                                        *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush)
{
        int   i;
        ULONG tbl_idx = ppdev->MNext % NUM_MONO_BRUSHES;
        PBYTE pdest;

        // Copy the monochrome pattern to the cache and off-screen.
        pdest = ppdev->Mtable[tbl_idx].pjLinear;
        for (i = 0; i < 8; i++)
        {
                ppdev->Mtable[tbl_idx].ajPattern[i] = pRbrush->ajPattern[i];
                pdest[i] = Swiz[pRbrush->ajPattern[i]];
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Mtable[tbl_idx].iUniq = ++ppdev->MNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Mtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Mtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      Cache4BPP()                                                                                                                       *
 *      Cache a realized 4-bpp brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->XNext % NUM_4BPP_BRUSHES;
        int       i, j;
        PBYTE psrc, pdest;
        ULONG *pulPalette;

        // Copy the 4-bpp pattern to the cache.
#pragma prefast(suppress: 203, "Ugly but works - we're copying pattern and palette (PREfast bug 611168)")
        memcpy(ppdev->Xtable[tbl_idx].ajPattern, pRbrush->ajPattern,
                   XLATE_PATSIZE + XLATE_COLORS * sizeof(ULONG));

        psrc = ppdev->Xtable[tbl_idx].ajPattern;
        pulPalette = ppdev->Xtable[tbl_idx].ajPalette;
        pdest = ppdev->Xtable[tbl_idx].pjLinear;
        switch (ppdev->ulBitCount)
        {
                case 8:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *pdest++ = (BYTE) pulPalette[psrc[j] >> 4];
                                        *pdest++ = (BYTE) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 16:
                        for (i = 0; i < 8; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] >> 4];
                                        *((WORD *)pdest)++ = (WORD) pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;

                case 24:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j += 2)
                                {
                                        ULONG p1, p2, p3, p4;

                                        p1 = pulPalette[psrc[j] >> 4];
                                        p2 = pulPalette[psrc[j] & 0x0F];
                                        p3 = pulPalette[psrc[j + 1] >> 4];
                                        p4 = pulPalette[psrc[j + 1] & 0x0F];
                                        *((DWORD *)pdest)++ = p1 | (p2 << 24);
                                        *((DWORD *)pdest)++ = (p2 >> 8) | (p3 << 16);
                                        *((DWORD *)pdest)++ = (p3 >> 16) | (p4 << 8);
                                }
                                psrc += 4;
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                                *((DWORD *)pdest)++ = *(DWORD *) &pdest[-24];
                        }
                        break;

                case 32:
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        pdest += ppdev->lDeltaScreen - 4 * 8 * 4;
                        for (i = 0; i < 4; i++)
                        {
                                for (j = 0; j < 4; j++)
                                {
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] >> 4];
                                        *((DWORD *)pdest)++ = pulPalette[psrc[j] & 0x0F];
                                }
                                psrc += 4;
                        }
                        break;
        }

        // Store the new uniq ID in the cache slot.
        pRbrush->iUniq = ppdev->Xtable[tbl_idx].iUniq = ++ppdev->XNext;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Xtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Xtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheDither()                                                                                                             *
 *      Cache a realized dither brush.                                                                            *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush)
{
        ULONG tbl_idx = ppdev->DNext++ % NUM_DITHER_BRUSHES;

        // Create the dither directly in off-screen memory.
        vDitherColor(pRbrush->iUniq, (ULONG *) ppdev->Dtable[tbl_idx].pjLinear);

        // Store the color in the cache slot.
        ppdev->Dtable[tbl_idx].ulColor = pRbrush->iUniq;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Dtable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Dtable[tbl_idx].xy;
        return(TRUE);
}

/**************************************************************************\
 *                                                                                                                                                *
 *      CacheBrush()                                                                                                              *
 *      Cache a realized color brush.                                                                             *
 *                                                                                                                                                *
\**************************************************************************/
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush)
{
        PBYTE psrc, pdest;
        ULONG tbl_idx = ppdev->CNext;

        if (++ppdev->CNext == ppdev->CLast)
        {
                ppdev->CNext = 0;
        }

        // Copy the brush bits to off-screen.
        psrc = pRbrush->ajPattern;
        pdest = ppdev->Ctable[tbl_idx].pjLinear;
        if (pRbrush->iBitmapFormat < BMF_24BPP)
        {
                memcpy(pdest, pRbrush->ajPattern, pRbrush->nPatSize);
        }
        else
        {
                memcpy(pdest, psrc, 32 * 4);
                memcpy(pdest + ppdev->lDeltaScreen, psrc + 32 * 4, 32 * 4);
        }

        ppdev->Ctable[tbl_idx].brushID = pRbrush;
        pRbrush->cache_slot = tbl_idx * sizeof(ppdev->Ctable[tbl_idx]);
        pRbrush->cache_xy = ppdev->Ctable[tbl_idx].xy;
        return(TRUE);
}

//--------------------------------------------------------------------------//
//                                                                          //
//  SetBrush()                                                              //
//  Used by op2BLT(), HostToScreenBLT() and ScreenToScreenBLT() in BITBLT.C //
//  to setup the chip to use the current brush.                             //
//                                                                          //
//--------------------------------------------------------------------------//
BOOL SetBrush(
                PPDEV     ppdev,
                ULONG     *bltdef, // local copy of the BLTDEF register.
                BRUSHOBJ  *pbo,
                POINTL    *pptlBrush)
{

        ULONG color;
        PRBRUSH pRbrush = 0;
        USHORT patoff_x, patoff_y;

        if (ppdev->bDirectDrawInUse)
                return(FALSE);

        //
        // See if the brush is really a solid color.
        //
        if (pbo->iSolidColor != 0xFFFFFFFF)  // It's a solid brush.
        {
                // Expand the color to a full 32 bit DWORD.
                switch (ppdev->ulBitCount)
                {
                        case 8:
                                color = pbo->iSolidColor & 0x000000FF;
                                color |= color << 8;
                                color |= color << 16;
                                break;

                        case 16:
                                color = pbo->iSolidColor & 0x0000FFFF;
                                color |= color << 16;
                                break;

                        case 24:
                                color = pbo->iSolidColor & 0x00FFFFFF;
                                break;

                        case 32:
                                color = pbo->iSolidColor;
                                break;
                }

                #if SOLID_CACHE
                        ppdev->Stable[ppdev->SNext].ulColor = color;
                #endif

                // Load the fg and bg color registers.
                REQUIRE(2);
                LL_BGCOLOR(color, 2);

                // Set the operation
                *bltdef |= 0x0007;   // OP2=FILL.

                return TRUE;  // That's it!
        }

        //
        // It's not a solid color, it's a pattern.
        //
        // Get the pointer to our drivers realization of the brush.
        if (pbo->pvRbrush != NULL)
        {
                pRbrush = pbo->pvRbrush;
        }
        else // we haven't realized it yet, so do so now.
        {
                pRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pRbrush == NULL)
                {
                        return(FALSE);  // Fail if we do not handle the brush.
                }
        }

        //
        // Set pattern offset.
        // NT specifies patttern offset as which pixel on the screen to align
        // with pattern(0,0).  Laguna specifies pattern offset as which pixel
        // of the pattern to align with screen(0,0).  Only the lowest three
        // bits are significant, so we can ignore any overflow when converting.
        // Also, even though PATOFF is a reg_16, we can't do byte wide writes
        // to it.  We have to write both PATOFF.pt.X and PATOFF.pt.Y in a single
        // 16 bit write.
        //
#if 1 //#1244
        patoff_x = (USHORT)(-(pptlBrush->x + ppdev->ptlOffset.x) & 7);
        patoff_y = (USHORT)(-(pptlBrush->y + ppdev->ptlOffset.y) & 7);
#else
        patoff_x = ((pptlBrush->x - 1) ^ 0x07) & 0x07;
        patoff_y = ((pptlBrush->y - 1) ^ 0x07) & 0x07;
#endif
        REQUIRE(1);
        LL16(grPATOFF.w, (patoff_y << 8) | patoff_x);

        //
        // What kind of brush is it?
        //
        if (pRbrush->iType == BRUSH_MONO) // Monochrome brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using MONO Brush.\n"));
                #define mb ((MC_ENTRY*)(((BYTE*)ppdev->Mtable) + pRbrush->cache_slot))
                if (mb->iUniq != pRbrush->iUniq)
                {
                        CacheMono(ppdev, pRbrush);
                }

                // Load the fg and bg color registers.
                REQUIRE(6);
                LL_FGCOLOR(pRbrush->ulForeColor, 0);
                LL_BGCOLOR(pRbrush->ulBackColor, 0);

                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x000D;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_4BPP) // 4-bpp brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using 4bpp Brush.\n"));
                #define xb ((XC_ENTRY*)(((BYTE*)ppdev->Xtable) + pRbrush->cache_slot))
                if (xb->iUniq != pRbrush->iUniq)
                {
                        Cache4BPP(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else if (pRbrush->iType == BRUSH_DITHER) // Dither brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using dither Brush.\n"));
                #define db ((DC_ENTRY*)(((BYTE*)ppdev->Dtable) + pRbrush->cache_slot))
                if (db->ulColor != pRbrush->iUniq)
                {
                        CacheDither(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
        else // Color brush.
        {
                DISPDBG((BRUSH_DBG_LEVEL,"DrvRealizeBrush: Using color Brush.\n"));
                #define cb ((BC_ENTRY*)(((BYTE*)ppdev->Ctable) + pRbrush->cache_slot))
                if (cb->brushID != pRbrush)
                {
                        CacheBrush(ppdev, pRbrush);
                }
                REQUIRE(2);
                LL32(grOP2_opMRDRAM, pRbrush->cache_xy);
                *bltdef |= 0x0009;
                return(TRUE);
        }
}



// ==========================================================================+
//                                                                          ||
// vInitBrushCache()                                                        ||
// Called by bInitSURF in SCREEN.C                                          ||
// Allocate some off screen memory to cache brushes in.                     ||
// Initialize the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInitBrushCache(
                PPDEV ppdev
)
{
        SIZEL sizel;
        int i;
        ULONG x, y;

        //
        // NOTE: The size and location of the brush cache itself
        //       is in pixel coordinates.  The offsets of the
        //       individual brushes within the cache are BYTE offsets.
        //

        //
        // We need to allocate a 128 BYTE wide rectangle.
        // The offscreen memory manager wants the size of the requested
        // rectangle in PIXELS.  So firure out how many pixels are in 128 bytes.
        //
        /*
                We are going to allocate 3 128-byte wide rectangles, side by side. The
                layout of this brush cache region is:

                +----------------+----------------+----------------+
                |                |                |   MONOCHROME   |
                |     COLOR      |      4BPP      +----------------+
                |    BRUSHES     |    BRUSHES     |     DITHER     |
                |                |                |    BRUSHES     |
                +----------------+----------------+----------------+
        */
        sizel.cy = max(max(NUM_COLOR_BRUSHES / 2,
                                           NUM_4BPP_BRUSHES * 2),
                                           NUM_MONO_BRUSHES / 16 + NUM_DITHER_BRUSHES / 2 + 2);
#if MEMMGR
        sizel.cx = 128 * 3;
#else
        sizel.cx = (128 * 3) / ppdev->iBytesPerPixel;
#endif

        //
        // Allocate the offscreen memory
        //
        DISPDBG((BRUSH_DBG_LEVEL,"Allocating the brush cache.\n"));
        ppdev->Bcache =  AllocOffScnMem(ppdev, &sizel, 0, 0);

        // Did the allocate succeed?
        if (! ppdev->Bcache)
        {
                //
                // We failed to allocate a brush cache.
                // Return while the entire cache is still marked as as unusable,
                // This will cause anything needing a brush to punt.
                //
                return;
        }

        //
        // Init the cache table.
        // The X offests of all the brushes in the cache are BYTE
        // offsets.
        //

        // Init the monochrome cache table. The x offsets are bit offsets.
    // Brushes are stored 16 to a row.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 16) * 8; // byte offset
                y = ppdev->Bcache->y + (i / 16);
                ppdev->Mtable[i].xy = (y << 16) | (x << 3); // convert to bit offset
                ppdev->Mtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Mtable[i].iUniq = 0;
        }
        ppdev->MNext = 0;

        // Init the 4-bpp cache table. The x offsets are byte offsets.
        // Each brush takes 2 rows.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 1);
                y = ppdev->Bcache->y + (i * 2);
                ppdev->Xtable[i].xy = (y << 16) | x;
                ppdev->Xtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Xtable[i].iUniq = 0;
        }
        ppdev->XNext = 0;

        // Init the dither cache table. The x offsets are byte offsets.
        // Two brushes per row.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                x = ppdev->Bcache->x + (128 * 2) + (i % 2) * 64;
                y = ppdev->Bcache->y + (i / 2) + (NUM_MONO_BRUSHES / 16);
                ppdev->Dtable[i].xy = (y << 16) | x;
                ppdev->Dtable[i].pjLinear = ppdev->pjScreen
                                                                  + x + (y * ppdev->lDeltaScreen);
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
        ppdev->DNext = 0;

        #if SOLID_CACHE
                // Solid brush cache is for using a mono brush with a mono source.
                // The mono brush is converted to a solid color brush.
                // Each brush takes two rows.
                for (i = 0; i < NUM_SOLID_BRUSHES; i++)
                {
                        x = ppdev->Bcache->x + (128 * 2);
                        y = ppdev->Bcache->y + (i * 2) + (NUM_MONO_BRUSHES / 16)
                          + (NUM_DITHER_BRUSHES / 2);
                        ppdev->Stable[i].xy = (y << 16) | x;
                        ppdev->Stable[i].pjLinear = ppdev->pjScreen
                                                                          + x + (y * ppdev->lDeltaScreen);
                }
                ppdev->SNext = 0;
        #endif

        // Init the color cache table. The x offsets are byte offsets.
        switch (ppdev->ulBitCount)
        {
                case 8: // 8-bpp
                        ppdev->CLast = NUM_8BPP_BRUSHES;
                        for (i = 0; i < NUM_8BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x + (i % 2) * 64;
                                y = ppdev->Bcache->y + (i / 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                case 16: // 16-bpp
                        ppdev->CLast = NUM_16BPP_BRUSHES;
                        for (i = 0; i < NUM_16BPP_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + i;
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;

                default: // 24-bpp or 32-bpp
                        ppdev->CLast = NUM_TC_BRUSHES;
                        for (i = 0; i < NUM_TC_BRUSHES; i++)
                        {
                                x = ppdev->Bcache->x;
                                y = ppdev->Bcache->y + (i * 2);
                                ppdev->Ctable[i].xy = (y << 16) | x;
                                ppdev->Ctable[i].pjLinear = ppdev->pjScreen
                                                                                  + x + (y * ppdev->lDeltaScreen);
                                ppdev->Ctable[i].brushID = 0;
                        }
                        break;
        }
        ppdev->CNext = 0;
}

// ==========================================================================+
//                                                                          ||
// vInvalidateBrushCache()                                                  ||
//                                                                          ||
// Invalidate the brush caching tables.                                     ||
//                                                                          ||
// ==========================================================================+
void vInvalidateBrushCache(PPDEV ppdev)
{
    ULONG i;

        // Invalidate the entire monochrome brush cache.
        for (i = 0; i < NUM_MONO_BRUSHES; i++)
        {
                ppdev->Mtable[i].iUniq = 0;
                memset(ppdev->Mtable[i].ajPattern, 0,
                           sizeof(ppdev->Mtable[i].ajPattern));
        }
//      ppdev->MNext = 0;

        // Invalidate the entire 4-bpp brush cache.
        for (i = 0; i < NUM_4BPP_BRUSHES; i++)
        {
                ppdev->Xtable[i].iUniq = 0;
                memset(ppdev->Xtable[i].ajPattern, 0,
                           sizeof(ppdev->Xtable[i].ajPattern));
        }
//      ppdev->XNext = 0;

        // Invalidate the entire dither brush cache.
        for (i = 0; i < NUM_DITHER_BRUSHES; i++)
        {
                ppdev->Dtable[i].ulColor = (ULONG) -1;
        }
//      ppdev->DNext = 0;

        // Invalidate the entire color brush cache.
        for (i = 0; i < (int) ppdev->CLast; i++)
        {
                ppdev->Ctable[i].brushID = 0;
        }
//      ppdev->CNext = 0;
}


#if LOG_CALLS
/* --------------------------------------------------------------------*\
|                                                                       |
| Dump information on what brushes are requested from GDI to the        |
| profiling file.  Allows us to track what gets accellerated and        |
| what gets punted.  This function gets compiled out under a free       |
| build.                                                                |
|                                                                       |
\*---------------------------------------------------------------------*/

extern long lg_i;
extern char lg_buf[256];

void LogRealizeBrush(
ULONG     acc,
PPDEV     ppdev,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo
)
{

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    lg_i = sprintf(lg_buf,"DrvRealizeBrush: ");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    // Did we realize it?  If not, why?
    switch (acc)
    {
        case  0: lg_i = sprintf(lg_buf,"(Realized) ");                   break;
        case  1: lg_i = sprintf(lg_buf,"(Punted - No PDEV) ");           break;
        case  2: lg_i = sprintf(lg_buf,"(Punted - Not STYPE_BITMAP) ");  break;
        case  3: lg_i = sprintf(lg_buf,"(Punted - Not 8x8) ");           break;
        case  4: lg_i = sprintf(lg_buf,"(Punted - Has mask) ");          break;
        case  5: lg_i = sprintf(lg_buf,"(Punted - Bad color depth) ");   break;
        case  6: lg_i = sprintf(lg_buf,"(Punted - ALLOC failed) ");      break;
        case  7: lg_i = sprintf(lg_buf,"(Punted - Color Bottom-Up) ");   break;
        case  8: lg_i = sprintf(lg_buf,"(Punted - No 1BPP Xlate) ");     break;
        case  9: lg_i = sprintf(lg_buf,"(Punted - Has Color Xlate) ");   break;
        case 10: lg_i = sprintf(lg_buf,"(Punted - 4bpp format) ");         break;
        case 11: lg_i = sprintf(lg_buf,"(Punted - 1bpp XLATE) ");          break;
        case 99: lg_i = sprintf(lg_buf,"(Dithered) ");             break;
        default: lg_i = sprintf(lg_buf,"(STATUS UNKNOWN) ");             break;
    }
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (psoPattern == NULL)
    {
        lg_i = sprintf(lg_buf,"FMT=NULL");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP :  lg_i = sprintf(lg_buf,"FMT=1_bpp ");      break;
            case BMF_4BPP :  lg_i = sprintf(lg_buf,"FMT=4_bpp ");      break;
            case BMF_8BPP :  lg_i = sprintf(lg_buf,"FMT=8_bpp ");      break;
            case BMF_16BPP:  lg_i = sprintf(lg_buf,"FMT=16bpp ");      break;
            case BMF_24BPP:  lg_i = sprintf(lg_buf,"FMT=24bpp ");      break;
            case BMF_32BPP:  lg_i = sprintf(lg_buf,"FMT=32bpp ");      break;
            case BMF_4RLE :  lg_i = sprintf(lg_buf,"FMT=4_rle ");      break;
            case BMF_8RLE :  lg_i = sprintf(lg_buf,"FMT=8_rle ");      break;
            default:         lg_i = sprintf(lg_buf,"FMT=OTHER ");      break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        lg_i = sprintf(lg_buf,"CX=%d CY=%d ", psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy);
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    }

    lg_i = sprintf(lg_buf,"MASK=%s ",
                                ((psoMask == NULL) ? "NONE":
                                ((psoMask->pvScan0 == psoPattern->pvScan0) ? "SAME" : "DIFF")));
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

    if (pxlo == NULL)
    {
        lg_i = sprintf(lg_buf,"XLAT=NONE ");
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        if (pxlo->flXlate & XO_TRIVIAL)
        {
            lg_i = sprintf(lg_buf,"XLAT=TRIVIAL ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TABLE)
        {
            lg_i = sprintf(lg_buf,"XLAT=TABLE ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }
        if (pxlo->flXlate & XO_TO_MONO)
        {
            lg_i = sprintf(lg_buf,"XLAT=TO_MONO ");
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

        switch (pxlo->iSrcType)
        {
            case PAL_INDEXED:   lg_i = sprintf(lg_buf,"SRCPAL=INDEXED  "); break;
            case PAL_BITFIELDS: lg_i = sprintf(lg_buf,"SRCPAL=BITFIELD "); break;
            case PAL_RGB:       lg_i = sprintf(lg_buf,"SRCPAL=R_G_B    "); break;
            case PAL_BGR:       lg_i = sprintf(lg_buf,"SRCPAL=B_G_R    "); break;
            default:            lg_i = sprintf(lg_buf,"SRCPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch (pxlo->iDstType)
        {
            case PAL_INDEXED:  lg_i = sprintf(lg_buf,"DSTPAL=INDEXED  "); break;
            case PAL_BITFIELDS:lg_i = sprintf(lg_buf,"DSTPAL=BITFIELD "); break;
            case PAL_RGB:      lg_i = sprintf(lg_buf,"DSTPAL=R_G_B    "); break;
            case PAL_BGR:      lg_i = sprintf(lg_buf,"DSTPAL=B_G_R    "); break;
            default:           lg_i = sprintf(lg_buf,"DSTPAL=NONE     "); break;
        }
        WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    lg_i = sprintf(lg_buf,"\r\n");
    WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}
#endif

#if SOLID_CACHE
/******************************************************************************
 *                                                                                                                                                        *
 * Name:                CacheSolid                                                                                                        *
 *                                                                                                                                                        *
 * Function:    Convert a solid color into a colored brush for use when a         *
 *                              monochrome source blt requires a solid brush. This will speed *
 *                              up WinBench 96 tests 5 and 9.                                                             *
 *                                                                                                                                                        *
 ******************************************************************************/
void CacheSolid(PPDEV ppdev)
{
        PBYTE pjBrush = ppdev->Stable[ppdev->SNext].pjLinear;
        ULONG color = ppdev->Stable[ppdev->SNext].ulColor;
        int   i, j;

        switch (ppdev->iBitmapFormat)
        {
                case BMF_8BPP:
                        for (i = 0; i < 64; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_16BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                // Remember, the color is already expanded!
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;

                case BMF_24BPP:
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        pjBrush += ppdev->lDeltaScreen - 128;
                        for (j = 0; j < 4; j++)
                        {
                                for (i = 0; i < 24; i += 3)
                                {
                                        *(ULONG *) &pjBrush[i] = color;
                                }
                                *(ULONG *) &pjBrush[i + 0] = *(ULONG *) &pjBrush[0];
                                *(ULONG *) &pjBrush[i + 4] = *(ULONG *) &pjBrush[4];
                                pjBrush += 32;
                        }
                        break;

                case BMF_32BPP:
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        pjBrush += ppdev->lDeltaScreen;
                        for (i = 0; i < 128; i += 4)
                        {
                                *(ULONG *) &pjBrush[i] = color;
                        }
                        break;
        }

        REQUIRE(2);
        LL32(grOP2_opMRDRAM, ppdev->Stable[ppdev->SNext].xy);
        ppdev->SNext = (ppdev->SNext + 1) % NUM_SOLID_BRUSHES;
}
#endif

#if DBG

//
// The rest of this file is debugging functions.
//

/* --------------------------------------------------------------------*\
|                                                                       |
| PrintBrush()                                                          |
| Dump a 1 bpp brush as 'X's and ' 's to the debuger so we can see what |
| it looks like.                                                        |
|                                                                       |
| We don't currently use this, but it can be useful to have for         |
| debugging purposes.                                                   |
|                                                                       |
\*---------------------------------------------------------------------*/
void PrintBrush(
        SURFOBJ  *psoPattern
)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (psoPattern->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"Brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush delta is %d bytes.\n",psoPattern->lDelta));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush uses %d bytes.\n",psoPattern->cjBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Brush bits are at 0x%08X.\n",psoPattern->pvBits));
        DISPDBG((BRUSH_DBG_LEVEL,"Scan 0 is at 0x%08X.\n",psoPattern->pvScan0));
        if (psoPattern->fjBitmap & BMF_TOPDOWN)
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is top down.\n",psoPattern->pvScan0));
        else
                        DISPDBG((BRUSH_DBG_LEVEL,"Brush is bottom up.\n",psoPattern->pvScan0));


        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
            c = (unsigned char)((long*)psoPattern->pvBits)[i];

            DISPDBG((BRUSH_DBG_LEVEL,"'"));
            for (j=7; (7>=j && j>=0) ; --j)
            {
                 if (c&1)
                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                 else
                        DISPDBG((BRUSH_DBG_LEVEL," "));
                 c = c >> 1;
            }
            DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

}


//
// ===========================================================================
// Dumps all kind of cool stuff about realized brushes to the debugger.
//
// Here's the realized brush structure:
/*

typedef struct {
        ULONG   nPatSize;
        ULONG   iBitmapFormat;
        ULONG   ulForeColor;
        ULONG   ulBackColor;
        ULONG   isCached;           // 1 if this brush is cached, 0 if not.
        ULONG   cache_slot;         // Slot number of cache table entry.
        ULONG   cache_x;            // These are the (x,y) location of
        ULONG   cache_y;            // the cached brush from screen(0,0)
        ULONG   cjMask;             // offset to mask bits in ajPattern[]
        BYTE    ajPattern[1];       // pattern bits followed by mask bits
} RBRUSH, *PRBRUSH;

*/
// ============================================================================
//
void PrintRealizedBrush(
        PRBRUSH pRbrush)
{
        int i,j;
        char c;

        // Only do this for 1bpp brushes.
        if (pRbrush->iBitmapFormat != BMF_1BPP)
                return;

        DISPDBG((BRUSH_DBG_LEVEL,"\nRealized brush information:\n"));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush colors:  FG = 0x%08X  BG = 0x%08X \n",
                                pRbrush->ulForeColor, pRbrush->ulForeColor));

        DISPDBG((BRUSH_DBG_LEVEL,"Brush pattern size is  %d bytes.\n",
                                pRbrush->nPatSize));

        DISPDBG((BRUSH_DBG_LEVEL,"PATTERN:\n"));

        for (i=0; i<8; ++i)
        {
                c = pRbrush->ajPattern[i];

                DISPDBG((BRUSH_DBG_LEVEL,"'"));
                for (j=7; (7>=j && j>=0) ; --j)
                {
                         if (c&1)
                                        DISPDBG((BRUSH_DBG_LEVEL,"X"));
                         else
                                        DISPDBG((BRUSH_DBG_LEVEL," "));
                         c = c >> 1;
                }
                DISPDBG((BRUSH_DBG_LEVEL,"'\n"));
        }

                DISPDBG((BRUSH_DBG_LEVEL,"\n"));

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\copybits.c ===
/******************************Module*Header*******************************\
* Module Name: COPYBITS.c
*
* Author: Noel VanHook
* Date: May. 31, 1995
* Purpose: Handle calls to DrvCopyBits
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/COPYBITS.C  $
*
*    Rev 1.50   Mar 04 1998 15:22:54   frido
* Added new shadow macros.
*
*    Rev 1.49   Feb 25 1998 16:43:48   frido
* Fixed a 16-bpp color translation problem for NT 5.0.
*
*    Rev 1.48   Feb 24 1998 13:19:10   frido
* Removed a few warning messages for NT 5.0.
*
*    Rev 1.47   Dec 10 1997 13:29:54   frido
* Merged from 1.62 branch.
*
*    Rev 1.46.1.0   Nov 10 1997 14:58:46   frido
* PDR#10893: With monochrome color translations in 8-bpp (palette) NT
* decides that a 2-color translation table with values 0 and 1 is a TRIVIAL
* translation table. But this breaks our assumption that the background is
* always black (0) and the foreground if white (FF). Lucky for us NT sets
* an extra bit in this case: the translation table is both TRIVIAL and has a
* TABLE.
*
*    Rev 1.46   Nov 04 1997 17:36:58   frido
* Fixed 8-bpp path when no color translation is required.
*
*    Rev 1.45   Nov 04 1997 09:41:10   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* Removed unaccessed local variables.
*
*    Rev 1.44   Nov 03 1997 15:09:24   frido
* Added REQUIRE and WRITE_STRING macros.
*
*    Rev 1.43   15 Oct 1997 12:02:26   noelv
* Added host to screen color translation
*
*    Rev 1.42   08 Aug 1997 17:23:34   FRIDO
*
* Updatded SWAT7 code for monochrome hardware bug.
*
*    Rev 1.41   25 Jun 1997 16:01:36   noelv
* Check for NULL translation table before using it.
*
*    Rev 1.40   12 Jun 1997 14:46:12   noelv
* Frido's optimized workaround for MONO HOSTDATA bug (SWAT7)
* SWAT:
* SWAT:    Rev 1.3   06 Jun 1997 10:42:34   frido
* SWAT: Changed 896 pixel width into 888.
* SWAT:
* SWAT:    Rev 1.2   05 Jun 1997 14:48:14   frido
* SWAT: Added SWAT7 code (monochrome bitblt cut-off).
*
*    Rev 1.39   08 Apr 1997 12:14:16   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.38   21 Mar 1997 10:54:16   noelv
*
* Combined 'do_flag' and 'sw_test_flag' together into 'pointer_switch'
*
*    Rev 1.37   19 Feb 1997 13:14:50   noelv
* Moved default xlate table to xlate.c
*
*    Rev 1.36   06 Feb 1997 10:37:38   noelv
*
* Put device to device stuff in it's own file.
*
*    Rev 1.35   28 Jan 1997 11:13:42   noelv
*
* Removed extra dword requirements from 5465 driver.
*
*    Rev 1.34   23 Jan 1997 17:26:36   bennyn
* Modified to support 5465 DD
*
*    Rev 1.33   23 Jan 1997 11:26:10   noelv
*
* Modified the '62 workaround to only happen on the '62
*
*    Rev 1.32   17 Jan 1997 10:10:30   noelv
* Workaround (punt) for HOSTDATA lockup on '62
*
*    Rev 1.31   18 Dec 1996 11:35:30   noelv
* Official workaround for mono hostdata bug.
*
*    Rev 1.30   17 Dec 1996 17:05:48   SueS
* Added test for writing to log file based on cursor at (0,0).  Added more
* information to the log file.
*
*    Rev 1.29   11 Dec 1996 14:18:54   noelv
*
* Punt 24bpp mono host to screen with rop=66 (hw bug?)
*
*    Rev 1.28   26 Nov 1996 10:47:34   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.27   13 Nov 1996 17:21:38   SueS
* Changed WriteFile calls to WriteLogFile.  Ifdef'ed out YUVBlt code
* if USE_ASM is turned off.
*
*    Rev 1.26   04 Oct 1996 16:52:00   bennyn
*
* Added DirectDraw YUV support
*
*    Rev 1.25   06 Sep 1996 09:14:46   noelv
*
* Cleaned up NULL driver code.
*
*    Rev 1.24   20 Aug 1996 11:03:20   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.3   18 Aug 1996 20:39:08   frido
* Changed DrvCopyBits' detection of memory bitmaps. This fixes some GPF's.
*
*    Rev 1.2   17 Aug 1996 13:18:14   frido
* New release from Bellevue.
*
*    Rev 1.1   15 Aug 1996 11:44:08   frido
* Added precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
*
*    Rev 1.22   28 May 1996 15:11:18   noelv
* Updated data logging.
*
*    Rev 1.21   24 Apr 1996 20:41:46   noelv
* Fixed syntax error in C code (not used when using inline assembler)
*
*    Rev 1.20   16 Apr 1996 22:48:42   noelv
* accelerated color xlate for device to device.
*
*    Rev 1.22   15 Apr 1996 17:26:46   frido
* Added color translation in DeviceToDevice.
*
*    Rev 1.21   12 Apr 1996 11:27:00   frido
* Fixed a type in DeviceToHost24.
*
*    Rev 1.20   08 Apr 1996 16:45:08   frido
* Added call to PuntBitBlt.
* Added check for translation in ScreenToHost.
* Added SolidBrush cache.
*
*    Rev 1.19   04 Apr 1996 09:57:10   frido
* Added test for bitmap format in ScreenToHost.
*
*    Rev 1.18   30 Mar 1996 22:12:16   frido
* Refined checking for invalid translation flags.
*
*    Rev 1.17   29 Mar 1996 14:53:52   frido
* Fixed problem with grayed icons.
*
*    Rev 1.16   27 Mar 1996 16:56:14   frido
* Added return values to Do... routines.
* Added check for undocumented translation flags.
* Added check for translation tables.
* Removed OP0 field in BLTDEF.
*
*    Rev 1.15   25 Mar 1996 12:03:58   frido
* Changed #ifdef frido into #if frido.
*
*    Rev 1.14   25 Mar 1996 11:53:30   frido
* Removed assembly for DoDeviceToDevice.
*
*    Rev 1.13   25 Mar 1996 11:52:38   frido
* Bellevue 102B03.
*
*    Rev 1.9   20 Mar 1996 17:16:08   BENNYN
* Fixed the BPR910 & BPR920 Phostone problems
*
*    Rev 1.8   20 Mar 1996 14:17:42   bennyn
*
*
*    Rev 1.7   19 Mar 1996 11:37:32   noelv
*
* Added data logging.
*
*    Rev 1.6   14 Mar 1996 09:38:46   andys
*
* Added if def on DoDeviceToDevice
*
*    Rev 1.5   07 Mar 1996 18:20:58   bennyn
* Removed read/modify/write on CONTROL reg
*
*    Rev 1.4   06 Mar 1996 12:51:30   noelv
* Frido ver 19b
*
*    Rev 1.9   06 Mar 1996 14:59:06   frido
* Added 'striping' wide bitmaps in 16-bpp and higher.
*
*    Rev 1.8   04 Mar 1996 20:22:50   frido
* Cached grCONTROL register.
*
*    Rev 1.7   01 Mar 1996 17:48:12   frido
* Added in-line assembly.
*
*    Rev 1.6   29 Feb 1996 20:23:46   frido
* Added 8-bpp source translation in 24- and 32-bpp HostToScreen.
*
*    Rev 1.5   28 Feb 1996 22:35:20   frido
* Added 8-bpp source translation in 16-bpp HostToScreen.
*
*    Rev 1.4   27 Feb 1996 16:38:06   frido
* Added device bitmap store/restore.
*
*    Rev 1.3   26 Feb 1996 23:37:08   frido
* Added comments.
* Rewritten ScreenToHost and HostToScreen routines.
* Removed several other bugs.
*
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"


#define COPYBITS_DBG_LEVEL 1

#if LOG_CALLS
    void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo);
#else
    #define LogCopyBits(acc, psoSrc, psoDest, pco, pxlo)
#endif

//
// Top level BLT functions.
//

#if (defined(i386) && USE_ASM)
BOOL YUVBlt(SURFOBJ*  psoTrg, SURFOBJ* psoSrc,  CLIPOBJ* pco,
            XLATEOBJ* pxlo,   RECTL*   prclTrg, POINTL*  pptlSrc);
#endif

BOOL CopyDeviceBitmap(SURFOBJ* psoTrg, SURFOBJ* psoSrc, CLIPOBJ* pco,
              XLATEOBJ* pxlo, RECTL* prclTrg, POINTL* pptlSrc,
              ULONG ulDRAWBLTDEF, COPYFN* pfn);
BOOL DoDeviceToDevice(SURFOBJ* psoTrg, SURFOBJ* psoSrc, XLATEOBJ* pxlo,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);
BOOL PuntBitBlt(SURFOBJ* psoDest, SURFOBJ* psoSrc, SURFOBJ* psoMask,
        CLIPOBJ* pco, XLATEOBJ* pxlo, RECTL* prclDest, POINTL* pptlSrc,
        POINTL* pptlMask, BRUSHOBJ* pbo, POINTL* pptlBrush, ROP4 rop4);

BOOL DoDeviceToDeviceWithXlate(SURFOBJ* psoTrg, SURFOBJ* psoSrc, ULONG* pulXlate,
              RECTL* prclTrg, POINTL* pptlSrc, ULONG ulDRAWBLTDEF);


#if SOLID_CACHE
    VOID CacheSolid(PDEV* ppdev);
#endif


/******************************************************************************\
*                                                                                                                                                          *
*  DrvCopyBits                                                                                             *
*                                                                                                                  *
\******************************************************************************/
BOOL DrvCopyBits(
    SURFOBJ*  psoTrg,
    SURFOBJ*  psoSrc,
    CLIPOBJ*  pco,
    XLATEOBJ* pxlo,
    RECTL*    prclTrg,
    POINTL*   pptlSrc)
{
    BOOL  fSrc, fDest;
    PDEV* ppdev;

    #if NULL_COPYBITS
    {
        if (pointer_switch)   return(TRUE);
    }
    #endif

    DISPDBG((COPYBITS_DBG_LEVEL, "DrvCopyBits\n"));

    // Determine if the source and target are the screen or a device bitmap.  I
    // have seen several cases where memory bitmaps are created with the dhpdev
    // set to the screen, so we must check if the surface handles to the screen
    // match.
    fDest = (psoTrg->dhpdev != 0);
    if (fDest)
    {
                // The destination must be either the screen or a device bitmap.
                if ((psoTrg->hsurf != ((PDEV*)(psoTrg->dhpdev))->hsurfEng) &&
                        (psoTrg->iType != STYPE_DEVBITMAP))
                {
                        fDest = FALSE;  // The destination is a memory bitmap.
                }
    }

    fSrc = (psoSrc->dhpdev != 0);
    if (fSrc)
    {
        // The source must be either the screen or a device bitmap.
        if ((psoSrc->hsurf != ((PDEV*)(psoSrc->dhpdev))->hsurfEng) &&
            (psoSrc->iType != STYPE_DEVBITMAP))
        {
            fSrc = FALSE;       // The source is a memory bitmap.
        }
    }

    ppdev = (PDEV*) (fSrc ? psoSrc->dhpdev : (fDest ? psoTrg->dhpdev : NULL));

    SYNC_W_3D(ppdev);

#if (defined(i386) && USE_ASM)
    if (ppdev->dwLgDevID < CL_GD5465)
    {
       if (YUVBlt(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc))
          return TRUE;
    };
#endif

    // If the destination is a DIB device bitmap, try copying it into
    // off-screen memory.
    if ( fDest &&                                       // Is destination valid?
         (psoTrg->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoTrg->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoTrg->dhsurf) )
        {
                psoTrg = ((DSURF*) psoTrg->dhsurf)->pso;
                fDest  = FALSE; // Destination is memory.
        }
    }

    // If the source is a DIB device bitmap, try copying it into off-screen
    // memory.
    if ( fSrc &&                                        // Is source valid?
         (psoSrc->iType == STYPE_DEVBITMAP) &&          // Is it a device bitmap?
                 ((DSURF*) psoSrc->dhsurf)->pso )       // Has it a surface?
    {
        if ( !bCreateScreenFromDib(ppdev, (DSURF*) psoSrc->dhsurf) )
        {
            psoSrc = ((DSURF*) psoSrc->dhsurf)->pso;
            fSrc   = FALSE;     // Source is memory.
        }
    }

    if (fDest)
    {
        // The target is the screen.
        if (fSrc)
        {
             // The source is the screen.
             if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, DoDeviceToDevice))
             {
                 LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                 return(TRUE);
             }
        }
        else if ( (psoSrc->iBitmapFormat <= BMF_8BPP) ||
                  (psoSrc->iBitmapFormat == psoTrg->iBitmapFormat) )
        {
            // Ths source is main memory. We only support 1-bpp, 4-bpp, 8-bpp,
            // or the device-bpp formats.
            if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                                 0x000000CC, ppdev->pfnHostToScreen))
            {
                LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
                return(TRUE);
            }
        }
    }


    else if (fSrc)
    {
        // The source is the screen.
        if (CopyDeviceBitmap(psoTrg, psoSrc, pco, pxlo, prclTrg, pptlSrc,
                             0x000000CC, ppdev->pfnScreenToHost))
        {
            LogCopyBits(0, psoSrc,  psoTrg, pco, pxlo);
            return(TRUE);
        }
    }

    // We have a memory to memory blit. Let NT handle it!
    LogCopyBits(1, psoSrc,  psoTrg, pco, pxlo);
    return PuntBitBlt(psoTrg, psoSrc, NULL, pco, pxlo, prclTrg, pptlSrc, NULL,
                      NULL, NULL, 0x0000CCCC);
}

#if LOG_CALLS
// ****************************************************************************
//
// LogCopyBlt()
// This routine is called only from DrvCopyBits()
// Dump information to a file about what is going on in CopyBit land.
//
// ****************************************************************************
void LogCopyBits(
        int       acc,
        SURFOBJ*  psoSrc,
        SURFOBJ*  psoDest,
        CLIPOBJ*  pco,
        XLATEOBJ* pxlo)
{
    PPDEV dppdev,sppdev,ppdev;
    char buf[256];
    int i;
    BYTE fg_rop, bg_rop;
    ULONG iDComplexity;

    dppdev = (PPDEV) (psoDest ? psoDest->dhpdev : 0);
    sppdev = (PPDEV) (psoSrc  ? psoSrc->dhpdev  : 0);
    ppdev = dppdev ? dppdev : sppdev;

    #if ENABLE_LOG_SWITCH
        if (pointer_switch == 0) return;
    #endif

    i = sprintf(buf,"DCB: ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

        switch(acc)
    {
        case 0: // Accelerated
            i = sprintf(buf, "ACCL ");
            break;

        case 1: // Punted
            i = sprintf(buf, "PUNT BitBlt ");
            break;

        default:
            i = sprintf(buf, "PUNT unknown ");
            break;

    }
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the SRC
    //
    if (psoSrc)
    {
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Src Id=%p ", psoSrc->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if ( ((PDSURF)psoSrc->dhsurf)->pso  )
                i = sprintf(buf,"S=DH ");
            else
                i = sprintf(buf,"S=DF ");
        }
        else if (psoSrc->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"S=S ");
        else
            i = sprintf(buf,"S=H ");
    }
    else
        i = sprintf(buf,"S=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Check the DEST
    //
    if (psoDest)
    {
        if (psoDest->iType == STYPE_DEVBITMAP)
        {
            i = sprintf(buf, "Dst Id=%p ", psoDest->dhsurf);
            WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
            if (  ((PDSURF)psoDest->dhsurf)->pso   )
                i = sprintf(buf,"D=DH ");
            else
                i = sprintf(buf,"D=DF ");
        }
        else if (psoDest->hsurf == ppdev->hsurfEng)
            i = sprintf(buf,"D=S ");
        else
            i = sprintf(buf,"D=H ");
    }
    else
        i = sprintf(buf,"D=N ");
    WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);




    //
    // Check the type of clipping.
    //
    iDComplexity = (pco ? pco->iDComplexity : DC_TRIVIAL);
    i = sprintf(buf,"C=%s ",
                (iDComplexity==DC_TRIVIAL ? "T":
                (iDComplexity == DC_RECT ? "R" : "C" )));
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);


    //
    // Type of translation
    //
    if (!pxlo)
    {
        i = sprintf(buf,"T=N ");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else if (pxlo->flXlate & XO_TRIVIAL)
    {
        i = sprintf(buf,"T=T ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }
    else
    {
        i = sprintf(buf,"T=NT ");
                WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
    }

    i = sprintf(buf,"\r\n");
        WriteLogFile(ppdev->pmfile, buf, i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);

}

#endif

/*****************************************************************************\
 * CopyDeviceBitmap
 *
 * This is the main entry routine for all bitblt functions. It will dispatch
 * the blit to the correct handler and performs the clipping.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pco                             Pointer to clip object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags. It will be filled
 *                                                              by the dispatch routine.
 *                              pfn                             Pointer to dispatch function.
 *
 * Returns:             TRUE if successful, FALSE if we cannot handle this blit.
\*****************************************************************************/
BOOL CopyDeviceBitmap(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        CLIPOBJ  *pco,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF,
        COPYFN   *pfn
)
{
        // Check for no clipping.
        if ( (pco == NULL) || (pco->iDComplexity == DC_TRIVIAL) )
        {
                return(pfn(psoTrg, psoSrc, pxlo, prclTrg, pptlSrc, ulDRAWBLTDEF));
        }

        // Check for single rectangle clipping.
        else if (pco->iDComplexity == DC_RECT)
        {
                RECTL  rcl;
                POINTL ptl;

                // Intersect the destination rectangle with the clipping rectangle.
                rcl.left = max(prclTrg->left, pco->rclBounds.left);
                rcl.top = max(prclTrg->top, pco->rclBounds.top);
                rcl.right = min(prclTrg->right, pco->rclBounds.right);
                rcl.bottom = min(prclTrg->bottom, pco->rclBounds.bottom);

                // Do we have a valid rectangle?
                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                {
                        // Setup the source offset.
                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                        // Dispatch the blit.
                        return(pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF));
                }
        }

        // Complex clipping.
        else
        {
                BOOL       bMore;
                ENUMRECTS8 ce;
                RECTL*     prcl;
                ULONG      ulDirClip = CD_ANY;

                // If we have a screen to screen blit, we must specify the sorting of
                // the rectangles since we must take care not to draw on a destination
                // before that destination itself may be used as the source for a blit.
                // This only accounts for the same physical surface, not between
                // different device bitmaps.
                if ( (pfn == DoDeviceToDevice) && (psoSrc->dhsurf == psoTrg->dhsurf) )
                {
                        if (prclTrg->left > pptlSrc->x)
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_LEFTUP : CD_LEFTDOWN;
                        }
                        else
                        {
                                ulDirClip =
                                        (prclTrg->top > pptlSrc->y) ? CD_RIGHTUP : CD_RIGHTDOWN;
                        }
                }

                // Start the enumeration process.
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDirClip, 0);
                do
                {
                        // Get a bunch of clipping rectangles.
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *) &ce);

                        // Loop through all clipping rectangles.
                        for (prcl = ce.arcl; ce.c--; prcl++)
                        {
                                RECTL  rcl;
                                POINTL ptl;

                                // Intersect the destination rectangle with the clipping
                                // rectangle.
                                rcl.left = max(prclTrg->left, prcl->left);
                                rcl.top = max(prclTrg->top, prcl->top);
                                rcl.right = min(prclTrg->right, prcl->right);
                                rcl.bottom = min(prclTrg->bottom, prcl->bottom);

                                if ( (rcl.left < rcl.right) && (rcl.top < rcl.bottom) )
                                {
                                        // Setup the source offset.
                                        ptl.x = pptlSrc->x + (rcl.left - prclTrg->left);
                                        ptl.y = pptlSrc->y + (rcl.top - prclTrg->top);
                                        // Dispatch the blit.
                                        if (!pfn(psoTrg, psoSrc, pxlo, &rcl, &ptl, ulDRAWBLTDEF))
                                        {
                                                return(FALSE);
                                        }
                                }
                        }
                }
                while (bMore);
        }

        // Always return TRUE.
        return(TRUE);
}




/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                      8 - B P P                                                                *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost8ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 8-bpp. Color translation is supported.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost8ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate the source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;

                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if ( (flXlate & XO_TRIVIAL) && !(flXlate & XO_TABLE) )
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 8;
                        fgColor |= fgColor << 8;
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;

                        #if 1 // SWAT: 08/08/97
                        // In 8-bpp the 5465AD has a hardware bug when 64 < width < 128.
                        if (sizl.cx > 64 && sizl.cx < 128)
                        {
                                sizl.cx = 64;
                        }
                        #endif
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = ptlSrc.x & 1;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if ! DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        BYTE  data[4];

                        // First, we convert 4 pixels at a time to create a 32-bit value to
                        // write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                data[0] = (BYTE) pulXlate[p[0] >> 4];
                                data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                data[2] = (BYTE) pulXlate[p[1] >> 4];
                                data[3] = (BYTE) pulXlate[p[1] & 0x0F];
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)data);
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;

                                case 3:
                                        data[0] = (BYTE) pulXlate[p[0] >> 4];
                                        data[1] = (BYTE) pulXlate[p[0] & 0x0F];
                                        data[2] = (BYTE) pulXlate[p[1] >> 4];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        //
        // If color translation is required, attempt to load the translation
        // table into the chip.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                            pxlo, (BYTE)(ulDRAWBLTDEF & 0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // pulXlate == NULL if there is no color translation is required.
        // pulXlate == translation table if color translation is required.
        // UseHWxlate == FALSE if the hardware will do the xlate for us.
        // UseHWxlate == TRUE if we must do the translation in software.

                // If we have invalid translation flags, punt the blit.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
                if (flXlate & 0x10)
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
                {
                                // We have a problem with the HOSTDATA TABLE.
                                // Punt till we can figure it out.
                                return(FALSE);
                        }
                        lExtra =
                                        ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
                }
                else
                {
                        lExtra = 0;
                }
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);

                // Test for SW color translation.
#if COLOR_TRANSLATE
                if (UseHWxlate)
#else
                if (pulXlate == NULL)
#endif
        {    // HW color translate, or no translate required.

            if (pulXlate)
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "Attempting HW color translation on 8bpp Host to Screen.\n"));
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.
            }
            else
            {
                DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                   "No color translation required on 8bpp Host to Screen.\n"));
                        LL_BLTEXT(sizl.cx, sizl.cy); // No xlate.
            }

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
                else  // Software color translation is required.
                {
            DISPDBG((COPYBITS_DBG_LEVEL, "Host8ToDevice: "
                  "Attempting SW color translation on 8bpp Host to Screen.\n"));
            ASSERTMSG(pulXlate,
                "Host8ToDevice: No translation table for SW color translation.\n");

                LL_BLTEXT(sizl.cx, sizl.cy);

                        while (sizl.cy--)
                        {
                                BYTE *p = pBits;

                                // We copy 4 pixels to fill an entire 32-bit DWORD.
                                for (i = 0; i < n; i++)
                                {
                                        BYTE data[4];

                                        data[0] = (BYTE) pulXlate[p[0]];
                                        data[1] = (BYTE) pulXlate[p[1]];
                                        data[2] = (BYTE) pulXlate[p[2]];
                                        data[3] = (BYTE) pulXlate[p[3]];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)data);
                                        p += 4;
                                }

                #if !DRIVER_5465
                                // Now, write the extra DWORDS.
                                REQUIRE(lExtra);
                                for (i = 0; i < lExtra; i++)
                                {
                                        LL32(grHOSTDATA[0], 0);
                                }
                #endif

                                // Next line.
                                pBits += lDelta;
                        }
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost8
 *
 * This routine performs a DeviceToHost for either monochrome or 8-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost8(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;

                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask, fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Lookup the foreground color in the translation table. We scan from
                // the back since in most cases it will be entry 255.
                pulXlate = pxlo->pulXlate;
                for (fgColor = 255; pulXlate[fgColor] != 1; fgColor--);

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PBYTE pSrc = pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x80;
                                if (pixels[1] == fgColor) data |= 0x40;
                                if (pixels[2] == fgColor) data |= 0x20;
                                if (pixels[3] == fgColor) data |= 0x10;
                                *(ULONG *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (pixels[0] == fgColor) data |= 0x08;
                                if (pixels[1] == fgColor) data |= 0x04;
                                if (pixels[2] == fgColor) data |= 0x02;
                                if (pixels[3] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_8BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits[prclTrg->left] =
                        ppdev->pjScreen[ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel(s).
                        switch (i)
                        {
                                case 1:
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 2:
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 1 6 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost16ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 16-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost16ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and offset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];

                        // Expand the colors.
                        bgColor |= bgColor << 16;
                        fgColor |= fgColor << 16;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0xFFFFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 2;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[
                                MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
        {
                lExtra = 0;
                }
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we convert 2 pixels at a time to create a 32-bit value
                        // to write to the hardware.
                        for (i = n; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4] |
                                                                        (pulXlate[p[0] & 0x0F] << 16));
                                p++;
                        }

                        // Now, write any remaining pixel.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {
        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
#if COLOR_TRANSLATE
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 2, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting HW color translation on 8bpp Host to 16bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
                    lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }
        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host16ToDevice: "
            "Attempting SW color translation on 8bpp Host to 16bpp Screen.\n"));

            // To do 8bpp host to 16bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host16ToDevice: No translation table for color translation.\n");

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
                        {
                                if (MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2) == 3788)
                                {
                                        // We have a problem with the HOSTDATA TABLE.
                                        // Punt till we can figure it out.
                                        return FALSE;
                                }
                                lExtra = ExtraDwordTable[
                                                MAKE_HD_INDEX(sizl.cx * 2, 0, ptlDest.x * 2)];
                        }
                        else
                        {
                                lExtra = 0;
                        }
            #endif

                // Calculate the source parameters.
                pBits += ptlSrc.x; // Start of source data on the host.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 2 pixels at a time to create a 32-bit value
                        // for the HOSTDATA register.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]] |
                                                (pulXlate[p[1]] << 16));
                                p += 2;
                        }

                        // Write any remainig pixels.
                        if (i)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[p[0]]);
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
#if _WIN32_WINNT >= 0x0500
                if ( pulXlate || (flXlate & 0x0200) )
#else
                if ( pulXlate || (flXlate & 0x0010) )
#endif
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 2;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = ((sizl.cx * 2) + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                    lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 2, lLeadIn, ptlDest.x * 2)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[i], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost16
 *
 * This routine performs a DeviceToHost for either monochrome or 16-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost16(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                WORD  fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                #if S2H_USE_ENGINE
                BYTE  pixels[4];
                #endif

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routines to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? (WORD) *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 2;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        PWORD pSrc = (WORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them with the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them with the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x80;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x40;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x20;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x10;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x08;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x04;
                                *(DWORD *)pixels = LLDR_SZ(grHOSTDATA[0]);
                                if (*(WORD *)&pixels[0] == fgColor) data |= 0x02;
                                if (*(WORD *)&pixels[1] == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_16BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(WORD *)pBits[prclTrg->left] = *(WORD *)
                        &ppdev->pjScreen[ptlSrc.x * 2 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 2 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 2;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 2 so the 32-bit HOSTDATA is
                        // happy.
                        for (i = sizl.cx; i >= 2; i -= 2)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remainig pixel.
                        if (i)
                        {
                                *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 2);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 2 4 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost24ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 24-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost24ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofsfet into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);


        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG bgColor, fgColor;
#if SWAT7
                SIZEL sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0x00FFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0] & 0x00FFFFFF;
                        fgColor = pulXlate[1] & 0x00FFFFFF;
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) && (fgColor == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to BYTE
                // adjust the source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 7;
                pBits += ptlSrc.x >> 3;
                n = (sizl.cx + lLeadIn + 7) >> 3;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 15 dwords HOSTDATA
        //
        if (n > 120) // 15 qwords = 120 bytes
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        BYTE *p = pBits;
                        BYTE pixels[4];

                        // First, we draw 32-pixels at a time to keep HOSTDATA happy.
                        for (i = n; i >= 4; i -= 4)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], *(DWORD *)p);
                                p += 4;
                        }

                        // Draw any remainig pixls.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *p);
                                        break;

                                case 2:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(WORD *)p);
                                        break;

                                case 3:
                                        pixels[0] = p[0];
                                        pixels[1] = p[1];
                                        pixels[2] = p[2];
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], *(DWORD *)pixels);
                                        break;
                        }

                        // Next line.
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                #if 1 // SWAT: 08/08/97
                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                #endif
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters. We are going to BYTE adjust the
                // source, so we also set the source phase.
                lLeadIn = (ptlSrc.x & 1) * 3;
                pBits += ptlSrc.x >> 1;
                n = sizl.cx + (ptlSrc.x & 1);

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;
                        ULONG pixels[4];

                        // First, we convert 4 pixels at a time to create three 32-bit
                        // values to write to the hardware.
                        for (i = n; i >= 4; i -= 4)
                        {
                                pixels[0] = pulXlate[p[0] >> 4];
                                pixels[1] = pulXlate[p[0] & 0x0F];
                                pixels[2] = pulXlate[p[1] >> 4];
                                pixels[3] = pulXlate[p[1] & 0x0F];
                                // 1000
                                REQUIRE(3);
                                LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                // 2211
                                LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                // 3332
                                LL32(grHOSTDATA[2], (pixels[2] >> 16) | (pixels[3] << 8));
                                p += 2;
                        }

                        // Now, write any remaining pixels.
                        switch (i)
                        {
                                case 1:
                                        // x000
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        break;

                                case 2:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        // 1000
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // xx11
                                        LL32(grHOSTDATA[1], pixels[1] >> 8);
                                        break;

                                case 3:
                                        pixels[0] = pulXlate[p[0] >> 4];
                                        pixels[1] = pulXlate[p[0] & 0x0F];
                                        pixels[2] = pulXlate[p[1] >> 4];
                                        // 1000
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0], pixels[0] | (pixels[1] << 24));
                                        // 2211
                                        LL32(grHOSTDATA[1], (pixels[1] >> 8) | (pixels[2] << 16));
                                        // xxx2
                                        LL32(grHOSTDATA[2], pixels[2] >> 16);
                                        break;
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost24ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 3, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

            DISPDBG((COPYBITS_DBG_LEVEL, "Host24ToDevice: "
            "Attempting HW color translation on 8bpp Host to 24bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.


                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.


                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //

                // Calculate the source parameters.
                pBits += ptlSrc.x;

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, 0, ptlDest.x * 3)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // We need to copy 4 pixels at a time to create three 32-bit values
                        // for the HOSTDATA register and stay in sync.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                REQUIRE(3);
                                LL32(grHOSTDATA[0],
                                         pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                LL32(grHOSTDATA[1],
                                         (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                LL32(grHOSTDATA[2],
                                         (pulXlate[p[2]] >> 16) | (pulXlate[p[3]] << 8));
                                p += 4;
                        }

                        // Write any remainig pixels.
                        switch (i)
                        {
                                case 1:
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[p[0]]);
                                        break;

                                case 2:
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1], pulXlate[p[1]] >> 8);
                                        break;

                                case 3:
                                        REQUIRE(3);
                                        LL32(grHOSTDATA[0],
                                                 pulXlate[p[0]] | (pulXlate[p[1]] << 24));
                                        LL32(grHOSTDATA[1],
                                                 (pulXlate[p[1]] >> 8) | (pulXlate[p[2]] << 16));
                                        LL32(grHOSTDATA[2], pulXlate[p[2]] >> 16);
                                        break;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
            }
                }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x * 3;
                lLeadIn = (DWORD)pBits & 3;
                pBits -= lLeadIn;
                n = (sizl.cx * 3 + lLeadIn + 3) >> 2;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 3, lLeadIn, ptlDest.x * 3)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all data in 32-bit. We don't have to worry about crossing any
                // boundaries, since within NT everything is DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost24
 *
 * This routine performs a DeviceToHost for either monochrome or 24-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost24(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;
                BYTE  pixels[12];

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 3;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a leftMask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                pSrc += 6;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a rightMask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[4] = LLDR_SZ(grHOSTDATA[0]);
                                *(DWORD *)&pixels[8] = LLDR_SZ(grHOSTDATA[0]);
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #else
                                *(DWORD *)&pixels[0] = pSrc[0];
                                *(DWORD *)&pixels[4] = pSrc[1];
                                *(DWORD *)&pixels[8] = pSrc[2];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x80;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x40;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x20;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x10;
                                *(DWORD *)&pixels[0] = pSrc[3];
                                *(DWORD *)&pixels[4] = pSrc[4];
                                *(DWORD *)&pixels[8] = pSrc[5];
                                if ( (*(DWORD *)&pixels[0] & 0x00FFFFFF) == fgColor )
                                        data |= 0x08;
                                if ( (*(DWORD *)&pixels[3] & 0x00FFFFFF) == fgColor )
                                        data |= 0x04;
                                if ( (*(DWORD *)&pixels[6] & 0x00FFFFFF) == fgColor )
                                        data |= 0x02;
                                if ( (*(DWORD *)&pixels[9] & 0x00FFFFFF) == fgColor )
                                        data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_24BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                DWORD data;

                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                pBits += prclTrg->left * 3;
                data = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 3 + ptlSrc.y * ppdev->lDeltaScreen];
                *(WORD *)&pBits[0] = (WORD)data;
                *(BYTE *)&pBits[2] = (BYTE)(data >> 16);
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = ((sizl.cx * 3 + 3) >> 2) & 1;
                #endif
                pBits += prclTrg->left * 3;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // First, we get pixels in chunks of 4 so the 32-bit HOSTDATA is
                        // happy and we are still in phase.
                        for (i = sizl.cx; i >= 4; i -= 4)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Then, we have to do the remaining pixel(s).
                        switch (i)
                        {
                                case 1:
                                        i = LLDR_SZ(grHOSTDATA[0]);
                                        ((WORD *)p)[0] = (WORD)i;
                                        ((BYTE *)p)[2] = (BYTE)(i >> 16);
                                        break;

                                case 2:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(WORD *)p = (WORD)LLDR_SZ(grHOSTDATA[0]);
                                        break;

                                case 3:
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *p++ = LLDR_SZ(grHOSTDATA[0]);
                                        *(BYTE *)p = (BYTE)LLDR_SZ(grHOSTDATA[0]);
                                        break;
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 3);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}

/*****************************************************************************\
 *                                                                                                                                                       *
 *                                                                 3 2 - B P P                                                           *
 *                                                                                                                                                       *
\*****************************************************************************/

/*****************************************************************************\
 * DoHost32ToDevice
 *
 * This routine performs a HostToScreen or HostToDevice blit. The host data
 * can be either monochrome, 4-bpp, or 32-bpp. Color translation is only
 * supported for monochrome and 4-bpp modes.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoHost32ToDevice(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlDest, ptlSrc;
        SIZEL  sizl;
        PPDEV  ppdev;
        PBYTE  pBits;
        LONG   lDelta, i, n, lLeadIn, lExtra, i1;
        ULONG  *pulXlate;
        FLONG  flXlate;

        // Calculate te source offset.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;

        // Determine the destination type and calculate the destination offset.
        if (psoTrg->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
                ptlDest.x = prclTrg->left + pdsurf->ptl.x;
                ptlDest.y = prclTrg->top + pdsurf->ptl.y;
                ppdev = pdsurf->ppdev;
        }
        else
        {
                ptlDest.x = prclTrg->left;
                ptlDest.y = prclTrg->top;
                ppdev = (PPDEV) psoTrg->dhpdev;
        }

        // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

        // Get the source variables and ofFset into source bits.
        lDelta = psoSrc->lDelta;
        pBits = (PBYTE)psoSrc->pvScan0 + (ptlSrc.y * lDelta);

        /*      -----------------------------------------------------------------------
                Test for monochrome source.
        */
        if (psoSrc->iBitmapFormat == BMF_1BPP)
        {
                ULONG  bgColor, fgColor;
#if SWAT7
                SIZEL  sizlTotal;
#endif

        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }


                // Set background and foreground colors.
                if (pulXlate == NULL)
                {
                        bgColor = 0x00000000;
                        fgColor = 0xFFFFFFFF;
                }
                else
                {
                        bgColor = pulXlate[0];
                        fgColor = pulXlate[1];
                }

                //
                // Special case: when we are expanding monochrome sources and we
                // already have a colored brush, we must make sure the monochrome color
                // translation can be achived by setting the saturation bit (expanding
                // 0's to 0 and 1's to 1). If the monochrome source also requires color
                // translation, we simply punt this blit back to GDI.
                //
                if (ulDRAWBLTDEF & 0x00040000)
                {
                        if ( (bgColor == 0x00000000) &&
                                 ((fgColor & 0x00FFFFFF) == 0x00FFFFFF) )
                        {
                                // Enable saturation for source (OP1).
                                ulDRAWBLTDEF |= 0x00008000;
                        }
                        #if SOLID_CACHE
                        else if ( ((ulDRAWBLTDEF & 0x000F0000) == 0x00070000) &&
                                          ppdev->Bcache )
                        {
                                CacheSolid(ppdev);
                                ulDRAWBLTDEF ^= (0x00070000 ^ 0x00090000);
                REQUIRE(4);
                                LL_BGCOLOR(bgColor, 2);
                                LL_FGCOLOR(fgColor, 2);
                        }
                        #endif
                        else
                        {
                                // Punt this call to the GDI.
                                return(FALSE);
                        }
                }
                else
                {
                        REQUIRE(4);
                        LL_BGCOLOR(bgColor, 2);
                        LL_FGCOLOR(fgColor, 2);
                }

                REQUIRE(9);
#if SWAT7
                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);

                sizlTotal = sizl;
                while (sizlTotal.cx)
                {
                        sizl.cx = min(sizlTotal.cx, 864);
                        sizl.cy = sizlTotal.cy;
#endif
                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we must setup the source phase.
                lLeadIn = ptlSrc.x & 31;
                pBits += (ptlSrc.x >> 3) & ~3;
                n = (sizl.cx + lLeadIn + 31) >> 5;

#if !SWAT7
        //
        // Chip bug. Laguna locks with more than 14 dwords HOSTDATA
        //
        if (n > 28) // 14 qwords = 28 dwords
        {
            return FALSE;
        }

                // Setup the Laguna registers for the blit. We also set the bit swizzle
                // bit in the grCONTROL register.
                ppdev->grCONTROL |= SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10600000, 2);
#endif

                // Start the blit.
// added REQUIRE above
//              REQUIRE(7);
                LL_OP1_MONO(lLeadIn, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // Copy all the bits to the screen, 32-bits at a time. We don't have to
                // worry about crossing any boundary since NT is always DWORD aligned.
                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, n);
                        pBits += lDelta;
                }
#if SWAT7
                sizlTotal.cx -= sizl.cx;
                ptlSrc.x += sizl.cx;
                ptlDest.x += sizl.cx;

                // Reload pBits.
                pBits = (PBYTE) psoSrc->pvScan0 + (ptlSrc.y * lDelta);
                }
#endif

                // Disable the swizzle bit in the grCONTROL register.
                ppdev->grCONTROL = ppdev->grCONTROL & ~SWIZ_CNTL;
                LL16(grCONTROL, ppdev->grCONTROL);
        }

        /*      -----------------------------------------------------------------------
                Test for 4-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_4BPP)
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // Calculate the source parameters.
                pBits += ptlSrc.x >> 1;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                // If there is no translation table, use the default translation table.
                if (pulXlate == NULL)
                {
                        pulXlate = ulXlate;
                }

                // Now we are ready to copy all the pixels to the hardware.
                while (sizl.cy--)
                {
                        BYTE  *p = pBits;

                        // First, we must align the source to a BYTE boundary.
                        if (ptlSrc.x & 1)
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] & 0x0F]);
                                        LL32(grHOSTDATA[1], pulXlate[p[1] >> 4]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p & 0x0F]);
                                }
                        }
                        else
                        {
                                // We convert 2 pixels at a time to create two 32-bit values
                                // to write to the hardware.
                                for (i = sizl.cx; i >= 2; i -= 2)
                                {
                                        REQUIRE(2);
                                        LL32(grHOSTDATA[0], pulXlate[p[0] >> 4]);
                                        LL32(grHOSTDATA[1], pulXlate[p[0] & 0x0F]);
                                        p++;
                                }

                                // Now, write any remaining pixel.
                                if (i)
                                {
                                        REQUIRE(1);
                                        LL32(grHOSTDATA[0], pulXlate[*p >> 4]);
                                }
                        }

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
        }

        /*      -----------------------------------------------------------------------
                Test for 8-bpp source.
        */
        else if (psoSrc->iBitmapFormat == BMF_8BPP)
        {

        //
        // Attempt to load the translation table into the chip.
        // After this call:
        //   pulXlate == NULL if there is no color translation is required.
        //   pulXlate == translation table if color translation is required.
        //   UseHWxlate == FALSE if the hardware will do the xlate for us.
        //   UseHWxlate == TRUE if we must do the translation in software.
        //
                #if COLOR_TRANSLATE
        ULONG UseHWxlate = bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc,
                                                                                        pxlo, (BYTE)(ulDRAWBLTDEF&0xCC));
                #else
                if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
                {
                        pulXlate = NULL;
                }
                else if (pxlo->flXlate & XO_TABLE)
                {
                        pulXlate = pxlo->pulXlate;
                }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }
                #endif

        // A translation table is required.
        // "Well, DUH!" you might say, but I've seen it missing before...
        if (!pulXlate)
        {
            DISPDBG((0, "\n\nHost32ToDevice: !!! WARNING !!! 8BPP source "
            "bitmap does not have a translation table.  Punting!\n\n"));
            return FALSE;
        }

#if COLOR_TRANSLATE
        //
        // NVH:  5465 Color XLATE bug!!!
        // Color translation is broken on the 5465 in 16, 24 and 32 bpp.
        //
        if (UseHWxlate)
        {
            DWORD phase = ( ((DWORD)(pBits + ptlSrc.x)) & 3);
            if (XLATE_IS_BROKEN(sizl.cx, 4, phase))
                UseHWxlate = FALSE; // force SW translation.
        }

        if (UseHWxlate)
        {
            // Use Hardware color translation.

             DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting HW color translation on 8bpp Host to 32bpp Screen.\n"));

                // Calculate the source parameters. We are going to DWORD adjust the
                // source, so we also set the source phase.
                pBits += ptlSrc.x;               // Start of source data on the host.
            lLeadIn = (DWORD)pBits & 3;      // Source phase.
                pBits -= lLeadIn;                // Backup to DWORD boundry.
                n = (sizl.cx + lLeadIn + 3) >> 2;// Number of HOSTDATA per scanline.

                // Start the blit.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
                LL_OP1_MONO(lLeadIn, 0);
                    LL_OP0(ptlDest.x, ptlDest.y);
            LL_BLTEXT_XLATE(8, sizl.cx, sizl.cy); // HW xlate.

                        while (sizl.cy--)
                        {
                                // Copy all data in 32-bit. We don't have to worry about
                                // crossing any boundaries, since within NT everything is DWORD
                                // aligned.
                                WRITE_STRING(pBits, n);
                                pBits += lDelta;
                        }

        }
        else
#endif
        {
            //
            // Use SW color translation.
            //
            DISPDBG((COPYBITS_DBG_LEVEL, "Host32ToDevice: "
            "Attempting SW color translation on 8bpp Host to 32bpp Screen.\n"));

            // To do 8bpp host to 32bpp screen we must have a translation table.
            ASSERTMSG(pulXlate,
                "Host32ToDevice: No translation table for color translation.\n");

                // Calculate the source parameters.
                pBits += ptlSrc.x;   // Start of source data on the host.

            #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
            {
                if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
                {
                    // We have a problem with the HOSTDATA TABLE.
                    // Punt till we can figure it out.
                    return FALSE;
                }
                        lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
            }
            else
            {
                lExtra = 0;
                        }
            #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        BYTE *p = pBits;

                        // Copy the pixels.
                        for (i = sizl.cx; i > 0; i--)
                        {
                                REQUIRE(1);
                                LL32(grHOSTDATA[0], pulXlate[*p]);
                                p++;
                        }

                #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
                #endif

                        // Next line.
                        pBits += lDelta;
                }
        }
        }

        /*      -----------------------------------------------------------------------
                Source is in same color depth as screen.
        */
        else
        {
        // Get the pointer to the translation table.
        flXlate = pxlo ? pxlo->flXlate : XO_TRIVIAL;
        if (flXlate & XO_TRIVIAL)
        {
                pulXlate = NULL;
        }
        else if (flXlate & XO_TABLE)
        {
                pulXlate = pxlo->pulXlate;
        }
        else if (pxlo->iSrcType == PAL_INDEXED)
        {
          pulXlate = XLATEOBJ_piVector(pxlo);
        }
        else
        {
            // Some kind of translation we don't handle
            return FALSE;
        }

                // If we have a translation table, punt it.
                if ( pulXlate || (flXlate & 0x10) )
                {
                        return(FALSE);
                }

                // Calculate the source parameters.
                pBits += ptlSrc.x * 4;

        #if !DRIVER_5465
                // Get the number of extra DWORDS per line for the HOSTDATA hardware
                // bug.
            if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE.
                // Punt till we can figure it out.
                return FALSE;
            }
                lExtra = ExtraDwordTable[MAKE_HD_INDEX(sizl.cx * 4, 0, ptlDest.x * 4)];
        }
        else
            lExtra = 0;
        #endif

                // Setup the Laguna registers.
                REQUIRE(9);
                LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);

                // Start the blit.
                LL_OP1_MONO(0, 0);
                LL_OP0(ptlDest.x, ptlDest.y);
                LL_BLTEXT(sizl.cx, sizl.cy);

                while (sizl.cy--)
                {
                        WRITE_STRING(pBits, sizl.cx);

            #if !DRIVER_5465
                        // Now, write the extra DWORDS.
                        REQUIRE(lExtra);
                        for (i = 0; i < lExtra; i++)
                        {
                                LL32(grHOSTDATA[0], 0);
                        }
            #endif

                        // Next line.
                        pBits += lDelta;
                }
   }
   return(TRUE);
}

/*****************************************************************************\
 * DoDeviceToHost32
 *
 * This routine performs a DeviceToHost for either monochrome or 32-bpp
 * destinations.
 *
 * On entry:    psoTrg                  Pointer to target surface object.
 *                              psoSrc                  Pointer to source surface object.
 *                              pxlo                    Pointer to translation object.
 *                              prclTrg                 Destination rectangle.
 *                              pptlSrc                 Source offset.
 *                              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                                                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToHost32(
        SURFOBJ  *psoTrg,
        SURFOBJ  *psoSrc,
        XLATEOBJ *pxlo,
        RECTL    *prclTrg,
        POINTL   *pptlSrc,
        ULONG    ulDRAWBLTDEF
)
{
        POINTL ptlSrc;
        PPDEV  ppdev;
        SIZEL  sizl;
        PBYTE  pBits;
        #if !S2H_USE_ENGINE
        PBYTE  pjScreen;
        #endif
        LONG   lDelta;
        ULONG  i, n;

        // Determine the source type and calculate the offset.
        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
                PDSURF pdsurf = (PDSURF)psoSrc->dhsurf;
                ppdev = pdsurf->ppdev;
                ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
                ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        }
        else
        {
                ppdev = (PPDEV)psoSrc->dhpdev;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;
        }

        // Calculate the size of the blit.
        sizl.cx = prclTrg->right - prclTrg->left;
        sizl.cy = prclTrg->bottom - prclTrg->top;

        // Calculate the destination variables.
        lDelta = psoTrg->lDelta;
        pBits = (PBYTE)psoTrg->pvScan0 + (prclTrg->top * lDelta);

        #if S2H_USE_ENGINE
        // Setup the Laguna registers.
        REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x20100000, 0);
        LL_OP0(0, 0);
        #else
        // Calculate the screen address.
        pjScreen = ppdev->pjScreen + ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen;

        // Wait for the hardware to become idle.
        while (LLDR_SZ(grSTATUS) != 0) ;
        #endif

        // Test for a monochrome destination.
        if (psoTrg->iBitmapFormat == BMF_1BPP)
        {
                BYTE  data, leftMask, rightMask;
                ULONG fgColor;
                DWORD *pulXlate;
                LONG  leftCount, rightCount, leftSkip;

                // Calculate the monochrome masks.
                pBits += prclTrg->left >> 3;
                leftSkip = prclTrg->left & 7;
                leftCount = (8 - leftSkip) & 7;
                leftMask = 0xFF >> leftSkip;
                rightCount = prclTrg->right & 7;
                rightMask = 0xFF << (8 - rightCount);

                // If we only have pixels in one byte, we combine rightMask with
                // leftMask and set the routine to skip everything but the rightMask.
                if (leftCount > sizl.cx)
                {
                        rightMask &= leftMask;
                        leftMask = 0xFF;
                        n = 0;
                }
                else
                {
                        n = (sizl.cx - leftCount) >> 3;
                }

                // Get the foreground color from the translation table.
                pulXlate = XLATEOBJ_piVector(pxlo);
                fgColor = pulXlate ? *pulXlate : 0;

                #if S2H_USE_ENGINE
                // Start the blit.
                LL_OP1(ptlSrc.x - leftSkip, ptlSrc.y);
                LL_BLTEXT(sizl.cx + leftSkip, sizl.cy);
                #else
                pjScreen -= leftSkip * 4;
                #endif

                while (sizl.cy--)
                {
                        PBYTE pDest = pBits;
                        #if !S2H_USE_ENGINE
                        DWORD *pSrc = (DWORD *)pjScreen;
                        #endif

                        // If we have a left mask specified, we get the pixels and store
                        // them in the destination.
                        if (leftMask != 0xFF)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = (*pDest & ~leftMask) | (data & leftMask);
                        }

                        // Translate all pixels that don't require masking.
                        for (i = 0; i < n; i++)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                pSrc += 8;
                                #endif
                                *pDest++ = data;
                        }

                        // If we have a right mask specified, we get the pixels and store
                        // them in the destination.
                        if (rightMask != 0x00)
                        {
                                data = 0;
                                #if S2H_USE_ENGINE
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x80;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x40;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x20;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x10;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x08;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x04;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x02;
                                if (LLDR_SZ(grHOSTDATA[0]) == fgColor) data |= 0x01;
                                #else
                                if (pSrc[0] == fgColor) data |= 0x80;
                                if (pSrc[1] == fgColor) data |= 0x40;
                                if (pSrc[2] == fgColor) data |= 0x20;
                                if (pSrc[3] == fgColor) data |= 0x10;
                                if (pSrc[4] == fgColor) data |= 0x08;
                                if (pSrc[5] == fgColor) data |= 0x04;
                                if (pSrc[6] == fgColor) data |= 0x02;
                                if (pSrc[7] == fgColor) data |= 0x01;
                                #endif
                                *pDest = (*pDest & ~rightMask) | (data & rightMask);
                        }

                        // Next line.
                        #if !S2H_USE_ENGINE
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }

        // We only support destination bitmaps with the same color depth and we
        // do not support any color translation.
        else if ( (psoTrg->iBitmapFormat != BMF_32BPP) ||
                          (pxlo && !(pxlo->flXlate & XO_TRIVIAL)) )
        {
                return(FALSE);
        }

        /*
                If the GetPixel routine is being called, we get here with both cx and
                cy set to 1 and the ROP to 0xCC (source copy). In this special case we
                read the pixel directly from memory. Of course, we must be sure the
                blit engine is finished working since it may still update the very
                pixel we are going to read! We could use the hardware for this, but it
                seems there is a HARDWARE BUG that doesn't seem to like the 1-pixel
                ScreenToHost very much.
        */
        #if S2H_USE_ENGINE
        else if ( (sizl.cx == 1) && (sizl.cy == 1) && (ulDRAWBLTDEF == 0x000000CC) )
        {
                // Wait for the hardware to become idle.
                while (LLDR_SZ(grSTATUS) != 0) ;

                // Get the pixel from screen.
                *(DWORD *)pBits[prclTrg->left] = *(DWORD *)
                        &ppdev->pjScreen[ptlSrc.x * 4 + ptlSrc.y * ppdev->lDeltaScreen];
        }
        #endif

        else
        {
                #if S2H_USE_ENGINE
                // The hardware requires us to get QWORDS.
                BOOL fExtra = sizl.cx & 1;
                #endif
                pBits += prclTrg->left * 4;

                #if S2H_USE_ENGINE
                // Start the bit.
                LL_OP1(ptlSrc.x, ptlSrc.y);
                LL_BLTEXT(sizl.cx, sizl.cy);
                #endif

                while (sizl.cy--)
                {
                        #if S2H_USE_ENGINE
                        DWORD *p = (DWORD *)pBits;

                        // Copy all pixels from screen to memory.
                        for (i = sizl.cx; i >= 1; i -= 1)
                        {
                                *p++ = LLDR_SZ(grHOSTDATA[0]);
                        }

                        // Get the extra pixel required for QWORD alignment.
                        if (fExtra)
                        {
                                LLDR_SZ(grHOSTDATA[0]);
                        }
                        #else
                        // Copy all pixels from screen to memory.
                        memcpy(pBits, pjScreen, sizl.cx * 4);

                        // Next line.
                        pjScreen += ppdev->lDeltaScreen;
                        #endif
                        pBits += lDelta;
                }
        }
        return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\ddblt.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddblt.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw BLT components
*           for the Laguna NT driver.
*
* MODULES:
*           WINNT                   WIN95
*             DdGetBltStatus()        GetBltStatus32()
*             SetGamma()
*             DrvStretch64()          DrvStretch64()
*             DrvStretch62()          DrvStretch62()
*             DdBlt()                 Blt32()
*             DupColor()              DupColor()
*             EnoughFifoForBlt()      EnoughFifoForBlt()
*                                     RGBResizeBOF64()
*                                     RGB16ShrinkBOF64()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/ddraw/src/ddblt.c  $
*
*    Rev 1.25   Feb 16 1998 16:20:02   frido
* Fixed a NT 4.0 compilation bug (lpData is called lpGbl).
*
*    Rev 1.24   14 Jan 1998 06:18:58   eleland
*
* support for display list page-flipping: calls to UpdateFlipStatus are
* thru pointer to function pfnUpdateFlipStatus
*
*    Rev 1.23   07 Jan 1998 17:45:30   xcong
* Fix the change for WIN95 which breaks NT in DUP_COLOR macro.
*
*    Rev 1.22   06 Jan 1998 14:31:28   xcong
* Change all the macros to use lpDDHALData instead of pDriverData.
*
*    Rev 1.21   06 Jan 1998 11:44:42   xcong
* Change pDriverData into local lpDDHALData for multi-monitor support.
*
*    Rev 1.20   03 Oct 1997 14:46:50   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.19   01 Oct 1997 17:44:24   eleland
* added check in blt32() to detect blts to host texture surfaces and
* punt those blts back to the ddraw HEL
*
*    Rev 1.18   30 Jul 1997 20:56:22   RANDYS
*
* Added code to check for zero extent blts
*
*    Rev 1.17   18 Jul 1997 10:23:34   RUSSL
* Modified StretchColor to use function ptr to blt routines rather than
* directly program registers.  This is for compatiblity with display lists
*
*    Rev 1.16   14 Jul 1997 14:49:32   RUSSL
* Modified BltInit's initialization of pfnDrvStrBlt for Win95
*
*    Rev 1.15   08 Jul 1997 11:15:20   RUSSL
* Removed an ASSERT that is no longer valid in StretchColor
*
*    Rev 1.14   07 Jul 1997 10:57:14   dzenz
* Added check of DRVSEM_DISPLAY_LIST semaphore to ascertain if
* qmRequestDirectAccess needs to be called.
*
*    Rev 1.13   08 Apr 1997 12:17:06   einkauf
* WINNT_VER40 affected only: add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.12   03 Apr 1997 15:24:48   RUSSL
* Added pfnDrvDstMBlt global var
* Added initializing pfnDrvDstMBlt in BltInit
* Modified DDBLT_DEPTHFILL case in Blt32 to blt based on surface colordepth
*   it was clearing 16bit zbuffers in 32bit modes with pixel blts so would
*   wipe out everything to the right of the actual zbuffer
*   Fixes at least PDRs #9152, 9150 & 8789 (maybe others as well)
*
*    Rev 1.11   01 Apr 1997 09:15:24   RUSSL
* Added calls to SyncWithQueueManager in GetBltStatus32
*
*    Rev 1.10   26 Mar 1997 14:08:22   RUSSL
* Added pfnDrvSrcMBlt global var
* Added initializing pfnDrvSrcMBlt in BltInit
* Moved sync with queue manager in Blt32 in front of updateFlipStatus since
*   updateFlipStatus may access the hardware
*
*    Rev 1.9   18 Mar 1997 07:50:24   bennyn
* Resolved NT compiling error by #ifdef queue manager sync call
*
*    Rev 1.8   12 Mar 1997 15:02:02   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:51:38   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   03 Mar 1997 10:32:34   eleland
* modified queue manager sync call to check 2d display list
* flag; removed USE_QUEUE_MANAGER #ifdef
*
*    Rev 1.5   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Call qmRequesetDirectAcces() if 3D is busy (Disabled)
*
*    Rev 1.4   21 Jan 1997 14:45:42   RUSSL
* Added include of ddinline.h
*
*    Rev 1.3   15 Jan 1997 10:45:20   RUSSL
* Made Win95 function ptr vars global
* Moved following inline functions to bltP.h: DupZFill, DupColor &
*   EnoughFifoForBlt
*
*    Rev 1.2   13 Dec 1996 15:28:32   CRAIGN
* Added a Frido YUV move fix.
*
*    Rev 1.1   25 Nov 1996 16:16:10   bennyn
* Fixed misc compiling errors for NT
*
*    Rev 1.0   25 Nov 1996 14:43:02   RUSSL
* Initial revision.
*
*    Rev 1.6   25 Nov 1996 14:40:02   RUSSL
* Yet another merge of winNT & win95 code
*
*    Rev 1.5   25 Nov 1996 11:39:02   RUSSL
* Added TransparentStretch function
*
*    Rev 1.4   18 Nov 1996 16:16:18   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.3   12 Nov 1996 09:42:02   CRAIGN
* Frido 1112s2 release... fixes TDDRAW case 26.
* Changed transparency for DDBLT_KEYDESTOVERRIDE to "not equal."
*
*    Rev 1.2   11 Nov 1996 12:36:48   CRAIGN
* Frido 1112 release - added software color key stretch.
*
*    Rev 1.1   06 Nov 1996 12:28:42   CRAIGN
* Frido 1106 - added check for rectangle movement.
*
*    Rev 1.0   01 Nov 1996 13:09:30   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.9   01 Nov 1996 09:23:24   BENNYN
* Initial copy of shareable DD blt code
*
* COMBINED WINNT & WIN95 VERSIONS OF BLT CODE
*
*    Rev 1.17   25 Oct 1996 11:55:54   RUSSL
* Forgot to remove the undef RDRAM_8BIT
*
*    Rev 1.16   25 Oct 1996 11:50:16   RUSSL
* Added use of function pointers for all the short blt functions (like
* DrvDstBlt, DrvSrcBlt, etc.).  Moved the short blt functions to a
* separate file (blt_dir.c).  Modified DrvStretch64, DrvStretch62,
* RGBResizeBOF64 & RGB16ShrinkBOF64 to use the blt function pointers
* rather than directly call one of the short blt functions or write
* directly to the registers.  This enables the short blt functions to
* be written as display lists rather than directly writing to the
* registers (in fact, that's whats in blt_dl.c)
*
* Added BltInit function to initialize the function pointers.  BltInit
* needs to be called by buildHALInfo32.
*
*    Rev 1.15   21 Oct 1996 11:56:08   RUSSL
* Added RGB16ShrinkBOF64 to handle 16bpp shrink blts on the 5464
* Now RGBResizeBOF64 only handles 8bpp stretches, 8bpp shrinks and
*   16bpp stretches on the 5464
* Added QFREE checking before blts in both RGB???BOF64 functions
*
*    Rev 1.14   16 Oct 1996 16:10:40   RUSSL
* Added RGBResizeBOF64 to handle resize blts on 5464
* 8bpp stretches, 8bpp shrinks and 16bpp stretches ain't perfect but
*   hopefully they're acceptable
* 16bpp shrinks are still broken
*
*    Rev 1.13   07 Oct 1996 09:03:04   RUSSL
* Modified DDRAW_COMPAT_xx conditionally compiled stuff
*
*    Rev 1.12   04 Oct 1996 11:39:10   KENTL
* Fixed PDR#6799 - playing two AVI's result in first window replicated in
* second. Changed the way Blt32 does an x-coordinate computation.
*
*    Rev 1.11   04 Oct 1996 10:46:50   KENTL
* Added fix for 32bpp video bug: we were trying to do stretches in 32bpp,
* which a) is not supported in HW and b) was being interpreted as 16bpp
* which cause really lousy things to happen on the screen.
*
*    Rev 1.9   04 Sep 1996 17:32:06   MARTINB
* Corrected shrink by 8 bug in odd sized mpegs.
* Corrected multiple mpeg sources corrupting working stroage.
*
*    Rev 1.8   22 Aug 1996 10:37:14   MARTINB
* Corrected a number of QFREE check constants for the strech62 routines that
* were causing sound breakup on moving / resizing a video window.
*
*    Rev 1.7   14 Aug 1996 16:53:20   MARTINB
* Yet another last minute fix to the last minute fix. This one fixes
* the banding in 422 video caused by doing the blt twice. The second time
* incorrectly !!
*
*    Rev 1.6   13 Aug 1996 13:25:02   MARTINB
* Moved shrink rejection for 565/8bit formats to correct place in blt32 logic
*
*    Rev 1.5   13 Aug 1996 08:31:12   MARTINB
* Added stretch routines for CL-GD5464 support
* renamed previous stretch logic to DrvStretch62.
*
*    Rev 1.4   23 Jul 1996 11:20:04   KENTL
* Merged in Jeff Orts D3D integration changes.
*   * Created DupZFill()
*   * Added code to do Z-Fill blits.
*
*    Rev 1.3   19 Jul 1996 16:24:38   CRAIGN
* Removed two int 3s that I left in the code.
*
*    Rev 1.2   19 Jul 1996 09:31:20   CRAIGN
* Added workaround for Stretch Bug o' Death.
* Instead of doing SRAM blts to make sure that PTAG is set/reset,
* use a destcopy blt to PTAGFooPixel.  This x/y coordinate is set by the
* display driver to be one pixel below the bottom of the screen (where the
* scratch buffer lives).
*
*    Rev 1.1   15 Jul 1996 16:58:40   RUSSL
* Added support for DirectDraw 3.0
*
*    Rev 1.0   26 Jun 1996 11:05:06   RUSSL
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

#include "flip.h"
#include "surface.h"
#include "blt.h"
#include "palette.h"
#include "qmgr.h"
#include "bltP.h"
#include "ddinline.h"
#include "ddshared.h"
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

/*----------------------------- DEFINES -----------------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

// DBGBREAKPOINT();
#define AFPRINTF(n)

#define DBGLVL        1
#define DBGLVL1       1
#define DBGLVL2       1      // DrvSrcBlt & SrvDstBlt
#define DBGLVL3       1      // DrvStretchBlt

#define LGDEVID              ppdev->dwLgDevID
#define OFFSCR_YUV_VAR       ppdev->offscr_YUV
#define MEMCMP(A,B)          memcmp(&ppdev->offscr_YUV.SrcRect, (A),(B))

#define DRAW_ENGINE_BUSY     DrawEngineBusy(lpDDHALData)
#define ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(DRIVERDATA* lpDDHALData)
#define SET_GAMMA            SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)  vUpdateFlipStatus(&ppdev->flipRecord, (arg))

#define DRVSTRETCH64      DrvStretch64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DRVSTRETCH62      DrvStretch62(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUP_COLOR         DupColor(PDEV* ppdev,
#define RGB_RESIZEBOF64   RGBResizeBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define RGB_16SHRINKBOF64 RGB16ShrinkBOF64(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define DUPZFILL          DupZFill(PDEV* ppdev,

#define CALL_ENOUGH_FIFO_FOR_BLT  EnoughFifoForBlt(lpDDHALData)

#define CALL_DELAY_9BIT_BLT(arg)          ppdev->pfnDelay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)   ppdev->pfnEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)  ppdev->pfnMEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)         ppdev->pfnDrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)        ppdev->pfnDrvDstMBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)     ppdev->pfnDrvSrcBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)               ppdev->pfnDrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLT(A)              ppdev->pfnDrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTX(A)             ppdev->pfnDrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_MBLTY(A)             ppdev->pfnDrvStrMBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTY(A)              ppdev->pfnDrvStrBltY(ppdev,lpDDHALData, (A))
#define CALL_DRV_STR_BLTX(A)              ppdev->pfnDrvStrBltX(ppdev,lpDDHALData, (A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(ppdev,lpDDHALData, (arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(ppdev,lpDDHALData, (A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(ppdev,lpDDHALData, (A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(ppdev,lpDDHALData, (A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(ppdev,lpDDHALData, (A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(ppdev, (A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)    RGBResizeBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)  RGB16ShrinkBOF64(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                       DupZFill(ppdev, (A),(B))

#define STRETCHCOLOR                                StretchColor(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(PDEV* ppdev, DRIVERDATA* lpDDHALData,
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(ppdev,lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))

#else   // ----- #elseif WINNT_VER40-----

#define TRACE_STRETCH 1
#define TRACE_ALL     1

#define LGDEVID                   lpDDHALData->dwLgVenDevID
#define OFFSCR_YUV_VAR            offscr_YUV
#define MEMCMP(A,B)               memcmp(&offscr_YUV.SrcRect, (A),(B))

#define ENOUGH_FIFO_FOR_BLT       EnoughFifoForBlt(lpDDHALData)
#define SET_GAMMA                 SetGamma(lpDDHALData)
#define UPDATE_FLIP_STATUS(arg)   updateFlipStatus((arg), lpDDHALData)

#define DRVSTRETCH64              DrvStretch64(
#define DRVSTRETCH62              DrvStretch62(
#define DUP_COLOR                 DupColor(
#define RGB_RESIZEBOF64           RGBResizeBOF64(
#define RGB_16SHRINKBOF64         RGB16ShrinkBOF64(
#define DUPZFILL                  DupZFill(

#define CALL_ENOUGH_FIFO_FOR_BLT              EnoughFifoForBlt(lpDDHALData)
#define CALL_DELAY_9BIT_BLT(arg)              pfnDelay9BitBlt(lpDDHALData,(arg))
#define CALL_EDGE_FILL_BLT(A,B,C,D,E,F)       pfnEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_MEDGE_FILL_BLT(A,B,C,D,E,F)      pfnMEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_DST_BLT(A,B,C,D)             pfnDrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_DST_MBLT(A,B,C,D)            pfnDrvDstMBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DRV_SRC_BLT(A,B,C,D,E,F)         pfnDrvSrcBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DRV_STR_BLT(A)                   pfnDrvStrBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLT(A)                  pfnDrvStrMBlt(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTX(A)                 pfnDrvStrMBltX(lpDDHALData,(A))
#define CALL_DRV_STR_MBLTY(A)                 pfnDrvStrMBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTY(A)                  pfnDrvStrBltY(lpDDHALData,(A))
#define CALL_DRV_STR_BLTX(A)                  pfnDrvStrBltX(lpDDHALData,(A))

#define CALL_DIR_DELAY_9BIT_BLT(arg)          DIR_Delay9BitBlt(lpDDHALData,(arg))
#define CALL_DIR_EDGE_FILL_BLT(A,B,C,D,E,F)   DIR_EdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_MEDGE_FILL_BLT(A,B,C,D,E,F)  DIR_MEdgeFillBlt(lpDDHALData,(A),(B),(C),(D),(E),(F))
#define CALL_DIR_DRV_DST_BLT(A,B,C,D)         DIR_DrvDstBlt(lpDDHALData,(A),(B),(C),(D))
#define CALL_DIR_DRV_STR_BLT(A)               DIR_DrvStrBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLT(A)              DIR_DrvStrMBlt(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTX(A)             DIR_DrvStrMBltX(lpDDHALData,(A))
#define CALL_DIR_DRV_STR_MBLTY(A)             DIR_DrvStrMBltY(lpDDHALData,(A))

#define CALL_DRVSTRETCH64(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DRVSTRETCH62(A,B,C,D,E,F,G,H,I,J,K,L)    DrvStretch62(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L))
#define CALL_DUP_COLOR(A)                             DupColor(lpDDHALData,(A))
#define CALL_RGB_RESIZEBOF64(A,B,C,D,E,F,G,H)         RGBResizeBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_RGB_16SHRINKBOF64(A,B,C,D,E,F,G,H)       RGB16ShrinkBOF64(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H))
#define CALL_DUPZFILL(A,B)                            DupZFill(lpDDHALData,(A),(B))

#define STRETCHCOLOR                                StretchColor(
#define CALL_STRETCHCOLOR(A,B,C,D,E,F,G,H,I)        StretchColor(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))
#define TRANSPARENTSTRETCH                          TransparentStretch(
#define CALL_TRANSPARENTSTRETCH(A,B,C,D,E,F,G,H,I)  TransparentStretch(lpDDHALData,(A),(B),(C),(D),(E),(F),(G),(H),(I))


#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

typedef short DDAX;
typedef struct {DDAX accum; DDAX maj; DDAX min;} AXIS;

#define EDGE_CLIP     // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define EDGE_CLIP_16  // Trim excess pixels from edges (>= 10%) in 8Bpp Mode
#define BOGUS_YUV  0x0081 // Top of palette below Windows reserved area
//#define BOGUS_8BIT

#define LOCK_HW_SEMAPHORE()    (lpDDHALData->DrvSemaphore |= DRVSEM_IN_USE)
#define UNLOCK_HW_SEMAPHORE()  (lpDDHALData->DrvSemaphore &= ~ DRVSEM_IN_USE)


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/
#ifdef WINNT_VER40
static __inline DWORD DUP_COLOR   DWORD dwColor );
#else
static __inline DWORD DUP_COLOR   LPGLOBALDATA lpDDHALData, DWORD dwColor );
#endif
static __inline BOOL ENOUGH_FIFO_FOR_BLT;

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/
static const WORD lncntl[] = {LN_8BIT, LN_RGB565, LN_24PACK, LN_24ARGB,};


// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40

ASSERTFILE("blt.c");
OFFSCR_YUV  offscr_YUV = {{ 0, 0, 0, 0}, FALSE};

PFN_DELAY9BLT    pfnDelay9BitBlt;
PFN_EDGEFILLBLT  pfnEdgeFillBlt;
PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
PFN_DRVDSTBLT    pfnDrvDstBlt;
PFN_DRVDSTMBLT   pfnDrvDstMBlt;
PFN_DRVSRCBLT    pfnDrvSrcBlt;
PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
PFN_DRVSTRBLT    pfnDrvStrBlt;
PFN_DRVSTRMBLT   pfnDrvStrMBlt;
PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
PFN_DRVSTRBLTY   pfnDrvStrBltY;
PFN_DRVSTRBLTX   pfnDrvStrBltX;

extern PFN_UPDATEFLIPSTATUS pfnUpdateFlipStatus;

#if ENABLE_CLIPPEDBLTS
PFN_CLIPPEDDRVDSTBLT  pfnClippedDrvDstBlt;
PFN_CLIPPEDDRVDSTMBLT pfnClippedDrvDstMBlt;
PFN_CLIPPEDDRVSRCBLT  pfnClippedDrvSrcBlt;
#endif

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

//***** SetGamma ********************************************************
// Use only for YUV 8BPP
//
#define LOWER_YUV       16
#define UPPER_YUV       240
#define LOWER_PALETTE   0
#define UPPER_PALETTE   255

void SetGamma(PDEV* ppdev, DRIVERDATA* lpDDHALData)
{
  int indx;
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;

  DISPDBG((DBGLVL, "DDraw - SetGamma\n"));

  for ( indx = LOWER_PALETTE ; indx <= UPPER_PALETTE ; indx++ )
  { // Initialise gamma palette

    int  value;
    value = ((indx - LOWER_YUV) * UPPER_PALETTE) / (UPPER_YUV - LOWER_YUV);
    if ( value < LOWER_PALETTE )
      value = LOWER_PALETTE;

    if ( value > UPPER_PALETTE )
      value = UPPER_PALETTE;

    LL8(grPalette_Write_Address, (BYTE)(indx));
    LL8(grPalette_Data, (BYTE)(value)); // Red
    LL8(grPalette_Data, (BYTE)(value)); // Grn
    LL8(grPalette_Data, (BYTE)(value)); // Blu
  };
} // SetGamma

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


/***************************************************************************
*
* FUNCTION:     RGBResizeBOF64
*
* DESCRIPTION:  Handles 8bpp RGB stretches, 8bpp RGB shrinks and
*               16bpp RGB stretches on the 5464
*
****************************************************************************/

#define SRAM_SIZE     128

void RGB_RESIZEBOF64
#ifndef WINNT_VER40
         LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;

  // setting nSRAMPixels to the number of pixels that fit in sram divided
  // by two gives better shrinks at 8bpp and doesn't lock up the chip on
  // stretches at 16bpp
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  bltr;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcxext;
  int   dstxext;
  int   srcx;
  int   xext;


  DD_LOG(("RGBResizeBOF64 - %d bpp %s in X\r\n", nBytesPixel,
          (cxDst < cxSrc) ? "shrink" : "stretch"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is an 8bpp shrink or stretch
  //     or its a 16bpp stretch
  ASSERT((1 == nBytesPixel) || (cxSrc <= cxDst));

  DBG_MESSAGE((" RGBResizeBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_MESSAGE(("                  Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  // initialize auto blt struct
  bltr.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  bltr.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  bltr.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));
  bltr.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),LOWORD(cyDst));

  bltr.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  bltr.SRCX           = cxSrc * nBytesPixel;

  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    bltr.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);

  bltr.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    bltr.LNCNTL.W |= LN_XSHRINK;
    bltr.LNCNTL.W &= ~LN_XINTP_EN;
    bltr.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    bltr.LNCNTL.W |= LN_YSHRINK;
    bltr.LNCNTL.W &= ~LN_YINTP_EN;
    bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  // Compute DDA terms.

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (DDAX)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  // write settings that don't vary over stripes to the chip
  CALL_DRV_STR_BLTY(&bltr);

  if (bltr.LNCNTL.W & LN_XSHRINK)
  {
    // 8bpp shrink in X
    accx = bltr.ACCUM_X;

    while (cxDst > 0)
    {
      // walk DDA to determine number of src & dst pixels to blt in
      // current stripe
      // computes error term (accx) for next stripe also
      srcxext = 0;
      dstxext = 0;
      for (;;)
      {
        // check for worst case srcxext larger than num pixels that
        // fit in sram
        if ((srcxext + bltr.SHRINKINC.pt.X + 1) > nSRAMPixels)
          break;

        accx += bltr.MIN_X;
        srcxext += bltr.SHRINKINC.pt.X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcxext++;
        }

        dstxext++;
        if (dstxext >= cxDst)
          break;
      }

      // adjust dst extent
      bltr.BLTEXT.pt.X = (USHORT)dstxext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // adjust dst extent remaining
      cxDst -= dstxext;

      // update auto blt struct settings
      // increment xDst & xSrc
      // store error term for next stripe
      bltr.OP0_opRDRAM.pt.X += (USHORT)dstxext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)srcxext;
      bltr.ACCUM_X          = accx;
    }
  }
  else
  {
    // stretch in X

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = bltr.ACCUM_X;
    srcx = xSrc;

    while (cxDst > xext)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&bltr);

      // increment xDst and decrement remaining dst extent
      xDst  += xext;
      cxDst -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        accx += bltr.MIN_X;
        if (0 > accx)
        {
          accx += bltr.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxDst)
    {
      // update auto blt struct settings
      bltr.OP0_opRDRAM.pt.X = (USHORT)xDst;
      bltr.OP1_opRDRAM.pt.X = (USHORT)srcx;
      bltr.ACCUM_X          = accx;
      bltr.BLTEXT.pt.X      = (USHORT)cxDst;

      // blt final stripe
      CALL_DRV_STR_BLTX(&bltr);
    }
  }
}

/***************************************************************************
*
* FUNCTION:     RGB16ShrinkBOF64
*
* DESCRIPTION:  Handles 16bpp RGB shrinks on the 5464
*
****************************************************************************/

#define ENABLE_INTERPOLATED_BLTS    1

void RGB_16SHRINKBOF64
#ifndef WINNT_VER40
        LPGLOBALDATA lpDDHALData,
#endif
         int xDst, int yDst, int cxDst, int cyDst,
         int xSrc, int ySrc, int cxSrc, int cySrc )
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;
  autoblt_regs  ScratchToDst;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   nSRAMext;
  int   cxTemp;
  int   xTemp;


  DD_LOG(("RGB16ResizeBOF64 - 16 bpp shrink in X\r\n"));
  DD_LOG(("dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifndef WINNT_VER40
  // Verify this is a 16bpp shrink!
  ASSERT(cxSrc > cxDst);
  ASSERT(nBytesPixel == 2);

  DBG_WARNING((" RGB16ShrinkBOF64 - Dst %08lXh,%08lXh  %08lX,%08lX",xDst,yDst,cxDst,cyDst));
  DBG_WARNING(("                    Src %08lXh,%08lXh  %08lX,%08lX",xSrc,ySrc,cxSrc,cySrc));
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  // THIS IS A SHRINK IN X!
  cxScratch = cxSrc & ~1;
  nSRAMext = 0x38;
  while (cxScratch > cxDst)
  {
    cxScratch >>= 1;
    nSRAMext >>= 1;
  }
  /* Check for zero extent blt */
  if (nSRAMext == 0)
    return;

  SrcToScratch.BLTEXT.DW      = MAKELONG(LOWORD(cxScratch),1);
  // Yes, the following line doesn't make any sense but using
  // half the dest x ext on a 16bpp rgb shrink to compute the
  // minor, major and initial accumulator terms appears to get
  // the hw to work correctly
  cxScratch /= 2;

  SrcToScratch.LNCNTL.W |= LN_XSHRINK;
#if ENABLE_INTERPOLATED_BLTS
  SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
#endif
  SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxScratch);

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
#if ENABLE_INTERPOLATED_BLTS
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
#endif
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyScratch);
  }

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;

  // Now that we have the major, minor and initial accumulator terms
  // computed, adjust dest x ext back to full width so we do the full
  // width of the blt below
  cxScratch *= 2;



  // initialize auto blt struct for scratch buffer to dst
  ScratchToDst.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  ScratchToDst.OP0_opRDRAM.DW = MAKELONG(LOWORD(xDst),LOWORD(yDst));
  ScratchToDst.OP1_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  ScratchToDst.BLTEXT.DW      = MAKELONG(LOWORD(cxDst),1);

  ScratchToDst.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  ScratchToDst.SRCX           = cxScratch * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    ScratchToDst.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  ScratchToDst.SHRINKINC.W = 0x0000;

  // THIS IS A STRETCH IN X!

  // THIS IS 1:1 IN Y

  // Compute DDA terms

  nDst[0] = cxDst;
  nDst[1] = cyDst;
  nSrc[0] = cxScratch;
  nSrc[1] = cyScratch;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (ScratchToDst.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  ScratchToDst.MAJ_X   = axis[0].maj;
  ScratchToDst.MIN_X   = axis[0].min;
  ScratchToDst.ACCUM_X = axis[0].accum;

  ScratchToDst.MAJ_Y   = axis[1].maj;
  ScratchToDst.MIN_Y   = axis[1].min;
  ScratchToDst.ACCUM_Y = axis[1].accum;


  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMext;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        // Even though the following line should be correct
        // the hw doesn't work correctly so we'll skip it
        // here and adjust srcx after the for loop
        //srcx += SrcToScratch.SHRINKINC.pt.X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
      // now adjust srcx with a bizarre equation that appears to get
      // the hw to work correctly
      srcx += ((nSRAMext / 2) * SrcToScratch.SHRINKINC.pt.X);
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // stretch in X, 1:1 in Y

    // set values for initial stripe
    xext = ((xDst + nSRAMPixels) & (~nSRAMMask)) - xDst;
    accx = ScratchToDst.ACCUM_X;
    srcx = xScratch;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&ScratchToDst);

    xTemp  = xDst;
    cxTemp = cxDst;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        ScratchToDst.ACCUM_X += ScratchToDst.MIN_X;
        if (0 > (short)ScratchToDst.ACCUM_X)
        {
          ScratchToDst.ACCUM_X += ScratchToDst.MAJ_X;
          srcx++;
        }
      }
      // set dst ext of current stripe
      xext = nSRAMPixels;
    }

    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      ScratchToDst.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      ScratchToDst.OP1_opRDRAM.pt.X = (USHORT)srcx;
      ScratchToDst.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&ScratchToDst);
    }
    // reset ACCUM_X for beginning of next scanline
    ScratchToDst.ACCUM_X = accx;

    // adjust dst ptr and dst extent
    ScratchToDst.OP0_opRDRAM.pt.Y++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdGetBltStatus (NT)
*                GetBltStatus32 (Win95)
*
* DESCRIPTION:   Doesn't currently really care what surface is specified,
*                just checks and goes.
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
  DRIVERDATA* lpDDHALData;
  PDEV*   ppdev;
  HRESULT ddRVal;

  DISPDBG((DBGLVL, "DDraw - DdGetBltStatus\n"));

  ppdev = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;

#else   // ----- #elseif WINNT_VER40 -----

DWORD __stdcall GetBltStatus32( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( lpGetBltStatus->lpDD);
  HRESULT ddRVal;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>


  DD_LOG(("GetBltStatus32 Entry\r\n"));

#ifndef WINNT_VER40
  SyncWithQueueManager(lpDDHALData);
#endif

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // DDGBS_CANBLT: can we add a blt?
  ddRVal = DD_OK;
  if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
  {
    // is a flip in progress?
#ifdef WINNT_VER40
    ddRVal = vUpdateFlipStatus(
        &ppdev->flipRecord,
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpData->fpVidMem,
        lpDDHALData);
#else
    ddRVal = pfnUpdateFlipStatus(
        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

     if (ddRVal == DD_OK)
     {
        // so there was no flip going on, is there room in the fifo
        // to add a blt?
        if (!CALL_ENOUGH_FIFO_FOR_BLT)
           ddRVal = DDERR_WASSTILLDRAWING;
        else
           ddRVal = DD_OK;
     };
  }
  else
  {
     // DDGBS_ISBLTDONE case: is a blt in progress?
    if (DRAW_ENGINE_BUSY)

       ddRVal = DDERR_WASSTILLDRAWING;
    else
       ddRVal = DD_OK;
  };

  lpGetBltStatus->ddRVal = ddRVal;

  DD_LOG(("GetBltStatus32 Exit\r\n"));

  return(DDHAL_DRIVER_HANDLED);

} // DDGetBltStatus or GetBltStatus32

/***************************************************************************
*
* FUNCTION:     DrvStretch64
*
* DESCRIPTION:
*
****************************************************************************/

void DRVSTRETCH64
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;

#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  DISPDBG((DBGLVL3, "DDraw - DrvStretch64 xD=%x, yD=%x, cxD=%x, cyD=%x, xS=%x, yS=%x, cxS=%x, cyS=%x, bpp=%x, t=%x, bo=%x, scn=%x\n",
           xDst, yDst, cxDst, cyDst,
           xSrc, ySrc, cxSrc, cySrc,
           nBytesPixel, SrcType, BaseOffset, OnScreen));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("DrvStretch64 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;
        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch64: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
     ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if (nBytesPixel == 2)
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if (cxDst > cxSrc)
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if (xDst & 3)   // This should be for LN_YUV422 only
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;   // save trim count for source clipping if required

          if ( cxFill > cxClip )
             cxFill = cxClip;  // check for no stretch left

           cxClip -= cxFill;  // reduce size
           cxDst  -= cxFill;  // reduce size
           xDst   += cxFill;  // force alignment to next even DWORD boundary

           CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV),
                              FALSE);
       }  // endif (xDst & 3)

       cxFill  = cxClip & 3;
       if (OnScreen && cxFill )
       {
          cxClip -= cxFill;   // force size to next smaller even DWORD count
          xFill   = xDst + cxClip;
          if ( cxClip >= cxSrc)
          {  // If shrink defer edge fill to later as there may be more
             CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
          }
       }  // endif ( cxFill )

       if ( (cxClip < cxSrc) )
       {  // Edge Clip on shrinks only ( add config flag check here )

          // extra pixels to discard above integer ratio
          int excess = (cxSrc / iratio) - cxClip;

#ifdef TRACE_STRETCH
         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, lpDDHALData->EdgeTrim));
#endif

          if ( excess && cxTrim )
          {  // These excess pixels are caused by our Dest alignment
             // problems on the Left edge
             if ( excess < (cxTrim * iratio) )
             {
                cxSrc  -= excess;
                xSrc   += excess;
                excess  = 0;
             }
             else
             {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
          }  // endif ( (cxClip < cxSrc) )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc  -= excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && (excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ))
         {  // if excess is less than % of frame trim edges
            int trim  = excess / 2; // half the excess of pixels
            xSrc     +=  trim;      // offset pixel pointer
            cxSrc    -= excess;     // all the excess in pixels

#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));
#endif
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
            }
         }  // endif ( iratio == 1 )
       }
       else
       { // Stretch adjustments
         if ( xSrc - BaseOffset )
         {  // if we are not starting from left edge of source image

            if ( cxTrim )
            {  // And we were forced to offset for left edge alignment

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));
#endif
               cxSrc -= cxTrim / iratio;
               xSrc  += cxTrim / iratio;
            }
         }
       }  // endif ( (cxClip < cxSrc) )

       // Global adjustments
       if ( xSrc & 1 )   // HW bug workaound for clipping
       {
          xSrc  += 1;    // Align to SRC DWORD Boundary
          cxSrc -= 1;    // Account for smaller size
       }
    }
    else
    {  // 8 Bit frame buffer.
       // Force alignment of output to QWORD ( it is documented as DWORD but broken)

       if ( cxDst >= (cxSrc*2) )
          iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
       else
          iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

       if ( xDst & 7 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 8 - (xDst & 7);

          if ( cxFill > cxClip )
             cxFill   = cxClip;  // check for no stretch left

          cxClip -= cxFill;  // reduce size
          cxDst  -= cxFill;  // reduce size
          xDst   += cxFill;  // force alignment to next even WORD boundary

          CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             0x00000000, FALSE);
       }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if (OnScreen && cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */

         if ( cxClip >= (cxSrc * 2))
         {  // If shrink defer edge fill to later as there may be more
            xFill = xDst + cxClip;
            CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                               0x00000000, FALSE);
         }
      }  // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;  // change pixel count to byte count

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;
         excess = ( cxSrc / iratio ) - cxClip; // extra pixels to discard
                                              // above integer ratio
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                 "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                 iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

         DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
                cxSrc  -= cxTrim * iratio;
                xSrc   += cxTrim * iratio;
                excess -= cxTrim * iratio;
             }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

         if ( excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100 ) )
         {  // if excess is less than specific % of frame trim edges
            int trim = excess / 2;  // half the excess as pixels
            xSrc +=  trim;          // offset pixel pointer
            cxSrc -= excess;        // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         } // endif (excess && ( excess <= (lpDDHALData->EdgeTrim * cxSrc)/100))

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is no zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;
               CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  0x00000000, FALSE);
            }
         }  // endif ( iratio == 1 )
      }  // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);  /* reduce size */
         xSrc = (xSrc + 3) & ~ 3;    /* Align to SRC DWORD Boundary */
      }
    }  // endif (nBytesPixel == 2)
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if (nBytesPixel == 1 && ((SrcType == LN_YUV422) || (SrcType == LN_RGB565))
     || ((nBytesPixel == 2) && (SrcType == LN_YUV422)))
  {
     CALL_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
    bltr.DRAWBLTDEF.DW = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W  |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W  |= LN_XSHRINK;
     bltr.LNCNTL.W  &= ~LN_XINTP_EN;   // Clear Average bit for ALL shrinks
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W |= LN_YSHRINK;
     bltr.LNCNTL.W &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
     if ( nBytesPixel == 1 )
        bltr.SRCX       = (USHORT)cxSrc;  // If mixed mode is *2 already
     else
        bltr.SRCX       = cxSrc * 2;
  }
  else
     bltr.SRCX       = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
       nDst[i] *= 4;
       nSrc[i] *= 4;
       nSrc[i] -= 3;

       kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    {  /* Shrink Terms */
       axis[i].maj =  (short)nDst[i];
       axis[i].min = - (nSrc[i] % nDst[i]);
       axis[i].accum = axis[i].maj - 1
                     - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    {  /* Stretch Terms */
       axis[i].maj =  kDst * nDst[i];
       axis[i].min = -kDst * nSrc[i];
       axis[i].accum = axis[i].maj - 1
                     - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  } // endfor

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ( ((SrcType == LN_8BIT) || (SrcType == LN_YUV422))
        && !(bltr.LNCNTL.W & LN_XSHRINK) )
  {
    // Put DDA parameter check/adjust (Optional for 5462/required for 5464)

    const  short maj_x = bltr.MAJ_X;
    const  short min_x = bltr.MIN_X;
    short  xaccum      = bltr.ACCUM_X;
    short  copy_xDst   = bltr.BLTEXT.pt.X;
    short  src_ext;
    short  inc_dx      = 1;
    short  inc_sx      = 0;
    short  SrcDstSz;

    SrcDstSz = ( SrcType == LN_8BIT ) ? 1 : 2 ;

    if ( (bltr.LNCNTL.W & LN_XSHRINK) )
       inc_sx = bltr.SHRINKINC.pt.X;

    inc_sx    *= SrcDstSz;
    inc_dx    *= SrcDstSz;
    copy_xDst *= (short)nBytesPixel;
    src_ext    = SrcDstSz;    // Source size starts with a pixel !!

    do
    { // Step through the X DDA accounting for src pixels consumed
      copy_xDst  -= inc_dx;
      src_ext    += inc_sx;
      xaccum     += min_x;
      if ( xaccum < 0 )
      {
        xaccum   += maj_x;
        src_ext  += SrcDstSz;
      }
    } while ( copy_xDst > 0 );

    bltr.SRCX  = src_ext;

    // End DDA parameter check / adjust.

    CALL_DRV_STR_BLT(&bltr);   // Single stretch

    if ( (SrcType == LN_YUV422) )
       CALL_DELAY_9BIT_BLT(TRUE);
  }
//  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
  else if (SrcType == LN_RGB565)
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int mtile_s = 128 - 1; // sram is 128 bytes
    int mtile_d = 128 - 1 ;      // 5464 Dest Workaround half tile size mask

    int endx  = xDst + cxClip;    // last x, exclusive
    int dstxe = endx & ~mtile_d;  // start of last tile

    int  accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  sav_accx;
    int  sav_dstx;
    int  sav_srcx;
    int  sav_src_ext;
    int  copy_srcx;
    int  xext;
    int  inc_sx;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif
    if (bltr.LNCNTL.W & LN_XSHRINK)
    {
       mtile_d = 128 - 1;
       dstxe   = endx & ~mtile_d;
    }

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;
       dstxe = endx & ~mtile_d;
    }

    if (LGDEVID == CL_GD5464)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    copy_srcx  = bltr.SRCX;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X   = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X   = (USHORT)srcx;
      bltr.ACCUM_X            = (USHORT)accx;
      xext                    = 0;
      src_ext                 = 0;
      inc_sx                  = bltr.SHRINKINC.pt.X * 2;

      if ( bltr.LNCNTL.W & LN_XSHRINK )
      {  // We have to treat the stretch / shrink cases differently
         // because of the need to handle both SRC & DST aligned cases.
         do
         {
           dstx     += 2;
           xext     += 2;
           accx     += axis[0].min;
           srcx     += inc_sx;
           src_ext  += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx + 4 ) & mtile_d);

         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;

         do
         {
           dstx    += 2;
           xext    += 2;
           accx    += axis[0].min;
           srcx    += inc_sx;
           src_ext += inc_sx;

           if ( !(srcx & mtile_s) )
              break;    // Try double striping !!

           if (accx < 0)
           {
              accx    += axis[0].maj;
              srcx    += 2;
              src_ext += 2;

              if ( !(srcx & mtile_s) )
                 break;    // Try double striping !!
           }
         } while ((dstx) & mtile_d);

         bltr.SRCX  = (USHORT)src_ext;
      }
      else
      {
         do
         {
            dstx += 2;
            xext += 2;
            accx += axis[0].min;

            if (accx < 0)
            {
               accx     += axis[0].maj;
               srcx     += 2;
               src_ext  += 2;

               if ( !(srcx & mtile_s) )
                  break;    // Try double striping !!

            }
         } while (dstx & mtile_d);

         bltr.SRCX = src_ext + 2;
         sav_dstx = dstx;
         sav_accx = accx;
         sav_srcx = srcx;
         sav_src_ext = src_ext;
      }

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DRV_STR_MBLTX(&bltr);

      dstx = sav_dstx;
      accx = sav_accx;
      srcx = sav_srcx;
      src_ext = sav_src_ext;
      copy_srcx -= src_ext;
    } // end while (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X  = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X  = (USHORT)srcx;
       bltr.ACCUM_X            = (USHORT)accx;
       bltr.SRCX               = (USHORT)copy_srcx;
       bltr.BLTEXT.PT.X        = endx - dstx;

       CALL_DRV_STR_MBLTX(&bltr);
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
       CALL_DELAY_9BIT_BLT(TRUE);
  }
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    if (LGDEVID == CL_GD5464 && SrcType != LN_8BIT)
    {
       bltr.SHRINKINC.pt.X *= 2;
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers
       bltr.SHRINKINC.pt.X /= 2;
    }
    else
       CALL_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
        src_ext = mtile  - (srcx & mtile_mask);
        if ( src_ext > cxSrc )
          src_ext = cxSrc;
      }
      else
      {
        if ( cxSrc < mtile )
           src_ext = cxSrc; // last partial tile
        else
           src_ext = mtile; // complete tile
      }

      srcx += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;

      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;

        if ( xaccum < 0 )
        {
           xaccum += maj_x;
           copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      if ( SrcType == LN_RGB565 )
         bltr.SRCX           = src_ext + 2;
      else
         bltr.SRCX           = (USHORT)src_ext;

      bltr.BLTEXT.pt.X      = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X        = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.
    //
    if ((cxFill > 0) && (cxClip = (xFill & 7)) &&
       ((SrcType == LN_YUV422)||((nBytesPixel == 1) && (SrcType == LN_RGB565))))
    {  // these must be extra pixels.  They must be filled using
       //  the same 9th bit and in the same format as the stretch
       if ( SrcType == LN_YUV422  )
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              MAKELONG(BOGUS_YUV, BOGUS_YUV), TRUE);
       else
          CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                              0x00000000, TRUE);

       xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
       cxFill -= cxClip;
    }

    if ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1))
        CALL_DELAY_9BIT_BLT(TRUE);

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
      if ( nBytesPixel == 2 )
         CALL_MEDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                             MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
     else
         CALL_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                            0x00000000, FALSE);
    }
  }
} // DrvStretch64

/***************************************************************************
*
* FUNCTION:     DrvStretch62
*
* DESCRIPTION:  The 5462 doesn't do display list programming, so
*               all blts must be direct (call the DIR_XXX functions)
*
****************************************************************************/

void DRVSTRETCH62
#ifndef WINNT_VER40
       LPGLOBALDATA lpDDHALData,
#endif
       int xDst, int yDst, int cxDst, int cyDst,
       int xSrc, int ySrc, int cxSrc, int cySrc,
       int nBytesPixel, int SrcType, int BaseOffset,
       int OnScreen)
{
  int   cxClip = cxDst;
  int   cyClip = cyDst;
  int   cxFill = 0;
  int   cyFill = cyDst;
  int   xFill  = xDst;
  int   yFill  = yDst;
  int   cxTrim = 0;
  int   iratio, i;
#ifdef RDRAM_8BIT
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
#endif

  autoblt_regs bltr;

  AXIS axis[2];
  int  nDst[2];
  int  nSrc[2];

#ifdef RDRAM_8BIT
  RECTL   SrcRectl;
  int     nFound = FALSE;
#endif

  DD_LOG(("DrvStretch62 - dst=%08lX dstext=%08lX src=%08lX srcext=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cySrc)));

#ifdef RDRAM_8BIT
  if (!lpDDHALData->fNineBitRDRAMS)
  {
     if (SrcType == LN_YUV422)
     {
        SrcRectl.left   = xSrc;
        SrcRectl.top    = ySrc;
        SrcRectl.right  = xSrc+cxSrc;
        SrcRectl.bottom = ySrc+cySrc;

        if (MEMCMP(&SrcRectl, sizeof(SrcRectl)) == 0)
           nFound = TRUE;

        if (nFound)
        {
#if 0
        DBG_MESSAGE(("Stretch: Found Offscreen Area P1(%x,%x) P2(%x,%x) Dst(%x, %x) Dst(%x %x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom,
                     xDst,
                     yDst,
                     xDst+cxDst,
                     yDst+cyDst));
#endif

           LL16(grX_Start_2, xDst + ((4 - (xDst & 3)) & 3));
           LL16(grY_Start_2, yDst);
           LL16(grX_End_2, xDst+(cxDst>>3<<3));
           LL16(grY_End_2, yDst+cyDst);
        }
        else
        {
#if 0
        DBG_MESSAGE(("Stretch: Not Found Offscreen Area P1(%x,%x) P2(%x,%x)\n",
                     SrcRectl.left,
                     SrcRectl.top,
                     SrcRectl.right,
                     SrcRectl.bottom));
#endif

           LL16(grX_Start_2, 0);
           LL16(grY_Start_2, 0);
           LL16(grX_End_2, 0);
           LL16(grY_End_2, 0);

           // Black Blit Here
           CALL_DIR_DRV_DST_BLT(0x107000CC,MAKELONG(xDst,yDst),0,MAKELONG(cxDst,cyDst));
           return ;
        }
     }  // endif (SrcType == LN_YUV422)
  }  // endif (!lpDDHALData->fNineBitRDRAMS)
#endif

#ifdef TRACE_STRETCH
  DBG_MESSAGE(("DrvStretch62: %4d,%4d %4dx%4d -> %4d,%4d %4dx%4d (%d %d) %d",
               xSrc, ySrc, cxSrc, cySrc,
               xDst, yDst, cxDst, cyDst,
               nBytesPixel, SrcType, BaseOffset));
#endif

  if ((SrcType == LN_YUV422) ||
      ((SrcType == LN_RGB565) && (nBytesPixel == 1)))
  { // Force alignment of output to QWORD ( it is documented as DWORD but broken)

    if ( nBytesPixel == 2 )
    {  // 16 bit frame buffer ( Note all ptrs/extents in terms of 16 bpp )
       // The X portions will be mutiplied by 2 by chip on being written )

       if ( cxDst > cxSrc )
          iratio = cxDst / cxSrc; // integer ratio of stretch
       else
          iratio = cxSrc / cxDst; // integer ratio of shrink

       if ( xDst & 3 )   /* This should be for LN_YUV422 only */
       {
          cxFill = 4 - (xDst & 3);
          cxTrim = cxFill;    // save trim count for source clipping if required

          if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

          cxClip -= cxFill;  /* reduce size */
          cxDst  -= cxFill;  /* reduce size */
          xDst   += cxFill;  /* force alignment to next even DWORD boundary */

          CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                               0,MAKELONG(cxFill,cyFill));

#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(1) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  //endif ( xDst & 3 )

      cxFill  = cxClip & 3;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         xFill   = xDst + cxClip;

        if ( cxClip >= cxSrc)
        {  // If shrink defer edge fill to later as there may be more
          CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                 MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(2) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
        }  // endif ( cxClip >= cxSrc)
      } // endif ( cxFill )

      if ( (cxClip < cxSrc) )
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, 2));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d", iratio, excess, 2));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge
            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess < (cxFill * iratio) )

         if ( excess && (excess < (2 * cxClip)/100 ))
         {  // if excess is less than 2% of frame trim edges
            int trim = excess / 2; // half the excess of pixels
            xSrc +=  trim;         // offset pixel pointer
            cxSrc -= excess;       // all the excess in pixels

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

            DISPDBG((DBGLVL1,
                     "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                     trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d", trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
         }

         if ( iratio == 1 )
         {  // we may have just changed a shrink to a 1 : 1
            // if excess is zero do edge fill now

            // extra pixels to discard above integer ratio
            excess = ( cxSrc / iratio ) - cxClip;

            if ( !excess && cxFill )
            {
               xFill = xDst + cxClip;

               CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                      MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(7) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
            }
         }  // endif ( iratio == 1 )
      }
      else
      { // Stretch adjustments
        if ( xSrc - BaseOffset )
        { // if we are not starting from left edge of source image

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          DISPDBG((DBGLVL1,
                   "DDraw - Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d",
                   iratio, cxTrim, xSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Trim for stretch iratio = %d , cxTrim = %d xSrc %d", iratio, cxTrim, xSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          if ( cxTrim )
          {  // And we were forced to offset for left edge alignment
             cxSrc  -= cxTrim / iratio;
             xSrc += cxTrim / iratio;
          }
        }
      }  // endif ( (cxClip < cxSrc) )

      // Global adjustments
      if ( xSrc & 1 )   /* HW bug workaound for clipping */
      {
         xSrc += 1;    /* Align to SRC DWORD Boundary */
         cxSrc -= 1;   /* Account for smaller size */
      }
    }
    else
    { // 8 Bit frame buffer.
      // Force alignment of output to QWORD ( it is documented as DWORD but broken)

      if ( cxDst >= (cxSrc*2) )
         iratio = cxDst / (2 * cxSrc); // integer ratio of stretch
      else
         iratio = (2 * cxSrc ) / cxDst;  // integer ratio of shrink

      if ( xDst & 7 )   /* This should be for LN_YUV422 only */
      {
         cxFill = 8 - (xDst & 7);

         if ( cxFill > cxClip )
            cxFill = cxClip;  // check for no stretch left

         cxClip -= cxFill;  /* reduce size */
         cxDst  -= cxFill;  /* reduce size */
         xDst   += cxFill;  /* force alignment to next even WORD boundary */

         CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                              0,MAKELONG(cxFill,cyFill));
#ifdef TRACE_STRETCH
        DBG_MESSAGE((" Edge Fill(3) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
      }  // endif ( xDst & 7 )

      cxFill  = cxClip & 7;

      if ( cxFill )
      {
         cxClip -= cxFill;    /* force size to next smaller even DWORD count */
         if ( cxClip >= (cxSrc * 2))
         { // If shrink defer edge fill to later as there may be more

           xFill  = xDst + cxClip;

#ifdef BOGUS_8BIT
           CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                  MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
           CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                0,MAKELONG(cxFill,cyFill));
#endif

#ifdef TRACE_STRETCH
          DBG_MESSAGE((" Edge Fill(4) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
         }
      } // endif ( cxFill )

      // change pixel pointer to byte pointer
      // taking account of X origin of buffer
      xSrc = BaseOffset + (xSrc - BaseOffset) * 2;

      cxSrc *= 2;     /* change pixel count to byte count */

#ifdef EDGE_CLIP
      if ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
      {  // Edge Clip on shrinks only ( add config flag check here )
         int excess;

         // extra pixels to discard above integer ratio
         excess = ( cxSrc / iratio ) - cxClip;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

         DISPDBG((DBGLVL1,
                  "DDraw - Edge Clip iratio = %d excess = %d Trim %% = %d",
                  iratio, excess, lpDDHALData->EdgeTrim));

#else   // ----- #elseif WINNT_VER40 -----

        DBG_MESSAGE((" Edge Clip iratio = %d excess = %d Trim %% = %d",
                     iratio, excess, lpDDHALData->EdgeTrim));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

         if ( excess && cxTrim )
         {  // These excess pixels are caused by our Dest alignment
            // problems on the Left edge
            if ( excess < (cxTrim * iratio) )
            {
               cxSrc  -= excess;
               xSrc   += excess;
               excess  = 0;
            }
            else
            {
               cxSrc  -= cxTrim * iratio;
               xSrc   += cxTrim * iratio;
               excess -= cxTrim * iratio;
            }
         }  // endif ( excess && cxTrim )

         if ( excess && cxFill)
         {  // These excess pixels are caused by our Dest alignment
            //  problems on the Right edge

            if ( excess < (cxFill * iratio) )
            {
               cxSrc -= excess;
               excess = 0;
            }
            else
            {
               cxSrc -= cxFill * iratio;
               excess -= cxFill * iratio;
            }
         }  // endif ( excess && cxFill)

        if ( excess && ( excess < (lpDDHALData->EdgeTrim * cxClip)/100 ) )
        {  // if excess is less than specific % of frame trim edges
           int trim = excess / 2;  // half the excess as pixels
           xSrc  +=  trim;      // offset pixel pointer
           cxSrc -= excess;    // all the excess in bytes

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

           DISPDBG((DBGLVL1,
                    "DDraw - Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                    trim, xSrc, cxSrc));

#else   // ----- #elseif WINNT_VER40 -----

          DBG_MESSAGE((" Edge Clip Left = %d, xSrc = %d, cxSrc = %d",
                       trim, xSrc, cxSrc));

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
        }

        if ( iratio == 1 )
        { // we may have just changed a shrink to a 1 : 1
          // if excess is no zero do edge fill now

          // extra pixels to discard above integer ratio
          excess = ( cxSrc / iratio ) - cxClip;

          if ( !excess && cxFill )
          {
             xFill = xDst + cxClip;

#ifdef BOGUS_8BIT
             CALL_DIR_EDGE_FILL_BLT(xFill, yFill, cxFill, cyFill,
                                    MAKELONG(BOGUS_YUV, BOGUS_YUV), FALSE);
#else
             CALL_DIR_DRV_DST_BLT(MAKELONG(0x0000,BD_RES),MAKELONG(xFill,yFill),
                                  0,MAKELONG(cxFill,cyFill));
#endif
#ifdef TRACE_STRETCH
            DBG_MESSAGE((" Edge Fill(6) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
          }  // endif ( !excess && cxFill )
        }  // endif ( iratio == 1 )
      } // endif ( (cxClip < cxSrc) && lpDDHALData->EdgeTrim)
#endif

      if ( xSrc & 3 )   /* HW bug workaound for clipping */
      {
         cxSrc -= 4 - (xSrc & 3);      // reduce size
         xSrc   = (xSrc + 3) & ~ 3;    // Align to SRC DWORD Boundary
      }
    }  // endif ( nBytesPixel == 2 )
  }

  if ( cxClip == 0 )
     return;     // discard zero extent stretchs

  if ( nBytesPixel == 1 &&
       ((SrcType == LN_YUV422) || (SrcType == LN_RGB565 )) ||
       ((nBytesPixel == 2) && (SrcType == LN_YUV422) ) )
  {
     /* This is to ensure that the last packet of any previous blt */
     /* does no go out with 9th bit set */

     CALL_DIR_DELAY_9BIT_BLT(FALSE);

     bltr.DRAWBLTDEF.DW   = MAKELONG(0x04CC, BD_RES | BD_OP1);
     lpDDHALData->YUVLeft = (USHORT)xDst;  // Save 9th bit rect coords for main
     lpDDHALData->YUVTop  = (USHORT)yDst;   // driver for exclusion purposes.
     lpDDHALData->YUVXExt = (USHORT)cxClip;
     lpDDHALData->YUVYExt = (USHORT)cyClip;

     // tell main driver the rectangle is valid
     lpDDHALData->DrvSemaphore |= DRVSEM_YUV_RECT_VALID;
  }
  else
     bltr.DRAWBLTDEF.DW  = MAKELONG(0x00CC, BD_RES | BD_OP1);

  bltr.OP0_opRDRAM.DW  = MAKELONG(xDst, yDst);
  bltr.OP1_opRDRAM.DW  = MAKELONG(xSrc, ySrc);

  bltr.BLTEXT.DW = MAKELONG(cxClip, cyClip);

  bltr.LNCNTL.W  = SrcType << LN_YUV_SHIFT;

  // Enable interpolation unless we have a palette (8bpp).
  if (SrcType != LN_8BIT )
     bltr.LNCNTL.W    |= LN_XINTP_EN | LN_YINTP_EN;

  bltr.SHRINKINC.w = 0x0000;

  if ( cxClip < cxSrc )
  {
     bltr.LNCNTL.W   |= LN_XSHRINK;
     bltr.LNCNTL.W   &= ~LN_XINTP_EN;
     bltr.SHRINKINC.pt.X = (cxSrc / cxClip);
  }

  if ( cyDst < cySrc )
  {
     bltr.LNCNTL.W   |= LN_YSHRINK;
     bltr.LNCNTL.W   &= ~LN_YINTP_EN;
     bltr.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  if ( SrcType == LN_YUV422 || SrcType == LN_RGB565 )
  {
    if ( nBytesPixel == 1 )
      bltr.SRCX  = (USHORT)cxSrc;  // If mixed mode is *2 already
    else
      bltr.SRCX = cxSrc * 2;
  }
  else
    bltr.SRCX   = cxSrc * nBytesPixel;

#ifdef TRACE_STRETCH
  DBG_MESSAGE((" cSrc = %d , %d : cDst = %d , %d : cClip = %d , %d",
               cxSrc, cySrc, cxDst, cyDst, cxClip, cyClip));
#endif

  // Compute DDA terms.
  nDst[0] = cxClip; nDst[1] = cyDst;
  nSrc[0] = cxSrc; nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

    if (bltr.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }

    if (bltr.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj =  (short)nDst[i];
      axis[i].min = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj =  kDst * nDst[i];
      axis[i].min = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }  // endfor (i = 0; i < 2; i++)

  bltr.MAJ_X   = axis[0].maj;
  bltr.MIN_X   = axis[0].min;
  bltr.ACCUM_X = axis[0].accum;

  bltr.MAJ_Y   = axis[1].maj;
  bltr.MIN_Y   = axis[1].min;
  bltr.ACCUM_Y = axis[1].accum;

  if ((SrcType == LN_8BIT) ||
      ((SrcType == LN_YUV422) && !(bltr.LNCNTL.W & LN_XSHRINK)) )
  {
     CALL_DIR_DRV_STR_BLT(&bltr);   // Single stretch

     if ( (SrcType == LN_YUV422) )
     {
        // This is to ensure that the last packet of blt does no go out with
        // 9th bit clear  It is cheaper than waiting, especially on single
        // stripe BLTs

        CALL_DIR_DELAY_9BIT_BLT(TRUE);
     }
  }
  else if (SrcType == LN_RGB565 && !(bltr.LNCNTL.W & LN_XSHRINK))
#if 1
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on destination alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;
       dstxe = endx & ~mtile;
    }

    CALL_DIR_DRV_STR_MBLTY(&bltr); // load the invariant sections of the engine

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }  // endwhile ((dstx & mtile) && (dstx < endx))

    // do the odd pixels we stepped over
    if (xext)
    {
       bltr.BLTEXT.PT.X    = (USHORT)xext;
       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    // do all the whole tiles but the last
    bltr.SRCX  -= (USHORT)src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
      bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
      bltr.ACCUM_X = accx;
      xext = 0;
      src_ext = 0;

      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X = (USHORT)xext;

      CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.SRCX -= (USHORT)src_ext;
    }  // endwhile (dstx < dstxe)

    // do the last tile
    if (dstx < endx)
    {
       bltr.OP0_opRDRAM.PT.X = (USHORT)dstx;
       bltr.OP1_opRDRAM.PT.X = (USHORT)srcx;
       bltr.ACCUM_X  = accx;

       bltr.BLTEXT.PT.X = endx - dstx;

       CALL_DIR_DRV_STR_MBLTX(&bltr);
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
       // This is to ensure that the last packet of stretch blt does no go out
       // with 9th bit clear. It is cheaper than waiting, especially on single
       // stripe BLTs

       CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#else
  {
    // HWBUG !!! -- Break into Double aligned vertical stripes
    // based on src and dest alignment
    // dword and tile masks

    const int mdwrd =   4 ;
    const int tile = 128 ; /* sram is 128 bytes */
    const int mtile = 128 - 1 ; /* sram is 128 bytes */

    int endx  = xDst + cxClip;  // last x, exclusive
    int dstxe = endx & ~mtile;  // start of last tile

    DDAX accx = axis[0].accum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  src_ext = 0;
    int  xext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
      cxSrc *= 2;   /* convert size to Bytes from pixels */
      cxDst *= 2;
      srcx = (xSrc *= 2);
      dstx = (xDst *= 2);
      bltr.OP0_opRDRAM.pt.X *= 2;
      bltr.OP1_opRDRAM.pt.X *= 2;
      endx *= 2;
      dstxe = endx & ~mtile;
    }

    // step to the next tile
    xext = 0;
    while ((dstx & mtile) && (dstx < endx))
    {
      dstx += 2;
      xext += 2;
      accx += axis[0].min;
      if (accx < 0)
      {
        accx += axis[0].maj;
        srcx += 2;
        src_ext += 2;
      }
    }

    // do the odd pixels we stepped over

    if (xext)
    {
      bltr.BLTEXT.PT.X    = xext;
      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do all the whole tiles but the last

    bltr.SRCX         -= src_ext;

    while (dstx < dstxe)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;
      xext = 0;
      src_ext = 0;
      do
      {
        dstx += 2;
        xext += 2;
        accx += axis[0].min;
        if (accx < 0)
        {
          accx += axis[0].maj;
          srcx += 2;
          src_ext += 2;
        }
      } while (dstx & mtile);

      bltr.BLTEXT.PT.X    = xext;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }

    // do the last tile
    if (dstx < endx)
    {
      bltr.OP0_opRDRAM.PT.X = dstx;
      bltr.OP1_opRDRAM.PT.X = srcx;
      bltr.ACCUM_X      = accx;

      bltr.BLTEXT.PT.X    = endx - dstx;

      CALL_DIR_DRV_STR_MBLT(&bltr);
    }
    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }
  }
#endif
  else
  {
    // HWBUG !!! -- Break into sram-aligned vertical tiles
    // based on source alignment
    // tile mask
    const int mtile = 128; /* sram is 128 bytes */
    const int mtile_mask = mtile - 1;
    const short maj_x = bltr.MAJ_X;
    const short min_x = bltr.MIN_X;
    int endx  = xDst + cxClip;  // last x, exclusive, in pixels

    short  xaccum;
    int  dstx = xDst;
    int  srcx = xSrc;
    int  dst_ext;
    int  src_ext;
    int  copy_src_ext;

#ifndef WINNT_VER40
    ASSERT( BITSPERPIXEL != 24 ); // HWBUG !!!
#endif

    if ( nBytesPixel == 2 )
    {
       cxSrc *= 2;   /* convert size to Bytes from pixels */
       cxDst *= 2;
       srcx = (xSrc *= 2);
       dstx = (xDst *= 2);
       bltr.OP0_opRDRAM.pt.X *= 2;
       bltr.OP1_opRDRAM.pt.X *= 2;
       endx *= 2;    /* convert end marker to bytes */
    }

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
    DBG_MESSAGE((" mtile = %d  maj = %d min = %d accum = %d shrinkinc = %04x",
                 mtile, maj_x, min_x, bltr.ACCUM_X, bltr.SHRINKINC));
#endif
#endif

    CALL_DIR_DRV_STR_MBLTY(&bltr);   // Load the invariant registers

    do
    {
      // get alignment to first src tile / sram break;
      if ( srcx & mtile_mask ) // initial alignment
      {
         src_ext = mtile  - (srcx & mtile_mask);
         if ( src_ext > cxSrc )
            src_ext = cxSrc;
      }
      else
      {
         if ( cxSrc < mtile )
            src_ext = cxSrc; // last partial tile
        else
            src_ext = mtile; // complete tile
      }

      srcx  += src_ext;    // account for amount of src consumed
      cxSrc -= src_ext;

      // calculate how many destination pixels == src_ext
      xaccum  = bltr.ACCUM_X;
      dst_ext = 0;
      copy_src_ext = src_ext;
      do
      {
        dst_ext += 2;
        copy_src_ext -= 2 * bltr.SHRINKINC.pt.X;
        xaccum += min_x;
        if ( xaccum < 0 )
        {
          xaccum += maj_x;
          copy_src_ext -= 2;
        }
      } while ( copy_src_ext > 0 && (dstx + dst_ext <= endx) );

      dst_ext &= ~3;    /* force destination extent to DWORDs */

      dstx += dst_ext;

#ifdef TRACE_STRETCH
#ifdef TRACE_ALL
      DBG_MESSAGE((" srcx = %d src_ext = %d cxSrc = %d dstx = %d dst_ext = %d end = %d",
                   srcx, src_ext, cxSrc, dstx, dst_ext, endx ));
#endif
#endif

      bltr.BLTEXT.pt.X = (USHORT)dst_ext;

      if ( dst_ext > 0 )
         CALL_DIR_DRV_STR_MBLTX(&bltr);

      bltr.ACCUM_X      = xaccum;
      bltr.OP0_opRDRAM.pt.X += (USHORT)dst_ext;
      bltr.OP1_opRDRAM.pt.X += (USHORT)src_ext;
      bltr.SRCX         -= (USHORT)src_ext;
    } while ( (dstx < endx) && ( cxSrc > 0));

    xFill = bltr.OP0_opRDRAM.pt.X;

    cxFill  = (xDst + cxDst) - xFill;

#ifdef TRACE_STRETCH
    DBG_MESSAGE((" srcx=%d src_ext=%d cxSrc=%d  dstx=%d dst_ext=%d end=%d xFill=%d cxFill=%d",
                 srcx, src_ext, cxSrc, dstx, dst_ext, endx, xFill, cxFill ));
#endif

    // Edge Fill for trailing edge was deferred. Calculate correct amount
    // Taking into account pixels skipped above for alignment.

    if ((cxFill > 0) && (cxClip = (xFill & 7)) && ((SrcType == LN_YUV422)||((nBytesPixel == 1) &&(SrcType == LN_RGB565))))
    {// these must be extra pixels.  They must be filled using
     //  the same 9th bit and in the same format as the stretch

      cxClip = 8 - cxClip;

      if ( SrcType == LN_YUV422 )
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,
                                MAKELONG(BOGUS_YUV-1,BOGUS_YUV-1),TRUE);
      }
      else
      {
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxClip,cyFill,0,TRUE);
      }

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill 9th bit set %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif

      xFill = bltr.OP0_opRDRAM.pt.X + cxClip;
      cxFill -= cxClip;
    }

    if ( (SrcType == LN_YUV422) || (SrcType == LN_RGB565 && nBytesPixel == 1) )
    {
      /* This is to ensure that the last packet of stretch blt does no go out with 9th bit clear */
      /* It is cheaper than waiting, especially on single stripe BLTs */

      CALL_DIR_DELAY_9BIT_BLT(TRUE);
    }

    if ( cxFill > 0 )
    {
      /* perform edge fill Blt */
#ifdef BOGUS_8BIT
      CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                              MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
#else
      if ( nBytesPixel == 2 )
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,
                                MAKELONG(BOGUS_YUV,BOGUS_YUV),FALSE);
      else
        CALL_DIR_MEDGE_FILL_BLT(xFill,yFill,cxFill,cyFill,0,FALSE);
#endif

#ifdef TRACE_STRETCH
      DBG_MESSAGE((" Edge Fill(5) %d,%d %d x %d", xFill, yFill, cxFill, cyFill));
#endif
    }
  }
} /* DrvStretch62 */

/***************************************************************************
*
* FUNCTION:     StretchColor
*
* DESCRIPTION:  This is a software solution for both the 5462 and 5464
*               to perform a stretch or shrink while there is a source
*               color key specified.
*
****************************************************************************/

void STRETCHCOLOR
#ifndef WINNT_VER40
  LPGLOBALDATA lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
  int   xError, yError;
  int   xRun, yRun;


  DD_LOG(("StretchColor - dst=%08lX dstext= %08lX src=%08lX srcext=%08lX colorkey=%08lX\r\n",
          MAKELONG(xDst,yDst),MAKELONG(cxDst,cyDst),
          MAKELONG(xSrc,ySrc),MAKELONG(cxSrc,cxSrc),
          ColorKey));
//  DD_LOG(("  Beer break! - we're gonna blt every pixel one at a time\r\n"));

  // Setup the hardware.
  //LL32(grDRAWBLTDEF.DW,   0x101101CC);
  //LL32(grOP_opBGCOLOR.DW, ColorKey);

  // Initialize the error terms.
  xError = ((cxSrc << 16) - 1) / cxDst + 1;
  yError = ((cySrc << 16) - 1) / cyDst + 1;

  // Y loop.
  for (yRun = 0; cyDst--;)
  {
    int dst = xDst;
    int src = xSrc;
    int cx  = cxDst;

    // X loop.
    for (xRun = 0; cx--;)
    {
      // Copy one pixel with color keying
      //LL32(grOP0_opRDRAM.DW, MAKELONG(dst, yDst));
      //LL32(grOP1_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grOP2_opRDRAM.DW, MAKELONG(src, ySrc));
      //LL32(grBLTEXT_EX.DW,   MAKELONG(1, 1));

      // this is bad but is needed for compatibility with display list
      CALL_DRV_SRC_BLT(0x101101CC,          // drawbltdef
                       MAKELONG(dst,yDst),  // dst coord
                       MAKELONG(src,ySrc),  // src coord
                       MAKELONG(src,ySrc),  // colorkey coord
                       ColorKey,            // colorkey
                       MAKELONG(1,1));      // extent

      // Advance destination x.
      dst++;

      // Adjust x error term.
      xRun += xError;
      while (HIWORD(xRun))
      {
        // Advance source x.
        src++;
        xRun -= MAKELONG(0, 1);
      }
    }

    // Advance destination y.
    yDst++;

    // Adjust y error term.
    yRun += yError;
    while (HIWORD(yRun))
    {
      // Advance source y.
      ySrc++;
      yRun -= MAKELONG(0, 1);
    }
  }
} /* StretchColor */

/***************************************************************************
*
* FUNCTION:     TransparentStretch
*
* DESCRIPTION:
*
****************************************************************************/

void TRANSPARENTSTRETCH
#ifndef WINNT_VER40
  LPGLOBALDATA  lpDDHALData,
#endif
  int xDst, int yDst, int cxDst, int cyDst,
  int xSrc, int ySrc, int cxSrc, int cySrc,
  DWORD ColorKey)
{
  const int nBytesPixel = BYTESPERPIXEL;
  const int nSRAMPixels = (SRAM_SIZE / nBytesPixel) / 2;
  const int nSRAMMask   = nSRAMPixels - 1;

  autoblt_regs  SrcToScratch;

  int   xScratch, yScratch;
  int   cxScratch, cyScratch;

  AXIS  axis[2];
  int   nDst[2];
  int   nSrc[2];
  int   i;

  DDAX  accx;
  int   srcx;
  int   xext;

  int   cxTemp;
  int   xTemp;


#ifndef WINNT_VER40
  ASSERT(cxDst >= cxSrc);
#endif

  xScratch = LOWORD(lpDDHALData->ScratchBufferOrg);
  yScratch = HIWORD(lpDDHALData->ScratchBufferOrg);
  cxScratch = cxDst;
  cyScratch = cyDst;

  // initialize auto blt struct for src to scratch buffer
  SrcToScratch.DRAWBLTDEF.DW  = MAKELONG(ROP_OP1_copy, (BD_RES+BD_OP1)*IS_VRAM);

  SrcToScratch.OP0_opRDRAM.DW = MAKELONG(LOWORD(xScratch),LOWORD(yScratch));
  SrcToScratch.OP1_opRDRAM.DW = MAKELONG(LOWORD(xSrc),LOWORD(ySrc));

  SrcToScratch.LNCNTL.W       = lncntl[nBytesPixel-1] << LN_YUV_SHIFT;

  SrcToScratch.SRCX           = cxSrc * nBytesPixel;

#if ENABLE_INTERPOLATED_BLTS
  // Enable interpolation unless we have a palette (8bpp)
  if (1 < nBytesPixel)
    SrcToScratch.LNCNTL.W |= (LN_XINTP_EN | LN_YINTP_EN);
#endif

  SrcToScratch.SHRINKINC.W = 0x0000;

  if (cxDst < cxSrc)
  {
    SrcToScratch.LNCNTL.W |= LN_XSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_XINTP_EN;
    SrcToScratch.SHRINKINC.pt.X = (cxSrc / cxDst);
  }

  if ( cyDst < cySrc )
  {
    SrcToScratch.LNCNTL.W |= LN_YSHRINK;
    SrcToScratch.LNCNTL.W &= ~LN_YINTP_EN;
    SrcToScratch.SHRINKINC.pt.Y = (cySrc / cyDst);
  }

  SrcToScratch.BLTEXT.DW = MAKELONG(LOWORD(cxScratch),1);

  // Compute DDA terms

  nDst[0] = cxScratch;
  nDst[1] = cyScratch;
  nSrc[0] = cxSrc;
  nSrc[1] = cySrc;

  for (i = 0; i < 2; i++)
  {
    int kDst = 1;

#if ENABLE_INTERPOLATED_BLTS
    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XINTP_EN : LN_YINTP_EN))
    {
      nDst[i] *= 4;
      nSrc[i] *= 4;
      nSrc[i] -= 3;

      kDst = 0x8000 / nDst[i];
    }
#endif

    if (SrcToScratch.LNCNTL.W & ((i==0) ? LN_XSHRINK : LN_YSHRINK))
    { /* Shrink Terms */
      axis[i].maj   =  (short)nDst[i];
      axis[i].min   = - (nSrc[i] % nDst[i]);
      axis[i].accum = axis[i].maj - 1
                      - ((nSrc[i] % nDst[i]) / (nSrc[i]/nDst[i] + 1));
    }
    else
    { /* Stretch Terms */
      axis[i].maj   =  kDst * nDst[i];
      axis[i].min   = -kDst * nSrc[i];
      axis[i].accum = axis[i].maj - 1
                      - ((axis[i].maj % -axis[i].min) / (nDst[i]/nSrc[i] + 1));
    }
  }

  SrcToScratch.MAJ_X   = axis[0].maj;
  SrcToScratch.MIN_X   = axis[0].min;
  SrcToScratch.ACCUM_X = axis[0].accum;

  SrcToScratch.MAJ_Y   = axis[1].maj;
  SrcToScratch.MIN_Y   = axis[1].min;
  SrcToScratch.ACCUM_Y = axis[1].accum;



  // loop over scanlines in dst
  // do two blts for each, one from src to scratch buffer
  //   then one from scratch buffer to dst
  while (0 < cyDst)
  {
    // blt one scanline high from src to scratch buffer

    // set values for initial stripe
    xext = nSRAMPixels;
    accx = SrcToScratch.ACCUM_X;
    srcx = xSrc;

    // write settings that don't vary over stripes to the chip
    CALL_DRV_STR_BLTY(&SrcToScratch);

    cxTemp = cxScratch;
    xTemp = xScratch;

    while (cxTemp > xext)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)xext;

      // blt current stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);

      // increment xDst and decrement remaining dst extent
      xTemp  += xext;
      cxTemp -= xext;

      // walk DDA to compute error term (accx) and xSrc for next stripe
      for (i = 0; i < xext; i++)
      {
        SrcToScratch.ACCUM_X += SrcToScratch.MIN_X;
        if (0 > (short)SrcToScratch.ACCUM_X)
        {
          SrcToScratch.ACCUM_X += SrcToScratch.MAJ_X;
          srcx++;
        }
      }
    }
    // if there's some area left to blt, then do it
    if (0 < cxTemp)
    {
      // update auto blt struct settings
      SrcToScratch.OP0_opRDRAM.pt.X = (USHORT)xTemp;
      SrcToScratch.OP1_opRDRAM.pt.X = (USHORT)srcx;
      SrcToScratch.BLTEXT.pt.X      = (USHORT)cxTemp;

      // blt final stripe
      CALL_DRV_STR_BLTX(&SrcToScratch);
    }
    // reset ACCUM_X for beginning of next scanline
    SrcToScratch.ACCUM_X = accx;

    // walk Y DDA for src to scratch buffer blt
    SrcToScratch.ACCUM_Y += SrcToScratch.MIN_Y;
    SrcToScratch.OP1_opRDRAM.pt.Y += SrcToScratch.SHRINKINC.pt.Y;
    if (0 > (short)SrcToScratch.ACCUM_Y)
    {
      SrcToScratch.ACCUM_Y += SrcToScratch.MAJ_Y;
      SrcToScratch.OP1_opRDRAM.pt.Y++;
    }


    // blt from scratch buffer to dst
    // 1:1 in X, 1:1 in Y, uses colorkey

    CALL_DRV_SRC_BLT(MAKELONG((DD_TRANS | ROP_OP1_copy),
                              ((BD_RES+BD_OP1+BD_OP2)*IS_VRAM)),
                     MAKELONG(xDst,yDst),
                     MAKELONG(xScratch,yScratch),
                     MAKELONG(xScratch,yScratch),
                     ColorKey,
                     MAKELONG(cxDst,1));
    yDst++;
    cyDst--;
  }
}

/****************************************************************************
* FUNCTION NAME: DdBlt (NT) or Blt32 (Win95)
*
* DESCRIPTION:
****************************************************************************/
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
DWORD DdBlt(PDD_BLTDATA pbd)
{
  DRIVERDATA* lpDDHALData;
  PDEV*    ppdev;
  PVGAR    pREG;

#else   // ----- #elseif WINNT_VER40 -----
DWORD __stdcall Blt32(LPDDHAL_BLTDATA pbd)
{
  LPGLOBALDATA lpDDHALData = GetDDHALContext( pbd->lpDD);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  HRESULT  ddrval;
  DWORD    dwFlags;

  DWORD  dwDstCoord;
  DWORD  dwDstWidth;
  DWORD  dwDstHeight;

  DWORD  dwSrcCoord;
  DWORD  dwSrcWidth;
  DWORD  dwSrcHeight;
  int    BaseOffset;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  PDD_SURFACE_LOCAL   dstx;
  PDD_SURFACE_LOCAL   srcx;
  PDD_SURFACE_GLOBAL  dst;
  PDD_SURFACE_GLOBAL  src;

  DISPDBG((DBGLVL, "DDraw - DdBlt\n"));

  ppdev = (PDEV*) pbd->lpDD->dhpdev;
  lpDDHALData = (DRIVERDATA*) &ppdev->DriverData;
  pREG = (PVGAR) lpDDHALData->RegsAddress;

#else   // ----- #elseif WINNT_VER40 -----

  LPDDRAWI_DDRAWSURFACE_LCL  dstx;
  LPDDRAWI_DDRAWSURFACE_LCL  srcx;
  LPDDRAWI_DDRAWSURFACE_GBL  dst;
  LPDDRAWI_DDRAWSURFACE_GBL  src;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  DD_LOG(("Blt32 Entry\r\n"));

#ifdef WINNT_VER40
  SYNC_W_3D(ppdev); // if 3D context(s) active, make sure 3D engine idle before continuing...
#endif

  // NOTES:
  //   Everything you need is in lpBlt->bltFX .
  //   Look at lpBlt->dwFlags to determine what kind of blt you are doing,
  //   DDBLT_xxxx are the flags.
  //
  // COLORKEY NOTES:
  //   ColorKey ALWAYS comes in BLTFX. You don't have to look it up in
  //   the surface.

#ifdef WINNT_VER40      // WINNT_VER40

#else   // ----- #elseif WINNT_VER40 -----
  // if direct draw is NOT using display list, it must sync here
  // updateFlipStatus may access the hardware!
  if (!lpDDHALData->DisplayListDDraw && ((lpDDHALData->DrvSemaphore & DRVSEM_3D_BUSY) || (lpDDHALData->DrvSemaphore & DRVSEM_DISPLAY_LIST)))
  {
     qmRequestDirectAccess();
  }
#endif // WINNT_VER40

    // is a flip in progress?
#ifdef WINNT_VER40
    ddrval = vUpdateFlipStatus(
        &ppdev->flipRecord,
        pbd->lpDDDestSurface->lpGbl->fpVidMem);
#else
#if defined(DDRAW_COMPAT_10)
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpData->fpVidMem
        lpDDHALData);
#else
    ddrval = pfnUpdateFlipStatus(
        pbd->lpDDDestSurface->lpGbl->fpVidMem,
        lpDDHALData);
#endif
#endif

  if (ddrval != DD_OK)
  {
     pbd->ddRVal = ddrval;
     DD_LOG(("Blt32 Exit - flip in progress, returning %08lX\r\n", ddrval));
     return (DDHAL_DRIVER_HANDLED);
  }

#ifndef WINNT_VER40
  // if the destination surface of this blt is a texture
  if (DDSCAPS_TEXTURE & pbd->lpDDDestSurface->ddsCaps.dwCaps)
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDDestSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }

  // if the source surface of this blt is non-null and is a texture
  if ((NULL != pbd->lpDDSrcSurface) &&
      (DDSCAPS_TEXTURE & pbd->lpDDSrcSurface->ddsCaps.dwCaps))
  {
    LP_SURFACE_DATA lpSurfaceData;

    lpSurfaceData = (LP_SURFACE_DATA)(pbd->lpDDSrcSurface->dwReserved1);

    // if the texture is a non-agp host texture (i.e. pci memory)
    if (lpSurfaceData->dwFlags & SURF_HOST_BASED_TEXTURE)
    {
        // punt the blt to direct draw hel
        pbd->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_NOTHANDLED;
    }
  }
#endif

  // If async, then only work if blter isn't busy.
  // This should probably be a little more specific to each call !!!
  dwFlags = pbd->dwFlags;

//#if 0
//  if( dwFlags & DDBLT_ASYNC )
//  {
//    if( !ENOUGH_FIFO_FOR_BLT )
//    {
//#if 0 // diagnostics for ASYNC BLT lockup
//      DWORD dwROP = pbd->bltFX.dwROP;
//      WORD rop = (WORD) LOBYTE( HIWORD( dwROP ) );
//      PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
//      DBG_MESSAGE(("Status = %02x QFREE = %2d", pREG->grSTATUS, pREG->grQFREE));
//      dstx = pbd->lpDDDestSurface;
//      dst  = dstx->lpData;
//      dwDstCoord  = cvlxy( dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwDstCoord += MAKELONG( pbd->rDest.left, pbd->rDest.top );
//      dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
//      dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
//      srcx = pbd->lpDDSrcSurface;
//      src  = srcx->lpData;
//      dwSrcCoord  = cvlxy( src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );
//      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
//      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
//      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
//
//        DBG_MESSAGE(("Failed Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
//          dwSrcCoord, dwSrcWidth, dwSrcHeight,
//          dwDstCoord, dwDstWidth, dwDstHeight,
//          rop));
//#endif
//      DBG_MESSAGE(("ASYNC FAILED"));
//      pbd->ddRVal = DDERR_WASSTILLDRAWING;
//      return DDHAL_DRIVER_HANDLED;
//    }
//  }
//#endif

  // get offset, width, and height for destination
  dstx = pbd->lpDDDestSurface;

#if DDRAW_COMPAT == 10
  dst  = dstx->lpData;
#else
  dst  = dstx->lpGbl;
#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

  dwDstCoord = cvlxy(ppdev->lDeltaScreen,
                     dst->fpVidMem,
                     BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

  dwDstCoord  = cvlxy( lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

  dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
  dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
  dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;

  /* Check for a zero extent stretchblt */

  if ((dwDstWidth == 0) || (dwDstHeight == 0))
  {
     pbd->ddRVal = DD_OK;
     return (DDHAL_DRIVER_HANDLED);
  }
  // If someone is running a full-screen exclusive app it is the
  // responsibility of the app to take care of the cursor. We don't
  // call BeginAccess or EndAccess for them.
  //
  // However, if someone is running a windowed app and they have
  // attached a clipper object to the destination surface then they
  // are more like a normal windows app and we call BeginAccess and
  // EndAccess for them around a blt. That is the only circumstance
  // where we currently do cursor exclusion.
  //
  // We do intend to add calls to BeginAccess and EndAccess around
  // a rectangle lock of the primary surface. In this case, we
  // would only do cursor exclusion if a lock rect is specified.
  // This will be implemented with DirectDraw 2.0.
  //
  // I believe that you should not do automatic cursor exclusion in
  // the driver because you will penalize all blts and locks.

  // Grab the hardware - disable HW cursor updates.
  LOCK_HW_SEMAPHORE();

  // Decipher the flags.
  if (dwFlags & DDBLT_ROP)
  {
    static const WORD mix2blt[] =
    {  // all ops color vram
      BD_RES                  ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0         ,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES          | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES | BD_OP0 | BD_OP1,
      BD_RES
    };  // all ops color vram

    DWORD dwROP = pbd->bltFX.dwROP;
    WORD  rop = (WORD) LOBYTE( HIWORD( dwROP ) );
    WORD  mix = rop & 0x0f;
    WORD  bdf = mix2blt[mix];

    if (bdf & BD_OP1) // SRC rops
    {
      srcx = pbd->lpDDSrcSurface;

#if DDRAW_COMPAT == 10
      src  = srcx->lpData;
#else
      src  = srcx->lpGbl;
#endif


#ifdef WINNT_VER40    // YUV movement code
#else
  if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    (src->ddpfSurface.dwFlags & DDPF_FOURCC)    &&
    (lpDDHALData->DrvSemaphore & DRVSEM_YUV_MOVED) )
  {
    BOOL fMoved = FALSE;
    RECT rYUV;
		LONG lDeltaX, lDeltaY, Scale;
		LONG SrcWidth, SrcHeight, DstWidth, DstHeight;

		SrcWidth = src->wWidth;
		SrcHeight = src->wHeight;

		if (lpDDHALData->DrvSemaphore & DRVSEM_YUV_RECT_VALID)
		{
			rYUV.left	= min(lpDDHALData->YUVLeft,
							  pbd->rDest.left);
			rYUV.top	= min(lpDDHALData->YUVTop,
							  pbd->rDest.top);
			rYUV.right	= max(lpDDHALData->YUVLeft + lpDDHALData->YUVXExt,
							  pbd->rDest.right);
			rYUV.bottom	= max(lpDDHALData->YUVTop + lpDDHALData->YUVYExt,
							  pbd->rDest.bottom);
			DstWidth  = rYUV.right  - rYUV.left;
			DstHeight = rYUV.bottom - rYUV.top;

			if (pbd->rDest.left > rYUV.left)
			{
				// YUV has moved to left.
				lDeltaX = pbd->rDest.left - rYUV.left;
				Scale   = (SrcWidth - pbd->rSrc.right) * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.right += lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.left -= lDeltaX;
				fMoved = TRUE;
			}
			if (pbd->rSrc.left > 0)
			{
				// YUV has moved to right.
				lDeltaX = rYUV.right - pbd->rDest.right;
				Scale   = pbd->rSrc.left * DstWidth / SrcWidth;
				lDeltaX = min(lDeltaX, Scale);
				pbd->rSrc.left   -= lDeltaX * SrcWidth / DstWidth;
				pbd->rDest.right += lDeltaX;
				fMoved = TRUE;
			}

			if (pbd->rDest.top > rYUV.top)
			{
				// YUV has moved up.
				lDeltaY = pbd->rDest.top - rYUV.top;
				Scale   = (SrcHeight - pbd->rSrc.bottom) * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.bottom += lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.top   -= lDeltaY;
				fMoved = TRUE;
			}
			if (pbd->rSrc.top > 0)
			{
				// YUV has moved down.
				lDeltaY = rYUV.bottom - pbd->rDest.bottom;
				Scale   = pbd->rSrc.top * DstHeight / SrcHeight;
				lDeltaY = min(lDeltaY, Scale);
				pbd->rSrc.top     -= lDeltaY * SrcHeight / DstHeight;
				pbd->rDest.bottom += lDeltaY;
				fMoved = TRUE;
			}
		}

		if (fMoved)
		{
			// Recalculate the destination parameters since they might have
			// changed.
			dwDstCoord  = cvlxy(lpDDHALData,dst->fpVidMem - lpDDHALData->ScreenAddress,
								BYTESPERPIXEL);
			dwDstCoord += MAKELONG(pbd->rDest.left, pbd->rDest.top);
			dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
			dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
		}
		else
		{
			// Clear the YUV movement flag.
			lpDDHALData->DrvSemaphore &= ~DRVSEM_YUV_MOVED;
		}
	}

#endif // YUV movement code

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

      dwSrcCoord  = cvlxy(ppdev->lDeltaScreen,
                          src->fpVidMem,
                          BYTESPERPIXEL);

#else   // ----- #elseif WINNT_VER40 -----

      dwSrcCoord  = cvlxy( lpDDHALData,src->fpVidMem - lpDDHALData->ScreenAddress, BYTESPERPIXEL );

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

      dwSrcCoord += MAKELONG( pbd->rSrc.left, pbd->rSrc.top );
      dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
      dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;

      if (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      {
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);

        DD_LOG(("Src Color Key Blt\r\n"));

        if ( (dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) )
        {
          if ( !(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
               (rop == 0x00CC) )
          {
            if (dwSrcWidth < dwDstWidth)
            {
              CALL_TRANSPARENTSTRETCH(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                      dwDstWidth, dwDstHeight,
                                      LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                      dwSrcWidth, dwSrcHeight,
                                      dwColor);
              goto blt_exit;
            }
            else
            {
              CALL_STRETCHCOLOR(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                               dwDstWidth, dwDstHeight,
                               LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                               dwSrcWidth, dwSrcHeight,
                               dwColor);
              goto blt_exit;
            }
          }
          else
          {
            DD_LOG(("Unsupported SrcColorKey Blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }
        }

//        // PATCOPY is faster if that's all we're doing.
//        if (rop == 0xCC)
//        {
//           rop = 0xF0;
//           bdf = BD_RES | BD_OP2;
//        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwSrcCoord,  // Src transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
      else if (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      {
        #if _WIN32_WINNT >= 0x500
        // For some reason on NT 5.0 ddckDestColorkey does not work,
        // but ddckSrcColorkey does...
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);
        #else
        DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.ddckDestColorkey.dwColorSpaceLowValue);
        #endif

        DD_LOG(("Dst Color Key Blt\r\n"));

        // Punt if stretch or shrink requested.
        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
        {
          DD_LOG(("Unsupported DstColorKey Blt -> punt\r\n"));
          ddrval = DDERR_UNSUPPORTED;
          goto blt_exit;
        }

        CALL_DRV_SRC_BLT(MAKELONG(rop|DD_TRANS|DD_TRANSOP, bdf | BD_OP2),
                         dwDstCoord,
                         dwSrcCoord,
                         dwDstCoord,  // Dst transparency
                         dwColor,     //
                         MAKELONG(dwDstWidth, dwDstHeight) );

      } // (dwFlags & DDBLT_KEYDESTOVERRIDE) // Destination Color Key
      else
      {
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: Blt from %08X %dx%d -> %08X %dx%d  rop %X",
                     dwSrcCoord, dwSrcWidth, dwSrcHeight,
                     dwDstCoord, dwDstWidth, dwDstHeight,
                     rop));
#endif
#ifdef TRACE_STRETCH
        DBG_MESSAGE(("Blt32: BaseOffset  %08X  %08X",
                     src->fpVidMem - lpDDHALData->ScreenAddress, PITCH));
        DBG_MESSAGE(("Blt32: src->w %04d  %04d (%04x)",
                     src->wWidth, src->wHeight,
                     (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH ));

#endif

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
        BaseOffset = src->fpVidMem % ppdev->lDeltaScreen;
#else   // ----- #elseif WINNT_VER40 -----
        BaseOffset = (src->fpVidMem - lpDDHALData->ScreenAddress) % PITCH;
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

        if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight) ||
            (srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT))
        {
          int  nBytesPixel = BYTESPERPIXEL;
          int  SrcType = lncntl[nBytesPixel - 1];
          int  SrcSize = nBytesPixel;

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40

          int  ySrcAddr = src->fpVidMem / ppdev->lDeltaScreen;

#else   // ----- #elseif WINNT_VER40 -----

          int ySrcAddr    =  (src->fpVidMem - lpDDHALData->ScreenAddress) / PITCH;

#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

          // Punt if 32bpp. The '62 and '64 don't do 32bpp stretches at all...
          // KENTL - 10/4/96
          if (nBytesPixel == 4)
          {
            DD_LOG(("Unsupported 32bpp resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // Punt if not SRCCPY.
          if (rop != 0x00CC)
          {
            DD_LOG(("Unsupport rop in resize blt -> punt\r\n"));
            ddrval = DDERR_UNSUPPORTED;
            goto blt_exit;
          }

          // This should only be RGB565 in 8Bit FB or YUV422 in 8 or 16.
          if ( srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT )
          {
            if ( src->ddpfSurface.dwFlags & DDPF_FOURCC )
               SrcType = LN_YUV422;
            else
               SrcType = LN_RGB565;

            SrcSize = 2;
          }

          if (LGDEVID == CL_GD5464)
          {
            if ( ! lpDDHALData->EdgeTrim )
              lpDDHALData->EdgeTrim = 15;  // Assign minimum trim percentage

            if ((SrcType == LN_YUV422))
            {
              // Check for 5464 shrink workaround
              if ((dwDstWidth * nBytesPixel) <=
                  ((dwSrcWidth * SrcSize) * (100 - lpDDHALData->EdgeTrim)/100))
              {
                DWORD  dwTDst_X;
                int    iratio;
                int    ratio_1, ratio_2;
                unsigned int  excess;

                if ( nBytesPixel == 1 )
                   dwSrcWidth *= SrcSize;

                iratio = dwSrcWidth / dwDstWidth;
                excess = dwSrcWidth % dwDstWidth;

                ratio_1 = iratio;

                // get power of 2 greater than current number
                ratio_2    = 1;
                do
                {
                   ratio_2 <<= 1;
                } while ( ratio_1 >>= 1 );

                // Check for special cases of ratio already a perfect
                // power of 2 or could be trimmed to a power of two.
                if ((!excess || ((100 * excess) <= (dwSrcWidth * (100 - lpDDHALData->EdgeTrim)/100)))
                    && ( (ratio_2 / iratio) == 2 ) )
                   ratio_2 >>= 1;

                if ( nBytesPixel == 1 )
                { // Mixed mode frame buffer so adjust coords / sizes
                  // to match
//#if 0
//                  if ( !( OFFSCR_YUV_VAR.ratio == ratio_2 ) )
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     ratio_2 /= 2;
//
//                     // Perform offscreen shrink to adjacent src buffer
//                     CALL_DRVSTRETCH64(
//                       OFFSCR_YUV_VAR.SrcRect.right * SrcSize,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel,
//                       SrcType,
//                       BaseOffset,
//                       FALSE);
//
//                     ratio_2 *= 2;
//                  }  // endif ( !( offscr_YUV.ratio == ratio_2 ) )
//
//                  // Perform stretch from adjacent src buffer to
//                  // onscreen dst
//                  dwTDst_X = LOWORD(dwSrcCoord) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left) *
//                    SrcSize;
//#else
                  if (!( src->dwReserved1 == (DWORD)ratio_2))
                  {
                     src->dwReserved1 = ratio_2;

                     ratio_2 /= 2;

                     DD_LOG(("YUV shrink to extra buffer (8bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                        BaseOffset+(src->wWidth * SrcSize), // X Address of DST buffer
                        ySrcAddr,               // Y Address of DST buffer
                        src->wWidth / ratio_2,  // Width in PIXELS of DST
                        src->wHeight,           // Height
                        BaseOffset,             // X Address of SRC buffer
                        ySrcAddr,               // Y Address of SRC buffer
                        src->wWidth,            // Width in PIXELS of SRC
                        src->wHeight,           // Height
                        nBytesPixel,
                        SrcType,
                        BaseOffset,
                        FALSE);

                        ratio_2 *= 2;
                  }

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
#else   // ----- #elseif WINNT_VER40 -----
                  // Perform stretch from adjacent src buffer   to onscreen dst
                  // Russ/Kent 10/4/96 - This fails for unknown reasons as code. The alternate coding
                  // seems to work better. Fixes PDR#6799
                  //  dwTDst_X  =  LOWORD(dwSrcCoord) / ratio_2 + (src->wWidth * SrcSize);
                  dwTDst_X  = BaseOffset + (LOWORD(dwSrcCoord) - BaseOffset)/ratio_2 + (src->wWidth*SrcSize);
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>

//#endif

//                  dwTDst_X   /= SrcSize;    // Modify src X address
                  dwSrcWidth /= SrcSize;

                  DD_LOG(("YUV stretch from extra buffer (8bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset + (src->wWidth * SrcSize),
                               TRUE);

                } // if ( nBytesPixel == 1 )
                else
                {
//#if 0
//                  if (!( OFFSCR_YUV_VAR.ratio == ratio_2))
//                  {
//                     OFFSCR_YUV_VAR.ratio = ratio_2;
//
//                     CALL_DRVSTRETCH64(
//                       lpDDHALData,
//                       OFFSCR_YUV_VAR.SrcRect.right,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left)/ratio_2,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.top,
//                       OFFSCR_YUV_VAR.SrcRect.right  - OFFSCR_YUV_VAR.SrcRect.left,
//                       OFFSCR_YUV_VAR.SrcRect.bottom - OFFSCR_YUV_VAR.SrcRect.top,
//                       nBytesPixel, SrcType, BaseOffset,
//                       FALSE);
//
//                  }; // endif (!(offscr_YUV.ratio == ratio_2))
//
//                  // Perform stretch from adjacent src buffer to onscreen dst
//                  dwTDst_X = (LOWORD(dwSrcCoord) / ratio_2) +
//                    (OFFSCR_YUV_VAR.SrcRect.right - OFFSCR_YUV_VAR.SrcRect.left);
//
//#else
                  if ( !( src->dwReserved1 == (DWORD)ratio_2 ) )
                  {
                     src->dwReserved1 = ratio_2;

                     DD_LOG(("YUV shrink to extra buffer (16bpp)\r\n"));

                     // Perform offscreen shrink to adjacent src buffer
                     CALL_DRVSTRETCH64(
                       BaseOffset + (src->wWidth) , // X Address of DST buffer
                       ySrcAddr,               // Y Address of DST buffer
                       src->wWidth / ratio_2,  // Width in PIXELS of DST
                       src->wHeight,           // Height
                       BaseOffset,             // X Address of SRC buffer
                       ySrcAddr,               // Y Address of SRC buffer
                       src->wWidth,            // Width in PIXELS of SRC
                       src->wHeight,           // Height
                       nBytesPixel,
                       SrcType,
                       BaseOffset,
                       FALSE);
                  }

                  // Perform stretch from adjacent src buffer to onscreen dst
                  dwTDst_X = (LOWORD(dwSrcCoord) - BaseOffset) / ratio_2 + BaseOffset + (src->wWidth);
//#endif

                  DD_LOG(("YUV stretch from extra buffer (16bpp)\r\n"));

                  CALL_DRVSTRETCH64(
                               LOWORD(dwDstCoord),
                               HIWORD(dwDstCoord),
                               dwDstWidth,
                               dwDstHeight,
                               dwTDst_X,
                               HIWORD(dwSrcCoord),
                               dwSrcWidth / ratio_2,
                               dwSrcHeight,
                               nBytesPixel,
                               SrcType,
                               BaseOffset,
                               TRUE);

                } // endif ( nBytesPixel == 1 )
              }
              else
              {
                DD_LOG(("YUV stretch\r\n"));

                CALL_DRVSTRETCH64(
                             LOWORD(dwDstCoord),
                             HIWORD(dwDstCoord),
                             dwDstWidth,
                             dwDstHeight,
                             LOWORD(dwSrcCoord),
                             HIWORD(dwSrcCoord),
                             dwSrcWidth,
                             dwSrcHeight,
                             nBytesPixel,
                             SrcType,
                             BaseOffset,
                             TRUE);
              }
            }  // if ((SrcType == LN_YUV422))
            else
            {
              DD_LOG(("RGB resize blt\r\n"));

              // handle shrinks & stretches
              if ((2 == nBytesPixel) && (dwSrcWidth > dwDstWidth))
              {
                // handles 16bpp RGB shrinks
                CALL_RGB_16SHRINKBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                       dwDstWidth, dwDstHeight,
                                       LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                       dwSrcWidth, dwSrcHeight);
              }
              else
              {
                // handles 16bpp RGB stretches, 8bpp stretches & 8bpp shrinks
                CALL_RGB_RESIZEBOF64(LOWORD(dwDstCoord), HIWORD(dwDstCoord),
                                     dwDstWidth, dwDstHeight,
                                     LOWORD(dwSrcCoord), HIWORD(dwSrcCoord),
                                     dwSrcWidth, dwSrcHeight);
              }
            } // endif ((SrcType == LN_YUV422))
          }  // if (LGDEVID == CL_GD5464)
          else
          {
            DD_LOG(("calling DrvStretch62\r\n"));

            CALL_DRVSTRETCH62(
                          LOWORD(dwDstCoord),
                          HIWORD(dwDstCoord),
                          dwDstWidth,
                          dwDstHeight,
                          LOWORD(dwSrcCoord),
                          HIWORD(dwSrcCoord),
                          dwSrcWidth,
                          dwSrcHeight,
                          nBytesPixel,
                          SrcType,
                          BaseOffset,
                          TRUE);

          }  // endif (LGDEVID == CL_GD5464)
        }
        else
        {
          DD_LOG(("1:1 two operand blt\r\n"));

          CALL_DRV_SRC_BLT(MAKELONG(rop, bdf),
                           dwDstCoord,
                           dwSrcCoord,
                           0UL,     // don't care
                           0UL,     //
                           MAKELONG(dwDstWidth, dwDstHeight));
        }
      } // endif (dwFlags & DDBLT_KEYSRCOVERRIDE) // Source Color Key
    }
    else // DST ONLY rops
    {
      DD_LOG(("Dst Only Blt\r\n"));

      CALL_DRV_DST_BLT(MAKELONG(rop, bdf),
                       dwDstCoord,
                       0UL,  // don't care
                       MAKELONG(dwDstWidth, dwDstHeight) );
    }  // endif (bdf & BD_OP1) // SRC rops
  } // (dwFlags & DDBLT_ROP)
  else if (dwFlags & DDBLT_COLORFILL)
  {
    DWORD dwColor = CALL_DUP_COLOR(pbd->bltFX.dwFillColor);

    DD_LOG(("Solid Color Fill\r\n"));

    CALL_DRV_DST_BLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwColor,  // fill color
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifndef WINNT_VER40     // Not WINNT_VER40
  else if (bD3DInit && dwFlags & DDBLT_DEPTHFILL)
  {
    //JGO changed for Laguna3D integration
    DWORD dwFillDepth = CALL_DUPZFILL(pbd->bltFX.dwFillDepth,
                                      dstx->lpGbl->ddpfSurface.dwZBufferBitDepth);

    DD_LOG(("Depth Fill Blt\r\n"));

    // convert to byte blt
    // 16 bit zbuffer in 32 bit frame buffer trashes everything to right
    // of zbuffer
    // Fixes PDR #9152
    ((PT *)(&dwDstCoord))->X *= (WORD)(dst->ddpfSurface.dwZBufferBitDepth / 8);
    dwDstWidth *= (dst->ddpfSurface.dwZBufferBitDepth / 8);

    CALL_DRV_DST_MBLT(MAKELONG(0x00CC, BD_RES | (BD_OP1 * IS_SOLID)),
                     dwDstCoord,
                     dwFillDepth,
                     MAKELONG(dwDstWidth, dwDstHeight));
  }
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
  else
  {
    DD_LOG(("Unsupported blt - dwFlags = %08lX\r\n", dwFlags));
    ddrval = DDERR_UNSUPPORTED;
    goto blt_exit;
  } // endif (dwFlags & DDBLT_ROP)

blt_exit:

  // Release the hardware - enable HW cursor updates.
  UNLOCK_HW_SEMAPHORE();

  if (ddrval != DD_OK)
     return DDHAL_DRIVER_NOTHANDLED;

  pbd->ddRVal = DD_OK;

  DD_LOG(("Blt32 Exit\r\n"));

  return DDHAL_DRIVER_HANDLED;

} /* DdBlt */

/***************************************************************************
*
* FUNCTION:     BltInit
*
* DESCRIPTION:
*
****************************************************************************/

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#ifdef WINNT_VER40      // WINNT_VER40
void BltInit (PDEV* ppdev,  BOOL bEnableDisplayListBlts )
#else   // ----- #elseif WINNT_VER40-----
void BltInit ( BOOL bEnableDisplayListBlts ,LPGLOBALDATA lpDDHALData)
#endif // WINNT_VER40 >>>>>>>>>>>>>>>>>>>>>>
{
  if ((CL_GD5462 == LGDEVID) || (FALSE == bEnableDisplayListBlts))
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DIR_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DIR_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DIR_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DIR_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DIR_DrvStrBltX;
#else
    pfnDelay9BitBlt = DIR_Delay9BitBlt;
    pfnEdgeFillBlt  = DIR_EdgeFillBlt;
    pfnMEdgeFillBlt = DIR_MEdgeFillBlt;
    pfnDrvDstBlt    = DIR_DrvDstBlt;
    pfnDrvDstMBlt   = DIR_DrvDstMBlt;
    pfnDrvSrcBlt    = DIR_DrvSrcBlt;
    pfnDrvSrcMBlt   = DIR_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DIR_DrvStrBlt;
    else
      pfnDrvStrBlt  = DIR_DrvStrBlt65;
    pfnDrvStrMBlt   = DIR_DrvStrMBlt;
    pfnDrvStrMBltY  = DIR_DrvStrMBltY;
    pfnDrvStrMBltX  = DIR_DrvStrMBltX;
    pfnDrvStrBltY   = DIR_DrvStrBltY;
    pfnDrvStrBltX   = DIR_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DIR_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DIR_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DIR_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DIR_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
  else
  {
#ifdef WINNT_VER40
    ppdev->pfnDelay9BitBlt = DL_Delay9BitBlt;
    ppdev->pfnEdgeFillBlt  = DL_EdgeFillBlt;
    ppdev->pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    ppdev->pfnDrvDstBlt    = DL_DrvDstBlt;
    ppdev->pfnDrvDstMBlt   = DL_DrvDstMBlt;
    ppdev->pfnDrvSrcBlt    = DL_DrvSrcBlt;
    ppdev->pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    ppdev->pfnDrvStrBlt    = DL_DrvStrBlt;
    ppdev->pfnDrvStrMBlt   = DL_DrvStrMBlt;
    ppdev->pfnDrvStrMBltY  = DL_DrvStrMBltY;
    ppdev->pfnDrvStrMBltX  = DL_DrvStrMBltX;
    ppdev->pfnDrvStrBltY   = DL_DrvStrBltY;
    ppdev->pfnDrvStrBltX   = DL_DrvStrBltX;
#else
    pfnDelay9BitBlt = DL_Delay9BitBlt;
    pfnEdgeFillBlt  = DL_EdgeFillBlt;
    pfnMEdgeFillBlt = DL_MEdgeFillBlt;
    pfnDrvDstBlt    = DL_DrvDstBlt;
    pfnDrvDstMBlt   = DL_DrvDstMBlt;
    pfnDrvSrcBlt    = DL_DrvSrcBlt;
    pfnDrvSrcMBlt   = DL_DrvSrcMBlt;
    if (REVID_PRE65 & lpDDHALData->bRevInfoBits)
      pfnDrvStrBlt  = DL_DrvStrBlt;
    else
      pfnDrvStrBlt  = DL_DrvStrBlt65;
    pfnDrvStrMBlt   = DL_DrvStrMBlt;
    pfnDrvStrMBltY  = DL_DrvStrMBltY;
    pfnDrvStrMBltX  = DL_DrvStrMBltX;
    pfnDrvStrBltY   = DL_DrvStrBltY;
    pfnDrvStrBltX   = DL_DrvStrBltX;
#if ENABLE_CLIPPEDBLTS
    if (! (REVID_PRE65 & lpDDHALData->bRevInfoBits))
    {
      if (CL_GD5465 == LGDEVID)
      {
        pfnClippedDrvDstBlt  = DL_SWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_SWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_SWClippedDrvSrcBlt;
      }
      else
      {
        pfnClippedDrvDstBlt  = DL_HWClippedDrvDstBlt;
        pfnClippedDrvDstMBlt = DL_HWClippedDrvDstMBlt;
        pfnClippedDrvSrcBlt  = DL_HWClippedDrvSrcBlt;
      }
    }
#endif
#endif
  }
}
#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\blt_dl.c ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         blt_dl.c
*
* DESCRIPTION:  Display List blts for the 5464
*
* REVISION HISTORY:
*
* $Log:   X:\log\laguna\ddraw\src\blt_dl.c  $
* 
*    Rev 1.20   06 Jan 1998 15:20:04   xcong
* 
*    Rev 1.19   06 Jan 1998 11:56:22   xcong
* Change pDriverData into lpDDHALData for multi-monitor support.
*
*    Rev 1.18   03 Oct 1997 14:31:12   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.17   15 Sep 1997 17:25:14   RUSSL
* Fix for PDR 10493 - Minor parenthesis change
*
*    Rev 1.16   24 Jul 1997 12:32:40   RUSSL
* Botched the overlap check, changed || to &&
*
*    Rev 1.15   24 Jul 1997 11:20:16   RUSSL
* Added DL_DrvStrBlt_OverlapCheck & DL_DrvStrMBlt_OverlapCheck
* inline functions
*
*    Rev 1.14   17 Jul 1997 14:31:58   RUSSL
* Fixed my copy & paste errors in the DD_LOG and ASSERTs in DL_DrvStrBlt65
*
*    Rev 1.13   15 Jul 1997 16:19:50   eleland
* removed the increment-and-immediate decrement of display list
* pointer at the end of each blt display list
*
*    Rev 1.12   14 Jul 1997 14:59:52   RUSSL
* Added DL_DrvStrBlt65
*
*    Rev 1.11   02 Jul 1997 19:13:10   eleland
* added wait instruction after each dl blit
*
*    Rev 1.10   03 Apr 1997 15:05:30   RUSSL
* Added DL_DrvDstMBlt function
*
*    Rev 1.9   26 Mar 1997 13:55:22   RUSSL
* Added DL_DrvSrcMBlt function
*
*    Rev 1.8   12 Mar 1997 15:01:20   RUSSL
* replaced a block of includes with include of precomp.h for
*   precompiled headers
*
*    Rev 1.7   07 Mar 1997 12:50:40   RUSSL
* Modified DDRAW_COMPAT usage
*
*    Rev 1.6   11 Feb 1997 11:40:34   bennyn
* Fixed the compiling error for NT
*
*    Rev 1.5   07 Feb 1997 16:30:34   KENTL
* Never mind the #ifdefs. The problems are deeper than that. We'd need
* ifdefs around half the code in the file.
*
*    Rev 1.4   07 Feb 1997 16:18:58   KENTL
* Addd #ifdef's around include qmgr.h
*
*    Rev 1.3   07 Feb 1997 13:22:36   KENTL
* Merged in Evan Leland's modifications to get Display List mode working:
* 	* include qmgr.h
* 	* Invoke qmAllocDisplayList to get pDisplayList pointer.
* 	* Invoke qmExecuteDisplayList on completed DL's
*
*    Rev 1.2   23 Jan 1997 17:08:48   bennyn
* Modified naming of registers
*
*    Rev 1.1   25 Nov 1996 16:15:48   bennyn
* Fixed misc compiling error for NT
*
*    Rev 1.0   25 Nov 1996 15:14:02   RUSSL
* Initial revision.
*
*    Rev 1.2   18 Nov 1996 16:18:56   RUSSL
* Added file logging for DDraw entry points and register writes
*
*    Rev 1.1   01 Nov 1996 13:08:40   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:02   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 11:08:22   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/***************************************************************************
* I N C L U D E S
****************************************************************************/

#include "precomp.h"

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else  // !WINNT_VER35

#ifdef WINNT_VER40      // WINNT_VER40

#define DBGLVL        1
#define AFPRINTF(n)

#else  // !WINNT_VER40

#include "l3system.h"
#include "l2d.h"
#include "bltP.h"
#include "qmgr.h"

#endif   // !WINNT_VER40

/***************************************************************************
* S T A T I C   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
ASSERTFILE("blt_dl.c");
#endif

/***************************************************************************
*
* FUNCTION:    DL_Delay9BitBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_Delay9BitBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_Delay9BitBlt\r\n"));

  /* This is to ensure that the last packet of any previous blt */
  /* does no go out with 9th bit set incorrectly */
  /* The boolean paramter is the 9th bit of the PREVIOUS BLT */

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | ((BD_RES + BD_OP0 + BD_OP1 + BD_OP2)*IS_VRAM);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP0_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP0_copy;

  // OP0_RDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(lpDDHALData->PTAGFooPixel);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(lpDDHALData->PTAGFooPixel);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(1,1);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_Delay9BitBlt */

/***************************************************************************
*
* FUNCTION:     DL_EdgeFillBlt
*
* DESCRIPTION:  Solid Fill BLT to fill in edges ( Pixel Coords / Extents )
*
****************************************************************************/

void DL_EdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_EdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_RY_0 << 16) | LOWORD(yFill);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */

/***************************************************************************
*
* FUNCTION:     DL_MEdgeFillBlt
*
* DESCRIPTION:  Using BYTE BLT coords / Extents perform EdgeFill BLT
*
****************************************************************************/

void DL_MEdgeFillBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_MEdgeFillBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          MAKELONG(xFill,yFill),MAKELONG(cxFill,cyFill),FillValue));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | (BD_RES * IS_VRAM + BD_OP1 * IS_SOLID);
  if (ninebit_on)
    *pDisplayList++ = (C_DRWDEF << 16) | (DD_PTAG | ROP_OP1_copy);
  else
    *pDisplayList++ = (C_DRWDEF << 16) | ROP_OP1_copy;

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(FillValue);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(FillValue);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(xFill);
  *pDisplayList++ = (C_MRY_0 << 16) | LOWORD(yFill);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = MAKELONG(LOWORD(cxFill),LOWORD(cyFill));

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_EdgeFillBlt */


/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  DD_LOG(("DL_DrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  rc = qmAllocDisplayList(10*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcBlt(
#ifdef WINNT_VER40
                   ppdev,
#endif
                   lpDDHALData,
                   dwDrawBlt,
                   dwDstCoord+dwDelta,
                   dwSrcCoord+dwDelta,
                   dwKeyCoord+dwDelta,
                   dwKeyColor,
                   dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvSrcMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvSrcMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;

  // Handle overlapped regions.
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_DrvSrcMBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // Check for x overlap.
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0,-1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first.
      DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                    ppdev,
#endif
                    lpDDHALData,
                    dwDrawBlt,
                    dwDstCoord+dwDelta,
                    dwSrcCoord+dwDelta,
                    dwKeyCoord+dwDelta,
                    dwKeyColor,
                    dwExtents-dwDelta);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList(14*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opMRDRAM
  *pDisplayList++ = (C_MRX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_MRY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opMRDRAM
  *pDisplayList++ = (C_MRX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_MRY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // MBLTEXT_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
  *pDisplayList++ = dwExtents;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvSrcMBlt */

#if 0
/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opRDRAM.pt.X - pblt->OP1_opRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opRDRAM.pt.Y - pblt->OP1_opRDRAM.pt.Y);

  if ((xdelta < pblt->BLTEXT.pt.X) &&
      (ydelta < pblt->BLTEXT.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->MBLTEXT.DW has src exents

    // blt the src to the lower right of the dest
    DL_DrvSrcBlt(
#ifdef WINNT_VER40
                 ppdev,
                 lpDDHALData,
#endif
                 MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                 pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW,
                 pblt->OP1_opRDRAM.DW,
						     0UL,         // don't care
						     0UL,
                 pblt->MBLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opRDRAM.DW = pblt->OP0_opRDRAM.DW + pblt->BLTEXT.DW - pblt->MBLTEXT.DW;
  }
}
#endif

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt_OverlapCheck
*
* DESCRIPTION:
*
****************************************************************************/

static void INLINE DL_DrvStrMBlt_OverlapCheck
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
  int xdelta,ydelta;


  xdelta = abs(pblt->OP0_opMRDRAM.pt.X - pblt->OP1_opMRDRAM.pt.X);
  ydelta = abs(pblt->OP0_opMRDRAM.pt.Y - pblt->OP1_opMRDRAM.pt.Y);

  if ((xdelta < pblt->MBLTEXTR_EX.pt.X) &&
      (ydelta < pblt->MBLTEXTR_EX.pt.Y))
  {
    // hack, hack, cough, cough
    // pblt->BLTEXT.DW has src exents (see DrvStretch65)

    // blt the src to the lower right of the dest
    DL_DrvSrcMBlt(
#ifdef WINNT_VER40
                  ppdev,
#endif
                  lpDDHALData,
                  MAKELONG(ROP_OP1_copy, BD_RES * IS_VRAM | BD_OP1 * IS_VRAM),
                  pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW,
                  pblt->OP1_opMRDRAM.DW,
						      0UL,         // don't care
						      0UL,
                  pblt->BLTEXT.DW);

    // update the src ptr to use this copy of the src
    pblt->OP1_opMRDRAM.DW = pblt->OP0_opMRDRAM.DW + pblt->MBLTEXTR_EX.DW - pblt->BLTEXT.DW;
  }
}

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt
*
* DESCRIPTION:	 62/64 version
*
****************************************************************************/

void DL_DrvStrBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

#if 0
    // check for overlap
    DL_DrvStrBlt_OverlapCheck(
#ifdef WINNT_VER40
                              ppdev,lpDDHALData,
#endif
                              pblt);
#endif

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBlt65
*
* DESCRIPTION:  65+ version
*
****************************************************************************/

void DL_DrvStrBlt65
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBlt65 - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opMRDRAM.DW,pblt->MBLTEXTR_EX.DW,pblt->OP1_opMRDRAM.DW));

  ASSERT( pblt->MBLTEXTR_EX.pt.X != 0 );
  ASSERT( pblt->MBLTEXTR_EX.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBlt65:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opMRDRAM.PT.X, pblt->OP1_opMRDRAM.PT.Y,
               pblt->OP0_opMRDRAM.PT.X, pblt->OP0_opMRDRAM.PT.Y,
               pblt->MBLTEXTR_EX.PT.X, pblt->MBLTEXTR_EX.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->STRETCH_CNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_STRCTL << 16) | pblt->STRETCH_CNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0   << 16) | pblt->OP0_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0   << 16) | pblt->OP0_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1   << 16) | pblt->OP1_opMRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1   << 16) | pblt->OP1_opMRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  // MBLTEXTR_EX
  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->MBLTEXTR_EX.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DIR_DrvStrBlt65 */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_DrvStrMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBlt - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrMBlt:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

    // check for overlap
    DL_DrvStrMBlt_OverlapCheck(
#ifdef WINNT_VER40
                               ppdev,
#endif
                               lpDDHALData,
                               pblt);

  rc = qmAllocDisplayList(19*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 15, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBlt */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrMBltX
*
****************************************************************************/

void DL_DrvStrMBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltY - dst.Y=%04X dstext.Y=%04X src=%04X\r\n",
          pblt->OP0_opRDRAM.pt.Y,pblt->BLTEXT.pt.Y,pblt->OP1_opRDRAM.pt.Y));

  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DrvStrMBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(13*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 11, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_MRY_0  << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_MRY_1  << 16) | pblt->OP1_opRDRAM.pt.Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrMBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrMBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrMBltX - dst.X=%04X dstext.X=%04X src.X=%04X\r\n",
          pblt->OP0_opRDRAM.pt.X,pblt->BLTEXT.pt.X,pblt->OP1_opRDRAM.pt.X));

  ASSERT( pblt->BLTEXT.pt.X != 0 );

  DBG_MESSAGE(("DrvStrMBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(8*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_MRX_0  << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_MRX_1  << 16) | pblt->OP1_opRDRAM.pt.X;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrMBltX */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltY
*
* DESCRIPTION:  Write regs that don't vary over the stripes
*               Used in conjunction with DL_DrvStrBltX
*
****************************************************************************/

void DL_DrvStrBltY
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltY\r\n"));

  DBG_MESSAGE(("DL_DrvStrBltY:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(12*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 10, 0);

  *pDisplayList++ = (C_LNCNTL << 16) | pblt->LNCNTL.W;
  *pDisplayList++ = (C_SHINC  << 16) | pblt->SHRINKINC.W;
  *pDisplayList++ = (C_SRCX   << 16) | pblt->SRCX;
  *pDisplayList++ = (C_MAJX   << 16) | pblt->MAJ_X;
  *pDisplayList++ = (C_MINX   << 16) | pblt->MIN_X;
  *pDisplayList++ = (C_MAJY   << 16) | pblt->MAJ_Y;
  *pDisplayList++ = (C_MINY   << 16) | pblt->MIN_Y;
  *pDisplayList++ = (C_ACCUMY << 16) | pblt->ACCUM_Y;
  *pDisplayList++ = (C_BLTDEF << 16) | pblt->DRAWBLTDEF.lh.HI;
  *pDisplayList++ = (C_DRWDEF << 16) | pblt->DRAWBLTDEF.lh.LO;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltY */

/***************************************************************************
*
* FUNCTION:     DL_DrvStrBltX
*
* DESCRIPTION:  Write stripe specific regs
*               Used in conjunction with DL_DrvStrMBltY
*
****************************************************************************/

void DL_DrvStrBltX
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  autoblt_ptr pblt
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD   *pDisplayList;
  qm_return     rc;
  QMDLHandle    Handle;


  DD_LOG(("DL_DrvStrBltX - dst=%08lX dstext=%08lX src=%08lX\r\n",
          pblt->OP0_opRDRAM.DW,pblt->BLTEXT.DW,pblt->OP1_opRDRAM.DW));

  ASSERT( pblt->BLTEXT.pt.X != 0 );
  ASSERT( pblt->BLTEXT.pt.Y != 0 );

  DBG_MESSAGE(("DL_DrvStrBltX:  %4d,%4d -> %4d,%4d %4dx%4d %04x %4d %04x",
               pblt->OP1_opRDRAM.PT.X, pblt->OP1_opRDRAM.PT.Y,
               pblt->OP0_opRDRAM.PT.X, pblt->OP0_opRDRAM.PT.Y,
               pblt->BLTEXT.PT.X, pblt->BLTEXT.PT.Y,
               pblt->ACCUM_X, pblt->SRCX, pblt->LNCNTL.W));

  rc = qmAllocDisplayList(9*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 5, 0);

  *pDisplayList++ = (C_ACCUMX << 16) | pblt->ACCUM_X;
  *pDisplayList++ = (C_RX_0   << 16) | pblt->OP0_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_0   << 16) | pblt->OP0_opRDRAM.pt.Y;
  *pDisplayList++ = (C_RX_1   << 16) | pblt->OP1_opRDRAM.pt.X;
  *pDisplayList++ = (C_RY_1   << 16) | pblt->OP1_opRDRAM.pt.Y;

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXTR_EX, 1, 0);
  *pDisplayList++ = pblt->BLTEXT.DW;

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_DrvStrBltX */

#if ENABLE_CLIPPEDBLTS

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_HWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  rc = qmAllocDisplayList((10+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 8, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // OP0_opMRDRAM
  *pDisplayList++ = (C_MRX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_MRY_0 << 16) | HIWORD(dwDstCoord);

  // MBLTEXT
  *pDisplayList++ = (C_MBLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_MBLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);
    UpperLeft.pt.X  *= nBytesPixel;
    LowerRight.pt.X *= nBytesPixel;

    // write clipping regs
    // MCLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // MCLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MCLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_HWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_HWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // check for negative dst coordinates, hw can't deal with negative OP0 values
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.X)
  {
    // reduce extent.X
    (short)((REG32 *)&dwExtents)->pt.X += (short)((REG32 *)&dwDstCoord)->pt.X;
    // bump src.X to right
    (short)((REG32 *)&dwSrcCoord)->pt.X -= (short)((REG32 *)&dwDstCoord)->pt.X;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.X to right
      (short)((REG32 *)&dwKeyCoord)->pt.X -= (short)((REG32 *)&dwKeyCoord)->pt.X;
    // clear dst.X
    ((REG32 *)&dwDstCoord)->pt.X = 0;
  }
  if (0 > (short)((REG32 *)&dwDstCoord)->pt.Y)
  {
    // reduce extent.Y
    (short)((REG32 *)&dwExtents)->pt.Y += (short)((REG32 *)&dwDstCoord)->pt.Y;
    // bump src.Y down
    (short)((REG32 *)&dwSrcCoord)->pt.Y -= (short)((REG32 *)&dwDstCoord)->pt.Y;
    if ((DD_TRANS | DD_TRANSOP) & dwDrawBlt)
      // bump key.Y down
      (short)((REG32 *)&dwKeyCoord)->pt.Y -= (short)((REG32 *)&dwKeyCoord)->pt.Y;
    // clean dst.Y
    ((REG32 *)&dwDstCoord)->pt.Y = 0;
  }

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_HWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((14+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 12, 0);

  // setup blt, write BLTEXT reg with extent which doesn't fire off blt
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // OP0_opRDRAM
  *pDisplayList++ = (C_RX_0 << 16) | LOWORD(dwDstCoord);
  *pDisplayList++ = (C_RY_0 << 16) | HIWORD(dwDstCoord);

  // OP1_opRDRAM
  *pDisplayList++ = (C_RX_1 << 16) | LOWORD(dwSrcCoord);
  *pDisplayList++ = (C_RY_1 << 16) | HIWORD(dwSrcCoord);

  // OP2_opRDRAM
  *pDisplayList++ = (C_RX_2 << 16) | LOWORD(dwKeyCoord);
  *pDisplayList++ = (C_RY_2 << 16) | HIWORD(dwKeyCoord);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // BLTEXT
  *pDisplayList++ = (C_BLTEXT_X << 16) | LOWORD(dwExtents);
  *pDisplayList++ = (C_BLTEXT_Y << 16) | HIWORD(dwExtents);

  // loop over clip list
  do
  {
    REG32   UpperLeft;
    REG32   LowerRight;

    // compute cliprect coords
    UpperLeft.DW  = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    LowerRight.DW = dwDstBaseXY + MAKELONG(pDestRects->right, pDestRects->bottom);

    // write clipping regs
    // CLIPULE
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPULE, 1, 0);
    *pDisplayList++ = UpperLeft.DW;

    // CLIPLOR_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_CLIPLOR_EX, 1, 0);
    *pDisplayList++ = LowerRight.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_HWClippedDrvSrcBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvDstMBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  const int   nBytesPixel = BYTESPERPIXEL;
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;


  DD_LOG(("DL_SWClippedDrvDstMBlt - dst=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwExtents,dwBgColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  rc = qmAllocDisplayList((6+dwRectCnt*4)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwBgColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwBgColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;

    // compute cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.loc.pt.X *= nBytesPixel;
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left) * nBytesPixel;
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // write OP0 and bltext regs
    // OP0_opMRDRAM
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_OP0_OPMRDRAM, 1, 0);
    *pDisplayList++ = DstDDRect.loc.DW;

    // MBLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_MBLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvDstMBlt */

/***************************************************************************
*
* FUNCTION:     DL_SWClippedDrvSrcBlt
*
* DESCRIPTION:
*
****************************************************************************/

void DL_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  PDEV        *ppdev,
  DRIVERDATA  *lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
)
{
#ifdef WINNT_VER40      // WINNT_VER40
#else  // !WINNT_VER40
  DWORD       *pDisplayList;
  qm_return   rc;
  QMDLHandle  Handle;

  // Handle overlapped regions
  const int xDelta = (int)LOWORD(dwDstCoord) - (int)LOWORD(dwSrcCoord);


  DD_LOG(("DL_SWClippedDrvSrcBlt - dst=%08lX src=%08lX ext=%08lX color=%08lX\r\n",
          dwDstCoord,dwSrcCoord,dwExtents,dwKeyColor));

  // make sure DD_CLIP isn't set in drawdef
  dwDrawBlt &= ~DD_CLIP;

  // Check for x overlap
  if ( abs(xDelta) < (int)LOWORD(dwExtents) )
  {
    const int yDelta = (int)HIWORD(dwDstCoord) - (int)HIWORD(dwSrcCoord);

    if ( (yDelta > 0) && (yDelta < (int)HIWORD(dwExtents)) )
    {
      const DWORD dwDelta = (dwExtents & MAKELONG(0, -1)) - MAKELONG(0, 1);

      // Convert to a bottom-up blt.
      dwDrawBlt  |= MAKELONG(0, BD_YDIR);
      dwDstCoord += dwDelta;
      dwSrcCoord += dwDelta;
      dwKeyCoord += dwDelta;
    }
    // are we sliding to the right?
    else if ( (xDelta > 0) && (yDelta == 0) )
    {
      const DWORD dwDelta = MAKELONG(xDelta, 0);

      // Blt the overlapped piece first
      DL_SWClippedDrvSrcBlt(
#ifdef WINNT_VER40
                            ppdev,
                            lpDDHALData,
#endif
                            dwDrawBlt,
                            dwDstCoord+dwDelta,
                            dwSrcCoord+dwDelta,
                            dwKeyCoord+dwDelta,
                            dwKeyColor,
                            dwExtents-dwDelta,
                            dwDstBaseXY,
                            dwSrcBaseXY,
                            dwRectCnt,
                            pDestRects);

      // Subtract the overlap from the original extents.
      dwExtents = MAKELONG(xDelta, HIWORD(dwExtents));
    }
  }

  rc = qmAllocDisplayList((6+dwRectCnt*9)*4, QM_DL_UNLOCKED, &Handle, &pDisplayList);

  *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 4, 0);

  // write regs that don't vary over rectangles
  // BLTDEF & DRAWDEF
  *pDisplayList++ = (C_BLTDEF << 16) | HIWORD(dwDrawBlt);
  *pDisplayList++ = (C_DRWDEF << 16) | LOWORD(dwDrawBlt);

  // BGCOLOR
  *pDisplayList++ = (C_BG_L << 16) | LOWORD(dwKeyColor);
  *pDisplayList++ = (C_BG_H << 16) | HIWORD(dwKeyColor);

  // loop over clip list
  do
  {
    DDRECTL   DstDDRect;
    DDRECTL   SrcDDRect;

    // compute dst cliprect coords
    DstDDRect.loc.DW = dwDstBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    DstDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    DstDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    // compute src cliprect coords
    SrcDDRect.loc.DW = dwSrcBaseXY + MAKELONG(pDestRects->left,  pDestRects->top);
    // don't care about src extent, it's the same as dst extent
    //SrcDDRect.ext.pt.X = (WORD)(pDestRects->right - pDestRects->left);
    //SrcDDRect.ext.pt.Y = (WORD)(pDestRects->bottom - pDestRects->top);

    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, COMMAND_2D, 6, 0);

    // write OP0, OP1, OP2 and bltext regs
    if ((DD_TRANS | DD_TRANSOP) == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // dst color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | DstDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | DstDDRect.loc.pt.Y;
    }
    else if (DD_TRANS == ((DD_TRANS | DD_TRANSOP) & dwDrawBlt))
    {
      // src color key
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | SrcDDRect.loc.pt.X;
      *pDisplayList++ = (C_RY_2 << 16) | SrcDDRect.loc.pt.Y;
    }
    else
    {
      // OP2_opRDRAM
      *pDisplayList++ = (C_RX_2 << 16) | 0;
      *pDisplayList++ = (C_RY_2 << 16) | 0;
    }

    // OP0_opRDRAM
    *pDisplayList++ = (C_RX_0 << 16) | DstDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_0 << 16) | DstDDRect.loc.pt.Y;

    // OP1_opRDRAM
    *pDisplayList++ = (C_RX_1 << 16) | SrcDDRect.loc.pt.X;
    *pDisplayList++ = (C_RY_1 << 16) | SrcDDRect.loc.pt.Y;

    // BLTEXT_EX
    *pDisplayList++ = write_dev_regs(DEV_ENG2D, 0, L2D_BLTEXT_EX, 1, 0);
    *pDisplayList++ = DstDDRect.ext.DW;

    pDestRects++;
  } while (0 < --dwRectCnt);

  *pDisplayList = wait_3d(0x3e0, 0);

  rc = qmExecuteDisplayList(Handle, pDisplayList, 0);
#endif   // !WINNT_VER40
} /* DL_SWClippedDrvSrcBlt */

#endif  // ENABLE_CLIPPEDBLTS

#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\color.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: color.c
 *
 * This algorithm for color dithering is patent pending and its use is
 * restricted to Microsoft products and drivers for Microsoft products.
 * Use in non-Microsoft products or in drivers for non-Microsoft product is
 * prohibited without written permission from Microsoft.
 *
 * The patent application is the primary reference for the operation of the
 * color dithering code.
 *
 * Note that in the comments and variable names, "vertex" means "vertex of
 * either the inner (half intensity) or outer (full intensity) color cube."
 * Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
 * 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
 * color cube, and 0 plus 249-255 are the vertices of the full color cube.
 * Vertex 7 is 75% gray; this could be used in the dither, but that would break
 * apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
 * compatible.
 *
 * Copyright (c) 1992 Microsoft Corporation
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/COLOR.C  $
* 
*    Rev 1.4   20 Aug 1996 11:03:18   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 11:44:24   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:16   frido
* Initial revision.
* 
*    Rev 1.3   05 Mar 1996 11:57:44   noelv
* Frido version 19
 * 
 *    Rev 1.2   03 Feb 1996 13:36:14   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.1   20 Jan 1996 22:14:52   frido
 * Moved the colored dithering to a seperate routine for the new dither cache.
 *
\**************************************************************************/

#include "precomp.h"

#ifndef frido
  #define frido 1
#endif

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
	PALETTEENTRY pal;
	ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
	ULONG ulCount;  // # of pixels in this vertex
	ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7,
	0, 4, 0, 4, 2, 6, 2, 6,
	0, 4, 0, 4, 2, 6, 2, 6,
	1, 5, 1, 5, 3, 7, 3, 7,
	1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
	0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
	0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
	0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
	0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
	0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
	0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
	0x00000000,
	0x01010101,
	0x02020202,
	0x03030303,
	0x04040404,
	0x05050505,
	0x06060606,
	0xF8F8F8F8,
	0x07070707,
	0xF9F9F9F9,
	0xFAFAFAFA,
	0xFBFBFBFB,
	0xFCFCFCFC,
	0xFDFDFDFD,
	0xFEFEFEFE,
	0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	248,
	7,
	249,
	250,
	251,
	252,
	253,
	254,
	255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
	ULONG   ulGrey, ulRed, ulGreen, ulBlue;

	// Figure out if we need a full color dither or only a monochrome dither
	if (iMode != DM_MONOCHROME)
	{
		// Full color dither
		#if !frido
		/*
		 *	I have moved all code here to a seperate routine for faster dither
		 *	realization. It doesn't effect the original code so I just keep it
		 *	split.
		 */
		#endif
		vDitherColor(rgb, pul);
	}
	else
	{
		// For monochrome we will only use the Intensity (grey level)
		RtlFillMemory((PVOID) pul, PATTERNSIZE / 2, 0); // zero the dither bits

		ulRed	= (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
		ulGreen	= (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
		ulBlue	= (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

		// I = .30R + .59G + .11B
		// For convience the following ratios are used:
		//
		//  77/256 = 30.08%
		// 151/256 = 58.98%
		//  28/256 = 10.94%

		ulGrey = (((ulRed * 77) + (ulGreen * 151) + (ulBlue * 28)) >> 8) & 255;

		// Convert the RGBI from 0-255 to 0-64 notation.

		ulGrey = (ulGrey + 1) >> 2;

		while(ulGrey)
		{
			ulGrey--;
			pul[ajByte[ulGrey]] |= (ULONG) ajBits[ulGrey];
		}
	}

	return(DCR_DRIVER);
}

VOID vDitherColor(ULONG rgb, ULONG *pul)
{
	ULONG		ulRed, ulGreen, ulBlue, ulSymmetry;
	ULONG		ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
	VERTEX_DATA	vVertexData[4];
	VERTEX_DATA	*pvVertexData;
	VERTEX_DATA	*pvVertexDataEnd;
	ULONG		*pulDitherOrder;
	ULONG		ulNumPixels;
	BYTE		jColor;
	ULONG		ulColor;
	VERTEX_DATA	*pvMaxVertex;
	ULONG		ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
	BYTE		*pjDither = (BYTE *)pul;
	int			i;

	// Split the color into red, green, and blue components
	ulRedTemp	= ((PAL_ULONG *) &rgb)->pal.peRed;
	ulGreenTemp	= ((PAL_ULONG *) &rgb)->pal.peGreen;
	ulBlueTemp	= ((PAL_ULONG *) &rgb)->pal.peBlue;

	// Sort the RGB so that the point is transformed into subspace 0, and
	// keep track of the swaps in ulSymmetry so we can unravel it again
	// later.  We want r >= g >= b (subspace 0).
	ulSymmetry = 0;
	if (ulBlueTemp > ulRedTemp)
	{
		SWAPTHEM(ulBlueTemp,ulRedTemp);
		ulSymmetry = SWAP_RB;
	}

	if (ulBlueTemp > ulGreenTemp)
	{
		SWAPTHEM(ulBlueTemp,ulGreenTemp);
		ulSymmetry |= SWAP_GB;
	}

	if (ulGreenTemp > ulRedTemp)
	{
		SWAPTHEM(ulGreenTemp,ulRedTemp);
		ulSymmetry |= SWAP_RG;
	}

	ulSymmetry <<= 4;   // for lookup purposes

	// Scale the values from 0-255 to 0-64. Note that the scaling is not
	// symmetric at the ends; this is done to match Windows 3.1 dithering
	ulRed	= (ulRedTemp + 1) >> 2;
	ulGreen	= (ulGreenTemp + 1) >> 2;
	ulBlue	= (ulBlueTemp + 1) >> 2;

	// Compute the subsubspace within subspace 0 in which the point lies,
	// then calculate the # of pixels to dither in the colors that are the
	// four vertexes of the tetrahedron bounding the color we're emulating.
	// Only vertices with more than zero pixels are stored, and the
	// vertices are stored in order of increasing intensity, saving us the
	// need to sort them later
	if ((ulRedTemp + ulGreenTemp) > 256)
	{
		// Subsubspace 2 or 3
		if ((ulRedTemp + ulBlueTemp) > 256)
		{
			// Subsubspace 3
			// Calculate the number of pixels per vertex, still in
			// subsubspace 3, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 3 is:
			// 7, 9, 0x0B, 0x0F
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (64 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			ulVertex2Temp = ulGreen - ulBlue;
			ulVertex3Temp = (ulRed - 64) + ulBlue;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
			}
		}
		else
		{
			// Subsubspace 2
			// Calculate the number of pixels per vertex, still in
			// subsubspace 2, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 2 is:
			// 3, 7, 9, 0x0B
			pvVertexData = vVertexData;
			ulVertex1Temp = ulBlue << 1;
			ulVertex2Temp = ulRed - ulGreen;
			ulVertex3Temp = (ulRed - 32) + (ulGreen - 32);
			if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex1Temp != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
			}
		}
	}
	else
	{
		// Subsubspace 0 or 1
		if (ulRedTemp > 128)
		{
			// Subsubspace 1
			// Calculate the number of pixels per vertex, still in
			// subsubspace 1, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 1 is:
			// 1, 3, 7, 9
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = ((32 - ulGreen) + (32 - ulRed)) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex2Temp = ulBlue << 1;
			ulVertex3Temp = (ulRed - 32) << 1;
			if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex2Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex2Temp != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
			}
		}
		else
		{
			// Subsubspace 0
			// Calculate the number of pixels per vertex, still in
			// subsubspace 0, then convert to original subspace. The pixel
			// counts and vertex numbers are matching pairs, stored in
			// ascending intensity order, skipping vertices with zero
			// pixels. The vertex intensity order for subsubspace 0 is:
			// 0, 1, 3, 7
			pvVertexData = vVertexData;
			if ((ulVertex0Temp = (32 - ulRed) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex0Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
			}
			if ((ulVertex1Temp = (ulRed - ulGreen) << 1) != 0)
			{
				pvVertexData->ulCount = ulVertex1Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
			}
			ulVertex3Temp = ulBlue << 1;
			if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
					ulVertex1Temp) - ulVertex3Temp) != 0)
			{
				pvVertexData->ulCount = ulVertex2Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
			}
			if (ulVertex3Temp != 0)
			{
				pvVertexData->ulCount = ulVertex3Temp;
				pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
			}
		}
	}

	// Now that we have found the bounding vertices and the number of
	// pixels to dither for each vertex, we can create the dither pattern

	// Handle 1, 2, and 3 & 4 vertices per dither separately
	ulTemp = pvVertexData - vVertexData;	// # of vertices with more than
											// zero pixels
	if (ulTemp > 2)
	{
		// There are 3 or 4 vertices in this dither

		if (ulTemp == 3)
		{
			// There are 3 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[1].ulCount >= vVertexData[2].ulCount)
			{
				pvMaxVertex = &vVertexData[1];
				ulTemp = vVertexData[1].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
		}
		else
		{
			// There are 4 vertices in this dither

			// Find the vertex with the most pixels, and fill the whole
			// destination bitmap with that vertex's color, which is faster
			// than dithering it
			if (vVertexData[2].ulCount >= vVertexData[3].ulCount)
			{
				pvMaxVertex = &vVertexData[2];
				ulTemp = vVertexData[2].ulCount;
			}
			else
			{
				pvMaxVertex = &vVertexData[3];
				ulTemp = vVertexData[3].ulCount;
			}
		}

		if (vVertexData[1].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[1];
			ulTemp = vVertexData[1].ulCount;
		}
		if (vVertexData[0].ulCount > ulTemp)
		{
			pvMaxVertex = &vVertexData[0];
		}

		pvVertexDataEnd = pvVertexData;

		// Prepare a dword version of the most common vertex number (color)
		ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

		// Mark that the vertex we're about to do doesn't need to be done
		// later
		pvMaxVertex->ulVertex = 0xFF;

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Now dither all the remaining vertices in order 0->2 or 0->3
		// (in order of increasing intensity)
		pulDitherOrder = aulDitherOrder;
		pvVertexData = vVertexData;
		do
		{
			if (pvVertexData->ulVertex == 0xFF)
			{
				// This is the max vertex, which we already did, but we
				// have to account for it in the dither order
				pulDitherOrder += pvVertexData->ulCount;
			}
			else
			{
				jColor = ajConvert[pvVertexData->ulVertex];
				ulNumPixels = pvVertexData->ulCount;
				switch (ulNumPixels & 3)
				{
					case 3:
						pjDither[*(pulDitherOrder+2)] = jColor;

					case 2:
						pjDither[*(pulDitherOrder+1)] = jColor;

					case 1:
						pjDither[*(pulDitherOrder+0)] = jColor;
						pulDitherOrder += ulNumPixels & 3;

					case 0:
						break;
				}
				if ((ulNumPixels >>= 2) != 0)
				{
					do
					{
						pjDither[*pulDitherOrder] = jColor;
						pjDither[*(pulDitherOrder+1)] = jColor;
						pjDither[*(pulDitherOrder+2)] = jColor;
						pjDither[*(pulDitherOrder+3)] = jColor;
						pulDitherOrder += 4;
					}
					while (--ulNumPixels);
				}
			}
		}
		while (++pvVertexData < pvVertexDataEnd);
	}
	else if (ulTemp == 2)
	{
		// There are exactly two vertices with more than zero pixels; fill
		// in the dither array as follows: block fill with vertex with more
		// points first, then dither in the other vertex
		if (vVertexData[0].ulCount >= vVertexData[1].ulCount)
		{
			// There are no more vertex 1 than vertex 0 pixels, so do
			// the block fill with vertex 0
			ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
			// Do the dither with vertex 1
			jColor = ajConvert[vVertexData[1].ulVertex];
			ulNumPixels = vVertexData[1].ulCount;
			// Set where to start dithering with vertex 1 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
		}
		else
		{
			// There are more vertex 1 pixels, so do the block fill
			// with vertex 1
			ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
			// Do the dither with vertex 0
			jColor = ajConvert[vVertexData[0].ulVertex];
			ulNumPixels = vVertexData[0].ulCount;
			// Set where to start dithering with vertex 0 (vertex 0 is
			// lower intensity, so its pixels come first in the dither
			// order)
			pulDitherOrder = aulDitherOrder;
		}

		// Block fill the dither pattern with the more common vertex
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}

		// Dither in the less common vertex
		switch (ulNumPixels & 3)
		{
			case 3:
				pjDither[*(pulDitherOrder+2)] = jColor;

			case 2:
				pjDither[*(pulDitherOrder+1)] = jColor;

			case 1:
				pjDither[*(pulDitherOrder+0)] = jColor;
				pulDitherOrder += ulNumPixels & 3;

			case 0:
				break;
		}
		if ((ulNumPixels >>= 2) != 0)
		{
			do
			{
				pjDither[*pulDitherOrder] = jColor;
				pjDither[*(pulDitherOrder+1)] = jColor;
				pjDither[*(pulDitherOrder+2)] = jColor;
				pjDither[*(pulDitherOrder+3)] = jColor;
				pulDitherOrder += 4;
			}
			while (--ulNumPixels);
		}
	}
	else
	{
		// There is only one vertex in this dither

		// No sorting or dithering is needed for just one color; we can
		// just generate the final DIB directly
		ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
		for (i = 0; i < 16; i++)
		{
			pul[i] = ulColor;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\ddflip.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddflip.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw FLIP components
*           for the Laguna NT driver.
*
* MODULES:
*           vGetDisplayDuration()
*           vUpdateFlipStatus()
*           DdFlip()
*           DdWaitForVerticalBlank()
*           DdGetFlipStatus()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddflip.c  $
* 
*    Rev 1.10   16 Sep 1997 15:04:06   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.9   29 Aug 1997 17:42:20   RUSSL
* Added 65 overlay support
*
*    Rev 1.8   11 Aug 1997 14:07:58   bennyn
*
* Enabled GetScanLine() (for PDR 10254)
*
****************************************************************************
****************************************************************************/
/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

#define CSL           0x00C4
#define CSL_5464      0x0140

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
// CurrentVLine is in ddinline.h for overlay
#else
/***************************************************************************
*
* FUNCTION:     CurrentVLine
*
* DESCRIPTION:
*
****************************************************************************/
static __inline int CurrentVLine (PDEV* ppdev)
{
  WORD   cline;
  PBYTE  pMMReg = (PBYTE) ppdev->pLgREGS_real;
  PWORD  pCSL;
  BYTE   tmpb;


  // on 5462 there is no CurrentScanLine register
  // on RevAA of 5465 it's busted
  if ((CL_GD5462 == ppdev->dwLgDevID) ||
     ((CL_GD5465 == ppdev->dwLgDevID) && (0 == ppdev->dwLgDevRev)))
     return 0;

  if (IN_VBLANK)
     return 0;

  // read current scanline
  if (ppdev->dwLgDevID == CL_GD5464)
     pCSL = (PWORD) (pMMReg + CSL_5464);
  else
     pCSL = (PWORD) (pMMReg + CSL);

  cline = *pCSL & 0x0FFF;

  // if scanline doubling is enabled, divide current scanline by 2
  tmpb = (BYTE) LLDR_SZ (grCR9);
  if (0x80 & tmpb)
     cline /= 2;

  // if current scanline is past end of visible screen return 0
  if (cline >= ppdev->cyScreen)
    return 0;
  else
    return cline;
}
#endif

/****************************************************************************
* FUNCTION NAME: vGetDisplayDuration
*
* DESCRIPTION:   Get the length, in EngQueryPerformanceCounter() ticks,
*                of a refresh cycle.
*                (Based on S3 DirectDraw code)
****************************************************************************/
#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(PFLIPRECORD pflipRecord)
{
  LONG        i,  j;
  LONGLONG    li, liMin;
  LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

  DISPDBG((DBGLVL, "DDraw - vGetDisplayDuration\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  memset(pflipRecord, 0, sizeof(FLIPRECORD));

  // Warm up EngQUeryPerformanceCounter to make sure it's in the working set
  EngQueryPerformanceCounter(&li);

  // Unfortunately, since NT is a proper multitasking system, we can't
  // just disable interrupts to take an accurate reading.  We also can't
  // do anything so goofy as dynamically change our thread's priority to
  // real-time.
  //
  // So we just do a bunch of short measurements and take the minimum.
  //
  // It would be 'okay' if we got a result that's longer than the actual
  // VBlank cycle time -- nothing bad would happen except that the app
  // would run a little slower.  We don't want to get a result that's
  // shorter than the actual VBlank cycle time -- that could cause us
  // to start drawing over a frame before the Flip has occured.
  while(IN_VBLANK);
  while(IN_DISPLAY);

  for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    // We're at the start of the VBlank active cycle!
    EngQueryPerformanceCounter(&aliMeasurement[i]);

    // Okay, so life in a multi-tasking environment isn't all that
    // simple.  What if we had taken a context switch just before
    // the above EngQueryPerformanceCounter call, and now were half
    // way through the VBlank inactive cycle?  Then we would measure
    // only half a VBlank cycle, which is obviously bad.  The worst
    // thing we can do is get a time shorter than the actual VBlank
    // cycle time.
    //
    // So we solve this by making sure we're in the VBlank active
    // time before and after we query the time.  If it's not, we'll
    // sync up to the next VBlank (it's okay to measure this period --
    // it will be guaranteed to be longer than the VBlank cycle and
    // will likely be thrown out when we select the minimum sample).
    // There's a chance that we'll take a context switch and return
    // just before the end of the active VBlank time -- meaning that
    // the actual measured time would be less than the true amount --
    // but since the VBlank is active less than 1% of the time, this
    // means that we would have a maximum of 1% error approximately
    // 1% of the times we take a context switch.  An acceptable risk.
    //
    // This next line will cause us wait if we're no longer in the
    // VBlank active cycle as we should be at this point:
    while(IN_DISPLAY);

    for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
    {
      while(IN_VBLANK);
      while(IN_DISPLAY);
    };
  };

  EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

  // Use the minimum:
  liMin = aliMeasurement[1] - aliMeasurement[0];

  for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
  {
    li = aliMeasurement[i] - aliMeasurement[i - 1];

    if (li < liMin)
       liMin = li;
  };

  // Round the result:
  pflipRecord->liFlipDuration
      = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;

  pflipRecord->liFlipTime = aliMeasurement[NUM_MEASUREMENTS_TO_TAKE];
  pflipRecord->bFlipFlag  = FALSE;
  pflipRecord->fpFlipFrom = 0;
} // getDisplayDuration


/****************************************************************************
* FUNCTION NAME: vUpdateFlipStatus
*
* DESCRIPTION:   Checks and sees if the most recent flip has occurred.
*                (Based on S3 DirectDraw code)
****************************************************************************/
HRESULT vUpdateFlipStatus(PFLIPRECORD pflipRecord, FLATPTR fpVidMem)
{
  LONGLONG liTime;

  DISPDBG((DBGLVL, "DDraw - vUpdateFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  // see if a flip has happened recently
  if ((pflipRecord->bFlipFlag) &&
      ((fpVidMem == 0xFFFFFFFF) || (fpVidMem == pflipRecord->fpFlipFrom)))
  {
    if ((IN_VBLANK))
    {
       if (pflipRecord->bWasEverInDisplay)
          pflipRecord->bHaveEverCrossedVBlank = TRUE;
    }
    else if (!(IN_DISPLAYENABLE))
    {
       if (pflipRecord->bHaveEverCrossedVBlank)
       {
          pflipRecord->bFlipFlag = FALSE;

          return(DD_OK);
       };
       pflipRecord->bWasEverInDisplay = TRUE;
    };

    EngQueryPerformanceCounter(&liTime);

    if (liTime - pflipRecord->liFlipTime <= pflipRecord->liFlipDuration)
    {
        return(DDERR_WASSTILLDRAWING);
    };

    pflipRecord->bFlipFlag = FALSE;
  };

  return(DD_OK);
} // updateFlipStatus


/****************************************************************************
* FUNCTION NAME: DdFlip
*
* DESCRIPTION:
*                (Based on S3 DirectDraw code)
****************************************************************************/
DWORD DdFlip(PDD_FLIPDATA lpFlip)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;

  ULONG       ulMemoryOffset;
  ULONG       ulLowOffset;
  ULONG       ulMiddleOffset;
  ULONG       ulHighOffset;
  BYTE        tmpb;

  DISPDBG((DBGLVL, "DDraw - DdFlip\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpFlip->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpFlip->lpSurfCurr->ddsCaps.dwCaps)
    return pDriverData->OverlayTable.pfnFlip(ppdev,lpFlip);
#endif

  // Is the current flip still in progress?
  // Don't want a flip to work until after the last flip is done,
  // so we ask for the general flip status.
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);

  if ((ddrval != DD_OK) || (DrawEngineBusy(pDriverData)))
  {
     lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // everything is OK, do the flip here
  {
    DWORD dwOffset;

    // Determine the offset to the new area.
    dwOffset = lpFlip->lpSurfTarg->lpGbl->fpVidMem >> 2;

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:
    while (IN_DISPLAYENABLE)
        ;

    // Flip the primary surface by changing CRD, CRC, CR1B and CR1D
    // Do CRD last because the start address is double buffered and
    // will take effect after CRD is updated.

    // need bits 19 & 20 of address in bits 3 & 4 of CR1D
    tmpb = (BYTE) LLDR_SZ (grCR1D);
    tmpb = (tmpb & ~0x18) | (BYTE3FROMDWORD(dwOffset) & 0x18);
    LL8(grCR1D, tmpb);

    // need bits 16, 17 & 18 of address in bits 0, 2 & 3 of CR1B
	 tmpb = (BYTE) LLDR_SZ (grCR1B);
    tmpb = (tmpb & ~0x0D) |
           ((((BYTE3FROMDWORD(dwOffset) & 0x06) << 1) |
              (BYTE3FROMDWORD(dwOffset) & 0x01)));
    LL8(grCR1B, tmpb);

    // bits 8-15 of address go in CRC
    LL8(grCRC, BYTE2FROMDWORD(dwOffset));
    // bits 0-7 of address go in CRD
    LL8(grCRD, BYTE1FROMDWORD(dwOffset));
  };

  // remember where/when we were when we did the flip
  EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

  ppdev->flipRecord.bFlipFlag              = TRUE;
  ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
  ppdev->flipRecord.bWasEverInDisplay      = FALSE;

  ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

  lpFlip->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
} // Flip


/****************************************************************************
* FUNCTION NAME: DdWaitForVerticalBlank
*
* DESCRIPTION:
****************************************************************************/
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
  PDEV*  ppdev;

  DISPDBG((DBGLVL, "DDraw - DdWaitForVerticalBlank\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;

  lpWaitForVerticalBlank->ddRVal = DD_OK;

  switch (lpWaitForVerticalBlank->dwFlags)
  {
    case DDWAITVB_I_TESTVB:
      // If TESTVB, it's just a request for the current vertical blank
      // status:
      lpWaitForVerticalBlank->bIsInVB = IN_VBLANK;
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:
      // If BLOCKBEGIN is requested, we wait until the vertical blank
      // is over, and then wait for the display period to end:
      while(IN_VBLANK);
      while(IN_DISPLAY);
      return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:
      // If BLOCKEND is requested, we wait for the vblank interval to end:
      while(IN_DISPLAY);
      while(IN_VBLANK);
      return(DDHAL_DRIVER_HANDLED);

    default:
      return DDHAL_DRIVER_NOTHANDLED;
  };  // end switch

  return(DDHAL_DRIVER_NOTHANDLED);
} // WaitForVerticalBlank


/****************************************************************************
* FUNCTION NAME: DdGetFlipStatus
*
* DESCRIPTION:   If the display has gone through one refresh cycle since
*                the flip occurred, we return DD_OK.  If it has not gone
*                through one refresh cycle we return DDERR_WASSTILLDRAWING
*                to indicate that this surface is still busy "drawing" the
*                flipped page. We also return DDERR_WASSTILLDRAWING if the
*                bltter is busy and the caller wanted to know if they could
*                flip yet.
****************************************************************************/
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
  DRIVERDATA* pDriverData;
  PDEV*  ppdev;

  ppdev = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DdGetFlipStatus\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpGetFlipStatus->lpDDSurface->ddsCaps.dwCaps)
  {
    DWORD   dwVWIndex;
    LP_SURFACE_DATA  pSurfaceData = (LP_SURFACE_DATA) lpGetFlipStatus->lpDDSurface->dwReserved1;

    dwVWIndex = GetVideoWindowIndex(pSurfaceData->dwOverlayFlags);

    lpGetFlipStatus->ddRVal =
        pDriverData->OverlayTable.pfnGetFlipStatus(ppdev,
                                                   lpGetFlipStatus->lpDDSurface->lpGbl->fpVidMem,
                                                   dwVWIndex);
  }
  else
#endif
  {
    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status.
    lpGetFlipStatus->ddRVal = vUpdateFlipStatus(&ppdev->flipRecord, 0xFFFFFFFF);
  }

  // Check if the bltter is busy if someone wants to know if they can flip
  if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
  {
     if ((lpGetFlipStatus->ddRVal == DD_OK) && DrawEngineBusy(pDriverData))
        lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
  }

  return(DDHAL_DRIVER_HANDLED);

} // GetFlipStatus


// #ifdef  DDDRV_GETSCANLINE  /************/
/****************************************************************************
* FUNCTION NAME: GetScanLine
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD GetScanLine(PDD_GETSCANLINEDATA lpGetScanLine)
{
  PDEV*   ppdev;

  ppdev  = (PDEV*) lpGetScanLine->lpDD->dhpdev;

  // If a vertical blank is in progress the scan line is in
  // indeterminant. If the scan line is indeterminant we return
  // the error code DDERR_VERTICALBLANKINPROGRESS.
  // Otherwise we return the scan line and a success code

  SYNC_W_3D(ppdev);   // if 3D context(s) active, make sure 3D engine idle before continuing...

  if (IN_VBLANK)
  {
     lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
  }
  else
  {
     lpGetScanLine->dwScanLine = CurrentVLine(ppdev);
     lpGetScanLine->ddRVal = DD_OK;
  };

  return DDHAL_DRIVER_HANDLED;

} // GetScanLine

// #endif // DDDRV_GETSCANLINE ************

#endif // ! ver 3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\ddraw.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddraw.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw components for the
*           Laguna NT driver.
*
* MODULES:
*           DdMapMemory()
*           DrvGetDirectDrawInfo()
*           DrvEnableDirectDraw()
*           DrvDisableDirectDraw()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddraw.c  $
* 
*    Rev 1.25   Apr 16 1998 15:19:50   frido
* PDR#11160. The hardware is broken converting 16-bit YUV to 24-bit RGB.
* 
*    Rev 1.24   16 Sep 1997 15:01:24   bennyn
* 
* Modified for NT DD overlay
* 
*    Rev 1.23   29 Aug 1997 17:11:54   RUSSL
* Added overlay support
*
*    Rev 1.22   12 Aug 1997 16:57:10   bennyn
*
* Moved the DD scratch buffer allocation to bInitSurf()
*
*    Rev 1.21   11 Aug 1997 14:06:10   bennyn
* Added DDCAPS_READSCANLINE support (For PDR 10254)
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"
//#include <driver.h>
//#include "laguna.h"

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

// FourCC formats are encoded in reverse because we're little endian:
#define FOURCC_YUY2  '2YUY'  // Encoded in reverse because we're little endian

#define SQXINDEX (0x3c4)
#define RDRAM_INDEX (0x0a)
#define BIT_9 (0x80)

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

/****************************************************************************
* FUNCTION NAME: DdMapMemory
*
* DESCRIPTION:   This is a new DDI call specific to Windows NT that is
*                used to map or unmap all the application modifiable
*                portions of the frame buffer into the specified process's
*                address space.
****************************************************************************/
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
  PDEV*                           ppdev;
  VIDEO_SHARE_MEMORY              ShareMemory;
  VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
  DWORD                           ReturnedDataLength;

  ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdMapMemory\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ShareMemory.ProcessHandle = lpMapMemory->hProcess;

  if (lpMapMemory->bMap)
  {
     // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:
     ShareMemory.RequestedVirtualAddress = 0;

     // We map in starting at the top of the frame buffer:
     ShareMemory.ViewOffset = 0;

     // We map down to the end of the frame buffer.
     //
     // Note: There is a 64k granularity on the mapping (meaning that
     //       we have to round up to 64k).
     //
     // Note: If there is any portion of the frame buffer that must
     //       not be modified by an application, that portion of memory
     //       MUST NOT be mapped in by this call.  This would include
     //       any data that, if modified by a malicious application,
     //       would cause the driver to crash.  This could include, for
     //       example, any DSP code that is kept in off-screen memory.

// v-normmi
// ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDeltaScreen);
   ShareMemory.ViewSize = ROUND_UP_TO_64K(ppdev->cyMemoryReal * ppdev->lDeltaScreen);

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            &ShareMemoryInformation,
                            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));

         lpMapMemory->ddRVal = DDERR_GENERIC;
         return(DDHAL_DRIVER_HANDLED);
     };

     lpMapMemory->fpProcess = (DWORD) ShareMemoryInformation.VirtualAddress;
  }
  else
  {
     ShareMemory.ViewOffset    = 0;
     ShareMemory.ViewSize      = 0;
     ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

     if (EngDeviceIoControl(ppdev->hDriver,
                            IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                            &ShareMemory,
                            sizeof(VIDEO_SHARE_MEMORY),
                            NULL,
                            0,
                            &ReturnedDataLength))
     {
         DISPDBG((0, "DDraw - Failed IOCTL_VIDEO_SHARE_MEMORY"));
     };
  };

  lpMapMemory->ddRVal = DD_OK;

  return(DDHAL_DRIVER_HANDLED);
}


/****************************************************************************
* FUNCTION NAME: DrvGetDirectDrawInfo
*
* DESCRIPTION:   Will be called before DrvEnableDirectDraw is called.
****************************************************************************/
BOOL DrvGetDirectDrawInfo(DHPDEV       dhpdev,
                          DD_HALINFO*  pHalInfo,
                          DWORD*       pdwNumHeaps,
                          VIDEOMEMORY* pvmList,   // Will be NULL on 1st call
                          DWORD*       pdwNumFourCC,
                          DWORD*       pdwFourCC) // Will be NULL on 1st call
{
  BOOL        bCanFlip;
  PDEV*       ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  POFMHDL     pds = NULL;

  DISPDBG((DBGLVL, "DDraw - DrvGetDirectDrawInfo\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  pHalInfo->dwSize = sizeof(DD_HALINFO);

  // Current primary surface attributes. Since HalInfo is zero-initialized
  // by GDI, we only have to fill in the fields which should be non-zero:
  pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
  pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
  pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
  pHalInfo->vmiData.lDisplayPitch   = ppdev->lDeltaScreen;

  pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
  pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

  pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->ulBitCount;

  if (ppdev->iBitmapFormat == BMF_8BPP)
     pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;

  // These masks will be zero at 8bpp:
  pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
  pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
  pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

  // Set up the pointer to the first available video memory after
  // the primary surface:
  bCanFlip     = FALSE;
  *pdwNumHeaps = 0;

  // Free up as much off-screen memory as possible:
  // Now simply reserve the biggest chunk for use by DirectDraw:
  if ((pds = ppdev->DirectDrawHandle) == NULL)
  {
#if DRIVER_5465
    pds = DDOffScnMemAlloc(ppdev);
    ppdev->DirectDrawHandle = pds;
#else
     // Because the 24 BPP transparent BLT is broken, punt it
     if (ppdev->iBitmapFormat != BMF_24BPP)
     {
        pds = DDOffScnMemAlloc(ppdev);
        ppdev->DirectDrawHandle = pds;
     };
#endif  // DRIVER_5465
  };

  if (pds != NULL)
  {
     *pdwNumHeaps = 1;

     // Fill in the list of off-screen rectangles if we've been asked
     // to do so:
     if (pvmList != NULL)
     {
        DISPDBG((0, "DirectDraw gets %li x %li surface at (%li, %li)\n",
                     pds->sizex,
                     pds->sizey,
                     pds->x,
                     pds->y));

        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
        pvmList->fpStart  = (pds->y * ppdev->lDeltaScreen) + pds->x;

        pvmList->dwWidth  = pds->sizex;
        pvmList->dwHeight = pds->sizey;
        pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;

        if ((DWORD) ppdev->cyScreen <= pvmList->dwHeight)
           bCanFlip = TRUE;

     }; // if (pvmList != NULL)
//#ifdef ALLOC_IN_CREATESURFACE
//  }
//  else
//  {
//     *pdwNumHeaps = 1;
//
//     // Fill in the list of off-screen rectangles if we've been asked
//     // to do so:
//     if (pvmList != NULL)
//     {
//        pvmList->dwFlags  = VIDMEM_ISRECTANGULAR;
//        pvmList->fpStart  = (FLATPTR) ppdev->pjScreen;
//
//        pvmList->dwWidth  = 1;
//        pvmList->dwHeight = ppdev->lTotalMem;
//        pvmList->ddsCaps.dwCaps = 0;
//        pvmList->ddsCapsAlt.dwCaps = 0;
//     }; // if (pvmList != NULL)
//#endif
  }; // if (pds != NULL)

  // Capabilities supported:
  pHalInfo->ddCaps.dwCaps = 0
                          | DDCAPS_BLT
                          | DDCAPS_BLTCOLORFILL
						  ;

#if 1 // PDR#11160
  if (ppdev->iBitmapFormat != BMF_24BPP)
		pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;
#endif

  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
     pHalInfo->ddCaps.dwCaps |= DDCAPS_READSCANLINE;

  #if DRIVER_5465
      pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_BLTSTRETCH
                                  ;

      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
          pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                  | DDCAPS_COLORKEY // NVH turned off for 24bpp  PDR #10142
                                  | DDCAPS_COLORKEYHWASSIST // NVH turned off for 24bpp PDR #10142
                                  ;
      }
  #else
      if (ppdev->iBitmapFormat != BMF_24BPP)
      {
         pHalInfo->ddCaps.dwCaps = pHalInfo->ddCaps.dwCaps
                                 | DDCAPS_COLORKEY
                                 | DDCAPS_COLORKEYHWASSIST;

         if (ppdev->iBitmapFormat != BMF_32BPP)
         {
            pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;
         };
      };
  #endif  // DRIVER_5465

  pHalInfo->ddCaps.dwCKeyCaps = 0;
  if (ppdev->iBitmapFormat != BMF_24BPP)
  {
      pHalInfo->ddCaps.dwCKeyCaps = pHalInfo->ddCaps.dwCKeyCaps
                                  | DDCKEYCAPS_SRCBLT   // NVH Turn off for 24bpp. PDR #10142
                                  | DDCKEYCAPS_DESTBLT  // NVH Turn off for 24bpp. PDR #10142
                                  ;
  }

  pHalInfo->ddCaps.ddsCaps.dwCaps = 0
                                  | DDSCAPS_OFFSCREENPLAIN
                                  | DDSCAPS_PRIMARYSURFACE
                                  ;
#ifndef ALLOC_IN_CREATESURFACE
  if (bCanFlip)
#endif
     pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_FLIP;

#ifdef ALLOC_IN_CREATESURFACE
  // Since we do our own memory allocation, we have to set dwVidMemTotal
  // ourselves.  Note that this represents the amount of available off-
  // screen memory, not all of video memory:
  pHalInfo->ddCaps.dwVidMemFree = ppdev->lTotalMem -
                 (ppdev->cxScreen * ppdev->cyScreen * ppdev->iBytesPerPixel);

  pHalInfo->ddCaps.dwVidMemTotal = pHalInfo->ddCaps.dwVidMemFree;
#endif

#if DRIVER_5465
  pHalInfo->ddCaps.dwFXCaps = 0
                            | DDFXCAPS_BLTARITHSTRETCHY
                            | DDFXCAPS_BLTSTRETCHX
                            | DDFXCAPS_BLTSTRETCHXN
                            | DDFXCAPS_BLTSTRETCHY
                            | DDFXCAPS_BLTSTRETCHYN
                            | DDFXCAPS_BLTSHRINKX
                            | DDFXCAPS_BLTSHRINKY
                            ;
#else
  if ((ppdev->iBitmapFormat != BMF_24BPP) &&
      (ppdev->iBitmapFormat != BMF_32BPP))
  {
     pHalInfo->ddCaps.dwFXCaps = 0
                               | DDFXCAPS_BLTARITHSTRETCHY
                               | DDFXCAPS_BLTSTRETCHX
                               | DDFXCAPS_BLTSTRETCHXN
                               | DDFXCAPS_BLTSTRETCHY
                               | DDFXCAPS_BLTSTRETCHYN
                               | DDFXCAPS_BLTSHRINKX
                               | DDFXCAPS_BLTSHRINKY
                               ;
  };
#endif  // DRIVER_5465

  // FOURCCs supported
#if DRIVER_5465 && defined(OVERLAY)
  if (! QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
#endif
  {
    *pdwNumFourCC = 1;
#if DRIVER_5465 && defined(OVERLAY)
    pDriverData->dwFourCC[0] = FOURCC_UYVY;
#else
    pDriverData->dwFourCC = FOURCC_UYVY;
#endif

    if (pdwFourCC != NULL)
    {
       *pdwFourCC = FOURCC_YUY2;
    }
  }

  // We have to tell DirectDraw our preferred off-screen alignment, even
  // if we're doing our own off-screen memory management:
  pHalInfo->vmiData.dwOffscreenAlign = 4;

  pHalInfo->vmiData.dwOverlayAlign = 0;
  pHalInfo->vmiData.dwTextureAlign = 0;
  pHalInfo->vmiData.dwZBufferAlign = 0;
  pHalInfo->vmiData.dwAlphaAlign = 0;

  pDriverData->RegsAddress = ppdev->pLgREGS;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, NULL, pHalInfo);
  }
#endif

  return(TRUE);
} // DrvGetDirectDrawInfo


/****************************************************************************
* FUNCTION NAME: DrvEnableDirectDraw
*
* DESCRIPTION:   GDI calls this function to obtain pointers to the
*                DirectDraw callbacks that the driver supports.
****************************************************************************/
BOOL DrvEnableDirectDraw(DHPDEV               dhpdev,
                         DD_CALLBACKS*        pCallBacks,
                         DD_SURFACECALLBACKS* pSurfaceCallBacks,
                         DD_PALETTECALLBACKS* pPaletteCallBacks)
{
  SIZEL  sizl;
  PDEV*  ppdev = (PDEV*) dhpdev;
  DRIVERDATA* pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvEnableDirectDraw\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    DWORD ReturnedDataLength;

    DISPDBG((0,"DrvEnableDirectDraw: Enable MMIO for PCI config regs.\n"));
    // Send message to miniport to enable MMIO access of PCI registers
    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_ENABLE_PCI_MMIO,
                           NULL,
                           0,
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
      RIP("DrvEnableDirectDraw failed IOCTL_VIDEO_ENABLE_PCI_MMIO");
    }
  }
  #endif

  pDriverData->ScreenAddress = ppdev->pjScreen;
  pDriverData->VideoBase = ppdev->pjScreen;

#if DRIVER_5465
#else  // for 5462 or 5464
  // Initialize the DRIVERDATA structure in PDEV
  pDriverData->PTAGFooPixel = 0;

  _outp(SQXINDEX, RDRAM_INDEX);
  pDriverData->fNineBitRDRAMS = _inp(SQXINDEX+1) & BIT_9 ? TRUE : FALSE;

  pDriverData->fReset = FALSE;
  pDriverData->DrvSemaphore = 0;
  pDriverData->EdgeTrim = 0;

  pDriverData->VideoSemaphore = 0;
  pDriverData->CurrentVideoFormat = 0;
  pDriverData->NumVideoSurfaces = 0;

  pDriverData->YUVTop  = 0;
  pDriverData->YUVLeft = 0;
  pDriverData->YUVXExt = 0;
  pDriverData->YUVYExt = 0;

  ppdev->offscr_YUV.SrcRect.left   = 0;
  ppdev->offscr_YUV.SrcRect.top    = 0;
  ppdev->offscr_YUV.SrcRect.right  = 0;
  ppdev->offscr_YUV.SrcRect.bottom = 0;
  ppdev->offscr_YUV.nInUse = 0;
  ppdev->offscr_YUV.ratio = 0;

  ppdev->bYUVuseSWPtr = TRUE;
#endif  // DRIVER_5465

  ppdev->bDirectDrawInUse = TRUE;

  // Setup DD Display list pointers
  BltInit (ppdev, FALSE);


  // Fill out the driver callback
  pCallBacks->dwFlags              = 0;

  pCallBacks->MapMemory            = DdMapMemory;
  pCallBacks->dwFlags              |= DDHAL_CB32_MAPMEMORY;

  pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
  pCallBacks->dwFlags              |= DDHAL_CB32_WAITFORVERTICALBLANK;


  pCallBacks->CanCreateSurface     = CanCreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CANCREATESURFACE;

  pCallBacks->CreateSurface        = CreateSurface;
  pCallBacks->dwFlags              |= DDHAL_CB32_CREATESURFACE;

// #ifdef  DDDRV_GETSCANLINE    //***********
  // ReadScanLine only support in 5464 & 5465
  if (ppdev->dwLgDevID >= CL_GD5464)
  {
     pCallBacks->GetScanLine       = GetScanLine;
     pCallBacks->dwFlags           |= DDHAL_CB32_GETSCANLINE;
  }
// #endif // DDDRV_GETSCANLINE   ************

  // Fill out the surface callback
  pSurfaceCallBacks->dwFlags       = 0;

#if DRIVER_5465
  pSurfaceCallBacks->Blt        = Blt65;
#else
  pSurfaceCallBacks->Blt        = DdBlt;
#endif  // DRIVER_5465

  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_BLT;

  pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETBLTSTATUS;

  pSurfaceCallBacks->Flip          = DdFlip;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_FLIP;

  pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_GETFLIPSTATUS;

  pSurfaceCallBacks->Lock          = DdLock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_LOCK;

  pSurfaceCallBacks->Unlock        = DdUnlock;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_UNLOCK;

  pSurfaceCallBacks->DestroySurface = DestroySurface;
  pSurfaceCallBacks->dwFlags       |= DDHAL_SURFCB32_DESTROYSURFACE;

#if DRIVER_5465 && defined(OVERLAY)
  if (QueryOverlaySupport(ppdev, ppdev->dwLgDevID))
  {
    // fill in overlay caps
    OverlayInit(ppdev, ppdev->dwLgDevID, pSurfaceCallBacks, NULL);
  }
#endif

  // Note that we don't call 'vGetDisplayDuration' here, for a couple of
  // reasons:
  //  o Because the system is already running, it would be disconcerting
  //    to pause the graphics for a good portion of a second just to read
  //    the refresh rate;
  //  o More importantly, we may not be in graphics mode right now.
  //
  // For both reasons, we always measure the refresh rate when we switch
  // to a new mode.

  return(TRUE);
}  // DrvEnableDirectDraw


/****************************************************************************
* FUNCTION NAME: DrvDisableDirectDraw
*
* DESCRIPTION:   GDI call this function when the last DirectDraw application
*                has finished running.
****************************************************************************/
VOID DrvDisableDirectDraw(DHPDEV dhpdev)
{
  DRIVERDATA* pDriverData;
  ULONG ultmp;

  PDEV* ppdev = (PDEV*) dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  DISPDBG((DBGLVL, "DDraw - DrvDisableDirectDraw\n"));

#if 0
  #if (VS_CONTROL_HACK && DRIVER_5465)
  {
    // Clear bit 0 to disable PCI register MMIO access
    DISPDBG((0,"DrvDisableDirectDraw: Disable MMIO for PCI config regs.\n"));
    ppdev->grVS_CONTROL &= 0xFFFFFFFE;
    LL32 (grVS_Control, ppdev->grVS_CONTROL);
  }
  #endif
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

#if DRIVER_5465
#else  // for 5462 or 5464
  if (ppdev->bYUVuseSWPtr)
  {
     // Disable the Hw cursor by clearing the hw cursor enable
     // bit in CURSOR_CONTROL reg
     ultmp = LLDR_SZ (grCursor_Control);
     if (ultmp & 1)
     {
        ultmp &= 0xFFFE;
        LL16 (grCursor_Control, ultmp);
     };
  };
#endif  // DRIVER_5465

  // DirectDraw is done with the display, so we can go back to using
  // all of off-screen memory ourselves:
  DDOffScnMemRestore(ppdev);

  ppdev->bYUVSurfaceOn = FALSE;
  ppdev->bDirectDrawInUse = FALSE;

} // DrvDisableDirectDraw

#endif // ! ver3.51



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG
  
ULONG DebugLevel = 0;

#endif // DBG

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

#if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL5465:"

#else // if DRIVER_5465

#define STANDARD_DEBUG_PREFIX "CL546X:"

#endif // if DRIVER_5465


VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

#if DBG

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel) {

#ifdef WINNT_VER40
	     EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
#else
        char buffer[128];

        vsprintf(buffer, DebugMessage, ap);

        OutputDebugStringA(buffer);
#endif

    }

    va_end(ap);

#endif // DBG

} // DebugPrint()

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\dev2dev.c ===
/******************************Module*Header*******************************\
* Module Name: DEV2DEV.c
*
* Author: Noel VanHook
* 
* Purpose: Handle device to device BLTs. 
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/dev2dev.c  $
* 
*    Rev 1.11   Mar 04 1998 15:13:52   frido
* Added new shadow macros.
* 
*    Rev 1.10   Jan 22 1998 16:20:10   frido
* Added 16-bit striping code.
* 
*    Rev 1.9   Jan 21 1998 13:46:52   frido
* Fixed the striping code since this is really the first time we check it.
* 
*    Rev 1.8   Jan 20 1998 11:43:26   frido
* Guess what? Striping was not turned on!
* 
*    Rev 1.7   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.6.1.2   Dec 05 1997 13:34:26   frido
* PDR#11043. When using a brush, striping should use pixels instead of
* bytes, so now there is an intelligent switcher in place.
* 
*    Rev 1.6.1.1   Nov 18 1997 15:14:56   frido
* Added striping for 24-bpp.
* 
*    Rev 1.6.1.0   Nov 10 1997 13:39:26   frido
* PDR#10893: Inside DoDeviceToDeviceWithXlate the source pointer
* was not updated after each access.
* 
*    Rev 1.6   Nov 04 1997 13:40:56   frido
* I removed a little too much code in DoDeviceToDevice. The result was
* a very slow screen-to-screen blits since everything was punted back to
* GDI.
* 
*    Rev 1.5   Nov 04 1997 09:49:18   frido
* Added COLOR_TRANSLATE switches around hardware color translation code.
* 
*    Rev 1.4   Nov 03 1997 15:20:06   frido
* Added REQUIRE macros.
* 
*    Rev 1.3   15 Oct 1997 12:03:00   noelv
* Pass rop code to CacheXlateTable().
* 
*    Rev 1.2   02 Oct 1997 09:48:22   noelv
* 
* Hardwre color translation only works with CC rop code.
* 
*    Rev 1.1   19 Feb 1997 13:14:22   noelv
* 
* Fixed LL_BLTEXT_XLATE()
* 
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*
\**************************************************************************/

#include "precomp.h"

#define DEV2DEV_DBG_LEVEL 0

//
// Set to 1 to stripe screen to screen operations along tile boundries.
// Set to 0 to do screen to screen operations in a few BLTs as possible.
//
// on the 62, 64 and 65 striping is faster than not striping.
//
#define STRIPE_SCR2SCR 1

//
// internal prototypes.
//
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
);





/*****************************************************************************\
 * DoDeviceToDevice
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit.  If there is a color translation table, we will attempt to use
 * the hardware color translator.  If we can't (or don't have one) we will
 * pass the call to DoDeviceToDeviceWithXlate, which will do the color
 * translation is software.
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pxlo            Pointer to translation object.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              The ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDevice(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    XLATEOBJ *pxlo,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    LONG   tileSize, maxStripeWidth;
    ULONG* pulXlate;
	BOOL   fStripePixels;
	BOOL   fFirst = TRUE;

    //
    // Determine the source type and adjust the source offset.
    //
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }


    //
    // Determine the destination type and adjust the destination offset.
    //
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }


    //
    // Is there a translation table?
    // If so, we will attempt to load it into the chip.  This also
    // points pulXlate at the color translation table, if there is one.
    //
	#if COLOR_TRANSLATE
    if (! bCacheXlateTable(ppdev, &pulXlate, psoTrg, psoSrc, pxlo,
						   (BYTE)(ulDRAWBLTDEF&0xCC)) )
	#else
	if ( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) )
	{
		pulXlate = NULL;
	}
	else if (pxlo->flXlate & XO_TABLE)
	{
		pulXlate = pxlo->pulXlate;
	}
	else
	{
		pulXlate = XLATEOBJ_piVector(pxlo);
	}

	if (pulXlate != NULL)
	#endif
    {
        // We must do software color translation.
        return DoDeviceToDeviceWithXlate(psoTrg, psoSrc, pulXlate, prclTrg,
										 pptlSrc, ulDRAWBLTDEF);
    }

    //
    // if pulXlate == NULL, there is no color translation required.
    // if pulXlate != NULL, we will do hardware translation.
    //

    //
    // We only do screen to screen color translation in 8 bpp.
    //
    ASSERTMSG( ((pulXlate == NULL) || (ppdev->iBitmapFormat == BMF_8BPP)),
            "DoDeviceToDevice: Xlate with non-8bpp.\n");
    if ((pulXlate) && (ppdev->iBitmapFormat != BMF_8BPP))
    {
        return FALSE;
    }


    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;

	fStripePixels = (ulDRAWBLTDEF & 0x000F0000) | (pulXlate != NULL);

	if (fStripePixels)
	{
	    // Calculate the number of pixels per tile and per SRAM line.
	    switch (ppdev->iBitmapFormat)
	    {
	        case BMF_8BPP:
	            tileSize = ppdev->lTileSize;
	            maxStripeWidth = 120;
	            break;

	        case BMF_16BPP:
	            tileSize = ppdev->lTileSize / 2;
	            maxStripeWidth = 120 / 2;
	            break;

	        case BMF_24BPP:
	            tileSize = ppdev->cxScreen;
	            maxStripeWidth = max(ptlDest.x - ptlSrc.x, 120 / 3);
	            break;

	        case BMF_32BPP:
	            tileSize = ppdev->lTileSize / 4;
	            maxStripeWidth = 120 / 4;
	            break;
	    }
	}
	else
	{
		// Convert everything to bytes.
		ptlSrc.x *= ppdev->iBytesPerPixel;
		ptlDest.x *= ppdev->iBytesPerPixel;
		sizl.cx *= ppdev->iBytesPerPixel;
		tileSize = ppdev->lTileSize;
		maxStripeWidth = 120;
	}

    // Test vertical direction of blitting and set grDRAWBLTDEF register
    // accordingly.
    if (ptlSrc.y < ptlDest.y)
    {
        ptlSrc.y += sizl.cy - 1;
        ptlDest.y += sizl.cy - 1;
		ulDRAWBLTDEF |= 0x90100000;
    }
    else
    {
        ulDRAWBLTDEF |= 0x10100000;
    }

    // Test horizontal direction of blitting.
    if ( (ptlSrc.x >= ptlDest.x) || (ptlSrc.y != ptlDest.y) )
    {
		if (ptlSrc.x >= ptlDest.x)
		{
	        // Blit to left.
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlSrc.x % tileSize));

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
	            cx = min(cx, tileSize - (ptlDest.x % tileSize));

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
			            LL_OP1(ptlSrc.x, ptlSrc.y);
			            LL_OP0(ptlDest.x, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
			                LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x, ptlSrc.y);
		            LL_OP0(ptlDest.x, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x += cx;
	            ptlDest.x += cx;
	            sizl.cx -= cx;
	        }
		}
		else
		{
	        // Blit to right.
			ptlSrc.x += sizl.cx;
			ptlDest.x += sizl.cx;
	        while (sizl.cx > 0)
	        {
	            // Calculate the width of this blit.
	            LONG cx = sizl.cx;

	            // Calculate how many pixels it is to the next source tile
	            // boundary. Use lesser value.
				if ((ptlSrc.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlSrc.x % tileSize);
				}

	            // Calculate how many pixels it is to the next destination tile
	            // boundary. Use lesser value.
				if ((ptlDest.x % tileSize) == 0)
				{
					cx = min(cx, tileSize);
				}
				else
				{
	            	cx = min(cx, ptlDest.x % tileSize);
				}

	            // Perform the blit.
				if (fFirst)
				{
					fFirst = FALSE;

					REQUIRE(9);
					LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);

					if (fStripePixels)
					{
		    	        LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		        	    LL_OP0(ptlDest.x - cx, ptlDest.y);

			            if (pulXlate) // launch a color xlate BLT
			                LL_BLTEXT_XLATE(8, cx, sizl.cy);
			            else // Launch a regular BLT
		    	            LL_BLTEXT(cx, sizl.cy);
					}
					else
					{
						LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
						LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
						LL_MBLTEXT(cx, sizl.cy);
					}
				}
				else if (pulXlate)
				{
					REQUIRE(7);
		            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
		            LL_OP0(ptlDest.x - cx, ptlDest.y);
					LL_BLTEXT_XLATE(8, cx, sizl.cy);
				}
				else
				{
					REQUIRE(4);
					if (fStripePixels)
					{
						LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
						LL16(grBLTEXT_XEX.PT.X, cx);
					}
					else
					{
						LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
						LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
						LL16(grMBLTEXT_XEX.PT.X, cx);
					}
				}

	            // Adjust the coordinates.
	            ptlSrc.x -= cx;
	            ptlDest.x -= cx;
	            sizl.cx -= cx;
	        }
		}
    }

    else
    {
        // Blit using SRAM.
        ptlSrc.x += sizl.cx;
        ptlDest.x += sizl.cx;

        while (sizl.cx > 0)
        {
            // Calculate the width of this blit. We must never overrun a single
            // SRAM cache line.
            LONG cx = min(sizl.cx, maxStripeWidth);

            // Calculate how many pixels it is to the next source tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlSrc.x - 1) % tileSize) + 1);

            // Calculate how many pixels it is to the next destination tile
            // boundary. Use lesser value.
            cx = min(cx, ((ptlDest.x - 1) % tileSize) + 1);

            // Do the blit.
			if (fFirst)
			{
				REQUIRE(9);
				LL_DRAWBLTDEF(ulDRAWBLTDEF, 0);
				if (fStripePixels)
				{
	        	    LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            	LL_OP0(ptlDest.x - cx, ptlDest.y);

					if (pulXlate) // Launch a color xlate BLT
	    	            LL_BLTEXT_XLATE(8, cx, sizl.cy);
		            else // Launch a regular BLT
		                LL_BLTEXT(cx, sizl.cy);
				}
				else
				{
					LL_OP1_MONO(ptlSrc.x - cx, ptlSrc.y);
					LL_OP0_MONO(ptlDest.x - cx, ptlDest.y);
					LL_MBLTEXT(cx, sizl.cy);
				}
			}
			else if (pulXlate)
			{
				REQUIRE(7);
	            LL_OP1(ptlSrc.x - cx, ptlSrc.y);
	            LL_OP0(ptlDest.x - cx, ptlDest.y);
				LL_BLTEXT_XLATE(8, cx, sizl.cy);
			}
			else
			{
				REQUIRE(4);
				if (fStripePixels)
				{
					LL16(grOP1_opRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opRDRAM.PT.X, ptlDest.x - cx);
					LL16(grBLTEXT_XEX.PT.X, cx);
				}
				else
				{
					LL16(grOP1_opMRDRAM.PT.X, ptlSrc.x - cx);
					LL16(grOP0_opMRDRAM.PT.X, ptlDest.x - cx);
					LL16(grMBLTEXT_XEX.PT.X, cx);
				}
			}

            // Adjust the coordinates.
            ptlSrc.x -= cx;
            ptlDest.x -= cx;
            sizl.cx -= cx;
        }
    }

    return(TRUE);
}







/*****************************************************************************\
 * DoDeviceToDeviceWithXlate
 *
 * This routine performs a ScreenToScreen, DeviceToScreen or ScreenToDevice
 * blit when there is a color translation table.
 * Color translation is done in software.
 *
 *
 * On entry:    psoTrg          Pointer to target surface object.
 *              psoSrc          Pointer to source surface object.
 *              pulXlate        Translation table.
 *              prclTrg         Destination rectangle.
 *              pptlSrc         Source offset.
 *              ulDRAWBLTDEF    Value for grDRAWBLTDEF register. This value has
 *                              the ROP and the brush flags.
\*****************************************************************************/
BOOL DoDeviceToDeviceWithXlate(
    SURFOBJ  *psoTrg,
    SURFOBJ  *psoSrc,
    ULONG    *pulXlate,
    RECTL    *prclTrg,
    POINTL   *pptlSrc,
    ULONG    ulDRAWBLTDEF
)
{
    POINTL ptlSrc, ptlDest;
    SIZEL  sizl;
    PPDEV  ppdev;
    BYTE*  pjSrc;
    DWORD* pjHostData;
    LONG   lDelta, lExtra, lLeadIn, i, n, tileSize, maxStripeWidth;


    // Determine the source type and adjust the source offset.
    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        // Source is a device bitmap.
        PDSURF pdsurf = (PDSURF) psoSrc->dhsurf;
        ptlSrc.x = pptlSrc->x + pdsurf->ptl.x;
        ptlSrc.y = pptlSrc->y + pdsurf->ptl.y;
        ppdev = pdsurf->ppdev;
    }
    else
    {
        // Source is the screen.
        ptlSrc.x = pptlSrc->x;
        ptlSrc.y = pptlSrc->y;
        ppdev = (PPDEV) psoSrc->dhpdev;
    }

    // Determine the destination type and adjust the destination offset.
    if (psoTrg->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) psoTrg->dhsurf;
        ptlDest.x = prclTrg->left + pdsurf->ptl.x;
        ptlDest.y = prclTrg->top + pdsurf->ptl.y;
    }
    else
    {
        ptlDest.x = prclTrg->left;
        ptlDest.y = prclTrg->top;
    }

    // We only support color translations in 8-bpp.
    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        return FALSE;
    }

    // Calculate the size of the blit.
    sizl.cx = prclTrg->right - prclTrg->left;
    sizl.cy = prclTrg->bottom - prclTrg->top;


    // Calculate the screen address.
    pjSrc = ppdev->pjScreen + ptlSrc.x + ptlSrc.y * ppdev->lDeltaScreen;
    lDelta = ppdev->lDeltaScreen;
    pjHostData = (DWORD*) ppdev->pLgREGS->grHOSTDATA;

    // Wait for the hardware to become idle.
    while (LLDR_SZ(grSTATUS) != 0) ;

    // DWORD align the source.
    lLeadIn = (DWORD)pjSrc & 3;
    pjSrc -= lLeadIn;
    n = (sizl.cx + lLeadIn + 3) >> 2;

    // Test for overlapping.
    if (ptlSrc.y < ptlDest.y)
    {
        // Negative direction.
        pjSrc += (sizl.cy - 1) * lDelta;
        ptlDest.y += sizl.cy - 1;
        lDelta = -lDelta;
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x90200000, 0);
    }
    else if (ptlSrc.y > ptlDest.y)
    {
        // Positive direction.
		REQUIRE(9);
        LL_DRAWBLTDEF(ulDRAWBLTDEF | 0x10200000, 0);
    }
    else
    {
        // Maybe horizontal overlap, punt call to GDI anyway.
        return(FALSE);
    }

    #if ! DRIVER_5465
        // Get the number of extra DWORDS per line for the HOSTDATA hardware
        // bug.
        if (ppdev->dwLgDevID == CL_GD5462)
        {
            if (MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x) == 3788)
            {
                // We have a problem with the HOSTDATA TABLE. 
                // Punt till we can figure it out.
                return FALSE; 
            }
            lExtra =
                ExtraDwordTable[MAKE_HD_INDEX(sizl.cx, lLeadIn, ptlDest.x)];
        }
        else
            lExtra = 0;
    #endif

    // Start the blit.
    LL_OP1_MONO(lLeadIn, 0);
    LL_OP0(ptlDest.x, ptlDest.y);
    LL_BLTEXT(sizl.cx, sizl.cy);

    while (sizl.cy--)
    {
		BYTE *p = pjSrc;
		BYTE pixel[4];

        for (i = 0; i < n; i++)
        {
            pixel[0] = (BYTE) pulXlate[p[0]];
            pixel[1] = (BYTE) pulXlate[p[1]];
            pixel[2] = (BYTE) pulXlate[p[2]];
            pixel[3] = (BYTE) pulXlate[p[3]];
			p += 4;
			REQUIRE(1);
            *pjHostData = *(DWORD*) pixel;
        }

        #if !DRIVER_5465
            // Now, write the extra DWORDS.
			REQUIRE(lExtra);
            for (i = 0; i < lExtra; i++)
            {
                LL32(grHOSTDATA[i], 0);
            }
        #endif

        // Next line.
        pjSrc += lDelta;
    }

    // Return okay.
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\displist.c ===
/******************************Module*Header*******************************\
*
* Module Name: displist.c
* Author: Goran Devic, Mark Einkauf
* Purpose: General output to Laguna3D 
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
\**************************************************************************/

#define OPENGL_MCD

#include "precomp.h"
#include "mcdhw.h"
#include "mcdutil.h"

/*********************************************************************
*   Defines
**********************************************************************/
#define DL_MIN_SIZE       (8 * KB)  // Minimum size of the d-list
#define DL_MAX_SIZE    (4096 * KB)  // Maximum size of the d-list

#define DL_SAFETY_MARGIN  (1 * KB)  // Margin when building d-list (b)

//WARNING!!! Any change to DL_START_OFFSET must be made in polys.c also!!!
#define DL_START_OFFSET    20       // 5 dwords offset for dlist
//WARNING!!! Any change to DL_START_OFFSET must be made in polys.c also!!!

/*********************************************************************
*   Include Files
**********************************************************************/



/*********************************************************************
*   Local Functions
**********************************************************************/

/*********************************************************************
*
*   DWORD _InitDisplayList( LL_DeviceState * DC )
*
*       Allocates memory and initializes display list structure.
*       Two display lists are created.
*
*   Where:
*
*       DC is the device context structure to be initialized
*       DC->dwDisplayListLen is the size of the display list
*           to be allocated (in bytes).
*
*   Returns:
*
*       LL_OK (0) if initialization succeeds
*       error_code if initialization fails
*
**********************************************************************/
DWORD _InitDisplayList( PDEV *ppdev, DWORD dwListLen )
{
    int i;
    
#if 0
    // The user requested DC->dwDisplayListLen bytes of system memory
    // to be used for device display list.  That memory will be
    // allocated and stay locked.  But first, we subdivide it at
    // several chunks for display list multibuffering.
    //
    
    // Sanity check
    //
    if( dwListLen < DL_MIN_SIZE || dwListLen > DL_MAX_SIZE )
        return( LLE_INI_DL_LEN );


    // Subdivide display list and allocate each chunk
    //
    chunk_size = (dwListLen / NUM_DL) & ~3;
    
    for( i=0; i<NUM_DL; i++ )
    {
        // Allocate memory for a display list
        //

        if( (LL_State.DL[i].hMem = AllocSystemMemory( chunk_size )) == 0 )
            return( LLE_INI_ALLOC_DL );
            
        // Get the linear and physical address of a display list
        //
        LL_State.DL[i].pdwLinPtr = (DWORD *) GetLinearAddress( LL_State.DL[i].hMem );
        LL_State.DL[i].dwPhyPtr  = GetPhysicalAddress( LL_State.DL[i].hMem );

        // Set the length and the parametarization pointer to point to the
        // offset of 20: 16 bytes are reserved for jump table, additional 4 bytes
        // for a semaphore.
        //
        LL_State.DL[i].dwLen = chunk_size;
        LL_State.DL[i].pdwNext = LL_State.DL[i].pdwLinPtr + DL_START_OFFSET/4;
        LL_State.DL[i].pdwStartOutPtr = LL_State.DL[i].pdwNext;//only used in coproc mode

        // Clear the jump table and a semaphore
        //
        LL_State.DL[i].pdwNext[0] = IDLE;
        LL_State.DL[i].pdwNext[1] = IDLE;
        LL_State.DL[i].pdwNext[2] = IDLE;
        LL_State.DL[i].pdwNext[3] = IDLE;
        LL_State.DL[i].pdwNext[4] = 0;
        
        // Set the safety margin for the parametarization routines
        //
        LL_State.DL[i].dwMargin = (DWORD)LL_State.DL[i].pdwLinPtr + chunk_size - DL_SAFETY_MARGIN;
        
        // Temporary fix for non-flushing TLB
        *(DWORD *)((DWORD)LL_State.DL[i].pdwLinPtr + chunk_size - 16) = BRANCH + DL_START_OFFSET;


        DEB2("Display list: %d\n", i );
        DEB2("\tLength = %d b\n", LL_State.DL[i].dwLen );
        DEB2("\tMemory handle = %08Xh\n", LL_State.DL[i].hMem );
        DEB2("\tLinear memory = %08Xh\n", LL_State.DL[i].pdwLinPtr );
        DEB2("\tPhysical memory = %08Xh\n", LL_State.DL[i].dwPhyPtr );
        DEB2("\tSafety margin = %08Xh\n", LL_State.DL[i].dwMargin );
    }

    // Set the current display list to the first one.  This one will be
    // used with parametarizations
    //
    LL_State.dwCdl = 0;
    LL_State.pDL = &LL_State.DL[0];
    *(LL_State.pRegs + PF_BASE_ADDR_3D) = LL_State.DL[0].dwPhyPtr;

#else 

	// MCD_TEMP - reduced InitDisplayList function to get running quickly - 1 DList only

    ppdev->LL_State.DL[0].pdwLinPtr = ppdev->temp_DL_chunk;

    // Set the length and the parametarization pointer to point to the
    // offset of 20: 16 bytes are reserved for jump table, additional 4 bytes
    // for a semaphore.
    //
    ppdev->LL_State.DL[0].dwLen = dwListLen;
    ppdev->LL_State.DL[0].pdwNext = ppdev->LL_State.DL[0].pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.DL[0].pdwStartOutPtr = ppdev->LL_State.DL[0].pdwNext;//only used in coproc mode

	ppdev->LL_State.pDL = &ppdev->LL_State.DL[ 0 ];
    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
	ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode
	
#endif			

    return( LL_OK );
}



#ifndef OPENGL_MCD

/*********************************************************************
*
*   void _CloseDisplayList()
*
*       Cleans up the memory allocations for display list(s).
*       This function is to be called at closing the library.
*
**********************************************************************/
void _CloseDisplayList()
{
    int i;
    

    // Loop through and free each chunk of the display list
    //
    for( i=0; i<NUM_DL; i++ )
    {
        // Free memory and reset pointers just to be safe
        //
        FreeSystemMemory( LL_State.DL[i].hMem );
        memset( &LL_State.DL[i], 0, sizeof(TDisplayList) );
    }

    LL_State.pDL = NULL;
}



/*********************************************************************
*
*   Batch cell instruction: LL_IDLE
*
*   Stores IDLE Laguna 3D microinstruction.
*
*   Every batch array that is sent to the LL_Execute() must have this
*   operation terminating it.
*
*   Example:
*
*       pBatch->bOp = LL_IDLE;
*
**********************************************************************/
DWORD * fnIdle( DWORD * pdwNext, LL_Batch * pBatch )
{
    if( !LL_State.fIndirectMode )
        *pdwNext++ = IDLE;

    return( pdwNext );
}


/*********************************************************************
*
*   Batch cell instruction: LL_NOP
*
*   Does nothing.
*
**********************************************************************/
DWORD * fnNop( DWORD * pdwNext, LL_Batch * pBatch )
{
    return( pdwNext );
}


/*********************************************************************
*
*   Batch cell instruction: LL_RAW_DATA
*
*   Copies raw data to the display list.  The pointer to data (DWORD *)
*   is pVert, number of dwords to be copied is in wCount.
*
*   Note: All the data must fit into a display list.  No explicit checking
*   is done.  Keep your data stream short!
*
*   Example:
*
*       pBatch->wCount = 2;                         // 2 integers of data
*       pBatch->pVert = (DWORD *) &MyData[0];       // Starting data address
*
**********************************************************************/
DWORD * fnRawData( DWORD * pdwNext, LL_Batch * pBatch )
{
    register int count;
    register DWORD * dwPtr;
    
   
    dwPtr = (DWORD *)pBatch->pVert;
    
    for( count = pBatch->wCount; count>0; count-- )
    {
        *pdwNext++ = *dwPtr++;
    }

    return( pdwNext );
}

#endif // ndef OPENGL_MCD

/*********************************************************************
*
*   DWORD * _RunLaguna( DWORD *pdwNext )
*
*       Spins off Laguna 3D and resets the parametarization pointers
*       to the next available d-list
*
*       The function will take into account the rendering mode that
*       was set to either processor or coprocessor indirect.
*       In the later case it will sense the instructions that can
*       not be executed in that mode and it will do them directly.
*
*   Where:
*
*       pdwNext is the pointer to a current display list to the next
*       available space.
*
*   Returns:
*
*       Offset in the new d-list to start building
*
**********************************************************************/
void _RunLaguna( PDEV *ppdev, DWORD *pdwNext )
{
    DWORD instr;
    int len;
    int address, offset, update_offset;
    int event;
    volatile int status;

    // Two rendering modes are supported: processor direct mode and
    // coprocessor indirect mode.
    //
    // MCD_TEMP - RunLaguna only supporting coprocessor mode now
  //if( ppdev->LL_State.fIndirectMode )
    {
        
        DWORD *pSrc, *pDest;

        // Co-processor indirect mode: use host data port to program
        // the hardware
        //
        pSrc = ppdev->LL_State.pDL->pdwStartOutPtr;
        pDest = ppdev->LL_State.pRegs + HOST_3D_DATA_PORT;

        // Assumption: On the entry of this loop pSrc points to the valid
        // instruction.
        //
        while( pdwNext != pSrc )
        {
            // The display list is examined for the instructions that
            // can not be executed in coprocessor mode.  That involves
            // partially disassembling each instruction and tracing the
            // number of parameters.
            //
            // All this work is done so that WRITE_DEV_REGS and READ_DEV_REGS
            // may be detected and simulated.  Other instructions such as
            // branches, idle, return, waits and interrupts are ignored.
            //
            /* Get the next instruction */

            instr = *pSrc;
            update_offset = 0;

            /* Switch on the instruction opcode */

    #if 1 // 1 here for good RM sound
      {
          int i;            
          status = *(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D);
          while (status & 0x200)
          {
            //i=10;  
            //while (i--) { /* don't read in tight loop*/ }    
              status = *(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D);
          }
      }  
    #endif          
        
            USB_TIMEOUT_FIX(ppdev) 

            switch( instr >> 27 )
            {
                case 0x00:              /* Draw point opcode */
                case 0x01:              /* Draw line opcode */
                case 0x02:              /* Draw poly opcode */
                case 0x03:              /* Write register opcode */

                    /* Get the amount of data for this opcode */
                    
                    len = (instr & 0x3F) + 1;

                    /* Send data to the host data area */

                    while( len-- )
                        *pDest = *pSrc++;

                    break;

                case 0x05:              /* Write device opcode (Simulated) */

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Get the amount of data for this opcode */
                    
                    len = instr & 0x3F;

                    /* Switch on the module selected */

                    switch( (instr >> 21) & 0x1F )
                    {
                        case 0x00:              /* VGA register set */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0000);
                            offset = (instr >> 6) & 0x0FF;

                            break;

                        case 0x01:              /* VGA frame buffer */

                            /* Setup the device address and offset */

                            address = 0xA0000;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x02:              /* Video port */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0100);
                            offset = (instr >> 6) & 0x07F;

                            break;

                        case 0x03:              /* Local peripheral bus */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0180);
                            offset = (instr >> 6) & 0x07F;

                            break;

                        case 0x04:              /* Miscellaneous */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0200);
                            offset = (instr >> 6) & 0x0FF;

                            break;

                        case 0x05:              /* 2D engine registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0400);
                            offset = (instr >> 6) & 0x3FF;

                            break;

                        case 0x06:              /* 2D host data */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x0800);
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x07:              /* Frame buffer */

                            /* Setup the device address and offset */

                            address = (int) ppdev->LL_State.pFrame;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x08:              /* ROM memory */

                            /* Setup the device address and offset */

                            address = 0xC0000;
                            offset = (instr >> 6) & 0x7FF;

                            break;

                        case 0x09:              /* 3D engine registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4000);
                            offset = (instr >> 6) & 0x1FF;

                            break;

                        case 0x0A:              /* 3D host XY registers */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4200);
                            offset = (instr >> 6) & 0x0FF;
                            update_offset = 4;

                            break;

                        case 0x0B:              /* 3D host data */

                            /* Setup the device address and offset */

                            address = (int) (((BYTE *) ppdev->LL_State.pRegs) + 0x4800);
                            offset = (instr >> 6) & 0x3FF;

                            break;

                        default:                /* Unknown module */

                            /* Setup the device address and offset */
                            //printf("RL:WriteDev, unknown mod instr=%x\n",instr);
                            address = (int)NULL;
                            offset = (int)NULL;

                            break;
                    }
                    /* If this device supported, send the data */

                    if ( address )
                    {
                        /* Send data to the device */

                        while( len-- )
                        {
                            *(DWORD *)( address + offset ) = *pSrc++;
                            offset += update_offset;
                        }

                    }
                    else
                        pSrc += len;

                    break;

                case 0x0D:              /* Control opcode */

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Switch on the sub-opcode value */

                    switch( (instr >> 22) & 0x0F )
                    {
                        case 0:                 /* Idle sub-opcode */

                            /* Force exit from display list */

                            pSrc = pdwNext;

                            break;

                        case 5:                 /* Clear sub-opcode */

                            *pDest = instr;

                            break;
                    }
                    break;

                case 0x0E:              /* Wait opcode */
                    {
                    int wait_time_out;

                    /* Step past the instruction opcode */

                    pSrc++;

                    /* Get the wait event mask */

                    event = instr & 0x3FF;

                    if (event == EV_BUFFER_SWITCH)
                        wait_time_out=100000;
                    else                            
                        wait_time_out=5000000;


                    /* Switch on the wait opcode sub-type (AND/OR/NAND/NOR) */

                    switch( (instr >> 24) & 0x03 )
                    {
                        case 0:                 /* Wait OR sub-opcode */

                            /* Wait for requested event to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x3E0;
                            } while((!(status & event)) && wait_time_out--);

                            break;

                        case 1:                 /* Wait NOR sub-code */

                            /* Wait for requested event to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x01F;
                            } while((!(status & event)) && wait_time_out--);

                            break;

                        case 2:                 /* Wait AND sub-opcode */

                            /* Wait for requested events to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x3E0;
                            } while(((status & event) != event) && wait_time_out--);

                            break;

                        case 3:                 /* Wait NAND sub-opcode */

                            /* Wait for requested events to happen */

                            do
                            {
                                status = (*(volatile *)(ppdev->LL_State.pRegs + PF_STATUS_3D) & 0x3FF) ^ 0x01F;
                            } while(((status & event) != event) && wait_time_out--);

                            break;
                    }
                  //if (wait_time_out <= 0) printf("WAIT TIMED OUT, instr = %x, ev=%x stat=%x\n",instr,event,status); 
                    }
                    break;

                default:                /* Unknown/unhandled opcode (Skip) */

                    //printf("RL:WriteDev, unknown opcode, instr=%x\n",instr);
                    /* Step past the instruction opcode */

                    pSrc++;

                    break;
            }
        }

    }

#if 0 // MCD_TEMP - no processor mode support yet
    else
    {

        // Check for valid address to put IDLE
        //
        if( ((int)pdwNext < (int)ppdev->LL_State.pDL->pdwLinPtr) || 
            ((int)pdwNext - (int)ppdev->LL_State.pDL->pdwLinPtr >= chunk_size - 16) )
        {
            //printf("DISPLAY LIST OVERRUN\n");

            goto proceed;    
        }

        // Stuff IDLE since this must be the end of current display list
        //
        *pdwNext = IDLE;


        // If Laguna is still busy with the previous d-list, poll
        // it until it is idle.
        //
        DEB("Entering 3D Engine Busy wait state...\n");
        LL_Wait();

        // We have to set the base address of the display list
        // This address is used as a base address when
        // fetching display list instructions
        //
        *(ppdev->LL_State.pRegs + PF_BASE_ADDR_3D) = ppdev->LL_State.pDL->dwPhyPtr;
        inp(0x80);
        inp(0x80);
        DEB2("New base: PF_BASE_ADDR_3D: %08X\n", *(ppdev->LL_State.pRegs + PF_BASE_ADDR_3D) );

        // Start the execution of the display list from the offset 0
        //
//      *(ppdev->LL_State.pRegs + PF_INST_3D) = BRANCH + DL_START_OFFSET;
        // No!  Temporary fix the prefetch bug and jump to the
        // top of the display list where the real branch(0)
        // instruction was stored during the display list initialization
        //
        DEB4("Issuing BRANCH %08X (->%08X ->%08X)\n", BRANCH + chunk_size - 16,
            *(DWORD *)((int)ppdev->LL_State.pDL->pdwLinPtr + chunk_size - 16),
            *(ppdev->LL_State.pDL->pdwLinPtr + 5) );

        if( *(DWORD *)((int)ppdev->LL_State.pDL->pdwLinPtr + chunk_size - 16) != BRANCH + DL_START_OFFSET )
        {
            //printf("BRANCH LOCATION CONTAINS INVALID DATA!\n");
            goto proceed;
        }

        *(ppdev->LL_State.pRegs + PF_INST_3D) = BRANCH + chunk_size - 16;
        inp(0x80);
        inp(0x80);
    }

proceed:

#endif // 0 - no processor mode support yet

#if 0
    // Set the active display list index to the next in an array
    //
    if( ++ppdev->LL_State.dwCdl >= NUM_DL )
        ppdev->LL_State.dwCdl = 0;


    // Reset the parametarization pointer to the beginning
    // of the next display list
    //
    ppdev->LL_State.pDL = &ppdev->LL_State.DL[ ppdev->LL_State.dwCdl ];
    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode

    return( ppdev->LL_State.pDL->pdwNext );
#else // 0
    // MCD_TEMP - ppdev->LL_State.pDL remains same always since only 1 DList

    ppdev->LL_State.pDL->pdwNext = ppdev->LL_State.pDL->pdwLinPtr + DL_START_OFFSET/4;
    ppdev->LL_State.pDL->pdwStartOutPtr = ppdev->LL_State.pDL->pdwNext;//only used in coproc mode
#endif // 0

}


#ifndef OPENGL_MCD

/*********************************************************************
*
*   void LL_Execute( LL_Batch * pBatch )
*
*       Builds the display list from the batch array and executes it.
*       This function is the main executing function.  If the batch
*       array cannot be completely fit into the available display
*       list, it will be processed in multiple pieces.
*
**********************************************************************/
void LL_Execute( LL_Batch * pBatch )
{
    register DWORD *pdwNext;

    // First we build the current display list
    //
    pdwNext = LL_State.pDL->pdwNext;

    do
    {
        // Build the current display list until IDLE instruction
        //
      //printf("bOp=%x\n",pBatch->bOp);
        pdwNext = (fnList[ pBatch->bOp ])( pdwNext, pBatch );

    } while( (pBatch++)->bOp != LL_IDLE );

    // Spin off the d-list that was just built and prepare to render 
    // to the next available d-list
    //
    (void)_RunLaguna( pdwNext );

}


/*********************************************************************
*
*   void LL_QueueOp( LL_Batch *pBatch )
*
*       Queues the operation.  This function supports programming the
*       l3d without using the arrays of batch cells and vertex cells.
*       Instead of building a batch command, all the parameters that
*       are to be set in a batch are passed in this function.
*
*   Where:
*
*       pBatch->bOp is the operation (eg. LL_LINE)
*       pBatch->wCount is the generic count
*       pBatch->dwFlags are the operation flags
*       pBatch->wBuf is the buffer/texture designator
*       pBatch->pVert is the pointer to a vertex array defining the operation
*
**********************************************************************/
void LL_QueueOp( LL_Batch *pBatch )
{
    // We continue building the current display list
    // If instruction was IDLE, spin-off the current d-list
    //
    if( pBatch->bOp == LL_IDLE )
        (void)_RunLaguna( LL_State.pDL->pdwNext );
    else
        LL_State.pDL->pdwNext = (fnList[ pBatch->bOp ])( LL_State.pDL->pdwNext, pBatch );
}


/*********************************************************************
*
*   void LL_SetRenderingMode( DWORD dwMode )
*
*       Sets the rendering mode: coprocessor indirect or processor
*       mode.  By default, library will use processor mode and build
*       display list to execute it.
*
*   Where:
*
*       dwMode is one of LL_PROCESSOR_MODE
*                        LL_COPROCESSOR_MODE
*
*
**********************************************************************/
void LL_SetRenderingMode( DWORD dwMode )
{
    LL_State.fIndirectMode = dwMode;

    DEB2("Rendering mode set to: %sPROCESSOR\n", dwMode?"CO":"" );

    LL_Wait();
}



/*********************************************************************
*
*   void DumpDisplayList( DWORD *pPtr, DWORD dwLen )
*
*       Dumps the content of the display list to the file.  This function
*       can be used by a software developer for debugging.
*
*       The display list disassembler (sldis.exe) may be used to 
*       disassemble the display list:
*
*           sldis -i9 < list00.pci > list00.out
*
*   Where:
*
*       pPtr is the starting address to dump
*       dwLen is the number of dwords to dump
*
**********************************************************************/
void DumpDisplayList( DWORD *pPtr, DWORD dwLen )
{
    static int count = 0;
    static char *sName = "List00.pci";
    FILE *fp;
    DWORD i;

#ifndef CGL

//    if( count == 5 )
//        count = 4;

    sprintf(&sName[4], "%02X.pci", count++ );
    printf("Temp Name: %s\nSize:%d dwords", sName, dwLen );

    if( (fp=fopen(sName, "w" ))==NULL )
        return;

    for( i=0; i<dwLen; i++ )
    {
        fprintf(fp, "%08X  %08X\n", pPtr, *pPtr );

        pPtr++;
    }

    fclose(fp);
    fflush(NULL);
#else // CGL's DLL - no file io allowed
    printf("Temp Name: %s\nSize:%d dwords\n", sName, dwLen );
    for( i=0; i<dwLen; i++ )
    {
        printf("%08X  %08X\n", pPtr, *pPtr );flushall();

        pPtr++;
    }
#endif

}


/*********************************************************************
*
*   void LL_Wait()
*
*       Waits for enging to become not busy.  Use this call when
*       switching from display list mode to direct programming
*       mode to ensure that the engine is idle.
*
*
**********************************************************************/
void LL_Wait()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

#define MAX_COUNT 1000000
#define DELAY_COUNT  100


    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) { /*inp(0x80);*/ }

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

void LL_Wait2()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) inp(0x80);

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

void LL_Wait3()
{
    DWORD dwValue;
    int delay;
    volatile DWORD dwCount;

    dwCount = 0;

    // Poll the 3D engine to finish rendering
    //
    do
    {
        dwValue = *(volatile *)(LL_State.pRegs + PF_STATUS_3D);

        if (dwValue & LL_State.dwWaitMode) {printf("WARNING: 3rd wait busy, val=%08x\n",dwValue);}

        DEB2("LL_Wait... PF_STATUS_3D: %08X\n", dwValue );
        DEB2("LL_Wait... PF_INST_3D: %08X\n", *(LL_State.pRegs + PF_INST_3D) );

        // wait before polling again to give PCI a breather, unless 
        // the last read shows everything idle
        for( delay = 0; 
            (delay<DELAY_COUNT) && (dwValue & LL_State.dwWaitMode); 
             delay++ ) inp(0x80);

        if( dwCount++ == MAX_COUNT )
            _ShutDown("Laguna does not respond (PF_STATUS is %08X)", dwValue );

    } while(dwValue & LL_State.dwWaitMode );
}

#endif // ndef OPENGL_MCD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\enable.c ===
/******************************Module*Header*******************************\
 *
 * Module Name: enable.c
 *
 * This module contains the functions that enable and disable the
 * driver, the pdev, and the surface.
 *
 * Copyright (c) 1995,1996 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/ENABLE.C  $
* 
*    Rev 1.46   Jan 20 1998 11:44:38   frido
* The fDataStreaming flag has changed its value from 1 into 0x80000000.
* 
*    Rev 1.45   Nov 04 1997 10:12:24   frido
* Added IOCtl call to Miniport to get the AGPDataStreaming value.
* 
*    Rev 1.44   Nov 03 1997 15:21:46   frido
* Added REQUIRE macros.
* 
*    Rev 1.43   16 Oct 1997 09:55:04   bennyn
* 
* Added bPrevModeDDOutOfVideoMem to DrvResetPDEV
* 
*    Rev 1.42   08 Aug 1997 17:24:00   FRIDO
* Added support for new memory manager.
* 
*    Rev 1.41   02 Jul 1997 15:56:00   noelv
* Added LgMatchDriverToChip() function.  Moved driver/chip match from bin
* from binitSurface to DrvEnablePdev()
* 
*    Rev 1.40   29 Apr 1997 16:28:40   noelv
* 
* Merged in new SWAT code.
* SWAT: 
* SWAT:    Rev 1.3   24 Apr 1997 11:37:28   frido
* SWAT: NT140b09 merge.
* SWAT: 
* SWAT:    Rev 1.2   18 Apr 1997 00:15:02   frido
* SWAT: NT140b07 merge.
* SWAT: 
* SWAT:    Rev 1.1   09 Apr 1997 17:32:34   frido
* SWAT: Called vAssertModeText in DrvAssertMode.
* 
*    Rev 1.39   09 Apr 1997 10:50:40   SueS
* Changed sw_test_flag to pointer_switch.
* 
*    Rev 1.38   09 Apr 1997 07:52:38   noelv
* Disabled the MCD code for NT 3.51
* 
*    Rev 1.37   08 Apr 1997 12:21:24   einkauf
* 
* new hooks for MCD when reset; add SYNC/IDLE for MCD/2D coordination
* 
*    Rev 1.36   21 Mar 1997 10:59:12   noelv
* 
* Combined the loggong flags into one ENABLE_LOGFILE flag.
* Removed PROFILE_DRIVER flag
* Added code to initialize QfreeData
* 
*    Rev 1.35   26 Feb 1997 13:19:42   noelv
* 
* Disable MCD code for NT 3.5x
* 
*    Rev 1.34   26 Feb 1997 09:22:10   noelv
* 
* Changed initial debugging message for 5465
* Added init code for MCD
* 
*    Rev 1.33   19 Feb 1997 13:15:32   noelv
* 
* Added translation table cache
* 
*    Rev 1.32   28 Jan 1997 16:18:42   bennyn
* Commented out "DrvEnableSurface failed bInitSurf" message
* 
*    Rev 1.31   06 Jan 1997 11:04:28   SueS
* Enabled DrvLineTo, since it's been fixed.
* 
*    Rev 1.30   18 Dec 1996 11:38:22   noelv
* 
* Unhooked DrvLineTo, 'cause it's broken.
* 
*    Rev 1.29   17 Dec 1996 16:53:24   SueS
* Added test for writing to log file based on cursor at (0,0).
* 
*    Rev 1.28   27 Nov 1996 11:32:44   noelv
* Disabled Magic Bitmap.  Yeah!!!
* 
*    Rev 1.27   26 Nov 1996 10:16:58   SueS
* Changed WriteLogFile parameters for buffering.
* 
*    Rev 1.26   13 Nov 1996 16:58:14   SueS
* Changed WriteFile calls to WriteLogFile.
* 
*    Rev 1.25   13 Nov 1996 08:17:18   noelv
* 
* Disabled test blt.
* 
*    Rev 1.24   07 Nov 1996 16:11:54   bennyn
* 
* Restore lost version (add drvresetPDEV support)
* 
*    Rev 1.23   31 Oct 1996 11:15:40   noelv
* 
* Split common buffer into two buffers.
* 
*    Rev 1.22   24 Oct 1996 14:40:38   noelv
* Demo bus master capabilities of 5464
* 
*    Rev 1.20   06 Sep 1996 08:55:02   noelv
* Hooked DrvStrokeAndFillPath and DrvStretchBlt when doinng analysis.
* 
*    Rev 1.19   20 Aug 1996 11:03:24   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.3   18 Aug 1996 22:48:36   frido
* #lineto - Added DrvLineTo.
* 
*    Rev 1.2   15 Aug 1996 12:09:34   frido
* Fixed NT 3.51/4.0 in DrvEnablePDEV.
* 
*    Rev 1.1   15 Aug 1996 11:42:40   frido
* Added precompiled header.
* 
*    Rev 1.0   14 Aug 1996 17:16:20   frido
* Initial revision.
* 
*    Rev 1.18   07 Aug 1996 09:34:04   noelv
* 
* re-hooked textout
* 
*    Rev 1.17   25 Jul 1996 15:57:44   bennyn
* 
* Modified for DirectDraw
* 
*    Rev 1.16   12 Jul 1996 09:38:22   bennyn
* Added getdisplayduration call for DirectDraw
* 
*    Rev 1.15   11 Jul 1996 15:53:50   bennyn
* 
* Added DirectDraw support
* 
*    Rev 1.14   17 May 1996 12:55:34   bennyn
* Fixed the problem NT40 allocate 400x90 twice
* 
*    Rev 1.13   16 May 1996 14:54:22   noelv
* Added logging code.
* 
*    Rev 1.12   01 May 1996 12:06:44   bennyn
* 
* Fixed resolution change bug for NT 4.0
* 
*    Rev 1.11   01 May 1996 10:59:10   bennyn
* 
* Modified for NT4.0
* 
*    Rev 1.10   25 Apr 1996 22:39:50   noelv
* Cleaned up data logging.
 * 
 *    Rev 1.9   04 Apr 1996 13:20:14   noelv
 * Frido release 26
 * 
 *    Rev 1.13   02 Apr 1996 09:08:36   frido
 * Bellevue lg102b04 release.
 * 
 *    Rev 1.12   28 Mar 1996 20:02:18   frido
 * Added new comments.
 * 
 *    Rev 1.11   28 Mar 1996 20:01:00   frido
 * Fixed bouncing screeen when cursor is disabled.
 * 
 *    Rev 1.10   25 Mar 1996 12:05:34   frido
 * Changed #ifdef LOG_CALLS into #if LOG_CALLS.
 * Removed warning message.
 * 
 *    Rev 1.9   25 Mar 1996 11:52:46   frido
 * Bellevue 102B03.
 * 
 *    Rev 1.5   12 Mar 1996 15:45:28   noelv
 * Added support for data logging and stroke and fill.
 * 
 *    Rev 1.8   12 Mar 1996 16:50:14   frido
 * Added stroke and fill stuff.
 * 
 *    Rev 1.7   29 Feb 1996 20:23:24   frido
 * Added bEnable flag in PPDEV.
 * 
 *    Rev 1.6   29 Feb 1996 19:25:08   frido
 * Turned HOOK_TEXTOUT flags back on for 16-bpp modes and higher.
 * 
 *    Rev 1.5   27 Feb 1996 16:38:10   frido
 * Added device bitmap store/restore.
 * 
 *    Rev 1.4   24 Feb 1996 01:24:18   frido
 * Added device bitmaps.
 * 
 *    Rev 1.3   03 Feb 1996 13:40:24   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 * 
 *    Rev 1.2   23 Jan 1996 15:14:26   frido
 * Added call to DrvDestroyFont.
 *
\**************************************************************************/

#include "precomp.h"
#include "SWAT.h"
#include "CLIOCtl.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },

//
//  Laguna Functions:
//
   {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
   {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
   {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize        },
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
   {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
   {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
   {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
   {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
   {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
   {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont	       },
   {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
   {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
   {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
   {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
#ifdef WINNT_VER40
   {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo  },
   {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw   },
   {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw  },
   {   INDEX_DrvLineTo,                (PFN) DrvLineTo             },
   {   INDEX_DrvResetPDEV,             (PFN) DrvResetPDEV          },
   #define LGHOOK_LINETO HOOK_LINETO
#else
   #define LGHOOK_LINETO 0
#endif


//
// We don't accelerate DrvStrokeAndFillPath or DrvStrethcBlt.  
// But we do want to hook them if we're doing driver analysis.
//
#if NULL_STROKEFILL 
   {   INDEX_DrvStrokeAndFillPath,     (PFN) DrvStrokeAndFillPath  },
   #define LGHOOK_STROKEANDFILLPATH HOOK_STROKEANDFILLPATH
#else
   #define LGHOOK_STROKEANDFILLPATH 0
#endif

#if NULL_STRETCH 
   {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
   #define LGHOOK_STRETCHBLT HOOK_STRETCHBLT
#else
   #define LGHOOK_STRETCHBLT 0
#endif    
   {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};


//
// Define the functions you want to hook for 8/16/24/32 pel formats
// We do not need to set HOOK_SYNCHRONIZEACCESS because we only support a
// single surface at the moment.  GDI only permits one thread to draw to
// a surface at a time.
// When we impliment device bitmaps, we may need to set this.
//
#define HOOKS_BMF8BPP (HOOK_BITBLT | HOOK_PAINT | HOOK_COPYBITS | HOOK_TEXTOUT \
		      | HOOK_STROKEPATH | LGHOOK_LINETO | HOOK_FILLPATH \
		      | LGHOOK_STROKEANDFILLPATH | LGHOOK_STRETCHBLT \
		      | HOOK_SYNCHRONIZE | HOOK_SYNCHRONIZEACCESS )

#define HOOKS_BMF16BPP  HOOKS_BMF8BPP
#define HOOKS_BMF24BPP  HOOKS_BMF8BPP
#define HOOKS_BMF32BPP  HOOKS_BMF8BPP


#if DRIVER_5465
    #define _DISP_ "CL5465.DLL"
#else
    #define _DISP_ "CL546x.DLL"
#endif

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

// Fill in as much as we can.

#ifdef WINNT_VER40
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 4.0.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 4.0.\n"));
    #endif // if DRIVER_5465
#else
    #if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 5465 DISPLAY DRIVER for NT 3.5x.\n"));
    #else // if DRIVER_5465
        DISPDBG((1, " ==> Cirrus Logic 546x DISPLAY DRIVER for NT 3.5x.\n"));
    #endif // if DRIVER_5465
#endif

    if (cj >= sizeof(DRVENABLEDATA))
	pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
	pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
	pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    DISPDBG((1, _DISP_ " DrvDisableDriver\n"));
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
#ifdef WINNT_VER40
HDEV		hdev,
#else
PWSTR       pwszDataFile,   // DataFile - not used
#endif
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Entry.\n"));

    // Allocate a physical device structure.
    #ifdef WINNT_VER40
        ppdev = (PPDEV) MEM_ALLOC(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    #else
        ppdev = (PPDEV) MEM_ALLOC(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PDEV));
    #endif

    if (ppdev == (PPDEV) NULL)
    {
        RIP(_DISP_ " DrvEnablePDEV failed MEM_ALLOC\n");
        return((DHPDEV) 0);
    }

    // Save the screen handle in the PDEV.
    ppdev->hDriver = hDriver;
    ppdev->pjScreen = 0;

   	//
    // Verify the driver matches the chip.
    //
    if (!LgMatchDriverToChip(ppdev))
    {
        #if DRIVER_5465
            DISPDBG((1," Chip doesn't match CL5465 driver.  Failing.\n"));
        #else
            DISPDBG((1," Chip doesn't match CL546x driver.  Failing.\n"));
        #endif
        goto error_free;
    }

    // Init MCD.
    #ifndef WINNT_VER35
        ppdev->hMCD = NULL;
        ppdev->NumMCDContexts = 0;
    #endif

    // Initialize the offscreen manager initial flag to FALSE
    ppdev->OFM_init = FALSE;

    // Initialize the color translation caches to NULL
    ppdev->XlateCache = NULL;

    // Initialize the pofmMagic to NULL
    #if WINBENCH96
        ppdev->pofmMagic = NULL;
    #endif

	#if DATASTREAMING
	{
		ULONG	ulReturn;
		BOOL	fDataStreaming = FALSE;

		if (! DEVICE_IO_CTRL(ppdev->hDriver,
							 IOCTL_GET_AGPDATASTREAMING,
							 NULL,
							 0,
							 (PVOID) &fDataStreaming,
							 sizeof(fDataStreaming),
							 &ulReturn,
							 NULL) )
		{
                        DISPDBG( (1, _DISP_ " DrvEnablePDEV: failed to get "
					  "AGPDataStreaming flag\n") );
			fDataStreaming = FALSE;	// default to OFF
		}
		ppdev->dwDataStreaming = fDataStreaming ? 0x80000000 : 0;
	}
	#endif

    // Get the current screen mode information.  Set up device caps and devinfo.
    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((1,_DISP_ " DrvEnablePDEV: bInitPDEV failed\n"));
        goto error_free;
    }

    // Initialize palette information.
    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPalette\n");
        goto error_free;
    }

    // Initialize device standard patterns.
    if (!bInitPatterns(ppdev, min(cPatterns, HS_DDI_MAX)))
    {
        RIP(_DISP_ " DrvEnablePDEV: failed bInitPatterns\n");
        vDisablePatterns(ppdev);
        vDisablePalette(ppdev);
        goto error_free;
    }

    // Copy the devinfo into the engine buffer.
    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the ahsurfPatterns array to handles each of the standard
    // patterns that were just created.
    memcpy((PVOID)ahsurfPatterns, ppdev->ahbmPat, ppdev->cPatterns*sizeof(HBITMAP));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.
    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    #if ENABLE_LOG_FILE
    {
        char buf[256];
        int i1;

        #if ENABLE_LOG_SWITCH
            if (pointer_switch == 1)
        #endif
        {
           DISPDBG((1, _DISP_ " Creating log file.\n"));
           CreateLogFile(ppdev->hDriver, &ppdev->TxtBuffIndex);
           ppdev->pmfile = ppdev->hDriver;   // handle to the miniport

           if (ppdev->pmfile == (HANDLE)-1)  // INVALID_HANDLE_VALUE
 	       RIP( _DISP_ " Couldn't create log file!\n");

           i1 = sprintf(buf, _DISP_ " Log file opened.\r\n");
           WriteLogFile(ppdev->pmfile, buf, i1, ppdev->TxtBuff, &ppdev->TxtBuffIndex);
        }

    }
    #endif
    #if LOG_QFREE
    {
        int i;
        for (i=0; i<32; ++i)
            QfreeData[i] = 0;
    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnablePDEV: Succeeded.\n"));
    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    MEMORY_FREE(ppdev);
    DISPDBG((1, _DISP_ " DrvEnablePDEV: Failed.\n"));
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    DISPDBG((1, _DISP_ " DrvCompletePDEV\n"));
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisablePDEV\n"));

    ppdev = (PPDEV) dhpdev;

    vDisablePalette((PPDEV) dhpdev);
    vDisablePatterns((PPDEV) dhpdev);

    MEMORY_FREE(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    DISPDBG((1, _DISP_ " DrvEnableSurface Entry.\n"));

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;


    if (!bInitSURF(ppdev, TRUE))
    {
        // Comments out this message because new two drivers model will break
        // here every time from power-up.
        //	RIP(_DISP_ " DrvEnableSurface failed bInitSURF\n");
        goto ReturnFailure;
    }

#ifdef WINNT_VER40
	ppdev->pvTmpBuffer = MEM_ALLOC(0, TMP_BUFFER_SIZE, ALLOC_TAG);
#else
	ppdev->pvTmpBuffer = VirtualAlloc(NULL, TMP_BUFFER_SIZE, MEM_RESERVE |
									  MEM_COMMIT, PAGE_READWRITE);
#endif

	if (ppdev->pvTmpBuffer == NULL)
	{
                DISPDBG((1, _DISP_ " DrvEnableSurface - Failed VirtualAlloc"));
		goto ReturnFailure;
	}

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 8)
    {
	if (!bInit256ColorPalette(ppdev)) {
	    RIP(_DISP_ " DrvEnableSurface failed to init the 8bpp palette\n");
		goto ReturnFailure;
	}
	ulBitmapType = BMF_8BPP;
	flHooks = HOOKS_BMF8BPP;
    }
    else if (ppdev->ulBitCount == 16)
    {
	ulBitmapType = BMF_16BPP;
	flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
	ulBitmapType = BMF_24BPP;
	flHooks = HOOKS_BMF24BPP;
    }
    else
    {
	ulBitmapType = BMF_32BPP;
	flHooks = HOOKS_BMF32BPP;
    }

    hsurf = (HSURF) EngCreateBitmap(sizl,
				    ppdev->lDeltaScreen,
				    ulBitmapType,
				    (ppdev->lDeltaScreen > 0) ? BMF_TOPDOWN : 0,
					(PVOID) (ppdev->pjScreen));

    if (hsurf == (HSURF) 0)
    {
	RIP(_DISP_ " DrvEnableSurface failed EngCreateBitmap\n");
		goto ReturnFailure;
    }

	ppdev->bEnable = TRUE;

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
	RIP(_DISP_ " DrvEnableSurface failed EngAssociateSurface\n");
	EngDeleteSurface(hsurf);
		goto ReturnFailure;
    }

    ppdev->hsurfEng = hsurf;
    ppdev->iBitmapFormat = ulBitmapType;

    if (!bEnableText(ppdev))
	goto ReturnFailure;

#ifdef WINNT_VER40
   // Accurately measure the refresh rate for DirectDraw use
   vGetDisplayDuration(&ppdev->flipRecord);
#endif


    //
    // Demo HostToScreen BLT
    //
    #if BUS_MASTER
    if (ppdev->BufLength)
    {
        unsigned long i;
        unsigned long temp;
        DWORD *bufD = (DWORD *)ppdev->Buf1VirtAddr;


        //
        // init the buffer.
        //
        for (i=0; i<ppdev->BufLength/4; ++i)
            bufD[i] = 0x87654321;

        DISPDBG((1, _DISP_ " bInitSurf: \n\n **** TestBLT **** \n"));

        // Enable the HOST XY unit.
        LL32(grHXY_HOST_CRTL_3D, 1);

        // Write host address.
        LL32(grHXY_BASE1_ADDRESS_PTR_3D, ppdev->Buf1PhysAddr);

        // Offset into host buffer is 0
        LL32(grHXY_BASE1_OFFSET0_3D, 0);
        LL32(grHXY_BASE1_OFFSET1_3D, 0);

        // Setup 2D engine.
		REQUIRE(8);
        LL16 (grBLTDEF, 0x1020);  // OP1 is host, RES is screen 
        LL16 (grDRAWDEF, 0xCC);   // SRCCPY

        // Source and destination XY address.
        LL16 (grOP1_opRDRAM.pt.X, 0); // source phase
        LL16 (grOP0_opRDRAM.pt.X, 0); // Destination x = 0;
        LL16 (grOP0_opRDRAM.pt.Y, 0); // Destination y = 0;

        // Size of destination rectangle.
        // This starts the 2D engine.
        LL16 (grMBLTEXT_EX.pt.X, 128);  // Width
        LL16 (grBLTEXT_EX.pt.Y, 16);    // Height

        // Write the length of the host data (in bytes)
        // This starts the Host XY unit.
        LL32(grHXY_BASE1_LENGTH_3D, ppdev->BufLength);


        //
        // Wait until HOST XY unit goes idle.
        //
        do {
            temp = LLDR_SZ (grPF_STATUS_3D);
        } while (temp & 0x80);

        DISPDBG((1, _DISP_ "        PF_STATUS: 0x%08X\n", temp));

    }
    #endif

    DISPDBG((1, _DISP_ " DrvEnableSurface Exit.\n"));
    return(hsurf);

ReturnFailure:
    
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((1, _DISP_ " Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;

    DISPDBG((1, _DISP_ " DrvDisableSurface Entry.\n"));

    ppdev = (PPDEV) dhpdev;

    ENSURE_3D_IDLE(ppdev);  

    if (((PPDEV) dhpdev)->pvTmpBuffer)
#ifdef WINNT_VER40
    	MEMORY_FREE(((PPDEV) dhpdev)->pvTmpBuffer);
#else
	    VirtualFree(((PPDEV) dhpdev)->pvTmpBuffer, 0, MEM_RELEASE);
#endif

    // Close the offscreen manager
    CloseOffScnMem((PPDEV) dhpdev);

#ifdef WINNT_VER40
   if (ppdev->CShsem != NULL)
   	EngDeleteSemaphore(ppdev->CShsem);
#else
    DeleteCriticalSection(&ppdev->PtrCritSec);
#endif

    if (((PPDEV) dhpdev)->hsurfEng)
        EngDeleteSurface(((PPDEV) dhpdev)->hsurfEng);
    
    vDisableSURF((PPDEV) dhpdev);
    ((PPDEV) dhpdev)->hsurfEng = (HSURF) 0;
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

#ifdef WINNT_VER40
BOOL APIENTRY DrvAssertMode(
#else
VOID DrvAssertMode(
#endif

DHPDEV dhpdev,
BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    DISPDBG((1, _DISP_ " DrvAssertMode, en=%d\n",bEnable));

    ENSURE_3D_IDLE(ppdev);

    #ifndef WINNT_VER35
    if (ppdev->hMCD)
    {
        ppdev->pAssertModeMCD(ppdev,bEnable);
    }
    #endif

	ppdev->bEnable = bEnable;
    if (bEnable)
    {
    // The screen must be reenabled, reinitialize the device to clean state.

	    bInitSURF(ppdev, FALSE);

		#if SWAT3
		// Enable font cache.
		vAssertModeText(ppdev, TRUE);
		#endif
    }
    else
    {
	POFMHDL pofm, pofmNext;

	#if (HW_PRESET_BUG)
	    //
	    // Disable the HW cursor for real, since we are leaving graphics mode.
	    //
	    ULONG ultmp = LLDR_SZ (grCursor_Control);
	    ultmp &= 0xFFFE;
	    LL16 (grCursor_Control, ultmp);
	#endif

	#if 1 // SWAT3 - font cache removal is now in vAssertMoveText.
	// Disable font cache.
	vAssertModeText(ppdev, FALSE);
	#endif

	#if MEMMGR
	{
		// Hostify all device bitmaps.
		extern void HostifyAllBitmaps(PPDEV ppdev);
		HostifyAllBitmaps(ppdev);
	}
	#else
	// We have to move all off-screen device bitmaps to memory.
	for (pofm = ppdev->OFM_UsedQ; pofm; pofm = pofmNext)
	{
	    pofmNext = pofm->nexthdl;

	    if ( (pofm->pdsurf) && (pofm->pdsurf->pofm) )
	    {
	    	if (!bCreateDibFromScreen(ppdev, pofm->pdsurf))
	    	{
	    	    RIP("Error moving off-screen bitmap to DIB");
	    	    break;
	    	}
	    }
	}
	#endif
        // We must give up the display.
        // Call the kernel driver to reset the device to a known state.

	if (!DEVICE_IO_CTRL(ppdev->hDriver,
			     IOCTL_VIDEO_RESET_DEVICE,
			     NULL,
			     0,
			     NULL,
			     0,
			     &ulReturn,
			     NULL))
	{
	    RIP(_DISP_ " DrvAssertMode failed IOCTL");
	}
    }

#ifdef WINNT_VER40
    return TRUE;
#else
    return;
#endif
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((1, _DISP_ " DrvGetModes: Entry.\n"));

    cModes = getAvailableModes(hDriver,
			       (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
			       &cbModeSize);

    if (cModes == 0)
    {
            DISPDBG((1, _DISP_ " DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
	cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
	//
	// Now copy the information for the supported modes back into the output
	// buffer
	//

	cbOutputSize = 0;

	pVideoTemp = pVideoModeInformation;

	do
	{
	    if (pVideoTemp->Length != 0)
	    {
		if (cOutputModes == 0)
		{
		    break;
		}

		//
		// Zero the entire structure to start off with.
		//

		memset(pdm, 0, sizeof(DEVMODEW));

		//
		// Set the name of the device to the name of the DLL.
		//

		memcpy(&(pdm->dmDeviceName), L"cl546x", sizeof(L"cl546x"));

		pdm->dmSpecVersion = DM_SPECVERSION;
		pdm->dmDriverVersion = DM_SPECVERSION;

		//
		// We currently do not support Extra information in the driver
		//

		pdm->dmDriverExtra = DRIVER_EXTRA_SIZE;

		pdm->dmSize = sizeof(DEVMODEW);
		pdm->dmBitsPerPel = pVideoTemp->NumberOfPlanes *
				    pVideoTemp->BitsPerPlane;
		pdm->dmPelsWidth = pVideoTemp->VisScreenWidth;
		pdm->dmPelsHeight = pVideoTemp->VisScreenHeight;
		pdm->dmDisplayFrequency = pVideoTemp->Frequency;

#ifdef WINNT_VER40
	   pdm->dmDisplayFlags = 0;
	   pdm->dmFields = DM_BITSPERPEL       |
                      DM_PELSWIDTH        |
                      DM_PELSHEIGHT       |
                      DM_DISPLAYFREQUENCY |
                      DM_DISPLAYFLAGS     ;
#else
		if (pVideoTemp->AttributeFlags & VIDEO_MODE_INTERLACED)
		{
		    pdm->dmDisplayFlags |= DM_INTERLACED;
		}
#endif

		//
		// Go to the next DEVMODE entry in the buffer.
		//

		cOutputModes--;

		pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
						   DRIVER_EXTRA_SIZE);

		cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

	    }

	    pVideoTemp = (PVIDEO_MODE_INFORMATION)
		(((PUCHAR)pVideoTemp) + cbModeSize);

	} while (--cModes);
    }

    MEMORY_FREE(pVideoModeInformation);

    DISPDBG((1, _DISP_ " DrvGetModes: Exit.\n"));
    return cbOutputSize;

}


/**************************************************************************\
* DrvResetPDEV
*
\**************************************************************************/

BOOL DrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew)
{
    PPDEV ppdevOld, ppdevNew;

    DISPDBG((1, _DISP_ " DrvResetPDEV:\n"));

    ppdevOld = (PPDEV) dhpdevOld;
    ppdevNew = (PPDEV) dhpdevNew;

#ifndef WINNT_VER35

    ENSURE_3D_IDLE(ppdevOld);

    ppdevNew->iUniqueness = ppdevOld->iUniqueness + 1;
    ppdevNew->pAllocOffScnMem = AllocOffScnMem;
    ppdevNew->pFreeOffScnMem = FreeOffScnMem;

    ppdevNew->bPrevModeDDOutOfVideoMem = ppdevOld->bPrevModeDDOutOfVideoMem;

#endif // ndef WINNT_VER35

    return (TRUE);
};


/* ===========================================================================
*	LgMatchDriverToChip()                                                 
*
*	This driver code base compiles into several different DLLs, based on
*	what C Preprocessor symbols are defined at compile time.  This allows us
*	to build several different chip specific drivers from a single code base.
*
*	This function checks the Laguna chip ID and returns TRUE if the chip is
*	one supported by this DLL.
*
* ========================================================================== */
BOOL LgMatchDriverToChip(
    PPDEV ppdev
)
{
 	DWORD returnedDataLength;
	WORD DeviceID;
	VIDEO_PUBLIC_ACCESS_RANGES   VideoAccessRanges[2];
	BYTE *pLgREGS_PCI_ID;

	// Get a pointer to the HW registers.
	if (!DEVICE_IO_CTRL(ppdev->hDriver,
					 IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
					 NULL,                      // input buffer
					 0,
					 (PVOID) VideoAccessRanges, // output buffer
					 sizeof (VideoAccessRanges),
					 &returnedDataLength,
					 NULL))
	{
		RIP(_DISP_  "LgMatchDriverToChip - QUERY_PUBLIC_ACCESS_RANGES ioctl failed!\n");
		return (FALSE);
	}
	pLgREGS_PCI_ID = ((BYTE *)VideoAccessRanges[0].VirtualAddress) + 0x302;

    //Get the chip id.
    DeviceID =  *(WORD *)pLgREGS_PCI_ID;
        DISPDBG((1,_DISP_ " MatchDriverToChip: Chip ID is 0x%08X.\n",DeviceID));

	// Does this driver instance support this chip?
    #if DRIVER_5465
        // This is the 5465 driver.  Fail if not a 5465 or later.
        if (DeviceID < CL_GD5465)
        {
            return FALSE;
        }
    #else
        // This is the 546x driver.  Fail if a 5465 or later.
        if (DeviceID >= CL_GD5465)
        {
            return FALSE;
        }
	#endif

	return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\ddsurf.c ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1996, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) -
*
* FILE:     ddsurf.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module implements the DirectDraw SURFACE
*           components for the Laguna NT driver.
*
* MODULES:
*           DdLock()
*           DdUnlock()
*           CanCreateSurface()
*           CreateSurface()
*           DestroySurface()
*
* REVISION HISTORY:
*   7/12/96     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ddsurf.c  $
* 
*    Rev 1.25   May 01 1998 11:33:02   frido
* Added one more check for PC98.
* 
*    Rev 1.24   May 01 1998 11:07:24   frido
* Finally the programmable blitter stride works.
* 
*    Rev 1.23   Mar 30 1998 13:04:38   frido
* Added one more call to Set256ByteFetch if an overlay failed to be created.
* 
*    Rev 1.22   Mar 25 1998 18:09:44   frido
* PDR#11184. Finally. When overlays are turned on, 256-byte fetch
* should be turned off. And when overlays are turned off again, 256-byte
* fetch should be restored.
* 
*    Rev 1.21   17 Oct 1997 11:29:48   bennyn
* Clear dwReserved1 after DestroySurface.
* 
*    Rev 1.20   16 Oct 1997 09:52:56   bennyn
* 
* Fixed the FlipCube FPS exceed refresh rate problem
* 
*    Rev 1.19   08 Oct 1997 11:29:38   RUSSL
* Fix so this file can be compiled without OVERLAY defined
* 
*    Rev 1.18   26 Sep 1997 11:01:14   bennyn
* Fixed PDR 10563
* 
*    Rev 1.17   16 Sep 1997 15:13:46   bennyn
* Added DD overlay support.
* 
*    Rev 1.16   03 Sep 1997 17:00:48   bennyn
* In CreateSurface() punts the request if at 320x240x8 or 320x200x8
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include <clioctl.h>

//
// This file isn't used in NT 3.51
//
#ifndef WINNT_VER35


/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK
#define DBGLVL        1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

#if DRIVER_5465 && defined(OVERLAY)
VOID GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount);
#endif

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

/*-------------------------- STATIC VARIABLES -----------------------------*/

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/

#if DRIVER_5465 // PDR#11184
VOID Set256ByteFetch(PPDEV ppdev, BOOL fEnable)
{
	ULONG ulStall = 50 * 1000;
	ULONG ulReturn;

	while (LLDR_SZ(grSTATUS) != 0) ;	// Wait for idle chip.
	while (LLDR_SZ(grQFREE) != 25) ;	// Wait for empty FIFO queue.
	if (!DEVICE_IO_CTRL(ppdev->hDriver,		// Wait for 50 ms.
                        IOCTL_STALL,
                        &ulStall, sizeof(ulStall),
                        NULL, 0,
                        &ulReturn,
                        NULL))
    {
        RIP("Set256ByteFetch - IOCTL_STALL failed!\n");
    }

	if (fEnable)
	{
		// Restore the CONTROL2 register value.
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save);
	}
	else
	{
		// Disable 256-byte fetch after storing the current value.
		ppdev->DriverData.dwCONTROL2Save = LLDR_SZ(grCONTROL2);
		LL16(grCONTROL2, ppdev->DriverData.dwCONTROL2Save & ~0x0010);
	}
}
#endif

/****************************************************************************
* FUNCTION NAME: DdLock
*
* DESCRIPTION:   This callback is invoked whenever a surface is about
*                to be directly accessed by the user. This is where you
*                need to make sure that a surface can be safely accessed
*                by the user.
*                If your memory cannot be accessed while in accelerator
*                mode, you should take either take the card out of
*                accelerator mode or else return DDERR_SURFACEBUSY
*                If someone is accessing a surface that was just flipped
*                away from, make sure that the old surface (what was the
*                primary) has finished being displayed.
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DdLock(PDD_LOCKDATA lpLock)
{
#ifdef RDRAM_8BIT
  RECTL SrcRectl;
#endif

  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  HRESULT     ddrval;
  DWORD       tmp;


  DISPDBG((DBGLVL, "DDraw - DdLock\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpLock->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  SYNC_W_3D(ppdev);

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpLock->lpDDSurface->ddsCaps.dwCaps)
  {
    ppdev->dwDDLinearCnt++;
    return pDriverData->OverlayTable.pfnLock(ppdev, lpLock);
  }
#endif

#ifdef RDRAM_8BIT
  if (lpLock->lpDDSurface->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC)
  {
     if (lpLock->bHasRect)
        SrcRectl = lpLock->rArea;
     else
     {
        tmp = lpLock->lpDDSurface->lpGbl->fpVidMem;
        SrcRectl.top  = cvlxy(ppdev->lDeltaScreen, tmp, BYTESPERPIXEL);

        SrcRectl.left = SrcRectl.top & 0xFFFF;
        SrcRectl.top = (SrcRectl.top >> 16) & 0xFFFF;
        SrcRectl.bottom = SrcRectl.top + lpLock->lpDDSurface->lpGbl->wHeight;
        SrcRectl.right = SrcRectl.left + lpLock->lpDDSurface->lpGbl->wWidth;
     };

    ppdev->offscr_YUV.nInUse = TRUE;
    ppdev->offscr_YUV.SrcRect = SrcRectl;

	 ppdev->offscr_YUV.ratio = 0;
	 lpLock->lpDDSurface->lpGbl->dwReserved1 = 0;
  };
#endif

  // get the monitor frequency after a mode reset
  if (pDriverData->fReset)
  {
     vGetDisplayDuration(&ppdev->flipRecord);
     pDriverData->fReset = FALSE;
  };

  // Check to see if any pending physical flip has occurred.
  // Don't allow a lock if a blt is in progress:
  ddrval = vUpdateFlipStatus(&ppdev->flipRecord,
                             lpLock->lpDDSurface->lpGbl->fpVidMem);

  if (ddrval != DD_OK)
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return(DDHAL_DRIVER_HANDLED);
  };

  // don't allow a lock if a blt is in progress
  // (only do this if your hardware requires it)
  // Note: GD5462 requires it. Blitter and screen
  // access are not otherwise synchronized.
  if ((ppdev->dwDDLinearCnt == 0) && (DrawEngineBusy(pDriverData)))
  {
     lpLock->ddRVal = DDERR_WASSTILLDRAWING;
     return DDHAL_DRIVER_HANDLED;
  };

  // Reference count it, just for the heck of it:
  ppdev->dwDDLinearCnt++;

  return(DDHAL_DRIVER_NOTHANDLED);

} // Lock


/****************************************************************************
* FUNCTION NAME: DdUnlock
*
* DESCRIPTION:
****************************************************************************/
DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock)
{
  PDEV* ppdev = (PDEV*) lpUnlock->lpDD->dhpdev;

  DISPDBG((DBGLVL, "DDraw - DdUnlock\n"));

#if DRIVER_5465 && defined(OVERLAY)
  if (DDSCAPS_OVERLAY & lpUnlock->lpDDSurface->ddsCaps.dwCaps)
    ppdev->DriverData.OverlayTable.pfnUnlock(ppdev,lpUnlock);
#endif

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev->dwDDLinearCnt--;

  return DDHAL_DRIVER_NOTHANDLED;

} // Unlock


/****************************************************************************
* FUNCTION NAME: CanCreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CanCreateSurface (PDD_CANCREATESURFACEDATA lpInput)
{
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;

  DISPDBG((DBGLVL, "DDraw - CanCreateSurface\n"));

  #ifdef DBGBRK
    DBGBREAKPOINT();
  #endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  // First check for overlay surfaces
  if (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
  {
    #if DRIVER_5465 && defined(OVERLAY)
        if (DDSCAPS_OVERLAY & lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps)
        {
            DWORD   dwFourCC;
            DWORD   dwBitCount;
            HRESULT hr;

            if (lpInput->bIsDifferentPixelFormat)
            {
                GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                            &dwFourCC, &dwBitCount);
            }
            else
            {
                dwBitCount = BITSPERPIXEL;
                if (16 == dwBitCount)
                dwFourCC = BI_BITFIELDS;
                else
                dwFourCC = BI_RGB;
            }

            hr = pDriverData->OverlayTable.pfnCanCreateSurface(ppdev,dwFourCC,dwBitCount);
            if (DD_OK != hr)
            {
                lpInput->ddRVal = hr;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    #else
        lpInput->ddRVal = DDERR_NOOVERLAYHW;;
        return (DDHAL_DRIVER_HANDLED);
    #endif
  }
  else if (lpInput->bIsDifferentPixelFormat)
  {
    // Next check for formats that don't match the primary surface.
    LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;

    if (lpFormat->dwFlags & DDPF_FOURCC)
    {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
            #if DRIVER_5465
                if (ppdev->iBitmapFormat == BMF_8BPP)
                    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
                else
                    lpInput->ddRVal = DD_OK;

                return (DDHAL_DRIVER_HANDLED);
                
            #else // 5462 and 5464 driver
                #if _WIN32_WINNT >= 0x0500
                    // For NT5 do not allow any YUV surfaces that are not
                    // overlays.
                    ;
                #else // NT4
                    // if we have nine bit RDRAMs then surface creation is okay
                    if (TRUE == pDriverData->fNineBitRDRAMS)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    }

                    // if we have eight bit RDRAMs then see if already
                    // have a YUV422 surface
                    else if (FALSE == ppdev->offscr_YUV.nInUse)
                    {
                        lpInput->ddRVal = DD_OK;
                        return (DDHAL_DRIVER_HANDLED);
                    };
                #endif
            #endif  // DRIVER_5465
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
    }
    else
    {
        // support RGB565 with RGB8 primary surface !!!
    };  // endif (lpFormat->dwFlags & DDPF_FOURCC)

    lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;

    return (DDHAL_DRIVER_HANDLED);
  }; // endif (lpInput->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)

  lpInput->ddRVal = DD_OK;

  return (DDHAL_DRIVER_HANDLED);
} // CanCreateSurface


/****************************************************************************
* FUNCTION NAME: InsertInDDOFSQ()
*
* DESCRIPTION:   Insert the handle into the DD Offscreen memory queue.
****************************************************************************/
void InsertInDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  hdl->prevhdl = NULL;

  if (ppdev->DDOffScnMemQ == NULL)
  {
    hdl->nexthdl = NULL;
    ppdev->DDOffScnMemQ = hdl;
  }
  else
  {
    ppdev->DDOffScnMemQ->prevhdl = hdl;
    hdl->nexthdl = ppdev->DDOffScnMemQ;
    ppdev->DDOffScnMemQ = hdl;
  };

} // InsertInDDOFSQ()



/****************************************************************************
* FUNCTION NAME: RemoveFrmDDOFSQ()
*
* DESCRIPTION:   Remove the handle from the DD Offscreen memory queue.
****************************************************************************/
BOOL RemoveFrmDDOFSQ(PPDEV  ppdev, DDOFM *hdl)
{
  DDOFM  *prvpds, *nxtpds;
  DDOFM  *pds;
  BOOL   fndflg;


  // Validate the release block
  fndflg = FALSE;
  pds = ppdev->DDOffScnMemQ;
  while (pds != 0)
  {
    if (hdl == pds)
    {
       fndflg = TRUE;
       break;
    };

    // Next free block
    pds = pds->nexthdl;
  }; // end while

  // Return if it is an invalid handle
  if (!fndflg)
     return (FALSE);

  prvpds = hdl->prevhdl;
  nxtpds = hdl->nexthdl;

  if (hdl == ppdev->DDOffScnMemQ)
  {
    ppdev->DDOffScnMemQ = nxtpds;

    if (nxtpds != 0)
       nxtpds->prevhdl = NULL;
  }
  else
  {
    if (nxtpds != NULL)
       nxtpds->prevhdl = prvpds;

    if (prvpds != NULL)
       prvpds->nexthdl = nxtpds;
  };

  // Free allocated DDOFM structure from host memory
  MEMORY_FREE(hdl);

  return (TRUE);
} // RemoveFrmDDOFSQ()



/****************************************************************************
* FUNCTION NAME: CreateSurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD CreateSurface (PDD_CREATESURFACEDATA lpInput)
{
  BOOL        puntflag = FALSE;
  BOOL        bYUVsurf;
#if DRIVER_5465 && defined(OVERLAY)
  BOOL        bOverlaySurf;
#endif  // #if DRIVER_5465 && defined(OVERLAY)
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  LPDDSURFACEDESC lpDDSurfaceDesc = lpInput->lpDDSurfaceDesc;
  LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurfaceDesc->ddpfPixelFormat;
  DWORD		  dwPitch = 0;

  DISPDBG((DBGLVL, "DDraw - CreateSurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;

  bYUVsurf = FALSE;
#if DRIVER_5465 && defined(OVERLAY)
  bOverlaySurf = FALSE;
#endif  // #if DRIVER_5465 && defined(OVERLAY)

#if DRIVER_5465

#ifdef ALLOC_IN_CREATESURFACE
{ // Support for 5465

  PDD_SURFACE_LOCAL  *lplpSurface;
  SIZEL   sizl;
  OFMHDL  *hdl = NULL;
  DDOFM   *pds;
  DWORD   i;

#if DRIVER_5465 && defined(OVERLAY)
  DWORD             dwBitCount;
  DWORD             dwFourCC;

  // check for overlay surface
  if (lpDDSurfaceDesc->ddsCaps.dwCaps & (  DDSCAPS_OVERLAY
#if DDRAW_COMPAT >= 50
                                         | DDSCAPS_VIDEOPORT
#endif
                                        ))
  {
    if (lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
    {
      GetFormatInfo(&(lpInput->lpDDSurfaceDesc->ddpfPixelFormat),
                    &dwFourCC, &dwBitCount);
    }
    else
    {
      dwFourCC = 0;
      dwBitCount = BITSPERPIXEL;
    }

#if DDRAW_COMPAT >= 50
    if((CL_GD5465 == pDriverData->dwLgVenDevID)
       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps))
    {
      if((lpDDSurfaceDesc->dwWidth * dwBitCount >> 3) >= 2048 )
      {
        //Surface is too wide for video port
        lpInput->ddRVal = DDERR_TOOBIGWIDTH;
        return DDHAL_DRIVER_HANDLED;
      }
    }
#endif

    bOverlaySurf = TRUE;

  } // end overlay surface handler
  else
#endif  // #if DRIVER_5465 && defined(OVERLAY)

  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           bYUVsurf = TRUE;
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

  // Not support 8BPP YUV surface
  if (
#if DRIVER_5465 && defined(OVERLAY)
      (!bOverlaySurf) &&
#endif  // #if DRIVER_5465 && defined(OVERLAY)
      ((bYUVsurf) && (8 == BITSPERPIXEL)))
  {
     lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
     return DDHAL_DRIVER_HANDLED;
  };  // endif (8 == BITSPERPIXEL)

  lplpSurface = lpInput->lplpSList;
  for (i = 0; i < lpInput->dwSCnt; i++)
  {
    PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

    sizl.cx = lpSurface->lpGbl->wWidth;
    sizl.cy = lpSurface->lpGbl->wHeight;

#if 1 // PC98
	if (   (lpDDSurfaceDesc->dwFlags == (DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH))
		&& (lpDDSurfaceDesc->ddsCaps.dwCaps == DDSCAPS_VIDEOMEMORY)
		&& (lpDDSurfaceDesc->dwHeight == 32 && lpDDSurfaceDesc->dwWidth == 32)
		&& (sizl.cx == 32 && sizl.cy == 32)
		&& (lpInput->dwSCnt == 1)
	)
	{
		sizl.cx = min(32 * 32, ppdev->lDeltaScreen / ppdev->iBytesPerPixel);
		sizl.cy = (32 * 32) / sizl.cx;
		if ( (sizl.cx * sizl.cy) < (32 * 32) )
		{
			sizl.cy++;
		}
		dwPitch = 32 * ppdev->iBytesPerPixel;
	}
#endif

#if DRIVER_5465 && defined(OVERLAY)
    // Adjust the overlay surface request size with pixel format 
    if (bOverlaySurf)
    {
       unsigned long  OvlyBPP;

       if (bYUVsurf)
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwYUVBitCount/8;
       else
          OvlyBPP = lpSurface->lpGbl->ddpfSurface.dwRGBBitCount/8;

       if (OvlyBPP > BYTESPERPIXEL)
          sizl.cx = (sizl.cx * OvlyBPP) / BYTESPERPIXEL;
    };
#endif  // #if DRIVER_5465 && defined(OVERLAY)

    // At certain modes (eg 1280x1024x24), When you runs MOV or AVI from
    // desktop, the DD CreateSurface has to punt the request back to DD 
    // due to no offscreen memmory available. When you hit ALT-ENTER to
    // go full screen, the appl swithces to mode (320x240x8 or 320x200x8),
    // create DD surfaces and then directly write to the DD surfaces.
    // Unfortunely, in those modes the pitch is 640 but the appl assumes
    // the pitch is 320 and we got half screen of the imagine.
    //
    // To fix the problem, just fails the create surface for those 
    // particule request.
    //
    puntflag = FALSE;
    if (ppdev->iBytesPerPixel == 1)
    {
       if ((ppdev->cxScreen == 320) && (sizl.cx == 320))
       {
          if (((ppdev->cyScreen == 240) && (sizl.cy == 240)) ||
              ((ppdev->cyScreen == 200) && (sizl.cy == 200)))
          {
             // Punt the create surface cause FlipCube FPS exceeds the
             // refresh rate.
             // So in order to bypass the above problem, it is looking for
             // bPrevModeDDOutOfVideoMem to be set when create surface fails
             // due to out of video memory in the previous mode before
             // punting the request.
             if (ppdev->bPrevModeDDOutOfVideoMem)
                puntflag = TRUE;
          };
       };
    };

    if (!puntflag)
    {
#if DRIVER_5465 && defined(OVERLAY)
		if (bOverlaySurf)
		{
			hdl = AllocOffScnMem(ppdev, &sizl, EIGHT_BYTES_ALIGN, NULL);
		}
		else
#endif  // #if DRIVER_5465 && defined(OVERLAY)
			hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

#if 1 // PC98
		if (!bOverlaySurf)
#endif
       // Somehow when allocate the bottom of the offscreen memory to
       // DirectDraw, it hangs the DirectDraw.
       // The following is temporary patch fix for the problem
       {
         BOOL   gotit;
         ULONG  val;
         ULONG  fpvidmem;

         val = ppdev->lTotalMem - 0x20000;
         gotit = FALSE;
         while ((!gotit) && (hdl != NULL))
         {
            fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

            if (fpvidmem > val)
            {
               pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
               if (pds==NULL) 
               {
                    FreeOffScnMem(ppdev, hdl);
                    lpInput->ddRVal = DDERR_OUTOFMEMORY;
                    return DDHAL_DRIVER_NOTHANDLED;
               }
               pds->prevhdl = 0;
               pds->nexthdl = 0;
               pds->phdl = hdl;

               InsertInDDOFSQ(ppdev, pds);
               hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
            }
            else
            {
               gotit = TRUE;
            };
         };  // endwhile
       }

       lpSurface->dwReserved1 = 0;

       if (hdl != NULL)
       {
#ifdef WINNT_VER40
          if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
          if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
          {
             ppdev->bPrevModeDDOutOfVideoMem = FALSE;

             // If pixel format is difference from FB, set the flag
             if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
             {
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             };

//           lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
             if (bYUVsurf)
             {
                lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
                lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
                lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth;
                lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;
                lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
             }; // endif (bYUVsurf)

#if DRIVER_5465 && defined(OVERLAY)
             if (bOverlaySurf)
             {
#if DDRAW_COMPAT >= 50
               if (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
#endif
               {
                 HRESULT hResult;

#if 1 // PDR#11184
// Finally... When overlays are turned on, 256-byte fetch should be turned off.
					if (pDriverData->dwOverlayCount++ == 0)
					{
						Set256ByteFetch(ppdev, FALSE);
					}
#endif

                 lpSurface->dwReserved1 = (DWORD) pds;
                 hResult = pDriverData->OverlayTable.pfnCreateSurface(ppdev,
                                                                      lpSurface,
                                                                      dwFourCC);

                 if (DD_OK != hResult)
                 {
					#if 1 // PDR#11184
					// Decrement overlay counter and maybe turn 256-byte fetch
					// back on.
					if (--pDriverData->dwOverlayCount == 0)
					{
						Set256ByteFetch(ppdev, TRUE);
					}
					#endif

                   // Free the allocated offscreen memory
                   FreeOffScnMem(ppdev, hdl);

                   // Free allocated DDOFM structure from host memory
            	    MEMORY_FREE(pds);

                   lpSurface->dwReserved1 = 0;

                   lpInput->ddRVal = hResult;
                   return DDHAL_DRIVER_HANDLED;
                 }
               }

// don't need this for NT yet
#if 0
               // if the surface width is larger than the display pitch, or
               // its a 5465, and a videoport surface wider than 2048 bytes or
               // its a CLPL surface
               // then convert to a linear allocation
               //
               // prior to DX5 we never even get called for surfaces wider than 
               // the display pitch

               if (   (FOURCC_YUVPLANAR == dwFourCC)
#if DDRAW_COMPAT >= 50
                   || (lpSurface->lpGbl->dwBlockSizeX > pDriverData->ScreenPitch)
                   || (   (CL_GD5465 == pDriverData->dwLgVenDevID)
                       && (DDSCAPS_VIDEOPORT & lpDDSurfaceDesc->ddsCaps.dwCaps)
                       && (2048 <= pDriverData->ScreenPitch)
                      )
#endif
                  )
               {
                 // fake a linear space in rectangular memory
                 LP_SURFACE_DATA   lpSurfaceData = (LP_SURFACE_DATA)(lpSurface->dwReserved1);
                 DWORD             dwTotalBytes;
                 DWORD             dwNumScanLines;

                 lpSurfaceData->dwOverlayFlags |= FLG_LINEAR;

                 // CLPL surfaces need 3/4 of the space an equivalent size
                 // YUV422 surface would need, the space allocated for the
                 // Y values is the width * height and the space for the UV
                 // interleaved values is half again as much.  Pad the Y
                 // region so the UV interleaved data is on a qword boundary
                 // in aperture 0
                 if (FOURCC_YUVPLANAR == dwFourCC)
                 {
                   // compute space needed for Y values
                   dwTotalBytes = ((lpSurface->lpGbl->wHeight * lpSurface->lpGbl->wWidth) + 7) & ~7;

                   // add on space for UV interleaved values
                   dwTotalBytes += dwTotalBytes / 2;

                   // CLPL surfaces have pitch same as width
                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->wWidth;
                 }
                 // the normal case
                 else
                 {
                   dwTotalBytes = lpSurface->lpGbl->dwBlockSizeY *
                                  lpSurface->lpGbl->dwBlockSizeX;

                   lpSurface->lpGbl->lPitch = lpSurface->lpGbl->dwBlockSizeX;
                 }

                 dwNumScanLines = (dwTotalBytes + pDriverData->ScreenPitch - 1) /
                                  pDriverData->ScreenPitch;

                 lpSurface->lpGbl->dwBlockSizeY = dwNumScanLines;
                 lpSurface->lpGbl->dwBlockSizeX = pDriverData->ScreenPitch;

                 if (! pDriverData->fWeAllocDDSurfaces)
                 {
                   LOAD_THE_STILL(lpSurface->lpGbl->dwBlockSizeX,
                                  lpSurface->lpGbl->dwBlockSizeY);
                 }
                 lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;
               }
#endif  // if 0
             };  // endif (bOverlaySurf)
#endif  // #if DRIVER_5465 && defined(OVERLAY)

             pds->prevhdl = 0;
             pds->nexthdl = 0;
             pds->phdl = hdl;

             InsertInDDOFSQ(ppdev, pds);

             lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                           hdl->aligned_x;

             lpSurface->dwReserved1 = (DWORD) pds ;
             lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
             lpSurface->lpGbl->yHint = hdl->aligned_y;
#if 1 // PC98
			if (dwPitch)
			{
				lpSurface->lpGbl->lPitch = dwPitch;
			}
			else
#endif
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

#if 1 // PC98
			if (dwPitch)
			{
				lpDDSurfaceDesc->lPitch = dwPitch;
			}
			else
#endif
             lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
             lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

             // We handled the creation entirely ourselves, so we have to
             // set the return code and return DDHAL_DRIVER_HANDLED:
             lpInput->ddRVal = DD_OK;
          }
          else
          {
             FreeOffScnMem(ppdev, hdl);
             lpInput->ddRVal = DDERR_OUTOFMEMORY;
             return DDHAL_DRIVER_NOTHANDLED;
          };
       }
       else
       {
          ppdev->bPrevModeDDOutOfVideoMem = TRUE;

          lpInput->ddRVal = DDERR_OUTOFVIDEOMEMORY;
          return DDHAL_DRIVER_NOTHANDLED;

//          lpSurface->lpGbl->lPitch = (ppdev->iBytesPerPixel * sizl.cx + 3) & ~3;
//          lpSurface->lpGbl->dwUserMemSize = lpSurface->lpGbl->lPitch * sizl.cy;

//          if (bYUVsurf)
//             lpSurface->lpGbl->fpVidMem |= DDHAL_PLEASEALLOC_USERMEM;
       };  // if (hdl != NULL)
    }  // endif (puntflag)

    lplpSurface++;
  };  // endfor

  if (puntflag)
  {
     lpInput->ddRVal = DDERR_GENERIC;
     return DDHAL_DRIVER_HANDLED;
  };

  if (hdl != NULL)
  {
     lpInput->ddRVal = DD_OK;
     return DDHAL_DRIVER_HANDLED;
  }
  else
  {
     return DDHAL_DRIVER_NOTHANDLED;
  };
};  //  // Support for 5465

#endif // ALLOC_IN_CREATESURFACE

#else
{ // Support for 5462 or 5464

  // Do nothing except fill in the block size for YUV surfaces.
  // We tag and count the video surfaces in Blt32.
  if (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
  {
     // only support alternate pixel format in 8 & 16 bpp frame buffers
     if ((8 != BITSPERPIXEL) && (16 != BITSPERPIXEL))
     {
        lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
        return DDHAL_DRIVER_HANDLED;
     };

     // Specify the block size for non-RGB surfaces
     if (lpFormat->dwFlags & DDPF_FOURCC)
     {
        #if _WIN32_WINNT >= 0x0500
           // For NT5, do not allow any YUV surfaces for 5462 and 5464
           lpInput->ddRVal = DDERR_INVALIDPIXELFORMAT;
           return DDHAL_DRIVER_HANDLED;
        #endif

        // YUV422 surface
        if (lpFormat->dwFourCC == FOURCC_UYVY)
        {
           PDD_SURFACE_LOCAL  *lplpSurface;
           unsigned int i;

           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
           if (0 == pDriverData->NumVideoSurfaces)
           {
              // no video surfaces so we can create anu format we want
              pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              pDriverData->CurrentVideoFormat &= 0xFF00;

              pDriverData->CurrentVideoFormat |= FMT_VID_16BPP | FMT_VID_YUV422;

              if (2 == BYTESPERPIXEL)
              {
                 pDriverData->CurrentVideoFormat |= FMT_VID_GAMMA;
                 SetGamma(ppdev, pDriverData);
              };

              ppdev->grFORMAT = (ppdev->grFORMAT & 0xFF00) |
                                (pDriverData->CurrentVideoFormat & 0x00FF);

              LL16(grFormat, ppdev->grFORMAT);

              if (TRUE == pDriverData->fNineBitRDRAMS)
              {
                 LL8(grStop_BLT_2, ENABLE_VIDEO_FORMAT);
                 LL8(grExternal_Overlay, ENABLE_RAMBUS_9TH_BIT);
              }
              else // 8 bit RDRAMs
              {
                 LL8(grStart_BLT_2, ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
                 LL8(grStop_BLT_2,  ENABLE_VIDEO_FORMAT | ENABLE_VIDEO_WINDOW);
              };
           }
           else
           {
              if ((FMT_VID_16BPP | FMT_VID_YUV422) == pDriverData->CurrentVideoFormat)
              {
                 pDriverData->NumVideoSurfaces += (WORD)lpInput->dwSCnt;
              }
              else
              {
                 UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));
                 lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
                 return DDHAL_DRIVER_HANDLED;
              };
           };  // endif (0 == pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           SET_DRVSEM_YUV();
           ppdev->bYUVSurfaceOn = TRUE;

           bYUVsurf = TRUE;

           // They may have specified multiple surfaces
           lplpSurface = lpInput->lplpSList;
           for (i = 0; i < lpInput->dwSCnt; i++)
           {
             PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

             lpSurface->lpGbl->ddpfSurface.dwYUVBitCount = 16;
             lpSurface->lpGbl->ddpfSurface.dwYBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwUBitMask = (DWORD) -1;
             lpSurface->lpGbl->ddpfSurface.dwVBitMask = (DWORD) -1;
             lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

             if (CL_GD5462 == ppdev->dwLgDevID)
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth << 1;
             else
                lpSurface->lpGbl->dwBlockSizeX = lpSurface->lpGbl->wWidth * 3;

             lpSurface->lpGbl->dwBlockSizeY = lpSurface->lpGbl->wHeight;

             lpSurface->lpGbl->fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE;

             lplpSurface++;
           };  // endfor
        }; // endif (lpFormat->dwFourCC == FOURCC_UYVY)
     };  // endif (lpFormat->dwFlags & DDPF_FOURCC)
  }  // endif (lpInput->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)

#ifdef ALLOC_IN_CREATESURFACE
  {
    PDD_SURFACE_LOCAL  *lplpSurface;
    SIZEL   sizl;
    OFMHDL  *hdl;
    DDOFM   *pds;
    DWORD   i;

    lplpSurface = lpInput->lplpSList;
    for (i = 0; i < lpInput->dwSCnt; i++)
    {
      PDD_SURFACE_LOCAL lpSurface = *lplpSurface;

      if (bYUVsurf)
      {
         sizl.cx = lpSurface->lpGbl->dwBlockSizeX/ppdev->iBytesPerPixel;
         sizl.cy = lpSurface->lpGbl->dwBlockSizeY;
         lpSurface->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
      }
      else
      {
         sizl.cx = lpSurface->lpGbl->wWidth;
         sizl.cy = lpSurface->lpGbl->wHeight;
      };

      hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);

      // Somehow when allocate the bottom of the offscreen memory to
      // DirectDraw, it hangs the DirectDraw.
      // The following is temporary patch fix for the problem
      {
        BOOL   gotit;
        ULONG  val;
        ULONG  fpvidmem;

        val = ppdev->lTotalMem - 0x20000;
        gotit = FALSE;
        while ((!gotit) && (hdl != NULL))
        {
           fpvidmem  = (hdl->aligned_y * ppdev->lDeltaScreen) + hdl->aligned_x;

           if (fpvidmem > val)
           {
              pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG);
              if (pds==NULL) 
              {
                  FreeOffScnMem(ppdev, hdl);
                  lpInput->ddRVal = DDERR_OUTOFMEMORY;
                  return DDHAL_DRIVER_NOTHANDLED;
              }
              pds->prevhdl = 0;
              pds->nexthdl = 0;
              pds->phdl = hdl;

              InsertInDDOFSQ(ppdev, pds);
              hdl = AllocOffScnMem(ppdev, &sizl, PIXEL_AlIGN, NULL);
           }
           else
           {
              gotit = TRUE;
           };
        };  // endwhile
      }

      lpSurface->dwReserved1 = 0;

      if (hdl != NULL)
      {
#ifdef WINNT_VER40
         if ((pds = (DDOFM *) MEM_ALLOC (FL_ZERO_MEMORY, sizeof(DDOFM), ALLOC_TAG)) != NULL)
#else
         if ((pds = (DDOFM *) MEM_ALLOC (LPTR, sizeof(DDOFM))) != NULL)
#endif
         {
            pds->prevhdl = 0;
            pds->nexthdl = 0;
            pds->phdl = hdl;

            InsertInDDOFSQ(ppdev, pds);

            lpSurface->lpGbl->fpVidMem  = (hdl->aligned_y * ppdev->lDeltaScreen) +
                                          hdl->aligned_x;

            lpSurface->dwReserved1 = (DWORD) pds ;
            lpSurface->lpGbl->xHint = hdl->aligned_x/ppdev->iBytesPerPixel;
            lpSurface->lpGbl->yHint = hdl->aligned_y;
            lpSurface->lpGbl->lPitch = ppdev->lDeltaScreen;

            lpDDSurfaceDesc->lPitch   = ppdev->lDeltaScreen;
            lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;

            // We handled the creation entirely ourselves, so we have to
            // set the return code and return DDHAL_DRIVER_HANDLED:
            lpInput->ddRVal = DD_OK;
         }
         else
         {
            FreeOffScnMem(ppdev, hdl);
         };
      };  // if (hdl != NULL)

      lplpSurface++;
    };  // endfor

    if (hdl != NULL)
       return DDHAL_DRIVER_HANDLED;
    else
       return DDHAL_DRIVER_NOTHANDLED;
  };
#endif // ALLOC_IN_CREATESURFACE
} // Support for 5462 or 5464

#endif  // DRIVER_5465

  return DDHAL_DRIVER_NOTHANDLED;
} // CreateSurface


/****************************************************************************
* FUNCTION NAME: DestroySurface
*
* DESCRIPTION:
*                (Based on Laguna Win95 DirectDraw code)
****************************************************************************/
DWORD DestroySurface (PDD_DESTROYSURFACEDATA lpInput)
{
  PDD_SURFACE_LOCAL  lpLocalSurface;
  DRIVERDATA* pDriverData;
  PDEV*       ppdev;
  DDOFM       *hdl;

  DISPDBG((DBGLVL, "DDraw - DestroySurface\n"));

#ifdef DBGBRK
  DBGBREAKPOINT();
#endif

  ppdev = (PDEV*) lpInput->lpDD->dhpdev;
  pDriverData = (DRIVERDATA*) &ppdev->DriverData;
  lpLocalSurface = lpInput->lpDDSurface;

#if DRIVER_5465
{ // Support for 5465
#if DRIVER_5465 && defined(OVERLAY)
	// check for overlay surface
	if (lpInput->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
	{
		pDriverData->OverlayTable.pfnDestroySurface(ppdev,lpInput);
#if 1 // PDR#11184
		// Enable 256-byte fetch if the last overlay surface has been destroyed.
		if (--pDriverData->dwOverlayCount == 0)
		{
			Set256ByteFetch(ppdev, TRUE);
		}
#endif
	}

#endif
} // Support for 5465

#else
{ // Support for 5462 or 5464

  if (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)
  {
     LPDDPIXELFORMAT lpFormat = &lpInput->lpDDSurface->lpGbl->ddpfSurface;

     if (DDPF_FOURCC & lpFormat->dwFlags)
     {
        if (FOURCC_UYVY == lpFormat->dwFourCC)
        {
           GRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

           if (0 == --pDriverData->NumVideoSurfaces)
           {
              CLR_DRVSEM_YUV();

              // disable stuff if there's no more video windows
              pDriverData->CurrentVideoFormat = pDriverData->CurrentVideoFormat & 0xFF00;

              // These trash the video window left on screen
              //pDriverData->grFormat = pREG->grFormat & 0xFF00;
              //pDriverData->grStop_BLT_2 &= ~ENABLE_VIDEO_FORMAT;
              //pDriverData->grExternal_Overlay &= ~ENABLE_RAMBUS_9TH_BIT;
           }; // endif (0 == --pDriverData->NumVideoSurfaces)

           UNGRAB_VIDEO_FORMAT_SEMAPHORE(&(pDriverData->VideoSemaphore));

#ifdef RDRAM_8BIT
           if (FALSE == pDriverData->fNineBitRDRAMS)
           {
              // Need to Delete Rectangle and Clear Window
              ppdev->offscr_YUV.nInUse = FALSE;
              LL16(grX_Start_2, 0);
              LL16(grY_Start_2, 0);
              LL16(grX_End_2, 0);
              LL16(grY_End_2, 0);
           };
#endif
        }; // endif (FOURCC_UYVY == lpFormat->dwFourCC)
     };  // endif (DDPF_FOURCC & lpFormat->dwFlags)
  };  // endif (DDRAWISURF_HASPIXELFORMAT & lpInput->lpDDSurface->dwFlags)

} // Support for 5462 or 5464
#endif  // #endif DRIVER_5465


#ifdef ALLOC_IN_CREATESURFACE
  if (lpLocalSurface->dwReserved1 != 0)
  {
     hdl = (DDOFM *) lpLocalSurface->dwReserved1;
     FreeOffScnMem(ppdev, hdl->phdl);
     RemoveFrmDDOFSQ(ppdev, hdl);
     lpLocalSurface->dwReserved1 = 0;
  };

  lpInput->ddRVal = DD_OK;

  return DDHAL_DRIVER_HANDLED;
#endif // ALLOC_IN_CREATESURFACE

  return DDHAL_DRIVER_NOTHANDLED;

} // DestroySurface

#if DRIVER_5465 && defined(OVERLAY)
/***************************************************************************
*
* FUNCTION:     GetFormatInfo()
*
* DESCRIPTION:  This returns the FOURCC and the bit depth of the specified
*               format.  This is useful since DirectDraw has so many
*               different ways to determine the format.
*
****************************************************************************/

VOID
GetFormatInfo (LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc, LPDWORD lpBitCount)
{
  if (lpFormat->dwFlags & DDPF_FOURCC)
  {
    *lpFourcc = lpFormat->dwFourCC;
    if (lpFormat->dwFourCC == BI_RGB)
    {
      *lpBitCount = lpFormat->dwRGBBitCount;
#ifdef DEBUG
      if (lpFormat->dwRGBBitCount == 8)
      {
        DBG_MESSAGE(("Format: RGB 8"));
      }
      else if (lpFormat->dwRGBBitCount == 16)
      {
        DBG_MESSAGE(("Format: RGB 5:5:5"));
      }
#endif
    }
    else if (lpFormat->dwFourCC == BI_BITFIELDS)
    {
      if ((lpFormat->dwRGBBitCount != 16) ||
          (lpFormat->dwRBitMask != 0xf800) ||
          (lpFormat->dwGBitMask != 0x07e0) ||
          (lpFormat->dwBBitMask != 0x001f))
      {
        *lpFourcc = (DWORD) -1;
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: RGB 5:6:5"));
      }
    }
    else
    {
      lpFormat->dwRBitMask = (DWORD) -1;
      lpFormat->dwGBitMask = (DWORD) -1;
      lpFormat->dwBBitMask = (DWORD) -1;
      if (FOURCC_YUVPLANAR == lpFormat->dwFourCC)
      {
        *lpBitCount = 8;
        DBG_MESSAGE(("Format: CLPL"));
      }
      else
      {
        *lpBitCount = 16;
        DBG_MESSAGE(("Format: UYVY"));
      }
    }
  }
  else if (lpFormat->dwFlags & DDPF_RGB)
  {
    if (lpFormat->dwRGBBitCount == 8)
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0xf800) &&
             (lpFormat->dwGBitMask == 0x07e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_BITFIELDS;
      DBG_MESSAGE(("Format: RGB 5:6:5"));
    }
    else if ((lpFormat->dwRGBBitCount == 16)  &&
             (lpFormat->dwRBitMask == 0x7C00) &&
             (lpFormat->dwGBitMask == 0x03e0) &&
             (lpFormat->dwBBitMask == 0x001f))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 5:5:5"));
    }
    else if (((lpFormat->dwRGBBitCount == 24) ||
              (lpFormat->dwRGBBitCount == 32))  &&
             (lpFormat->dwRBitMask == 0xff0000) &&
             (lpFormat->dwGBitMask == 0x00ff00) &&
             (lpFormat->dwBBitMask == 0x0000ff))
    {
      *lpFourcc = BI_RGB;
      DBG_MESSAGE(("Format: RGB 8:8:8"));
    }
    else
    {
      *lpFourcc = (DWORD) -1;
    }
    *lpBitCount = lpFormat->dwRGBBitCount;
  }
  else if (DDPF_PALETTEINDEXED4 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 4;
  }
  else if (DDPF_PALETTEINDEXED8 & lpFormat->dwFlags)
  {
    *lpFourcc = (DWORD)-1;
    *lpBitCount = 8;
  }
  else if (lpFormat->dwRGBBitCount == 16)
  {
    *lpFourcc = BI_RGB;
    *lpBitCount = lpFormat->dwRGBBitCount;    // always 16 for now.
  }
  else
  {
    *lpFourcc = (DWORD) -1;
    *lpBitCount = 0;
  }
}
#endif // DRIVER_5465 && OVERLAY

#endif // ! ver 3.51




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\escape.c ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		escape.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module Handles escapes
*
* MODULES:
*           DrvEscape()
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/ESCAPE.C  $
* 
*    Rev 1.14   Dec 10 1997 13:32:12   frido
* Merged from 1.62 branch.
* 
*    Rev 1.13.1.0   Nov 10 1997 11:34:08   phyang
* Added 5 escape functions for utilities to update registry values.
* 
*    Rev 1.13   10 Sep 1997 10:40:36   noelv
* Modified QUERYESCSUPPORT to only return TRUE for escapes we actually suppor
* It was returning TRUE all the time.
* 
*    Rev 1.12   20 Aug 1997 15:49:42   bennyn
* 
* Added IS_CIRRUS_DRIVER escape support
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include "precomp.h"
#include "clioctl.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define DBGBRK

#define ESC_DBG_LVL 1


#if 0   // MCD not working good
#if ( DRIVER_5465 && !defined(WINNT_VER35) )
    #define CLMCD_ESCAPE_SUPPORTED
#endif
#endif// 0 MCD not working good



#ifdef CLMCD_ESCAPE_SUPPORTED
//    #define CLMCDDLLNAME	    "CLMCD.DLL"
//    #define CLMCDINITFUNCNAME   "CLMCDInit"

MCDRVGETENTRYPOINTSFUNC CLMCDInit(PPDEV ppdev);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/

#ifdef CLMCD_ESCAPE_SUPPORTED

typedef BOOL (*MCDRVGETENTRYPOINTSFUNC)(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);
typedef POFMHDL (*ALLOCOFFSCNMEMFUNC)(PPDEV ppdev, PSIZEL surf, ULONG alignflag, POFM_CALLBACK pcallback);
typedef BOOL    (*FREEOFFSCNMEMFUNC)(PPDEV ppdev, OFMHDL *hdl);
//typedef MCDRVGETENTRYPOINTSFUNC (*CLMCDINITFUNC)(PPDEV);

#endif // def CLMCD_ESCAPE_SUPPORTED


/*-------------------------- STATIC VARIABLES -----------------------------*/


/****************************************************************************
* FUNCTION NAME: DrvEscape()
*
* DESCRIPTION:   Driver escape entry point.
*
* REVISION HISTORY:
*   11/16/95     Benny Ng      Initial version
****************************************************************************/
ULONG APIENTRY DrvEscape(SURFOBJ *pso,
                         ULONG   iEsc,
                         ULONG   cjIn,
                         PVOID   pvIn,
                         ULONG   cjOut,
                         PVOID   pvOut)

{
  PPDEV ppdev = (PPDEV) pso->dhpdev;
  DWORD returnedDataLength = 0;
  ULONG retval = FALSE;

  PMMREG_ACCESS pInMRAccess;
  PMMREG_ACCESS pMRAccess;
  BYTE  *pbAddr;
  WORD  *pwAddr;
  DWORD *pdwAddr;

  DISPDBG((ESC_DBG_LVL, "DrvEscape-Entry.\n"));   

  switch (iEsc)
  {


    //
    // Prior to using an Escape, an application will ask us 
    // if we support it first.  Return TRUE if we can handle 
    // the requested escape.
    //
    case QUERYESCSUPPORT:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: QUERY_ESCAPE_SUPPORTED. "
          "Requested escape is 0x%X.\n", *((ULONG *)pvIn) ));   

      switch ( *((ULONG *)pvIn) )
      {
        case QUERYESCSUPPORT:
        case IS_CIRRUS_DRIVER:
        case GET_VIDEO_MEM_SIZE:
        case CRTC_READ:
        case GET_BIOS_VERSION:
        case GET_PCI_VEN_DEV_ID:
        case GET_EDID_DATA:
        #ifdef CLMCD_ESCAPE_SUPPORTED // OpenGL MCD Interface
            case MCDFUNCS:
        #endif
        case CIRRUS_ESCAPE_FUNCTION:
        #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
            case ID_LGPM_SETHWMODULESTATE:
            case ID_LGPM_GETHWMODULESTATE:
        #endif
        case BIOS_CALL_REQUEST:
        case GET_CL_MMAP_ADDR:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We support the requested escape.\n"));   
            retval = TRUE;

        default:
            DISPDBG((ESC_DBG_LVL, 
              "DrvEscape: We DO NOT support the requested escape.\n"));   
            retval = FALSE;
      }
      break;

    };  // case QUERYESCSUPPORT


    case SET_AGPDATASTREAMING:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_AGPDATASTREAMING.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(BYTE))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_AGPDATASTREAMING,
                             pvIn,
                             sizeof(BYTE),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_AGPDATASTREAMING


    case SET_DDCCONTROLFLAG:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_DDCCONTROLFLAG.\n"));   
      retval = FALSE;
      if (cjIn == sizeof(DWORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_DDCCONTROLFLAG,
                             pvIn,
                             sizeof(DWORD),
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_DDCCONTROLFLAG


    case SET_NONDDCMONITOR_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_DATA.\n"));   
      retval = FALSE;
      if (cjIn == 128)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_DATA,
                             pvIn,
                             128,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_DATA


    case SET_NONDDCMONITOR_BRAND:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_BRAND.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_BRAND,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_BRAND


    case SET_NONDDCMONITOR_MODEL:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: SET_NONDDCMONITOR_MODEL.\n"));   
      retval = FALSE;
      if (cjIn > 0)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_SET_NONDDCMONITOR_MODEL,
                             pvIn,
                             cjIn,
                             NULL,
                             0,
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case SET_NONDDCMONITOR_MODEL


    case IS_CIRRUS_DRIVER:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: IS_CIRRUS_DRIVER.\n"));   
      retval = TRUE;
      break;
    }  // end case IS_CIRRUS_DRIVER



    case GET_VIDEO_MEM_SIZE:
    {
      BYTE  btmp;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_VIDEO_MEM_SIZE.\n"));   
      if (cjOut == sizeof(BYTE))
      {
         btmp = ppdev->lTotalMem/0x10000;
         *pOut = btmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_VIDEO_MEM_SIZE



    case CRTC_READ:
    {
      BYTE  bindex;
      PBYTE pMMReg = (PBYTE) ppdev->pLgREGS_real;
      PBYTE pIn  = (PBYTE) pvIn;
      PBYTE pOut = (PBYTE) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: CRTC_READ.\n"));   
      if ((cjIn  == sizeof(BYTE)) &&
          (cjOut == sizeof(BYTE)))
      {
         bindex = (*pIn) * 4;
         pMMReg = pMMReg + bindex;
         *pOut = *pMMReg;
         retval = TRUE;
      };
      break;
    }  // end case CRTC_READ


    case GET_BIOS_VERSION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_BIOS_VERSION.\n"));   
      if (cjOut == sizeof(WORD))
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_GET_BIOS_VERSION,
                             NULL,
                             0,
                             pvOut,
                             sizeof(WORD),
                             &returnedDataLength,
                             NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_BIOS_VERSION



    case GET_PCI_VEN_DEV_ID:
    {
      ULONG  ultmp;
      PULONG pOut = (PULONG) pvOut;

      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_PCI_VEN_DEV_ID.\n"));   
      if (cjOut == sizeof(DWORD))
      {
         ultmp = ppdev->dwLgVenID;
         ultmp = (ultmp << 16) | (ppdev->dwLgDevID & 0xFFFF);
         *pOut = ultmp;
         retval = TRUE;
      };
      break;
    }  // end case GET_PCI_VEN_DEV_ID



    case GET_EDID_DATA:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_EDID_DATA.\n"));   
      if (cjOut == 132)
      {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                            IOCTL_GET_EDID_DATA,
                            NULL,
                            0,
                            pvOut,
                            132,
                            &returnedDataLength,
                            NULL))
         {
            retval = TRUE;
         };
      };
      break;
    }  // end case GET_EDID_DATA



    #ifdef CLMCD_ESCAPE_SUPPORTED
	// OpenGL Mini-Client Driver Interface
    case MCDFUNCS:
    {
	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFUNC start\n"));   
        if (!ppdev->hMCD) {
            WCHAR uDllName[50];
            UCHAR dllName[50];
            ULONG nameSize;

            {
                HANDLE      hCLMCD;

//                // load and initialize the dll containing MCD support for display driver
//                EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
//                                       CLMCDDLLNAME, sizeof(CLMCDDLLNAME));
//
//                if (hCLMCD = EngLoadImage(uDllName))

                  {

//                    CLMCDINITFUNC pCLMCDInit =  EngFindImageProcAddress(hCLMCD,
//                                                     (LPSTR)CLMCDINITFUNCNAME);

//                    if (pCLMCDInit)

                      {

                        // Enable 3D engine - if enable fails, don't continue loading MCD dll
                        if (LgPM_SetHwModuleState(ppdev, MOD_3D, ENABLE))
                        {

                            DRVENABLEDATA temp;

                            // MCD dispdriver dll init returns ptr to MCDrvGetEntryPoints,
                            //  which is passed to init proc for MCD helper lib a few lines down...
//                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = (*pCLMCDInit)(ppdev);
                            MCDRVGETENTRYPOINTSFUNC pMCDGetEntryPoints = CLMCDInit(ppdev);


                            ppdev->pAllocOffScnMem = AllocOffScnMem;
                            ppdev->pFreeOffScnMem = FreeOffScnMem;

                            // after MCD display driver dll loaded, load MCD helper lib (MSFT supplied)
                
                            EngMultiByteToUnicodeN(uDllName, sizeof(uDllName), &nameSize,
                                                   MCDENGDLLNAME, sizeof(MCDENGDLLNAME));

                            if (ppdev->hMCD = EngLoadImage(uDllName)) {
                                MCDENGINITFUNC pMCDEngInit =  EngFindImageProcAddress(ppdev->hMCD,
                                                                 (LPSTR)MCDENGINITFUNCNAME);

                                if (pMCDEngInit) {
                                    (*pMCDEngInit)(pso, pMCDGetEntryPoints);
                                    ppdev->pMCDFilterFunc = EngFindImageProcAddress(ppdev->hMCD,
                                                                (LPSTR)MCDENGESCFILTERNAME);

                                }
                            }

                            
                        }
                        
                    }
                }
            }


        }

        if (ppdev->pMCDFilterFunc) {
        #ifdef DBGBRK                           
            DBGBREAKPOINT();
        #endif
            if ((*ppdev->pMCDFilterFunc)(pso, iEsc, cjIn, pvIn,			   
                                         cjOut, pvOut, &retval))
			{
        	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc SUCCESS, retval=%x\n",retval));   
                return retval;
			}
      	 	DISPDBG((ESC_DBG_LVL, "DrvEscape-MCDFilterFunc FAILED\n"));   
        }
    }
    break;
    #endif // def CLMCD_ESCAPE_SUPPORTED



    case CIRRUS_ESCAPE_FUNCTION:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: CIRRUS_ESCAPE_FUNCTION.\n"));   
      if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
          (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
      {
         VIDEO_POWER_MANAGEMENT  inPM;
         BOOL bCallFail = FALSE;

         VIDEO_X86_BIOS_ARGUMENTS *pinregs  = (VIDEO_X86_BIOS_ARGUMENTS *) pvIn;
         VIDEO_X86_BIOS_ARGUMENTS *poutregs = (VIDEO_X86_BIOS_ARGUMENTS *) pvOut;

         poutregs->Eax = 0x014F;
         poutregs->Ebx = pinregs->Ebx;
         poutregs->Ecx = pinregs->Ecx;
 
         if (pinregs->Eax == 0x4F10)
         {
            if (pinregs->Ebx == 0x0001)
               inPM.PowerState = VideoPowerOn;
            else if (pinregs->Ebx == 0x0101)
               inPM.PowerState = VideoPowerStandBy;
            else if (pinregs->Ebx == 0x0201)
               inPM.PowerState = VideoPowerSuspend;
             else if (pinregs->Ebx == 0x0401)
               inPM.PowerState = VideoPowerOff;
             else
               bCallFail = TRUE;


             if (!bCallFail)
             {
                if (DEVICE_IO_CTRL(ppdev->hDriver,
                                   IOCTL_VIDEO_SET_POWER_MANAGEMENT,
                                   &inPM,
                                   sizeof(VIDEO_POWER_MANAGEMENT),
                                   NULL,
                                   0,
                                   &returnedDataLength,
                                   NULL))
                {
                   poutregs->Eax = 0x004F;
                   retval = TRUE;
                };
             };  // endif (!bCallFail)
         };  // endif (pinregs->Eax == 0x4F10)
      };

      break;
    };  // case CIRRUS_ESCAPE_FUNCTION



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_SETHWMODULESTATE:
    {
       ULONG state;
       DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_SETHWMODULESTATE.\n"));   

       if (ppdev->dwLgDevID >= CL_GD5465)
       {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_SetHwModuleState(ppdev, pIn->arg1, pIn->arg2);
          };
       }; // endif (ppdev->dwLgDevID >= CL_GD5465)
      break;
    };  // case ID_LGPM_SETHWMODULESTATE
    #endif



    #if (!(WINNT_VER35)) && DRIVER_5465 // NT 4.0+ and 5465+
    case ID_LGPM_GETHWMODULESTATE:
    {
        ULONG state;
        DISPDBG((ESC_DBG_LVL, "DrvEscape: ID_LGPM_GETHWMODULESTATE.\n"));   

        if (ppdev->dwLgDevID >= CL_GD5465)
        {
          if ((cjIn  == sizeof(LGPM_IN_STRUCT)) &&
              (cjOut == sizeof(LGPM_OUT_STRUCT)))
          {
             LGPM_IN_STRUCT  *pIn  = (LGPM_IN_STRUCT *) pvIn;
             LGPM_OUT_STRUCT *pOut = (LGPM_OUT_STRUCT *) pvOut;

             retval = TRUE;

             pOut->status = FALSE;
             pOut->retval = 0;

             pOut->status = LgPM_GetHwModuleState(ppdev, pIn->arg1, &state);
             pOut->retval = state;
          };

        }; // endif (ppdev->dwLgDevID >= CL_GD5465)
        break;
    };  // case ID_LGPM_GETHWMODULESTATE
    #endif



    case BIOS_CALL_REQUEST:
    {
        if ((cjIn  == sizeof(VIDEO_X86_BIOS_ARGUMENTS)) &&
            (cjOut == sizeof(VIDEO_X86_BIOS_ARGUMENTS)))
        {
         if (DEVICE_IO_CTRL(ppdev->hDriver,
                             IOCTL_CL_BIOS,
                             pvIn,
                             cjIn,
                             pvOut,
                             cjOut,
                             &returnedDataLength,
                             NULL))
            retval = TRUE;
        };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-BIOS_CALL_REQUEST\n"));

        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

      break;
    }; // end case BIOS_CALL_REQUEST



    case GET_CL_MMAP_ADDR:
    {
      DISPDBG((ESC_DBG_LVL, "DrvEscape: GET_CL_MMAP_ADDR.\n"));   
      if ((cjIn != sizeof(MMREG_ACCESS)) || (cjOut != sizeof(MMREG_ACCESS)))
         break;

      pInMRAccess = (MMREG_ACCESS *) pvIn;
      pMRAccess   = (MMREG_ACCESS *) pvOut;

      pMRAccess->Offset = pInMRAccess->Offset;
      pMRAccess->ReadVal = pInMRAccess->ReadVal;
      pMRAccess->WriteVal = pInMRAccess->WriteVal;
      pMRAccess->RdWrFlag = pInMRAccess->RdWrFlag;
      pMRAccess->AccessType = pInMRAccess->AccessType;

      pbAddr = (BYTE *) ppdev->pLgREGS;
      pbAddr = pbAddr + pMRAccess->Offset;

      if (pMRAccess->RdWrFlag == READ_OPR)  // Read operation
      {
         pMRAccess->WriteVal = 0;
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            retval = FALSE;
         };
      }
      else if (pMRAccess->RdWrFlag == WRITE_OPR)  // Write operation
      {
         retval = TRUE;

         if (pMRAccess->AccessType == BYTE_ACCESS)
         {
            pMRAccess->ReadVal = (*pbAddr) & 0xFF;
            *pbAddr = (BYTE) (pMRAccess->WriteVal & 0xFF);
         }
         else if (pMRAccess->AccessType == WORD_ACCESS)
         {
            pwAddr = (WORD *)pbAddr;
            pMRAccess->ReadVal = (*pwAddr) & 0xFFFF;
            *pwAddr = (WORD) (pMRAccess->WriteVal & 0xFFFF);
         }
         else if (pMRAccess->AccessType == DWORD_ACCESS)
         {
            pdwAddr = (DWORD *)pbAddr;
            pMRAccess->ReadVal = *pdwAddr;
            *pdwAddr = pMRAccess->WriteVal;
         }
         else
         {
            pMRAccess->ReadVal = 0;
            pMRAccess->WriteVal = 0;
            retval = FALSE;
         };
      };

        DISPDBG((ESC_DBG_LVL, "DrvEscape-GET_CL_MMAP_ADDR\n"));
        DISPDBG((ESC_DBG_LVL, "DrvEscape-rd=%x, wr=%x\n",
                        pMRAccess->ReadVal, pMRAccess->WriteVal));
        #ifdef DBGBRK
          DbgBreakPoint();
        #endif

        break;
    }; // IOCTL_CL_GET_MMAP_ADDR



    default:

        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape:  default - Escape not handled.\n"));   
        DISPDBG((ESC_DBG_LVL, 
            "DrvEscape: Requested escape is 0x%X.\n",iEsc ));   
        DISPDBG((ESC_DBG_LVL, "DrvEscape:  Returning FALSE.\n"));   

        retval = FALSE;
        break;

  };  // end switch


  DISPDBG((ESC_DBG_LVL, "DrvEscape-Exit.\n"));   

  return (retval);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast solid-coloured, unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

#define FASTFILL_DBG_LEVEL 1

typedef struct _EDGEDATA {
    LONG      x;                // Current x position
    LONG      dx;               // # pixels to advance x on each scan
    LONG      lError;           // Current DDA error
    LONG      lErrorUp;         // DDA error increment on each scan
    LONG      lErrorDown;       // DDA error adjustment
    POINTFIX* pptfx;            // Points to start of current edge
    LONG      dptfx;            // Delta (in bytes) from pptfx to next point
    LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

/******************************Public*Routine******************************\
* BOOL bMmFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* This routine is in no way the ultimate convex polygon drawing routine
* (what can I say, I was pressed for time when I wrote this :-).  Some
* obvious things that would make it faster:
*
*    1) Write it in Asm and amortize the FIFO checking costs (check out
*       i386\fastfill.asm for a version that does this).
*
*    2) Take advantage of any hardware such as the ATI's SCAN_TO_X
*       command, or any built-in trapezoid support (note that with NT
*       you may get non-integer end-points, so you must be able to
*       program the trapezoid DDA terms directly).
*
*    3) Do some rectangle coalescing when both edges are y-major.  This
*       could permit removal of my vertical-edges special case.  I
*       was also thinking of special casing y-major left edges on the
*       S3, because the S3 leaves the current 'x' unchanged on every blt,
*       so a scan that starts on the same 'x' as the one above it
*       would require only two commands to the accelerator (obviously,
*       this only helps when we're not overdriving the accelerator).
*
*    4) Make the non-complex polygon detection faster.  If I could have
*       modified memory before the start of after the end of the buffer,
*       I could have simplified the detection code.  But since I expect
*       this buffer to come from GDI, I can't do that.  Another thing
*       would be to have GDI give a flag on calls that are guaranteed
*       to be convex, such as 'Ellipses' and 'RoundRects'.  Note that
*       the buffer would still have to be scanned to find the top-most
*       point.
*
*    5) Special case integer points.  Unfortunately, for this to be
*       worth-while would require GDI to give us a flag when all the
*       end-points of a path are integers, which it doesn't do.
*
*    6) Add rectangular clipping support.
*
*    7) Implement support for a single sub-path that spans multiple
*       path data records, so that we don't have to copy all the points
*       to a single buffer like we do in 'fillpath.c'.
*
*    8) Use 'ebp' and/or 'esp' as a general register in the inner loops
*       of the Asm loops, and also Pentium-optimize the code.  It's safe
*       to use 'esp' on NT because it's guaranteed that no interrupts
*       will be taken in our thread context, and nobody else looks at the
*       stack pointer from our context.
*
*    9) Do the fill bottom-up instead of top-down.  With the S3, we have
*       to only set 'cur_y' once because each drawing command automatically
*       advances 'cur_y' (unless the polygon has zero pels lit on a scan),
*       so we set this right at the beginning.  But for an integer end-point
*       polygon, unless the top edge is horizontal, no pixels are lit on
*       that first scan (so at the beginning of almost every integer
*       polygon, we go through the 'zero width' logic and again set
*       'cur_y').  We could avoid this extra work by building the polygon
*       from bottom to top: for the bottom-most point B in a polygon, it
*       is guaranteed that any scan with lit pixels will be no lower than
*       'ceiling(B.y) - 1'.  Unfortunately, building bottom-up makes the
*       fractional-DDA calculations a little more complex, so I didn't do it.
*
*       Building bottom-up would also improve the polygon score in version
*       3.11 of a certain benchmark, because it has a big rectangle at the
*       top of every polygon -- we would get better processing overlap
*       because we wouldn't have to wait around for the accelerator to
*       finish drawing the big rectangle.
*
*   10) Make a better guess in the initialization as to which edge is the
*       'left' edge, and which is the 'right'.  As it is, we immediately
*       go through the swap-edges logic for half of all polygons when we
*       start to run the DDA.  The reason why I didn't implement better-guess
*       code is because it would have to look at the end-point of the top
*       edges, and to get at the end-points we have to watch that we don't
*       wrap around the ends of the points buffer.
*
*   11) Lots of other things I haven't thought of.
*
* NOTE: Unlike the x86 Asm version, this routine does NOT assume that it
*       has 16 FIFO entries available.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bMmFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       ulHwForeMix,
ULONG       ulHwBackMix,
ULONG       iSolidColor,
BRUSHOBJ*  pbo)
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      y;            // Current Y Location
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    DISPDBG((FASTFILL_DBG_LEVEL,"bMmFastFill %x %x %x\n", ulHwForeMix, ulHwBackMix, ppdev->uBLTDEF << 16 | ulHwForeMix,
       ppdev->uBLTDEF << 16 | ulHwForeMix));

    REQUIRE(5);

    // Set up BltDef and DrawDef
    LL_DRAWBLTDEF(ppdev->uBLTDEF << 16 | ulHwForeMix, 2);

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        DISPDBG((FASTFILL_DBG_LEVEL,"False Exit %s %d\n", __FILE__, __LINE__));
        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    yTrapezoid = (pptfxTop->y + 15) >> 4;
    DISPDBG((FASTFILL_DBG_LEVEL, "%d yTrapezoid init %x\n", __LINE__, yTrapezoid));

    // Make sure we initialize the DDAs appropriately:

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        // Let's set the Foreground Register here since they are
        switch (ppdev->ulBitCount)
        {
                case 8: // For 8 bpp duplicate byte 0 into bytes 1,2,3.
                        iSolidColor = (iSolidColor & 0xFF) | (iSolidColor << 8);

                case 16: // For 16 bpp, duplicate the low word into the high word.
                        iSolidColor = (iSolidColor & 0xFFFF) | (iSolidColor << 16);
        }

        DISPDBG((FASTFILL_DBG_LEVEL,"FASTFILL: Set Color %x.\n", iSolidColor));
        LL_BGCOLOR(iSolidColor, 2);
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns
    }
        y = yTrapezoid;
        DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x\n", __LINE__, y));
// done above   REQUIRE(1);
        LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                {
                    DISPDBG((FASTFILL_DBG_LEVEL,"True Exit %s %d\n", __FILE__, __LINE__));
                    return(TRUE);
                }
                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    DISPDBG((FASTFILL_DBG_LEVEL, "%d cyTrapezoid =  %d\n",
                        __LINE__, cyTrapezoid));

    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;
    yTrapezoid    += cyTrapezoid;                   // Top scan in next trap

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
                DISPDBG((FASTFILL_DBG_LEVEL, "%d lWidth %x %x %x cyTrapezoid %x \n",
                                __LINE__, lWidth, aed[RIGHT].x, aed[LEFT].x, cyTrapezoid));
        if (lWidth >= 0)
        {
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n",__LINE__, aed[LEFT].x));
                REQUIRE(5);
//              REQUIRE(4);
                LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
                LL_BLTEXT(lWidth + 1, cyTrapezoid);
                DISPDBG((FASTFILL_DBG_LEVEL, "DO a Blt %x\n",(cyTrapezoid << 16) | (lWidth + 1)));
                y += cyTrapezoid;
                DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y));
                LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else if (lWidth == -1)
        {
            // If the rectangle was too thin to light any pels, we still
            // have to advance the y current position:
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, y + ppdev->ptlOffset.y);
        }
        else
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);
            goto ContinueVertical;
        }

        goto NewTrapezoid;
    }

    while (TRUE)
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        // The very first time through, make sure we set x:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
        if (lWidth >= 0)
        {
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New x %x\n", __LINE__, aed[LEFT].x));
            REQUIRE(5);
//          REQUIRE(4);
            LL16(grOP0_opRDRAM.pt.X, aed[LEFT].x + ppdev->ptlOffset.x);
            LL_BLTEXT(lWidth + 1, 1);
            DISPDBG((FASTFILL_DBG_LEVEL,"%d New y %x\n", __LINE__, y+1));
            LL16(grOP0_opRDRAM.pt.Y, ++y + ppdev->ptlOffset.y);

    ContinueAfterZero:

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                goto NewTrapezoid;
        }
        else if (lWidth == -1)
        {
            y = yTrapezoid - cyTrapezoid + 1;
            DISPDBG((FASTFILL_DBG_LEVEL, "%d New y %x yTrap %x cyTrap %x\n",
                                __LINE__, y, yTrapezoid, cyTrapezoid));
            REQUIRE(1);
            LL16(grOP0_opRDRAM.pt.Y, (y + ppdev->ptlOffset.y) );
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].dx,         aed[RIGHT].dx,         lTmp);
            SWAP(aed[LEFT].lError,     aed[RIGHT].lError,     lTmp);
            SWAP(aed[LEFT].lErrorUp,   aed[RIGHT].lErrorUp,   lTmp);
            SWAP(aed[LEFT].lErrorDown, aed[RIGHT].lErrorDown, lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);

            continue;
        }
    }
    DISPDBG((FASTFILL_DBG_LEVEL,"Eof Exit %s %d\n", __FILE__, __LINE__));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\laguna\disp\cl5465\fillpath.c ===
/******************************************************************************\
*
* $Workfile:   FILLPATH.C  $
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/FILLPATH.C  $
*
*    Rev 1.14   Mar 04 1998 15:24:00   frido
* Added new shadow macros.
*
*    Rev 1.13   Nov 03 1997 15:26:36   frido
* Added REQUIRE macros.
*
*    Rev 1.12   08 Apr 1997 12:24:28   einkauf
*
* add SYNC_W_3D to coordinate MCD/2D HW access
*
*    Rev 1.11   21 Mar 1997 11:41:44   noelv
*
* Combined do_flag and sw_test_flag into point_switch
*
*    Rev 1.10   17 Dec 1996 17:04:26   SueS
* Added test for writing to log file based on cursor at (0,0).  Added
* more information to the log file.
*
*    Rev 1.9   26 Nov 1996 10:46:10   noelv
* Changed DBG LEVEL.
*
*    Rev 1.8   26 Nov 1996 10:24:10   SueS
* Changed WriteLogFile parameters for buffering.
*
*    Rev 1.7   13 Nov 1996 15:58:52   SueS
* Changed WriteFile calls to WriteLogFile.
*
*    Rev 1.6   06 Sep 1996 14:46:24   noelv
*
* Updated NULL driver code for 4.0
*
*    Rev 1.5   20 Aug 1996 11:03:32   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.2   17 Aug 1996 15:32:30   frido
* #1244 - Fixed brush rotation for off-screen bitmaps.
* Added new comment header.
* Cleaned up some code.
*
\******************************************************************************/

#include "precomp.h"

BOOL CacheMono(PPDEV ppdev, PRBRUSH pRbrush);
BOOL Cache4BPP(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheDither(PPDEV ppdev, PRBRUSH pRbrush);
BOOL CacheBrush(PPDEV ppdev, PRBRUSH pRbrush);

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit signed
// LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies two
// 32-bit LONGs to produce a 64-bit LONGLONG result.  I use it because it is
// much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path for
                                    // which we'll attempt to join all the path
                                    // records so that the path may still be
                                    // drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath  = 0;
    ULONG BufferMissInFillpath = 0;
#endif

#if LOG_CALLS
    VOID LogFillPath(ULONG acc, PPDEV ppdev, SURFOBJ* pso);
#else
    #define LogFillPath(acc, ppdev, pso)
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT   iScansLeft;
    INT   X;
    INT   Y;
    INT   iErrorTerm;
    INT   iErrorAdjustUp;
    INT   iErrorAdjustDown;
    INT   iXWhole;
    INT   iXDirection;
    INT   iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to the fill code.
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

#define FILLPATH_DBG_LEVEL 1

// MIX translation table. Translates a mix 1-16, into an old style ROP 0-255.
extern BYTE gaMix[];

VOID  AdvanceAETEdges(EDGE* pAETHead);
VOID  XSortAETEdges(EDGE* pAETHead);
VOID  MoveNewEdges(EDGE* pGETHead, EDGE* pAETHead, INT iCurrentY);
EDGE* AddEdgeToGET(EDGE* pGETHead, EDGE* pFreeEdge, POINTFIX* ppfxEdgeStart,
                                   POINTFIX* ppfxEdgeEnd, RECTL* pClipRect);
BOOL  ConstructGET(EDGE* pGETHead, EDGE* pFreeEdges, PATHOBJ* ppo,
                                   PATHDATA* pd, BOOL bMore, RECTL* pClipRect);
VOID  AdjustErrorTerm(INT* pErrorTerm, INT iErrorAdjustUp,
                                          INT iErrorAdjustDown, INT yJump, INT* pXStart,
                                          INT iXDirection);

extern BYTE Rop2ToRop3[];

BYTE gajRop[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};


/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        uRop;       // Hardware foreground mix value
    ULONG        uRopb;       // Hardware background mix value
    ULONG        avec;                  // A-vector notation for ternary rop
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine
    BOOL         bRealizeTransparent; // Need a transparent realization for Rop

    BOOL         bSolid;
    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];
    ULONG        ulBltDef = 0x1000;


    #if NULL_PATH
    {
            if (pointer_switch)    return(TRUE);
    }
    #endif

    DISPDBG((FILLPATH_DBG_LEVEL,"DrvFillPath\n"));

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            DISPDBG((FILLPATH_DBG_LEVEL,"Complex Clipping Early Out\n"));
            #if LOG_CALLS
                ppdev = (PDEV*) pso->dhpdev;
                LogFillPath(2,  ppdev, NULL);
            #endif
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        DISPDBG((FILLPATH_DBG_LEVEL,"Nothing to do out\n"));
        #if LOG_CALLS
            ppdev = (PDEV*) pso->dhpdev;
            LogFillPath(0,  ppdev, pso);
        #endif
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:
         // This is where to put device bit maps
    ppdev = (PDEV*) pso->dhpdev;

    SYNC_W_3D(ppdev);

    if (pso->iType == STYPE_DEVBITMAP)
    {
        PDSURF pdsurf = (PDSURF) pso->dhsurf;

        if ( pdsurf->pso && !bCreateScreenFromDib(ppdev, pdsurf) )
        {
                LogFillPath(4,  ppdev, NULL);
                return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                                                           flOptions));
        }
        ppdev->ptlOffset = pdsurf->ptl;
    }
    else
    {
        ppdev->ptlOffset.x = ppdev->ptlOffset.y = 0;
    }

    pfnFill = vMmFillSolid;
    uRop = Rop2ToRop3[mix & 0xF];
    uRopb = Rop2ToRop3[(mix >> 8) & 0xF];
    bSolid = ((pbo == NULL) || (pbo->iSolidColor != -1));

    //
    // Make it simple and punt this one until later
    //
    avec = gajRop[uRop];
    if ((uRop != uRopb) && !bSolid)
    {
           DISPDBG((FILLPATH_DBG_LEVEL, "ROPs it Fore=%x Back=%x ROP3=%x\n", uRop, uRopb, ROP3MIX(uRop, uRopb)));
                uRop = ROP3MIX(uRop, uRopb);
                avec = gajRop[uRop];
                if (avec & AVEC_NEED_SOURCE)
              {
              // Use the implicit mask in the brush object.
              // Note pre-align mask (as if "anchored")

              if (!bSetMask(ppdev, pbo, pptlBrush, &ulBltDef))
              {
                  DISPDBG((FILLPATH_DBG_LEVEL, "Set Mask Failed"));
                  LogFillPath(5,  ppdev, NULL);
                  return FALSE;
              }
                  }


    }

    iSolidColor = 0;                    // Assume we won't need a pattern
    bRealizeTransparent = FALSE;
    if (avec & AVEC_NEED_PATTERN)
    {
                  iSolidColor = pbo->iSolidColor;
        if (pbo->iSolidColor == -1)
        {
            bRealizeTransparent = (uRop != uRopb);
            if (pbo->pvRbrush == NULL)
            {
                pbo->pvRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                if (pbo->pvRbrush == NULL)
                {
                    DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Get Brush\n"));
                    LogFillPath(6,  ppdev, NULL);
                    return(FALSE);
                }
            }
            pfnFill = vMmFillPatFast;
        }
                else
                        ulBltDef |= (BD_OP2 * IS_SOLID);         // Or in 0x0007
    }

    if (avec & AVEC_NEED_DEST)
                ulBltDef |= (BD_OP0 * IS_VRAM);  // Or in 0x0100

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
#ifdef S3
        #if !FASTFILL_PATTERNS
            goto SkipFastFill;
        #else
            // We handle patterns in 'pfnFastFill' only if we can use the S3
            // hardware patterns.
            if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
                goto SkipFastFill;

            // Note: prb->pbe will be NULL and prb->ptlBrushOrg.x will be -1 the
            //       first time an RBRUSH is used.  So we have to check the
            //       alignment *before* dereferencing prb->pbe...

            if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
                (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
                (rbc.prb->apbe[IBOARD(ppdev)]->prbVerify != rbc.prb)      ||
                (rbc.prb->bTransparent != bRealizeTransparent))
            {
                vMmFastPatRealize(ppdev, pbo, pptlBrush,
                                         bRealizeTransparent);

            }
        #endif
#endif

            // Realize the brush
            if (!SetBrush(ppdev, &ulBltDef, pbo, pptlBrush))
            {
                 DISPDBG((FILLPATH_DBG_LEVEL,"Could Not Set Brush\n"));
                 LogFillPath(6,  ppdev, NULL);
                 return FALSE;
            }
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

                  ppdev->uBLTDEF = ulBltDef;
        if (bMmFastFill(ppdev, pd.count, pd.pptfx, uRop,
                                 uRopb, iSolidColor, pbo))
        {
            LogFillPath(0,  ppdev, pso);
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom)
            {
               LogFillPath(0,  ppdev, pso);
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle))
            {
                // Totally clipped, nothing to do
                LogFillPath(0,  ppdev, pso);
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
#ifdef WINNT_VER40
        pFreeEdges = (EDGE *) MEM_ALLOC(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);
#else
        pFreeEdges = (EDGE *) MEM_ALLOC(LMEM_FIXED, (ppo->cCurves * sizeof(EDGE)));
#endif

        if (pFreeEdges == NULL)
        {
            LogFillPath(1,  ppdev, NULL);
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect))
    {
        LogFillPath(7,  ppdev, NULL);
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                                                        ppdev->uBLTDEF = ulBltDef;
                    (*pfnFill)(ppdev, ulNumRects, prclRects, uRop,
                               uRopb, pbo, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
                  ppdev->uBLTDEF = ulBltDef;
        (*pfnFill)(ppdev, ulNumRects, prclRects, uRop, uRopb,
                   pbo, pptlBrush);
    }

    LogFillPath(0,  ppdev, pso);

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        MEMORY_FREE (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        