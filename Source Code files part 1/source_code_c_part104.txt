  filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(FmGroupControl( Group,
                           NULL,
                           dwControlCode,
                           lpInBuffer,
                           dwInBufferSize,
                           lpOutBuffer,
                           nOutBufferSize,
                           lpBytesReturned,
                           lpcbRequired ));
}


error_status_t
s_ApiNodeNetworkControl(
    IN HNETWORK_RPC hNetwork,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    hNode - Supplies a handle to the node on which the network
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;
    PNM_NODE    Node;

    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);
    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmNetworkControl(Network,
                            Node,
                            dwControlCode,
                            lpInBuffer,
                            dwInBufferSize,
                            lpOutBuffer,
                            nOutBufferSize,
                            lpBytesReturned,
                            lpcbRequired ));
}


error_status_t
s_ApiNetworkControl(
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;

    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmNetworkControl(Network,
                            NULL,
                            dwControlCode,
                            lpInBuffer,
                            dwInBufferSize,
                            lpOutBuffer,
                            nOutBufferSize,
                            lpBytesReturned,
                            lpcbRequired ));
}


error_status_t
s_ApiNodeNetInterfaceControl(
    IN HNETINTERFACE_RPC hNetInterface,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface to be controlled.

    hNode - Supplies a handle to the node on which the network
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;
    PNM_NODE    Node;

    API_CHECK_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);
    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmInterfaceControl(NetInterface,
                              Node,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNetInterfaceControl(
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;

    API_CHECK_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmInterfaceControl(NetInterface,
                              NULL,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNodeNodeControl(
    IN HNODE_RPC hNode,
    IN HNODE_RPC hHostNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     Node;
    PNM_NODE     HostNode;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_NODE(HostNode, hHostNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmNodeControl( Node,
                          HostNode,
                          dwControlCode,
                          lpInBuffer,
                          dwInBufferSize,
                          lpOutBuffer,
                          nOutBufferSize,
                          lpBytesReturned,
                          lpcbRequired ));
}


error_status_t
s_ApiNodeControl(
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE Node;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(NmNodeControl( Node,
                          NULL,
                          dwControlCode,
                          lpInBuffer,
                          dwInBufferSize,
                          lpOutBuffer,
                          nOutBufferSize,
                          lpBytesReturned,
                          lpcbRequired ));
}



error_status_t
s_ApiNodeClusterControl(
    IN HCLUSTER hCluster,
    IN HNODE_RPC hHostNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and the cluster.

Arguments:

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     HostNode;

    API_CHECK_INIT();

    VALIDATE_NODE(HostNode, hHostNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(CsClusterControl(
               HostNode,
               dwControlCode,
               lpInBuffer,
               dwInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               lpBytesReturned,
               lpcbRequired ));
}


error_status_t
s_ApiClusterControl(
    IN HCLUSTER hCluster,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and the cluster.

Arguments:

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    API_CHECK_INIT();

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(CsClusterControl(
               NULL,
               dwControlCode,
               lpInBuffer,
               dwInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               lpBytesReturned,
               lpcbRequired ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\enum.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    Server side support for Cluster APIs dealing with enumeration

Author:

    John Vert (jvert) 9-Feb-1996

Revision History:

--*/
#include "apip.h"

//
// Define structure passed to enumeration routine.
//
typedef struct _REFOBJECT {
    HDMKEY RootKey;
    LPCWSTR FriendlyName;
    DWORD NameLength;
    LPWSTR NameBuffer;
    OBJECT_TYPE Type;
} REFOBJECT, *PREFOBJECT;

BOOL
ApipEnumResourceWorker(
    IN PENUM_LIST *pEnum,
    IN PVOID Context2,
    IN PFM_RESOURCE Node,
    IN LPCWSTR Name
    );

BOOL
ApipEnumGroupResourceWorker(
    IN PENUM_LIST *pEnum,
    IN PVOID Context2,
    IN PFM_RESOURCE Node,
    IN LPCWSTR Name
    );

BOOL
ApipEnumNodeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    );


BOOL
ApipEnumResTypeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    );

BOOL
ApipEnumGroupWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    );

BOOL
ApipEnumNetworkWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD
ApipEnumInternalNetworks(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated
    );

BOOL
ApipEnumNetworkInterfaceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
ApipFreeEnum(
    IN PENUM_LIST Enum
    );



error_status_t
s_ApiCreateEnum(
    IN handle_t IDL_handle,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the specified objects and returns the
    list of objects to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    IDL_handle - RPC binding handle, not used

    dwType - Supplies the type of objects to be enumerated

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;

    //initialize to NULL for failure cases
    *ReturnEnum = NULL;

    if (dwType != CLUSTER_ENUM_NODE) {
        API_CHECK_INIT();
    }

    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        if ((dwType & ~CLUSTER_ENUM_INTERNAL_NETWORK) != 0) {
            return(ERROR_INVALID_PARAMETER);
        }
    }
    else {
        if (dwType & ~CLUSTER_ENUM_ALL) {
            return(ERROR_INVALID_PARAMETER);
        }
    }

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all nodes
    //
    if (dwType & CLUSTER_ENUM_NODE) {
        OmEnumObjects(ObjectTypeNode,
                      ApipEnumNodeWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all resource types
    //
    if (dwType & CLUSTER_ENUM_RESTYPE) {
        OmEnumObjects(ObjectTypeResType,
                      ApipEnumResTypeWorker,
                      &Enum,
                      &Allocated);
    }

    //
    // Enumerate all resources
    //
    if (dwType & CLUSTER_ENUM_RESOURCE) {
        OmEnumObjects(ObjectTypeResource,
                      ApipEnumResourceWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all groups
    //
    if (dwType & CLUSTER_ENUM_GROUP) {
        OmEnumObjects(ObjectTypeGroup,
                      ApipEnumGroupWorker,
                      &Enum,
                      &Allocated);

    }

    //
    // Enumerate all networks
    //
    if (dwType & CLUSTER_ENUM_NETWORK) {
        OmEnumObjects(ObjectTypeNetwork,
                      ApipEnumNetworkWorker,
                      &Enum,
                      &Allocated);
    }

    //
    // Enumerate internal networks in highest to lowest priority order.
    //
    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        Status = ApipEnumInternalNetworks(&Enum, &Allocated);

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }
    }

    //
    // Enumerate all network interfaces
    //
    if (dwType & CLUSTER_ENUM_NETINTERFACE) {
        OmEnumObjects(ObjectTypeNetInterface,
                      ApipEnumNetworkInterfaceWorker,
                      &Enum,
                      &Allocated);
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:

    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    return(Status);

}


VOID
ApipFreeEnum(
    IN PENUM_LIST Enum
    )
/*++

Routine Description:

    Frees an ENUM_LIST and all of its strings.

Arguments:

    Enum - Supplies the Enum to free.

Return Value:

    None.

--*/

{
    DWORD i;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
}


VOID
ApipAddToEnum(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN LPCWSTR Name,
    IN DWORD Type
    )

/*++

Routine Description:

    Common worker callback routine for enumerating objects.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Name - Supplies the name of the object to be added to the ENUM_LIST.

           A copy of this name will be created by using MIDL_user_allocate.

    Type - Supplies the object's type

Return Value:

    None


--*/

{
    PENUM_LIST Enum;
    PENUM_LIST NewEnum;
    DWORD NewAllocated;
    DWORD Index;
    LPWSTR NewName;

    NewName = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
    if (NewName == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[API] ApipAddToEnum: No memory for object name\n");
        return;
    }
    lstrcpyW(NewName, Name);
    Enum = *pEnum;
    if (Enum->EntryCount >= *pAllocated) {
        //
        // Need to grow the ENUM_LIST
        //
        NewAllocated = *pAllocated + 8;
        NewEnum = MIDL_user_allocate(ENUM_SIZE(NewAllocated));
        if (NewEnum == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, "[API] ApipAddToEnum: No memory for enum list\n");
            MIDL_user_free(NewName);
            return;
        }
        CopyMemory(NewEnum, Enum, ENUM_SIZE(*pAllocated));
        CL_ASSERT( Enum->EntryCount == NewEnum->EntryCount );
        *pAllocated = NewAllocated;
        *pEnum = NewEnum;
        MIDL_user_free(Enum);
        Enum = NewEnum;
    }

    //
    // Initialize new entry field.
    //
    Enum->Entry[Enum->EntryCount].Name = NewName;
    Enum->Entry[Enum->EntryCount].Type = Type;
    ++Enum->EntryCount;

    return;
}



BOOL
ApipEnumResourceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resources.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Resource - Supplies the resource to be added to the ENUM_LIST

    Name - Supplies the resource's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Resource);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_RESOURCE);
        MIDL_user_free( RealName);
    }
    return(TRUE);
}


BOOL
ApipEnumGroupResourceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resources.
    Adds the specified resource to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Resource - Supplies the resource to be added to the ENUM_LIST

    Name - Supplies the resource's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Resource);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_GROUP_ENUM_CONTAINS);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


BOOL
ApipEnumNodeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of nodes.
    Adds the specified node to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Node - Supplies the node to be added to the ENUM_LIST

    Name - Supplies the node's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPCWSTR RealName;

    RealName = OmObjectName(Node);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NODE);
    }
    return(TRUE);
}


BOOL
ApipEnumResTypeWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of resource types.
    Adds the specified resource type to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Node - Supplies the resource type to be added to the ENUM_LIST

    Name - Supplies the resource type's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    ApipAddToEnum(pEnum,
                  pAllocated,
                  Name,
                  CLUSTER_ENUM_RESTYPE);
    return(TRUE);
}


BOOL
ApipEnumGroupWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of groups.
    Adds the specified group to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Group - Supplies the group to be added to the ENUM_LIST

    Name - Supplies the group's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPCWSTR RealName;

    RealName = OmObjectName(Group);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_GROUP);
    }
    return(TRUE);
}



BOOL
ApipEnumNetworkWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of networks.
    Adds the specified network to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Object - Supplies the object to be added to the ENUM_LIST

    Name - Supplies the network's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Object);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NETWORK);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


DWORD
ApipEnumInternalNetworks(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated
    )

/*++

Routine Description:

    Enumerates all networks used for internal communication.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD         Status;
    DWORD         NetworkCount;
    PNM_NETWORK  *NetworkList;
    DWORD         i;
    LPWSTR        RealName;


    Status = NmEnumInternalNetworks(&NetworkCount, &NetworkList);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    for (i=0; i<NetworkCount; i++) {
        RealName = ApipGetObjectName(NetworkList[i]);

        if (RealName != NULL) {
            ApipAddToEnum(pEnum,
                          pAllocated,
                          RealName,
                          (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK);
            MIDL_user_free( RealName );
        }

        OmDereferenceObject(NetworkList[i]);
    }

    if (NetworkList != NULL) {
        LocalFree(NetworkList);
    }

    return(ERROR_SUCCESS);

}


BOOL
ApipEnumNetworkInterfaceWorker(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN PVOID Object,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of network interfaces.
    Adds the specified network interface to the list that is being
    built up.

Arguments:

    pEnum - Supplies a pointer to the current enumeration list.

    pAllocated - Supplies a pointer to a dword specifying the current
        allocation size of the ENUM_LIST.

    Object - Supplies the object to be added to the ENUM_LIST

    Name - Supplies the network interface's name

Return Value:

    TRUE to indicate that enumeration should continue.


--*/
{
    LPWSTR RealName;

    RealName = ApipGetObjectName(Object);
    if (RealName != NULL) {
        ApipAddToEnum(pEnum,
                      pAllocated,
                      RealName,
                      CLUSTER_ENUM_NETINTERFACE);
        MIDL_user_free( RealName );
    }
    return(TRUE);
}


error_status_t
s_ApiCreateNodeEnum(
    IN HNODE_RPC hNode,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the resource objects contained in the specified
    node and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hNode - Supplies the node to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PNM_INTERFACE * InterfaceList;
    DWORD InterfaceCount;
    PNM_NODE Node;
    DWORD i;


    API_CHECK_INIT();

    VALIDATE_NODE_EXISTS(Node, hNode);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));

    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    if (dwType & CLUSTER_NODE_ENUM_NETINTERFACES) {
        Status = NmEnumNodeInterfaces(
                     Node,
                     &InterfaceCount,
                     &InterfaceList
                     );

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }

        for (i=0; i<InterfaceCount; i++) {
            ApipAddToEnum(&Enum,
                          &Allocated,
                          OmObjectName(InterfaceList[i]),
                          CLUSTER_NODE_ENUM_NETINTERFACES);
            OmDereferenceObject(InterfaceList[i]);
        }

        if (InterfaceList != NULL) {
            LocalFree(InterfaceList);
        }
    }

    *ReturnEnum = Enum;

    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}


error_status_t
s_ApiCreateGroupResourceEnum(
    IN HGROUP_RPC hGroup,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the resource objects contained in the specified
    group and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hGroup - Supplies the group to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_GROUP_ENUM_CONTAINS  - All resources contained in the specified
                                           group

            CLUSTER_GROUP_ENUM_NODES     - All nodes in the specified group's preferred
                                           owner list.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PFM_GROUP Group;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all contained resources
    //
    if (dwType & CLUSTER_GROUP_ENUM_CONTAINS) {
        //
        // Enumerate all resources for the Group.
        //
        Status = FmEnumerateGroupResources(Group,
                                  ApipEnumGroupResourceWorker,
                                  &Enum,
                                  &Allocated);
        if ( Status != ERROR_SUCCESS ) {
            goto ErrorExit;
        }
    }

    if (dwType & CLUSTER_GROUP_ENUM_NODES) {
        LPWSTR Buffer=NULL;
        DWORD BufferSize=0;
        DWORD DataSize=0;
        DWORD i;
        HDMKEY GroupKey;
        LPCWSTR Next;
        PNM_NODE Node;

        //
        // Enumerate all preferred nodes for the group.
        // Just get this data right out of the registry.
        //
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Group),
                             KEY_READ);
        if (GroupKey == NULL) {
            Status = GetLastError();
            goto ErrorExit;
        }
        Status = DmQueryMultiSz(GroupKey,
                                CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                                &Buffer,
                                &BufferSize,
                                &DataSize);
        DmCloseKey(GroupKey);
        if (Status != ERROR_FILE_NOT_FOUND) {
            if (Status != ERROR_SUCCESS) {
                //
                //  Chittur Subbaraman (chitturs) - 10/05/98
                //  Fix memory leak
                //
                LocalFree(Buffer);
                goto ErrorExit;
            }
            for (i=0; ; i++) {
                Next = ClRtlMultiSzEnum(Buffer, DataSize/sizeof(WCHAR), i);
                if (Next == NULL) {
                    Status = ERROR_SUCCESS;
                    break;
                }
                Node = OmReferenceObjectById(ObjectTypeNode, Next);
                if (Node != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  OmObjectName(Node),
                                  CLUSTER_GROUP_ENUM_NODES);
                    OmDereferenceObject(Node);
                }

            }
        }
        //
        //  Chittur Subbaraman (chitturs) - 10/05/98
        //  Fix memory leak
        //
        LocalFree(Buffer);
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}


error_status_t
s_ApiCreateNetworkEnum(
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )

/*++

Routine Description:

    Enumerates all the interface objects contained in the specified
    network and returns them to the caller. The client-side is
    responsible for freeing the allocated memory.

Arguments:

    hNetwork - Supplies the network to be enumerated

    dwType - Supplies a bitmask of the type of properties to be
            enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    PNM_INTERFACE * InterfaceList;
    DWORD InterfaceCount;
    PNM_NETWORK Network;
    DWORD i;


    API_CHECK_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));

    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    if (dwType & CLUSTER_NETWORK_ENUM_NETINTERFACES) {
        Status = NmEnumNetworkInterfaces(
                     Network,
                     &InterfaceCount,
                     &InterfaceList
                     );

        if (Status != ERROR_SUCCESS) {
            goto ErrorExit;
        }

        for (i=0; i<InterfaceCount; i++) {
            ApipAddToEnum(&Enum,
                          &Allocated,
                          OmObjectName(InterfaceList[i]),
                          CLUSTER_NETWORK_ENUM_NETINTERFACES);
            OmDereferenceObject(InterfaceList[i]);
        }

        if (InterfaceList != NULL) {
            LocalFree(InterfaceList);
        }
    }

    *ReturnEnum = Enum;

    return(ERROR_SUCCESS);

ErrorExit:
    if (Enum != NULL) {
        ApipFreeEnum(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);

}

LPWSTR
ApipGetObjectName(
    IN PVOID Object
    )

/*++

Routine Description:

    Allocates a string and fills in the object's name.

Arguments:

    Object - A pointer to the object to get its name.

Return Value:

    A pointer to a WSTR that contains the user-friendly name of the object.
    NULL on failure - use GetLastError to get the Win32 error code.

--*/

{
    LPWSTR  Name;
    DWORD   NameSize;

    if ( OmObjectName(Object) == NULL ) {
        Name = MIDL_user_allocate(1 * sizeof(WCHAR));
        if ( Name != NULL ) {
            *Name = (WCHAR)0;
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        NameSize = lstrlenW(OmObjectName(Object));
        Name = MIDL_user_allocate((NameSize + 1) * sizeof(WCHAR));
        if ( Name != NULL ) {
            lstrcpyW( Name, OmObjectName(Object) );
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(Name);

} // ApipGetObjectName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\group.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Server side support for Cluster APIs dealing with groups

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HGROUP_RPC
s_ApiOpenGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszGroupName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing group object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszGroupName - Supplies the name of the group to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a group object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HGROUP_RPC Group;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }
    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Group = OmReferenceObjectByName(ObjectTypeGroup, lpszGroupName);
    if (Group == NULL) {
        LocalFree(Handle);
        *Status = ERROR_GROUP_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_GROUP_HANDLE;
    Handle->Flags = 0;
    Handle->Group = Group;
    InitializeListHead(&Handle->NotifyList);
    *Status = ERROR_SUCCESS;
    return(Handle);
}

HGROUP_RPC
s_ApiCreateGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszGroupName,
    OUT error_status_t *pStatus
    )

/*++

Routine Description:

    Creates a new group object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszGroupName - Supplies the name of the group to create.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a group object if successful

    NULL otherwise.

--*/

{
    HGROUP_RPC Group=NULL;
    UUID Guid;
    DWORD Status = ERROR_SUCCESS;
    WCHAR *KeyName=NULL;
    PAPI_HANDLE Handle;
    DWORD dwDisposition;
    HDMKEY hKey = NULL;

    if (ApiState != ApiStateOnline) {
        *pStatus = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
retry:
    //
    //
    // Create a GUID for this group.
    //
    Status = UuidCreate(&Guid);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }
    Status = UuidToString(&Guid, &KeyName);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }

    //
    // Create this group in the FM. This will also trigger the notification.
    //
    Group = FmCreateGroup(KeyName, lpszGroupName);

    if (Group == NULL) {
        Status = GetLastError();
        if (Status == ERROR_ALREADY_EXISTS) {
            RpcStringFree(&KeyName);
            goto retry;
        }
    }

error_exit:   
    if (KeyName != NULL) {
        RpcStringFree(&KeyName);
    }
    
    *pStatus = Status;
    
    if (Status == ERROR_SUCCESS) {
        CL_ASSERT(Group != NULL);
        Handle->Type = API_GROUP_HANDLE;
        Handle->Group = Group;
        Handle->Flags = 0;
        InitializeListHead(&Handle->NotifyList);
        return(Handle);
    } else {
        LocalFree(Handle);
        return(NULL);
    }
}


error_status_t
s_ApiDeleteGroup(
    IN HGROUP_RPC hGroup
    )
/*++

Routine Description:

    Deletes a cluster group. The group must contain no resources.

Arguments:

    hGroup - Supplies the group to delete.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PFM_GROUP Group;
    HDMKEY Key;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Status = FmDeleteGroup(Group);
    if (Status == ERROR_SUCCESS) {
        DmDeleteTree(DmGroupsKey,OmObjectId(Group));
    }
    return(Status);
}


error_status_t
s_ApiCloseGroup(
    IN OUT HGROUP_RPC *phGroup
    )

/*++

Routine Description:

    Closes an open group context handle.

Arguments:

    Group - Supplies a pointer to the HGROUP_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PFM_GROUP Group;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_GROUP(Group, *phGroup);

    Handle = (PAPI_HANDLE)*phGroup;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Group);

    LocalFree(Handle);
    *phGroup = NULL;

    return(ERROR_SUCCESS);
}


VOID
HGROUP_RPC_rundown(
    IN HGROUP_RPC Group
    )

/*++

Routine Description:

    RPC rundown procedure for a HGROUP_RPC. Just closes the handle.

Arguments:

    Group - Supplies the HGROUP_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseGroup(&Group);
}


error_status_t
s_ApiGetGroupState(
    IN HGROUP_RPC hGroup,
    OUT DWORD *lpState,
    OUT LPWSTR *lpNodeName
    )

/*++

Routine Description:

    Returns the current state of the specified group.

Arguments:

    hGroup - Supplies the group whose state is to be returned.

    lpState - Returns the current state of the group

    lpNodeName - Returns the name of the node where the group is currently online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    LPWSTR NodeName;
    DWORD NameLength;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    NameLength = MAX_COMPUTERNAME_LENGTH+1;
    NodeName = MIDL_user_allocate(NameLength*sizeof(WCHAR));
    if (NodeName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *lpState = FmGetGroupState( Group,
                                NodeName,
                                &NameLength);
    if ( *lpState ==  ClusterGroupStateUnknown ) {
        MIDL_user_free(NodeName);
        return(GetLastError());
    }
    *lpNodeName = NodeName;

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiSetGroupName(
    IN HGROUP_RPC hGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Sets the new friendly name of a group.

Arguments:

    hGroup - Supplies the group whose name is to be set.

    lpszGroupName - Supplies the new name of hGroup

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    HDMKEY GroupKey;
    DWORD Status;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    //
    // Tell the FM about the new name. If it is OK with the
    // FM, go ahead and update the registry.
    //
    Status = FmSetGroupName(Group,
                            lpszGroupName);
    if (Status == ERROR_SUCCESS) {
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Group),
                             KEY_SET_VALUE);
        if (GroupKey == NULL) {
            return(GetLastError());
        }

        Status = DmSetValue(GroupKey,
                            CLUSREG_NAME_GRP_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszGroupName,
                            (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
        DmCloseKey(GroupKey);
    }

    return(Status);
}


error_status_t
s_ApiGetGroupId(
    IN HGROUP_RPC hGroup,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a group.

Arguments:

    hGroup - Supplies the group whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_GROUP Group;
    DWORD IdLen;
    LPCWSTR Id;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    Id = OmObjectId(Group);

    IdLen = (lstrlenW(Id)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(IdLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Id, IdLen);
    return(ERROR_SUCCESS);
}


DWORD
s_ApiOnlineGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Brings a group and all its dependencies online

Arguments:

    hGroup - Supplies the group to be brought online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmOnlineGroup(Group));

}


DWORD
s_ApiOfflineGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Brings a group and all its dependents offline

Arguments:

    hGroup - Supplies the group to be brought offline

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmOfflineGroup(Group));

}



DWORD
s_ApiMoveGroup(
    IN HGROUP_RPC hGroup
    )

/*++

Routine Description:

    Moves a group and all its dependents to another system.

Arguments:

    hGroup - Supplies the group to be moved

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);

    return(FmMoveGroup(Group, NULL));

}


DWORD
s_ApiMoveGroupToNode(
    IN HGROUP_RPC hGroup,
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Moves a group and all its dependents to another system.

Arguments:

    hGroup - Supplies the group to be moved

    hNode - Supplies the node to move the group to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    VALIDATE_NODE(Node, hNode);

    return(FmMoveGroup(Group, Node));

}



error_status_t
s_ApiSetGroupNodeList(
    IN HGROUP_RPC hGroup,
    IN UCHAR *lpNodeList,
    IN DWORD cbListSize
    )
/*++

Routine Description:

    Sets the list of preferred nodes for a group.

Arguments:

    hGroup - Supplies the group to set the preferred nodes.

    lpNodeList - Supplies the list of preferred owners, as a REG_MULTI_SZ.

    cbListSize - Supplies the size in bytes of the preferred owners list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP Group;
    HDMKEY GroupKey;
    DWORD Status;
    LPWSTR lpszTemp = ( LPWSTR ) lpNodeList;
    DWORD cchListSize = cbListSize / sizeof ( WCHAR );

    API_ASSERT_INIT();

    //
    // Make sure the node list is formatted as a MULTI_SZ (and if it is empty it should 
    // have at least a single NULL). Don't rely on clusapi.dll doing this since a hacker may be able to 
    // bypass clusapi.dll (even though we make that hard with security callback). Also, since 
    // lpNodeList is declared as a byte buffer in the IDL file, RPC won't help you with 
    // anything (except make sure cbListSize is allocated.)
    //
    if ( ( lpNodeList == NULL ) ||  
         ( cbListSize % sizeof ( WCHAR ) != 0 ) || // User passed in a size not a multiple of WCHAR
         ( cchListSize < 1 ) || // List is of zero length
         ( lpszTemp[ cchListSize - 1 ] != UNICODE_NULL ) || // Last char is not NULL
         ( ( cchListSize > 1 ) && // List has at least 2 elements and last but one is not NULL
           ( lpszTemp[ cchListSize - 2 ] != UNICODE_NULL ) ) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    VALIDATE_GROUP_EXISTS(Group, hGroup);

    //
    // Set the registry with the REG_MULTI_SZ. Let the FM pick it up from
    // there.
    //
    GroupKey = DmOpenKey(DmGroupsKey,
                         OmObjectId(Group),
                         KEY_SET_VALUE);
    if (GroupKey == NULL) {
        return(GetLastError());
    }

    Status = DmSetValue(GroupKey,
                        CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                        REG_MULTI_SZ,
                        (CONST BYTE *)lpNodeList,
                        cbListSize);

    DmCloseKey(GroupKey);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\intrface.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Server side support for Cluster APIs dealing with network interfaces

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HNETINTERFACE_RPC
s_ApiOpenNetInterface(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNetInterfaceName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing network interface object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNetInterfaceName - Supplies the name of the netinterface to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a network interface object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HNETINTERFACE_RPC NetInterface;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));

    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    NetInterface = OmReferenceObjectByName(ObjectTypeNetInterface,
                                           lpszNetInterfaceName);

    if (NetInterface == NULL) {
        LocalFree(Handle);
        *Status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_NETINTERFACE_HANDLE;
    Handle->Flags = 0;
    Handle->NetInterface = NetInterface;
    InitializeListHead(&Handle->NotifyList);

    *Status = ERROR_SUCCESS;

    return(Handle);
}


error_status_t
s_ApiCloseNetInterface(
    IN OUT HNETINTERFACE_RPC *phNetInterface
    )

/*++

Routine Description:

    Closes an open network interface context handle.

Arguments:

    NetInterface - Supplies a pointer to the HNETINTERFACE_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_INTERFACE NetInterface;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NETINTERFACE(NetInterface, *phNetInterface);

    Handle = (PAPI_HANDLE)*phNetInterface;
    ApipRundownNotify(Handle);

    OmDereferenceObject(NetInterface);

    LocalFree(Handle);
    *phNetInterface = NULL;

    return(ERROR_SUCCESS);
}


VOID
HNETINTERFACE_RPC_rundown(
    IN HNETINTERFACE_RPC NetInterface
    )

/*++

Routine Description:

    RPC rundown procedure for a HNETINTERFACE_RPC. Just closes the handle.

Arguments:

    NetInterface - Supplies the HNETINTERFACE_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseNetInterface(&NetInterface);
}


error_status_t
s_ApiGetNetInterfaceState(
    IN HNETINTERFACE_RPC hNetInterface,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified network interface.

Arguments:

    hNetInterface - Supplies the network interface whose state is to be returned

    lpState - Returns the current state of the network interface

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_INTERFACE NetInterface;


    API_ASSERT_INIT();

    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    *lpState = NmGetInterfaceState( NetInterface );

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiGetNetInterface(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName,
    IN LPCWSTR lpszNetworkName,
    OUT LPWSTR *lppszInterfaceName
    )
/*++

Routine Description:

    Gets the network interface for the given node and network.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the node name

    lpszNetworkName - Supplies the network name

    lppszInterfaceName - Returns the interface name

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    API_ASSERT_INIT();

    return(NmGetInterfaceForNodeAndNetwork(
               lpszNodeName,
               lpszNetworkName,
               lppszInterfaceName
               ));
}


error_status_t
s_ApiGetNetInterfaceId(
    IN HNETINTERFACE_RPC hNetInterface,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a network interface.

Arguments:

    hNetInterface - Supplies the network interface whose identifer is to be
                    returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_INTERFACE NetInterface;
    DWORD NameLen;
    LPCWSTR Name;


    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    Name = OmObjectId(NetInterface);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);

    *pGuid = MIDL_user_allocate(NameLen);

    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    CopyMemory(*pGuid, Name, NameLen);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\network.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Server side support for Cluster APIs dealing with networks

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HNETWORK_RPC
s_ApiOpenNetwork(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNetworkName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing network object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNetworkName - Supplies the name of the network to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a network object if successful

    NULL otherwise.

--*/

{
    PAPI_HANDLE Handle;
    HNETWORK_RPC Network;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));

    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Network = OmReferenceObjectByName(ObjectTypeNetwork, lpszNetworkName);

    if (Network == NULL) {
        LocalFree(Handle);
        *Status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        return(NULL);
    }

    Handle->Type = API_NETWORK_HANDLE;
    Handle->Flags = 0;
    Handle->Network = Network;
    InitializeListHead(&Handle->NotifyList);

    *Status = ERROR_SUCCESS;

    return(Handle);
}


error_status_t
s_ApiCloseNetwork(
    IN OUT HNETWORK_RPC *phNetwork
    )

/*++

Routine Description:

    Closes an open network context handle.

Arguments:

    Network - Supplies a pointer to the HNETWORK_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_NETWORK Network;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NETWORK(Network, *phNetwork);

    Handle = (PAPI_HANDLE)*phNetwork;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Network);

    LocalFree(Handle);
    *phNetwork = NULL;

    return(ERROR_SUCCESS);
}


VOID
HNETWORK_RPC_rundown(
    IN HNETWORK_RPC Network
    )

/*++

Routine Description:

    RPC rundown procedure for a HNETWORK_RPC. Just closes the handle.

Arguments:

    Network - Supplies the HNETWORK_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    API_ASSERT_INIT();

    s_ApiCloseNetwork(&Network);
}


error_status_t
s_ApiGetNetworkState(
    IN HNETWORK_RPC hNetwork,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified network.

Arguments:

    hNetwork - Supplies the network whose state is to be returned.

    lpState - Returns the current state of the network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;


    API_ASSERT_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    *lpState = NmGetNetworkState( Network );

    return( ERROR_SUCCESS );
}


error_status_t
s_ApiSetNetworkName(
    IN HNETWORK_RPC hNetwork,
    IN LPCWSTR lpszNetworkName
    )
/*++

Routine Description:

    Sets the new friendly name of a network.

Arguments:

    hNetwork - Supplies the network whose name is to be set.

    lpszNetworkName - Supplies the new name of hNetwork

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NETWORK Network;
    HDMKEY NetworkKey;
    DWORD Status = ERROR_INVALID_FUNCTION;

    API_ASSERT_INIT();

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Status = NmSetNetworkName(
                 Network,
                 lpszNetworkName
                 );

    return(Status);
}


error_status_t
s_ApiGetNetworkId(
    IN HNETWORK_RPC hNetwork,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a network.

Arguments:

    hNetwork - Supplies the network whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_NETWORK Network;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Name = OmObjectId(Network);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);

    *pGuid = MIDL_user_allocate(NameLen);

    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    CopyMemory(*pGuid, Name, NameLen);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\node.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Public interfaces for managing the nodes of a cluster

Author:

    John Vert (jvert) 11-Jan-1996

Revision History:

--*/
#include "apip.h"


HNODE_RPC
s_ApiOpenNode(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing node object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the node to open.

    Status - Returns any error

Return Value:

    A context handle to a node object if successful

    NULL otherwise.

--*/

{
    HNODE_RPC Node;
    PAPI_HANDLE Handle;

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }
    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    Node = OmReferenceObjectByName(ObjectTypeNode, lpszNodeName);
    if (Node != NULL) {
        *Status = ERROR_SUCCESS;
    } else {
        *Status = ERROR_CLUSTER_NODE_NOT_FOUND;
        LocalFree(Handle);
        return(NULL);
    }
    Handle->Type = API_NODE_HANDLE;
    Handle->Node = Node;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}


error_status_t
s_ApiGetNodeId(
    IN HNODE_RPC hNode,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier for a node.

Arguments:

    hNode - Supplies the node whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PNM_NODE Node;
    DWORD IdLen;
    LPCWSTR Id;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Id = OmObjectId(Node);
    CL_ASSERT(Id != NULL);

    IdLen = (lstrlenW(Id)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(IdLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Id, IdLen);
    return(ERROR_SUCCESS);
}


error_status_t
s_ApiCloseNode(
    IN OUT HNODE_RPC *phNode
    )

/*++

Routine Description:

    Closes an open node context handle.

Arguments:

    Node - Supplies a pointer to the HNODE_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PNM_NODE Node;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, *phNode);

    Handle = (PAPI_HANDLE)*phNode;
    ApipRundownNotify(Handle);

    OmDereferenceObject(Node);
    LocalFree(*phNode);
    *phNode = NULL;

    return(ERROR_SUCCESS);
}



VOID
HNODE_RPC_rundown(
    IN HNODE_RPC Node
    )

/*++

Routine Description:

    RPC rundown procedure for a HNODE_RPC. Just closes the handle.

Arguments:

    Node - supplies the HNODE_RPC that is to be rundown.

Return Value:

    None.

--*/

{

    s_ApiCloseNode(&Node);

}


error_status_t
s_ApiGetNodeState(
    IN HNODE_RPC hNode,
    OUT DWORD *lpState
    )

/*++

Routine Description:

    Returns the current state of the specified node.

Arguments:

    hNode - Supplies the node whose state is to be returned.

    lpState - Returns the current state of the node

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

//    *lpState = NmGetNodeState( Node );
    *lpState = NmGetExtendedNodeState( Node );
    return( ERROR_SUCCESS );
}


error_status_t
s_ApiPauseNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Pauses a node in the cluster

Arguments:

    hNode - Supplies the node to be paused.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmPauseNode( Node );
    return( Status );

}


error_status_t
s_ApiResumeNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Resumes a node in the cluster

Arguments:

    hNode - Supplies the node to be resumed.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmResumeNode( Node );
    return( Status );

}


error_status_t
s_ApiEvictNode(
    IN HNODE_RPC hNode
    )

/*++

Routine Description:

    Pauses a node in the cluster

Arguments:

    hNode - Supplies the node to be evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NODE(Node, hNode);

    Status = NmEvictNode( Node );
    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Server side support for the notification APIs in the NT Cluster Service

Author:

    John Vert (jvert) 26-Mar-1996

Revision History:

--*/
#include "apip.h"

//
// Classification of the item types based on FilterType
//

#define ITEM_TYPE_OBJECT_NAME (CLUSTER_CHANGE_GROUP_STATE          |   \
                               CLUSTER_CHANGE_GROUP_ADDED          |   \
                               CLUSTER_CHANGE_GROUP_DELETED        |   \
                               CLUSTER_CHANGE_GROUP_PROPERTY       |   \
                               CLUSTER_CHANGE_NODE_STATE           |   \
                               CLUSTER_CHANGE_NODE_DELETED         |   \
                               CLUSTER_CHANGE_NODE_ADDED           |   \
                               CLUSTER_CHANGE_NODE_PROPERTY        |   \
                               CLUSTER_CHANGE_RESOURCE_STATE       |   \
                               CLUSTER_CHANGE_RESOURCE_ADDED       |   \
                               CLUSTER_CHANGE_RESOURCE_DELETED     |   \
                               CLUSTER_CHANGE_RESOURCE_PROPERTY    |   \
                               CLUSTER_CHANGE_NETWORK_STATE        |   \
                               CLUSTER_CHANGE_NETWORK_ADDED        |   \
                               CLUSTER_CHANGE_NETWORK_DELETED      |   \
                               CLUSTER_CHANGE_NETWORK_PROPERTY     |   \
                               CLUSTER_CHANGE_NETINTERFACE_STATE   |   \
                               CLUSTER_CHANGE_NETINTERFACE_ADDED   |   \
                               CLUSTER_CHANGE_NETINTERFACE_DELETED |   \
                               CLUSTER_CHANGE_NETINTERFACE_PROPERTY)

#define ITEM_TYPE_OBJECT_ID   (CLUSTER_CHANGE_RESOURCE_TYPE_DELETED    | \
                               CLUSTER_CHANGE_RESOURCE_TYPE_ADDED      | \
                               CLUSTER_CHANGE_QUORUM_STATE             | \
                               CLUSTER_CHANGE_CLUSTER_STATE)

#define ITEM_TYPE_REGISTRY    (CLUSTER_CHANGE_REGISTRY_NAME            | \
                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      | \
                               CLUSTER_CHANGE_REGISTRY_VALUE           | \
                               CLUSTER_CHANGE_REGISTRY_SUBTREE)

#define ITEM_TYPE_NAME        (ITEM_TYPE_REGISTRY                   | \
                               CLUSTER_CHANGE_HANDLE_CLOSE          | \
                               CLUSTER_CHANGE_CLUSTER_PROPERTY)


//
// Define types local to this module
//

typedef struct _INTEREST {
    LIST_ENTRY ListEntry;
    LIST_ENTRY HandleList;
    PVOID Object;
    DWORD Filter;
    DWORD Key;
} INTEREST, *PINTEREST;

typedef struct _ITEM {
    LIST_ENTRY ListEntry;
    DWORD FilterType;
    DWORD NotifyKey;
    union {
        LPVOID Object;
        WCHAR KeyName[0];               // For registry notifications
    };
} ITEM, *PITEM;

//
// Function prototypes local to this module
//
DWORD
ApipAddNotifyInterest(
    IN PNOTIFY_PORT Notify,
    IN PAPI_HANDLE ObjectHandle,
    IN DWORD Filter,
    IN DWORD NotifyKey,
    IN DWORD NotifyFilter
    );

//
// Define static data local to this module
//
LIST_ENTRY NotifyListHead;
CRITICAL_SECTION NotifyListLock;


VOID
ApiReportRegistryNotify(
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2,
    IN DWORD     CompletionFilter,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Interface to be called by DM when a registry change triggers
    a notification.

Arguments:

    Context1 - Supplies the first DWORD of Context that was passed
        to DmNotifyChangeKey. This is the NOTIFY_PORT to be used.

    Context2 - Supplies the second DWORD of Context that was passed
        to DmNotifyChangeKey. This is the NotifyKey to be used.

    CompletionFilter - Supplies the type of change that occurred.

    KeyName - Supplies the relative name of the key that was changed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY InterestEntry;
    PLIST_ENTRY PortEntry;
    PINTEREST Interest;
    PITEM Item;
    PNOTIFY_PORT NotifyPort;
    DWORD NameLength;

    ClRtlLogPrint(LOG_NOISE,
               "[API] Notification on port %1!8lx!, key %2!8lx! of type %3!d!. KeyName %4!ws!\n",
               (DWORD)Context1,
               (DWORD)Context2,
               CompletionFilter,
               KeyName);

    NameLength = (lstrlenW(KeyName)+1)*sizeof(WCHAR);
    NotifyPort  = (PNOTIFY_PORT)Context1;

    //
    // Post notification item for this interest.
    //
    Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM)+NameLength);
    if (Item != NULL) {
        Item->FilterType = CompletionFilter;
        Item->NotifyKey = (DWORD)Context2;
        CopyMemory(Item->KeyName, KeyName, NameLength);

        ClRtlInsertTailQueue(&NotifyPort->Queue, &Item->ListEntry);
    } else {
        ClRtlLogPrint(LOG_UNUSUAL, "[API] ApiReportRegistryNotify: Memory alloc failure for registry item, status %1!u!\n",
                      GetLastError());
    }
}


VOID
ApipRundownNotify(
    IN PAPI_HANDLE Handle
    )
/*++

Routine Description:

    Runs down any notification interests on a particular
    cluster object. The INTEREST structures will be yanked
    from their notification lists and freed.

Arguments:

    Handle - Supplies the API handle for the object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PINTEREST Interest;

    if (IsListEmpty(&Handle->NotifyList)) {
        return;
    }

    EnterCriticalSection(&NotifyListLock);
    while (!IsListEmpty(&Handle->NotifyList)) {
        ListEntry = RemoveHeadList(&Handle->NotifyList);
        Interest = CONTAINING_RECORD(ListEntry,
                                     INTEREST,
                                     HandleList);
        CL_ASSERT(Interest->Object == Handle->Cluster);

        RemoveEntryList(&Interest->ListEntry);
        LocalFree(Interest);
    }
    LeaveCriticalSection(&NotifyListLock);
}


DWORD
WINAPI
ApipEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes cluster events and dispatches the notifications to the appropriate
    notify queues.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD Filter;
    DWORD NameLength = 0;
    PLIST_ENTRY PortEntry;
    PNOTIFY_PORT NotifyPort;
    PLIST_ENTRY InterestEntry;
    PINTEREST Interest;
    PITEM Item;

    //
    // Translate EP event types into clusapi notification filters
    //
    switch (Event) {
        case CLUSTER_EVENT_API_NODE_UP:
        case CLUSTER_EVENT_NODE_DOWN:
        case CLUSTER_EVENT_NODE_JOIN:
        case CLUSTER_EVENT_NODE_CHANGE:
            Filter = CLUSTER_CHANGE_NODE_STATE;
            break;

        case CLUSTER_EVENT_NODE_ADDED:
            Filter = CLUSTER_CHANGE_NODE_ADDED;
            break;

        case CLUSTER_EVENT_NODE_PROPERTY_CHANGE:            
            Filter = CLUSTER_CHANGE_NODE_PROPERTY;
            break;

        case CLUSTER_EVENT_NODE_DELETED:
            Filter = CLUSTER_CHANGE_NODE_DELETED;
            break;

        case CLUSTER_EVENT_RESOURCE_ONLINE:
        case CLUSTER_EVENT_RESOURCE_OFFLINE:
        case CLUSTER_EVENT_RESOURCE_FAILED:
        case CLUSTER_EVENT_RESOURCE_CHANGE:
            Filter = CLUSTER_CHANGE_RESOURCE_STATE;
            break;

        case CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_RESOURCE_PROPERTY;
            break;

        case CLUSTER_EVENT_RESOURCE_ADDED:
            Filter = CLUSTER_CHANGE_RESOURCE_ADDED;
            break;

        case CLUSTER_EVENT_RESOURCE_DELETED:
            Filter = CLUSTER_CHANGE_RESOURCE_DELETED;
            break;

        case CLUSTER_EVENT_GROUP_ONLINE:
        case CLUSTER_EVENT_GROUP_OFFLINE:
        case CLUSTER_EVENT_GROUP_FAILED:
        case CLUSTER_EVENT_GROUP_CHANGE:
            Filter = CLUSTER_CHANGE_GROUP_STATE;
            break;

        case CLUSTER_EVENT_GROUP_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_GROUP_PROPERTY;
            break;

        case CLUSTER_EVENT_GROUP_ADDED:
            Filter = CLUSTER_CHANGE_GROUP_ADDED;
            break;

        case CLUSTER_EVENT_GROUP_DELETED:
            Filter = CLUSTER_CHANGE_GROUP_DELETED;
            break;

        case CLUSTER_EVENT_NETWORK_UNAVAILABLE:
        case CLUSTER_EVENT_NETWORK_DOWN:
        case CLUSTER_EVENT_NETWORK_PARTITIONED:
        case CLUSTER_EVENT_NETWORK_UP:
            Filter = CLUSTER_CHANGE_NETWORK_STATE;
            break;

        case CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_NETWORK_PROPERTY;
            break;

        case CLUSTER_EVENT_NETWORK_ADDED:
            Filter = CLUSTER_CHANGE_NETWORK_ADDED;
            break;

        case CLUSTER_EVENT_NETWORK_DELETED:
            Filter = CLUSTER_CHANGE_NETWORK_DELETED;
            break;

        case CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE:
        case CLUSTER_EVENT_NETINTERFACE_FAILED:
        case CLUSTER_EVENT_NETINTERFACE_UNREACHABLE:
        case CLUSTER_EVENT_NETINTERFACE_UP:
            Filter = CLUSTER_CHANGE_NETINTERFACE_STATE;
            break;

        case CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_NETINTERFACE_PROPERTY;
            break;

        case CLUSTER_EVENT_NETINTERFACE_ADDED:
            Filter = CLUSTER_CHANGE_NETINTERFACE_ADDED;
            break;

        case CLUSTER_EVENT_NETINTERFACE_DELETED:
            Filter = CLUSTER_CHANGE_NETINTERFACE_DELETED;
            break;

        case CLUSTER_EVENT_RESTYPE_ADDED:
            Filter = CLUSTER_CHANGE_RESOURCE_TYPE_ADDED;
            break;

        case CLUSTER_EVENT_RESTYPE_DELETED:
            Filter = CLUSTER_CHANGE_RESOURCE_TYPE_DELETED;
            break;

        case CLUSTER_EVENT_PROPERTY_CHANGE:
            Filter = CLUSTER_CHANGE_CLUSTER_PROPERTY;
            break;

        default:
            //
            // No notification for any of the other events yet.
            //
            return(ERROR_SUCCESS);

    }

    //
    // Run through the outstanding notify sessions and post notify items
    // for any matches.
    //
    EnterCriticalSection(&NotifyListLock);
    PortEntry = NotifyListHead.Flink;
    while (PortEntry != &NotifyListHead) {
        NotifyPort = CONTAINING_RECORD(PortEntry, NOTIFY_PORT, ListEntry);
        if (NotifyPort->Filter & Filter) {

            //
            // There are notification interests for this notify type, run
            // through the list of notification interests.
            //
            InterestEntry = NotifyPort->InterestList.Flink;
            while (InterestEntry != &NotifyPort->InterestList) {
                Interest = CONTAINING_RECORD(InterestEntry, INTEREST, ListEntry);

                //
                // Report the notification if the Interest's cluster object is NULL (which
                // means that this is a general cluster interest) or if the interest's specific
                // object matches the object reporting the notify.
                //
                if ((Interest->Filter & Filter) &&
                    ((Interest->Object == NULL) ||
                     (Interest->Object == Context))) {
                    //
                    // Post notification item for this interest.
                    //
                    if (Filter & ITEM_TYPE_NAME) {
                        NameLength = (lstrlenW(Context)+1)*sizeof(WCHAR);
                        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM)+NameLength);
                    } else {
                        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM));
                    }
                    if (Item != NULL) {
                        Item->FilterType = Filter;
                        Item->NotifyKey = Interest->Key;

                        if (!(Filter & ITEM_TYPE_NAME)) {
                            //
                            // Reference the object again to ensure that the name does
                            // not disappear out from under us before we are done with it.
                            //
                            Item->Object = Context;
                            OmReferenceObject(Context);
                        } else {
                            CopyMemory(Item->KeyName, Context, NameLength);
                        }
                        ClRtlInsertTailQueue(&NotifyPort->Queue, &Item->ListEntry);
                    } else {
                        ClRtlLogPrint(LOG_UNUSUAL, "[API] ApipEventHandler: Memory alloc failure notification item, status %1!u!\n",
                                      GetLastError());
                    }
                }
                InterestEntry = InterestEntry->Flink;
            }
        }
        PortEntry = PortEntry->Flink;
    }

    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);
}


HNOTIFY_RPC
s_ApiCreateNotify(
    IN HCLUSTER_RPC hCluster,
    OUT error_status_t *rpc_error
    )

/*++

Routine Description:

    Creates the server side of a notification port.

Arguments:

    IDL_handle - Supplies cluster handle.

    dwFilter - Supplies the cluster events of interest.

    dwNotifyKey - Supplies a key to be returned on any notifications

    rpc_error - Returns any RPC-specific error

Return Value:

    An RPC context handle for a notification port.

    NULL on failure.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port = NULL;
    PAPI_HANDLE Handle = NULL;
    //assume success
    *rpc_error = ERROR_SUCCESS;

    if (ApiState != ApiStateOnline) 
    {
        *rpc_error = ERROR_SHARING_PAUSED;
        goto FnExit;
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) 
    {
        *rpc_error = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    Port = LocalAlloc(LMEM_FIXED, sizeof(NOTIFY_PORT));
    if (Port == NULL) 
    {
        *rpc_error = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    InitializeListHead(&Port->InterestList);
    InitializeListHead(&Port->RegistryList);
    InitializeCriticalSection(&Port->Lock);
    Status = ClRtlInitializeQueue(&Port->Queue);
    if (Status != ERROR_SUCCESS) 
    {
        *rpc_error = Status;
        goto FnExit;
    }

    EnterCriticalSection(&NotifyListLock);
    InsertTailList(&NotifyListHead, &Port->ListEntry);
    LeaveCriticalSection(&NotifyListLock);

    Handle->Type = API_NOTIFY_HANDLE;
    Handle->Notify = Port;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    
FnExit:    
    if ((*rpc_error) != ERROR_SUCCESS)
    {
        if (Port) LocalFree(Port);
        if (Handle) LocalFree(Handle);
        return (NULL);
    }
    else
    {
        return(Handle);
    }        
}



error_status_t
s_ApiAddNotifyCluster(
    IN HNOTIFY_RPC hNotify,
    IN HCLUSTER_RPC hCluster,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey
    )

/*++

Routine Description:

    Adds another set of notification events to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hCluster - Supplies the cluster to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PAPI_HANDLE Handle;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);

    Handle = (PAPI_HANDLE)hCluster;
    if ((Handle == NULL ) || (Handle->Type != API_CLUSTER_HANDLE)) {
        return(ERROR_INVALID_HANDLE);
    }
    Status = ApipAddNotifyInterest(Port,
                                   Handle,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (dwFilter & ITEM_TYPE_REGISTRY) {
        //
        // Add a registry notification for the entire cluster.
        //
        DmNotifyChangeKey(DmClusterParametersKey,
                          dwFilter & ITEM_TYPE_REGISTRY,
                          (dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE,
                          &Port->RegistryList,
                          ApiReportRegistryNotify,
                          (DWORD_PTR)Port,
                          dwNotifyKey);
    }
    return(Status);

}


error_status_t
s_ApiAddNotifyNode(
    IN HNOTIFY_RPC hNotify,
    IN HNODE_RPC hNode,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a node-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNode - Supplies the node to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this node

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NODE Node;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NODE(Node, hNode);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNode,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetNodeState(Node);
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyGroup(
    IN HNOTIFY_RPC hNotify,
    IN HGROUP_RPC hGroup,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a group-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hGroup - Supplies the group to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_GROUP Group;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_GROUP_EXISTS(Group, hGroup);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hGroup,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = Group->StateSequence;
    }
    return(Status);

}


error_status_t
s_ApiAddNotifyNetwork(
    IN HNOTIFY_RPC hNotify,
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a network-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetwork - Supplies the network to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NETWORK Network;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetwork,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);

    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetNetworkState( Network );
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyNetInterface(
    IN HNOTIFY_RPC hNotify,
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a network interface-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetInterface - Supplies the network interface to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_INTERFACE NetInterface;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetInterface,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);

    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = NmGetInterfaceState( NetInterface );
    }

    return(Status);
}


error_status_t
s_ApiAddNotifyResource(
    IN HNOTIFY_RPC hNotify,
    IN HRES_RPC hResource,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    OUT DWORD *dwStateSequence
    )

/*++

Routine Description:

    Adds a resource-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hResource - Supplies the resource to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    dwStateSequence - Returns the current state sequence for the
        specified object

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_RESOURCE Resource;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hResource,
                                   dwFilter,
                                   dwNotifyKey,
                                   0);
    if (Status == ERROR_SUCCESS) {
        *dwStateSequence = Resource->StateSequence;
    }
    return(Status);

}


error_status_t
s_ApiReAddNotifyNode(
    IN HNOTIFY_RPC hNotify,
    IN HNODE_RPC hNode,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a node-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNode - Supplies the node to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this node

    dwStateSequence - Supplies the previous state sequence. If this does
        not match the current sequence, an immediate notification will
        be issued.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NODE Node;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NODE(Node, hNode);

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNode for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectId(Node),
               dwFilter,
               dwStateSequence,
               NmGetNodeState(Node));
    if (NmGetNodeState(Node) != (CLUSTER_NODE_STATE)dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NODE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNode,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyGroup(
    IN HNOTIFY_RPC hNotify,
    IN HGROUP_RPC hGroup,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a group-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hGroup - Supplies the group to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_GROUP Group;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_GROUP_EXISTS(Group, hGroup);
    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyGroup for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectName(Group),
               dwFilter,
               dwStateSequence,
               Group->StateSequence);
    if (Group->StateSequence != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_GROUP_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hGroup,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);

}


error_status_t
s_ApiReAddNotifyNetwork(
    IN HNOTIFY_RPC hNotify,
    IN HNETWORK_RPC hNetwork,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a network-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetwork - Supplies the network to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_NETWORK Network;
    DWORD NotifyFilter = 0;
    CLUSTER_NETWORK_STATE CurrentState;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETWORK_EXISTS(Network, hNetwork);

    CurrentState = NmGetNetworkState( Network );

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNetwork for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
                OmObjectName(Network),
                dwFilter,
                dwStateSequence,
                CurrentState);

    if ((DWORD)CurrentState != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NETWORK_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetwork,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyNetInterface(
    IN HNOTIFY_RPC hNotify,
    IN HNETINTERFACE_RPC hNetInterface,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a network interface-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hNetInterface - Supplies the network interface to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this network

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PNM_INTERFACE NetInterface;
    DWORD NotifyFilter = 0;
    CLUSTER_NETINTERFACE_STATE CurrentState;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_NETINTERFACE_EXISTS(NetInterface, hNetInterface);

    CurrentState = NmGetInterfaceState( NetInterface );

    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyNetInterface for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
                OmObjectName(NetInterface),
                dwFilter,
                dwStateSequence,
                CurrentState);

    if ((DWORD)CurrentState != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_NETINTERFACE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }

    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hNetInterface,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);
}


error_status_t
s_ApiReAddNotifyResource(
    IN HNOTIFY_RPC hNotify,
    IN HRES_RPC hResource,
    IN DWORD dwFilter,
    IN DWORD dwNotifyKey,
    IN DWORD dwStateSequence
    )

/*++

Routine Description:

    Adds a resource-specific notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hResource - Supplies the resource to be added

    dwFilter - Supplies the set of notification events to be added.

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    PFM_RESOURCE Resource;
    DWORD NotifyFilter;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    ClRtlLogPrint(LOG_NOISE,
               "[API] s_ApiReAddNotifyGroup for %1!ws! (%2!lx!) oldstate %3!d! newstate %4!d!\n",
               OmObjectName(Resource),
               dwFilter,
               dwStateSequence,
               Resource->StateSequence);
    if (Resource->StateSequence != dwStateSequence) {
        NotifyFilter = CLUSTER_CHANGE_RESOURCE_STATE & dwFilter;
    } else {
        NotifyFilter = 0;
    }
    Status = ApipAddNotifyInterest(Port,
                                   (PAPI_HANDLE)hResource,
                                   dwFilter,
                                   dwNotifyKey,
                                   NotifyFilter);
    return(Status);

}


error_status_t
s_ApiAddNotifyKey(
    IN HNOTIFY_RPC hNotify,
    IN HKEY_RPC hKey,
    IN DWORD dwNotifyKey,
    IN DWORD Filter,
    IN BOOL WatchSubTree
    )

/*++

Routine Description:

    Adds a registry notification event to an existing
    cluster notification port

Arguments:

    hNotify - Supplies the notification port

    hKey - Supplies the key to be added

    dwNotifyKey - Supplies the notification key to be returned on
        any notification events for this group

    WatchSubTree - Supplies whether the notification applies to just
        the specified key or to the keys entire subtree

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PNOTIFY_PORT Port;
    HDMKEY Key;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);
    VALIDATE_KEY(Key, hKey);
    Status = DmNotifyChangeKey(Key,
                               Filter,
                               WatchSubTree,
                               &Port->RegistryList,
                               ApiReportRegistryNotify,
                               (DWORD_PTR)Port,
                               dwNotifyKey);
    return(Status);

}


void
HNOTIFY_RPC_rundown(
    IN HNOTIFY_RPC hNotify
    )

/*++

Routine Description:

    RPC rundown routine for notification ports.

Arguments:

    hNotify - Supplies the notification port to be rundown

Return Value:

    None.

--*/

{
    s_ApiCloseNotify(&hNotify);
}


error_status_t
s_ApiUnblockGetNotifyCall(
    IN HNOTIFY_RPC hNotify
    )

/*++

Routine Description:

    Unblocks the s_ApiGetNotify call.

Arguments:

    hNotify - Supplies the notification port to be closed.

Return Value:

    None.

--*/

{
    PNOTIFY_PORT pPort;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2000
    //
    //  In order to prevent the client from calling ApiGetNotify
    //  during or after the context handle is destroyed, we split
    //  the notification port close into two steps. In the first step,
    //  we merely unblock the ApiGetNotify call without freeing the 
    //  context handle. That is the purpose of this function.
    //  In the next step, we free the context handle. The client can now 
    //  perform the notification port close in 2 steps, properly 
    //  synchronizing the freeing of the context handle with the call to 
    //  ApiGetNotify. This avoids an AV in RPC code caused by the 
    //  ApiGetNotify call being made during or soon after the context 
    //  handle is freed.
    //
    API_ASSERT_INIT();

    VALIDATE_NOTIFY( pPort, hNotify );

    DELETE_HANDLE( hNotify );

    ApipUnblockGetNotifyCall( pPort );
    
    return( ERROR_SUCCESS );
}

DWORD
s_ApiCloseNotify(
    IN OUT HNOTIFY_RPC *phNotify
    )

/*++

Routine Description:

    Closes a cluster notification port and unblocks the s_ApiGetNotify
    thread, if necessary.

Arguments:

    phNotify - Supplies the pointer to the notification port to be closed.
               Returns NULL

Return Value:

    ERROR_SUCCESS.

--*/

{
    PNOTIFY_PORT pPort;

    API_ASSERT_INIT();

    if ( *phNotify == NULL ) return ( ERROR_INVALID_HANDLE );
 
    if ( !IS_HANDLE_DELETED( *phNotify ) )
    {
        //
        //  If the handle is not already deleted, this means this call is
        //  coming from a client that does not make the ApiUnblockGetNotify
        //  call. In such a case, do all the work of unblocking the 
        //  ApiGetNotify thread and freeing the context handle.
        //
        VALIDATE_NOTIFY( pPort, *phNotify );

        ApipUnblockGetNotifyCall( pPort );
    } else
    {
        pPort = ((PAPI_HANDLE)(*phNotify))->Notify;
    }

    DeleteCriticalSection(&pPort->Lock);
    
    LocalFree( pPort );

    LocalFree( *phNotify );

    *phNotify = NULL;

    return( ERROR_SUCCESS );
}

error_status_t
s_ApiGetNotify(
    IN HNOTIFY_RPC hNotify,
    IN DWORD Timeout,
    OUT DWORD *dwNotifyKey,
    OUT DWORD *dwFilter,
    OUT DWORD *dwStateSequence,
    OUT LPWSTR *Name
    )


/*++

Routine Description:

    Retrieves a cluster notification event from a notify port

Arguments:

    hNotify - Supplies the notification port

    Timeout - Supplies the time to wait in ms.

    dwNotifyKey - Returns the notification key of the event

    dwFilter - Returns the notification type of the event

    dwStateSequence - Returns the current state sequence of the object.

    Name - Returns the name of the event. This buffer must be
        freed on the client side with MIDL_user_free

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PNOTIFY_PORT Port;
    PLIST_ENTRY ListEntry;
    PITEM Item;
    DWORD NameLen;
    LPCWSTR ObjectName;
    LPWSTR NullName = L"";
    DWORD StateSequence = 0;

    API_ASSERT_INIT();

    VALIDATE_NOTIFY(Port, hNotify);

    //
    // Make sure that Port is valid.
    //
    if ( Port == NULL ) {
        return(ERROR_INVALID_HANDLE);
    }

    //
    // Wait for something to arrive in the queue.
    // Take the lock to make sure the notify port doesn't
    // disappear out from under us.
    //
    EnterCriticalSection(&Port->Lock);
    if (IS_HANDLE_DELETED(hNotify)) {
        ListEntry = NULL;
    } else {
        ListEntry = ClRtlRemoveHeadQueue(&Port->Queue);
    }
    LeaveCriticalSection(&Port->Lock);
    if (ListEntry == NULL) {
        return(ERROR_NO_MORE_ITEMS);
    }

    Item = CONTAINING_RECORD(ListEntry, ITEM, ListEntry);
    if (Item->FilterType & ITEM_TYPE_OBJECT_NAME) {
        ObjectName = OmObjectName( Item->Object );
    } else if (Item->FilterType & ITEM_TYPE_OBJECT_ID) {
        ObjectName = OmObjectId( Item->Object );
    } else if (Item->FilterType & ITEM_TYPE_NAME) {
        ObjectName = Item->KeyName;
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[API] s_ApiGetNotify: Unrecognized filter type,0x%1!08lx!\r\n",
            Item->FilterType);
        LocalFree(Item);
#if DBG
        CL_ASSERT(FALSE)
#endif
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Get the state sequence for those notifications that have
    // state sequences.
    //
    if (Item->FilterType & CLUSTER_CHANGE_GROUP_STATE) {
        StateSequence = ((PFM_GROUP)(Item->Object))->StateSequence;
    } else if (Item->FilterType & CLUSTER_CHANGE_RESOURCE_STATE) {
        StateSequence = ((PFM_RESOURCE)(Item->Object))->StateSequence;
    } else if (Item->FilterType & CLUSTER_CHANGE_NODE_STATE) {
        StateSequence = NmGetNodeState((PNM_NODE)(Item->Object));
    }
    if ( ObjectName == NULL ) {
        ObjectName = NullName;
    }
    NameLen = (lstrlenW(ObjectName)+1)*sizeof(WCHAR);
    *Name = MIDL_user_allocate(NameLen);
    if (*Name != NULL) {
        CopyMemory(*Name, ObjectName, NameLen);
    }

    *dwFilter = Item->FilterType;
    *dwNotifyKey = Item->NotifyKey;
    *dwStateSequence = StateSequence;
    if (Item->FilterType & (ITEM_TYPE_OBJECT_NAME | ITEM_TYPE_OBJECT_ID)) {
        OmDereferenceObject(Item->Object);
    }
    LocalFree(Item);

    if (*Name == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        return(ERROR_SUCCESS);
    }

}


DWORD
ApipAddNotifyInterest(
    IN PNOTIFY_PORT Notify,
    IN PAPI_HANDLE ObjectHandle,
    IN DWORD Filter,
    IN DWORD NotifyKey,
    IN DWORD NotifyFilter
    )

/*++

Routine Description:

    Registers a notification interest on an existing
    cluster notification port

Arguments:

    Notify - Supplies the notification port

    ObjectHandle - Supplies a pointer to the object's handle.

    Filter - Supplies the set of notification events to be added.

    NotifyKey - Supplies the notification key to be returned on
        any notification events

    NotifyNow - Supplies whether a notification should be immediately
        posted (TRUE).

    NotifyFilter - If not zero, indicates that a notification should be
        immediately posted with the specified filter.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PINTEREST Interest;
    PITEM Item;

    if (Filter == 0) {
        return(ERROR_SUCCESS);
    }

    Interest = LocalAlloc(LMEM_FIXED, sizeof(INTEREST));
    if (Interest == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Interest->Object = ObjectHandle->Cluster;
    Interest->Filter = Filter;
    Interest->Key = NotifyKey;

    EnterCriticalSection(&NotifyListLock);
    InsertHeadList(&Notify->InterestList, &Interest->ListEntry);
    InsertHeadList(&ObjectHandle->NotifyList, &Interest->HandleList);
    Notify->Filter |= Filter;
    if (NotifyFilter) {
        //
        // Post an immediate notification on this object.
        //
        //SS: this assert is wrong because you can have a filter
        //that is a combination of say CLUSTER_CHANGE_GROUP_STATE+CLUSTER_CHANGE_HANDLE_CLOSE
        //and that is perfectly valid
        //CL_ASSERT(!(Filter & ITEM_TYPE_NAME));
        Item = LocalAlloc(LMEM_FIXED, sizeof(ITEM));
        if (Item != NULL) {
            Item->FilterType = NotifyFilter;
            Item->NotifyKey = Interest->Key;
            Item->Object = ObjectHandle->Node;
            OmReferenceObject(ObjectHandle->Node);
            ClRtlInsertTailQueue(&Notify->Queue, &Item->ListEntry);
        } else {
            ClRtlLogPrint(LOG_UNUSUAL, "[API] ApipAddNotifyInterest: Memory alloc failure for immediate notification item, status %1!u!\n",
                          GetLastError());
        }

    }
    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);

}

DWORD
ApipUnblockGetNotifyCall(
    PNOTIFY_PORT pPort
    )

/*++

Routine Description:

    Unblocks the s_ApiGetNotify call.

Arguments:

    pPort - Port associated with the session.

Return Value:

    ERROR_SUCCESS.

--*/

{
    PINTEREST Interest;
    PLIST_ENTRY ListEntry;
    LIST_ENTRY RundownList;
    PITEM Item;

    EnterCriticalSection(&NotifyListLock);
    RemoveEntryList(&pPort->ListEntry);

    //
    // rundown registry notifications
    //
    DmRundownList(&pPort->RegistryList);

    //
    // Abort any waiters on the queue and rundown any
    // items that may have already been posted to the
    // queue.
    //
    ClRtlRundownQueue(&pPort->Queue, &RundownList);
    while (!IsListEmpty(&RundownList)) {
        ListEntry = RemoveHeadList(&RundownList);
        Item = CONTAINING_RECORD(ListEntry,
                                 ITEM,
                                 ListEntry);
        if (!(Item->FilterType & ITEM_TYPE_NAME)) {
            OmDereferenceObject(Item->Object);
        }
        LocalFree(Item);
    }

    EnterCriticalSection(&pPort->Lock);
    ClRtlDeleteQueue(&pPort->Queue);
    LeaveCriticalSection(&pPort->Lock);

    //
    // rundown list of notify interests and delete each one.
    //
    while (!IsListEmpty(&pPort->InterestList)) {
        ListEntry = RemoveHeadList(&pPort->InterestList);
        Interest = CONTAINING_RECORD(ListEntry, INTEREST, ListEntry);
        RemoveEntryList(&Interest->HandleList);
        LocalFree(Interest);
    }

    LeaveCriticalSection(&NotifyListLock);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\cpinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cpinit.c

Abstract:

    Initialization and shutdown code for the Checkpoint Manager (CP)

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"

extern PFM_RESOURCE     gpQuoResource;

BOOL
CppCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

BOOL
CpckCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

BOOL
CppEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

BOOL
CpckEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );


VOID
CppResourceNotify(
    IN PVOID Context,
    IN PFM_RESOURCE Resource,
    IN DWORD NotifyCode
    )
/*++

Routine Description:

    Resource notification callback for hooking resource state
    changes. This allows to to register/deregister our registry
    notifications for that resource.

Arguments:

    Context - Supplies the context. Not used

    Resource - Supplies the resource that is going online or
        has been taken offline.

    NotifyCode - Supplies the type of notification, either
        NOTIFY_RESOURCE_PREONLINE or NOTIFY_RESOURCE_POSTOFFLINE
        /NOTIFY_RESOURCE_FAILED.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppResourceNotify for resource %1!ws!\n",
               OmObjectName(Resource));

    if ( Resource->QuorumResource ) {
        return;
    }

    if (NotifyCode == NOTIFY_RESOURCE_PREONLINE) {
        //
        //  If you are running in fix quorum mode and the quorum resource is offline, then there 
        //  is really no point attempting to restore the checkpoints since you are doomed to 
        //  fail accessing the quorum.
        //
        if ( ( CsNoQuorum ) && ( gpQuoResource->State == ClusterResourceOffline ) ) return;
        
        //
        // Restore any checkpointed registry state for this resource
        // This will also start the registry notification thread.
        //
        Resource->CheckpointState = 0;
        Status = CppWatchRegistry(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWatchRegistry for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }

        Status = CpckReplicateCryptoKeys(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpckReplicateCryptoKeys for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }
    } else {
        CL_ASSERT(NotifyCode == NOTIFY_RESOURCE_POSTOFFLINE ||
            NotifyCode == NOTIFY_RESOURCE_FAILED);
        //
        // Remove any posted registry notification for this resource
        //
        Status = CppRundownCheckpoints(Resource);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppUnWatchRegistry for resource %1!ws! failed %2!d!\n",
                       OmObjectName(Resource),
                       Status);
        }
    }
}


DWORD
CpInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the checkpoint manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    InitializeCriticalSection(&CppNotifyLock);
    InitializeListHead(&CpNotifyListHead);
    //
    // Register for resource online/offline notifications
    //
    Status = OmRegisterTypeNotify(ObjectTypeResource,
                                  NULL,
                                  NOTIFY_RESOURCE_PREONLINE |
                                  NOTIFY_RESOURCE_POSTOFFLINE|
                                  NOTIFY_RESOURCE_FAILED,
                                  CppResourceNotify);

    return(ERROR_SUCCESS);
}


DWORD
CpShutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the Checkpoint Manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DeleteCriticalSection(&CppNotifyLock);
    return(ERROR_SUCCESS);
}


DWORD
CpCompleteQuorumChange(
    IN LPCWSTR lpszOldQuorumPath
    )
/*++

Routine Description:

    Completes a change of the quorum disk. This involves deleting
    all the checkpoint files on the old quorum disk.

    Simple algorithm used here is to enumerate all the resources.
    For each resource, enumerate all its checkpoints and delete the
    checkpoint files.

Arguments:

    lpszNewQuorumPath - Supplies the new quorum path.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_CALLBACK_CONTEXT CbContext;

    CbContext.lpszPathName = lpszOldQuorumPath;
    
    OmEnumObjects(ObjectTypeResource,
                  CppEnumResourceCallback,
                  (PVOID)&CbContext,
                  CppRemoveCheckpointFileCallback);

    OmEnumObjects(ObjectTypeResource,
                  CpckEnumResourceCallback,
                  (PVOID)&CbContext,
                  CpckRemoveCheckpointFileCallback);

    return(ERROR_SUCCESS);
}


DWORD
CpCopyCheckpointFiles(
    IN LPCWSTR lpszPathName,
    IN BOOL    IsChangeFileAttribute
    )
/*++

Routine Description:

    Copies all the checkpoint files from the quorum disk to the supplied
    directory path. This function is invoked whenever the quorum disk
    changes or when the user wants to make a backup of the cluster DB
    on the quorum disk.

    Simple algorithm used here is to enumerate all the resources.
    For each resource, enumerate all its checkpoints and copy the
    checkpoint files from the quorum disk to the supplied path.

Arguments:

    lpszPathName - Supplies the destination path name.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_CALLBACK_CONTEXT CbContext;

    CbContext.lpszPathName = lpszPathName;
    CbContext.IsChangeFileAttribute = IsChangeFileAttribute;
   
    OmEnumObjects(ObjectTypeResource,
                  CppEnumResourceCallback,
                  (PVOID)&CbContext,
                  CppCopyCheckpointCallback);

    OmEnumObjects(ObjectTypeResource,
                  CpckEnumResourceCallback,
                  (PVOID)&CbContext,
                  CpckCopyCheckpointCallback);

    return(ERROR_SUCCESS);
}


BOOL
CppEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PENUM_VALUE_CALLBACK lpValueEnumRoutine,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for copying or deleting checkpoints
    when the quorum resource changes or when the user is making
    a backup of the cluster DB on the quorum disk.

Arguments:

    lpszPathName - Supplies the new quorum path to be passed to lpValueEnumRoutine.

    lpValueEnumRoutine - Supplies the value enumeration callback to
        be called if checkpoints exist.

    Resource - Supplies the resource object.

    Name - Supplies the resource name

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    CP_CALLBACK_CONTEXT Context;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    if (ResourceKey != NULL) {

        //
        // Open up the RegSync key
        //
        RegSyncKey = DmOpenKey(ResourceKey,
                               L"RegSync",
                               KEY_READ);
        DmCloseKey(ResourceKey);
        if (RegSyncKey != NULL) {

            Context.lpszPathName = pCbContext->lpszPathName;
            Context.Resource = Resource;
            Context.IsChangeFileAttribute = pCbContext->IsChangeFileAttribute;
            DmEnumValues(RegSyncKey,
                         lpValueEnumRoutine,
                         &Context);
            DmCloseKey(RegSyncKey);
        }
    }

    return(TRUE);
}


BOOL
CppCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing or when the user is making a backup of the cluster DB
    on the quorum disk. Copies the specified checkpoint file from the 
    current quorum directory to the supplied path (in the Context parameter).

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (new path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{
    WCHAR  OldCheckpointFile[MAX_PATH+1];
    LPWSTR NewCheckpointDir;
    LPWSTR NewCheckpointFile;
    DWORD  Status;
    DWORD  Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppCopyCheckpointCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get a temporary file name for saving the old checkpoint file
    //
    Status = DmCreateTempFileName(OldCheckpointFile);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - DmCreateTempFileName for old file failed with status %1!d! for resource %2!ws!...\n",
                   Status,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    //  Get the old checkpoint file from the node hosting the quorum resource
    //
    Status = CpGetDataFile(Context->Resource,
                           Id,
                           OldCheckpointFile,
                           FALSE);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - CpGetDataFile for checkpoint ID %2!d! failed with status %1!d! for resource %3!ws!...\n",
                   Status,
                   Id,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get the new checkpoint file and directory
    //
    Status = CppGetCheckpointFile(Context->Resource,
                                  Id,
                                  &NewCheckpointDir,
                                  &NewCheckpointFile,
                                  Context->lpszPathName,
                                  FALSE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback - CppGetCheckpointFile for new file failed %1!d!\n",
                   Status);
        return(TRUE);
    }

    //
    //  If necessary, try to change the file attributes to NORMAL
    //
    if (Context->IsChangeFileAttribute == TRUE) {
        QfsSetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_NORMAL);
        QfsSetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_NORMAL);
    }


    //
    // Create the new directory.
    //
    if (!QfsCreateDirectory(NewCheckpointDir, NULL)) {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppCopyCheckpointCallback unable to create directory %1!ws!, error %2!d!\n",
                       NewCheckpointDir,
                       Status);
            LocalFree(NewCheckpointFile);
            LocalFree(NewCheckpointDir);
            return(TRUE);
        }
        Status = ERROR_SUCCESS;
    }

    //
    // Copy the old file to the new file
    //
    if (!QfsClRtlCopyFileAndFlushBuffers(OldCheckpointFile, NewCheckpointFile)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppCopyCheckpointCallback unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   OldCheckpointFile,
                   NewCheckpointFile,
                   Status);
    }

    //
    //  If necessary, change the file attributes to READONLY
    //
    if ((Status == ERROR_SUCCESS) && (Context->IsChangeFileAttribute == TRUE)) {
        if (!QfsSetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_READONLY)
            ||
            !QfsSetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_READONLY)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CP] CppCopyCheckpointCallback unable to change file attributes in %1!ws!, error %2!d!\n",
                    NewCheckpointDir,
                    Status);
        }
    }

    LocalFree(NewCheckpointFile);
    LocalFree(NewCheckpointDir);
    return(TRUE);
}


BOOL
CppRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing. Deletes the specified checkpoint file from the old
    quorum directory.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (old path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{

    DWORD Status;
    DWORD Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppRemoveCheckpointFileCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    Status = CppDeleteFile(Context->Resource, Id, Context->lpszPathName);
    
    return(TRUE);
}

BOOL
CpckEnumResourceCallback(
    IN PCP_CALLBACK_CONTEXT pCbContext,
    IN PENUM_VALUE_CALLBACK lpValueEnumRoutine,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for copying or deleting crypto checkpoints
    when the quorum resource changes or when the user is making
    a backup of the cluster DB on the quorum disk.

Arguments:

    lpszPathName - Supplies the new quorum path to be passed to lpValueEnumRoutine.

    lpValueEnumRoutine - Supplies the value enumeration callback to
        be called if checkpoints exist.

    Resource - Supplies the resource object.

    Name - Supplies the resource name

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    CP_CALLBACK_CONTEXT Context;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    if (ResourceKey != NULL) {

        //
        // Open up the CryptoSyncKey key
        //
        CryptoSyncKey = DmOpenKey(ResourceKey,
                               L"CryptoSync",
                               KEY_READ);
        DmCloseKey(ResourceKey);
        if (CryptoSyncKey != NULL) {

            Context.lpszPathName = pCbContext->lpszPathName;
            Context.Resource = Resource;
            Context.IsChangeFileAttribute = pCbContext->IsChangeFileAttribute;
            DmEnumValues(CryptoSyncKey,
                         lpValueEnumRoutine,
                         &Context);
            DmCloseKey(CryptoSyncKey);
        }
    }

    return(TRUE);
}


BOOL
CpckCopyCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Crypto key enumeration callback used when the quorum resource
    is changing or when the user is making a backup of the cluster DB
    on the quorum disk. Copies the specified checkpoint file from the 
    current quorum directory to the supplied path (in the Context parameter).

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (new path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{
    WCHAR  OldCheckpointFile[MAX_PATH+1];
    LPWSTR NewCheckpointDir;
    LPWSTR NewCheckpointFile;
    DWORD  Status;
    DWORD  Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckCopyCheckpointCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get a temporary file name for saving the old checkpoint file
    //
    Status = DmCreateTempFileName(OldCheckpointFile);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpckCopyCheckpointCallback - DmCreateTempFileName for old file failed with status %1!d! for resource %2!ws!...\n",
                   Status,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    //  Get the old checkpoint file from the node hosting the quorum resource
    //
    Status = CpGetDataFile(Context->Resource,
                           Id,
                           OldCheckpointFile,
                           TRUE);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpckCopyCheckpointCallback - CpGetDataFile for checkpoint ID %2!d! failed with status %1!d! for resource %3!ws!...\n",
                   Status,
                   Id,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    //
    // Get the new checkpoint file and directory
    //
    Status = CppGetCheckpointFile(Context->Resource,
                                  Id,
                                  &NewCheckpointDir,
                                  &NewCheckpointFile,
                                  Context->lpszPathName,
                                  TRUE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckCopyCheckpointCallback - CppGetCheckpointFile for new file failed %1!d!\n",
                   Status);
        return(TRUE);
    }

    //
    //  If necessary, try to change the file attributes to NORMAL
    //
    if (Context->IsChangeFileAttribute == TRUE) {
        QfsSetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_NORMAL);
        QfsSetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_NORMAL);
    }


    //
    // Create the new directory.
    //
    if (!QfsCreateDirectory(NewCheckpointDir, NULL)) {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckCopyCheckpointCallback unable to create directory %1!ws!, error %2!d!\n",
                       NewCheckpointDir,
                       Status);
            LocalFree(NewCheckpointFile);
            LocalFree(NewCheckpointDir);
            return(TRUE);
        }
        Status = ERROR_SUCCESS;
    }

    //
    // Copy the old file to the new file
    //
    if (!QfsClRtlCopyFileAndFlushBuffers(OldCheckpointFile, NewCheckpointFile)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckCopyCheckpointCallback unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   OldCheckpointFile,
                   NewCheckpointFile,
                   Status);
    }

    //
    //  If necessary, change the file attributes to READONLY
    //
    if ((Status == ERROR_SUCCESS) && (Context->IsChangeFileAttribute == TRUE)) {
        if (!QfsSetFileAttributes(NewCheckpointFile, FILE_ATTRIBUTE_READONLY)
            ||
            !QfsSetFileAttributes(NewCheckpointDir, FILE_ATTRIBUTE_READONLY)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CPCK] CpckCopyCheckpointCallback unable to change file attributes in %1!ws!, error %2!d!\n",
                    NewCheckpointDir,
                    Status);
        }
    }

    LocalFree(NewCheckpointFile);
    LocalFree(NewCheckpointDir);
    return(TRUE);
}

/****
@func       DWORD | CpRestoreCheckpointFiles | Create a directory if necessary
            and copy all the resource checkpoint files from the backup
            directory to the quorum disk

@parm       IN LPWSTR | lpszSourcePathName | The name of the source path
            where the files are backed up.

@parm       IN LPWSTR | lpszSubDirName | The name of the sub-directory under
            the source path which can be a possible candidate for 
            containing the resource checkpoint files.

@parm       IN LPCWSTR | lpszQuoLogPathName | The name of the quorum disk 
            path where the files will be restored.
                      
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f DmpRestoreClusterDatabase> 
****/
DWORD CpRestoreCheckpointFiles(
    IN LPWSTR  lpszSourcePathName,
    IN LPWSTR  lpszSubDirName,
    IN LPCWSTR lpszQuoLogPathName )
{
    LPWSTR          szSourcePathName = NULL;
    LPWSTR          szSourceFileName = NULL;
    WCHAR           szDestPathName[MAX_PATH];
    WCHAR           szDestFileName[MAX_PATH];
    DWORD           dwLen;
    QfsHANDLE       hFindFile = QfsINVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           szTempCpFileNameExtn[10];
    DWORD           status;

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //

    dwLen = lstrlenW( lpszSourcePathName );
    dwLen += lstrlenW( lpszSubDirName );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 15 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[CP] CpRestoreCheckpointFiles: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              lpszSourcePathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    
    lstrcpyW( szSourcePathName, lpszSourcePathName );
    lstrcatW( szSourcePathName, lpszSubDirName ); 
    
    if ( szSourcePathName[dwLen-1] != L'\\' )
    {
        szSourcePathName[dwLen++] = L'\\';
        szSourcePathName[dwLen] = L'\0';
    }

    mbstowcs ( szTempCpFileNameExtn, "*.CP*", 6 );
    lstrcatW ( szSourcePathName, szTempCpFileNameExtn );

    //
    //  Try to find the first file in the directory
    //
    hFindFile = QfsFindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( !QfsIsHandleValid( hFindFile )  )
    {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[CP] CpRestoreCheckpointFiles: No file can be found in the supplied path %1!ws! Error = %2!%d! !!!\n",
                    szSourcePathName,
                    status);  
            CL_LOGFAILURE( status );
        } else
        {
            status = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    dwLen = lstrlenW( szSourcePathName );
    
    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                 sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[CP] CpRestoreCheckpointFiles: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              szSourcePathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
      
    lstrcpyW( szDestPathName, lpszQuoLogPathName );
    lstrcatW( szDestPathName, lpszSubDirName );
    dwLen = lstrlenW( szDestPathName );
    
    if ( szDestPathName[dwLen-1] != L'\\' )
    {
        szDestPathName[dwLen++] = L'\\';
        szDestPathName[dwLen] = L'\0';
    }
    //
    // Create the new directory, if necessary
    //
    if ( !QfsCreateDirectory ( szDestPathName, NULL ) ) 
    {
        status = GetLastError();
        if ( status != ERROR_ALREADY_EXISTS ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[CP] CpRestoreCheckpointFiles: Unable to create directory %1!ws!, error %2!d!\n",
                    szDestPathName,
                    status);
            CL_LOGFAILURE( status );
            goto FnExit;
        }
    }

    status = ERROR_SUCCESS;

    while ( status == ERROR_SUCCESS )
    {
        //
        //  Copy the checkpoint file to the destination
        //
        lstrcpyW( szSourceFileName, szSourcePathName );
        lstrcatW( szSourceFileName, FindData.cFileName );
        lstrcpyW( szDestFileName, szDestPathName );
        lstrcatW( szDestFileName, FindData.cFileName );

        status = QfsCopyFile( szSourceFileName, szDestFileName, FALSE );
        if ( !status ) 
        {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CP] CpRestoreCheckpointFiles: Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                    szSourceFileName,
                    szDestFileName,
                    status);
            CL_LOGFAILURE( status );
            goto FnExit;
        } 

        //
        //  Set the file attribute to normal. Continue even if you 
        //  fail in this step but log an error. 
        //
        if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CP] CpRestoreCheckpointFiles::Error in changing %1!ws! attribute to NORMAL\n",
                    szDestFileName);
        }

        if ( QfsFindNextFile( hFindFile, &FindData ) )
        {
            status = ERROR_SUCCESS;
        } else
        {
            status = GetLastError();
        }
    }

    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[CP] CpRestoreCheckpointFiles: FindNextFile failed !!!\n");
    }

FnExit:
    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );
    QfsFindCloseIfValid( hFindFile );
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Server side support for Cluster registry database APIs

Author:

    John Vert (jvert) 8-Mar-1996

Revision History:

--*/
#include "apip.h"


PAPI_HANDLE
ApipMakeKeyHandle(
    IN HDMKEY Key
    )
/*++

Routine Description:

    Allocates and initializes an API_HANDLE structure for the
    specified HDMKEY.

Arguments:

    Key - Supplies the HDMKEY.

Return Value:

    A pointer to the initialized API_HANDLE structure on success.

    NULL on memory allocation failure.

--*/

{
    PAPI_HANDLE Handle;

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        return(NULL);
    }
    Handle->Type = API_KEY_HANDLE;
    Handle->Flags = 0;
    Handle->Key = Key;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);

}


HKEY_RPC
s_ApiGetRootKey(
    IN handle_t IDL_handle,
    IN DWORD samDesired,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens the registry key at the root of the cluster registry database

Arguments:

    IDL_handle - Supplies RPC binding handle, not used.

    samDesired - Supplies requested security access

    Status - Returns error code, if any.

Return Value:

    A handle to the opened registry key.

--*/

{
    DWORD Error;
    HDMKEY Key;
    PAPI_HANDLE Handle=NULL;

    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        goto FnExit;
    }
    Key = DmGetRootKey(samDesired);
    RpcRevertToSelf();
    if (Key == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(Key);
        if (Handle == NULL) {
            DmCloseKey(Key);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }
FnExit:    
    return(Handle);
}


HKEY_RPC
s_ApiCreateKey(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN PRPC_SECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT LPDWORD lpdwDisposition,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Creates a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, it is created on all nodes in
    the cluster.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. The only currently
        supported option is REG_OPTION_VOLATILE

    samDesired - Supplies desired security access mask

    lpSecurityAttributes - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

    Status - Returns the error code if the function is unsuccessful.

Return Value:

    A handle to the specified key if successful

    NULL otherwise.

--*/

{
    HDMKEY NewKey;
    PAPI_HANDLE Handle = NULL;
    PAPI_HANDLE RootHandle = NULL;

    if (hKey != NULL) {
        RootHandle = (PAPI_HANDLE)hKey;
        if (RootHandle->Type != API_KEY_HANDLE) {
            *Status = ERROR_INVALID_HANDLE;
            return(NULL);
        }
    } else {
        *Status = ERROR_INVALID_HANDLE;
        return(NULL);
    }

    if (ApiState != ApiStateOnline) {
        *Status = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        return(NULL);
    }

    if ( ARGUMENT_PRESENT( lpSecurityAttributes ) &&
         (lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor != NULL) &&
         !RtlValidRelativeSecurityDescriptor( lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor,
          lpSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
          0 ) ) {
            *Status = ERROR_INVALID_SECURITY_DESCR;
            goto FnExit;
    }

    NewKey = DmCreateKey(RootHandle->Key,
                         lpSubKey,
                         dwOptions,
                         samDesired,
                         ARGUMENT_PRESENT(lpSecurityAttributes)
                              ? lpSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor
                              : NULL,
                         lpdwDisposition);
    if (NewKey == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(NewKey);
        if (Handle == NULL) {
            DmCloseKey(NewKey);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }

FnExit:
    RpcRevertToSelf();
    return(Handle);
}


HKEY_RPC
s_ApiOpenKey(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

    Status - Returns the error code if the function is unsuccessful.

Return Value:

    A handle to the specified key if successful

    NULL otherwise.

--*/

{
    HDMKEY NewKey;
    PAPI_HANDLE Handle=NULL;
    PAPI_HANDLE RootHandle;

    if (hKey != NULL) {
        RootHandle = (PAPI_HANDLE)hKey;
        if (RootHandle->Type != API_KEY_HANDLE) {
            *Status = ERROR_INVALID_HANDLE;
            return(NULL);
        }
    } else {
        *Status = ERROR_INVALID_HANDLE;
        return(NULL);
    }

    *Status = RpcImpersonateClient(NULL);
    if (*Status != RPC_S_OK)
    {
        goto FnExit;
    }

    NewKey = DmOpenKey(RootHandle->Key,
                       lpSubKey,
                       samDesired);
    if (NewKey == NULL) {
        *Status = GetLastError();
    } else {
        Handle = ApipMakeKeyHandle(NewKey);
        if (Handle == NULL) {
            DmCloseKey(NewKey);
            *Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *Status = ERROR_SUCCESS;
        }
    }
    RpcRevertToSelf();
FnExit:    
    return(Handle);
}

error_status_t
s_ApiEnumKey(
    IN HKEY_RPC hKey,
    IN DWORD dwIndex,
    OUT LPWSTR *KeyName,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Enumerates the subkeys of a cluster registry key.

Arguments:

    hKey - Supplies the registry key for which the subkeys should
           be enumerated.

    dwIndex - Supplies the index to be enumerated.

    KeyName - Returns the name of the dwIndex subkey. The memory
           allocated for this buffer must be freed by the client.

    lpftLastWriteTime - Returns the last write time.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LONG Status;
    DWORD NameLength;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            NULL,
                            &NameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    NameLength += 1;

    *KeyName = MIDL_user_allocate(NameLength*sizeof(WCHAR));
    if (*KeyName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = DmEnumKey(DmKey,
                       dwIndex,
                       *KeyName,
                       &NameLength,
                       lpftLastWriteTime);
    if (Status != ERROR_SUCCESS) {
        MIDL_user_free(*KeyName);
        *KeyName = NULL;
    }
    return(Status);
}


DWORD
s_ApiSetValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST UCHAR *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key.

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY  DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    return(DmSetValue(DmKey,
                      lpValueName,
                      dwType,
                      lpData,
                      cbData));
}


DWORD
s_ApiDeleteValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();
    return(DmDeleteValue(DmKey, lpValueName));
}


error_status_t
s_ApiQueryValue(
    IN HKEY_RPC hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpValueType,
    OUT PUCHAR lpData,
    IN DWORD cbData,
    OUT LPDWORD lpcbRequired
    )

/*++

Routine Description:

    Queries a named value for the specified cluster registry subkey

Arguments:

    hKey - Supplies the subkey whose value should be queried

    lpValueName - Supplies the named value to be queried

    lpValueType - Returns the type of the value's data

    lpData - Returns the value's data

    cbData - Supplies the size (in bytes) of the lpData buffer
             Returns the number of bytes copied into the lpData buffer
             If lpData==NULL, cbData is set to the required buffer
             size and the function returns ERROR_SUCCESS

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    DWORD BuffSize;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    BuffSize = cbData;
    Status = DmQueryValue(DmKey,
                          lpValueName,
                          lpValueType,
                          lpData,
                          &BuffSize);
    if ((Status == ERROR_SUCCESS) ||
        (Status == ERROR_MORE_DATA)) {
        *lpcbRequired = BuffSize;
    }

    return(Status);
}


DWORD
s_ApiDeleteKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();
    return(DmDeleteKey(DmKey, lpSubKey));
}


error_status_t
s_ApiEnumValue(
    IN HKEY_RPC hKey,
    IN DWORD dwIndex,
    OUT LPWSTR *lpValueName,
    OUT LPDWORD lpType,
    OUT UCHAR *lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD TotalSize
    )

/*++

Routine Description:

    Enumerates the specified value of a registry subkey

Arguments:

    hKey - Supplies the registry key handle

    dwIndex - Supplies the index of the value to be enumerated

    lpValueName - Returns the name of the dwIndex'th value. The
        memory for this name is allocated on the server and must
        be freed by the client side.

    lpType - Returns the value data type

    lpData - Returns the value data

    lpcbData - Returns the number of bytes written to the lpData buffer.

    TotalSize - Returns the size of the data

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LONG Status;
    DWORD OriginalNameLength;
    DWORD NameLength;
    DWORD DataLength;
    HDMKEY DmKey;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            NULL,
                            NULL,
                            NULL,
                            &NameLength,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    NameLength += 1;

    *lpValueName = MIDL_user_allocate(NameLength * sizeof(WCHAR));
    if (*lpValueName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *TotalSize = *lpcbData;

    //
    //  Chittur Subbaraman (chitturs) - 3/13/2001
    //
    //  First of all, at the beginning of this function, a big enough buffer for lpValueName
    //  is allocated. This means that ERROR_SUCCESS or ERROR_MORE_DATA will be returned by
    //  DmEnumValue depending ONLY on the size of the lpData buffer. This info is used by
    //  by the clusapi layer when it makes a decision based on the return code from this
    //  function.
    //
    //  Note that *TotalSize is initialized to *lpcbData just above. The TotalSize OUT variable 
    //  allows the required lpData size to be returned without touching lpcbData. This is 
    //  important since lpcbData is declared as the sizeof lpData in the IDL file and that is 
    //  what RPC will consider the lpData buffer size as. So, it is important that if the lpData
    //  buffer is not big enough, this function does not change the value of *lpcbData from what
    //  it was originally at IN time.
    //
    //  Strange behavior of RegEnumValue: If you supply a big enough buffer for lpValueName and
    //  a smaller than required buffer for lpData, then RegEnumValue won't bother to fill in
    //  lpValueName and will return ERROR_MORE_DATA. This irregular behavior is handled by
    //  DmEnumValue.
    //
    //  For reference pointers, RPC won't allow a client to pass in NULL pointers. That is why
    //  clusapi layer uses dummy variables in case some of the parameters passed in by the
    //  client caller is NULL.
    //
    //
    //  Behavior of RegEnumValue (assuming lpValueName buffer is big enough):
    //      (1) If lpData = NULL and lpcbData = NULL, then returns ERROR_SUCCESS.
    //      (2) If lpData = NULL and lpcbData != NULL, then returns ERROR_SUCCESS and sets
    //          *lpcbData to total buffer size required.
    //      (3) If lpData != NULL and lpcbData != NULL, but the data buffer size is smaller than
    //          required size, then returns ERROR_MORE_DATA and sets *lpcbData to the size required.
    //      (4) If lpData != NULL and lpcbData != NULL and the buffer is big enough, then returns
    //          ERROR_SUCCESS and sets *lpcbData to the size of the data copied into lpData.
    //
    //  OUR GOAL: ClusterRegEnumValue == RegEnumValue.
    //
    //  
    //  The following cases are handled by this function and the clusapi layer. Note that in this
    //  analysis, we assume that the client has called into clusapi with a big enough lpValueName
    //  buffer size. (If this is not true, then clusapi layer handles that, check ClusterRegEnumValue.)
    //
    //  Case 1: Client passes in lpData=NULL, lpcbData=NULL to ClusterRegEnumValue.
    //
    //      In this case, the clusapi layer will point both lpData and lpcbData to local dummy
    //      variables and initialize *lpcbData to 0. Thus, s_ApiEnumValue will see 
    //      both lpData and lpcbData as valid pointers. If the data value is bigger than the size of
    //      *lpcbData, then DmEnumValue will return ERROR_MORE_DATA. In this case, *TotalSize will
    //      contain the required buffer size and *lpcbData will be untouched. The client detects this 
    //      error code and sets the return status to ERROR_SUCCESS and *lpcbData to *TotalSize. Note
    //      that the 2nd action has less relevance since lpcbData is pointing to a local dummy variable.
    //      If the data value is of zero size, DmEnumValue will return ERROR_SUCCESS. 
    //      In such a case, *lpcbData will be set to *TotalSize before returning by this function. 
    //      Note that since the data size is 0, DmEnumValue would set *TotalSize to 0 and hence 
    //      *lpcbData will also be set to 0. Thus, in this case, when ApiEnumValue returns to the 
    //      clusapi layer, lpValueName will be filled in, *lpData will not be changed and *lpcbData 
    //      will be set to 0.
    //
    //  Case 2: Client passes in lpData=NULL, lpcbData!=NULL and *lpcbData=0 to ClusterRegEnumValue.
    //
    //      In this case, lpData alone will be pointing to a dummy clusapi buffer when ApiEnumValue
    //      is invoked. Thus, s_ApiEnumValue will get both lpData and lpcbData as valid pointers.
    //      If the data size is non-zero, then DmEnumValue will return ERROR_MORE_DATA and
    //      *TotalSize will contain the size of the required buffer. When this function returns,
    //      *lpcbData will remain untouched. As in case 1, the clusapi layer will set status
    //      to ERROR_SUCCESS and *lpcbData to *TotalSize. Thus, the client will see the required
    //      buffer size in *lpcbData. If the data size is zero, then it is handled as in case 1.
    //
    //  Case 3: Client passes in lpData!=NULL, lpcbData!=NULL, but the data buffer size is smaller than
    //      required.
    //
    //      In this case, both lpData and lpcbData will be pointing to client buffers (or RPC buffers
    //      representing them) at the entry to s_ApiEnumValue. DmEnumValue will return ERROR_MORE_DATA
    //      and this function will return the size required in *TotalSize. *lpcbData will not be
    //      touched. At the clusapi layer, *lpcbData will be set to *TotalSize and ERROR_MORE_DATA
    //      will be returned to the client.
    //      
    //  Case 4: Client passes in lpData!=NULL, lpcbData!=NULL and the data buffer size is big enough.
    //
    //      In this case, as in case 3, s_ApiEnumValue will have lpData and lpcbData pointing to 
    //      client buffers. DmEnumValue will return ERROR_SUCCESS, data copied to lpData and 
    //      *lpcbData will be set to *TotalSize (which is the size of the data copied into the 
    //      lpData buffer), before returning. The clusapi layer will return these values to the client.
    //
    Status = DmEnumValue(DmKey,
                         dwIndex,
                         *lpValueName,
                         &NameLength,
                         lpType,
                         lpData,
                         TotalSize);

    if (Status == ERROR_MORE_DATA) {
        return(Status);
    } else if (Status != ERROR_SUCCESS) {
        MIDL_user_free(*lpValueName);
        *lpValueName = NULL;
        *lpcbData = 0;
    } else {
        // This tells RPC how big the lpData buffer
        // is so it can copy the buffer to the client.
        *lpcbData = *TotalSize;
    }
    return(Status);
}


error_status_t
s_ApiQueryInfoKey(
    IN  HKEY_RPC hKey,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
/*++

Routine Description:

    Retrieves information about a specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key.

    lpcSubKeys - Points to a variable that receives the number of subkeys
        contained by the specified key.

    lpcbMaxSubKeyLen - Points to a variable that receives the length, in
        characters, of the key's subkey with the longest name.
        The count returned does not include the terminating null character.

    lpcValues - Points to a variable that receives the number of values
        associated with the key.

    lpcbMaxValueNameLen - Points to a variable that receives the length,
        in characters, of the key's longest value name. The count
        returned does not include the terminating null character.

    lpcbMaxValueLen - Points to a variable that receives the length, in
        bytes, of the longest data component among the key's values.

    lpcbSecurityDescriptor - Points to a variable that receives the length,
        in bytes, of the key's security descriptor.

    lpftLastWriteTime - Pointer to a FILETIME structure.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY DmKey;
    DWORD Status;

    VALIDATE_KEY(DmKey, hKey);

    Status = DmQueryInfoKey(DmKey,
                            lpcSubKeys,
                            lpcbMaxSubKeyLen,
                            lpcValues,
                            lpcbMaxValueNameLen,
                            lpcbMaxValueLen,
                            lpcbSecurityDescriptor,
                            lpftLastWriteTime);
    return(Status);
}


error_status_t
s_ApiCloseKey(
    IN OUT HKEY_RPC *pKey
    )

/*++

Routine Description:

    Closes a cluster registry key

Arguments:

    pKey - Supplies the key to be closed
           Returns NULL

Return Value:

    None.

--*/

{
    HDMKEY DmKey;
    DWORD Status;

    VALIDATE_KEY(DmKey, *pKey);

    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    Status = DmCloseKey(DmKey);
    RpcRevertToSelf();

    LocalFree(*pKey);
    *pKey = NULL;

    return(Status);
}


void
HKEY_RPC_rundown(
    IN HKEY_RPC Key
    )

/*++

Routine Description:

    RPC rundown routine for cluster registry keys

Arguments:

    Key - Supplies the handle to be rundown

Return Value:

    None.

--*/

{
    HDMKEY DmKey;

    //this should not call impersonate client

    if ((Key != NULL) && (((PAPI_HANDLE)(Key))->Type == API_KEY_HANDLE)) 
    {
        DmKey = ((PAPI_HANDLE)(Key))->Key;                  
        DmCloseKey(DmKey);
        LocalFree(Key);
    }
}


DWORD
s_ApiSetKeySecurity(
    IN HKEY hKey,
    IN DWORD SecurityInformation,
    IN PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    Sets the security on the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be set.

    pRpcSecurityDescriptor - Supplies the security information

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;
    DWORD Status;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    pSecurityDescriptor = pRpcSecurityDescriptor->lpSecurityDescriptor;
    if (!RtlValidRelativeSecurityDescriptor( pSecurityDescriptor,
          pRpcSecurityDescriptor->cbInSecurityDescriptor,0)){
        return(ERROR_INVALID_PARAMETER);
    }
    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    Status = DmSetKeySecurity(DmKey, SecurityInformation, pSecurityDescriptor);
    RpcRevertToSelf();
    return(Status);
}


DWORD
s_ApiGetKeySecurity(
    IN HKEY hKey,
    IN DWORD SecurityInformation,
    IN OUT PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    Gets the security from the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be retrieved.

    pRpcSecurityDescriptor - Returns the security information

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY DmKey;
    DWORD cbLength;
    DWORD Status;
    PSECURITY_DESCRIPTOR    lpSD;

    VALIDATE_KEY(DmKey, hKey);
    API_CHECK_INIT();

    cbLength = pRpcSecurityDescriptor->cbInSecurityDescriptor;
    lpSD = LocalAlloc(LMEM_FIXED, cbLength);
    if (lpSD == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Status = RpcImpersonateClient(NULL);
    if (Status != ERROR_SUCCESS) {
        LocalFree(lpSD);
        return(Status);
    }
    Status = DmGetKeySecurity(DmKey, SecurityInformation, lpSD, &cbLength);
    RpcRevertToSelf();
    if (Status == ERROR_SUCCESS) {
        Status = MapSDToRpcSD(lpSD, pRpcSecurityDescriptor);
    }
    if (Status != ERROR_SUCCESS) {
        pRpcSecurityDescriptor->cbInSecurityDescriptor = cbLength;
        pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
    }

    LocalFree(lpSD);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\resource.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Server side support for Cluster APIs dealing with resources

Author:

    John Vert (jvert) 7-Mar-1996

Revision History:

--*/
#include "apip.h"

HRES_RPC
s_ApiOpenResource(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszResourceName,
    OUT error_status_t *Status
    )

/*++

Routine Description:

    Opens a handle to an existing resource object.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceName - Supplies the name of the resource to open.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a resource object if successful

    NULL otherwise.

--*/

{
    HRES_RPC Resource;
    PAPI_HANDLE Handle;

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }
    Resource = OmReferenceObjectByName(ObjectTypeResource, lpszResourceName);
    if (Resource == NULL) {
        LocalFree(Handle);
        *Status = ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_NOISE,
                      "[API] s_ApiOpenResource: Resource %1!ws! not found, status = %2!u!...\n",
                      lpszResourceName,
                      *Status);
        return(NULL);
    }
    *Status = ERROR_SUCCESS;
    Handle->Type = API_RESOURCE_HANDLE;
    Handle->Resource = Resource;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}

HRES_RPC
s_ApiCreateResource(
    IN HGROUP_RPC hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags,
    OUT error_status_t *pStatus
    )

/*++

Routine Description:

    Creates a new resource object.

Arguments:

    hGroup - Supplies the group the resource is to be created in.

    lpszResourceName - Supplies the name of the resource to create.

    lpszResourceType - Supplies the type of the resource.

    dwFlags - Supplies any optional flags.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a resource object if successful

    NULL otherwise.

--*/

{
    HRES_RPC Resource=NULL;
    PFM_GROUP Group;
    UUID Guid;
    DWORD Status = ERROR_SUCCESS;
    WCHAR *KeyName=NULL;
    HDMKEY Key=NULL;
    HDMKEY GroupKey=NULL;
    HDMKEY TypeKey = NULL;
    HDMKEY ParamKey;
    DWORD Disposition;
    DWORD pollIntervals = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
    PAPI_HANDLE Handle;
    PFM_RESTYPE ResType;
    DWORD dwPersistentState = 0;
    DWORD dwClusterHighestVersion;

    if (ApiState != ApiStateOnline) 
    {
        *pStatus = ERROR_SHARING_PAUSED;
        return(NULL);
    }

    if ((hGroup == NULL) || (((PAPI_HANDLE)hGroup)->Type != API_GROUP_HANDLE)) 
    {
        *pStatus = ERROR_INVALID_HANDLE;
        return(NULL);
    }
    Group = ((PAPI_HANDLE)hGroup)->Group;

    //
    // Check for bogus flags.
    //
    if (dwFlags & ~CLUSTER_RESOURCE_VALID_FLAGS) 
    {
        *pStatus = ERROR_INVALID_PARAMETER;
        return(NULL);
    }

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));
    if (Handle == NULL) 
    {
        *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    //
    //  Chittur Subbaraman (chitturs) - 1/30/2000
    //
    //  If we are dealing with the mixed mode cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    //
    // Open the resource type key. This validates that the specified type exists.
    //
    TypeKey = DmOpenKey(DmResourceTypesKey,
                        lpszResourceType,
                        KEY_READ);
    if (TypeKey == NULL) 
    {
        Status = GetLastError();
        goto error_exit;
    }

retry:
    //
    // Create a GUID for this resource.
    //
    Status = UuidCreate(&Guid);

    if (Status != RPC_S_OK) 
    {
        goto error_exit;
    }
    Status = UuidToString(&Guid, &KeyName);
    if (Status != RPC_S_OK) 
    {
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[API] Creating resource %1!ws! <%2!ws!> (%3!ws!)\n",
                  lpszResourceType,
                  lpszResourceName,
                  KeyName);

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {   
        //
        // Create the new resource key.
        //
        Key = DmCreateKey(DmResourcesKey,
                          KeyName,
                          0,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &Disposition);
        if (Key == NULL) 
        {
            Status = GetLastError();
            goto error_exit;
        }
        if (Disposition != REG_CREATED_NEW_KEY) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[API] ApiCreateResource generated GUID %1!ws! that already existed! This is impossible.\n",
                          KeyName);
            DmCloseKey(Key);
            RpcStringFree(&KeyName);
            goto retry;
        }
        
        CL_ASSERT(Disposition == REG_CREATED_NEW_KEY);

        //
        // Set the resource's name in the registry
        //
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszResourceName,
                            (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // Set the resource's type in the registry
        // Note we reference the resource type and use its ID
        // so that the case is correct.
        //
        ResType = OmReferenceObjectById(ObjectTypeResType, lpszResourceType);
        if ( ResType == NULL )
        {
            //
            // Should not happen normally since we checked if the type existed in
            // the registry.
            //
            Status = ERROR_RESOURCE_TYPE_NOT_FOUND;
            goto error_exit;
        }
        lpszResourceType = OmObjectId(ResType);
        OmDereferenceObject(ResType);
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_TYPE,
                            REG_SZ,
                            (CONST BYTE *)lpszResourceType,
                            (lstrlenW(lpszResourceType)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // Set the resource's poll intervals in the registry.
        //
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_LOOKS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&pollIntervals,
                            4);
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }
        Status = DmSetValue(Key,
                            CLUSREG_NAME_RES_IS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&pollIntervals,
                            4);
        if (Status != ERROR_SUCCESS) 
        {
            goto error_exit;
        }

        //
        // If this resource should be started in a separate monitor, set that
        // parameter now.
        //
        if (dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR) 
        {
            DWORD SeparateMonitor = 1;

            Status = DmSetValue(Key,
                                CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                REG_DWORD,
                                (CONST BYTE *)&SeparateMonitor,
                                sizeof(SeparateMonitor));
            if (Status != ERROR_SUCCESS) 
            {
                goto error_exit;
            }
        }

        //
        // Create a Parameters key for the resource.
        //
        ParamKey = DmCreateKey(Key,
                               CLUSREG_KEYNAME_PARAMETERS,                   
                               0,
                               KEY_READ,
                               NULL,
                               &Disposition);
        if (ParamKey == NULL) 
        {
            CL_LOGFAILURE(GetLastError());
        } else 
        {
            DmCloseKey(ParamKey);
        }

        GroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group), KEY_READ | KEY_WRITE);
        if (GroupKey == NULL) 
        {
            Status = GetLastError();
            goto error_exit;
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/25/99
        //
        //  Make sure you set the persistent state of the resource to 
        //  ClusterResourceOffline before you create the resource. If
        //  this is not done, if you create a resource in a group which
        //  is online, the group's persistent state value (i.e., 1 in
        //  this case) is inherited by the resource in FmpQueryResourceInfo
        //  (only the memory state is set and not the registry state and
        //  this was a problem as well) and if you move such a group to 
        //  another node, it will bring the newly created resource online.
        //
        Status = DmSetValue( Key,
                             CLUSREG_NAME_RES_PERSISTENT_STATE,
                             REG_DWORD,
                             ( CONST BYTE * )&dwPersistentState,
                             sizeof( DWORD ) );
                         
        if ( Status != ERROR_SUCCESS ) 
        {
            goto error_exit;
        }
    }
    
    Resource = FmCreateResource(Group, KeyName, lpszResourceName, lpszResourceType, dwFlags);

    if (Resource == NULL) 
    {
        Status = GetLastError();
        //
        //  HACKHACK: Looks like this retry loop was coded up to retry in case a new resource got the
        //  GUID of an existing resource. FmpUpdateCreateResource returns this error in case of a conflict.
        //  It is best to get rid of it since we should assume UUidCreate generates a unique ID that
        //  doesn't conflict with anything else.  Else, it is a bug in that API. We should not be
        //  masking that.
        //
        if (Status == ERROR_ALREADY_EXISTS) 
        {
            RpcStringFree(&KeyName);
            goto retry;
        }
        goto error_exit;
    }

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        //
        // Add the resource to the Contains value of the specified group.
        //      
        Status = DmAppendToMultiSz(GroupKey,
                                   CLUSREG_NAME_GRP_CONTAINS,
                                   KeyName);
        if (Status != ERROR_SUCCESS) 
        {
            //
            // BUGBUG John Vert (jvert) 3-May-1996
            //      Need to delete this from the FM!
            //
            OmDereferenceObject(Resource);
            Resource = NULL;
        }
    }
    
error_exit:
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        if (Key != NULL) 
        {
            if (Status != ERROR_SUCCESS) 
            {
                //
                // Try and cleanup the key we just created.
                //
                DmDeleteKey(Key, CLUSREG_KEYNAME_PARAMETERS);
                DmDeleteKey(DmResourcesKey, KeyName);
            }
            DmCloseKey(Key);
        }
        if (GroupKey != NULL) 
        {
            DmCloseKey(GroupKey);
        }
    }

    if (TypeKey != NULL) 
    {
        DmCloseKey(TypeKey);
    }

    if (KeyName != NULL) 
    {
        RpcStringFree(&KeyName);
    }

    *pStatus = Status;
    if (Status != ERROR_SUCCESS) 
    {
        LocalFree(Handle);
        return(NULL);
    }

    CL_ASSERT(Resource != NULL);
    Handle->Type = API_RESOURCE_HANDLE;
    Handle->Resource = Resource;
    Handle->Flags = 0;
    InitializeListHead(&Handle->NotifyList);
    return(Handle);
}


error_status_t
s_ApiDeleteResource(
    IN HRES_RPC hResource
    )
/*++

Routine Description:

    Deletes the specified cluster resource from the group. The resource
    must have no other resources dependent on it.

Arguments:

    hResource - Supplies the cluster resource to be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PFM_RESOURCE Resource;
    DWORD Status;
    HDMKEY Key;
    HDMKEY GroupKey;
    DWORD  dwClusterHighestVersion; 

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    //  Chittur Subbaraman (chitturs) - 09/07/2000
    //
    //  If we are dealing with a Whistler-Win2K cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    Status = FmDeleteResource(Resource);

    if ( ( Status == ERROR_SUCCESS ) && 
         ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) ) {
        Status = DmDeleteTree(DmResourcesKey,OmObjectId(Resource));
        if ( (Status != ERROR_SUCCESS) &&
             (Status != ERROR_FILE_NOT_FOUND) ) {
            CL_LOGFAILURE( Status );
            return(Status);
        }
        GroupKey = DmOpenKey(DmGroupsKey,
                             OmObjectId(Resource->Group),
                             KEY_READ | KEY_SET_VALUE);
        if (GroupKey != NULL) {
            DmRemoveFromMultiSz(GroupKey,
                                CLUSREG_NAME_GRP_CONTAINS,
                                OmObjectId(Resource));
            DmCloseKey(GroupKey);
        }
    }
    return(Status);
}


error_status_t
s_ApiCloseResource(
    IN OUT HRES_RPC *phResource
    )

/*++

Routine Description:

    Closes an open resource context handle.

Arguments:

    Resource - Supplies a pointer to the HRES_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PFM_RESOURCE Resource;
    PAPI_HANDLE Handle;

    VALIDATE_RESOURCE(Resource, *phResource);

    Handle = (PAPI_HANDLE)*phResource;
    ApipRundownNotify(Handle);
    OmDereferenceObject(Resource);

    LocalFree(*phResource);
    *phResource = NULL;

    return(ERROR_SUCCESS);
}


VOID
HRES_RPC_rundown(
    IN HRES_RPC Resource
    )

/*++

Routine Description:

    RPC rundown procedure for a HRES_RPC. Just closes the handle.

Arguments:

    Resource - Supplies the HRES_RPC that is to be rundown.

Return Value:

    None.

--*/

{
    s_ApiCloseResource(&Resource);
}


error_status_t
s_ApiGetResourceState(
    IN HRES_RPC hResource,
    OUT DWORD *lpState,
    OUT LPWSTR *lpNodeId,
    OUT LPWSTR *lpGroupName
    )

/*++

Routine Description:

    Returns the current state of the specified resource.

Arguments:

    hResource - Supplies the resource whose state is to be returned.

    lpState - Returns the current state of the resource

    lpNodeId - Returns the Id of the node where the resource is currently online

    lpGroupName - Returns the name of the group the the resource is a member of

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    LPWSTR NodeId;
    DWORD IdLength;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    IdLength = MAX_COMPUTERNAME_LENGTH+1;
    NodeId = MIDL_user_allocate(IdLength*sizeof(WCHAR));
    if (NodeId == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *lpState = FmGetResourceState( Resource,
                                   NodeId,
                                   &IdLength);
    if ( *lpState == ClusterResourceStateUnknown ) {
        MIDL_user_free(NodeId);
        return(GetLastError());
    }
    *lpNodeId = NodeId;
    *lpGroupName = ApipGetObjectName(Resource->Group);

    return(ERROR_SUCCESS);
}


error_status_t
s_ApiSetResourceName(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName
    )
/*++

Routine Description:

    Sets the new friendly name of a resource.

Arguments:

    hResource - Supplies the resource whose name is to be set.

    lpszResourceName - Supplies the new name of hResource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    DWORD Status;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Tell the FM about the new name. If it is OK with the
    // FM, go ahead and update the registry.
    //
    Status = FmSetResourceName(Resource,
                               lpszResourceName);


    return(Status);
}



error_status_t
s_ApiGetResourceId(
    IN HRES_RPC hResource,
    OUT LPWSTR *pGuid
    )

/*++

Routine Description:

    Returns the unique identifier (GUID) for a resource.

Arguments:

    hResource - Supplies the resource whose identifer is to be returned

    pGuid - Returns the unique identifier. This memory must be freed on the
            client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    Name = OmObjectId(Resource);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);
    *pGuid = MIDL_user_allocate(NameLen);
    if (*pGuid == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*pGuid, Name, NameLen);
    return(ERROR_SUCCESS);
}


error_status_t
s_ApiGetResourceType(
    IN HRES_RPC hResource,
    OUT LPWSTR *lpszResourceType
    )

/*++

Routine Description:

    Returns the resource type for a resource.

Arguments:

    hResource - Supplies the resource whose identifer is to be returned

    lpszResourceType - Returns the resource type name. This memory must be
            freed on the client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    DWORD NameLen;
    LPCWSTR Name;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    if ( Resource->Type == NULL ) {
        return(ERROR_INVALID_STATE);
    }

    Name = OmObjectId(Resource->Type);

    NameLen = (lstrlenW(Name)+1)*sizeof(WCHAR);
    *lpszResourceType = MIDL_user_allocate(NameLen);
    if (*lpszResourceType == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(*lpszResourceType, Name, NameLen);
    return(ERROR_SUCCESS);
}


DWORD
s_ApiOnlineResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Brings a resource and all its dependencies online

Arguments:

    hResource - Supplies the resource to be brought online

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE(Resource, hResource);

    return(FmOnlineResource(Resource));

}


DWORD
s_ApiFailResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Initiates a resource failure. The specified resource is treated as failed.
    This causes the cluster to initiate the same failover process that would
    result if the resource actually failed.

Arguments:

    hResource - Supplies the resource to be failed over

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    return(FmFailResource(Resource));

}


DWORD
s_ApiOfflineResource(
    IN HRES_RPC hResource
    )

/*++

Routine Description:

    Brings a resource and all its dependents offline

Arguments:

    hResource - Supplies the resource to be brought offline

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    return(FmOfflineResource(Resource));

}


error_status_t
s_ApiAddResourceDependency(
    IN HRES_RPC hResource,
    IN HRES_RPC hDependsOn
    )
/*++

Routine Description:

    Adds a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    hResource - Supplies the resource which is dependent.

    hDependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    DWORD Status;
    HDMKEY ResKey;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(DependsOn, hDependsOn);

    //
    // Call the FM to create the dependency relationship.
    //
    Status = FmAddResourceDependency(Resource, DependsOn);
    if (Status == ERROR_SUCCESS) {
        //
        // Add the dependency information to the cluster database.
        //
        ResKey = DmOpenKey(DmResourcesKey,
                           OmObjectId(Resource),
                           KEY_READ | KEY_SET_VALUE);
        if (ResKey == NULL) {
            Status = GetLastError();
            CL_LOGFAILURE(Status);
        } else {
            Status = DmAppendToMultiSz(ResKey,
                                       CLUSREG_NAME_RES_DEPENDS_ON,
                                       OmObjectId(DependsOn));
            DmCloseKey(ResKey);
        }
        if (Status != ERROR_SUCCESS) {
            FmRemoveResourceDependency(Resource, DependsOn);
        }
    }
    return(Status);
}

error_status_t
s_ApiRemoveResourceDependency(
    IN HRES_RPC hResource,
    IN HRES_RPC hDependsOn
    )
/*++

Routine Description:

    Removes a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    hResource - Supplies the resource which is dependent.

    hDependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    DWORD Status;
    HDMKEY ResKey;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(DependsOn, hDependsOn);

    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((Resource->Group != DependsOn->Group) ||
        (Resource == DependsOn)) {
        return(ERROR_DEPENDENCY_NOT_FOUND);
    }

    //
    // Remove the dependency from the registry database.
    //
    ResKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(Resource),
                       KEY_READ | KEY_SET_VALUE);
    if (ResKey == NULL) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
    } else {
        Status = DmRemoveFromMultiSz(ResKey,
                                     CLUSREG_NAME_RES_DEPENDS_ON,
                                     OmObjectId(DependsOn));
        DmCloseKey(ResKey);
    }

    if (Status == ERROR_SUCCESS) {

        //
        // Call the FM to remove the dependency relationship.
        //
        Status = FmRemoveResourceDependency(Resource, DependsOn);

    } else if (Status == ERROR_FILE_NOT_FOUND) {

        //
        // Map this expected error to something a little more reasonable.
        //
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }

    return(Status);
}


error_status_t
s_ApiCanResourceBeDependent(
    IN HRES_RPC hResource,
    IN HRES_RPC hResourceDependent
    )
/*++

Routine Description:

    Determines if the resource identified by hResource can depend on hResourceDependent.
    In order for this to be true, both resources must be members of the same group and
    the resource identified by hResourceDependent cannot depend on the resource identified
    by hResource, whether directly or indirectly.

Arguments:

    hResource - Supplies a handle to the resource to be dependent.

    hResourceDependent - Supplies a handle to the resource on which
        the resource identified by hResource can depend.


Return Value:

    If the resource identified by hResource can depend  on the resource
        identified by hResourceDependent, the return value is ERROR_SUCCESS.

    Otherwise, the return value is ERROR_DEPENDENCY_ALREADY_EXISTS.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE ResourceDependent;

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_RESOURCE_EXISTS(ResourceDependent, hResourceDependent);

    if (Resource == ResourceDependent) {
        //
        // The caller is confused and is trying to make something
        // depend on itself.
        //
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    }

    if (Resource->Group != ResourceDependent->Group) {
        //
        // The caller is confused and is trying to make something
        // depend on a resource in another group.
        //
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    }

    //
    //  If the dependent is a quorum resource, you can't add a dependency.
    //
    if ( Resource->QuorumResource ) {
        return ( ERROR_DEPENDENCY_NOT_ALLOWED );
    }

    if (FmDependentResource(ResourceDependent, Resource, FALSE)) {
        return(ERROR_DEPENDENCY_ALREADY_EXISTS);
    } else {

        //
        // Finally check to make sure an immediate dependency does
        // not already exist.
        //
        if (FmDependentResource(Resource, ResourceDependent, TRUE)) {
            return(ERROR_DEPENDENCY_ALREADY_EXISTS);
        } else {
            return(ERROR_SUCCESS);
        }
    }

}

error_status_t
s_ApiCreateResEnum(
    IN HRES_RPC hResource,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )
/*++

Routine Description:

    Enumerates all the specified resource properties and returns the
    list of objects to the caller. The client-side is responsible
    for freeing the allocated memory.

Arguments:

    hResource - Supplies the resource whose properties are to be
                enumerated.

    dwType - Supplies the type of properties to be enumerated.

    ReturnEnum - Returns the requested objects.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    DWORD i;
    DWORD Result;
    PFM_RESOURCE Resource;
    PFM_RESOURCE Target;
    PNM_NODE Node;
    LPWSTR RealName;

    if (dwType & ~CLUSTER_RESOURCE_ENUM_ALL) {
        return(ERROR_INVALID_PARAMETER);
    }

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    Enum->EntryCount = 0;

    //
    // Enumerate all dependencies.
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_DEPENDS) {
        i=0;
        do {
            Result = FmEnumResourceDependent(Resource,
                                             i,
                                             &Target);
            if (Result == ERROR_SUCCESS) {
                RealName = ApipGetObjectName( Target );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_DEPENDS);
                    MIDL_user_free(RealName);                                  
                }
                OmDereferenceObject(Target);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    //
    // Enumerate all dependents
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_PROVIDES) {
        i=0;
        do {
            Result = FmEnumResourceProvider(Resource,
                                            i,
                                            &Target);
            if (Result == ERROR_SUCCESS) {
                RealName = ApipGetObjectName( Target );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_PROVIDES);
                    MIDL_user_free(RealName);                                  
                }
                OmDereferenceObject(Target);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    //
    // Enumerate all possible nodes
    //
    if (dwType & CLUSTER_RESOURCE_ENUM_NODES) {
        i=0;
        do {
            Result = FmEnumResourceNode(Resource,
                                        i,
                                        &Node);
            if (Result == ERROR_SUCCESS) {
                RealName = (LPWSTR)OmObjectName( Node );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_ENUM_NODES);
                }
                OmDereferenceObject(Node);
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    *ReturnEnum = Enum;
    return(ERROR_SUCCESS);

ErrorExit:

    if (Enum != NULL) {
        MIDL_user_free(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);
}


error_status_t
s_ApiAddResourceNode(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode
    )
/*++

Routine Description:

    Adds a node to the list of nodes where the specified resource
    can be brought online.

Arguments:

    hResource - Supplies the resource whose list of possible nodes is
        to be modified.

    hNode - Supplies the node to be added to the resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE Node;
    DWORD Status;
    DWORD dwUserModified;
    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Call the FM to do the real work.
    //
    Status = FmChangeResourceNode(Resource, Node, TRUE);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }
    //
    //  BUGBUG: What are the consequences of DmSetValue failing ?
    //
    //write out the fact that the user has explicitly set the 
    //resource possible node list
    //
    dwUserModified = 1;

    ClRtlLogPrint(LOG_NOISE,
                  "[API] s_ApiAddResourceNode: Setting UserModifiedPossibleNodeList key for resource %1!ws! \r\n",
                  OmObjectId(Resource));
                         
    DmSetValue( Resource->RegistryKey,
                     CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                     REG_DWORD,
                     (LPBYTE)&dwUserModified,
                     sizeof(DWORD));

    return(Status);
}


error_status_t
s_ApiRemoveResourceNode(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode
    )
/*++

Routine Description:

    Removes a node from the list of nodes that can host the
    specified resource. The resource must not be currently
    online on the specified node.

Arguments:

    hResource - Supplies the resource whose list of possible nodes is
        to be modified.

    hNode - Supplies the node to be removed from the resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE Node;
    DWORD Status;
    DWORD dwUserModified;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Call the FM to do the real work.
    //
    Status = FmChangeResourceNode(Resource, Node, FALSE);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    //  BUGBUG: What are the consequences of DmSetValue failing.
    //
    //write out the fact that the user has explicitly set the 
    //resource possible node list
    //
    dwUserModified = 1;
    ClRtlLogPrint(LOG_NOISE,
                  "[API] s_ApiRemoveResourceNode: Setting UserModifiedPossibleNodeList key for resource %1!ws! \r\n",
                  OmObjectId(Resource));

    DmSetValue( Resource->RegistryKey,
                     CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                     REG_DWORD,
                     (LPBYTE)&dwUserModified,
                     sizeof(DWORD));

    //SS: moved the write to the registry settings to the fm
    // layer as well, this way it is truly transactional
    
    return(Status);
}


error_status_t
s_ApiCreateResourceType(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Creates a new resource type in the cluster.  Note that this API only
    defines the resource type in the cluster registry and registers the
    resource type with the cluster service.  The calling program is
    responsible for installing the resource type DLL on each node in the
    cluster.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceTypeName - Supplies the new resource types name. The
        specified name must be unique within the cluster.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators

    lpszResourceTypeDll - Supplies the name of the new resource types DLL.

    dwLooksAlive - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlive - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    HDMKEY TypeKey = NULL;
    DWORD Disposition;
    DWORD dwClusterHighestVersion;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  If we are dealing with the mixed mode cluster, do the
    //  registry updates right here since the GUM handler won't do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) {   
        //
        // Add the resource information to the registry. If the key does not already
        // exist, then the name is unique and we can go ahead and call the FM to
        // create the actual resource type object.
        //
        TypeKey = DmCreateKey(DmResourceTypesKey,
                              lpszTypeName,
                              0,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &Disposition);
        if (TypeKey == NULL) {
            return(GetLastError());
        }
        if (Disposition != REG_CREATED_NEW_KEY) {
            DmCloseKey(TypeKey);
            return(ERROR_ALREADY_EXISTS);
        }

        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_DLL_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszDllName,
                            (lstrlenW(lpszDllName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_IS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&dwIsAlive,
                            sizeof(dwIsAlive));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                            REG_DWORD,
                            (CONST BYTE *)&dwLooksAlive,
                            sizeof(dwIsAlive));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
        Status = DmSetValue(TypeKey,
                            CLUSREG_NAME_RESTYPE_NAME,
                            REG_SZ,
                            (CONST BYTE *)lpszDisplayName,
                            (lstrlenW(lpszDisplayName)+1)*sizeof(WCHAR));
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    Status = FmCreateResourceType(lpszTypeName,
                                  lpszDisplayName,
                                  lpszDllName,
                                  dwLooksAlive,
                                  dwIsAlive);
    if (Status != ERROR_SUCCESS) {
        goto error_exit;
    }

    if (TypeKey != NULL) {
        DmCloseKey(TypeKey);
    }
    return(ERROR_SUCCESS);

error_exit:
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) {   
        DmCloseKey(TypeKey);
        DmDeleteKey(DmResourceTypesKey, lpszTypeName);
    }
    return(Status);
}


error_status_t
s_ApiDeleteResourceType(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName
    )
/*++

Routine Description:

    Deletes a resource type in the cluster.  Note that this API only
    deletes the resource type in the cluster registry and unregisters the
    resource type with the cluster service.  The calling program is
    responsible for deleting the resource type DLL on each node in the
    cluster.  If any resources of the specified type exist, this API
    fails.  The calling program is responsible for deleting any resources
    of this type before deleting the resource type.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszResourceTypeName - Supplies the name of the resource type to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    //
    // Delete the resource from the FM. This will check to make sure no
    // resources of the specified type exist and check that the resource
    // is already installed.
    //
    Status = FmDeleteResourceType(lpszTypeName);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Now remove the resource type from the registry.
    //
    DmDeleteTree(DmResourceTypesKey, lpszTypeName);

    return(ERROR_SUCCESS);
}


error_status_t
s_ApiChangeResourceGroup(
    IN HRES_RPC hResource,
    IN HGROUP_RPC hGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    hResource - Supplies the resource to move.

    hGroup - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    Resource;
    PFM_GROUP       Group;
    DWORD           Status;
    
    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_GROUP_EXISTS(Group, hGroup);


    //
    // Call the FM to do the real work. 
    //
    Status = FmChangeResourceGroup(Resource, Group);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

FnExit:
    return(Status);
}

/****
@func       error_status_t | s_ApiCreateResTypeEnum | Enumerates the list of 
            nodes in which the resource type can be supported and 
            returns the list of nodes to the caller. The client-side 
            is responsible for freeing the allocated memory.

@parm       IN handle_t | IDL_handle | RPC binding handle, not used.
@parm       IN LPCWSTR  | lpszTypeName | Name of the resource type.
@parm       IN DWORD | dwType | Supplies the type of properties 
            to be enumerated.
@parm       OUT PNM_NODE | ReturnEnum | Returns the requested objects.

@comm       This routine helps enumerating all the nodes that a particular
            resource type can be supported on.

@rdesc      ERROR_SUCCESS on success. Win32 error code otherwise.

@xref       
****/
error_status_t
s_ApiCreateResTypeEnum(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszTypeName,
    IN DWORD dwType,
    OUT PENUM_LIST *ReturnEnum
    )
{
    DWORD Status;
    DWORD Allocated = 0;
    PENUM_LIST Enum = NULL;
    DWORD i;
    DWORD Result;
    PFM_RESTYPE  pResType = NULL;
    PNM_NODE     pNode;
    LPWSTR       RealName = NULL;

    pResType = OmReferenceObjectById(ObjectTypeResType, 
                                    lpszTypeName);

    if (dwType & ~CLUSTER_RESOURCE_TYPE_ENUM_ALL) {
        Status = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }
                                    
    Allocated = INITIAL_ENUM_LIST_ALLOCATION;
    Enum = MIDL_user_allocate(ENUM_SIZE(Allocated));
    if (Enum == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    
    if (pResType == NULL) {
        //
        // The object cannot be found in the list !
        //
        Status = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto ErrorExit;
    }

    Enum->EntryCount = 0;

    //
    // Enumerate all possible nodes
    //
    if (dwType & CLUSTER_RESOURCE_TYPE_ENUM_NODES) {
        i=0;
        do {
            Result = FmEnumResourceTypeNode(pResType,
                                            i,
                                            &pNode);
            if (Result == ERROR_SUCCESS) {
                RealName = (LPWSTR)OmObjectName( pNode );
                if (RealName != NULL) {
                    ApipAddToEnum(&Enum,
                                  &Allocated,
                                  RealName,
                                  CLUSTER_RESOURCE_TYPE_ENUM_NODES);
                }
                OmDereferenceObject( pNode );
                ++i;
            }
        } while ( Result == ERROR_SUCCESS );
    }

    *ReturnEnum = Enum;
    OmDereferenceObject( pResType );
    return(ERROR_SUCCESS);

ErrorExit:
    if (pResType != NULL) {
        OmDereferenceObject( pResType );
    }
    if (Enum != NULL) {
        MIDL_user_free(Enum);
    }

    *ReturnEnum = NULL;
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\crypto.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    Interfaces for registering and deregistering crypto checkpoint
    handlers.

Author:

    Jeff Spelman (jeffspel) 11/10/1998

Revision History:

    Charlie Wickham (charlwi) 7/7/00

        added "how this works" section
--*/

#include "cpp.h"
#include "wincrypt.h"

#if 0

How crypto checkpointing works

Crypto checkpointing allows a crypto key container to be associated with a
resource. When that resource is moved to another node in the cluster, the key
container is constructed/updated from the checkpoint information on the previous
hosting node. The key container is not replicated; it only appears on a node if
the resource is moved to that node. Keys in the container must be exportable.

The user identifies the crypto key container by passing in a string of the
form "Type\Name\Key" where Type is CSP Provider type, Name is the provider
name, and Key is the key container name. The key container must already exist
prior to adding the checkpoint. They are created using the Crypto APIs.

Checkpoints are added in CpckAddCryptoCheckpoint. Checkpoint information is
stored in two places: in the CryptoSync key under the resource's GUID key and
in a datafile on the quorum drive. A new key, called CryptoSync, is created
under the resource key. In this key are values that are of the form 00000001,
00000002, etc. The data associated with the value is the string identifying
the crypto key container. The value name is also used as the datafile name
with a .CPR extension, i.e., if the value name is 00000001, then the
associated datafile would be in a subdirectory of the quorum area which is
named using the resource's GUID, and a filename of 00000001.CPR.

The checkpoint datafile contains all the information to restore the crypto key
container on another node in the cluster, i.e., a header
(CRYPTO_KEY_FILE_DATA), the signature and exchange keys if they exist, and the
security descriptor associated with key container.

Upon receiving the control code, the cluster service cracks the string into
its component parts and stores the data in a CRYPTO_KEY_INFO structure. The
CryptoSync key is opened/created and a check is made to see if the checkpoint
already exists. If not, an unused ID is found and the checkpoint is saved to a
file on the quorum disk.

When the resource is moved to another node, the FM calls CpckReplicateCryptoKeys
to restore the keys on that node. This routine reads the file and creates the
key container, imports the keys and sets the security descr. on the container.

Delete cleans up registry entry and file.

#endif

//
// Local type and structure definitions
//
// context structures are used during the DmEnumValues routine to pass data
// into the callback routine.
//
typedef struct _CPCK_ADD_CONTEXT {
    BOOL fFound;
    BYTE *pbInfo;
    DWORD cbInfo;
} CPCK_ADD_CONTEXT, *PCPCK_ADD_CONTEXT;

typedef struct _CPCK_DEL_CONTEXT {
    DWORD dwId;
    BYTE *pbInfo;
    DWORD cbInfo;
} CPCK_DEL_CONTEXT, *PCPCK_DEL_CONTEXT;

typedef struct _CPCK_GET_CONTEXT {
    DWORD cCheckpoints;
    BOOL fNeedMoreData;
    DWORD cbAvailable;
    DWORD cbRequired;
    BYTE *pbOutput;
} CPCK_GET_CONTEXT, *PCPCK_GET_CONTEXT;

//
// struct for Crypto Key information; breaks the container name into its
// component parts.
//
typedef struct _CRYPTO_KEY_INFO {
    DWORD dwVersion;
    DWORD dwProvType;
    LPWSTR pwszProvName;
    LPWSTR pwszContainer;
} CRYPTO_KEY_INFO, *PCRYPTO_KEY_INFO;

// current version for the CRYPTO_KEY_INFO struct
#define CRYPTO_KEY_INFO_VERSION     1

//
// struct for key data when writing and reading from files; additional memory
// is allocated after the structure to hold the exported signature key (if
// present), the exported exchange key (if present) and the optional security
// descriptor. At least one of the optional key components must be present in
// the container.
//

#define SALT_SIZE   16
#define IV_SIZE      8

typedef struct _CRYPTO_KEY_FILE_DATA {
    DWORD dwVersion;
    DWORD cbSig;            // offset from beginning of struct to exported Signature Key
    DWORD cbExch;           // offset from beginning of struct to exported Exchange Key
    DWORD cbSecDescr;       // offset from beginning of struct to container security descr.
    struct _CRYPTO_KEY_FILE_INITIALIZATION_DATA {
        BYTE rgbSigIV[IV_SIZE];
        BYTE rgbExchIV[IV_SIZE];
        BYTE rgbSalt[SALT_SIZE];
    };
} CRYPTO_KEY_FILE_DATA, *PCRYPTO_KEY_FILE_DATA;

// current version for the CRYPTO_KEY_INFO struct
#define CRYPTO_KEY_FILE_DATA_VERSION     1

//
//  Table that specifies for w2k {Crypto provider, default key length for RC2, default effective key length for
//  RC2}.
//
CP_RC2_W2k_KEYLEN_STRUCT   CP_RC2_W2k_KEYLEN_TABLE [] =
{
    { MS_DEF_PROV, 40, 40 },
    { MS_ENHANCED_PROV, 128, 40 },
    { MS_STRONG_PROV, 40, 40 },
    { MS_DEF_DSS_DH_PROV, 40, 40},
    { MS_ENH_DSS_DH_PROV, 40, 40 }
};

//
// Local function prototypes
//
BOOL
CpckReplicateCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    );

BOOL
CpckAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_ADD_CONTEXT Context
    );

BOOL
CpckDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_DEL_CONTEXT Context
    );

BOOL
CpckGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_GET_CONTEXT Context
    );

DWORD
CpckInstallKeyContainer(
    IN HCRYPTPROV hProv,
    IN LPWSTR   FileName,
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo
    );

DWORD
CpckCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HCRYPTPROV hProv,
    IN DWORD dwId,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo
    );

CL_NODE_ID
CppGetQuorumNodeId(
    VOID
    );

BOOL
CpckGetKeyLength(
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo,
    OUT PDWORD          pdwKeyLength,
    OUT PDWORD          pdwEffectiveKeyLength
    );

DWORD
CpckReplicateCryptoKeys(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Restores any crypto key checkpoints for this resource.

Arguments:

    Resource - Supplies the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);

    if (ResourceKey != NULL) {

        //
        // Open up the CryptoSync key
        //
        CryptoSyncKey = DmOpenKey(ResourceKey,
                                  L"CryptoSync",
                                  KEY_READ);
        DmCloseKey(ResourceKey);
        if (CryptoSyncKey != NULL) {

            DmEnumValues(CryptoSyncKey,
                         CpckReplicateCallback,
                         Resource);
            DmCloseKey(CryptoSyncKey);
        }

        return(ERROR_SUCCESS);
    } else {
        DWORD   status;

        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckReplicateCryptoKeys - couldn't open Resource key. error %1!d!\n",
                      status);

        return status;
    }

} //  CpckReplicateCryptoKeys


void
FreeCryptoKeyInfo(
    IN OUT CRYPTO_KEY_INFO *pCryptoKeyInfo
    )
/*++

Routine Description:

    Frees the string pointers in the structure.

Arguments:

    CryptoKeyInfo - Pointer to the CRYPTO_KEY_INFO structure which

--*/
{
    if (NULL != pCryptoKeyInfo)
    {
        if (NULL != pCryptoKeyInfo->pwszProvName)
        {
            LocalFree(pCryptoKeyInfo->pwszProvName);
            pCryptoKeyInfo->pwszProvName = NULL;
        }
        if (NULL != pCryptoKeyInfo->pwszContainer)
        {
            LocalFree(pCryptoKeyInfo->pwszContainer);
            pCryptoKeyInfo->pwszContainer = NULL;
        }
    }
} // FreeCryptoKeyInfo


DWORD
CpckValueToCryptoKeyInfo(
    OUT CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPVOID ValueData,
    IN DWORD ValueSize
    )
/*++

Routine Description:

    Converts from a binary blob into a CryptoKeyInfo structure.  Basically
    this just does some value and pointer assignments. The blob is a string of
    the format "Provider Type\Provider Name\Container Name".

Arguments:

    CryptoKeyInfo - Pointer to the CRYPTO_KEY_INFO structure which is filled in

    ValueData - Supplies the value data (this is the binary blob)

    ValueSize - Supplies the size of ValueData

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD   *pdw;
    WCHAR   *pwsz = (WCHAR*)ValueData;
    DWORD   cb = sizeof(DWORD) * 2;
    DWORD   cwch;
    DWORD   i;
    DWORD   Status = ERROR_SUCCESS;

    // make sure the length is OK (at least two slashes and a NULL?)
    if (ValueSize < sizeof(WCHAR) * 3)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // first is the numerical Provider type; find the slash separating it from
    // the provider name
    for (i = 0; i < (ValueSize - 3) / sizeof(WCHAR); i++)
    {
        if (L'\\' == pwsz[i])
        {
            pwsz[i] = L'\0';
            break;
        }
    }

    if ((ValueSize - 3) / sizeof(WCHAR) == i)
    {
        pwsz[i] = L'\\';
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    pCryptoKeyInfo->dwProvType = _wtoi(pwsz);
    pwsz[i] = L'\\';
    cwch = i;

    // grab the provider name pointer
    for (i = i + 1; i < (ValueSize - 2) / sizeof(WCHAR); i++)
    {
        if (L'\\' == pwsz[i])
        {
            pwsz[i] = L'\0';
            break;
        }
    }

    if ((ValueSize - 2) / sizeof(WCHAR) == i)
    {
        pwsz[i] = L'\\';
        Status = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    cb = (wcslen(&pwsz[cwch + 1]) + 1) * sizeof(WCHAR);
    if (NULL == (pCryptoKeyInfo->pwszProvName = 
        (WCHAR*)LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    wcscpy(pCryptoKeyInfo->pwszProvName, &pwsz[cwch + 1]);
    pwsz[i] = L'\\';
    cwch = i;

    // grab the container name pointer
    cb = (wcslen(&pwsz[cwch + 1]) + 1) * sizeof(WCHAR);
    if (NULL == (pCryptoKeyInfo->pwszContainer = 
        (WCHAR*)LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    wcscpy(pCryptoKeyInfo->pwszContainer, &pwsz[cwch + 1]);

Ret:
    return (Status);

} // CpckValueToCryptoKeyInfo


DWORD
CpckOpenCryptoKeyContainer(
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN BOOL fCreate,
    OUT HCRYPTPROV *phProv
    )
/*++

Routine Description:

    Opens a crypto key container (always uses CRYPT_MACHINE_KEYSET). Checks
    for either a signature and/or an exchange key and that they are
    exportable.

Arguments:

    pCryptKeyInfo - Supplies the information for opening the container

    fCreate - Flag indicating if container is to be created

    phProv - The resulting Crypto Provider handle

Return Value:

    ERROR_SUCCESS if succeeds

    Crypto Error code if it fails

--*/

{
    BOOLEAN WasEnabled;
    HCRYPTKEY hSigKey = 0;
    HCRYPTKEY hExchKey = 0;
    DWORD dwPermissions;
    DWORD cbPermissions;
    DWORD Status = 0;

    //
    // Attempt to open the specified crypto key container.
    //
    if (!CryptAcquireContextW(phProv,
                              pCryptoKeyInfo->pwszContainer,
                              pCryptoKeyInfo->pwszProvName,
                              pCryptoKeyInfo->dwProvType,
                              CRYPT_MACHINE_KEYSET))
    {
        if (fCreate)
        {
            //
            // if unable to open then create the container
            //
            if (!CryptAcquireContextW(phProv,
                                      pCryptoKeyInfo->pwszContainer,
                                      pCryptoKeyInfo->pwszProvName,
                                      pCryptoKeyInfo->dwProvType,
                                      CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
            {
                Status = GetLastError();
            }
        }
        else
        {
            Status = GetLastError();
        }
    }

    // if failed then try with BACKUP/RESTORE privilege
    if (0 != Status)
    {
        //
        //
        Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                                  &WasEnabled);

        if ( Status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckOpenCryptoKeyContainer failed to enable thread privilege %1!d!...\n",
                      Status);
            goto Ret;
        }

        if (!CryptAcquireContextW(phProv,
                                  pCryptoKeyInfo->pwszContainer,
                                  pCryptoKeyInfo->pwszProvName,
                                  pCryptoKeyInfo->dwProvType,
                                  CRYPT_MACHINE_KEYSET))
        {
            if (fCreate)
            {
                //
                // if unable to open then create the container
                //
                if (!CryptAcquireContextW(phProv,
                                          pCryptoKeyInfo->pwszContainer,
                                          pCryptoKeyInfo->pwszProvName,
                                          pCryptoKeyInfo->dwProvType,
                                          CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET))
                {
                    Status = GetLastError();
                }
            }
            else
            {
                Status = GetLastError();
            }
        }
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

    if ((0 == Status) && (!fCreate))
    {
        // check if there is a sig key
        if (CryptGetUserKey(*phProv, AT_SIGNATURE, &hSigKey))
        {
            // check if key is exportable
            cbPermissions = sizeof(DWORD);
            if (!CryptGetKeyParam(hSigKey,
                                  KP_PERMISSIONS,
                                  (BYTE*)&dwPermissions,
                                  &cbPermissions,
                                  0))
            {
                Status = GetLastError();
                goto Ret;
            }
            if (!(dwPermissions & CRYPT_EXPORT))
            {
                Status = (DWORD)NTE_BAD_KEY;
                goto Ret;
            }
        }

        // check if there is an exchange key
        if (CryptGetUserKey(*phProv, AT_KEYEXCHANGE, &hExchKey))
        {
            // check if key is exportable
            cbPermissions = sizeof(DWORD);
            if (!CryptGetKeyParam(hExchKey,
                                  KP_PERMISSIONS,
                                  (BYTE*)&dwPermissions,
                                  &cbPermissions,
                                  0))
            {
                Status = GetLastError();
                goto Ret;
            }
            if (!(dwPermissions & CRYPT_EXPORT))
            {
                Status = (DWORD)NTE_BAD_KEY;
                goto Ret;
            }
        }
    }
Ret:
    if (hSigKey)
        CryptDestroyKey(hSigKey);
    if (hExchKey)
        CryptDestroyKey(hExchKey);

    return Status;
} // CpckOpenCryptoKeyContainer


BOOL
CpckReplicateCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Value enumeration callback for replicating a resource's crypto key
    checkpoints.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry crypto key info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Resource - Supplies the resource this value is a crypto key checkpoint for

Return Value:

    TRUE to continue enumeration

--*/

{
    DWORD Id;
    DWORD Status;
    WCHAR TempFile[MAX_PATH];
    CRYPTO_KEY_INFO CryptoKeyInfo;
    HCRYPTPROV hProv = 0;
    BOOL fRet = TRUE;

    memset(&CryptoKeyInfo, 0, sizeof(CryptoKeyInfo));

    Id = wcstol(ValueName, NULL, 16);  // skip past the 'Crypto' prefix
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        goto Ret;
    }

    //
    // convert from binary blob into a Crypto Key Info structure
    //

    Status = CpckValueToCryptoKeyInfo(&CryptoKeyInfo,
                                      ValueData,
                                      ValueSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback invalid crypto info %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        goto Ret;
    }

    Status = CpckOpenCryptoKeyContainer(&CryptoKeyInfo,
                                        TRUE,
                                        &hProv);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback CryptAcquireContext failed for %1!ws! %2!ws! with %3!d! for resource %4!ws!\n",
                   CryptoKeyInfo.pwszContainer,
                   CryptoKeyInfo.pwszProvName,
                   Status,
                   OmObjectName(Resource));
        goto Ret;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CPCK] CpckReplicateCallback retrieving crypto id %1!lx! for resource %2!ws\n",
               Id,
               OmObjectName(Resource));
    //
    // See if there is any checkpoint data for this ID.
    //
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }
    Status = CpGetDataFile(Resource,
                           Id,
                           TempFile,
                           TRUE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckReplicateCallback - CpGetDataFile for id %1!lx! resource %2!ws! failed %3!d!\n",
                   Id,
                   OmObjectName(Resource),
                   Status);
    } else {

        //
        // Finally install the checkpointed file into the registry.
        //
        Status = CpckInstallKeyContainer(hProv, TempFile, &CryptoKeyInfo);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckReplicateCallback: could not restore temp file %1!ws! to container %2!ws! error %3!d!\n",
                       TempFile,
                       CryptoKeyInfo.pwszContainer,
                       Status);
            // Log the event for crypto key failure
            CsLogEventData2(LOG_CRITICAL,
                            CP_CRYPTO_CKPT_RESTORE_FAILED,
                            sizeof(Status),
                            &Status,
                            OmObjectName(Resource),
                            CryptoKeyInfo.pwszContainer);
        }

    }
    QfsDeleteFile(TempFile);

    //
    // watcher for crypto keys is not currently available or needed
    //
Ret:
    FreeCryptoKeyInfo(&CryptoKeyInfo);

    if (hProv)
        CryptReleaseContext(hProv, 0);

    return fRet;
} // CpckReplicateCallback


DWORD
CpckAddCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )
/*++

Routine Description:

    Adds a new crypto key checkpoint to a resource's list.

Arguments:

    Resource - supplies the resource the crypto key checkpoint should be added to.

    InBuffer - Supplies the crypto key information (always CRYPT_MACHINE_KEYSET)

    InBufferSize - Supplies the length of InBuffer

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HDMKEY  SyncKey;
    CPCK_ADD_CONTEXT Context;
    HDMKEY  ResourceKey = NULL;
    HDMKEY  CryptoSyncKey = NULL;
    DWORD   Disposition;
    DWORD   Id;
    WCHAR   IdName[9];
    DWORD   Status;
    CLUSTER_RESOURCE_STATE State;
    BOOLEAN WasEnabled;
    DWORD   Count=60;
    CRYPTO_KEY_INFO CryptoKeyInfo;
    HCRYPTPROV hProv = 0;

    memset(&CryptoKeyInfo, 0, sizeof(CryptoKeyInfo));

    //
    // convert from binary blob into a Crypto Key Info structure
    //

    Status = CpckValueToCryptoKeyInfo(&CryptoKeyInfo,
                                      InBuffer,
                                      InBufferSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckAddCryptoCheckpoint: invalid crypto info for resource %1!ws!\n",
                      OmObjectName(Resource));
        goto Ret;
    }

    Status = CpckOpenCryptoKeyContainer(&CryptoKeyInfo,
                                        FALSE,
                                        &hProv);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckAddCryptoCheckpoint: open key container failed for "
                      "container %1!ws! (provider: %2!ws!) with %3!d! for resource %4!ws!\n",
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName,
                      Status,
                      OmObjectName(Resource));
        goto Ret;
    }

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);

    if( ResourceKey == NULL ) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: couldn't open Resource key for %1!ws! error %2!d!\n",
                      OmObjectName(Resource),
                      Status);
        goto Ret;                   
    }

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmCreateKey(ResourceKey,
                                L"CryptoSync",
                                0,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &Disposition);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: couldn't create CryptoSync key for "
                      "resource %1!ws! error %2!d!\n",
                      OmObjectName(Resource),
                      Status);
        goto Ret;                   
    }
    if (Disposition == REG_OPENED_EXISTING_KEY) {
        //
        // Enumerate all the other values to make sure this key is
        // not already registered.
        //
        Context.fFound = FALSE;
        Context.pbInfo = InBuffer;
        Context.cbInfo = InBufferSize;
        DmEnumValues(CryptoSyncKey,
                     CpckAddCheckpointCallback,
                     &Context);
        if (Context.fFound) {
            //
            // This checkpoint already exists.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[CPCK] CpckAddCryptoCheckpoint: failing attempt to add duplicate "
                          "checkpoint for resource %1!ws!, container %2!ws! (provider: %3!ws!)\n",
                          OmObjectName(Resource),
                          CryptoKeyInfo.pwszContainer,
                          CryptoKeyInfo.pwszProvName);
            Status = ERROR_ALREADY_EXISTS;
            goto Ret;
        }

        //
        // Now we need to find a unique checkpoint ID for this registry subtree.
        // Start at 1 and keep trying value names until we get to one that does
        // not already exist.
        //
        for (Id=1; ; Id++) {
            DWORD dwType;
            DWORD cbData;

            wsprintfW(IdName,L"%08lx",Id);
            cbData = 0;
            Status = DmQueryValue(CryptoSyncKey,
                                  IdName,
                                  &dwType,
                                  NULL,
                                  &cbData);
            if (Status == ERROR_FILE_NOT_FOUND) {
                //
                // Found a free ID.
                //
                break;
            }
        }
    } else {
        //
        // The crypto sync reg key was just created, so this must be the only checkpoint
        // that exists.
        //
        Id = 1;
        wsprintfW(IdName, L"%08lx",Id);
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[CPCK] CpckAddCryptoCheckpoint: creating new checkpoint id %1!d! "
                  "for resource %2!ws!, container %3!ws! (provider: %4!ws!)\n",
                  Id,
                  OmObjectName(Resource),
                  CryptoKeyInfo.pwszContainer,
                  CryptoKeyInfo.pwszProvName);

    Status = DmSetValue(CryptoSyncKey,
                        IdName,
                        REG_BINARY,
                        (CONST BYTE *)InBuffer,
                        InBufferSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: failed to create new checkpoint id %1!d! "
                      "for resource %2!ws!, container %3!ws! (provider: %4!ws!)\n",
                      Id,
                      OmObjectName(Resource),
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName);
        goto Ret;
    }

RetryCheckpoint:
    //
    // Take the initial checkpoint
    //
    Status = CpckCheckpoint(Resource,
                            hProv,
                            Id,
                            &CryptoKeyInfo);

    // this may fail due to quorum resource being offline. We could do one of
    // two things here, wait for quorum resource to come online or retry. We
    // retry as this may be called from the online routines of a resource and
    // we dont want to add any circular waits.
    if ((Status == ERROR_ACCESS_DENIED) ||
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        if (Count--)
        {
            Sleep(1000);
            goto RetryCheckpoint;
        } 
#if DBG
        else
        {
            if (IsDebuggerPresent())
                DebugBreak();
        }        
#endif                                
        
    }
    
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[CPCK] CpckAddCryptoCheckpoint: failed to take initial checkpoint for "
                      "resource %1!ws!, container %2!ws! (provider: %3!ws!), error %4!d!\n",
                      OmObjectName(Resource),
                      CryptoKeyInfo.pwszContainer,
                      CryptoKeyInfo.pwszProvName,
                      Status);
        goto Ret;
    }
Ret:
    FreeCryptoKeyInfo(&CryptoKeyInfo);

    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (CryptoSyncKey)
        DmCloseKey(CryptoSyncKey);

    return(Status);
} // CpckAddCryptoCheckpoint


BOOL
CpckAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_ADD_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for adding a new registry
    checkpoint subtrees. This is only used to see if the specified
    registry subtree is already being watched.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto key information)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (memcmp(ValueData, Context->pbInfo, Context->cbInfo) == 0) {
        //
        // Found a match
        //
        Context->fFound = TRUE;
        return(FALSE);
    }
    return(TRUE);
} // CpckAddCheckpointCallback


DWORD
CpckDeleteCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )
/*++

Routine Description:

    Removes a crypto key checkpoint from a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    InBuffer - Supplies the crypto key information (always CRYPT_MACHINE_KEYSET)

    InBufferSize - Supplies the length of InBuffer

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPCK_DEL_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    DWORD Status;
    WCHAR ValueId[9];
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;
    CLUSTER_RESOURCE_STATE State;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);

    if ( ResourceKey == NULL ) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't open Resource key. error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmOpenKey(ResourceKey,
                           L"CryptoSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't open CryptoSync key error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Enumerate all the values to find this one
    //
    Context.dwId = 0;
    Context.pbInfo = InBuffer;
    Context.cbInfo = InBufferSize;
    DmEnumValues(CryptoSyncKey,
                 CpckDeleteCheckpointCallback,
                 &Context);
    if (Context.dwId == 0) {
        //
        // The specified tree was not found.
        //
        DmCloseKey(CryptoSyncKey);
        return(ERROR_FILE_NOT_FOUND);
    }

    wsprintfW(ValueId,L"%08lx",Context.dwId);
    Status = DmDeleteValue(CryptoSyncKey, ValueId);
    DmCloseKey(CryptoSyncKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't delete value %1!ws! error %2!d!\n",
                   ValueId,
                   Status);
        return(Status);
    }

    //delete the file corresponding to this checkpoint
    Status = CpckDeleteCryptoFile(Resource, Context.dwId, NULL);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteCryptoCheckpoint - couldn't delete checkpoint file , error %1!d!\n",
                   Status);
        return(Status);
    }

    return(Status);
} // CpckDeleteCryptoCheckpoint

DWORD
CpckRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    This is called when a resource is deleted to remove all the checkpoints
    and the related stuff in the registry.

Arguments:

    Resource - supplies the resource 

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status;

    //delete all the checkpoints corresponding to this resource
    Status = CpckDeleteCryptoFile(Resource, 0, NULL);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckRemoveResourceCheckpoints, CpckDeleteCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    

FnExit:
    return(Status);
} // CpckRemoveResourceCheckpoints


BOOL
CpckDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_DEL_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for deleting an old registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (memcmp(ValueData, Context->pbInfo, Context->cbInfo) == 0) {
        //
        // Found a match
        //
        Context->dwId = wcstol(ValueName, NULL, 16);  // skip past the 'Crypto' prefix
        return(FALSE);
    }
    return(TRUE);
} // CpckDeleteCheckpointCallback


DWORD
CpckGetCryptoCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Retrieves a list of the resource's crypto checkpoints

Arguments:

    Resource - Supplies the resource whose crypto checkpoints should be retrieved.

    OutBuffer - Supplies a pointer to the output buffer.

    OutBufferSize - Supplies the size (in bytes) of the output buffer.

    BytesReturned - Returns the number of bytes written to the output buffer.

    Required - Returns the number of bytes required. (if the output buffer was insufficient)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPCK_GET_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY CryptoSyncKey;
    DWORD Status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);

    if (ResourceKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckGetCryptoCheckpoints - couldn't open Resource key. error %1!d!\n",
                      Status);
        return(Status);
    }

    //
    // Open up the CryptoSync key
    //
    CryptoSyncKey = DmOpenKey(ResourceKey,
                           L"CryptoSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (CryptoSyncKey == NULL) {
        //
        // No reg sync key, therefore there are no subtrees
        //
        return(ERROR_SUCCESS);
    }

    Context.cCheckpoints = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    Context.cbRequired = sizeof(WCHAR);
    if (OutBufferSize < sizeof(WCHAR) * 2)
    {
        Context.fNeedMoreData = TRUE;
        Context.cbAvailable = 0;
        *BytesReturned = 0;
    }
    else
    {
        Context.fNeedMoreData = FALSE;
        Context.cbAvailable = OutBufferSize - sizeof(WCHAR);
        Context.pbOutput = (BYTE*)(OutBuffer);
        *BytesReturned = sizeof(WCHAR) * 2;
    }

    DmEnumValues(CryptoSyncKey,
                 CpckGetCheckpointsCallback,
                 &Context);

    DmCloseKey(CryptoSyncKey);

    if ((0 != Context.cCheckpoints) && Context.fNeedMoreData) {
        Status = ERROR_MORE_DATA;
    } else {
        Status = ERROR_SUCCESS;
    }

    if ( 0 == Context.cCheckpoints ) {
        *BytesReturned = 0;
        *Required = 0;
    } else {
        if ( Context.fNeedMoreData ) {
            *Required = Context.cbRequired;
        } else {
            *BytesReturned = (DWORD)(Context.pbOutput - OutBuffer);
        }
    }


    return(Status);
} // CpckGetCryptoCheckpoints

BOOL
CpckGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPCK_GET_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for retrieving all of a resource's
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

--*/

{
    Context->cbRequired += ValueSize;
    Context->cCheckpoints++;
    if (Context->cbAvailable >= ValueSize) {
        CopyMemory(Context->pbOutput, ValueData, ValueSize);
        Context->pbOutput += ValueSize;
        Context->cbAvailable -= ValueSize;
    } else {
        Context->fNeedMoreData = TRUE;
    }
    return(TRUE);
} // CpckGetCheckpointsCallback

DWORD
CpckGenSymKey(
    IN HCRYPTPROV hProv,
    IN BYTE *pbSalt,
    IN BYTE *pbIV,
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo,
    IN DWORD dwKeyLength,   OPTIONAL
    IN DWORD dwEffectiveKeyLength,  OPTIONAL
    OUT HCRYPTKEY *phSymKey
    )

/*++

Routine Description:

    Generate a session key based on the specified Salt and IV.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pbSalt - Salt value

    pbIV - IV value

    pCryptoKeyInfo - Crypto key related information.

    dwKeyLength - Key length to be used to generate the session key.    OPTIONAL

    dwEffectiveKeyLength - Effective key length to be used to generate the session key. OPTIONAL

    phSymKey - Resulting symmetric key (CALG_RC2)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    HCRYPTHASH      hHash = 0;
    DWORD           cbPassword = 0;
    DWORD           Status;

    if (!CryptCreateHash(hProv,
                         CALG_SHA1,
                         0,
                         0,
                         &hHash))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (!CryptHashData(hHash,
                       pbSalt,
                       SALT_SIZE,
                       0))
    {
        Status = GetLastError();
        goto Ret;
    }

    if ( ( dwKeyLength == 0 ) || ( dwEffectiveKeyLength == 0 ) )
    {
        //
        //  Get the RC2 key length and effective key length to be used for generating the
        //  session key. These are the values used by W2K. Thus, we want to ensure that session keys
        //  generated at W2K can import the data exported by Windows Server 2003 side and vice versa.
        //
        if ( !CpckGetKeyLength ( pCryptoKeyInfo, &dwKeyLength, &dwEffectiveKeyLength ) )
        {
            Status = GetLastError();
            goto Ret;
        }
    }
    
    // derive the key from the hash
    if (!CryptDeriveKey(hProv,
                        CALG_RC2,
                        hHash,
                        dwKeyLength << 16,    // Set key length. Don't rely on default that changes between OS versions.
                        phSymKey))
    {
        Status = GetLastError();
        goto Ret;
    }

    // set the IV on the key
    if (!CryptSetKeyParam(*phSymKey,
                          KP_IV,
                          pbIV,
                          0))
    {
        Status = GetLastError();
        goto Ret;
    }

    //
    // Set the effective key length on the key. Don't rely on default that changes between OS versions.
    //
    if (!CryptSetKeyParam(*phSymKey,
                          KP_EFFECTIVE_KEYLEN,
                          (PBYTE)&dwEffectiveKeyLength,
                          0))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (hHash)
        CryptDestroyHash(hHash);

    return (Status);
} // CpckGenSymKey

DWORD
CpckExportPrivateKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN BYTE *pbIV,
    IN BYTE *pbSalt,
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo,
    OUT BYTE *pbExportedKey,
    OUT DWORD *pcbExportedKey
    )

/*++

Routine Description:

    Exports the private key data.

Arguments:

    hProv - Handle to the crypto provider (key container)

    hKey - Handle to the key to export

    pbIV - IV for the symmetric key

    pbSalt - Salt to generate symmetric key

    pCryptoKeyInfo - Crypto key related information.

    pbExportedKey - Supplies the buffer the key is to be exported into

    pcbExportedKey - Supplies the length of the buffer, if pbExportedKey is
                     NULL then this will be the length of the key to export

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    HCRYPTKEY hSymKey = 0;
    DWORD Status;

    // create the symmetric key to encrypt the private key with
    Status = CpckGenSymKey(hProv,
                           pbSalt,
                           pbIV,
                           pCryptoKeyInfo,
                           0,
                           0,
                           &hSymKey);
    if (0 != Status)
    {
        goto Ret;
    }


    // Export the key
    if (!CryptExportKey(hKey,
                        hSymKey,
                        PRIVATEKEYBLOB,
                        0,
                        pbExportedKey,
                        pcbExportedKey))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (hSymKey)
        CryptDestroyKey(hSymKey);

    return (Status);
} // CpckExportPrivateKey


DWORD
CpckGetKeyContainerSecDescr(
    IN HCRYPTPROV hProv,
    OUT PSECURITY_DESCRIPTOR *ppSecDescr,
    OUT DWORD *pcbSecDescr
    )
/*++

Routine Description:

    Gets the key container security descriptor so that when replicated
    the same descriptor may be set on the replicated key.

Arguments:

    hProv - Handle to the crypto provider (key container)

    ppSecDescr - Pointer to buffer holding security descriptor

    pcbSecDescr - Pointer to the length of the returned security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PTOKEN_PRIVILEGES pPrevPriv = NULL;
    DWORD cbPrevPriv = 0;
    BYTE rgbNewPriv[ sizeof( TOKEN_PRIVILEGES ) + ( 2 * sizeof( LUID_AND_ATTRIBUTES )) ];
    PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    HANDLE hThreadToken = 0;
    PSECURITY_DESCRIPTOR pNewSD = NULL;
    DWORD dw;
    DWORD dwFlags;
    DWORD Status = ERROR_SUCCESS;
    BOOLEAN threadHasNoToken = TRUE;

    //
    // if we already have a thread token, use it for adjusting the privs
    //
    if (FALSE == OpenThreadToken(GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                 TRUE,
                                 &hThreadToken))
    {
        HANDLE hProcToken;
        BOOL success;

        //
        // no thread token; dup the process token for eventual assignment to
        // our thread. This way, privileges are enabled at the thread level
        // instead of at the process level.
        //
        if (FALSE == OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE, &hProcToken ))
        {
            Status = GetLastError();
            goto Ret;
        }

        success = DuplicateTokenEx(hProcToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                             // token attrs - use default SD
                                   SecurityImpersonation,
                                   TokenImpersonation,
                                   &hThreadToken );

        CloseHandle(hProcToken);

        if ( !success )
        {
            Status = GetLastError();
            goto Ret;
        }
    } else {
        threadHasNoToken = FALSE;
    }

    //
    //  Adjust token privileges to enable SE_RESTORE_NAME and SE_SECURITY_NAME privileges.
    //  The former is needed since we are passing OWNER_SECURITY_INFORMATION flags to
    //  CryptGetProvParam and the latter is needed since we are passing SACL_SECURITY_INFORMATION
    //  flags.
    //
    memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
    pNewPriv->PrivilegeCount = 2;
    if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                              &(pNewPriv->Privileges[0].Luid)))
    {
        Status = GetLastError();
        goto Ret;
    }
    if(!LookupPrivilegeValueW(NULL, SE_RESTORE_NAME,
                              &(pNewPriv->Privileges[1].Luid)))
    {
        Status = GetLastError();
        goto Ret;
    }

    pNewPriv->Privileges[0].Attributes = pNewPriv->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
    // get the length of the previous state
    AdjustTokenPrivileges(hThreadToken,
                          FALSE,
                          (PTOKEN_PRIVILEGES)pNewPriv,
                          sizeof(dw),
                          (PTOKEN_PRIVILEGES)&dw,
                          &cbPrevPriv);

    // alloc for the previous state
    if (NULL == (pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,
                                                           cbPrevPriv)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // adjust the privileges and get the previous state
    if (!AdjustTokenPrivileges(hThreadToken,
                               FALSE,
                               pNewPriv,
                               cbPrevPriv,
                               (PTOKEN_PRIVILEGES)pPrevPriv,
                               &cbPrevPriv))
    {
        Status = GetLastError();
        goto Ret;
    }

    if ( threadHasNoToken ) {
        if ( FALSE == SetThreadToken( NULL, hThreadToken )) {
            Status = GetLastError();
            goto Ret;
        }
    }

    dwFlags = OWNER_SECURITY_INFORMATION | 
              GROUP_SECURITY_INFORMATION | 
              DACL_SECURITY_INFORMATION  |
              SACL_SECURITY_INFORMATION ;

    // get the security descriptor
    if (CryptGetProvParam(hProv,
                           PP_KEYSET_SEC_DESCR,
                           NULL,
                           pcbSecDescr,
                           dwFlags))
    {
        if (NULL != (*ppSecDescr =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT,
                                             *pcbSecDescr)))
        {
            if (!CryptGetProvParam(hProv,
                                   PP_KEYSET_SEC_DESCR,
                                   (BYTE*)(*ppSecDescr),
                                   pcbSecDescr,
                                   dwFlags))
            {
                Status = GetLastError();
            }
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        Status = GetLastError();
    }

    //
    // revert back to previous privilege level
    //
    if ( threadHasNoToken ) {
        if ( FALSE == SetThreadToken( NULL, NULL )) {
            Status = GetLastError();
            goto Ret;
        }
    } else {
        if (!AdjustTokenPrivileges(hThreadToken,
                                   FALSE,
                                   pPrevPriv,
                                   0,
                                   NULL,
                                   NULL))
        {
            Status = GetLastError();
            goto Ret;
        }
    }

    //
    // bail if we encountered any errors while getting SD info
    //
    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    // ge the control on the security descriptor to check if self relative
    if (!GetSecurityDescriptorControl(*ppSecDescr, 
                                      &Control,
                                      &dwRevision))
    {
        Status = GetLastError();
        goto Ret;
    }

    // if not self relative then make a self relative copy
    if (!(SE_SELF_RELATIVE & Control))
    {
        if (NULL == (pNewSD =
            (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_ZEROINIT,
                                             *pcbSecDescr)))
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        if (!MakeSelfRelativeSD(*ppSecDescr,
                                pNewSD,
                                pcbSecDescr))
        {
            Status = GetLastError();
            goto Ret;
        }
        LocalFree(*ppSecDescr);
        *ppSecDescr = (BYTE*)pNewSD;
        pNewSD = NULL;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pPrevPriv)
        LocalFree(pPrevPriv);

    if (pNewSD)
        LocalFree(pNewSD);

    if (hThreadToken)
        CloseHandle(hThreadToken);

    return Status;
} // CpckGetKeyContainerSecDescr

DWORD
CpckStoreKeyContainer(
    IN HCRYPTPROV hProv,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPWSTR TempFile
    )
/*++

Routine Description:

    Writes the key container associated with the provider handle to a
    the specified file.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pCryptoKeyInfo - Crypto key information (password if given)

    TempFile - Supplies the file which the key data is to be written to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    CRYPTO_KEY_FILE_DATA KeyFileData;
    HCRYPTKEY hSigKey = 0;
    HCRYPTKEY hExchKey = 0;
    BYTE *pb = NULL;
    DWORD cb = 0;
    DWORD dwBytesWritten;
    QfsHANDLE  hFile = QfsINVALID_HANDLE_VALUE;
    DWORD dwPermissions = 0;
    DWORD cbPermissions ;
    PSECURITY_DESCRIPTOR pSecDescr = NULL;
    DWORD cbSecDescr;
    DWORD Status;

    memset(&KeyFileData, 0, sizeof(KeyFileData));

    // generate the necessary random data for salt and IVs.
    // calls with the sig IV buffer but this will fill the
    // exch IV and Salt as well since the buffer len is 32
    if (!CryptGenRandom(hProv,
                        sizeof(struct _CRYPTO_KEY_FILE_INITIALIZATION_DATA),
                        KeyFileData.rgbSigIV))
    {
        Status = GetLastError();
        goto Ret;
    }
    KeyFileData.dwVersion = CRYPTO_KEY_FILE_DATA_VERSION;

    // calculate the length of key data
    cb = sizeof(KeyFileData);

    // get the self relative security descriptor
    Status = CpckGetKeyContainerSecDescr(hProv,
                                         &pSecDescr,
                                         &cbSecDescr);
    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }
    cb += cbSecDescr;

    // get sig key length if necessary
    if (CryptGetUserKey(hProv, AT_SIGNATURE, &hSigKey))
    {
        // check if key is exportable
        cbPermissions = sizeof(DWORD);
        if (!CryptGetKeyParam(hSigKey,
                              KP_PERMISSIONS,
                              (BYTE*)&dwPermissions,
                              &cbPermissions,
                              0))
        {
            Status = GetLastError();
            goto Ret;
        }
        if (!(dwPermissions & CRYPT_EXPORT))
        {
            Status = (DWORD)NTE_BAD_KEY;
            goto Ret;
        }

        // get the sig key length
        Status = CpckExportPrivateKey(hProv,
                                      hSigKey,
                                      KeyFileData.rgbSigIV,
                                      KeyFileData.rgbSalt,
                                      pCryptoKeyInfo,
                                      NULL,
                                      &(KeyFileData.cbSig));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbSig;
    }

    // get key exchange key length if necessary
    if (CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hExchKey))
    {
        // check if key is exportable
        dwPermissions = 0;
        cbPermissions = sizeof(DWORD);
        if (!CryptGetKeyParam(hExchKey,
                              KP_PERMISSIONS,
                              (BYTE*)&dwPermissions,
                              &cbPermissions,
                              0))
        {
            Status = GetLastError();
            goto Ret;
        }
        if (!(dwPermissions & CRYPT_EXPORT))
        {
            Status = (DWORD)NTE_BAD_KEY;
            goto Ret;
        }

        // get the exchange key length
        Status = CpckExportPrivateKey(hProv,
                                      hExchKey,
                                      KeyFileData.rgbExchIV,
                                      KeyFileData.rgbSalt,
                                      pCryptoKeyInfo,
                                      NULL,
                                      &(KeyFileData.cbExch));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbExch;
    }

    // allocate space for the keys
    if (NULL == (pb = LocalAlloc(LMEM_ZEROINIT, cb)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // copy the key file data into the pb
    cb = sizeof(KeyFileData);

    // copy the signature key
    if (0 != hSigKey)
    {
        Status = CpckExportPrivateKey(hProv,
                                      hSigKey,
                                      KeyFileData.rgbSigIV,
                                      KeyFileData.rgbSalt,
                                      pCryptoKeyInfo,
                                      pb + cb,
                                      &(KeyFileData.cbSig));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbSig;
    }
    // copy the key exchange key
    if (0 != hExchKey)
    {
        Status = CpckExportPrivateKey(hProv,
                                      hExchKey,
                                      KeyFileData.rgbExchIV,
                                      KeyFileData.rgbSalt,
                                      pCryptoKeyInfo,
                                      pb + cb,
                                      &(KeyFileData.cbExch));
        if (0 != Status)
        {
            goto Ret;
        }
        cb += KeyFileData.cbExch;
    }

    // copy the security descriptor
    CopyMemory(pb + cb, (BYTE*)pSecDescr, cbSecDescr);
    cb += cbSecDescr;

    // copy the lengths
    CopyMemory(pb, &KeyFileData, sizeof(KeyFileData));

    // write the buffer to the file
    hFile = QfsCreateFile(TempFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if ( !QfsIsHandleValid(hFile) )
    {
        Status = GetLastError();
        goto Ret;
    }

    if (!QfsWriteFile(hFile, pb, cb, &dwBytesWritten, NULL))
    {
        Status = GetLastError();
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pSecDescr)
        LocalFree(pSecDescr);
    QfsCloseHandleIfValid(hFile);
    if (pb)
        LocalFree(pb);
    if (hSigKey)
        CryptDestroyKey(hSigKey);
    if (hExchKey)
        CryptDestroyKey(hExchKey);

    return (Status);
} // CpckStoreKeyContainer


DWORD
CpckSaveCheckpointToFile(
    IN HCRYPTPROV hProv,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo,
    IN LPWSTR   TempFile)
/*++

Routine Description:

    have DM create a temp file and call the routine that exports the keys and
    writes the checkpoint file.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pCryptoKeyInfo - Crypto key information (password if given)

    TempFile - Supplies the file which the key data is to be written to

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD   Status;
    
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        TempFile[0] = L'\0';
        return(Status);
    }

    // put the key information into the file
    Status = CpckStoreKeyContainer(hProv, pCryptoKeyInfo, TempFile);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckSaveCheckpointToFile failed to get store container %1!ws! %2!ws! to file %3!ws! error %4!d!\n",
                   pCryptoKeyInfo->pwszContainer,
                   pCryptoKeyInfo->pwszProvName,
                   TempFile,
                   Status);
        CL_LOGFAILURE(Status);
        QfsDeleteFile(TempFile);
        TempFile[0] = L'\0';
    }        

    return(Status);
} // CpckSaveCheckpointToFile


DWORD
CpckCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HCRYPTPROV hProv,
    IN DWORD dwId,
    IN CRYPTO_KEY_INFO *pCryptoKeyInfo
    )
/*++

Routine Description:

    Takes a checkpoint of the specified crypto key.

Arguments:

    Resource - Supplies the resource this is a checkpoint for.

    hKey - Supplies the crypto info to checkpoint

    dwId - Supplies the checkpoint ID.

    KeyName - Supplies the name of the registry key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR TempFile[MAX_PATH];

    Status = CpckSaveCheckpointToFile(hProv, pCryptoKeyInfo, TempFile);
    if (Status == ERROR_SUCCESS)
    {
        //
        // Got a file with the right bits in it. Checkpoint the
        // file.
        //
        Status = CpSaveDataFile(Resource,
                                dwId,
                                TempFile,
                                TRUE);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CPCK] CpckCheckpoint - CpSaveData failed %1!d!\n",
                       Status);
        }
    }
    //if the file was created, delete it
    if (TempFile[0] != L'\0')
        QfsDeleteFile(TempFile);

    return(Status);
} // CpckCheckpoint

DWORD
CpckSetKeyContainerSecDescr(
    IN HCRYPTPROV hProv,
    IN BYTE *pbSecDescr,
    IN DWORD cbSecDescr
    )
/*++

Routine Description:

    Sets the key container security descriptor.

Arguments:

    hProv - Handle to the crypto provider (key container)

    pbSecDescr - Buffer holding security descriptor

    cbSecDescr - Length of the security descriptor

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PTOKEN_PRIVILEGES pPrevPriv = NULL;
    DWORD cbPrevPriv = 0;
    BYTE rgbNewPriv[ sizeof( TOKEN_PRIVILEGES ) + ( 2 * sizeof( LUID_AND_ATTRIBUTES )) ];
    PTOKEN_PRIVILEGES pNewPriv = (PTOKEN_PRIVILEGES)rgbNewPriv;
    HANDLE hThreadToken = 0;
    DWORD dw;
    DWORD dwFlags;
    DWORD Status = ERROR_SUCCESS;
    BOOLEAN threadHasNoToken = TRUE;

    //
    // if we already have a thread token, use it for adjusting the privs
    //
    if (FALSE == OpenThreadToken(GetCurrentThread(),
                                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                 TRUE,
                                 &hThreadToken))
    {
        HANDLE hProcToken;
        BOOL success;

        //
        // no thread token; dup the process token for eventual assignment to
        // our thread. This way, privileges are enabled at the thread level
        // instead of at the process level.
        //
        if (FALSE == OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE, &hProcToken ))
        {
            Status = GetLastError();
            goto Ret;
        }

        success = DuplicateTokenEx(hProcToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                             // token attrs - use default SD
                                   SecurityImpersonation,
                                   TokenImpersonation,
                                   &hThreadToken );

        CloseHandle(hProcToken);

        if ( !success )
        {
            Status = GetLastError();
            goto Ret;
        }
    } else {
        threadHasNoToken = FALSE;
    }

    //
    //  Adjust token privileges to enable SE_RESTORE_NAME and SE_SECURITY_NAME privileges.
    //  The former is needed since we are passing OWNER_SECURITY_INFORMATION flags to
    //  CryptSetProvParam and the latter is needed since we are passing SACL_SECURITY_INFORMATION
    //  flags.
    //
    memset(rgbNewPriv, 0, sizeof(rgbNewPriv));
    pNewPriv->PrivilegeCount = 2;
    if(!LookupPrivilegeValueW(NULL, SE_SECURITY_NAME,
                              &(pNewPriv->Privileges[0].Luid)))
    {
        Status = GetLastError();
        goto Ret;
    }
    if(!LookupPrivilegeValueW(NULL, SE_RESTORE_NAME,
                              &(pNewPriv->Privileges[1].Luid)))
    {
        Status = GetLastError();
        goto Ret;
    }

    pNewPriv->Privileges[0].Attributes = pNewPriv->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    // get the length of the previous state
    AdjustTokenPrivileges(hThreadToken,
                          FALSE,
                          (PTOKEN_PRIVILEGES)pNewPriv,
                          sizeof(dw),
                          (PTOKEN_PRIVILEGES)&dw,
                          &cbPrevPriv);

    // alloc for the previous state
    if (NULL == (pPrevPriv = (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT,
                                                           cbPrevPriv)))
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // adjust the privileges and get the previous state
    if ( !AdjustTokenPrivileges(hThreadToken,
                                FALSE,
                                pNewPriv,
                                cbPrevPriv,
                                (PTOKEN_PRIVILEGES)pPrevPriv,
                                &cbPrevPriv))
    {
        Status = GetLastError();
        goto Ret;
    }

    if ( threadHasNoToken ) {
        if ( FALSE == SetThreadToken( NULL, hThreadToken )) {
            Status = GetLastError();
            goto Ret;
        }
    }

    dwFlags = OWNER_SECURITY_INFORMATION | 
              GROUP_SECURITY_INFORMATION | 
              DACL_SECURITY_INFORMATION  |
              SACL_SECURITY_INFORMATION ;

    // get the security descriptor
    if (!CryptSetProvParam(hProv,
                           PP_KEYSET_SEC_DESCR,
                           pbSecDescr,
                           dwFlags))
    {
        Status = GetLastError();
    }

    //
    // revert back to previous privilege level
    //
    if ( threadHasNoToken ) {
        if ( FALSE == SetThreadToken( NULL, NULL )) {
            Status = GetLastError();
            goto Ret;
        }
    } else {
        if (!AdjustTokenPrivileges(hThreadToken,
                                   FALSE,
                                   pPrevPriv,
                                   0,
                                   NULL,
                                   NULL))
        {
            Status = GetLastError();
            goto Ret;
        }
    }

    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if (pPrevPriv)
        LocalFree(pPrevPriv);

    if (hThreadToken)
        CloseHandle(hThreadToken);

    return Status;
} // CpCkSetKeyContainerSecDescr


DWORD
CpckImportPrivateKey(
     IN HCRYPTPROV hProv,
     IN BYTE *pbIV,
     IN BYTE *pbSalt,
     IN BYTE *pbKey,
     IN DWORD cbKey,
     IN PCRYPTO_KEY_INFO pCryptoKeyInfo
    )
/*++

Routine Description:

    Exports the private key data.

Arguments:

    hProv - Handle to the crypto provider (key container)

    hKey - Handle to the key to export

    pbIV - IV for the symmetric key

    pbSalt - Salt to generate symmetric key

    pbKey - Supplies the buffer the key is in

    cbKey - Supplies the length of the key buffer

    pCryptoKeyInfo - Crypto key related information.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOLEAN                 WasEnabled;
    HCRYPTKEY               hSymKey = 0;
    HCRYPTKEY               hKey = 0;
    DWORD                   Status = ERROR_SUCCESS;

    //
    //  Create the symmetric key to encrypt the private key with
    //
    Status = CpckGenSymKey(hProv,
                           pbSalt,
                           pbIV,
                           pCryptoKeyInfo,
                           0,
                           0,
                           &hSymKey);
    if (0 != Status)
    {
        goto Ret;
    }

    //
    // Import the key
    //
    if (!CryptImportKey(hProv,
                        pbKey,
                        cbKey,
                        hSymKey,
                        CRYPT_EXPORTABLE,
                        &hKey))
    {
        //
        //  If failed then try with BACKUP/RESTORE privilege enabled
        //
        Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                            &WasEnabled);

        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL, "[CPCK] CpckImportPrivateKey: Failed to enable thread privilege, status %1!d!\n",
                          Status);
            goto Ret;
        }
       
        if (!CryptImportKey(hProv,
                            pbKey,
                            cbKey,
                            hSymKey,
                            CRYPT_EXPORTABLE,
                            &hKey))
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[CPCK] CpckImportPrivateKey: Failed to import key for provider %1!ws!, status %2!d!\n",
                          pCryptoKeyInfo->pwszProvName,
                          GetLastError());

            if ( hSymKey )
            {
                CryptDestroyKey( hSymKey );
                hSymKey = 0;
            }

            //
            //  If the key was unable to be imported even after enabling the restore privilege,
            //  give the import a last chance by specifying the key lengths to be 40 bits. This
            //  retry is necessary since the Windows Server 2003 RC1 already had a bug by which
            //  it exported the keys with these parameters. To import those keys, this is the only
            //  way out.
            //
            Status = CpckGenSymKey(hProv,
                                   pbSalt,
                                   pbIV,
                                   pCryptoKeyInfo,
                                   40,
                                   40,
                                   &hSymKey);

            if (Status != ERROR_SUCCESS)
            {
                goto Ret;
            }

            //
            //  Import the key with 40 bit key lengths
            //
            if (!CryptImportKey(hProv,
                                pbKey,
                                cbKey,
                                hSymKey,
                                CRYPT_EXPORTABLE,
                                &hKey))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, "[CPCK] CpckImportPrivateKey: Failed to import key for provider %1!ws! with 40 bit session key lengths, status %2!d!\n",
                              pCryptoKeyInfo->pwszProvName,
                              Status);
            }
        }
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    } 
    
Ret:
    if (hSymKey)
        CryptDestroyKey(hSymKey);
    if (hKey)
        CryptDestroyKey(hKey);

    return (Status);
} // CpckImportPrivateKey



DWORD
CpckInstallKeyContainer(
    IN HCRYPTPROV hProv,
    IN LPWSTR   FileName,
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo
    )
/*++

Routine Description:

    Installs new crypto key information from a specified file.

Arguments:

    hProv - Supplies the provider handle where FileName will be installed to.

    FileName - The name of the file from which to read the crypto key info
               to install.

   pCryptoKeyInfo - Crypto key related information.

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    HANDLE hMap = NULL;
    BYTE *pbFile = NULL;
    QfsHANDLE hFile = QfsINVALID_HANDLE_VALUE;
    DWORD cbFile = 0;
    DWORD *pdwVersion;
    CRYPTO_KEY_FILE_DATA *pKeyFileData;
    DWORD Status;

    // read the key data from the file
    hFile = QfsCreateFile(FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);
    if (!QfsIsHandleValid(hFile) )
    {
        Status = GetLastError();
        goto Ret;
    }

    if (0xFFFFFFFF == (cbFile = QfsGetFileSize(hFile, NULL)))
    {
        Status = GetLastError();
        goto Ret;
    }
    if (sizeof(CRYPTO_KEY_FILE_DATA) > cbFile)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }
 
    if (NULL == (hMap = QfsCreateFileMapping(hFile, NULL, PAGE_READONLY,
                                          0, 0, NULL)))
    {
        Status = GetLastError();
        goto Ret;
    }

    if (NULL == (pbFile = (BYTE*)MapViewOfFile(hMap, FILE_MAP_READ,
                                               0, 0, 0 )))
    {
        Status = GetLastError();
        goto Ret;
    }

    // get the length information out of the file
    pKeyFileData = (CRYPTO_KEY_FILE_DATA*)pbFile;
    if (CRYPTO_KEY_FILE_DATA_VERSION != pKeyFileData->dwVersion)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }
    if ((sizeof(CRYPTO_KEY_FILE_DATA) + pKeyFileData->cbSig +
         pKeyFileData->cbExch) > cbFile)
    {
        Status = ERROR_FILE_INVALID;
        goto Ret;
    }

    if (pKeyFileData->cbSig)
    {
        // import the sig key if there is one
        Status = CpckImportPrivateKey(hProv,
                                      pKeyFileData->rgbSigIV,
                                      pKeyFileData->rgbSalt,
                                      pbFile + sizeof(CRYPTO_KEY_FILE_DATA),
                                      pKeyFileData->cbSig,
                                      pCryptoKeyInfo);
        if (0 != Status)
        {
            goto Ret;
        }
    }

    if (pKeyFileData->cbExch)
    {
        // import the exch key if there is one
        Status = CpckImportPrivateKey(hProv,
                                      pKeyFileData->rgbExchIV,
                                      pKeyFileData->rgbSalt,
                                      pbFile + sizeof(CRYPTO_KEY_FILE_DATA) +
                                          pKeyFileData->cbSig,
                                      pKeyFileData->cbExch,
                                      pCryptoKeyInfo);
        if (0 != Status)
        {
            goto Ret;
        }
    }

    Status = CpckSetKeyContainerSecDescr(hProv,
                                pbFile + sizeof(CRYPTO_KEY_FILE_DATA) +
                                    pKeyFileData->cbSig + pKeyFileData->cbExch,
                                pKeyFileData->cbSecDescr);
    if (ERROR_SUCCESS != Status)
    {
        goto Ret;
    }

    Status = ERROR_SUCCESS;
Ret:
    if(pbFile)
        UnmapViewOfFile(pbFile);

    if(hMap)
        CloseHandle(hMap);

    QfsCloseHandleIfValid(hFile);

    return(Status);
} // CpckInstallKeyContainer

DWORD
CpckDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    Gets the file corresponding to the checkpoint id relative
    to the supplied path and deletes it.

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if the completed successfully

    Win32 error code otherwise.

--*/
    
{    
    DWORD   Status;
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;

    Status = CppGetCheckpointFile(Resource, dwCheckpointId,
        &pszDirectoryName, &pszFileName, lpszQuorumPath, TRUE);


    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteFile- couldnt get checkpoint file name, error %1!d!\n",
                   Status);
        goto FnExit;
    }


    if (!QfsDeleteFile(pszFileName))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CPCK] CpckDeleteFile - couldn't delete the file, error %1!d!\n",
                   Status);
        goto FnExit;                   
    }

    //
    // Now try and delete the directory.
    //
    if (!QfsRemoveDirectory(pszDirectoryName)) 
    {
        //if there is a failure, we still return success
        //because it may not be possible to delete a directory
        //when it is not empty
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CPCK] CpckDeleteFile- unable to remove directory %1!ws!, error %2!d!\n",
                      pszDirectoryName,
                      GetLastError());
    }

FnExit:
    if (pszFileName)
        LocalFree(pszFileName);
    if (pszDirectoryName)
        LocalFree(pszDirectoryName);

    return(Status);
} // CpckDeleteFile

BOOL
CpckRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    )
/*++

Routine Description:

    Registry value enumeration callback used when the quorum resource
    is changing. Deletes the specified checkpoint file from the old
    quorum directory.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the crypto info)

    ValueType - Supplies the value type (must be REG_BINARY)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the quorum change context (old path and resource)

Return Value:

    TRUE to continue enumeration

--*/

{

    DWORD Status;
    DWORD Id;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CPCK] CpckRemoveCheckpointFileCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Context->Resource));
        return(TRUE);
    }

    Status = CpckDeleteFile(Context->Resource, Id, Context->lpszPathName);
    
    return(TRUE);
} // CpckRemoveCheckpointFileCallback


DWORD
CpckDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    )
/*++

Routine Description:

    Deletes the checkpoint file corresponding the resource.
    This node must be the owner of the quorum resource

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if completed successfully

    Win32 error code otherwise.

--*/

{

    DWORD               Status = ERROR_SUCCESS;

    if (dwCheckpointId)
    {
        Status = CpckDeleteFile(Resource, dwCheckpointId, lpszQuorumPath);
    }
    else
    {
        HDMKEY              ResourceKey;
        HDMKEY              CryptoSyncKey;
        CP_CALLBACK_CONTEXT Context;

    
        //delete all checkpoints corresponding to this resource
        
        //
        // Open up the resource's key
        //
        ResourceKey = DmOpenKey(DmResourcesKey,
                                OmObjectId(Resource),
                                KEY_READ);

        if (ResourceKey == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                          "[CPCK] CpckDeleteCheckpointFile - couldn't open Resource key. error %1!d!\n",
                          Status);
            goto FnExit;
        }

        //
        // Open up the CryptoSync key
        //
        CryptoSyncKey = DmOpenKey(ResourceKey,
                               L"CryptoSync",
                               KEY_READ | KEY_WRITE);
        DmCloseKey(ResourceKey);
        if (CryptoSyncKey == NULL)
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                       "[CPCK] CpckDeleteCheckpointFile- couldn't open CryptoSync key error %1!d!\n",
                       Status);
            goto FnExit;
        }

        Context.lpszPathName = lpszQuorumPath;
        Context.Resource = Resource;

        //
        // Enumerate all the values and delete them one by one.
        //
        DmEnumValues(CryptoSyncKey,
                     CpckRemoveCheckpointFileCallback,
                     &Context);
        DmCloseKey(CryptoSyncKey);
    }

FnExit:
    return(Status);

} // CpckDeleteCheckpointFile


DWORD
CpckDeleteCryptoFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    This function removes the checkpoint file correspoinding to the
    checkpoint id for a given resource from the given directory.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszQuorumPath - Supplies the path of the cluster files on a quorum device.                    

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID  OwnerNode;
    DWORD       Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CPCK] CpckDeleteCryptoFile: removing checkpoint file for id %1!d! at quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) 
        {
            Status = CpckDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
        } 
        else
        {
            Status = CpDeleteCryptoCheckpoint(Session[OwnerNode],
                            OmObjectId(Resource),
                            dwCheckpointId,
                            lpszQuorumPath);

            //talking to an old server, cant perform this function
            //ignore the error
            if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
                Status = ERROR_SUCCESS;        
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CPCK] CpckDeleteCryptoFile: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
} // CpckDeleteCryptoFile

BOOL
CpckGetKeyLength(
    IN PCRYPTO_KEY_INFO pCryptoKeyInfo,
    OUT PDWORD          pdwKeyLength,
    OUT PDWORD          pdwEffectiveKeyLength
    )
/*++

Routine Description:

    This routine gets the key lengths for a specific provider for the RC2 algorithm. It first looks
    at the cluster private property area and if not found, it will look at the predefined table.
    
Arguments:

    pCryptoKeyInfo - Crypto key related information.

    pdwKeyLength - Key length.

    pdwEffectiveKeyLength - Effective key length.
    
Return Value:

    TRUE - Call was successful, FALSE otherwise.
    
--*/
{
    DWORD           i;
    BOOL            fStatus = FALSE;
    DWORD           dwStatus, cbKeyLengths = 0, dwStringIndex;
    LPWSTR          pmszKeyLengths = NULL;
    HDMKEY          hClusterParamsKey = NULL;

    //
    //  Look at the cluster private properties if the user specified the key lengths for
    //  the provider.
    //
    hClusterParamsKey = DmOpenKey ( DmClusterParametersKey,
                                    CLUSREG_KEYNAME_PARAMETERS,
                                    KEY_READ );

    if ( hClusterParamsKey != NULL )
    {
        dwStatus = DmQueryMultiSz( hClusterParamsKey,
                                   pCryptoKeyInfo->pwszProvName,
                                   &pmszKeyLengths,
                                   &cbKeyLengths,
                                   &cbKeyLengths );

        if ( dwStatus == ERROR_SUCCESS )
        {
            for ( dwStringIndex = 0; ; dwStringIndex++ ) 
            {
                LPCWSTR     pszKeyLength;

                pszKeyLength = ClRtlMultiSzEnum( pmszKeyLengths,
                                                 cbKeyLengths / sizeof( WCHAR ),
                                                 dwStringIndex );

                if ( pszKeyLength == NULL ) 
                {
                    break;
                }

                switch ( dwStringIndex )
                {
                    case 0:
                        *pdwKeyLength = wcstoul ( pszKeyLength, NULL, 10 );
                        break;
                        
                    case 1:
                        *pdwEffectiveKeyLength = wcstoul ( pszKeyLength, NULL, 10 );
                        fStatus = TRUE;
                        ClRtlLogPrint(LOG_NOISE, "[CPCK] CpckGetKeyLength: [From cluster property] Provider %1!ws!, key length = %2!u!, effective length = %3!u!\n",
                                      pCryptoKeyInfo->pwszProvName,
                                      *pdwKeyLength,
                                      *pdwEffectiveKeyLength);
                        goto FnExit;

                    default:
                        break;
                } // switch
            } // for
        } // if
    } // if

    //
    //  No key lengths were specified in the private properties area or there were some errors
    //  reading them. Search the table.
    //
    for ( i=0; i<RTL_NUMBER_OF ( CP_RC2_W2k_KEYLEN_TABLE ); i++ )
    {
        if ( lstrcmpi ( pCryptoKeyInfo->pwszProvName, CP_RC2_W2k_KEYLEN_TABLE[i].lpszProviderName ) == 0 )
        {
            fStatus = TRUE;
            *pdwKeyLength = CP_RC2_W2k_KEYLEN_TABLE[i].dwDefaultKeyLength;
            *pdwEffectiveKeyLength = CP_RC2_W2k_KEYLEN_TABLE[i].dwDefaultEffectiveKeyLength;
            ClRtlLogPrint(LOG_NOISE, "[CPCK] CpckGetKeyLength: [From table] Provider %1!ws!, key length = %2!u!, effective length = %3!u!\n",
                          pCryptoKeyInfo->pwszProvName,
                          *pdwKeyLength,
                          *pdwEffectiveKeyLength);
            goto FnExit;
        } // if
    } // for

    ClRtlLogPrint(LOG_CRITICAL, "[CPCK] CpckGetKeyLength: Unable to find provider %1!ws! entry in table or in cluster private props\n",
                  pCryptoKeyInfo->pwszProvName);
    
    SetLastError ( ERROR_NOT_FOUND );
    
FnExit:
    if ( hClusterParamsKey ) DmCloseKey ( hClusterParamsKey );
    LocalFree ( pmszKeyLengths );
    return ( fStatus );
} // CpckGetKeyLength
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\cpp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cpp.h

Abstract:

    Private data structures and procedure prototypes for the
    Checkpoint Manager (CP) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_CP

//global data relating to the quorum resource
#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION gQuoLock;
#else
    extern RTL_RESOURCE     gQuoLock;
#endif    

//
//  This macro validates whether the passed in ID is NULL terminated. This is needed for
//  CP RPCs since all of those pass a string declared not as [string] but as an array of WCHARs whose
//  length is declared as CLUSTER_ID_SIZE. See CpDepositCheckpoint(...) definition in clusrpc.idl 
//  for instance. Thus, there is no guarantee that the string will be NULL terminated by RPC runtime. 
//  Thus, we need to make sure hackers can't blow us away with junk data directly targetting
//  the RPC endpoint (even though we make that hard with security callbacks.). Note that we 
//  can't change the IDL definition since we will break mixed mode clusters.
//
#define CP_VALIDATE_ID_STRING( szId )                       \
{                                                           \
    if ( szId [ CLUSTER_ID_SIZE - 1 ] != UNICODE_NULL )     \
        return ( ERROR_INVALID_PARAMETER );                 \
}

typedef struct _CP_CALLBACK_CONTEXT {
    PFM_RESOURCE Resource;
    LPCWSTR lpszPathName;
    BOOL    IsChangeFileAttribute;
} CP_CALLBACK_CONTEXT, *PCP_CALLBACK_CONTEXT;

typedef struct _CP_RC2_W2k_KEYLEN_STRUCT
{
    LPCWSTR     lpszProviderName;
    DWORD       dwDefaultKeyLength;
    DWORD       dwDefaultEffectiveKeyLength;
} CP_RC2_W2k_KEYLEN_STRUCT, *PCP_RC2_W2k_KEYLEN_STRUCT;

//
// Local function prototypes
//
DWORD
CppReadCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppWriteCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppGetCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId,
    OUT OPTIONAL LPWSTR *pDirectoryName,
    OUT LPWSTR *pFileName,
    IN OPTIONAL LPCWSTR lpszQuorumDir,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CppCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HKEY hKey,
    IN DWORD dwId,
    IN LPCWSTR KeyName
    );

//
// Crypto key checkpoint interfaces
//
DWORD
CpckReplicateCryptoKeys(
    IN PFM_RESOURCE Resource
    );

BOOL
CpckRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );

//
// Registry watcher interfaces
//
DWORD
CppWatchRegistry(
    IN PFM_RESOURCE Resource
    );

DWORD
CppUnWatchRegistry(
    IN PFM_RESOURCE Resource
    );

DWORD
CppRegisterNotify(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR lpszKeyName,
    IN DWORD dwId
    );

DWORD
CppRundownCheckpoints(
    IN PFM_RESOURCE Resource
    );

DWORD
CppRundownCheckpointById(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId
    );

DWORD
CppInstallDatabase(
    IN HKEY hKey,
    IN LPWSTR   FileName
    );


BOOL
CppRemoveCheckpointFileCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCP_CALLBACK_CONTEXT Context
    );


DWORD CppDeleteCheckpointFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD
CpckDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    );
    
DWORD CppDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD CpckDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD
CpckDeleteCryptoFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

error_status_t
CppDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData,
    BOOLEAN fCryptoCheckpoint
    );

error_status_t
CppRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BOOLEAN fCryptoCheckpoint,
    BYTE_PIPE CheckpointData
    );

error_status_t
CppDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath,
    BOOL        fCryptoCheckpoint
    );

BOOL
CppIsQuorumVolumeOffline(
    VOID
    );

extern CRITICAL_SECTION CppNotifyLock;
extern LIST_ENTRY CpNotifyListHead;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Interfaces for registering and deregistering registry checkpoint
    handlers.

Author:

    John Vert (jvert) 1/16/1997

Revision History:

--*/
#include "cpp.h"

//
// Local type and structure definitions
//
typedef struct _CPP_ADD_CONTEXT {
    BOOL Found;
    LPCWSTR KeyName;
} CPP_ADD_CONTEXT, *PCPP_ADD_CONTEXT;

typedef struct _CPP_DEL_CONTEXT {
    DWORD dwId;
    LPCWSTR KeyName;
} CPP_DEL_CONTEXT, *PCPP_DEL_CONTEXT;

typedef struct _CPP_GET_CONTEXT {
    DWORD Available;
    DWORD Required;
    LPWSTR lpOutput;
} CPP_GET_CONTEXT, *PCPP_GET_CONTEXT;

//
// Local function prototypes
//
BOOL
CppWatchCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    );

BOOL
CppAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_ADD_CONTEXT Context
    );

BOOL
CppDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_DEL_CONTEXT Context
    );

BOOL
CppGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_GET_CONTEXT Context
    );


DWORD
CppWatchRegistry(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Restores any registry checkpoints for this resource and begins
    watching the registry for any further modifications.

Arguments:

    Resource - Supplies the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ);
    DmCloseKey(ResourceKey);
    if (RegSyncKey != NULL) {

        DmEnumValues(RegSyncKey,
                     CppWatchCallback,
                     Resource);
        DmCloseKey(RegSyncKey);
    }

    return(ERROR_SUCCESS);
}


BOOL
CppWatchCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Value enumeration callback for watching a resource's registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Resource - Supplies the resource this value is a registry checkpoint for

Return Value:

    TRUE to continue enumeration

--*/

{
    HKEY hKey;
    DWORD Id;
    DWORD Status;
    DWORD Disposition;
    WCHAR TempFile[MAX_PATH];
    BOOLEAN WasEnabled;

    Id = wcstol(ValueName, NULL, 16);
    if (Id == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppWatchCallback invalid checkpoint ID %1!ws! for resource %2!ws!\n",
                   ValueName,
                   OmObjectName(Resource));
        return(TRUE);
    }

    //
    // Attempt to create the specified registry key.
    //
    Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                             ValueData,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hKey,
                             &Disposition);
    if (Status != ERROR_SUCCESS) {
        //
        // For some reason we could not open the key. Try again with restore
        // privilege. Note that this will not work if the key does not exist.
        // Not much we can do in that case.
        //
        Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           &WasEnabled);
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
               "[CP] CppWatchCallback - ClRtlEnableThreadPrivilege failed with Status %1!u!\n",
               Status);
            return(TRUE);
        }
                           
        Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               ValueData,
                               REG_OPTION_BACKUP_RESTORE,
                               KEY_WRITE,
                               &hKey);
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);

                           
    }

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWatchCallback: could not create key %1!ws! error %2!d!\n",
                   ValueData,
                   Status);
        return(TRUE);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppWatchCallback retrieving checkpoint id %1!lx! for resource %2!ws\n",
               Id,
               OmObjectName(Resource));
    //
    // See if there is any checkpoint data for this ID.
    //
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }
    Status = CpGetDataFile(Resource,
                           Id,
                           TempFile,
                           FALSE);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppWatchCallback - CpGetDataFile for id %1!lx! resource %2!ws! failed %3!d!\n",
                   Id,
                   OmObjectName(Resource),
                   Status);
    } else {

        //
        // Finally install the checkpointed file into the registry.
        //
        Status = CppInstallDatabase(hKey,
                                    TempFile);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWatchCallback: could not restore temp file %1!ws! to key %2!ws! error %3!d!\n",
                       TempFile,
                       ValueData,
                       Status);
            CsLogEventData2(LOG_CRITICAL,
                            CP_REG_CKPT_RESTORE_FAILED,
                            sizeof(Status),
                            &Status,
                            OmObjectName(Resource),
                            ValueData);
        }

    }
    QfsDeleteFile(TempFile);
    RegCloseKey(hKey);

    //
    // Install the registry watcher for this checkpoint
    //
    Status = CppRegisterNotify(Resource,
                               ValueData,
                               Id);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWatchRegistry - CppRegisterNotify failed for key %1!ws! %1!d!\n",
                   ValueData,
                   Status);
    }

    return(TRUE);
}


DWORD
CpAddRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Adds a new registry checkpoint to a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_ADD_CONTEXT Context;
    HDMKEY  ResourceKey = NULL;
    HDMKEY  RegSyncKey = NULL;
    DWORD   Disposition;
    DWORD   Id;
    WCHAR   IdName[9];
    DWORD   Status;
    HKEY    hKey = NULL;
    CLUSTER_RESOURCE_STATE State;
    BOOLEAN WasEnabled;
    DWORD   Count=60;
    HKEY    hKeyOpen = NULL;


    //
    // Reject all callers that believe they can checkpoint the Cluster hive or anything under it.
    //
    if ( _wcsnicmp( KeyName, CLUSREG_KEYNAME_CLUSTER, RTL_NUMBER_OF ( CLUSREG_KEYNAME_CLUSTER ) - 1  ) == 0 ) 
    {
        Status = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[CP] CpAddRegistryCheckpoint: Invalid key name %1!ws! supplied for resource %2!ws!, status %3!u!\n",
                      KeyName,
                      OmObjectName(Resource),
                      Status);
        goto FnExit;                   
    }

    //
    // Make sure the specified key is valid.
    //  - First we try and open the key while using backup privilege.
    //    If the key exists, this will get us a handle even if our account
    //    does not have permission.
    //  - If you are using REG_OPTION_BACKUP_RESTORE and the key does not
    //    exist, a new key will not be created. So if the first create fails,
    //    we try again without REG_OPTION_BACKUP_RESTORE. This will create
    //    the key if it does not exist (and we have permission to create such
    //    a key) If the key does not exist and we cannot create they key,
    //    the checkpoint add fails.
    //
    Status = ClRtlEnableThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       &WasEnabled);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[CP] CpAddRegistryCheckpoint - ClRtlEnableThreadPrivilege failed with Status %1!u!\n",
               Status);
        goto FnExit;               

    }
    Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                             KeyName,
                             0,
                             NULL,
                             REG_OPTION_BACKUP_RESTORE,
                             KEY_READ,
                             NULL,
                             &hKey,
                             &Disposition);
    ClRtlRestoreThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       WasEnabled);
    if (Status != ERROR_SUCCESS) {
        //
        // Try again without REG_OPTION_BACKUP_RESTORE.
        //
        Status = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                 KeyName,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ,
                                 NULL,
                                 &hKey,
                                 &Disposition);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpAddRegistryCheckpoint Could not create key %1!ws! error %2!d!\n",
                       KeyName,
                       Status);
            goto FnExit;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpAddRegistryCheckpoint created new key %1!ws! for checkpointing.\n",
                       KeyName);
        }
    }

    //
    //  Chittur Subbaraman (chitturs) - 2/26/99
    //
    //  Make sure the key can be opened. Else, bail out.
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         KeyName,
                         &hKeyOpen);

    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                    "[CP] CpAddRegistryCheckpoint Could not open key %1!ws! error %2!d!\n",
                    KeyName,
                    Status);  
        goto FnExit;
    }

    if ( hKeyOpen != NULL ) {
        RegCloseKey( hKeyOpen );
    }

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
                            
    if( ResourceKey == NULL ) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint couldn't open Resource key for %1!ws! error %2!d!\n",
                   OmObjectName(Resource),
                   Status);
        goto FnExit;                   
    }

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmCreateKey(ResourceKey,
                             L"RegSync",
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &Disposition);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint couldn't create RegSync key for %1!ws! error %2!d!\n",
                   OmObjectName(Resource),
                   Status);
        goto FnExit;                   
    }
    if (Disposition == REG_OPENED_EXISTING_KEY) {
        //
        // Enumerate all the other values to make sure this key is
        // not already registered.
        //
        Context.Found = FALSE;
        Context.KeyName = KeyName;
        DmEnumValues(RegSyncKey,
                     CppAddCheckpointCallback,
                     &Context);
        if (Context.Found) {
            //
            // This checkpoint already exists.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpAddRegistryCheckpoint failing attempt to add duplicate checkpoint for %1!ws!\n",
                       KeyName);
            Status = ERROR_ALREADY_EXISTS;
            goto FnExit;
        }

        //
        // Now we need to find a unique checkpoint ID for this registry subtree.
        // Start at 1 and keep trying value names until we get to one that does
        // not already exist.
        //
        for (Id=1; ; Id++) {
            DWORD dwType;
            DWORD cbData;

            wsprintfW(IdName,L"%08lx",Id);
            cbData = 0;
            Status = DmQueryValue(RegSyncKey,
                                  IdName,
                                  &dwType,
                                  NULL,
                                  &cbData);
            if (Status == ERROR_FILE_NOT_FOUND) {
                //
                // Found a free ID.
                //
                break;
            }
        }
    } else {
        //
        // The key was just created, so this must be the only checkpoint
        // that exists.
        //
        Id = 1;
        wsprintfW(IdName, L"%08lx",Id);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CpAddRegistryCheckpoint creating new checkpoint id %1!d! for subtree %2!ws!\n",
               Id,
               KeyName);

    Status = DmSetValue(RegSyncKey,
                        IdName,
                        REG_SZ,
                        (CONST BYTE *)KeyName,
                        (lstrlenW(KeyName)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint failed to create new checkpoint id %1!d! error %2!d!\n",
                   Id,
                   KeyName);
        goto FnExit;
    }

RetryCheckpoint:
    //
    // Take the initial checkpoint
    //
    Status = CppCheckpoint(Resource,
                           hKey,
                           Id,
                           KeyName);

    //this may fail due to quorum resource being offline
    // we could do one of two things here, wait for quorum resource to
    // come online or retry
    // we retry as this may be called from the online routines of a
    //resource and we dont want to add any circular waits
    if ((Status == ERROR_ACCESS_DENIED) ||
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        if (Count--)
        {
            Sleep(1000);
            goto RetryCheckpoint;
        } 
#if DBG
        else
        {
            if (IsDebuggerPresent())
                DebugBreak();
        }        
#endif                                
        
    }

    
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpAddRegistryCheckpoint failed to take initial checkpoint for %1!ws! error %2!d!\n",
                   KeyName,
                   Status);
        goto FnExit;
    }

    //
    // If the resource is currently online, add this to the list of subtree notifications
    //

    State = FmGetResourceState(Resource, NULL, NULL);
    if ((State == ClusterResourceOnline) ||
        (State == ClusterResourceOnlinePending)) {
        Status = CppRegisterNotify(Resource,
                                   KeyName,
                                   Id);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpAddRegistryCheckpoint - CppRegisterNotify failed for key %1!ws! %1!d!\n",
                       KeyName,
                       Status);
        }
    }

FnExit:
    if (RegSyncKey) DmCloseKey(RegSyncKey);
    if (hKey) RegCloseKey(hKey);
    return(Status);
}


BOOL
CppAddCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_ADD_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for adding a new registry
    checkpoint subtrees. This is only used to see if the specified
    registry subtree is already being watched.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (lstrcmpiW(ValueData, Context->KeyName) == 0) {
        //
        // Found a match
        //
        Context->Found = TRUE;
        return(FALSE);
    }
    return(TRUE);
}


DWORD
CpDeleteRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Removes a registry checkpoint from a resource's list.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_DEL_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    DWORD Status;
    WCHAR ValueId[9];
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;
    CLUSTER_RESOURCE_STATE State;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't open RegSync key error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Enumerate all the values to find this one
    //
    Context.dwId = 0;
    Context.KeyName = KeyName;
    DmEnumValues(RegSyncKey,
                 CppDeleteCheckpointCallback,
                 &Context);
    if (Context.dwId == 0) {
        //
        // The specified tree was not found.
        //
        DmCloseKey(RegSyncKey);
        return(ERROR_FILE_NOT_FOUND);
    }

    wsprintfW(ValueId,L"%08lx",Context.dwId);
    Status = DmDeleteValue(RegSyncKey, ValueId);
    DmCloseKey(RegSyncKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't delete value %1!ws! error %2!d!\n",
                   ValueId,
                   Status);
        return(Status);
    }

    //delete the file corresponding to this checkpoint
    Status = CpDeleteCheckpointFile(Resource, Context.dwId, NULL);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpDeleteRegistryCheckpoint - couldn't delete checkpoint file , error %1!d!\n",
                   Status);
        return(Status);
    }

    //
    // Now remove the checkpoint from our watcher list
    //
    State = FmGetResourceState(Resource, NULL, NULL);
    if ((State == ClusterResourceOnline) ||
        (State == ClusterResourceOnlinePending)) {
        Status = CppRundownCheckpointById(Resource, Context.dwId);
    }

    return(Status);
}


DWORD
CpRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    This is called when a resource is deleted to remove all the checkpoints
    and the related stuff in the registry.

Arguments:

    Resource - supplies the resource the registry checkpoint should be added to.

    KeyName - Supplies the name of the registry key (relative to HKEY_LOCAL_MACHINE);

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status;

    //delete all the checkpoints corresponding to this resource
    Status = CpDeleteCheckpointFile(Resource, 0, NULL);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpRemoveResourceCheckpoints, CppDeleteCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    

FnExit:
    return(Status);
}



BOOL
CppDeleteCheckpointCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_DEL_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for deleting an old registry
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

    FALSE if a match is found and enumeration should be stopped

--*/

{
    if (lstrcmpiW(ValueData, Context->KeyName) == 0) {
        //
        // Found a match
        //
        Context->dwId = wcstol(ValueName, NULL, 16);
        return(FALSE);
    }
    return(TRUE);
}


DWORD
CpGetRegistryCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Retrieves a list of the resource's registry checkpoints

Arguments:

    Resource - Supplies the resource whose registry checkpoints should be retrieved.

    OutBuffer - Supplies a pointer to the output buffer.

    OutBufferSize - Supplies the size (in bytes) of the output buffer.

    BytesReturned - Returns the number of bytes written to the output buffer.

    Required - Returns the number of bytes required. (if the output buffer was insufficient)

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CPP_GET_CONTEXT Context;
    HDMKEY ResourceKey;
    HDMKEY RegSyncKey;
    DWORD Status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Open up the resource's key
    //
    ResourceKey = DmOpenKey(DmResourcesKey,
                            OmObjectId(Resource),
                            KEY_READ);
    CL_ASSERT(ResourceKey != NULL);

    //
    // Open up the RegSync key
    //
    RegSyncKey = DmOpenKey(ResourceKey,
                           L"RegSync",
                           KEY_READ | KEY_WRITE);
    DmCloseKey(ResourceKey);
    if (RegSyncKey == NULL) {
        //
        // No reg sync key, therefore there are no subtrees
        //
        return(ERROR_SUCCESS);
    }

    Context.Available = OutBufferSize;
    Context.Required = 0;
    Context.lpOutput = (LPWSTR)OutBuffer;

    DmEnumValues(RegSyncKey,
                 CppGetCheckpointsCallback,
                 &Context);

    DmCloseKey(RegSyncKey);

    if (Context.Available < sizeof(WCHAR)) {
        Status = ERROR_MORE_DATA;
    } else {
        if ( (PCHAR)(Context.lpOutput) - OutBuffer ) {
            *Context.lpOutput++ = L'\0';
        }
        Status = ERROR_SUCCESS;
    }

    if ( Context.Required ) {
        *Required = Context.Required + sizeof(WCHAR);
    }

    //
    // If the buffer was large enough for all the data, indicate the
    // number of bytes we are returning in the output buffer.
    //
    if ( OutBufferSize >= *Required ) {
        *BytesReturned = (DWORD)((PCHAR)(Context.lpOutput) - OutBuffer);
    }

    return(Status);
}

BOOL
CppGetCheckpointsCallback(
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PCPP_GET_CONTEXT Context
    )
/*++

Routine Description:

    Value enumeration callback for retrieving all of a resource's
    checkpoint subtrees.

Arguments:

    ValueName - Supplies the name of the value (this is the checkpoint ID)

    ValueData - Supplies the value data (this is the registry subtree)

    ValueType - Supplies the value type (must be REG_SZ)

    ValueSize - Supplies the size of ValueData

    Context - Supplies the callback context

Return Value:

    TRUE to continue enumeration

--*/

{
    Context->Required += ValueSize;
    if (Context->Available >= ValueSize) {
        CopyMemory(Context->lpOutput, ValueData, ValueSize);
        Context->lpOutput += ValueSize/sizeof(WCHAR);
        Context->Available -= ValueSize;
    } else {
        Context->Available = 0;
    }
    return(TRUE);
}

DWORD CppSaveCheckpointToFile(
    IN HKEY     hKey,
    IN LPCWSTR  KeyName,
    IN LPWSTR   TempFile)
{
    DWORD   Status;
    
    Status = DmCreateTempFileName(TempFile);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        TempFile[0] = L'\0';
        return(Status);
    }

    Status = DmGetDatabase(hKey, TempFile);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppCheckpoint failed to get registry database %1!ws! to file %2!ws! error %3!d!\n",
                   KeyName,
                   TempFile,
                   Status);
        CL_LOGFAILURE(Status);
        QfsDeleteFile(TempFile);
        TempFile[0] = L'\0';
    }        

    return(Status);
}


DWORD
CppCheckpoint(
    IN PFM_RESOURCE Resource,
    IN HKEY hKey,
    IN DWORD dwId,
    IN LPCWSTR KeyName
    )
/*++

Routine Description:

    Takes a checkpoint of the specified registry key.

Arguments:

    Resource - Supplies the resource this is a checkpoint for.

    hKey - Supplies the registry subtree to checkpoint

    dwId - Supplies the checkpoint ID.

    KeyName - Supplies the name of the registry key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR TempFile[MAX_PATH];

    Status = CppSaveCheckpointToFile(hKey, KeyName, TempFile);
    if (Status == ERROR_SUCCESS)
    {
        //
        // Got a file with the right bits in it. Checkpoint the
        // file.
        //
        Status = CpSaveDataFile(Resource,
                                dwId,
                                TempFile,
                                FALSE);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppCheckpoint - CpSaveData failed %1!d!\n",
                       Status);
        }
    }
    //if the file was created, delete it
    if (TempFile[0] != L'\0')
        QfsDeleteFile(TempFile);

    return(Status);
}



DWORD
CppInstallDatabase(
    IN HKEY hKey,
    IN LPWSTR   FileName
    )
/*++

Routine Description:

    Installs a new registry database from a specified file.

Arguments:

    hKey - Supplies the registry key where FileName will be installed to.

    FileName - The name of the file from which to read the registry database
               to install.

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    DWORD    Status;
    BOOLEAN  WasEnabled;

    //
    // Install the new registry from the file
    //
    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        return(Status);
    }
    Status = RegRestoreKeyW(hKey,
                            FileName,
                            REG_FORCE_RESTORE);
    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                       WasEnabled);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] Error installing registry database from %1!ws!, error %2!u!.\n",
                   FileName,
                   Status);
    }

    return(Status);
}


DWORD
CppDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR  lpszQuorumPath
    )
/*++

Routine Description:

    Deletes the checkpoint file corresponding the resource.
    This node must be the owner of the quorum resource

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if completed successfully

    Win32 error code otherwise.

--*/

{

    DWORD               Status;


    if (dwCheckpointId)
    {
        Status = CppDeleteFile(Resource, dwCheckpointId, lpszQuorumPath);
    }
    else
    {
        HDMKEY              ResourceKey;
        HDMKEY              RegSyncKey;
        CP_CALLBACK_CONTEXT Context;

    
        //delete all checkpoints corresponding to this resource
        
        //
        // Open up the resource's key
        //
        ResourceKey = DmOpenKey(DmResourcesKey,
                                OmObjectId(Resource),
                                KEY_READ);
        CL_ASSERT(ResourceKey != NULL);

        //
        // Open up the RegSync key
        //
        RegSyncKey = DmOpenKey(ResourceKey,
                               L"RegSync",
                               KEY_READ | KEY_WRITE);
        DmCloseKey(ResourceKey);
        if (RegSyncKey == NULL)
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppDeleteCheckpointFile- couldn't open RegSync key error %1!d!\n",
                       Status);
            goto FnExit;
        }

        Context.lpszPathName = lpszQuorumPath;
        Context.Resource = Resource;

        //
        // Enumerate all the values and delete them one by one.
        //
        DmEnumValues(RegSyncKey,
                     CppRemoveCheckpointFileCallback,
                     &Context);
        DmCloseKey(RegSyncKey);
    }

FnExit:
    return(Status);

}    

DWORD CppDeleteFile(    
    IN PFM_RESOURCE     Resource,
    IN DWORD            dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    Gets the file corresponding to the checkpoint id relative
    to the supplied path and deletes it.

Arguments:

    PFM_RESOURCE - Supplies the pointer to the resource.

    dwCheckpointId - The checkpoint id to be deleted.  If 0, all
        checkpoints are deleted.

    lpszQuorumPath - If specified, the checkpoint file relative
     to this path is deleted.        

Return Value:

    ERROR_SUCCESS if the completed successfully

    Win32 error code otherwise.

--*/
    
{    
    DWORD   Status;
    LPWSTR  pszFileName=NULL;
    LPWSTR  pszDirectoryName=NULL;

    Status = CppGetCheckpointFile(Resource, dwCheckpointId,
        &pszDirectoryName, &pszFileName, lpszQuorumPath, FALSE);


    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDeleteFile- couldnt get checkpoint file name, error %1!d!\n",
                   Status);
        goto FnExit;
    }


    if (!QfsDeleteFile(pszFileName))
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDeleteFile - couldn't delete the file %2!ws!, error %1!d!\n",
                   Status,
                   pszFileName);
        goto FnExit;                   
    }

    //
    // Now try and delete the directory.
    //
    if (!QfsRemoveDirectory(pszDirectoryName)) 
    {
        //if there is a failure, we still return success
        //because it may not be possible to delete a directory
        //when it is not empty
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppDeleteFile- unable to remove directory %1!ws!, error %2!d!\n",
                   pszDirectoryName,
                   GetLastError());
    }

FnExit:
    if (pszFileName) LocalFree(pszFileName);
    if (pszDirectoryName) LocalFree(pszDirectoryName);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\send.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.c

Abstract:

    APIs for the client side of the checkpoint manager

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"


CL_NODE_ID
CppGetQuorumNodeId(
    VOID
    )
/*++

Routine Description:

    Returns the node ID of the node owning the quorum resource.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE QuorumResource;
    DWORD Status;
    DWORD NodeId;

    Status = FmFindQuorumResource(&QuorumResource);
    if (Status != ERROR_SUCCESS) {
        return((DWORD)-1);
    }

    NodeId = FmFindQuorumOwnerNodeId(QuorumResource);
    OmDereferenceObject(QuorumResource);

    return(NodeId);
}



DWORD
CpSaveDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    This function checkpoints arbitrary data for the specified resource. The data is stored on the quorum
    disk to ensure that it survives partitions in time. Any node in the cluster may save or retrieve
    checkpointed data.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the name of the file with the checkpoint data.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID OwnerNode;
    DWORD Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpSaveData: checkpointing data id %1!d! to quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) {
            Status = CppWriteCheckpoint(Resource,
                                        dwCheckpointId,
                                        lpszFileName,
                                        fCryptoCheckpoint);
        } else {
            QfsHANDLE hFile;
            FILE_PIPE FilePipe;
            hFile = QfsCreateFile(lpszFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                0,
                                NULL);
            if (!QfsIsHandleValid(hFile)) {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                           "[CP] CpSaveData: failed to open data file %1!ws! error %2!d!\n",
                           lpszFileName,
                           Status);
            } else {
                DmInitFilePipe(&FilePipe, hFile);
                try {
                    if (fCryptoCheckpoint) {
                        Status = CpDepositCryptoCheckpoint(Session[OwnerNode],
                                                           OmObjectId(Resource),
                                                           dwCheckpointId,
                                                           FilePipe.Pipe);
                    } else {
                        Status = CpDepositCheckpoint(Session[OwnerNode],
                                                     OmObjectId(Resource),
                                                     dwCheckpointId,
                                                     FilePipe.Pipe);
                    }
                } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[CP] CpSaveData - s_CpDepositCheckpoint from node %1!d! raised status %2!d!\n",
                               OwnerNode,
                               GetExceptionCode());
                    Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
                }
                DmFreeFilePipe(&FilePipe);
                QfsCloseHandle(hFile);
            }
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpSaveData: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
}

DWORD
CpDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    )
/*++

Routine Description:

    This function removes the checkpoint file correspoinding to the
    checkpoint id for a given resource from the given directory.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszQuorumPath - Supplies the path of the cluster files on a quorum device.                    

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID  OwnerNode;
    DWORD       Status;

    do {
        OwnerNode = CppGetQuorumNodeId();
        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CpDeleteDataFile: removing checkpoint file for id %1!d! at quorum node %2!d!\n",
                    dwCheckpointId,
                    OwnerNode);
        if (OwnerNode == NmLocalNodeId) 
        {
            Status = CppDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
        } 
        else
        {
            Status = CpDeleteCheckpoint(Session[OwnerNode],
                            OmObjectId(Resource),
                            dwCheckpointId,
                            lpszQuorumPath);

            //talking to an old server, cant perform this function
            //ignore the error
            if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
                Status = ERROR_SUCCESS;                                        
        }

        if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
            //
            // This node no longer owns the quorum resource, retry.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[CP] CpSaveData: quorum owner %1!d! no longer owner\n",
                        OwnerNode);
        }
    } while ( Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER );
    return(Status);
}



DWORD
CpGetDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    This function retrieves checkpoint data for the specified resource. The data must
    have been saved by CpSaveData. Any node in the cluster may save or retrieve
    checkpointed data.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is
        responsible for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the filename where the data should be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CL_NODE_ID OwnerNode;
    DWORD Status;
    DWORD Count = 60;
    
RetryRetrieveChkpoint:
    OwnerNode = CppGetQuorumNodeId();
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CpGetDataFile: restoring data id %1!d! from quorum node %2!d!\n",
                dwCheckpointId,
                OwnerNode);
    if (OwnerNode == NmLocalNodeId) {
        Status = CppReadCheckpoint(Resource,
                                   dwCheckpointId,
                                   lpszFileName,
                                   fCryptoCheckpoint);
    } else {
        QfsHANDLE hFile;
        FILE_PIPE FilePipe;

        hFile = QfsCreateFile(lpszFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL);
        if (!QfsIsHandleValid(hFile)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CpGetDataFile: failed to create new file %1!ws! error %2!d!\n",
                       lpszFileName,
                       Status);
        } else {
            DmInitFilePipe(&FilePipe, hFile);
            try {
                if (fCryptoCheckpoint) {
                    Status = CpRetrieveCryptoCheckpoint(Session[OwnerNode],
                                                        OmObjectId(Resource),
                                                        dwCheckpointId,
                                                        FilePipe.Pipe);
                } else {
                    Status = CpRetrieveCheckpoint(Session[OwnerNode],
                                                  OmObjectId(Resource),
                                                  dwCheckpointId,
                                                  FilePipe.Pipe);
                }
            } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[CP] CpGetData - s_CpRetrieveCheckpoint from node %1!d! raised status %2!d!\n",
                           OwnerNode,
                           GetExceptionCode());
                CL_UNEXPECTED_ERROR( GetExceptionCode() );
                Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
            }
            DmFreeFilePipe(&FilePipe);
            QfsFlushFileBuffers(hFile);
            QfsCloseHandle(hFile);
        }
    }
    if (Status == ERROR_HOST_NODE_NOT_RESOURCE_OWNER) {
        //
        // This node no longer owns the quorum resource, retry.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CpGetData: quorum owner %1!d! no longer owner\n",
                    OwnerNode);
        goto RetryRetrieveChkpoint;                    
    }
    else if ((Status == ERROR_ACCESS_DENIED) || 
        (Status == ERROR_INVALID_FUNCTION) ||
        (Status == ERROR_NOT_READY) ||
        (Status == RPC_X_INVALID_PIPE_OPERATION) ||
        (Status == ERROR_BUSY) ||
        (Status == ERROR_SWAPERROR))
    {
        //if the quorum resource offline suddenly
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CpGetData: quorum resource went offline in the middle, Count=%1!u!\n",
                   Count);
        //we dont prevent the quorum resource from going offline if some resource 
        //is blocked for a long time in its online/offline thread- this is because 
        //some resources(like dtc)try to enumerate resources in the  quorum group
        //we increase the timeout to give cp a chance to retrieve the checkpoint 
        //while the quorum group is being moved or failed over
        if (Count--)
        {
            Sleep(1000);
            goto RetryRetrieveChkpoint;
        }            
    }

    if (Status != ERROR_SUCCESS) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", Status);

        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CpGetDataFile - failed to retrieve checkpoint %1!d! error %2!d!\n",
                   dwCheckpointId,
                   Status);
        CL_LOGCLUSERROR2(CP_RESTORE_REGISTRY_FAILURE, OmObjectName(Resource), string);
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif            
                     
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Registry notification processor for registry checkpoints.

    This is a fairly gnarly bit of code. Each resource can have multiple
    registry subtree notifications associated with it. Each active notification
    has an associated Registry Notify Block (RNB) chained off the FM_RESOURCE
    structure. A single registry notification thread can handle max 31 RNBs
    This is because WaitForMultipleObjects maxes out at 64 objects and each RNB
    takes two wait slots.

    When an RNB is created, an available notify thread is found (or created if
    there are none). Then the notify thread is woken up with its command event
    to insert the RNB into its array of wait events.

    Once a notification occurs, the notify thread sets the RNB to "pending" and
    sets its associated timer to go off in a few seconds. If another registry
    notification occurs, the timer is reset. Thus, the timer will not actually
    go off until there have been no registry notifications for a few seconds.

    When the RNB timer fires, the notify thread checkpoints its subtree and
    puts it back on the queue. If the notify thread is asked to remove a RNB
    that is in the "pending" state, it cancels the timer, checkpoints the registry,
    and removes the RNB from its list.

Author:

    John Vert (jvert) 1/17/1997

Revision History:

--*/
#include "cpp.h"

CRITICAL_SECTION CppNotifyLock;
LIST_ENTRY CpNotifyListHead;

#define MAX_BLOCKS_PER_GROUP ((MAXIMUM_WAIT_OBJECTS-1)/2)
#define LAZY_CHECKPOINT 3               // checkpoint 3 seconds after last update

typedef struct _RNB {
    struct _RNB *Next;
    BOOL Pending;
    PFM_RESOURCE Resource;
    LPWSTR KeyName;
    DWORD dwId;
    HKEY hKey;
    HANDLE hEvent;
    HANDLE hTimer;
    struct _NOTIFY_GROUP *NotifyGroup;
    DWORD NotifySlot;
} RNB, *PRNB;

typedef enum {
    NotifyAddRNB,
    NotifyRemoveRNB
} NOTIFY_COMMAND;

typedef struct _NOTIFY_GROUP {
    LIST_ENTRY      ListEntry;           // Linkage onto CpNotifyListHead;
    HANDLE          hCommandEvent;
    HANDLE          hCommandComplete;
    HANDLE          hThread;
    NOTIFY_COMMAND  Command;
    ULONG_PTR       CommandContext;
    DWORD           BlockCount;
    HANDLE          WaitArray[MAXIMUM_WAIT_OBJECTS];
    PRNB            NotifyBlock[MAXIMUM_WAIT_OBJECTS-1];
} NOTIFY_GROUP, *PNOTIFY_GROUP;

//
// Local function prototypes
//
DWORD
CppRegNotifyThread(
    IN PNOTIFY_GROUP Group
    );

DWORD
CppNotifyCheckpoint(
    IN PRNB Rnb
    );


DWORD
CppRegisterNotify(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR lpszKeyName,
    IN DWORD dwId
    )
/*++

Routine Description:

    Creates a registry notification block for the specified resource.

Arguments:

    Resource - Supplies the resource the notification is for.

    KeyName - Supplies the registry subtree (relative to HKEY_LOCAL_MACHINE

    CheckpointId - Supplies the checkpoint ID.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PLIST_ENTRY ListEntry;
    PNOTIFY_GROUP Group;
    PNOTIFY_GROUP CurrentGroup;
    PRNB Block;

    Block = CsAlloc(sizeof(RNB));
    Block->Resource = Resource;
    Block->KeyName = CsStrDup(lpszKeyName);
    Block->dwId = dwId;
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         lpszKeyName,
                         &Block->hKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[CP] CppRegisterNotify failed to open key %1!ws! error %2!d!\n",
                   lpszKeyName,
                   Status);
        return(Status);
    }
    Block->hTimer = CreateWaitableTimer(NULL,FALSE,NULL);
    CL_ASSERT(Block->hTimer != NULL);
    Block->hEvent = CreateEventW(NULL,TRUE,FALSE,NULL);
    CL_ASSERT(Block->hEvent != NULL);
    Block->Pending = FALSE;

    //
    // Get the lock
    //
    EnterCriticalSection(&CppNotifyLock);

    //
    // Find a group with space for this notify block
    //
    Group = NULL;
    ListEntry = CpNotifyListHead.Flink;
    while (ListEntry != &CpNotifyListHead) {
        CurrentGroup = CONTAINING_RECORD(ListEntry,
                                         NOTIFY_GROUP,
                                         ListEntry);
        ListEntry = ListEntry->Flink;
        if (CurrentGroup->BlockCount < MAX_BLOCKS_PER_GROUP) {
            //
            // Found a group.
            //
            Group = CurrentGroup;
            break;
        }
    }
    if (Group == NULL) {
        DWORD ThreadId;
        HANDLE hThread;

        //
        // Need to spin up a new group
        //
        Group = CsAlloc(sizeof(NOTIFY_GROUP));
        ZeroMemory(Group, sizeof(NOTIFY_GROUP));
        Group->hCommandEvent = CreateEventW(NULL,FALSE,FALSE,NULL);
        if ( Group->hCommandEvent == NULL ) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        Group->hCommandComplete = CreateEventW(NULL,FALSE,FALSE,NULL);
        if ( Group->hCommandComplete == NULL ) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        hThread = CreateThread(NULL,
                               0,
                               CppRegNotifyThread,
                               Group,
                               0,
                               &ThreadId);
        if (hThread == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppRegisterNotify failed to create new notify thread %1!d!\n",
                       Status);
            CloseHandle ( Group->hCommandComplete );
            CloseHandle ( Group->hCommandEvent );
            LocalFree(Group);
            goto error_exit2;
        }
        Group->hThread = hThread;
        InsertHeadList(&CpNotifyListHead, &Group->ListEntry);
    }

    //
    // Wake up the notify thread to insert the RNB for us.
    //
    Block->NotifyGroup = Group;
    Group->Command = NotifyAddRNB;
    Group->CommandContext = (ULONG_PTR)Block;
    SetEvent(Group->hCommandEvent);
    WaitForSingleObject(Group->hCommandComplete, INFINITE);

    Block->Next = (PRNB)Resource->CheckpointState;
    Resource->CheckpointState = Block;

    LeaveCriticalSection(&CppNotifyLock);
    return(ERROR_SUCCESS);

error_exit2:
    LeaveCriticalSection(&CppNotifyLock);
    RegCloseKey(Block->hKey);
    CloseHandle(Block->hTimer);
    CloseHandle(Block->hEvent);
    CsFree(Block->KeyName);
    CsFree(Block);
    return(Status);
}


DWORD
CppRegNotifyThread(
    IN PNOTIFY_GROUP Group
    )
/*++

Routine Description:

    Worker thread that handles multiple registry notification subtrees.

Arguments:

    Group - Supplies the NOTIFY_GROUP control structure owned by this thread.

Return Value:

    None.

--*/

{
    PRNB Rnb;
    DWORD Signalled;
    DWORD Index;
    BOOL Success;
    DWORD Slot;
    DWORD Status;

    Group->BlockCount = 0;
    Group->WaitArray[0] = Group->hCommandEvent;
    do {
        Signalled = WaitForMultipleObjects(Group->BlockCount*2 + 1,
                                           Group->WaitArray,
                                           FALSE,
                                           INFINITE);
        if (Signalled == Group->BlockCount*2) {
            switch (Group->Command) {
                case NotifyAddRNB:
                    //
                    // Add this notify block to our list.
                    //
                    CL_ASSERT(Group->BlockCount < MAX_BLOCKS_PER_GROUP);
                    Rnb = (PRNB)Group->CommandContext;

                    Status = RegNotifyChangeKeyValue(Rnb->hKey,
                                 TRUE,
                                 REG_LEGAL_CHANGE_FILTER,
                                 Rnb->hEvent,
                                 TRUE);
                    if (Status != ERROR_SUCCESS) {
                        CL_UNEXPECTED_ERROR(Status);
                    }

                    Index = Group->BlockCount*2;
                    Group->WaitArray[Index] = Rnb->hEvent;
                    Group->WaitArray[Index+1] = Rnb->hTimer;
                    Rnb->NotifySlot = Group->BlockCount;
                    Group->NotifyBlock[Rnb->NotifySlot] = Rnb;
                    ++Group->BlockCount;
                    Group->WaitArray[Group->BlockCount*2] = Group->hCommandEvent;
                    break;

                case NotifyRemoveRNB:
                    Rnb = (PRNB)Group->CommandContext;

                    //
                    // Check to see if the RNB is pending. If so, checkpoint it
                    // now before we remove it.
                    //
                    if (Rnb->Pending) {

                        DWORD   Count = 60;
                    
                        ClRtlLogPrint(LOG_NOISE,
                                   "[CP] CppRegNotifyThread checkpointing key %1!ws! to id %2!d! due to removal while pending\n",
                                   Rnb->KeyName,
                                   Rnb->dwId);
RetryCheckpoint:                                   
                        Status = CppNotifyCheckpoint(Rnb);
                        if (Status != ERROR_SUCCESS)
                        {
                            WCHAR  string[16];



                            ClRtlLogPrint(LOG_CRITICAL,
                                   "[CP] CppRegNotifyThread, CppNotifyCheckpoint failed with Status=%1!u!\n",
                                   Status);
                            if ((Status == ERROR_ACCESS_DENIED) ||
                                (Status == ERROR_INVALID_FUNCTION) ||
                                (Status == ERROR_NOT_READY) ||
                                (Status == RPC_X_INVALID_PIPE_OPERATION) ||
                                (Status == ERROR_BUSY) ||
                                (Status == ERROR_SWAPERROR))
                            {
                                //SS: we should retry forever??
                                //SS: Since we allow the quorum to come
                                //offline after 30 seconds of waiting on 
                                //pending resources, the checkpointing should
                                //be able to succeed
                                if (Count--)
                                {
                                    Sleep(1000);
                                    goto RetryCheckpoint;
                                }                                    
                            }
#if DBG
                            if (IsDebuggerPresent())
                                DebugBreak();
#endif                                
                            wsprintfW(&(string[0]), L"%u", Status);
                            CL_LOGCLUSERROR2(CP_SAVE_REGISTRY_FAILURE, Rnb->KeyName, string);
                        } 
                        // irrespective of the failure set pending to FALSE
                        Rnb->Pending = FALSE;
                    }

                    //
                    // Move everything down to take the previous RNB's slot.
                    //
                    Index = Rnb->NotifySlot * 2 ;
                    Group->BlockCount--;
                    for (Slot = Rnb->NotifySlot; Slot < Group->BlockCount; Slot++) {

                        Group->NotifyBlock[Slot] = Group->NotifyBlock[Slot+1];
                        Group->NotifyBlock[Slot]->NotifySlot--;
                        Group->WaitArray[Index] = Group->WaitArray[Index+2];
                        Group->WaitArray[Index+1] = Group->WaitArray[Index+3];
                        Index += 2;
                    }
                    Group->WaitArray[Index] = NULL;
                    Group->WaitArray[Index+1] = NULL;
                    Group->WaitArray[Index+2] = NULL;
                    Group->NotifyBlock[Group->BlockCount] = NULL;
                    Group->WaitArray[Group->BlockCount*2] = Group->hCommandEvent;
                    break;

                default:
                    CL_UNEXPECTED_ERROR( Group->Command );
                    break;
            }
            SetEvent(Group->hCommandComplete);
        } else {
            //
            // Either a registry notification or a timer has fired.
            // Process this.
            //
            Rnb = Group->NotifyBlock[(Signalled)/2];
            if (!(Signalled & 1)) {
                LARGE_INTEGER DueTime;
                //
                // This is a registry notification.
                // All we do for registry notifications is set the timer, issue
                // the RegNotify again, mark the RNB as pending, and rewait.
                //
                DueTime.QuadPart = -10 * 1000 * 1000 * LAZY_CHECKPOINT;
                Success = SetWaitableTimer(Rnb->hTimer,
                                           &DueTime,
                                           0,
                                           NULL,
                                           NULL,
                                           FALSE);
                CL_ASSERT(Success);
                Status = RegNotifyChangeKeyValue(Rnb->hKey,
                                                 TRUE,
                                                 REG_LEGAL_CHANGE_FILTER,
                                                 Rnb->hEvent,
                                                 TRUE);
                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[CP] CppRegNotifyThread - error %1!d! attempting to reregister notification for %2!ws!\n",
                               Status,
                               Rnb->KeyName);
                }

                //
                // Mark it pending so if someone tries to remove it we know that
                // we should checkpoint first.
                //
                Rnb->Pending = TRUE;

            } else {
                //
                // This must be a timer firing
                //
                CL_ASSERT(Rnb->Pending);

                ClRtlLogPrint(LOG_NOISE,
                           "[CP] CppRegNotifyThread checkpointing key %1!ws! to id %2!d! due to timer\n",
                           Rnb->KeyName,
                           Rnb->dwId);

                           
                Status = CppNotifyCheckpoint(Rnb);
                if (Status == ERROR_SUCCESS)
                {
                    Rnb->Pending = FALSE;
                }
                else
                {
                    LARGE_INTEGER DueTime;

                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[CP] CppRegNotifyThread CppNotifyCheckpoint due to timer failed, reset the timer.\n");
                    //
                    // This checkpoint on timer can fail because the quorum resource is
                    // not available.  This is because we do not sychronoze the quorum
                    // state change with this timer and it is too inefficient to do so !
                    
                    DueTime.QuadPart = -10 * 1000 * 1000 * LAZY_CHECKPOINT;
                    Success = SetWaitableTimer(Rnb->hTimer,
                                               &DueTime,
                                               0,
                                               NULL,
                                               NULL,
                                               FALSE);
                    CL_ASSERT(Success);
                    
                    //Pending remains set to TRUE.
                        
                }
            }

        }


    } while ( Group->BlockCount > 0 );

    return(ERROR_SUCCESS);
}


DWORD
CppNotifyCheckpoint(
    IN PRNB Rnb
    )
/*++

Routine Description:

    Checkpoints the registry subtree for the specified RNB

Arguments:

    Rnb - Supplies the registry notification block to be checkpointed

Return Value:

    None

--*/

{
    DWORD Status;

    Status = CppCheckpoint(Rnb->Resource,
                           Rnb->hKey,
                           Rnb->dwId,
                           Rnb->KeyName);
                           

    return(Status);
}


DWORD
CppRundownCheckpoints(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Runs down, frees, and removes any registry notification blocks
    for the specified resource.

Arguments:

    Resource - Supplies the resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PRNB Rnb;
    PRNB NextRnb;
    PNOTIFY_GROUP Group;

    EnterCriticalSection(&CppNotifyLock);
    NextRnb = (PRNB)Resource->CheckpointState;
    while (NextRnb) {
        Rnb = NextRnb;
        NextRnb = NextRnb->Next;

        ClRtlLogPrint(LOG_NOISE,
                   "[CP] CppRundownCheckpoints removing RNB for %1!ws!\n",
                   Rnb->KeyName);

        Group = Rnb->NotifyGroup;

        //
        // Send a command to the group notify thread to remove the RNB.
        //
        if (Group->BlockCount == 1) 
        {
            //
            // Remove this group, it is going to be empty. The worker thread
            // will exit after this command
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppRundownCheckpoints removing empty group\n");
            RemoveEntryList(&Group->ListEntry);

            //dont wait, the notification thread for this group will automatically
            //exit when the block count drops to 0.  It cleans up the hCommandEvent
            //and the hCompleteEvent on exit, so do not do a waitforsingleobject() 
            //in this case.
            Group->Command = NotifyRemoveRNB;
            Group->CommandContext = (ULONG_PTR)Rnb;
            SetEvent(Group->hCommandEvent);
            //wait for the thread to exit
            WaitForSingleObject(Group->hThread, INFINITE);
            // Clean up the group structure 
            CloseHandle(Group->hCommandEvent);
            CloseHandle(Group->hCommandComplete);
            CloseHandle(Group->hThread);
            CsFree(Group);
        }
        else
        {
            //the block count is greater than 1, remove the rnb, signal
            //the thread and wait
            Group->Command = NotifyRemoveRNB;
            Group->CommandContext = (ULONG_PTR)Rnb;
            SetEvent(Group->hCommandEvent);
            WaitForSingleObject(Group->hCommandComplete, INFINITE);
        }

        //
        // Clean up all the allocations and handles in the RNB.
        //
        CsFree(Rnb->KeyName);
        RegCloseKey(Rnb->hKey);
        CloseHandle(Rnb->hEvent);
        CloseHandle(Rnb->hTimer);
        CsFree(Rnb);
    }
    Resource->CheckpointState = 0;

    LeaveCriticalSection(&CppNotifyLock);

    return(ERROR_SUCCESS);
}


DWORD
CppRundownCheckpointById(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId
    )
/*++

Routine Description:

    Runs down, frees, and removes the registry notification block
    for the specified resource and checkpoint ID.

Arguments:

    Resource - Supplies the resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PRNB Rnb;
    PRNB NextRnb;
    PRNB *ppLastRnb;
    PNOTIFY_GROUP Group;

    EnterCriticalSection(&CppNotifyLock);
    NextRnb = (PRNB)Resource->CheckpointState;
    ppLastRnb = &((PRNB)Resource->CheckpointState);
    while (NextRnb) {
        Rnb = NextRnb;
        NextRnb = NextRnb->Next;
        if (Rnb->dwId == dwId) {
            ClRtlLogPrint(LOG_NOISE,
                       "[CP] CppRundownCheckpointById removing RNB for %1!ws!\n",
                       Rnb->KeyName);
            //remove from the list of checkpoint id's for the resource                       
            *ppLastRnb = NextRnb;
                
            Group = Rnb->NotifyGroup;

            //
            // Send a command to the group notify thread to remove the RNB.
            //
            if (Group->BlockCount == 1) 
            {
                //
                // Remove this group, it is going to be empty. The worker thread
                // will exit after this command
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[CP] CppRundownCheckpointById removing empty group\n");

                RemoveEntryList(&Group->ListEntry);

                //dont wait, the notification thread for this group will automatically
                //exit when the block count drops to 0.  It cleans up the hCommandEvent
                //and the hCompleteEvent on exit, so do not do a waitforsingleobject() 
                //in this case.
                Group->Command = NotifyRemoveRNB;
                Group->CommandContext = (ULONG_PTR)Rnb;
                SetEvent(Group->hCommandEvent);
                //wait for the thread to exit
                WaitForSingleObject(Group->hThread, INFINITE);
                // Clean up the group structure 
                CloseHandle(Group->hCommandEvent);
                CloseHandle(Group->hCommandComplete);
                CloseHandle(Group->hThread);
                CsFree(Group);
            }
            else
            {
                //the block count is greater than 1, remove the rnb, signal
                //the thread and wait
                Group->Command = NotifyRemoveRNB;
                Group->CommandContext = (ULONG_PTR)Rnb;
                SetEvent(Group->hCommandEvent);
                WaitForSingleObject(Group->hCommandComplete, INFINITE);
            }

            
            //
            // Clean up all the allocations and handles in the RNB.
            //
            CsFree(Rnb->KeyName);
            RegCloseKey(Rnb->hKey);
            CloseHandle(Rnb->hEvent);
            CloseHandle(Rnb->hTimer);
            CsFree(Rnb);
            LeaveCriticalSection(&CppNotifyLock);
            return(ERROR_SUCCESS);
        }
        ppLastRnb = &Rnb->Next;
    }
    ClRtlLogPrint(LOG_UNUSUAL,
               "[CP] CppRundownCheckpointById - could not find checkpoint %1!d! in resource %2!ws!\n",
               dwId,
               OmObjectName(Resource));

    LeaveCriticalSection(&CppNotifyLock);
    return(ERROR_FILE_NOT_FOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    APIs for the server-side RPC support for the Checkpoint Manager

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#include "cpp.h"


error_status_t
CppDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData,
    BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR FileName = NULL;
    LPWSTR DirectoryName = NULL;
    BOOL Success;
    PFM_RESOURCE Resource;

    ACQUIRE_SHARED_LOCK(gQuoLock);

    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) 
    {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  &DirectoryName,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    OmDereferenceObject(Resource);
    
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDepositCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppDepositCheckpoint checkpointing data to file %1!ws!\n",
               FileName);
    //
    // Create the directory.
    //
    if (!QfsCreateDirectory(DirectoryName, NULL)) 
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppDepositCheckpoint unable to create directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
        else
        {
            //the directory exists, set Status to ERROR_SUCCESS
            Status = ERROR_SUCCESS;
        }
    }
    else
    {

        //
        // The directory was newly created. Put the appropriate ACL on it
        // so that only ADMINs can read it.
        //

        Status = QfsSetFileSecurityInfo(DirectoryName,
                                         GENERIC_ALL,
                                         GENERIC_ALL,
                                         0);

        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppDepositCheckpoint- unable to set ACL on directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
    }
    
    //
    // Pull the checkpoint data file across RPC
    //
    Status = DmPullFile(FileName, CheckpointData);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppDepositCheckpoint - DmPullFile %1!ws! failed %2!d!\n",
                   FileName,
                   Status);
    }

FnExit:
    RELEASE_LOCK(gQuoLock);

    //clean up
    if (DirectoryName) LocalFree(DirectoryName);
    if (FileName) LocalFree(FileName);
    
    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    //At this point, CppDepositCheckpoint should either 

    //a) throw the error code as an exception, or 
    //b) drain the [in] pipe and then return the error code normally

    //but if it returns without draining the pipe, and the RPC runtime throws 
    //the pipe-discipline exception.
    if (Status != ERROR_SUCCESS)
        RpcRaiseException(Status);

    return(Status);
}


error_status_t
s_CpDepositCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppDepositCheckpoint(IDL_handle,
                                ResourceId,
                                dwCheckpointId,
                                CheckpointData,
                                FALSE
                                );
}


error_status_t
s_CpDepositCryptoCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC to allow other nodes to checkpoint data to the
    quorum disk.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose data is being checkpointed

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data can be retrieved.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppDepositCheckpoint(IDL_handle,
                                ResourceId,
                                dwCheckpointId,
                                CheckpointData,
                                TRUE
                                );
}


error_status_t
CppRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BOOLEAN fCryptoCheckpoint,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR FileName=NULL;
    HANDLE hFile;
    BOOL Success;
    PFM_RESOURCE Resource;

    ACQUIRE_SHARED_LOCK(gQuoLock);
    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  NULL,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    OmDereferenceObject(Resource);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppRetrieveCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppRetrieveCheckpoint retrieving data from file %1!ws!\n",
               FileName);

    //
    // Push the checkpoint data file across RPC
    //
    Status = DmPushFile(FileName, CheckpointData, TRUE);  // TRUE == encrypt the data on the wire
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppRetrieveCheckpoint - DmPushFile %1!ws! failed %2!d!\n",
                   FileName,
                   Status);
    }

FnExit:
    RELEASE_LOCK(gQuoLock);
    //cleanup
    if (FileName) LocalFree(FileName);

    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    return(Status);
}


error_status_t
s_CpRetrieveCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppRetrieveCheckpoint(IDL_handle,
                                 ResourceId,
                                 dwCheckpointId,
                                 FALSE,
                                 CheckpointData
                                 );

}


error_status_t
s_CpRetrieveCryptoCheckpoint(
    handle_t IDL_handle,
    LPCWSTR ResourceId,
    DWORD dwCheckpointId,
    BYTE_PIPE CheckpointData
    )
/*++

Routine Description:

    Server side RPC through which data checkpointed to the quorum disk
    can be retrieved by other nodes.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint data is to be retrieved

    dwCheckpointId - Unique identifier of the checkpoint

    CheckpointData - pipe through which checkpoint data should be sent

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppRetrieveCheckpoint(IDL_handle,
                                 ResourceId,
                                 dwCheckpointId,
                                 TRUE,
                                 CheckpointData
                                 );

}

error_status_t
CppDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath,
    BOOL        fCryptoCheckpoint
    )
/*++

Routine Description:

    Server side RPC through which the checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD           Status;
    PFM_RESOURCE    Resource = NULL;

    Resource = OmReferenceObjectById(ObjectTypeResource, ResourceId);
    if (Resource == NULL) {
        Status = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    if (fCryptoCheckpoint) {
        Status = CpckDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
    } else {
        Status = CppDeleteCheckpointFile(Resource, dwCheckpointId, lpszQuorumPath);
    }

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

FnExit:
    if (Resource) OmDereferenceObject(Resource);
    return(Status);
}

error_status_t
s_CpDeleteCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath
    )
/*++

Routine Description:

    Server side RPC through which the checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppDeleteCheckpoint(IDL_handle,
                               ResourceId,
                               dwCheckpointId,
                               lpszQuorumPath,
                               FALSE);
}

error_status_t
s_CpDeleteCryptoCheckpoint(
    handle_t    IDL_handle,
    LPCWSTR     ResourceId,
    DWORD       dwCheckpointId,
    LPCWSTR     lpszQuorumPath
    )
/*++

Routine Description:

    Server side RPC through which the crypto checkpoint file  corresponding to a 
    given checkpointid for a resource is deleted.

Arguments:

    IDL_handle - RPC binding handle, not used.

    ResourceId - Name of the resource whose checkpoint file is to be deleted.

    dwCheckpointId - Unique identifier of the checkpoint. If 0, all checkpoints
    must be deleted.

    lpszQuorumPath - The path to the cluster files from where these files must
    be deleted.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    CP_VALIDATE_ID_STRING ( ResourceId );

    return CppDeleteCheckpoint(IDL_handle,
                               ResourceId,
                               dwCheckpointId,
                               lpszQuorumPath,
                               TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dminit.c

Abstract:

    Contains the initialization code for the Cluster Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

//
// Global Data
//

HKEY DmpRoot;
HKEY DmpRootCopy;
LIST_ENTRY KeyList;
CRITICAL_SECTION KeyLock;
HDMKEY DmClusterParametersKey;
HDMKEY DmResourcesKey;
HDMKEY DmResourceTypesKey;
HDMKEY DmGroupsKey;
HDMKEY DmNodesKey;
HDMKEY DmNetworksKey;
HDMKEY DmNetInterfacesKey;
HDMKEY DmQuorumKey;
HANDLE ghQuoLogOpenEvent=NULL;

#if NO_SHARED_LOCKS
CRITICAL_SECTION gLockDmpRoot;
#else
RTL_RESOURCE    gLockDmpRoot;
#endif
BOOL gbIsQuoLoggingOn=FALSE;
HANDLE ghDiskManTimer=NULL;//disk management timer
PFM_RESOURCE gpQuoResource=NULL;  //set when DMFormNewCluster is completed
HANDLE ghCheckpointTimer = NULL; //timer for periodic checkpointing
BOOL   gbDmInited = FALSE; //set to TRUE when all phases of dm initialization are over
extern HLOG ghQuoLog;
BOOL   gbDmpShutdownUpdates = FALSE;


//define public cluster key value names
const WCHAR cszPath[]= CLUSREG_NAME_QUORUM_PATH;
const WCHAR cszMaxQuorumLogSize[]=CLUSREG_NAME_QUORUM_MAX_LOG_SIZE;
const WCHAR cszParameters[] = CLUSREG_KEYNAME_PARAMETERS;

//other const strings
const WCHAR cszQuoFileName[]=L"quolog.log";
const WCHAR cszQuoTombStoneFile[]=L"quotomb.stn";
const WCHAR cszTmpQuoTombStoneFile[]=L"quotomb.tmp";

GUM_DISPATCH_ENTRY DmGumDispatchTable[] = {
    {3, (PGUM_DISPATCH_ROUTINE1)DmpUpdateCreateKey},
    {4, (PGUM_DISPATCH_ROUTINE1)DmpUpdateSetSecurity}
    };

//
// Global data for interfacing with registry watcher thread
//
HANDLE hDmpRegistryFlusher=NULL;
HANDLE hDmpRegistryEvent=NULL;
HANDLE hDmpRegistryRestart=NULL;
DWORD
DmpRegistryFlusher(
    IN LPVOID lpThreadParameter
    );

//
// Local function prototypes
//
VOID
DmpInvalidateKeys(
    VOID
    );

VOID
DmpReopenKeys(
    VOID
    );

DWORD
DmpLoadHive(
    IN LPCWSTR Path
    );

typedef struct _DMP_KEY_DEF {
    HDMKEY *pKey;
    LPWSTR Name;
} DMP_KEY_DEF;

DMP_KEY_DEF DmpKeyTable[] = {
    {&DmResourcesKey, CLUSREG_KEYNAME_RESOURCES},
    {&DmResourceTypesKey, CLUSREG_KEYNAME_RESOURCE_TYPES},
    {&DmQuorumKey, CLUSREG_KEYNAME_QUORUM},
    {&DmGroupsKey, CLUSREG_KEYNAME_GROUPS},
    {&DmNodesKey, CLUSREG_KEYNAME_NODES},
    {&DmNetworksKey, CLUSREG_KEYNAME_NETWORKS},
    {&DmNetInterfacesKey, CLUSREG_KEYNAME_NETINTERFACES}
};


DWORD
DmInitialize(
    VOID
    )

/*++

Routine Description:

    Inits the config database manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOL Success;
    DWORD Status = ERROR_SUCCESS;
    DWORD dwOut;

    ClRtlLogPrint(LOG_NOISE,"[DM] Initialization\n");

    InitializeListHead(&KeyList);
    InitializeCriticalSection(&KeyLock);

    //create a critical section for locking the database while checkpointing
    INITIALIZE_LOCK(gLockDmpRoot);

    //create a named event that is used for waiting for quorum resource
    //to go online
    ghQuoLogOpenEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!ghQuoLogOpenEvent)
    {
        CL_UNEXPECTED_ERROR((Status = GetLastError()));
        goto FnExit;

    }

    Success = DmpInitNotify();
    CL_ASSERT(Success);
    if (!Success)
    {
        Status = GetLastError();
        goto FnExit;
    }

    //find out if the databasecopy was in progresss on last death
    DmpGetDwordFromClusterServer(L"ClusterDatabaseCopyInProgress", &dwOut, 0);

LoadClusterDatabase:
    //
    // Open key to root of cluster.
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    //
    // If the key was not found, go load the database.
    //
    if (Status == ERROR_FILE_NOT_FOUND) {
        WCHAR Path[MAX_PATH];
        WCHAR BkpPath[MAX_PATH];
        WCHAR *p;

        Status = GetModuleFileName(NULL, Path, MAX_PATH);

        //
        //  GetModuleFileName may not NULL terminate the Path.
        //
        Path [ RTL_NUMBER_OF ( Path ) - 1 ] = UNICODE_NULL;

        if (Status == 0) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Couldn't find cluster database, status=%1!u!\n", 
                         Status);
            goto FnExit;
        }

        //get the name of the cluster database
        p=wcsrchr(Path, L'\\');
        if (p == NULL) 
        {
            Status = ERROR_FILE_NOT_FOUND;
            CL_UNEXPECTED_ERROR(Status);
            goto FnExit;
        }
        //see if we should load the hive from the old one or the bkp file
        *p = L'\0';
        wcscpy(BkpPath, Path);
#ifdef   OLD_WAY
        wcscat(Path, L"\\CLUSDB");
        wcscat(BkpPath, L"\\CLUSTER_DATABASE_TMPBKP_NAME");
#else    // OLD_WAY
        wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
        wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
#endif   // OLD_WAY

        if (dwOut)
        {
            //the backip file must exist
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmInitialize:: DatabaseCopy was in progress on last death, get hive from %1!ws!!\n",
                BkpPath);
            //set file attributes of the BkpPath
            if (!QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmInitialize:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                    BkpPath, Status);
                goto FnExit;                
            }

            //ClRtlCopyFileAndFlushBuffers preserves the attributes on the original file
            if (!QfsClRtlCopyFileAndFlushBuffers(BkpPath, Path))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Databasecopy was in progress,Failed to copy %1!ws! to %2!ws!, Status=%3!u!\n",
                    BkpPath, Path, Status);
                //set the file attribute on the backup, so that
                //nobody mucks with it without knowing what they are 
                //doing
                QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
                goto FnExit;                
            }
            //now we can reset the DatabaseCopyInProgress value in the registry
            //set databaseCopyInProgress key to FALSE
            //This will flush the key as well
            Status = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress", 0);
            if (Status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Failed to reset ClusterDatabaseCopyInProgress, Status=%1!u!\n",
                    Status);
                goto FnExit;            
            }
            //Now we can delete the backup path, since the key has been flushed
            if (!QfsDeleteFile(BkpPath))
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmInitialize:: Failed to delete the backup when it wasnt needed,Status=%1!u!\n",
                    GetLastError());
                //this is not fatal so we ignore the error                    
            }
        }
        else
        {
            //the backup file might exist
            //this is true when safe copy makes a backup but hasnt 
            //set the value DatabaseCopyInProgress in the registry
            //if it does delete it
            //set file attributes of the BkpPath
            if (!QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
            {
                //errors are not fatal, we just ignore them                    
                //this may fail because the path doesnt exist                                    
            }
            //Now we can delete the backup path, since the key has been flushed
            //this is not fatal so we ignore the error                    
            if (QfsDeleteFile(BkpPath))
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmInitialize:: Deleted the unneeded backup of the cluster database\n");
            }

        }
        
        Status = DmpLoadHive(Path);
        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Couldn't load cluster database\n");
            CsLogEventData(LOG_CRITICAL,
                           DM_DATABASE_CORRUPT_OR_MISSING,
                           sizeof(Status),
                           &Status);
            goto FnExit;                           
        }
        
        Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                             DmpClusterParametersKeyName,
                             &DmpRoot);
        //
        // HACKHACK John Vert (jvert) 6/3/1997
        //      There is a bug in the registry with refresh
        //      where the Parent field in the root cell doesn't
        //      get flushed to disk, so it gets blasted if we
        //      do a refresh. Then we crash in unload. So flush
        //      out the registry to disk here to make sure the
        //      right Parent field gets written to disk.
        //
        if (Status == ERROR_SUCCESS) {
            DWORD Dummy=0;
            //
            // Make something dirty in the root
            //
            RegSetValueEx(DmpRoot,
                          L"Valid",
                          0,
                          REG_DWORD,
                          (PBYTE)&Dummy,
                          sizeof(Dummy));
            RegDeleteValue(DmpRoot, L"Valid");
            Status = RegFlushKey(DmpRoot);
        }
    } else {

        //if the hive is already loaded we unload and reload it again
        //to make sure that it is loaded with the right flags and
        //also to make sure that the backup copy is used in case
        //of failures
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmInitialize: The hive was loaded- rollback, unload and reload again\n");
        //BUGBUG:: currently the unload flushes the hive, ideally we 
        //would like to unload it without flushing it
        //This way a part transaction wont be a part of the hive
        //However, if somebody messes with the cluster hive using
        //regedt32 and if reg_no_lazy flush is not specified, some
        //changes might get flushed to the hive.
        
        //We can try and do the rollback in any case,
        //the rollback will fail if the registry wasnt loaded with the
        //reg_no_lazy_flush flag.
        //unload it and then proceed to reload it 
        //this will take care of situations where a half baked clusdb
        //gets loaded because of failures
        Status = DmRollbackRegistry();
        if (Status != ERROR_SUCCESS)
        {
            //we ignore the error
            Status = ERROR_SUCCESS;
        }            
        RegCloseKey(DmpRoot);
        if ( DmpRootCopy != NULL ) {
            RegCloseKey(DmpRootCopy);
        }
        DmpRoot = DmpRootCopy = NULL;
        Status = DmpUnloadHive();
        
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmInitialize: DmpUnloadHive failed, Status=%1!u!\n",
                Status);
            goto FnExit;                 
        }        
        goto LoadClusterDatabase;            
    }
    
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRootCopy);
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmInitialize:: Failed to open copy of registry key,Status=%1!u!\n",
            Status);
        goto FnExit;
    }

    //
    // Create the registry watcher thread
    //
    Status = DmpStartFlusher();
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }
    //
    // Open the cluster keys
    //
    Status = DmpOpenKeys(MAXIMUM_ALLOWED);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        goto FnExit;
    }

FnExit:
    return(Status);

}//DmInitialize


DWORD
DmpRegistryFlusher(
    IN LPVOID lpThreadParameter
    )
/*++

Routine Description:

    Registry watcher thread for explicitly flushing changes.

Arguments:

    lpThreadParameter - not used

Return Value:

    None.

--*/

{
    DWORD         Status;
    HANDLE        hEventFullSubtree = NULL;
    HANDLE        hTimer = NULL;
    HANDLE        hEventTopOnly = NULL;
    HANDLE        WaitArray[5];
    LARGE_INTEGER DueTime;
    BOOL          Dirty = FALSE;
    BOOL          subtreeNeedsReg = TRUE;
    BOOL          topNeedsReg = TRUE;


    //
    // Create a notification event and a delayed timer for lazy flushing.
    //
    hEventFullSubtree = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEventFullSubtree == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmpRegistryFlusher couldn't create notification event %1!d!\n",
                      Status);
        goto error_exit;
    }

    hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
    if (hTimer == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmpRegistryFlusher couldn't create notification timer %1!d!\n",
                      Status);
        goto error_exit;
    }

    hEventTopOnly = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEventTopOnly == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmpRegistryFlusher couldn't create notification event %1!d!\n",
                      Status);
        goto error_exit;
    }

    WaitArray[0] = hDmpRegistryEvent;
    WaitArray[1] = hEventFullSubtree;
    WaitArray[2] = hTimer;
    WaitArray[3] = hDmpRegistryRestart;
    WaitArray[4] = hEventTopOnly;

    while (TRUE) {
        //
        // Set up a registry notification on DmpRoot. We acquire the lock here to
        // make sure that rollback or install is not messing with the database
        // while we are trying to get a notification.
        //
        Status = ERROR_SUCCESS;
        ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
        // Because we are now waiting on 2 separate RegNotify's, we can't just
        // reregister for notications on every iteration.  Need to see which
        // registration is "stale".
        if ( subtreeNeedsReg ) {
            Status = RegNotifyChangeKeyValue(DmpRoot,
                                            TRUE,
                                            REG_LEGAL_CHANGE_FILTER,
                                            hEventFullSubtree,
                                            TRUE);
            subtreeNeedsReg = FALSE;
        }

        if ( topNeedsReg && Status == ERROR_SUCCESS ) {
            Status = RegNotifyChangeKeyValue(DmpRootCopy,
                                             FALSE, // not whole subtree
                                             REG_LEGAL_CHANGE_FILTER,
                                             hEventTopOnly,
                                             TRUE);
            topNeedsReg = FALSE;
        }
        RELEASE_LOCK(gLockDmpRoot);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                            "[DM] DmpRegistryFlusher couldn't register for notifications %1!d!\n",
                            Status);
            break;
        }

        //
        // Wait for something to happen.
        //
        Status = WaitForMultipleObjects(sizeof(WaitArray)/sizeof(WaitArray[0]),
                                        WaitArray,
                                        FALSE,
                                        (DWORD)-1);

        switch (Status) {
            case 0:
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 0\r\n");
                //
                // We have been asked to stop, clean up and exit
                //
                Status = ERROR_SUCCESS;
                if (Dirty) {
                    //
                    // Make sure any changes that we haven't gotten around to flushing
                    // get flushed now.
                    //
                    DmCommitRegistry();
                }
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: exiting\r\n");
                goto error_exit;
                break;

            case 1:
                // The subtree RegNotify is now stale and needs to be reregistered.
                subtreeNeedsReg = TRUE;
                
                //
                // A registry change has occurred. Set our timer to
                // go off in 5 seconds. At that point we will do the
                // actual flush.
                //
                //ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 1\r\n");

                DueTime.QuadPart = -5 * 10 * 1000 * 1000;
                if (!SetWaitableTimer(hTimer,
                                      &DueTime,
                                      0,
                                      NULL,
                                      NULL,
                                      FALSE)) {
                    //
                    // Some error occurred, go ahead and flush now.
                    //
                    Status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[DM] DmpRegistryFlusher failed to set lazy flush timer %1!d!\n",
                               Status);
#if DBG
                    CL_ASSERT(FALSE);
#endif
                    DmCommitRegistry();
                    Dirty = FALSE;
                } else {
                    Dirty = TRUE;
                }
                break;

            case 2:
                //
                // The lazy flush timer has gone off, commit the registry now.
                //
                //ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: got 2\r\n");
                DmCommitRegistry();
                Dirty = FALSE;
                break;

            case 3:
                //
                // DmpRoot has been changed, restart the loop with the new handle.
                //
                ClRtlLogPrint(LOG_NOISE,"[DM] DmpRegistryFlusher: restarting\n");                
                // Because the HKEYs have been closed, both RegNotify's are 
                // now stale and need to be reregistered.
                subtreeNeedsReg = topNeedsReg = TRUE;
                break;

            case 4:
                //
                // Since this registry change may have come from a DM update, the
                // parameters under the Cluster key may have changed on another node.
                // Update our in-memory variables to reflect the current registry settings.
                //
                CsRefreshGlobalsFromRegistry();

                // The top RegNotify is now stale and needs to be reregistered.
                topNeedsReg = TRUE;
                break;

            default:
                //
                // Something very odd has happened
                //
                ClRtlLogPrint(LOG_CRITICAL,
                              "[DM] DmpRegistryFlusher got error %1!d! from WaitForMultipleObjects\n",
                              Status);
                goto error_exit;
        } // switch
    } // while TRUE

error_exit:
    if ( hEventTopOnly != NULL )
        CloseHandle(hEventTopOnly);

    if ( hTimer != NULL )
        CloseHandle(hTimer);

    if ( hEventFullSubtree != NULL )
        CloseHandle(hEventFullSubtree);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmpRegistryFlusher exiting abnormally, status %1!d!\n",
                      Status);
    }
    
    return(Status);
}


DWORD
DmJoin(
    IN RPC_BINDING_HANDLE RpcBinding,
    OUT DWORD *StartSeq
    )
/*++

Routine Description:

    Performs the join and synchronization process for the
    database manager.

Arguments:

    RpcBinding - Supplies an RPC binding handle to the Join Master

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;
    DWORD GumSequence;
    DWORD CurrentSequence;


    //
    // Register our update handler.
    //
    GumReceiveUpdates(TRUE,
                      GumUpdateRegistry,
                      DmpUpdateHandler,
                      DmWriteToQuorumLog,
                      sizeof(DmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      DmGumDispatchTable,
                      NULL);

retry:
    CurrentSequence = DmpGetRegistrySequence();

    Status = GumBeginJoinUpdate(GumUpdateRegistry, &GumSequence);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] GumBeginJoinUpdate failed %1!d!\n",
                   Status);
        return(Status);
    }
    /*
    if (CurrentSequence == GumSequence) {
        //
        // Our registry sequence already matches. No need to slurp
        // down a new copy.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[DM] DmJoin: registry database is up-to-date\n");
    } else
    */
    //SS: always get the database irrespective of the sequence numbers
    //this is because transactions may be lost in the log file due
    //to the fact that it is not write through and because of certain
    //race conditions in down notifications vs gum failure conditions.
    {

        ClRtlLogPrint(LOG_NOISE,
                   "[DM] DmJoin: getting new registry database\n");
        Status = DmpSyncDatabase(RpcBinding, NULL);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[DM] DmJoin: DmpSyncDatabase failed %1!d!\n",
                       Status);
            return(Status);
        }
    }

    //
    // Issue GUM join update
    //
    Status = GumEndJoinUpdate(GumSequence,
                              GumUpdateRegistry,
                              DmUpdateJoin,
                              0,
                              NULL);
    if (Status == ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] GumEndJoinUpdate with sequence %1!d! failed with a sequence mismatch\n",
                   GumSequence);
        goto retry;
    } else if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] GumEndJoinUpdate with sequence %1!d! failed with status %2!d!\n",
                   GumSequence,
                   Status);
        return(Status);
    }

    *StartSeq = GumSequence;

    return(ERROR_SUCCESS);

} // DmJoin


/*
DWORD
DmFormNewCluster(
    VOID
    )
{
    DWORD Status;


    //
    // Set the current GUM sequence to be one more than the one in the registry.
    //
    // SS: this will be the one to be used for the next gum transaction,
    // it should be one than the current as the logger discards the first of
    // every record the same transaction number to resolve changes made when the
    // locker/logger node dies in the middle of a transaction
    GumSetCurrentSequence(GumUpdateRegistry, (DmpGetRegistrySequence()+1));

    return(ERROR_SUCCESS);

} // DmFormNewCluster

*/

DWORD
DmFormNewCluster(
    VOID
    )

/*++

Routine Description:

    This routine sets the gum sequence number from the registry before
    logs are unrolled and prepares the quorum object for quorum logging.
    It also hooks events  for node up/down notifications.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   dwError=ERROR_SUCCESS;

    //
    // Set the current GUM sequence to be one more than the one in the registry.
    //
    // SS: this will be the one to be used for the next gum transaction,
    // it should be one than the current as the logger discards the first of
    // every record the same transaction number to resolve changes made when the
    // locker/logger node dies in the middle of a transaction
    GumSetCurrentSequence(GumUpdateRegistry, (DmpGetRegistrySequence()+1));

    //
    // Register our update handler.
    //
    GumReceiveUpdates(FALSE,
                      GumUpdateRegistry,
                      DmpUpdateHandler,
                      DmWriteToQuorumLog,
                      sizeof(DmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      DmGumDispatchTable,
                      NULL);

    //hook the callback for node related notification with the event processor
    if (dwError = DmpHookEventHandler())
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: DmpHookEventHandler failed 0x!08lx!\r\n",
                dwError);
        goto FnExit;
    };

    //get the quorum resource and hook the callback for notification on quorum resource
    if (dwError = DmpHookQuorumNotify())
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: DmpHookQuorumNotify failed 0x%1!08lx!\r\n",
                dwError);
        goto FnExit;
    };


    //SS: if this procedure is successfully completed gpQuoResource is NON NULL.
FnExit:

    return(dwError);

} // DmUpdateFormNewCluster

DWORD
DmUpdateFormNewCluster(
    VOID
    )

/*++

Routine Description:

    This routine updates the cluster registry after the quorum resource has
    been arbitrated as part of forming a new cluster. The database manager
    is expected to read logs or do whatever it needs to update the current
    state of the registry - presumably using logs that are written to the
    quorum resource. This implies that the quorum resource represents some
    form of stable storage.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       dwError=ERROR_SUCCESS;
    BOOL        bAreAllNodesUp = TRUE;    //assume all nodes are up


    //since we havent been logging as yet, take a checkpoint
    if (ghQuoLog)
    {
        //get a checkpoint database
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmUpdateFormNewCluster - taking a checkpoint\r\n");
        //
        //  Chittur Subbaraman (chitturs) - 6/3/99
        //  
        //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
        //  so as to maintain the ordering between this lock and the log lock.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);

        dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0);

        RELEASE_LOCK(gLockDmpRoot);
        
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmUpdateFormNewCluster - Failed to take a checkpoint in the log file\r\n");
            CL_UNEXPECTED_ERROR(dwError);
        }

    }

    //if all nodes are not up, turn quorum logging on
    if ((dwError = OmEnumObjects(ObjectTypeNode, DmpNodeObjEnumCb, &bAreAllNodesUp, NULL))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster : OmEnumObjects returned 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    if (!bAreAllNodesUp)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmUpdateFormNewCluster - some node down\r\n");
        gbIsQuoLoggingOn = TRUE;
    }

    //add a timer to monitor disk space, should be done after we have formed.
    ghDiskManTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!ghDiskManTimer)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    AddTimerActivity(ghDiskManTimer, DISKSPACE_MANAGE_INTERVAL, 1, DmpDiskManage, NULL);

    gbDmInited = TRUE;
    
FnExit:
    return (dwError);
} // DmFormNewCluster


/****
@func   DWORD | DmPauseDiskManTimer| The disk manager timer activity to monitor
        space on the quorum disk is set to a puased state.

@rdesc  Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm   This is called while the quorum resource is being changed.

@xref   <f DmRestartDiskManTimer>
****/
DWORD DmPauseDiskManTimer()
{
    DWORD dwError=ERROR_SUCCESS;

    if (ghDiskManTimer)
        dwError = PauseTimerActivity(ghDiskManTimer);
    return(dwError);
}

/****
@func   DWORD | DmRestartDiskManTimer| This disk manager activity to monitor
        space on the quorum disk is set back to activated state.

@rdesc  Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm   This is called after the quorum resource has been changed.

@xref   <f DmPauseDiskManTimer>
****/
DWORD DmRestartDiskManTimer()
{
    DWORD dwError=ERROR_SUCCESS;
    if (ghDiskManTimer)
        dwError = UnpauseTimerActivity(ghDiskManTimer);
    return(dwError);
}
/****
@func           DWORD | DmRollChanges| This waits for the quorum resource to come online at
                        initialization when a cluster is being formed.  The changes in the quorum
                        log file are applied to the local cluster database.

@rdesc          Returns ERROR_SUCCESS on success.  Else returns the error code.

@comm           This allows for partitions in time.

@xref
****/
DWORD DmRollChanges()
{

    DWORD dwError=ERROR_SUCCESS;


    //before applying the changes validate that this quorum resource is the real one
    if ((dwError = DmpChkQuoTombStone()) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpChkQuoTombStone() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;

    }
    if ((dwError = DmpApplyChanges()) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpApplyChanges() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    //ss: this is here since lm doesnt know about the ownership of quorum
    //disks today
    //call DmpCheckSpace
    if ((dwError = DmpCheckDiskSpace()) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmRollChanges: DmpCheckDiskSpace() failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

FnExit:
    return(dwError);
}



DWORD DmShutdown()
{
    DWORD   dwError;

    ClRtlLogPrint(LOG_NOISE,
        "[Dm] DmShutdown\r\n");

    //this will close the timer handle
    if (ghDiskManTimer) RemoveTimerActivity(ghDiskManTimer);

    if (gpQuoResource)
    {
        // DmFormNewCluster() completed
        //
        // Deregister from any further GUM updates
        //
        //GumIgnoreUpdates(GumUpdateRegistry, DmpUpdateHandler);
    }
    //unhook the callback for notification on quorum resource
    if (dwError = DmpUnhookQuorumNotify())
    {
        //just log the error as we are shutting down
        ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmShutdown: DmpUnhookQuorumNotify failed 0x%1!08lx!\r\n",
                dwError);

    }


    //if the quorum log is open close it
    if (ghQuoLog)
    {
        LogClose(ghQuoLog);
        ghQuoLog = NULL;
        //dont try and log after this
        gbIsQuoLoggingOn = FALSE;
    }

    //close the event created for notification of the quorum resource to
    //go online
    if (ghQuoLogOpenEvent)
    {
        //wait any thread blocked on this
        SetEvent(ghQuoLogOpenEvent);
        CloseHandle(ghQuoLogOpenEvent);
        ghQuoLogOpenEvent = NULL;
    }

    //
    // Shut down the registry flusher thread.
    //
    DmpShutdownFlusher();

    return(dwError);
}


DWORD
DmpStartFlusher(
    VOID
    )
/*++

Routine Description:

    Starts up a new registry flusher thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ThreadId;

    ClRtlLogPrint(LOG_NOISE,"[DM] DmpStartFlusher: Entry\r\n");
    if (!hDmpRegistryFlusher)
    {
        hDmpRegistryEvent = CreateEventW(NULL,FALSE,FALSE,NULL);
        if (hDmpRegistryEvent == NULL) {
            return(GetLastError());
        }
        hDmpRegistryRestart = CreateEventW(NULL,FALSE,FALSE,NULL);
        if (hDmpRegistryRestart == NULL) {
            CloseHandle(hDmpRegistryEvent);
            return(GetLastError());
        }
        hDmpRegistryFlusher = CreateThread(NULL,
                                           0,
                                           DmpRegistryFlusher,
                                           NULL,
                                           0,
                                           &ThreadId);
        if (hDmpRegistryFlusher == NULL) {
            CloseHandle(hDmpRegistryRestart);
            CloseHandle(hDmpRegistryEvent);
            return(GetLastError());
        }
        ClRtlLogPrint(LOG_NOISE,"[DM] DmpStartFlusher: thread created\r\n");

    }
    return(ERROR_SUCCESS);
}


VOID
DmpShutdownFlusher(
    VOID
    )
/*++

Routine Description:

    Cleanly shutsdown the registry flusher thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_NOISE,"[DM] DmpShutdownFlusher: Entry\r\n");

    if (hDmpRegistryFlusher) {
        ClRtlLogPrint(LOG_NOISE,"[DM] DmpShutdownFlusher: Setting event\r\n");
        SetEvent(hDmpRegistryEvent);
        WaitForSingleObject(hDmpRegistryFlusher, INFINITE);
        CloseHandle(hDmpRegistryFlusher);
        hDmpRegistryFlusher = NULL;
        CloseHandle(hDmpRegistryEvent);
        CloseHandle(hDmpRegistryRestart);
        hDmpRegistryEvent = NULL;
        hDmpRegistryRestart = NULL;
    }
}


VOID
DmpRestartFlusher(
    VOID
    )
/*++

Routine Description:

    Restarts the registry flusher thread if DmpRoot is being changed.

    N.B. In order for this to work correctly, gLockDmpRoot MUST be held!

Arguments:

    None.

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_NOISE,"[DM] DmpRestartFlusher: Entry\r\n");
#if NO_SHARED_LOCKS    
    CL_ASSERT(HandleToUlong(gLockDmpRoot.OwningThread) == GetCurrentThreadId());
#else
    CL_ASSERT(HandleToUlong(gLockDmpRoot.ExclusiveOwnerThread) == GetCurrentThreadId());
#endif
    if (hDmpRegistryRestart) { 
        // GorN 11/11/2001 DmpRestart flusher could be called before the hDmpRegistryRestart is set
        SetEvent(hDmpRegistryRestart);
    }
}

DWORD
DmUpdateJoinCluster(
    VOID
    )

/*++

Routine Description:

    This routine is called after a node has successfully joined a cluster.
    It allows the DM to hook callbacks for node up/down notifications and for
    quorum resource change notification.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   dwError=ERROR_SUCCESS;
    BOOL    bAreAllNodesUp = FALSE;  

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmUpdateJoinCluster: Begin.\r\n");

    //if all nodes are not up, turn quorum logging on
    if ((dwError = OmEnumObjects(ObjectTypeNode, DmpNodeObjEnumCb, &bAreAllNodesUp, NULL))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateJoinCluster : OmEnumObjects returned 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    if (!bAreAllNodesUp)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmUpdateJoinCluster - some node down\n");
        gbIsQuoLoggingOn = TRUE;
    }

    //hook the notification for node up/down so we can keep track  of whether logging
    //should be on or off.
    if (dwError = DmpHookEventHandler())
    {
        //BUGBUG SS: do we log this or return this error code
        ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmUpdateJoinCluster: DmpHookEventHandler failed 0x%1!08lx!\r\n",
            dwError);

    }

    //hook the callback for notification on quorum resource
    if (dwError = DmpHookQuorumNotify())
    {
        ClRtlLogPrint(LOG_UNUSUAL,
        "[DM] DmUpdateJoinCluster: DmpHookQuorumNotify failed 0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    if ((dwError = DmpCheckDiskSpace()) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateJoinCluster: DmpCheckDiskSpace() failed 0x%1!08lx!\r\n",
                    dwError);
        goto FnExit;
    }

    //add a timer to monitor disk space, should be done after we have joined.
    ghDiskManTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!ghDiskManTimer)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    //register a periodic timer
    AddTimerActivity(ghDiskManTimer, DISKSPACE_MANAGE_INTERVAL, 1,  DmpDiskManage, NULL);

    gbDmInited = TRUE;
    
FnExit:
    return(dwError);
} // DmUpdateJoinCluster


DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    )
/*++

Routine Description:

    Opens all the standard cluster registry keys. If any of the
    keys are already opened, they will be closed and reopened.

Arguments:

    samDesired - Supplies the access that the keys will be opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD i;
    DWORD Status;

    DmClusterParametersKey = DmGetRootKey( MAXIMUM_ALLOWED );
    if ( DmClusterParametersKey == NULL ) {
        Status = GetLastError();
        CL_UNEXPECTED_ERROR(Status);
        return(Status);
    }

    for (i=0;
         i<sizeof(DmpKeyTable)/sizeof(DMP_KEY_DEF);
         i++) {

        *DmpKeyTable[i].pKey = DmOpenKey(DmClusterParametersKey,
                                         DmpKeyTable[i].Name,
                                         samDesired);
        if (*DmpKeyTable[i].pKey == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Failed to open key %1!ws!, status %2!u!\n",
                       DmpKeyTable[i].Name,
                       Status);
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}


VOID
DmpInvalidateKeys(
    VOID
    )
/*++

Routine Description:

    Invalidates all open cluster registry keys.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDMKEY Key;

    ListEntry = KeyList.Flink;
    while (ListEntry != &KeyList) {
        Key = CONTAINING_RECORD(ListEntry,
                                DMKEY,
                                ListEntry);
        if (!Key->hKey)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpInvalidateKeys %1!ws! Key was deleted since last reopen but not closed\n",
                Key->Name);

            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] THIS MAY BE A KEY LEAK !!\r\n");
        }            
        else
        {
            RegCloseKey(Key->hKey);
            Key->hKey = NULL;
        }            
        ListEntry = ListEntry->Flink;
    }
}


VOID
DmpReopenKeys(
    VOID
    )
/*++

Routine Description:

    Reopens all the keys that were invalidated by DmpInvalidateKeys

Arguments:

    None

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDMKEY Key;
    DWORD Status;

    ListEntry = KeyList.Flink;
    while (ListEntry != &KeyList) {
        Key = CONTAINING_RECORD(ListEntry,
                                DMKEY,
                                ListEntry);
        CL_ASSERT(Key->hKey == NULL);
        Status = RegOpenKeyEx(DmpRoot,
                              Key->Name,
                              0,
                              Key->GrantedAccess,
                              &Key->hKey);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,"[DM] Could not reopen key %1!ws! error %2!d!\n",Key->Name,Status);
            // if the error is file not found, then the key was deleted while the handle
            // was open.  Set the key to NULL
            // If the key is used after delete, it should be validated
            if (Status == ERROR_FILE_NOT_FOUND)
                Key->hKey = NULL;
            else
                CL_UNEXPECTED_ERROR(Status);

        }
        ListEntry = ListEntry->Flink;
    }
}


DWORD
DmpGetRegistrySequence(
    VOID
    )
/*++

Routine Description:

    Returns the current registry sequence stored in the registry.

Arguments:

    None.

Return Value:

    The current registry sequence.

--*/

{
    DWORD Length;
    DWORD Type;
    DWORD Sequence;
    DWORD Status;

    Length = sizeof(Sequence);
    Status = RegQueryValueExW(DmpRoot,
                              CLUSREG_NAME_CLUS_REG_SEQUENCE,
                              0,
                              &Type,
                              (LPBYTE)&Sequence,
                              &Length);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmpGetRegistrySequence failed %1!u!\n",Status);
        Sequence = 0;
    }

    return(Sequence);
}


DWORD DmWaitQuorumResOnline()
/*++

Routine Description:

    Waits for quorum resource to come online.  Used for quorum logging.

Arguments:

    None

Return Value:

    returns ERROR_SUCCESS - if the online event is signaled and the quorum
    notification callback is called.  Else returns the wait status.

--*/
{

    // Wait indefinitely for the quorum resource to go online
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (ghQuoLogOpenEvent)
    {

        dwError  = WaitForSingleObject(ghQuoLogOpenEvent, INFINITE);


        switch(dwError)
        {
            case WAIT_OBJECT_0:
                //everything is fine
                dwError = ERROR_SUCCESS;
                break;

            case WAIT_TIMEOUT:
                //couldnt roll the changes
                dwError = ERROR_TIMEOUT;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmRollChanges: Timed out waiting on dmInitEvent\r\n");
                break;

            case WAIT_FAILED:
                CL_ASSERT(dwError != WAIT_FAILED);
                dwError = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmRollChanges: wait on dmInitEventfailed failed 0x%1!08lx!\r\n",
                    dwError );
                break;
        } // switch
    }

    return(dwError);
}

VOID DmShutdownUpdates(
    VOID
    )
/*++

Routine Description:

    Shutdown DM GUM updates.

Arguments:

    None

Return Value:

    None.
--*/
{
    gbDmpShutdownUpdates = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\cp\store.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    store.c

Abstract:

    Interface for storing and retrieving checkpoint data on the quorum
    disk.

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/
#define QFS_DO_NOT_UNMAP_WIN32 // for CppIsQuorumVolumeOffline 
#include "cpp.h"
#include <ntddvol.h>


DWORD
CppGetCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwId,
    OUT OPTIONAL LPWSTR *pDirectoryName,
    OUT LPWSTR *pFileName,
    IN OPTIONAL LPCWSTR lpszQuorumDir,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Constructs the correct directory and file names for the checkpoint
    file on the quorum disk.

Arguments:

    Resource - Supplies the quorum resource.

    dwId - Supplies the checkpoint ID

    DirectoryName - if present, returns the full name of the directory the
        checkpoint file should be created in. This buffer must be
        freed by the caller with LocalFree

    FileName - Returns the full pathname of the checkpoint file. This buffer must
        be freed by the caller with LocalFree

    lpszQuorumDir - If present, supplies the quorum directory to use.
                If not present, the current quorum directory is used.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPCWSTR ResourceId;
    LPWSTR QuorumDir=NULL;
    DWORD QuorumDirLength=0;
    LPWSTR Dir;
    DWORD DirLen;
    LPWSTR File;
    DWORD FileLen;
    WCHAR Buff[13];     // 8.3 + NULL

    if (lpszQuorumDir == NULL) {
        Status = DmQuerySz( DmQuorumKey,
                            cszPath,
                            &QuorumDir,
                            &QuorumDirLength,
                            &QuorumDirLength);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppGetCheckpointFile failed to get quorum path %1!d!\n",
                       Status);
            return(Status);
        }
    } else {
        QuorumDir = (LPWSTR)lpszQuorumDir;
        QuorumDirLength = (lstrlenW(QuorumDir)+1)*sizeof(WCHAR);
    }

    ResourceId = OmObjectId(Resource);
    DirLen = QuorumDirLength + sizeof(WCHAR) + (lstrlenW(ResourceId)*sizeof(WCHAR));
    Dir = LocalAlloc(LMEM_FIXED, DirLen);
    if (Dir == NULL) {
        if (lpszQuorumDir == NULL) {
            LocalFree(QuorumDir);
        }
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(Dir, QuorumDir);
    // Remove double \\ in path, QON Create directory gets confused.
    if ((lstrlenW(QuorumDir) == 0) || (QuorumDir[lstrlenW(QuorumDir)-1] != '\\')) {
        lstrcatW(Dir, L"\\");
    }
    lstrcatW(Dir, ResourceId);
    if (lpszQuorumDir == NULL) {
        LocalFree(QuorumDir);
    }

    //
    // Now construct the file name
    //
    FileLen = DirLen + sizeof(WCHAR) + sizeof(Buff);
    File = LocalAlloc(LMEM_FIXED, FileLen);
    if (File == NULL) {
        LocalFree(Dir);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if (fCryptoCheckpoint) {
        wsprintfW(Buff, L"%08lx.CPR", dwId);
    } else {
        wsprintfW(Buff, L"%08lx.CPT", dwId);
    }
    lstrcpyW(File, Dir);
    lstrcatW(File, L"\\");
    lstrcatW(File, Buff);

    if (ARGUMENT_PRESENT(pDirectoryName)) {
        *pDirectoryName = Dir;
    } else {
        LocalFree(Dir);
    }
    *pFileName = File;
    return(ERROR_SUCCESS);
}


DWORD
CppReadCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Reads a checkpoint off the quorum disk.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is
        responsible for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the filename where the data should be retrieved.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR FileName = NULL;
    BOOL Success;

    //
    //  Chittur Subbaraman (chitturs) - 8/2/99
    //
    //  Remove gQuoLock acquisition from this function also following
    //  the reasoning outlined in CppWriteCheckpoint function. Note that
    //  the caller of this function will retry on specific errors.
    //  [We have to play these hacks to survive !]
    // 
    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  NULL,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppReadCheckpoint restoring checkpoint from file %1!ws! to %2!ws!\n",
               FileName,
               lpszFileName);

    Success = QfsClRtlCopyFileAndFlushBuffers(FileName, lpszFileName);
    if (!Success) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   FileName,
                   lpszFileName,
                   Status);
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppReadCheckpoint - Was that due to quorum resource not being up ???\n");
    } else {
        Status = ERROR_SUCCESS;
    }


FnExit:
    if (FileName) LocalFree(FileName);
    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;

    return(Status);
}


DWORD
CppWriteCheckpoint(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    )
/*++

Routine Description:

    Writes a checkpoint to the quorum disk.

Arguments:

    Resource - Supplies the resource associated with this data.

    dwCheckpointId - Supplies the unique checkpoint ID describing this data. The caller is responsible
                    for ensuring the uniqueness of the checkpoint ID.

    lpszFileName - Supplies the name of the file with the checkpoint data.

    fCryptoCheckpoint - Indicates if the checkpoint is a crypto checkpoint.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status = ERROR_SUCCESS;
    LPWSTR DirectoryName = NULL;
    LPWSTR FileName = NULL;
    BOOL Success;

    //
    //  Chittur Subbaraman (chitturs) - 8/2/99
    //
    //  Remove gQuoLock acquisition from this function. This is necessary
    //  since this function could get invoked indirectly from 
    //  FmpRmDoInterlockedDecrement (as a part of the synchronous 
    //  notification - Consider a case where the resource is failing
    //  or going offline and you have to rundown the checkpoints as
    //  a part of the synchronous notification. The rundown function
    //  CppRundownCheckpoints needs to wait until the CppRegNotifyThread
    //  completes and the latter could be stuck trying to write a
    //  checkpoint by calling this function) before the "blockingres" count is
    //  decremented. Now the quorum resource offline operation could
    //  be waiting inside FmpRmOfflineResource waiting for this count
    //  to go down to zero and this holds the gQuoLock (so as not to
    //  let any more resources to bump up this count). So if we want
    //  to get the gQuoLock here, we have an easy deadlock. Note that
    //  the caller of this function will retry on specific errors.
    //  [We have to play these hacks to survive !]
    //
    Status = CppGetCheckpointFile(Resource,
                                  dwCheckpointId,
                                  &DirectoryName,
                                  &FileName,
                                  NULL,
                                  fCryptoCheckpoint);
    if (Status != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWriteCheckpoint - CppGetCheckpointFile failed %1!d!\n",
                   Status);
        goto FnExit;
    }
    ClRtlLogPrint(LOG_NOISE,
               "[CP] CppWriteCheckpoint checkpointing file %1!ws! to file %2!ws!\n",
               lpszFileName,
               FileName);

    //
    // Create the directory.
    //
    if (!QfsCreateDirectory(DirectoryName, NULL)) 
    {
        Status = GetLastError();
        if (Status != ERROR_ALREADY_EXISTS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWriteCheckpoint unable to create directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;                       
        }
        else
        {
            //the directory exists, it is alright, set Status to ERROR_SUCCESS
            Status = ERROR_SUCCESS;
        }
        
    } 
    else
    {
        //
        // The directory was newly created. Put the appropriate ACL on it
        // so that only ADMINs can read it.
        //
        Status = QfsSetFileSecurityInfo(DirectoryName,
                                         GENERIC_ALL,
                                         GENERIC_ALL,
                                         0);

        if (Status != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CP] CppWriteCheckpoint unable to set ACL on directory %1!ws!, error %2!d!\n",
                       DirectoryName,
                       Status);
            goto FnExit;
        }
    }
    

    //
    // Copy the file
    //
    Success = QfsClRtlCopyFileAndFlushBuffers(lpszFileName, FileName);
    if (!Success) 
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CP] CppWriteCheckpoint unable to copy file %1!ws! to %2!ws!, error %3!d!\n",
                   lpszFileName,
                   FileName,
                   Status);
    } 

FnExit:

    //clean up
    if (DirectoryName) LocalFree(DirectoryName);
    if (FileName) LocalFree(FileName);

    //
    //  Adjust the return status if the quorum volume is truly offline and that is why this
    //  call failed.
    //
    if ( ( Status != ERROR_SUCCESS ) && ( CppIsQuorumVolumeOffline() == TRUE ) ) Status = ERROR_NOT_READY;
    
    return(Status);
}

BOOL
CppIsQuorumVolumeOffline(
    VOID
    )
/*++

Routine Description:

    Check the state of the quorum volume.

Arguments:

    None
    
Return Value:

    TRUE - Quorum volume is offline.

    FALSE - Quorum volume is online OR it is not possible to determine the quorum volume state

Notes:

    This function is called in private CP functions to check if the quorum volume is offline or not.
    This is necessary since the error codes returned in those functions when they try to
    access the quorum disk when it is offline does not deterministically point out the state
    of the disk. Note that this function will only perform its job when the quorum volume is 
    a physical disk since the storage stack drivers alone implement the IOCTL_IS_VOLUME_OFFLINE
    at the time of this implementation.

--*/

{
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               dwStatus;
    DWORD               cbBytesReturned = 0;
    WCHAR               szFileName[10];
    WCHAR               szQuorumLogPath[MAX_PATH];
    WCHAR               szQuorumDriveLetter[4];
    BOOL                fOffline = FALSE;

    //
    //  Get the quorum log path so that we can get the quorum drive letter off it.
    //
    dwStatus = DmGetQuorumLogPath( szQuorumLogPath, sizeof( szQuorumLogPath ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                     "[CP] CppIsQuorumVolumeOffline: DmGetQuorumLogPath failed, Status = %1!u!...\n",
                     dwStatus);
        goto FnExit;
    }

    dwStatus = QfsIsOnline(szQuorumLogPath, &fOffline);
    if (dwStatus == ERROR_SUCCESS) {
        // MNS Quorum cluster, and quorum is online.
        // Return TRUE, this would retry the checkpoint operation.
        ClRtlLogPrint(LOG_CRITICAL,
                    "[CP] CppIsQuorumVolumeOffline: Quorum is online, Chekpoint should have succeeded\n"); 
        return FALSE;
    }
    else if (dwStatus != ERROR_NO_MATCH) {
        // MNS quorum cluster. But clussvc failed to connect to quorum. Maybe offline.
        return TRUE;
    }
    else {
        // Non MNS cluster. Continue Processing.
        // Resetting the original value.
        fOffline = FALSE;
    }

    //
    //  Create a file name of the form \\.\Q:
    //
    lstrcpyn( szQuorumDriveLetter, szQuorumLogPath, 3 );

    //
    //  See if the drive letter looks syntactically valid. We don't want to proceed further
    //  if the quorum is a network share.
    //
    if ( !ClRtlIsPathValid( szQuorumDriveLetter ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                     "[CP] CppIsQuorumVolumeOffline: Quorum path %1!ws! does not have a drive letter, returning...\n",
                     szQuorumLogPath);
        goto FnExit;
    }

    lstrcpy( szFileName, L"\\\\.\\" );
    lstrcat( szFileName, szQuorumDriveLetter );
   
    //
    //  Open a handle to the quorum volume
    //
    hFile = CreateFile( szFileName,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[CP] CppIsQuorumVolumeOffline: CreateFile for file %1!ws! failed, Status = %2!u!...\n",
                     szFileName,
                     dwStatus);
        goto FnExit;
    }

    //
    //  Check if the volume is offline or not
    //
    if ( !DeviceIoControl( hFile,                   // Device handle
                           IOCTL_VOLUME_IS_OFFLINE, // IOCTL code
                           NULL,                    // In buffer
                           0,                       // In buffer size
                           NULL,                    // Out buffer
                           0,                       // Out buffer size
                           &cbBytesReturned,        // Bytes returned
                           NULL ) )                 // Overlapped
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_GEN_FAILURE )
            ClRtlLogPrint(LOG_UNUSUAL,
                         "[CP] CppIsQuorumVolumeOffline: IOCTL_VOLUME_IS_OFFLINE failed, Status = %1!u!...\n",
                         dwStatus);
        goto FnExit;
    } 

    //
    //  Volume is offline, adjust return status
    //
    fOffline = TRUE;

    ClRtlLogPrint(LOG_NOISE, "[CP] CppIsQuorumVolumeOffline: Quorum volume IS offline...\n");
    
FnExit:
    if ( hFile != INVALID_HANDLE_VALUE ) CloseHandle( hFile );

    return ( fOffline );
}// CppIsQuorumVolumeOffline
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmnotify.c

Abstract:

    Contains notification support for the Configuration Database Manager

    Each call to DmNotifyChangeKey adds a leaf to the notification tree. This
    tree is expected to be sparse, so each node is implemented as a linked list of
    subnodes and a linked list of leaves.

    When a registry modification occurs, the tree is traversed from the root
    to the leaf representing the key. Any leaves along the path are candidates
    for reporting a notification event.

Author:

    John Vert (jvert) 9/18/1996

Revision History:

--*/
#include "dmp.h"

typedef struct _DM_NOTIFY_BRANCH {
    LIST_ENTRY SiblingList;             // Links onto parent's ChildList.
    LIST_ENTRY ChildList;               // Links onto child's SiblingList.
    LIST_ENTRY LeafList;                // Links
    struct _DM_NOTIFY_BRANCH *Parent;   // Parent
    USHORT NameLength;
    WCHAR KeyName[0];                   // Name component (a single keyname, not a path)
} DM_NOTIFY_BRANCH, *PDM_NOTIFY_BRANCH;

typedef struct _DM_NOTIFY_LEAF {
    LIST_ENTRY SiblingList;             // Links onto parent branch's ChildList
    LIST_ENTRY KeyList;                 // Links onto DMKEY.NotifyList
    LIST_ENTRY RundownList;             // Passed into DmNotifyChangeKey, used for rundown
    HDMKEY     hKey;
    DWORD      CompletionFilter;
    DM_NOTIFY_CALLBACK NotifyCallback;
    DWORD_PTR  Context1;
    DWORD_PTR  Context2;
    PDM_NOTIFY_BRANCH Parent;
    BOOL       WatchTree;
} DM_NOTIFY_LEAF, *PDM_NOTIFY_LEAF;

CRITICAL_SECTION NotifyLock;
PDM_NOTIFY_BRANCH NotifyRoot=NULL;

//
// Local function prototypes
//
VOID
DmpPruneBranch(
    IN PDM_NOTIFY_BRANCH Branch
    );

PDM_NOTIFY_BRANCH
DmpFindKeyInBranch(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN OUT LPCWSTR *RelativeName,
    OUT WORD *pNameLength
    );

DWORD
DmpAddNotifyLeaf(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN PDM_NOTIFY_LEAF NewLeaf,
    IN LPCWSTR RelativeName
    );

VOID
DmpReportNotifyWorker(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN LPCWSTR RelativeName,
    IN LPCWSTR FullName,
    IN DWORD Filter
    );


BOOL
DmpInitNotify(
    VOID
    )
/*++

Routine Description:

    Initializes the notification package for the DM.

Arguments:

    None.

Return Value:

    TRUE if successful

    FALSE otherwise

--*/

{
    InitializeCriticalSection(&NotifyLock);

    return(TRUE);
}


DWORD
DmNotifyChangeKey(
    IN HDMKEY hKey,
    IN DWORD CompletionFilter,
    IN BOOL WatchTree,
    IN OPTIONAL PLIST_ENTRY ListHead,
    IN DM_NOTIFY_CALLBACK NotifyCallback,
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2
    )
/*++

Routine Description:

    Registers a notification for a specific registry key. When the
    notification event occurs, ApiReportRegistryNotify will be called.

Arguments:

    hKey - Supplies the registry key handle on which the notification
           should be posted.

    CompletionFilter - Supplies the registry events which should trigger
           the notification.

    WatchTree - Supplies whether or not changes to the children of the specified
           key should trigger the notification.

    ListHead - If present, supplies the listhead that the new notification should be
            queued to. This listhead should be passed to DmRundownList.

    NotifyCallback - Supplies the notification routine that should be called
            when the notification occurs.

    Context1 - Supplies the first DWORD of context to be passed to ApiReportRegistryNotify

    Context2 - Supplies the second DWORD of context to be passed to ApiReportRegistryNotify

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PDMKEY Key;
    PDM_NOTIFY_LEAF Leaf;
    DWORD Status;

    Key = (PDMKEY)hKey;

    Leaf = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_LEAF));
    if (Leaf == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Leaf->hKey = hKey;
    Leaf->CompletionFilter = CompletionFilter;
    Leaf->WatchTree = WatchTree;
    Leaf->NotifyCallback = NotifyCallback;
    Leaf->Context1 = Context1;
    Leaf->Context2 = Context2;

    EnterCriticalSection(&NotifyLock);

    if (NotifyRoot == NULL) {
        //
        // Create notify root here.
        //
        NotifyRoot = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_BRANCH));
        if (NotifyRoot == NULL) {
            LeaveCriticalSection(&NotifyLock);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        InitializeListHead(&NotifyRoot->SiblingList);
        InitializeListHead(&NotifyRoot->ChildList);
        InitializeListHead(&NotifyRoot->LeafList);
        NotifyRoot->Parent = NULL;
    }

    Status = DmpAddNotifyLeaf(NotifyRoot, Leaf, Key->Name);
    if (Status == ERROR_SUCCESS) {
        InsertHeadList(&Key->NotifyList, &Leaf->KeyList);
        if (ARGUMENT_PRESENT(ListHead)) {
            InsertHeadList(ListHead, &Leaf->RundownList);
        } else {
            Leaf->RundownList.Flink = NULL;
            Leaf->RundownList.Blink = NULL;
        }
    } else {
        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);

    return(Status);
}


VOID
DmRundownList(
    IN PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a list of leaves. Used by the API when the notify port
    is closed.

Arguments:

    ListHead - Supplies the head of the rundown list. This is the
        same listhead passed to DmNotifyChangeKey

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;

    //
    // Remove all outstanding DM_NOTIFY_LEAF structures from this list.
    //
    EnterCriticalSection(&NotifyLock);
    while (!IsListEmpty(ListHead)) {
        ListEntry = RemoveHeadList(ListHead);
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 RundownList);
        RemoveEntryList(&Leaf->SiblingList);
        RemoveEntryList(&Leaf->KeyList);

        //
        // Attempt to prune this branch.
        //
        DmpPruneBranch(Leaf->Parent);

        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);
}


VOID
DmpRundownNotify(
    IN PDMKEY Key
    )
/*++

Routine Description:

    Cleans up any outstanding notifications for a key when the
    key is being closed.

Arguments:

    Key - Supplies the key

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;

    //
    // Remove all outstanding DM_NOTIFY_LEAF structures from this key.
    //
    EnterCriticalSection(&NotifyLock);
    while (!IsListEmpty(&Key->NotifyList)) {
        ListEntry = RemoveHeadList(&Key->NotifyList);
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 KeyList);
        RemoveEntryList(&Leaf->SiblingList);
        if (Leaf->RundownList.Flink != NULL) {
            RemoveEntryList(&Leaf->RundownList);
        }

        //
        // Attempt to prune this branch.
        //
        DmpPruneBranch(Leaf->Parent);

        LocalFree(Leaf);
    }

    LeaveCriticalSection(&NotifyLock);

}


VOID
DmpPruneBranch(
    IN PDM_NOTIFY_BRANCH Branch
    )
/*++

Routine Description:

    Checks to see if a branch is empty and should be pruned (freed).
    If the branch is empty, this routine will recursively call itself
    on the parent until a non-empty branch is found.

Arguments:

    Branch - Supplies the branch to be pruned.

Return Value:

    None.

--*/

{
    if ((IsListEmpty(&Branch->ChildList)) &&
        (IsListEmpty(&Branch->LeafList))) {

        //
        // No need to keep this branch around any more. Remove
        // it from its parent, then check to see if the parent
        // should be pruned.
        //
        if (Branch->Parent == NULL) {
            //
            // This is the root, go ahead and free it up too.
            //
            CL_ASSERT(NotifyRoot == Branch);
            NotifyRoot = NULL;

        } else {
            RemoveEntryList(&Branch->SiblingList);
            DmpPruneBranch(Branch->Parent);
        }
        LocalFree(Branch);
    }
}


DWORD
DmpAddNotifyLeaf(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN PDM_NOTIFY_LEAF NewLeaf,
    IN LPCWSTR RelativeName
    )
/*++

Routine Description:

    Adds a leaf to the notification key.

    If the RelativeName is empty, a leaf is created in RootBranch.

    If the RelativeName is not empty, look up its first component
    in RootBranch. If it's not there, create it. Then call ourselves
    recursively after stripping off the first component of RelativeName

Arguments:

    RootBranch - Supplies the root where the leaf is to be added

    NewLeaf - Supplies the new leaf structure

    RelativeName - Supplies the relative name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_BRANCH Branch;
    USHORT NameLength;
    LPCWSTR NextName;

    if (RelativeName[0] == '\0') {
        InsertHeadList(&RootBranch->LeafList, &NewLeaf->SiblingList);
        NewLeaf->Parent = RootBranch;
        return(ERROR_SUCCESS);
    }

    NextName = RelativeName;
    Branch = DmpFindKeyInBranch(RootBranch, &NextName, &NameLength);
    if (Branch == NULL) {
        //
        // No branch existed with this name. Create a new branch.
        //
        Branch = LocalAlloc(LMEM_FIXED, sizeof(DM_NOTIFY_BRANCH) + NameLength*sizeof(WCHAR));
        if (Branch == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        InitializeListHead(&Branch->ChildList);
        InitializeListHead(&Branch->LeafList);
        Branch->Parent = RootBranch;
        Branch->NameLength = NameLength;
        CopyMemory(Branch->KeyName, RelativeName, NameLength*sizeof(WCHAR));
        InsertHeadList(&RootBranch->ChildList, &Branch->SiblingList);
    }

    //
    // Call ourselves recursively on the new branch.
    //
    return(DmpAddNotifyLeaf(Branch, NewLeaf, NextName));
}


VOID
DmpReportNotify(
    IN LPCWSTR KeyName,
    IN DWORD Filter
    )
/*++

Routine Description:

    Interface to the rest of DM to report a notification event on
    a particular key.

Arguments:

    Key - Supplies the key that was modified.

    Filter - Supplies the modification type.

Return Value:

    None.

--*/

{
    if (NotifyRoot == NULL) {
        return;
    }

    EnterCriticalSection(&NotifyLock);

    if (NotifyRoot != NULL) {
        DmpReportNotifyWorker(NotifyRoot,
                              KeyName,
                              KeyName,
                              Filter);
    }

    LeaveCriticalSection(&NotifyLock);

}


VOID
DmpReportNotifyWorker(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN LPCWSTR RelativeName,
    IN LPCWSTR FullName,
    IN DWORD Filter
    )
/*++

Routine Description:

    Recursive worker routine that drills down through the notification
    tree until it reaches the supplied name. Notifications are issued
    for any leaves along the path that match the event.

Arguments:

    RootBranch - Supplies the branch of the tree to start with.

    RelativeName - Supplies the name of the changed key, relative to Branch.

    FullName - Supplies the full name of the changed key.

    Filter - Supplies the type of event.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PDM_NOTIFY_LEAF Leaf;
    PDM_NOTIFY_BRANCH Branch;
    LPCWSTR NextName;
    WORD Dummy;

    //
    // First, issue notifies for any leaves at this node
    //
    ListEntry = RootBranch->LeafList.Flink;
    while (ListEntry != &RootBranch->LeafList) {
        Leaf = CONTAINING_RECORD(ListEntry,
                                 DM_NOTIFY_LEAF,
                                 SiblingList);
        if (Leaf->CompletionFilter & Filter) {
            if ( Leaf->WatchTree ||
                (RelativeName[0] == '\0')) {

                (Leaf->NotifyCallback)(Leaf->Context1,
                                       Leaf->Context2,
                                       Filter,
                                       RelativeName);

            }
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Now search the child list for a subkey that matches the next component
    // of the key name. If there isn't one, we are done. If there is one,
    // call ourselves recursively on it.
    //
    if (RelativeName[0] == '\0') {
        return;
    }
    NextName = RelativeName;
    Branch = DmpFindKeyInBranch(RootBranch, &NextName, &Dummy);
    if (Branch != NULL) {
        DmpReportNotifyWorker(Branch, NextName, FullName, Filter);
    }

}


PDM_NOTIFY_BRANCH
DmpFindKeyInBranch(
    IN PDM_NOTIFY_BRANCH RootBranch,
    IN OUT LPCWSTR *RelativeName,
    OUT WORD *pNameLength
    )
/*++

Routine Description:

    Finds the next component of a key name in a branch.

Arguments:

    RootBranch - Supplies the branch to search.

    RelativeName - Supplies the relative name of the key.
                   Returns the remaining name

    NameLength - Returns the length of the next component.

Return Value:

    Pointer to the found branch if successful.

    NULL otherwise.

--*/

{
    PDM_NOTIFY_BRANCH Branch;
    USHORT NameLength;
    LPCWSTR NextName;
    PLIST_ENTRY ListEntry;

    //
    // Find the first component of the relative name.
    //
    NextName = wcschr(*RelativeName, '\\');
    if (NextName==NULL) {
        NameLength = (USHORT)lstrlenW(*RelativeName);
        NextName = *RelativeName + NameLength;
    } else {
        NameLength = (USHORT)(NextName - *RelativeName);
        ++NextName;
    }
    *pNameLength = NameLength;

    //
    // Search through the root's children to try and find a match on the
    // first component.
    //
    ListEntry = RootBranch->ChildList.Flink;
    while (ListEntry != &RootBranch->ChildList) {
        Branch = CONTAINING_RECORD(ListEntry,
                                   DM_NOTIFY_BRANCH,
                                   SiblingList);
        if ((NameLength == Branch->NameLength) &&
            (wcsncmp(*RelativeName, Branch->KeyName, NameLength)==0)) {

            //
            // We have matched an existing branch. Return success.
            //
            *RelativeName = NextName;
            return(Branch);
        }
        ListEntry = ListEntry->Flink;
    }
    *RelativeName = NextName;

    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmp.h ===
#ifndef _DMP_H
#define _DMP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmp.h

Abstract:

    Private header file for the Config Database Manager (DM) component
    of the NT Cluster Service

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_DM

#define DM_SEPARATE_HIVE 1

// For now is hKey is NULL, we assume that it was deleted while this handle was open
#define ISKEYDELETED(pDmKey)            \
        (!((pDmKey != NULL) && (pDmKey->hKey)))

#define AMIOWNEROFQUORES(pQuoResource)  \
        (NmGetNodeId(NmLocalNode) == NmGetNodeId(pQuoResource->Group->OwnerNode))


//
// DMKEY Structure.
//

typedef struct _DMKEY {
    LIST_ENTRY ListEntry;
    LIST_ENTRY NotifyList;
    HKEY    hKey;
    DWORD   GrantedAccess;
    WCHAR   Name[0];
} DMKEY, *PDMKEY;

//
// Update handler definition
//
DWORD
DmpUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

// JAF: Moved DM_UPDATE_TYPE into dm.h because receive.c needs access to it and doesn't
// have service\dm in its include path.

//
// Key creation update structure.
//
typedef struct _DM_CREATE_KEY_UPDATE {
    LPDWORD lpDisposition;              // only valid on issuing node
    HKEY    *phKey;                     // only valid on issuing node
    DWORD   samDesired;
    DWORD   dwOptions;
    BOOL    SecurityPresent;
} DM_CREATE_KEY_UPDATE, *PDM_CREATE_KEY_UPDATE;


//
// Key deletion update structure.
//
typedef struct _DM_DELETE_KEY_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    WCHAR   Name[0];
} DM_DELETE_KEY_UPDATE, *PDM_DELETE_KEY_UPDATE;

//
// Value set update structure.
//
typedef struct _DM_SET_VALUE_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    DWORD   NameOffset;
    DWORD   DataOffset;
    DWORD   DataLength;
    DWORD   Type;
    WCHAR   KeyName[0];
} DM_SET_VALUE_UPDATE, *PDM_SET_VALUE_UPDATE;

//
// Value delete update structure.
//
typedef struct _DM_DELETE_VALUE_UPDATE {
    LPDWORD lpStatus;                   // only valid on issuing node
    DWORD   NameOffset;
    WCHAR   KeyName[0];
} DM_DELETE_VALUE_UPDATE, *PDM_DELETE_VALUE_UPDATE;

// the record structure for quorum logging


typedef struct _DM_LOGSCAN_CONTEXT{
        DWORD       dwSequence;
        LSN         StartLsn;
        DWORD       dwLastSequence;
}DM_LOGSCAN_CONTEXT, *PDM_LOGSCAN_CONTEXT;
//
// Data local to the DM module.
//
extern HKEY DmpRoot;
extern HKEY DmpRootCopy;
extern LIST_ENTRY KeyList;
extern CRITICAL_SECTION KeyLock;
extern BOOL gbDmpShutdownUpdates;

//disk space requirements
//1M, is lower than this, gracefully shutdown
#define DISKSPACE_LOW_WATERMARK     (1 * 1024 * 1000)
//2M, if lower then send alert
#define DISKSPACE_HIGH_WATERMARK    (5 * 1024 * 1000)
//minimum required to start the cluster service
#define DISKSPACE_INIT_MINREQUIRED  DISKSPACE_HIGH_WATERMARK

#define DISKSPACE_MANAGE_INTERVAL     (5 * 60 * 1000) //5 minute..log management functions are performed

#define DEFAULT_CHECKPOINT_INTERVAL     (4 ) // in hours

typedef struct _LOCALXSACTION{
    DWORD       dwSig;
    DWORD       dwSequence;
    HXSACTION   hLogXsaction;   //the log transaction
    LIST_ENTRY  PendingNotifyListHead;  //the pending notifications to be issued on commit
}LOCALXSACTION, *PLOCALXSACTION;


typedef struct _DM_PENDING_NOTIFY{
    LIST_ENTRY  ListEntry;
    LPWSTR      pszKeyName;
    DWORD       dwFilter;
}DM_PENDING_NOTIFY, *PDM_PENDING_NOTIFY;


#define LOCALXSAC_SIG   'CAXL'

#define GETLOCALXSACTION(pLocalXsaction, hLocalXsaction)    \
        (pLocalXsaction) = (PLOCALXSACTION)(hLocalXsaction); \
        CL_ASSERT((pLocalXsaction)->dwSig == LOCALXSAC_SIG)

//quorum log tombstone
#define     MAXSIZE_RESOURCEID         128
typedef struct _QUO_TOMBSTONE{
       WCHAR    szOldQuoResId[MAXSIZE_RESOURCEID];
       WCHAR    szOldQuoLogPath[MAX_PATH];
}QUO_TOMBSTONE, *PQUO_TOMBSTONE;


//
// Function prototypes local to the DM
//
DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    );

DWORD
DmpGetRegistrySequence(
    VOID
    );

DWORD
DmpSyncDatabase(
    IN RPC_BINDING_HANDLE  RpcBinding,
    IN OPTIONAL LPCWSTR Directory
    );

VOID
DmpUpdateSequence(
    VOID
    );

VOID
DmpInvalidateKeys(
    VOID
    );

VOID
DmpReopenKeys(
    VOID
    );

//
// Notification interface
//
BOOL
DmpInitNotify(
    VOID
    );

VOID
DmpRundownNotify(
    IN PDMKEY Key
    );

VOID
DmpReportNotify(
    IN LPCWSTR KeyName,
    IN DWORD Filter
    );

//for delivering notifications when a transaction is committed
VOID
DmpReportPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN BOOL             bCommit
    );

DWORD
DmpAddToPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN LPCWSTR          pszName,
    IN DWORD            dwFilter
    );

//
// Update handlers
//

DWORD
DmpUpdateCreateKey(
    IN BOOL SourceNode,
    IN PDM_CREATE_KEY_UPDATE CreateUpdate,
    IN LPCWSTR KeyName,
    IN OPTIONAL LPVOID lpSecurityDescriptor
    );

DWORD
DmpUpdateDeleteKey(
    IN BOOL SourceNode,
    IN PDM_DELETE_KEY_UPDATE Update
    );

DWORD
DmpUpdateSetValue(
    IN BOOL SourceNode,
    IN PDM_SET_VALUE_UPDATE Update
    );

DWORD
DmpUpdateDeleteValue(
    IN BOOL SourceNode,
    IN PDM_DELETE_VALUE_UPDATE Update
    );

DWORD
DmpUpdateSetSecurity(
    IN BOOL SourceNode,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN LPCWSTR KeyName,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN LPDWORD pGrantedAccess
    );


//
// For Quorum Logging
//
DWORD DmpChkQuoTombStone(void);

DWORD DmpApplyChanges(void);

DWORD DmpCheckDiskSpace(void);

//diskmanage functions
void
WINAPI DmpDiskManage(
    IN HANDLE   hTimer,
    IN PVOID    pContext
    );

void WINAPI DmpCheckpointTimerCb(
    IN HANDLE hTimer,
    IN PVOID pContext
    );

DWORD DmWriteToQuorumLog(
    IN DWORD        dwGumDispatch,
    IN DWORD        dwSequence,
    IN DWORD        dwType,
    IN PVOID        pData,
    IN DWORD        dwSize
    );

BOOL DmpLogApplyChangesCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         Transaction,
    IN TRTYPE       TransactionType,
    IN const        PVOID pLogData,
    IN DWORD        DataLength
    );

BOOL WINAPI DmpApplyTransactionCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         TransactionId,
    IN const PVOID  pLogData,
    IN DWORD        dwDataLength
    );

DWORD  DmpLogFindStartLsn(
    IN HLOG         hQuoLog,
    OUT LSN         *pStartScanLsn,
    IN OUT LPDWORD  pdwSequence);

BOOL WINAPI DmpLogFindStartLsnCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         Transaction,
    IN TRTYPE       TransactionType,
    IN const        PVOID pLogData,
    IN DWORD        DataLength);

DWORD WINAPI DmpGetSnapShotCb(
    IN LPCWSTR      lpszPathName,
    IN PVOID        pContext,
    OUT LPWSTR      szChkPtFile,
    OUT LPDWORD     pdwChkPtSequence);

DWORD
    DmpHookQuorumNotify(void);

DWORD
    DmpUnhookQuorumNotify(void);


void DmpQuoObjNotifyCb(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification);

DWORD
    DmpHookEventHandler();


BOOL DmpNodeObjEnumCb(
    IN BOOL *pbAreAllNodesUp,
    IN PVOID pContext2,
    IN PVOID pNode,
    IN LPCWSTR szName);

DWORD WINAPI
DmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID pContext
    );

DWORD
DmpLoadHive(
    IN LPCWSTR Path
    );

DWORD
DmpUnloadHive(
    );

DWORD DmpRestoreClusterDatabase(
    IN LPCWSTR  lpszQuoLogPathName 
    );

DWORD DmpLogCheckpointAndBackup(
    IN HLOG     hLogFile,    
    IN LPWSTR   lpszPathName);


DWORD DmpGetCheckpointInterval(
    OUT LPDWORD pdwCheckpointInterval);

DWORD DmpHandleNodeDownEvent(
    IN LPVOID  NotUsed );

//
// registry flusher thread interface.
//
DWORD
DmpStartFlusher(
    VOID
    );

VOID
DmpShutdownFlusher(
    VOID
    );


VOID
DmpRestartFlusher(
    VOID
    );

DWORD
DmpSetDwordInClusterServer(
    LPCWSTR lpszValueName,
    DWORD   dwValue
    );


DWORD DmpGetDwordFromClusterServer(
    IN LPCWSTR lpszValueName,
    OUT LPDWORD pdwValue,
    IN DWORD   dwDefaultValue
    );
    
DWORD
DmpSafeDatabaseCopy(
    IN LPCWSTR  FileName,
    IN LPCWSTR  Path,
    IN LPCWSTR  BkpPath,
    IN BOOL     bDeleteSrcFile
    );

#endif //ifndef _DMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmlocal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmlocal.c

Abstract:

    Contains the routines for local transactions that can be called within
    gum handlers.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"
#include "clusudef.h"

extern BOOL             gbIsQuoLoggingOn;
extern PFM_RESOURCE     gpQuoResource;
extern DWORD            gbIsQuoResOnline;
extern HLOG             ghQuoLog;
#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

/****
@func       HXSACTION | DmBeginLocalUpdate| Called by gum handlers to make consistent
            changes to the local registry.  The log is reset and a start transaction
            record is written to the log, if the log is active.

@comm       When GumHandlers need to update the registry consitently they must use the 
            LocalApis provided by DM.  

@rdesc      Returns a transaction handle. NULL on failure.  Call GetLastError()
            for error code.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
HLOCALXSACTION DmBeginLocalUpdate()
{
    DWORD   dwError=ERROR_SUCCESS;
    LSN     StartXsactionLsn;
    DWORD   dwSequence;
    HXSACTION hXsaction = NULL;
    PLOCALXSACTION  pLocalXsaction = NULL;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmBeginLocalUpdate Entry\r\n");

    //lock the data base, so that a check point is not taken in this duration
    //this lock is released in DmCommitLocalUpdate() or DmAbortLocalUpdate()
    //this lock also prevents the the registry from being flushed.
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    
    //Commit the registry so that it can be restored on  abort
    if ((dwError = DmCommitRegistry()) != ERROR_SUCCESS)
    {
        goto FnExit;
    }
    //allocate memory for local transaction
    pLocalXsaction = LocalAlloc(LMEM_FIXED, sizeof(LOCALXSACTION));
    if (!pLocalXsaction)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pLocalXsaction->dwSig = LOCALXSAC_SIG;
    dwSequence = GumGetCurrentSequence(GumUpdateRegistry);
    pLocalXsaction->dwSequence = dwSequence;
    pLocalXsaction->hLogXsaction = NULL;
    InitializeListHead(&pLocalXsaction->PendingNotifyListHead);
    
    //log the start checkpoint record
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) && ghQuoLog)
    {

        hXsaction = LogStartXsaction(ghQuoLog, dwSequence ,RMRegistryMgr, 0);
        if (!hXsaction)
        {
            dwError = GetLastError();
        }
        pLocalXsaction->hLogXsaction = hXsaction;
    }
FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        if (pLocalXsaction) LocalFree(pLocalXsaction);
        pLocalXsaction = NULL;
        RELEASE_LOCK(gLockDmpRoot);

        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBeginLocalUpdate Exit, pLocalXsaction=0x%1!08lx! Error=0x%2!08lx!\r\n",
                pLocalXsaction, dwError);
        SetLastError(dwError);
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBeginLocalUpdate Exit, pLocalXsaction=0x%1!08lx!\r\n",
                pLocalXsaction);
    }

    return((HLOCALXSACTION)pLocalXsaction);
}



/****
@func       DWORD | DmCommitLocalUpdate| This api must be called to commit
            the changes to the local registry.

@parm       IN HXSACTION | hXsaction | The handle to the transaction to be committed.

@comm       A commit record is written the quorum log if logging is active.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmBeginLocalUpdate> <f DmAbortLocalUpdate>
****/
DWORD DmCommitLocalUpdate(IN HLOCALXSACTION hLocalXsaction)
{
    DWORD dwError=ERROR_SUCCESS;
    PLOCALXSACTION  pLocalXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCommitLocalUpdate Entry\r\n");

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);
    

    //update the gum sequence
    DmpUpdateSequence();

    DmpReportPendingNotifications(pLocalXsaction, TRUE );

    //write a commit record to the quorum log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        CL_ASSERT(pLocalXsaction->hLogXsaction);
        dwError = LogCommitXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 0);
        // 
        //  Chittur Subbaraman (chitturs) - 1/19/99
        //
        pLocalXsaction->hLogXsaction = NULL;
    }

    // 
    //  Chittur Subbaraman (chitturs) - 1/19/99
    //
    //  Make sure that the hLogXsaction memory is freed (even in the case
    //  in which you started a local xsaction and didn't get a chance to
    //  commit it or abort it to the log because quorum logging got turned
    //  off in the middle, for example. This turning off of the logging
    //  in the middle of a transaction could be considered as a bug ?)
    //
    LocalFree( pLocalXsaction->hLogXsaction );
    
    //invalidate the signature and free the transaction structure
    pLocalXsaction->dwSig = 0;
    LocalFree(pLocalXsaction);
    //release the database
    RELEASE_LOCK(gLockDmpRoot);

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCommitLocalUpdate Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);
}


/****
@func       DWORD | DmAbortLocalUpdate| DmAbortLocalUpdate aborts all the changes
            to the local registry associated with this transaction.

@parm       IN HXSACTION | hXsaction | The handle to the transaction to be committed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmBeginLocalUpdate> <f DmCommitLocalUpdate>
****/
DWORD DmAbortLocalUpdate(IN HLOCALXSACTION hLocalXsaction)
{
    DWORD           dwError=ERROR_SUCCESS;
    PLOCALXSACTION  pLocalXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmAbortLocalUpdate Entry\r\n");

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    //write the abort chkpoint record
    //if the locker  node is logging this is valid,
    //if the nonlocker node is logging, and it aborts
    // some other node will inherit the quorum log and
    //checkpoint and hence commit this update.
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        CL_ASSERT(pLocalXsaction->hLogXsaction);
        LogAbortXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 0);
        // 
        //  Chittur Subbaraman (chitturs) - 1/19/99
        //
        pLocalXsaction->hLogXsaction = NULL;
    }

    //SS: if the rollback fails, then we kill ourselves??
    //restore the old registry
    if ((dwError = DmRollbackRegistry()) != ERROR_SUCCESS)
    {
        CL_UNEXPECTED_ERROR(dwError);
    }

    //free any pending notifications that were built up for
    //this transaction
    DmpReportPendingNotifications(pLocalXsaction, FALSE );

    // 
    //  Chittur Subbaraman (chitturs) - 1/19/99
    //
    //  Make sure that the hLogXsaction memory is freed (even in the case
    //  in which you started a local xsaction and didn't get a chance to
    //  commit it or abort it to the log because quorum logging got turned
    //  off in the middle, for example. This turning off of the logging
    //  in the middle of a transaction could be considered as a bug ?)
    //
    LocalFree( pLocalXsaction->hLogXsaction );
    
    //free the transaction structure, it cannot be used any more
    pLocalXsaction->dwSig = 0;
    LocalFree(pLocalXsaction);

    //release the database
    RELEASE_LOCK(gLockDmpRoot);

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmAbortLocalUpdate Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);

}




DWORD
DmLocalSetValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key on the local machine

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DWORD       Status = ERROR_SUCCESS;
    PDMKEY      Key;
    PUCHAR      Dest;
    DWORD       NameLength;
    DWORD       ValueNameLength;
    DWORD       UpdateLength;
    PDM_SET_VALUE_UPDATE Update = NULL;
    PLOCALXSACTION  pLocalXsaction;
    
    Key = (PDMKEY)hKey;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Status = RegSetValueExW(Key->hKey,
                            lpValueName,
                            0,
                            dwType,
                            lpData,
                            cbData);

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_VALUE);

    //write it to the quorum log 
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource)  
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {
        Key = (PDMKEY)hKey;
        NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
        ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
        UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
                       NameLength +
                       ValueNameLength +
                       cbData;


        Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
        if (Update == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }


        Update->lpStatus = NULL;
        Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
        Update->DataOffset = Update->NameOffset + ValueNameLength;
        Update->DataLength = cbData;
        Update->Type = dwType;
        CopyMemory(Update->KeyName, Key->Name, NameLength);

        Dest = (PUCHAR)Update + Update->NameOffset;
        CopyMemory(Dest, lpValueName, ValueNameLength);

        Dest = (PUCHAR)Update + Update->DataOffset;
        CopyMemory(Dest, lpData, cbData);

        
        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateSetValue, Update, UpdateLength) == NULL_LSN)
        {
            Status = GetLastError();
        }
    }        
                            
FnExit:
    if (Update) LocalFree(Update);
    return(Status);

}


HDMKEY
DmLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Creates a key in the local registry. If the key exists, it
    is opened. If it does not exist, it is created.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. 

    samDesired - Supplies desired security access mask

    lpSecurityDescriptor - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY                  Parent;
    PDMKEY                  Key = NULL;
    DWORD                   NameLength;
    DWORD                   Status;
    PDM_CREATE_KEY_UPDATE   CreateUpdate = NULL;
    PVOID                   pBuffer = NULL;
    DWORD                   dwBufLength;
    DWORD                   dwSecurityLength;
    PLOCALXSACTION          pLocalXsaction;
    

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    if (dwOptions == REG_OPTION_VOLATILE)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    Parent = (PDMKEY)hKey;

    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Create the key on the local machine.
    //
    Status = RegCreateKeyExW(Parent->hKey,
                             lpSubKey,
                             0,
                             NULL,
                             0,
                             samDesired,
                             lpSecurityDescriptor,
                             &Key->hKey,
                             lpDisposition);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_NAME);

    //successfully created key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        //get the length of the security structure
        if (ARGUMENT_PRESENT(lpSecurityDescriptor)) 
        {
            dwSecurityLength = GetSecurityDescriptorLength(lpSecurityDescriptor);
        } 
        else 
        {
            dwSecurityLength = 0;
        }

        CreateUpdate = (PDM_CREATE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, sizeof(DM_CREATE_KEY_UPDATE));
        if (CreateUpdate == NULL) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }

        //
        // Issue the update.
        //
        CreateUpdate->lpDisposition = lpDisposition;
        CreateUpdate->phKey = &Key->hKey;
        CreateUpdate->samDesired = samDesired;
        CreateUpdate->dwOptions = dwOptions;

        if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
            CreateUpdate->SecurityPresent = TRUE;
        } else {
            CreateUpdate->SecurityPresent = FALSE;
        }

        //marshall the data, 
        pBuffer = GumMarshallArgs(&dwBufLength,
                            3, 
                            sizeof(DM_CREATE_KEY_UPDATE),
                            CreateUpdate,
                            (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                            Key->Name,
                            dwSecurityLength,
                            lpSecurityDescriptor);
        if (pBuffer)
        {
            CL_ASSERT(pLocalXsaction->hLogXsaction);
            //write it to the logger
            if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
                DmUpdateCreateKey, pBuffer, dwBufLength) == NULL_LSN)
            {   
                Status = GetLastError();
                goto FnExit;
            }                
        }
    }


    

FnExit:    
    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        Key = NULL;
        SetLastError(Status);
    }
    if (CreateUpdate) LocalFree(CreateUpdate);
    if (pBuffer) LocalFree(pBuffer);
    return((HDMKEY)Key);

}


DWORD
DmLocalRemoveFromMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes a string from a REG_MULTI_SZ value.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be removed from the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR Buffer=NULL;
    DWORD BufferSize;
    DWORD DataSize;
    LPWSTR Current;
    DWORD CurrentLength;
    DWORD i;
    LPWSTR Next;
    PCHAR Src, Dest;
    DWORD NextLength;
    DWORD MultiLength;
    


    BufferSize = 0;
    Status = DmQueryString(hKey,
                           lpValueName,
                           REG_MULTI_SZ,
                           &Buffer,
                           &BufferSize,
                           &DataSize);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MultiLength = DataSize/sizeof(WCHAR);
    Status = ClRtlMultiSzRemove(Buffer,
                                &MultiLength,
                                lpString);
    if (Status == ERROR_SUCCESS) {
        //
        // Set the new value back.
        //
        Status = DmLocalSetValue(hLocalXsaction,
                                 hKey,
                                 lpValueName,
                                 REG_MULTI_SZ,
                                 (CONST BYTE *)Buffer,
                                 MultiLength * sizeof(WCHAR));

    } else if (Status == ERROR_FILE_NOT_FOUND) {
        Status = ERROR_SUCCESS;
    }
    if (Buffer) LocalFree(Buffer);
    return(Status);
}

DWORD
DmLocalAppendToMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )

/*++

Routine Description:

    Adds another string to a REG_MULTI_SZ value. If the value does
    not exist, it will be created.

Arguments:

    hLocalXsaction - A handle to a local transaction.
    
    hKey - Supplies the key where the value exists. This key must
           have been opened with KEY_READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be appended to the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ValueLength = 512;
    DWORD ReturnedLength;
    LPWSTR ValueData;
    DWORD StringLength;
    DWORD Status;
    DWORD cbValueData;
    PWSTR s;
    DWORD Type;

    StringLength = (lstrlenW(lpString)+1)*sizeof(WCHAR);
retry:
    ValueData = LocalAlloc(LMEM_FIXED, ValueLength + StringLength);
    if (ValueData == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    cbValueData = ValueLength;
    Status = DmQueryValue(hKey,
                          lpValueName,
                          &Type,
                          (LPBYTE)ValueData,
                          &cbValueData);
    if (Status == ERROR_MORE_DATA) {
        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = cbValueData;
        LocalFree(ValueData);
        goto retry;
    }
    if (Status == ERROR_FILE_NOT_FOUND) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData;

    } else if (Status == ERROR_SUCCESS) {
        //
        // A value already exists. Append our string to the
        // MULTI_SZ.
        //
        s = (PWSTR)((PCHAR)ValueData + cbValueData) - 1;
    } else {
        LocalFree(ValueData);
        return(Status);
    }

    CopyMemory(s, lpString, StringLength);
    s += (StringLength / sizeof(WCHAR));
    *s++ = L'\0';

    Status = DmLocalSetValue(
                        hLocalXsaction,
                        hKey,
                        lpValueName,
                        REG_MULTI_SZ,
                        (CONST BYTE *)ValueData,
                        (DWORD)((s-ValueData)*sizeof(WCHAR)));
    LocalFree(ValueData);

    return(Status);
}

DWORD
DmLocalDeleteKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key from the local registry. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_KEY_UPDATE       Update=NULL;
    DWORD                       Status;
    PLOCALXSACTION              pLocalXsaction;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Key = (PDMKEY)hKey;
    NameLength = (lstrlenW(Key->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    UpdateLength = NameLength + sizeof(DM_DELETE_KEY_UPDATE);

    Update = (PDM_DELETE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);

    if (Update == NULL) 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //dont need an update on status thru marshalled data
    Update->lpStatus = NULL;
    CopyMemory(Update->Name, Key->Name, (lstrlenW(Key->Name) + 1) * sizeof(WCHAR));
    if (Update->Name[0] != L'\0') 
    {
        lstrcatW(Update->Name, L"\\");
    }
    lstrcatW(Update->Name, lpSubKey);
    
    Status = RegDeleteKeyW(DmpRoot, Update->Name);

    if (Status != ERROR_SUCCESS)
        goto FnExit;

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Update->Name, CLUSTER_CHANGE_REGISTRY_NAME);

    //successfully deleted key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource)  
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateDeleteKey, Update, UpdateLength) == NULL_LSN)
        {   
            Status = GetLastError();
            goto FnExit;
        }                

    }


FnExit:
    if (Update) LocalFree(Update);
    return(Status);
}

DWORD
DmLocalDeleteTree(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )
/*++

Routine Description:

    Deletes the specified registry subtree in the local registry. 
    All subkeys are    deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL.
        Any subkeys of the specified key will also be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY Subkey;
    DWORD i;
    DWORD Status;
    LPWSTR KeyBuffer=NULL;
    DWORD MaxKeyLen;
    DWORD NeededSize;

    Subkey = DmOpenKey(hKey,
                       lpSubKey,
                       MAXIMUM_ALLOWED);
    if (Subkey == NULL) {
        Status = GetLastError();
        return(Status);
    }

    //
    // Get the size of name buffer we will need.
    //
    Status = DmQueryInfoKey(Subkey,
                            NULL,
                            &MaxKeyLen,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        DmCloseKey(Subkey);
        return(Status);
    }
    KeyBuffer = LocalAlloc(LMEM_FIXED, (MaxKeyLen+1)*sizeof(WCHAR));
    if (KeyBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        DmCloseKey(Subkey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate the subkeys and apply ourselves recursively to each one.
    //
    i=0;
    do {
        NeededSize = MaxKeyLen+1;
        Status = DmEnumKey(Subkey,
                           i,
                           KeyBuffer,
                           &NeededSize,
                           NULL);
        if (Status == ERROR_SUCCESS) {
            //
            // Call ourselves recursively on this keyname.
            //
            DmLocalDeleteTree(hLocalXsaction, Subkey, KeyBuffer);

        } else {
            //
            // Some odd error, keep going with the next key.
            //
            ++i;
        }

    } while ( Status != ERROR_NO_MORE_ITEMS );

    DmCloseKey(Subkey);

    Status = DmLocalDeleteKey(hLocalXsaction, hKey, lpSubKey);

    if (KeyBuffer != NULL) {
        LocalFree(KeyBuffer);
    }
    return(Status);
}


DWORD
DmLocalDeleteValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    )
{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       ValueNameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_VALUE_UPDATE     Update=NULL;
    PUCHAR                      Dest;
    DWORD                       Status;
    HKEY                        hRegKey;
    PLOCALXSACTION              pLocalXsaction;

    GETLOCALXSACTION(pLocalXsaction, hLocalXsaction);

    Key = (PDMKEY)hKey;

    Status = RegOpenKeyExW(DmpRoot,
                           Key->Name,
                           0,
                           KEY_SET_VALUE,
                           &hRegKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }


    Status = RegDeleteValueW(hRegKey, lpValueName);
    RegCloseKey(hRegKey);

    if (Status!=ERROR_SUCCESS)
        goto FnExit;

    //add the pending notification to be delivered on commit
    DmpAddToPendingNotifications(pLocalXsaction, Key->Name, CLUSTER_CHANGE_REGISTRY_VALUE);

    //successfully created key, write to the log
    if (gbIsQuoLoggingOn && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource) 
        && ghQuoLog && pLocalXsaction->hLogXsaction)
    {

        //if successful and this is the logging node, then log
        // the transaction
        NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
        ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
        UpdateLength = sizeof(DM_DELETE_VALUE_UPDATE) +
                       NameLength +
                       ValueNameLength;

        Update = (PDM_DELETE_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
        if (Update == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }


        Update->lpStatus = NULL;
        Update->NameOffset = FIELD_OFFSET(DM_DELETE_VALUE_UPDATE, KeyName)+NameLength;

        CopyMemory(Update->KeyName, Key->Name, NameLength);

        Dest = (PUCHAR)Update + Update->NameOffset;
        CopyMemory(Dest, lpValueName, ValueNameLength);

        if (LogWriteXsaction(ghQuoLog, pLocalXsaction->hLogXsaction, 
            DmUpdateDeleteValue, Update, UpdateLength) == NULL_LSN)
        {   
            Status = GetLastError();
            goto FnExit;
        }                
    }

FnExit:
    if (Update) LocalFree(Update);
    return(Status);
}


/****
@func       VOID | DmpReportPendingNotifications| This is called
            on commit or abort of a local transactions.  On a commit,
            notifications related to changes within a transaction
            are delivered.

@parm       IN PLOCALXSACTION | pLocalXsaction| A pointer to the local
            transation context.

@parm       IN BOOL | bCommit| Set to TRUE when the transaction is 
            commited.

@comm       The pending notification structure associated with the
            transaction is cleaned up.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
VOID
DmpReportPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN BOOL             bCommit
    )
{
    PLIST_ENTRY         pListEntry;
    PDM_PENDING_NOTIFY  pDmPendingNotify;
    
    pListEntry = pLocalXsaction->PendingNotifyListHead.Flink;

    //remove the entries and proces them one by one
    //free them when done
    while (pListEntry != &pLocalXsaction->PendingNotifyListHead)
    {
        pDmPendingNotify = CONTAINING_RECORD(pListEntry, DM_PENDING_NOTIFY, ListEntry);
        // if transaction is commited
        if (bCommit)
            DmpReportNotify(pDmPendingNotify->pszKeyName, pDmPendingNotify->dwFilter);               
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDmPendingNotify->ListEntry );
        LocalFree(pDmPendingNotify->pszKeyName);
        LocalFree(pDmPendingNotify);
    }
    return;
}


/****
@func       DWORD | DmpAddToPendingNotifications| This is called
            by the DmLocal Api's to queue registry notifications
            on success.  The notifications are delivered or 
            thrown away depending on whether the transaction commits
            or aborts.

@parm       IN PLOCALXSACTION | pLocalXsaction| A pointer to the local
            transation context.

@parm       IN LPCWSTR | pszName| A pointer to the registry key name.

@parm       IN DWORD | dwFilter | The filters associated with the notification.

@comm       A new pending notification structure is created and associated 
            with the transaction.

@xref       <f DmAbortLocalUpdate> <f DmCommitLocalUpdate>
****/
DWORD    
DmpAddToPendingNotifications(
    IN PLOCALXSACTION   pLocalXsaction,
    IN LPCWSTR          pszName,
    IN DWORD            dwFilter
)    
{
    DWORD               dwError = ERROR_SUCCESS;
    PDM_PENDING_NOTIFY  pDmPendingNotify;

    pDmPendingNotify = LocalAlloc(LPTR, sizeof(DM_PENDING_NOTIFY));
    if (!pDmPendingNotify)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    pDmPendingNotify->pszKeyName = LocalAlloc(LMEM_FIXED, 
                        ((lstrlenW(pszName) + 1 ) * sizeof(WCHAR)));
    if (!pDmPendingNotify->pszKeyName)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //initialize the structure
    lstrcpyW(pDmPendingNotify->pszKeyName, pszName);
    pDmPendingNotify->dwFilter = dwFilter;
    InitializeListHead(&pDmPendingNotify->ListEntry);

    //add to the list
    InsertTailList(&pLocalXsaction->PendingNotifyListHead, 
        &pDmPendingNotify->ListEntry);    


FnExit:
    return(dwError);
}

/****
@func       DWORD | DmAmITheOwnerOfTheQuorumResource| This harmless
            function is used by regroup module to determine whether
            a node thinks that it is the owner of the quorum resource or not.
****/
DWORD DmAmITheOwnerOfTheQuorumResource() {
  return gpQuoResource 
      && gpQuoResource->Group 
      && gbIsQuoResOnline 
      && AMIOWNEROFQUORES(gpQuoResource);
}



DWORD
DmRtlLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY * phkResult,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Wrapper function for DmLocalCreateKey to be used with CLRtl* functions.

--*/    
{   
    DWORD   status;

    *phkResult= DmLocalCreateKey(
                    hLocalXsaction,
                    hKey,
                    lpSubKey,
                    dwOptions,
                    samDesired,
                    lpSecurityDescriptor,
                    lpDisposition
                    );
    if(* phkResult == NULL)
        status=GetLastError();
    else
        status=ERROR_SUCCESS;
    return status;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmlog.c

Abstract:

    Contains the quorum logging related functions for
    the cluster registry.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"
#include "tchar.h"
#include "clusudef.h"
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

//global static data
HLOG                ghQuoLog=NULL;  //pointer to the quorum log
DWORD               gbIsQuoResOnline = FALSE;
DWORD               gbNeedToCheckPoint = FALSE;
DWORD               gbIsQuoResEnoughSpace = TRUE;
HLOG                ghNewQuoLog = NULL; //pointer to the new quorum resource
//global data
extern HANDLE           ghQuoLogOpenEvent;
extern BOOL             gbIsQuoLoggingOn;
extern HANDLE           ghDiskManTimer;
extern HANDLE           ghCheckpointTimer;
extern PFM_RESOURCE     gpQuoResource;  //set when DmFormNewCluster is complete
extern BOOL             gbDmInited;
#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

//forward definitions
void DmpLogCheckPointCb();

/****
@func       DWORD | DmPrepareQuorumResChange| When the quorum resource is changed,
            the FM invokes this api on the owner node of the new quorum resource
            to create a new quorum log file.

@parm       IN PVOID | pResource | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       When a quorum resource is changed, the fm calls this funtion before it
            updates the quorum resource.  If a new log file needs to be created,
            a checkpoint is taken.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmPrepareQuorumResChange(
    IN PVOID    pResource,
    IN LPCWSTR  lpszPath,
    IN DWORD    dwMaxQuoLogSize)
{
    DWORD           dwError=ERROR_SUCCESS;
    PFM_RESOURCE    pNewQuoRes;
    WCHAR           szFileName1[MAX_PATH];  //for new quorum log,for tombstonefile
    LSN             FirstLsn;
    WCHAR           szFileName2[MAX_PATH];  //for old quorum log, for temp tombstone
    DWORD           dwCurLogSize;
    DWORD           dwMaxLogSize;
    DWORD           dwChkPtSequence;
    WIN32_FIND_DATA FindData;
    QfsHANDLE      hSrchTmpFiles;

    pNewQuoRes = (PFM_RESOURCE)pResource;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange - Entry\r\n");


    //the resource is already online at this point
    //if the directory doesnt exist create it
    dwError = QfsClRtlCreateDirectory(lpszPath);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Failed to create directory, Status=%1!u!\r\n",
            dwError);
        goto FnExit;
    }

    lstrcpyW(szFileName1, lpszPath);
    lstrcatW(szFileName1, cszQuoFileName);

    //if the log file is open here
    //this implies that the new quorum resource is the on the same node
    //as the old one
    if (ghQuoLog)
    {
        LogGetInfo(ghQuoLog, szFileName2, &dwCurLogSize, &dwMaxLogSize);

        //if the file is the same as the new log file, simply set the size
        if (!lstrcmpiW(szFileName2, szFileName1))
        {
            LogSetInfo(ghQuoLog, dwMaxQuoLogSize);
            ghNewQuoLog = ghQuoLog;
            goto FnExit;
        }
    }


    //delele all the quorum logging related files
    //delete the log if it exits
    QfsDeleteFile(szFileName1);
    //delete all checkpoint files
    lstrcpyW(szFileName2, lpszPath);
    lstrcatW(szFileName2, L"*.tmp");
    hSrchTmpFiles = QfsFindFirstFile(szFileName2, & FindData);
    if (QfsIsHandleValid(hSrchTmpFiles))
    {
        lstrcpyW(szFileName2, lpszPath);
        lstrcatW(szFileName2, FindData.cFileName);
        QfsDeleteFile(szFileName2);

        while (QfsFindNextFile( hSrchTmpFiles, & FindData))
        {
            lstrcpyW(szFileName2, lpszPath);
            lstrcatW(szFileName2, FindData.cFileName);
            QfsDeleteFile(szFileName2);
        }
        QfsFindClose(hSrchTmpFiles);
    }

    dwError = QfsSetFileSecurityInfo(lpszPath, 
        GENERIC_ALL, GENERIC_ALL, 0); 
    
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - ClRtlSetObjSecurityInfo Failed, Status=%1!u!\r\n",
            dwError);
        goto FnExit;
    }
    //open the new log file

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange: the name of the quorum file is %1!ls!\r\n",
        szFileName1);

    //open the log file
    ghNewQuoLog = LogCreate(szFileName1, dwMaxQuoLogSize,
        (PLOG_GETCHECKPOINT_CALLBACK)DmpGetSnapShotCb, NULL,
        TRUE, &FirstLsn);

    if (!ghNewQuoLog)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmPrepareQuorumResChange: Quorum log could not be opened, error = %1!u!\r\n",
            dwError);
        CsLogEventData1( LOG_CRITICAL,
                         CS_DISKWRITE_FAILURE,
                         sizeof(dwError),
                         &dwError,
                         szFileName1 );
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
    }

    //create a checkpoint in the new place
    dwError = DmpGetSnapShotCb(lpszPath, NULL, szFileName1, &dwChkPtSequence);
    if (dwError != ERROR_SUCCESS)
    {
        CL_LOGFAILURE(dwError);
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
        goto FnExit;
    }

    dwError = LogCheckPoint(ghNewQuoLog, TRUE, szFileName1, dwChkPtSequence);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - failed to take chkpoint, error = %1!u!\r\n",
            dwError);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmPrepareQuorumResChange - checkpoint taken\r\n");


    //
    // Call the checkpoint manager to copy over any checkpoint files
    //
    if ( !( CsNoQuorum ) || ( gpQuoResource->State == ClusterResourceOnline ) )
    {
        dwError = CpCopyCheckpointFiles(lpszPath, FALSE);
        if (dwError != ERROR_SUCCESS)
        {
            goto FnExit;
        }
    } else
    {
        ClRtlLogPrint(LOG_NOISE, 
            "[DM] DmPrepareQuorumResChange: Skip copying checkpoint files from old quorum, FixQuorum=%1!u!, QuoState=%2!u!...\n",
            CsNoQuorum,
            gpQuoResource->State);       
    }

    //create the tombstone and tmp file names
    lstrcpyW(szFileName1, lpszPath);
    lstrcatW(szFileName1, cszQuoTombStoneFile);

    lstrcpyW(szFileName2, lpszPath);
    lstrcatW(szFileName2, cszTmpQuoTombStoneFile);

    //rename the quorum tomstone file,it if it exists
    if (!QfsMoveFileEx(szFileName1, szFileName2,
        MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
    {
        //this may fail if the tombstone doesnt exist, ignore error
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmPrepareQuorumResChange:tombstone doesnt exist,movefilexW failed, error=0x%1!08lx!\r\n",
            GetLastError());
    }

FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        //if not sucess, clean up the new file
        if (ghNewQuoLog)
        {
            LogClose(ghNewQuoLog);
            ghNewQuoLog = NULL;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Exit, error=0x%1!08lx!\r\n",
            dwError);
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmPrepareQuorumResChange - Exit, status=0x%1!08lx!\r\n",
            dwError);
    }

    return(dwError);

} // DmPrepareQuorumResChange

/****
@func       void | DmDwitchToNewQuorumLog| This is called to switch to a new
            quorum log when the quorum resource is changed.

@comm       When a quorum resource is successfully changed, this function is
            to switch quorum logs.  The synchronous notifications for the old resource
            are unhooked and those for the new resource file are hooked.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
void DmSwitchToNewQuorumLog(
    IN LPCWSTR lpszQuoLogPath,
    IN DWORD dwNewQuorumResourceCharacteristics)
{
    WCHAR   szTmpQuoTombStone[MAX_PATH];
    DWORD   dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmSwitchQuorumLogs - Entry\r\n");

    //unhook notifications with the old quorum resource
    DmpUnhookQuorumNotify();
    //ask the dm to register with the new quorum resource
    DmpHookQuorumNotify();

    //if the new log file exists... this is the owner of the new quorum resource.
    //the new log file may be the same as the old one
    if (ghNewQuoLog)
    {
        if (ghQuoLog && (ghQuoLog != ghNewQuoLog))
        {
            LogClose(ghQuoLog);
           //take another checkpoint to the new quorum file,
           //so that the last few updates make into it
            if ((dwError = LogCheckPoint(ghNewQuoLog, TRUE, NULL, 0))
                != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmSwitchQuorumLogs - Failed to take a checkpoint\r\n");
                CL_UNEXPECTED_ERROR(dwError);
            }
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmSwitchQuorumLogs - taken checkpoint\r\n");

            ghQuoLog = NULL;
        }
        ghQuoLog = ghNewQuoLog;
        ghNewQuoLog = NULL;

        // if the old tombstome was replace by a tmp file at the beginning
        //of change quorum resource delete it now
        //get the tmp file for the new quorum resource
        lstrcpyW(szTmpQuoTombStone, lpszQuoLogPath);
        lstrcatW(szTmpQuoTombStone, cszTmpQuoTombStoneFile);
        QfsDeleteFile(szTmpQuoTombStone);
        
    }
    else
    {
        //if the old log file is open, owner of the old quorum resource
        if (ghQuoLog)
        {
            LogClose(ghQuoLog);
            ghQuoLog = NULL;
        }
    }

    if (FmDoesQuorumAllowLogging(dwNewQuorumResourceCharacteristics) != ERROR_SUCCESS)
    {
        //this is not enough to ensure the dm logging will cease
        //the ghQuoLog parameter must be NULL
        CsNoQuorumLogging = TRUE;
        if (ghQuoLog)
        {
            LogClose(ghQuoLog);
            ghQuoLog = NULL;
        }                
    } else if ( !CsUserTurnedOffQuorumLogging )
    {
        //
        //  If the user did not turn off quorum logging explicitly, then turn it back on since
        //  the new quorum resource is not local quorum.
        //
        CsNoQuorumLogging = FALSE;    
    }

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmSwitchQuorumLogs - Exit!\r\n");
    return;
}

/****
@func       DWORD | DmReinstallTombStone| If the change to a new quorum
            resource fails, the new log is closed and the tombstone is
            reinstalled.

@parm       IN LPCWSTR | lpszQuoLogPath | The path for maintenance cluster files.

@comm       The old quorum log file is deleted and a tomstone file is created in its
            place.  If this tombstone file is detected in the quorum path, the node
            is not allowed to do a form.  It must do a join to find about the new
            quorum resource from the node that knows about the most recent quorum
            resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmReinstallTombStone(
    IN LPCWSTR  lpszQuoLogPath
)
{

    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szQuoTombStone[MAX_PATH];
    WCHAR           szTmpQuoTombStone[MAX_PATH];



    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmReinstallTombStone - Entry\r\n");

    if (ghNewQuoLog)
    {
        //get the tmp file for the new quorum resource
        lstrcpyW(szTmpQuoTombStone, lpszQuoLogPath);
        lstrcatW(szTmpQuoTombStone, cszTmpQuoTombStoneFile);

        //create the tombstone file or replace the previous one with a new one
        lstrcpyW(szQuoTombStone, lpszQuoLogPath);
        lstrcatW(szQuoTombStone, cszQuoTombStoneFile);

        //restore the tombstone
        if (!QfsMoveFileEx(szTmpQuoTombStone, szQuoTombStone,
            MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
        {
            //this may fail if the tombstone doesnt exist, ignore error
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmReinstallTombStone :Warning-MoveFileExW failed, error=0x%1!08lx!\r\n",
                GetLastError());
        }
        // if this is not the same as the old log file, close it
        if (ghNewQuoLog != ghQuoLog)
        {
            LogClose(ghNewQuoLog);
        }
        ghNewQuoLog = NULL;
    }

    return(dwError);
}


/****
@func       DWORD | DmCompleteQuorumResChange| This is called on the quorum resource
            if the old quorum log file is not the same as the new one.

@parm       IN PVOID | pOldQuoRes | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       The old quorum log file is deleted and a tomstone file is created in its
            place.  If this tombstone file is detected in the quorum path, the node
            is not allowed to do a form.  It must do a join to find about the new
            quorum resource from the node that knows about the most recent quorum
            resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD DmCompleteQuorumResChange(
    IN LPCWSTR  lpszOldQuoResId,
    IN LPCWSTR  lpszOldQuoLogPath
)
{
    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szOldQuoFileName[MAX_PATH];
    QfsHANDLE       hTombStoneFile;
    WCHAR           szQuorumTombStone[MAX_PATH];
    PQUO_TOMBSTONE  pTombStone = NULL;
    DWORD           dwBytesWritten;
    WIN32_FIND_DATA FindData;
    QfsHANDLE       hSrchTmpFiles;



    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCompleteQuorumResChange - Entry\r\n");

    //the old log file name
    lstrcpyW(szOldQuoFileName, lpszOldQuoLogPath);
    lstrcatW(szOldQuoFileName, cszQuoFileName);

    //create the tombstone file or replace the previous one with a new one
    lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
    lstrcatW(szQuorumTombStone, cszQuoTombStoneFile);

    pTombStone = LocalAlloc(LMEM_FIXED, sizeof(QUO_TOMBSTONE));
    if (!pTombStone)
    {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;
    }
    hTombStoneFile = QfsCreateFile(szQuorumTombStone,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL);

    if (!QfsIsHandleValid(hTombStoneFile) )
    {
        //dont return failure
        CL_LOGFAILURE(dwError);
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;

    }
    //write the old quorum path to it.
    lstrcpyn(pTombStone->szOldQuoResId, lpszOldQuoResId, MAXSIZE_RESOURCEID);
    lstrcpy(pTombStone->szOldQuoLogPath, lpszOldQuoLogPath);

    //write the tombstones
    if (! QfsWriteFile(hTombStoneFile, pTombStone, sizeof(QUO_TOMBSTONE),
        &dwBytesWritten, NULL))
    {
        CL_LOGFAILURE(GetLastError());
        CsLogEvent(LOG_UNUSUAL, DM_TOMBSTONECREATE_FAILED);
        goto DelOldFiles;
    }

    CL_ASSERT(dwBytesWritten == sizeof(QUO_TOMBSTONE));

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmCompleteQuorumResChange: tombstones written\r\n");

DelOldFiles:
    //
    //delete the old quorum files
    //
    if (!QfsDeleteFile(szOldQuoFileName))
        CL_LOGFAILURE(GetLastError());

    //delele other tmp files in there
    lstrcpyW(szOldQuoFileName, lpszOldQuoLogPath);
    lstrcatW(szOldQuoFileName, L"*.tmp");
    hSrchTmpFiles = QfsFindFirstFile(szOldQuoFileName, & FindData);
    if (QfsIsHandleValid(hSrchTmpFiles))
    {
        lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
        lstrcatW(szQuorumTombStone, FindData.cFileName);
        QfsDeleteFile(szQuorumTombStone);

        while (QfsFindNextFile( hSrchTmpFiles, & FindData))
        {
            lstrcpyW(szQuorumTombStone, lpszOldQuoLogPath);
            lstrcatW(szQuorumTombStone, FindData.cFileName);
            QfsDeleteFile(szQuorumTombStone);
        }
        QfsFindClose(hSrchTmpFiles);
    }

    //
    // Clean up the old registry checkpoint files
    //
    CpCompleteQuorumChange(lpszOldQuoLogPath);

    QfsCloseHandleIfValid(hTombStoneFile);
    if (pTombStone) LocalFree(pTombStone);
    return(dwError);
}

/****
@func       DWORD | DmWriteToQuorumLog| When a transaction to the cluster database
            is completed successfully, this function is invoked.

@parm       DWORD | dwSequence | The sequnece number of the transaction.

@parm       PVOID | pData | A pointer to a record data.

@parm       DWORD | dwSize | The size of the record data in bytes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/
DWORD WINAPI DmWriteToQuorumLog(
    IN DWORD dwGumDispatch,
    IN DWORD dwSequence,
    IN DWORD dwType,
    IN PVOID pData,
    IN DWORD dwSize)
{
    DWORD dwError=ERROR_SUCCESS;

    //dmupdate is coming before the DmUpdateJoinCluster is called.
    //at this point we are not the owner of quorum in any case
    
    if (!gpQuoResource)
        goto FnExit;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmWriteToQuorumLog Entry Seq#=%1!u! Type=%2!u! Size=%3!u!\r\n",
         dwSequence, dwType, dwSize);
    //
    //  Chittur Subbaraman (chitturs) - 6/3/99
    //  
    //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
    //  so as to maintain the ordering between this lock and the log lock.
    //
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);
    
    //if I am the owner of the quorum logs, just write the record
    if (gbIsQuoLoggingOn && ghQuoLog && gbIsQuoResOnline && AMIOWNEROFQUORES(gpQuoResource))
    {
        if (dwGumDispatch == PRE_GUM_DISPATCH)
        {
            //make sure the logger has enough space to commit this else
            //refuse this GUM transaction
            dwError = LogCommitSize(ghQuoLog, RMRegistryMgr, dwSize);
            if (dwError != ERROR_SUCCESS)
            {
                if (dwError == ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE)
                {
                    //map error
                    CL_LOGCLUSERROR(LM_DISKSPACE_LOW_WATERMARK);
                    gbIsQuoResEnoughSpace = FALSE;
                }
            }
            else
            {
                if (!gbIsQuoResEnoughSpace) gbIsQuoResEnoughSpace = TRUE;
            }
        }
        else if (dwGumDispatch == POST_GUM_DISPATCH)
        {
            if (LogWrite(ghQuoLog, dwSequence, TTCompleteXsaction, RMRegistryMgr,
                dwType, pData, dwSize) == NULL_LSN)
            {
                dwError = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmWriteToQuorumLog failed, error=0x%1!08lx!\r\n",
                    dwError);
            }
        }
    }
    
    RELEASE_LOCK(gLockDmpRoot);
    
FnExit:
    return (dwError);

}

/****
@func   DWORD | DmpChkQuoTombStone| This checks the quorum logs to ensure
        that it is the most recent one before rolling in the changes.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@comm   This looks for the tombstone file and if one exists.  It checks if this
        quorum file is marked as dead in there.

@xref   <f FmSetQuorumResource>
****/
DWORD DmpChkQuoTombStone()
{
    DWORD           dwError=ERROR_SUCCESS;
    WCHAR           szQuorumLogPath[MAX_PATH];
    WCHAR           szQuorumTombStone[MAX_PATH];
    QfsHANDLE      hTombStoneFile = QfsINVALID_HANDLE_VALUE;
    PQUO_TOMBSTONE  pTombStone = NULL;
    DWORD           dwBytesRead;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpChkQuoTombStone - Entry\r\n");

    dwError = DmGetQuorumLogPath(szQuorumLogPath, sizeof(szQuorumLogPath));
    if (dwError)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - DmGetQuorumLogPath failed,error=0x%1!08lx!\n",
            dwError);
        goto FnExit;
    }

    lstrcpyW(szQuorumTombStone, szQuorumLogPath);
    lstrcatW(szQuorumTombStone,  L"\\quotomb.stn");

    pTombStone = LocalAlloc(LMEM_FIXED, sizeof(QUO_TOMBSTONE));
    if (!pTombStone)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    hTombStoneFile = QfsCreateFile(szQuorumTombStone,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

    if (!QfsIsHandleValid(hTombStoneFile) )
    {
        //there is no tombstone file, not a problem-we can proceed with the form
        goto FnExit;
    }

    //found a tombstone file
    //read the file
    if (! QfsReadFile(hTombStoneFile, pTombStone, sizeof(QUO_TOMBSTONE),
        &dwBytesRead, NULL))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - Couldn't read the tombstone,error=0x%1!08lx!\n",
            dwError);
        //dont return an error, we can proceed with form??
        goto FnExit;
    }

    if (dwBytesRead != sizeof(QUO_TOMBSTONE))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone - Couldn't read the entire tombstone\r\n");
        //dont return an error, we can proceed with form??
        goto FnExit;
    }


    if ((!lstrcmpW(OmObjectId(gpQuoResource), pTombStone->szOldQuoResId))
        && (!lstrcmpiW(szQuorumLogPath, pTombStone->szOldQuoLogPath)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone:A tombstone for this resource, and quorum log file was found here.\r\n");
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone:This is node is only allowed to do a join, make sure another node forms\r\n");
        //log something into the eventlog
        CL_LOGCLUSERROR(SERVICE_MUST_JOIN);
        //we exit with succes because this is by design and we dont want
        //clusprxy to retry starting unnecessarily
        ExitProcess(dwError);
        goto FnExit;
    }
    else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpChkQuoTombStone: Bogus TombStone ??\r\n");
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif
        goto FnExit;

    }
FnExit:
    QfsCloseHandleIfValid(hTombStoneFile);
    if (pTombStone) LocalFree(pTombStone);
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpChkQuoTombStone: Exit, returning 0x%1!08lx!\r\n",
        dwError);
    return(dwError);
}


/****
@func       DWORD | DmpApplyChanges| When dm is notified that the cluster form is
            occuring, it calls DmpApplyChanges to apply the quorum logs to the
            cluster database.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This opens the quorum file.  Note that it doesnt close the quorum file.

@xref
****/
DWORD DmpApplyChanges()
{
    LSN                 FirstLsn;
    DWORD               dwErr = ERROR_SUCCESS;
    DWORD               dwSequence;
    DM_LOGSCAN_CONTEXT  DmAppliedChangeContext;


    if (ghQuoLog == NULL)
    {
        return(ERROR_QUORUMLOG_OPEN_FAILED);
    }
    //find the current sequence number from the registry
    dwSequence = DmpGetRegistrySequence();
    ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: The current registry sequence number %1!d!\r\n",
            dwSequence);

    // upload a database if the current sequence number is lower or equal to
    // the one in the database OR if the user is forcing a restore database
    // operation.
    // find the lsn of the record from which we need to start applying changes
    // if null there are no changes to apply
    dwErr = DmpLogFindStartLsn(ghQuoLog, &FirstLsn, &dwSequence);

    if (dwErr != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: DmpLogFindStartLsn failed, error=0x%1!08lx!\r\n",
            dwErr);
        goto FnExit;
    }

    //dwSequence now contains the current sequence number in the registry
    DmAppliedChangeContext.dwSequence = dwSequence;

    if (FirstLsn != NULL_LSN)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpApplyChanges: The LSN of the record to apply changes from 0x%1!08lx!\r\n",
            FirstLsn);

        if (dwErr = LogScan(ghQuoLog, FirstLsn, TRUE,(PLOG_SCAN_CALLBACK)DmpLogApplyChangesCb,
            &DmAppliedChangeContext) != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpApplyChanges: LogScan failed, error=0x%1!08lx!\r\n",
                dwErr);
        }
        //if the more changes have been applied
        if (DmAppliedChangeContext.dwSequence != dwSequence)
        {
            //set the gum sequence number to the trid that has been applied
            GumSetCurrentSequence(GumUpdateRegistry, DmAppliedChangeContext.dwSequence);
            //update the registry with this sequence number
            DmpUpdateSequence();
            //set the gum sequence number to one higher for the next transaction
            GumSetCurrentSequence(GumUpdateRegistry,
                (DmAppliedChangeContext.dwSequence + 1));

            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpApplyChanges: Gum sequnce number set to = %1!d!\r\n",
                (DmAppliedChangeContext.dwSequence + 1));

        }
    }
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpApplyChanges: Exit, returning 0x%1!08lx!\r\n",
        dwErr);
    return(dwErr);
}


/****
@func   DWORD | DmpFindStartLsn| Uploads the last checkpoint from the
        quorum and returns the LSN of the record from which the changes
        should be applied.

@parm   IN HLOG | hQuoLog | the log file handle.

@parm   OUT LSN *| pStartScanLsn | Returns the LSN of the record in the
        quorum log from which changes must be applied is returned here.
        NULL_LSN is returned if no changes need to be applied.

@parm   IN OUT  LPDWORD | *pdwSequence | Should be set to the current sequence
        number is the cluster registry.  If a new chkpoint is uploaded, the
        sequence number corresponding to that is returned.

@rdesc  Returns ERROR_SUCCESS if a valid LSN is returned. This may be NULL_LSN.
        Returns the error code if the database cannot be uploaded from the last chkpoint
        or if something horrible happens.

@comm   This finds the last valid check point in the log file.  The data
        base is synced with this checkpoint and the gum sequence number is
        set to one plus the sequence number of that checkpoint.  If no
        checkpoint record is found, a checkpoint is taken and NULL_LSN is
        returned.

@xref
****/
DWORD DmpLogFindStartLsn(
    IN HLOG hQuoLog,
    OUT LSN *pStartScanLsn,
    IN OUT LPDWORD pdwSequence)
{
    LSN                 ChkPtLsn;
    LSN                 StartScanLsn;
    DWORD               dwChkPtSequence=0;
    DWORD               dwError = ERROR_SUCCESS;
    WCHAR               szChkPtFileName[LOG_MAX_FILENAME_LENGTH];
    DM_LOGSCAN_CONTEXT  DmAppliedChangeContext;

    *pStartScanLsn = NULL_LSN;
    ChkPtLsn = NULL_LSN;
    //read the last check point record if any and the transaction id till that
    //checkpoint
    dwError = LogGetLastChkPoint(hQuoLog, szChkPtFileName, &dwChkPtSequence,
        &ChkPtLsn);
    if (dwError != ERROR_SUCCESS)
    {
        //no chk point record found
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogFindStartLsn: LogGetLastChkPoint failed, error=0x%1!08lx!\r\n",
            dwError );

        // this can happen either due to the fact that the log file was just created,
        // and hence there is no checkpoint or because log file was messed up
        // and the mount process corrected it but removed the checkpoint.
        // If it is the second case, then logpmountlog should put something in the
        // event log
        if (dwError == ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND)
        {
            //
            //  Chittur Subbaraman (chitturs) - 6/3/99
            //  
            //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
            //  so as to maintain the ordering between this lock and the log lock.
            //
            ACQUIRE_SHARED_LOCK(gLockDmpRoot);

            //take a checkpoint, so that this doesnt happen the next time
            dwError = LogCheckPoint(hQuoLog, TRUE, NULL, 0);

            RELEASE_LOCK(gLockDmpRoot);
            
            if (dwError != ERROR_SUCCESS)
            {
                //check point could not be taken
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[DM] DmpLogFindStartLsn: Checkpoint on first form failed, error=0x%1!08lx!\r\n",
                    dwError );
                goto FnExit;
            }
        }
        else
        {
            //there were other errors
            goto FnExit;
        }
    }
    else
    {
        //found check point record
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogFindStartLsn: LogGetLastChkPt rets, Seq#=%1!d! ChkPtLsn=0x%2!08lx!\r\n",
            dwChkPtSequence, ChkPtLsn);

        //
        //  Chittur Subbaraman (chitturs) - 10/18/98
        //
        //  If the user is forcing a database restore from backup, then
        //  do not check whether the current sequence number in the registry
        //  is younger than the checkpoint sequence number in the quorum log.
        //  Just, go ahead and load the checkpoint from restored database.
        //
        if ( CsDatabaseRestore == TRUE )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpLogFindStartLsn: User forcing a chkpt upload from quorum log...\r\n");
        }
        else 
        {
        
            //if the sequence number is greater than the check point sequence number
            //plus one, that implies..that only changes from that sequence number
            //need to be applied.(this node may not have been the first one to die)
            //We dont always apply the database because if logging is mostly off
            //and the two nodes die simultaneosly we want to prevent losing all the
            //changes
            //else if the checkpoint sequence is one below the current
            //current sequence number, then the locker node could have died after updating
            //get the current checkpoint irrespective of what the current sequence number is
            //this is because a checkpoint with the same sequence number may have
            //a change that is different from whats there in the current registry.
            //if node 'a'(locker and logger dies in the middle of logging trid=x+1,
            //the other node,'b' will take over logging and checkpoint the database
            //at trid=x.  If 'a' comes back up, it needs to throw aways its x+1 change
            //and apply changes from the log from chk pt x.

            if (*pdwSequence > (dwChkPtSequence + 1))
            {
                //the current sequence number is less than or equal to chkpt Seq + 1
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpLogFindStartLsn: ChkPt not applied, search for next seq\r\n");


                DmAppliedChangeContext.dwSequence = *pdwSequence;
                DmAppliedChangeContext.StartLsn = NULL_LSN;
                //find the LSN from which to apply changes
                if (dwError = LogScan(ghQuoLog, ChkPtLsn, TRUE,(PLOG_SCAN_CALLBACK)DmpLogFindStartLsnCb,
                    &DmAppliedChangeContext) != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpLogFindStartLsn: LogScan failed, no changes will be applied, error=0x%1!08lx!\r\n",
                        dwError);
                    goto FnExit;
                }
                *pStartScanLsn = DmAppliedChangeContext.StartLsn;
                goto FnExit;
            }
        } 

        //
        //  The current registry sequence number is less than or equal 
        //  to chkpt Seq + 1 OR the user is forcing a database restore
        //  from the backup area.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogFindStartLsn: Uploading chkpt from quorum log\r\n");


        //make sure that no keys are added to the key list because of opens/creates
        ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
        //hold the key lock as well
        EnterCriticalSection(&KeyLock);

        //invalidate all open keys
        DmpInvalidateKeys();
        
        if ((dwError = DmInstallDatabase(szChkPtFileName, NULL, FALSE)) != ERROR_SUCCESS)
        {
            //couldnt install the database
            //bad !
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogFindStartLsn: DmpInstallDatabase failed, error=0x%1!08lx!\r\n",
                dwError);
            CsLogEventData( LOG_CRITICAL,
                            DM_CHKPOINT_UPLOADFAILED,
                            sizeof(dwError),
                            &dwError );
            DmpReopenKeys();
            //release the locks            
            LeaveCriticalSection(&KeyLock);
            RELEASE_LOCK(gLockDmpRoot);
            goto FnExit;
        }
        else
        {
            //the current sequence number is less than or equal to chkpt Seq + 1
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpLogFindStartLsn: chkpt uploaded from quorum log\r\n");

            //since we downloaded the database, we should start
            //aplying changes from ChkPtLsn
            *pStartScanLsn = ChkPtLsn;
            *pdwSequence = dwChkPtSequence;
            //set the gum sequence number to be the next one
            //ss: the next logged transaction shouldnt have the same
            //transaction id
            GumSetCurrentSequence(GumUpdateRegistry, (dwChkPtSequence+1));
            //reopen the keys
            DmpReopenKeys();
            //release the locks            
            LeaveCriticalSection(&KeyLock);
            RELEASE_LOCK(gLockDmpRoot);
            goto FnExit;
        }
    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpLogFindStartLsn: LSN=0x%1!08lx!, returning 0x%2!08lx!\r\n",
        *pStartScanLsn, dwError);

    return(dwError);
}

/****
@func       DWORD | DmpLogFindStartLsnCb| The callback tries to find the first record
            with a transaction id that is larger than the sequence number of the
            local database.

@parm       PVOID | pContext| A pointer to a DM_STARTLSN_CONTEXT structure.
@parm       LSN | Lsn| The LSN of the record.
@parm       RMID | Resource | The resource manager for this transaction.
@parm       RMID | ResourceType | The resource manager for this transaction.
@parm       TRID | Transaction | The transaction number of this record.
@parm       PVOID | pLogData | The log data for this record.
@parm       DWORD | DataLength | The length of the record.

@rdesc      Returns TRUE to continue scan.  FALSE to stop.

@comm       This function returns true if the sequence number of the record
            being scanned is higher than the seqence number passed in the context.

@xref       <f DmpLogFindStartLsn> <f LogScan>
****/
BOOL WINAPI DmpLogFindStartLsnCb(
    IN PVOID    pContext,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN TRTYPE   TrType,
    IN const    PVOID pLogData,
    IN DWORD    DataLength)
{
    PDM_LOGSCAN_CONTEXT pDmStartLsnContext= (PDM_LOGSCAN_CONTEXT) pContext;


    CL_ASSERT(pDmStartLsnContext);
    if (Transaction > (int)pDmStartLsnContext->dwSequence)
    {
        pDmStartLsnContext->StartLsn = Lsn;
        return (FALSE);
    }

    return(TRUE);
}

/****
@func       DWORD | DmpHookQuorumNotify| This hooks a callback to be invoked whenever
            the state of the quorum resource changes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is used to monitor the state of
@xref
****/
DWORD DmpHookQuorumNotify()
{

    DWORD   dwError = ERROR_SUCCESS;

    if (dwError = FmFindQuorumResource(&gpQuoResource))
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmUpdateFormNewCluster: FmFindQuorumResource failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    dwError = OmRegisterNotify(gpQuoResource, NULL,
        NOTIFY_RESOURCE_POSTONLINE| NOTIFY_RESOURCE_PREOFFLINE |
        NOTIFY_RESOURCE_OFFLINEPENDING | NOTIFY_RESOURCE_POSTOFFLINE |
        NOTIFY_RESOURCE_FAILED,
        DmpQuoObjNotifyCb);

FnExit:
    return(dwError);
}


/****
@func       DWORD | DmpUnhookQuorumNotify| This unhooks the callback function
            that is registered with the object.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/

DWORD DmpUnhookQuorumNotify()
{
    DWORD dwError = ERROR_SUCCESS;

    if (gpQuoResource)
    {
        dwError = OmDeregisterNotify(gpQuoResource, DmpQuoObjNotifyCb);
        OmDereferenceObject(gpQuoResource);
    }
    return(ERROR_SUCCESS);
}


/****
@func       DWORD | DmpQuoObjNotifyCb| This is a callback that is called on
            change of state on quorum resource.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/

void DmpQuoObjNotifyCb(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification)
{

    switch(dwNotification)
    {
    case NOTIFY_RESOURCE_POSTONLINE:
        gbIsQuoResOnline = TRUE;
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpQuoObjNotifyCb: Quorum resource is online\r\n");

        //if this is the owner of the quorum resource
        //and the log is not open, open the log
        if (AMIOWNEROFQUORES(gpQuoResource) && !CsNoQuorumLogging)
        {

            //ToDo: the quorum file name should be obtained from the setup
            //for now obtain the value from the cluster registry.
            WCHAR   szQuorumFileName[MAX_PATH];
            LSN     FirstLsn;
            DWORD   dwError;
            DWORD   dwType;
            DWORD   dwLength;
            DWORD   dwMaxQuoLogSize;
            DWORD   bForceReset = FALSE;
            ULONG   OldHardErrorValue;

            //bug# :106647
            //SS: HACKHACK disabling hard error pop ups so that disk corruption
            //is caught somewhere else..
            //atleast the pop-ups must be disabled for the whole process !
            //me thinks this is covering up the problem of disk corruption
            //disk corruption should not occur!
            RtlSetThreadErrorMode(RTL_ERRORMODE_FAILCRITICALERRORS,
                                  &OldHardErrorValue);

            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpQuoObjNotifyCb: Own quorum resource, try open the quorum log\r\n");

            if (DmGetQuorumLogPath(szQuorumFileName, sizeof(szQuorumFileName)) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpQuoObjNotifyCb: Quorum log file is not configured\r\n");
            }
            else
            {
                BOOL                fSetSecurity = FALSE;
                QfsHANDLE          hFindFile = QfsINVALID_HANDLE_VALUE;
                WIN32_FIND_DATA     FindData;
                
                hFindFile = QfsFindFirstFile( szQuorumFileName, &FindData ); 

                if ( !QfsIsHandleValid(hFindFile)  )
                {
                    dwError = GetLastError();
                    ClRtlLogPrint(LOG_NOISE,
                                 "[DM] DmpQuoObjNotifyCb: FindFirstFile on path %1!ws! failed, Error=%2!d! !!!\n",
                                 szQuorumFileName,
                                 dwError);                   
                    if ( dwError == ERROR_PATH_NOT_FOUND )
                    {
                        fSetSecurity = TRUE;
                    }
                } else
                {
                    QfsFindClose( hFindFile );
                }

                //if the directory doesnt exist create it
                dwError = QfsClRtlCreateDirectory(szQuorumFileName);
                if (dwError != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[DM] DmpQuoObjNotifyCb: Failed to create directory %1!ws!, error=0x%2!08lx!...\n",
                        szQuorumFileName,
                        dwError);

                    CL_UNEXPECTED_ERROR(dwError);
                    CsInconsistencyHalt(dwError);
                }

                if ( fSetSecurity == TRUE )
                {

                    ClRtlLogPrint(LOG_NOISE,
                                  "[DM] DmpQuoObjNotifyCb: Attempting to set security on directory %1!ws!...\n",
                                  szQuorumFileName);
                    dwError = QfsSetFileSecurityInfo( szQuorumFileName, 
                                                       GENERIC_ALL,      // for Admins
                                                       GENERIC_ALL,      // for Owner
                                                       0 );              // for Everyone

                    if ( dwError != ERROR_SUCCESS )
                    {
                        ClRtlLogPrint(LOG_CRITICAL,
                                      "[DM] DmpQuoObjNotifyCb: ClRtlSetObjSecurityInfo failed for file %1!ws!, Status=%2!u!\r\n",
                                      szQuorumFileName,
                                      dwError);
                        CL_LOGFAILURE( dwError );
                        CsInconsistencyHalt( dwError );
                    }
                }

                DmGetQuorumLogMaxSize(&dwMaxQuoLogSize);

                // If the resource monitor dies and comes back up, this can happen
                if (ghQuoLog != NULL)
                {
                    HLOG    hQuoLog;
                    
                    //
                    //  Make sure the ghQuoLog variable is NULLed out with lock held exclusively BEFORE the log
                    //  is closed. This will prevent race cases in which another thread reads the ghQuoLog variable and
                    //  assumes blindly that the log is open.
                    //
                    ACQUIRE_EXCLUSIVE_LOCK( gLockDmpRoot );
                    hQuoLog = ghQuoLog;
                    ghQuoLog = NULL;
                    RELEASE_LOCK( gLockDmpRoot );
                
                    LogClose( hQuoLog );
                }

                if (gbIsQuoLoggingOn) gbNeedToCheckPoint = TRUE;

                //
                //  Chittur Subbaraman (chitturs) - 10/16/98
                //
                //  Check whether you need to restore the database from a
                //  user-supplied backup directory to the quorum disk. This
                //  restore operation is done only once when the Dm has
                //  not been fully initialized. Note that this function
                //  is called whenever the state of the quorum resource
                //  changes but the restore operation is only done once.
                //
                if ( ( gbDmInited == FALSE ) &&
                     ( CsDatabaseRestore == TRUE ) )
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Beginning DB restoration from %1!ws!...\r\n",
                          CsDatabaseRestorePath);
                    if ( ( dwError = DmpRestoreClusterDatabase ( szQuorumFileName ) )
                            != ERROR_SUCCESS )
                    {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[DM] DmpQuoObjNotifyCb: DB restore operation from %1!ws! failed! Error=0x%2!08lx!\r\n",
                              CsDatabaseRestorePath,
                              dwError);
                        CL_LOGFAILURE( dwError );
                        CsDatabaseRestore = FALSE;
                        CsInconsistencyHalt( dwError );
                    }
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: DB restoration from %1!ws! successful...\r\n",
                          CsDatabaseRestorePath);
                    CL_LOGCLUSINFO( SERVICE_CLUSTER_DATABASE_RESTORE_SUCCESSFUL );
                }

                lstrcat(szQuorumFileName, cszQuoFileName);
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpQuoObjNotifyCb: the name of the quorum file is %1!ls!\r\n",
                      szQuorumFileName);

                // 
                // Chittur Subbaraman (chitturs) - 12/4/99
                //
                // If the quorum log file is found to be missing or corrupt,
                // reset it only under the following conditions, else
                // fail the log creation and halt the node.
                //
                // (1) A freshly formed cluster,
                // (2) The user has chosen to reset the log since the user
                //     does not have a backup.
                // (3) After the quorum resource has successfully come
                //     online on this node and the DM has been initialized
                //     successfully. This is because the sanity of the
                //     quorum log file has already been verified at
                //     initialization and the chances of the quorum log
                //     missing or getting corrputed after that are not
                //     so high (due to it being held open by the cluster
                //     service) and so it is not worth halting the node 
                //     during run-time.
                //
                if ((CsFirstRun && !CsUpgrade) || 
                    (CsResetQuorumLog) || 
                    (gbDmInited == TRUE))
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Will try to reset Quorum log if file not found or if corrupt\r\n");
                    bForceReset = TRUE;
                }                    
                //  open the log file
                ghQuoLog = LogCreate(szQuorumFileName, dwMaxQuoLogSize,
                        (PLOG_GETCHECKPOINT_CALLBACK)DmpGetSnapShotCb, NULL,
                        bForceReset, &FirstLsn);

                if (!ghQuoLog)
                {
                    dwError = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpQuoObjNotifyCb: Quorum log could not be opened, error = 0x%1!08lx!\r\n",
                        dwError);
                    CL_LOGFAILURE(dwError);
                    CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
                }
                else
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb: Quorum log opened\r\n");
                }
                if (gbNeedToCheckPoint && ghQuoLog)
                {
                    //take a checkpoint and set the flag to FALSE.
                    gbNeedToCheckPoint = FALSE;
                    //get a checkpoint database
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpQuoObjNotifyCb - taking a checkpoint\r\n");
                    //
                    //  Chittur Subbaraman (chitturs) - 6/3/99
                    //  
                    //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
                    //  so as to maintain the ordering between this lock and the log lock.
                    //
                    ACQUIRE_SHARED_LOCK(gLockDmpRoot);
    
                    dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0); 

                    RELEASE_LOCK(gLockDmpRoot);
                    
                    if (dwError != ERROR_SUCCESS)
                    {
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[DM] DmpEventHandler - Failed to take a checkpoint in the log file, error = 0x%1!08lx!\r\n",
                            dwError);
                        CL_UNEXPECTED_ERROR(dwError);
                        CsInconsistencyHalt(dwError);
                    }

                }
                //if the checkpoint timer doesnt already exist
                //check if the timer has already been created - we might
                // get two post online notifications
                //and dont cause a timer leak
                if (!ghCheckpointTimer)
                {
                    ghCheckpointTimer = CreateWaitableTimer(NULL, FALSE, NULL);

                    if (!ghCheckpointTimer)
                    {
                        CL_UNEXPECTED_ERROR(dwError = GetLastError());
                    }
                    else
                    {

                        DWORD dwCheckpointInterval;
                        
                        dwError = DmpGetCheckpointInterval(&dwCheckpointInterval);
                        CL_ASSERT(dwError == ERROR_SUCCESS);

                        //add a timer to take periodic checkpoints 
                        AddTimerActivity(ghCheckpointTimer, dwCheckpointInterval, 
                            1, DmpCheckpointTimerCb, &ghQuoLog);
                    }
                }                    
            }
            //SS:completion of hack, revert to enabling pop-ups
            RtlSetThreadErrorMode(OldHardErrorValue, NULL);

        }
        if (ghQuoLogOpenEvent)
        {
            //this is the first notification after the form
            //allow the initialization to continue after rolling
            //back the changes
            SetEvent(ghQuoLogOpenEvent);
        }
        break;


    case NOTIFY_RESOURCE_FAILED:
    case NOTIFY_RESOURCE_PREOFFLINE:
    case NOTIFY_RESOURCE_OFFLINEPENDING:
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpQuoObjNotifyCb: Quorum resource offline/offlinepending/preoffline\r\n");
        gbIsQuoResOnline = FALSE;
        if (ghQuoLog)
        {
            HLOG    hQuoLog;
            
            //stop the checkpoint timer
            if (ghCheckpointTimer)
            {
                RemoveTimerActivity(ghCheckpointTimer);
                ghCheckpointTimer = NULL;
            }

            //
            //  Make sure the ghQuoLog variable is NULLed out with lock held exclusively BEFORE the log
            //  is closed. This will prevent race cases in which another thread reads the ghQuoLog variable and
            //  assumes blindly that the log is open.
            //
            ACQUIRE_EXCLUSIVE_LOCK( gLockDmpRoot );
            hQuoLog = ghQuoLog;
            ghQuoLog = NULL;
            RELEASE_LOCK( gLockDmpRoot );
            
            LogClose( hQuoLog );
            //dont try and log after this
            gbIsQuoLoggingOn = FALSE;
        }
        if (ghQuoLogOpenEvent)
        {
            //this is the first notification after the form
            //allow the initialization to continue after rolling
            //back the changes
            SetEvent(ghQuoLogOpenEvent);
        }

        break;

    }
}

/****
@func       DWORD | DmpHookEventHandler| This hooks a callback to be invoked whenever
            the state of the quorum resource changes.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is used to monitor the state of nodes and turn quorum logging on or off.
@xref
****/
DWORD DmpHookEventHandler()
{
    DWORD   dwError;

    dwError = EpRegisterEventHandler(CLUSTER_EVENT_ALL,DmpEventHandler);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmHookEventHandler: EpRegisterEventHandler failed, error=0x%1!08lx!\r\n",
            dwError);
        CL_UNEXPECTED_ERROR( dwError );
    }

    return(dwError);
}



/****
@func       DWORD | DmpEventHandler| This routine handles events for the Cluster
            Database Manager.

@parm       CLUSTER_EVENT | Event | The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

@parm       PVOID| pContext | A pointer to context associated with the particular event.

@rdesc      Returns ERROR_SUCCESS else a Win32 error code on other errors.

@comm       This is used to monitor the state of nodes and turn quorum logging on or off.
@xref
****/
DWORD WINAPI DmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID pContext
    )
{
    DWORD   dwError=ERROR_SUCCESS;
    BOOL    bAreAllNodesUp;

    switch ( Event ) {
    case CLUSTER_EVENT_NODE_UP:
        bAreAllNodesUp = TRUE;
        if ((dwError = OmEnumObjects(ObjectTypeNode, DmpNodeObjEnumCb, &bAreAllNodesUp, NULL))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM]DmpEventHandler : OmEnumObjects returned, error=0x%1!08lx!\r\n",
                dwError);

        }
        else
        {
            if (bAreAllNodesUp)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpEventHandler - node is up, turning quorum logging off\r\n");

                gbIsQuoLoggingOn = FALSE;
            }
        }
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        if (!gbIsQuoLoggingOn)
        {
            HANDLE  hThread = NULL;
            DWORD   dwThreadId;

            //
            //  Chittur Subbaraman (chitturs) - 7/23/99
            //
            //  Create a new thread to handle the checkpointing on a 
            //  node down. This is necessary since we don't want the
            //  DM node down handler to be blocked in any fashion. If
            //  it is blocked since FmCheckQuorumState couldn't get the 
            //  quorum group lock and some other thread got the group 
            //  lock and is waiting for the GUM lock, then we have 
            //  an immediate deadlock. Only after this node down 
            //  handler finishes, any subsequent future node down
            //  processing can be started.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpEventHandler - Node is down, turn quorum logging on...\r\n");

            gbIsQuoLoggingOn = TRUE;
            
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpEventHandler - Create thread to handle node down event...\r\n");
  
            hThread = CreateThread( NULL, 
                                    0, 
                                    DmpHandleNodeDownEvent,
                                    NULL, 
                                    0, 
                                    &dwThreadId );

            if ( hThread == NULL )
            {
                dwError = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmpEventHandler - Unable to create thread to handle node down event. Error=0x%1!08lx!\r\n",
                dwError);
                CsInconsistencyHalt( dwError );
            }
        
            CloseHandle( hThread );
        }

        break;

    case CLUSTER_EVENT_NODE_CHANGE:
        break;

    case CLUSTER_EVENT_NODE_ADDED:
        break;

    case CLUSTER_EVENT_NODE_DELETED:
        break;

    case CLUSTER_EVENT_NODE_JOIN:
        break;


    }
    return(dwError);

} // DmpEventHandler


/****
@func       DWORD | DmpNodeObjEnumCb| This is a callback that is called when node
            objects are enumberate by the dm.

@parm       PVOID | pContext| A pointer to a DMLOGRECORD structure.
@parm       PVOID | pObject| A pointer to quorum resource object.
@parm       DWORD | dwNotification| A pointer to a DMLOGRECORD structure.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref
****/
BOOL DmpNodeObjEnumCb(IN BOOL *pbAreAllNodesUp, IN PVOID pContext2,
    IN PVOID pNode, IN LPCWSTR szName)
{

    if ((NmGetNodeState(pNode) != ClusterNodeUp) &&
        (NmGetNodeState(pNode) != ClusterNodePaused))
        *pbAreAllNodesUp = FALSE;
    //if any of the nodes is down fall out
    return(*pbAreAllNodesUp);
}

/****
@func       BOOL | DmpGetSnapShotCb| This callback is invoked when the logger
                        is asked to take a checkpoint record for the cluster registry.

@parm       PVOID| pContext | The checkpoint context passed into LogCreate.

@parm       LPWSTR | szChkPtFile | The name of the file in which to take a checkpoint.

@parm       LPDWORD | pdwChkPtSequence | The sequence number related with this
            checkpoint is returned in this.

@rdesc      Returns a result code. ERROR_SUCCESS on success.  If the file corresponding
            to this checkpoint already exists, it will return ERROR_ALREADY_EXISTS and
            szChkPtFile will be set to the name of the file.

@comm       LogCheckPoint() calls this function when the log manager is asked to checkpoint the
            dm database.

@xref
****/

DWORD WINAPI DmpGetSnapShotCb(IN LPCWSTR szPathName, IN PVOID pContext,
    OUT LPWSTR szChkPtFile, OUT LPDWORD pdwChkPtSequence)
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szFilePrefix[MAX_PATH] = L"chkpt";
    WCHAR   szTempFile[MAX_PATH] = L"";

    ACQUIRE_SHARED_LOCK( gLockDmpRoot );

    szChkPtFile[0] = L'\0';

    //
    //  Chittur Subbaraman (chitturs) - 5/1/2000
    //
    //  Checkpoint file name is based on registry sequence number. It is possible that two
    //  or more consecutive calls to this function to take checkpoints may read the same
    //  registry sequence number. Thus, if DmGetDatabase fails for some reason, it is possible
    //  that an existing checkpoint file will get corrupted. Thus, even though the quorum log
    //  marks a 'start checkpoint record' and an 'end checkpoint record', it could turn out
    //  to be useless if this function manages to corrupt an existing checkpoint file. To solve
    //  this problem, we first generate a temp file, take a cluster hive snapshot as this temp
    //  file, then atomically move the temp file to the final checkpoint file using the MoveFileEx
    //  function.
    //

    //
    //  Create a new unique temp file name
    //
    if ( !QfsGetTempFileName( szPathName, szFilePrefix, 0, szTempFile ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] DmpGetSnapShotCb: Failed to generate a temp file name, PathName=%1!ls!, FilePrefix=%2!ls!, Error=0x%3!08lx!\r\n",
            szPathName, szFilePrefix, dwError);
        goto FnExit;
    }

    dwError = DmCommitRegistry();         // Ensure up-to-date snapshot

    if ( dwError != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[LM] DmpGetSnapShotCb: DmCommitRegistry() failed, Error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    dwError = DmGetDatabase( DmpRoot, szTempFile );

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpGetSnapShotCb: DmpGetDatabase returned 0x%1!08lx!\r\n",
        dwError);

    if ( dwError == ERROR_SUCCESS )
    {
        *pdwChkPtSequence = DmpGetRegistrySequence();

        //
        // Create a checkpoint file name based on the registry sequence number
        //
        if ( !QfsGetTempFileName( szPathName, szFilePrefix, *pdwChkPtSequence, szChkPtFile ) )
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] DmpGetSnapShotCb: Failed to generate a chkpt file name, PathName=%1!ls!, FilePrefix=%2!ls!, Error=0x%3!08lx!\r\n",
                szPathName, szFilePrefix, dwError);
            //
            // Reset the file name to null, as this information will be used to determine
            // if the checkpoint was taken
            //
            szChkPtFile[0] = L'\0';
            goto FnExit;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[LM] DmpGetSnapshotCb: Checkpoint file name=%1!ls! Seq#=%2!d!\r\n",
            szChkPtFile, *pdwChkPtSequence);

        if ( !QfsMoveFileEx( szTempFile, szChkPtFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH ) )
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] DmpGetSnapShotCb: Failed to move the temp file to checkpoint file, TempFileName=%1!ls!, ChkPtFileName=%2!ls!, Error=0x%3!08lx!\r\n",
                szTempFile, szChkPtFile, dwError);
            //
            // Reset the file name to null, as this information will be used to determine
            // if the checkpoint was taken
            //
            szChkPtFile[0] = L'\0';
            goto FnExit;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    if ( dwError != ERROR_SUCCESS )
    {
        QfsDeleteFile( szTempFile );
    }
    return ( dwError );
}

/****
@func       BOOL WINAPI | DmpLogApplyChangesCb| This callback walks through the records in
            the quorum logs and applies changes to the local database.

@parm       PVOID | pContext | The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

@parm       LSN | Lsn | Lsn of the record.

@parm       RMID | Resource | The resource id of the entity that logged this record.

@parm       RMTYPE | ResourceType | The record type that is specific to the resource id.

@parm       TRID | Transaction | The sequence number of the transaction.

@parm       const PVOID | pLogData | A pointer to the record data.

@parm       DWORD | DataLength | The length of the data in bytes.

@rdesc      Returns TRUE to continue scan else returns FALSE.

@comm       This function is called at initialization when a cluster is being formed to apply
            transactions from the quorum log to the local cluster database.
@xref
****/

BOOL WINAPI DmpLogApplyChangesCb(
    IN PVOID    pContext,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceType,
    IN TRID     Transaction,
    IN TRTYPE   TransactionType,
    IN const    PVOID pLogData,
    IN DWORD    DataLength)
{

    DWORD               Status;
    PDM_LOGSCAN_CONTEXT pDmAppliedChangeContext = (PDM_LOGSCAN_CONTEXT) pContext;
    TRSTATE             trXsactionState;
    BOOL                bRet = TRUE;

    CL_ASSERT(pDmAppliedChangeContext);
    //if the resource id is not the same as dm..ignore..go to the next one

    switch(TransactionType)
    {
        case TTStartXsaction:
            Status = LogFindXsactionState(ghQuoLog, Lsn, Transaction, &trXsactionState);
            if (Status != ERROR_SUCCESS)
            {
                //there was an error
                ClRtlLogPrint(LOG_NOISE, "[DM] DmpLogApplyChangesCb ::LogFindXsaction failed, error=0x%1!08lx!\r\n",
                Status);
                //assume unknown state
                CL_LOGFAILURE(Status);
                trXsactionState = XsactionUnknown;
            }
            //if the transaction is successful apply it, else continue
            if (trXsactionState == XsactionCommitted)
            {
                Status = LogScanXsaction(ghQuoLog, Lsn, Transaction, DmpApplyTransactionCb,
                    NULL);
                if (Status != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_NOISE,
                        "[DM] DmpLogApplyChangesCb :LogScanTransaction for committed record failed, error=0x%1!08lx!\r\n",
                        Status);
                    bRet = FALSE;
                    CL_LOGFAILURE(Status);
                    break;
                }
                pDmAppliedChangeContext->dwSequence = Transaction;
            }
            else
            {
                ClRtlLogPrint(LOG_NOISE, "[DM] TransactionState = %1!u!\r\n",
                    trXsactionState);
            }
            break;


        case TTCompleteXsaction:
            bRet = DmpApplyTransactionCb(NULL, Lsn, Resource, ResourceType,
                Transaction, pLogData, DataLength);
            pDmAppliedChangeContext->dwSequence = Transaction;
            break;

        default:
            CL_ASSERT(FALSE);

    }

    return(bRet);

}


BOOL WINAPI DmpApplyTransactionCb(
    IN PVOID        pContext,
    IN LSN          Lsn,
    IN RMID         Resource,
    IN RMTYPE       ResourceType,
    IN TRID         TransactionId,
    IN const PVOID  pLogData,
    IN DWORD        dwDataLength)
{
    DWORD   Status;

    switch(ResourceType)
    {

        case DmUpdateCreateKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmpLogScanCb::DmUpdateCreateKey\n");
            //SS: we dont care at this point as to where the update originated
            Status = DmpUpdateCreateKey(FALSE,
                                        GET_ARG(pLogData,0),
                                        GET_ARG(pLogData,1),
                                        GET_ARG(pLogData,2));
            break;

        case DmUpdateDeleteKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteKey \n");
            Status = DmpUpdateDeleteKey(FALSE,
                        (PDM_DELETE_KEY_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateSetValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateSetValue \n");
            Status = DmpUpdateSetValue(FALSE,
                        (PDM_SET_VALUE_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateDeleteValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteValue\n");
            Status = DmpUpdateDeleteValue(FALSE,
                        (PDM_DELETE_VALUE_UPDATE)((PBYTE)pLogData));
            break;

        case DmUpdateJoin:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmUpdateJoin\n");
            Status = ERROR_SUCCESS;
            break;

        default:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmpLogScanCb:uType = %1!u!\r\n",
                ResourceType);
            Status = ERROR_INVALID_DATA;
            CL_UNEXPECTED_ERROR(ERROR_INVALID_DATA);
            break;

    }
    return(TRUE);
}

/****
@func       WORD| DmpLogCheckPtCb| A callback fn for DM
            to take a checkpoint to the log if the quorum
            resource is online on this node.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       This callback is called when the quorum resource
            is online on this node.  Since the quorum resource
            synchronous callbacks are called before the resource 
            state changes are propagated, if the quorum is online
            the log must be open.
            
@xref
****/
void DmpLogCheckPointCb()
{
    DWORD dwError;

    //
    //  Chittur Subbaraman (chitturs) - 9/22/99
    //
    //  If the quorum logging switch is off, don't do anything.
    //
    if (CsNoQuorumLogging) return;
    
    //once it is online the log file should be open
    //SS:BUGS: should we log something in the eventlog
    if (ghQuoLog)
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/3/99
        //  
        //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
        //  so as to maintain the ordering between this lock and the log lock.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);

        //get a checkpoint database
        dwError = LogCheckPoint(ghQuoLog, TRUE, NULL, 0);

        RELEASE_LOCK(gLockDmpRoot);
        
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpLogCheckPointCb - Failed to take a checkpoint in the log file, error=0x%1!08lx!\r\n",
                dwError);
            CL_UNEXPECTED_ERROR(dwError);
        }
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckPointCb - taken checkpoint\r\n");
    }
    else 
    {
        CsInconsistencyHalt(ERROR_QUORUMLOG_OPEN_FAILED);
    }

    
}

/****
@func       WORD| DmGetQuorumLogPath| Reads the quorum log file path configured in
            the registry during setup.

@parm       LPWSTR | szQuorumLogPath | A pointer to a wide string of size MAX_PATH.
@parm       DWORD | dwSize | The size of szQuorumLogPath in bytes.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD DmGetQuorumLogPath(LPWSTR szQuorumLogPath, DWORD dwSize)
{
    DWORD Status;
    
    Status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        &szQuorumLogPath,
                        &dwSize,
                        &dwSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetQuorumLogPath failed, error=%1!u!\n", Status);
        goto FnExit;
    }

FnExit:    
    return(Status);
}

/****
@func       WORD| DmpGetCheckpointInterval| Reads the checkpoint interval
            from the registry, else returns the default.

@parm       LPDWORD | pdwCheckpointInterval | A pointer to DWORD where 
            the checkpoint interval, in secs, is returned.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       The default checkpoint interval is 4 hours.  The registry must be configured
            in units of hours.
@xref
****/
DWORD DmpGetCheckpointInterval(
    OUT LPDWORD pdwCheckpointInterval)
{
    DWORD dwDefCheckpointInterval = DEFAULT_CHECKPOINT_INTERVAL;
    DWORD dwStatus = ERROR_SUCCESS;
    
    dwStatus = DmQueryDword( DmQuorumKey,
                        CLUSREG_NAME_CHECKPOINT_INTERVAL,
                        pdwCheckpointInterval,
                        &dwDefCheckpointInterval);

    if (dwStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetCheckpointInterval Failed, error=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }
    //the checkpoint interval cant be less than 1 hour or more than 1 day
    if ((*pdwCheckpointInterval  < 1) || (*pdwCheckpointInterval>24)) 
        *pdwCheckpointInterval = DEFAULT_CHECKPOINT_INTERVAL;

    //convert to msecs
    *pdwCheckpointInterval = *pdwCheckpointInterval * 60 * 60 * 1000;

FnExit:
    return(dwStatus);
}


/****
@func       WORD| DmGetQuorumLogMaxSize| Reads the quorum log file max size.

@parm       LPDWORD | pdwMaxLogSize| A pointer to a dword containing the size.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD DmGetQuorumLogMaxSize(LPDWORD pdwMaxLogSize)
{
    DWORD Status;
    DWORD dwDefaultLogMaxSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    Status = DmQueryDword( DmQuorumKey,
                        cszMaxQuorumLogSize,
                        pdwMaxLogSize,
                        &dwDefaultLogMaxSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, "[DM] DmGetQuorumLogMaxSize failed, error=%1!u!\n",Status);
    }

    return(Status);
}


/****
@func           DWORD | DmpCheckDiskSpace| Called to check for the disk space
            on the quorum resource after it is brought online and logs are rolled up.

@rdesc          ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm           This function checks if there is enough disk space and sets up
            a periodic timer to monitor the disk space.

@xref           <f DmpDiskManage>
****/
DWORD DmpCheckDiskSpace()
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szQuoLogPathName[MAX_PATH];
    ULARGE_INTEGER   liNumTotalBytes;
    ULARGE_INTEGER   liNumFreeBytes;

    //if you own the quorum resource, try to check the size
    if (gpQuoResource && AMIOWNEROFQUORES(gpQuoResource) && gbIsQuoResOnline)
    {
        //get the path
        if ((dwError = DmGetQuorumLogPath(szQuoLogPathName, sizeof(szQuoLogPathName)))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpCheckDiskSpace: Quorum log file is not configured, error=%1!u!\r\n",
                dwError);
            //log something in the event log
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        
        //check the minimum space on the quorum disk
        if (!QfsGetDiskFreeSpaceEx(szQuoLogPathName, &liNumFreeBytes, &liNumTotalBytes,
            NULL))
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpCheckDiskSpace: GetDiskFreeSpace returned error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }

        //if not available, log something in the event log and bail out
        if ((liNumFreeBytes.HighPart == 0) &&
            (liNumFreeBytes.LowPart < DISKSPACE_INIT_MINREQUIRED))
        {
            CL_LOGCLUSWARNING(LM_DISKSPACE_HIGH_WATERMARK);
            dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
            goto FnExit;
        }

    }


FnExit:
    return(dwError);
}


/****
@func       DWORD | DmpDiskManage | This is the callback registered to perform
            periodic disk check functions on the quorum resource.

@comm       If the disk space has dipped below the lowwatermark, this gracefully
            shuts the cluster service. If the disk space dips below the high
            watermark, it sends an alert to registered recipients.

@xref       <f DmpCheckDiskSpace>
****/
void WINAPI DmpDiskManage(
    IN HANDLE hTimer,
    IN PVOID pContext)
{
    DWORD           dwError;
    WCHAR           szQuoLogPathName[MAX_PATH];
    ULARGE_INTEGER  liNumTotalBytes;
    ULARGE_INTEGER  liNumFreeBytes;
    static DWORD    dwNumWarnings=0;

    
    if (!gpQuoResource || (!AMIOWNEROFQUORES(gpQuoResource)) ||
        (!gbIsQuoResOnline || (CsNoQuorumLogging)))
    {
        //the owner of the quorum resource checks the disk space
        //the quorum disk shouldnt go offline
        //skip checking if no quorum logging is required
        return;
    }
    //get the path
    if ((dwError = DmGetQuorumLogPath(szQuoLogPathName, sizeof(szQuoLogPathName)))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: Quorum log file is not configured, error=%1!u!\r\n",
            dwError);
        //log something in the event log
        CL_UNEXPECTED_ERROR(dwError);
        goto FnExit;
    }

    //check the minimum space on the quorum disk
    if (!QfsGetDiskFreeSpaceEx(szQuoLogPathName, &liNumFreeBytes, &liNumTotalBytes,
        NULL))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: GetDiskFreeSpace returned error=0x%1!08lx!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    if ((liNumFreeBytes.HighPart == 0) &&
        (liNumFreeBytes.LowPart < DISKSPACE_LOW_WATERMARK))
    {
        //reached the low water mark
        dwNumWarnings++;
        //ss: we can control the rate at which we put things in the
        //event log but once every five minutes is not bad.
        //ss: post an event ???
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpDiskManage: GetDiskFreeSpace - Not enough disk space, Avail=0x%1!08lx!\r\n",
            liNumFreeBytes.LowPart);
        CL_LOGCLUSWARNING(LM_DISKSPACE_LOW_WATERMARK);
    }
    else
    {
        gbIsQuoResEnoughSpace = TRUE;
        dwNumWarnings = 0;
    }
FnExit:
    return;
}


/****
@func       DWORD | DmpCheckpointTimerCb | This is the callback registered to perform
            periodic checkpointing on the quorum log.

@parm       IN HANDLE| hTimer| The timer associated with checkpointing interval.

@parm       IN PVOID | pContext | A pointer to the handle for the quorum log file.

@comm       This helps in backups.  If you want to take a cluster backup by making
            a copy of the quorum.log and checkpoint files, then if both nodes have
            been up for a long time both the files can be old.  By taking a periodic
            checkpoint we guarantee that they are not more than n hours old.

****/
void WINAPI DmpCheckpointTimerCb(
    IN HANDLE hTimer,
    IN PVOID pContext)
{

    HLOG    hQuoLog;
    DWORD   dwError;

    //
    //  Chittur Subbaraman (chitturs) - 6/3/99
    //  
    //  Make sure the gLockDmpRoot is held before LogCheckPoint is called
    //  so as to maintain the ordering between this lock and the log lock.
    //  In addition, we want to read the pContext safely. This is because
    //  pContext is a pointer to the log and could change via the SetClusterQuorumResource
    //  API.
    //
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);
    
    hQuoLog = *((HLOG *)pContext);

    if (hQuoLog && gbDmInited)
    {

        //get a checkpoint database
        ClRtlLogPrint(LOG_NOISE,
            "[DM]DmpCheckpointTimerCb- taking a checkpoint\r\n");
        
        dwError = LogReset(hQuoLog);
       
        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM]DmpCheckpointTimerCb - Failed to reset log, error=%1!u!\r\n",
                dwError);
            CL_UNEXPECTED_ERROR(dwError);
        }
    }

    RELEASE_LOCK(gLockDmpRoot);
}

/****
@func       DWORD | DmBackupClusterDatabase | Take a fresh checkpoint and 
            copy the quorum log and the checkpoint file to the supplied 
            path name. This function is called with gQuoLock held.

@parm       IN LPCWSTR | lpszPathName | The directory path name where the 
            files have to be backed up. This path must be visible to the 
            node on which the quorum resource is online (i.e., this node
            in this case).

@comm       This function first takes a fresh checkpoint, updates the quorum
            log file and then copies the two files to a backup area.

@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f DmpLogCheckpointAndBackup> <f DmpRestoreClusterDatabase>
****/
DWORD DmBackupClusterDatabase(
    IN LPCWSTR  lpszPathName)
{
    QfsHANDLE           hFindFile = QfsINVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    DWORD               status = ERROR_SUCCESS;
    LPWSTR              szDestPathName = NULL;
    DWORD               dwLen;

    //
    //  Chittur Subbaraman (chitturs) - 10/12/98
    //
    dwLen = lstrlenW( lpszPathName ); 

    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szDestPathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 5 ) *
                                 sizeof ( WCHAR ) );

    if ( szDestPathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              lpszPathName); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }

    lstrcpyW( szDestPathName, lpszPathName );
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( szDestPathName [dwLen-1] != L'\\' )
    {
        szDestPathName [dwLen++] = L'\\';
    }
    //
    //  Add a wild character at the end to search for any file in the
    //  supplied directory
    //
    szDestPathName[dwLen++] = L'*';
    szDestPathName[dwLen] = L'\0';

    //
    //  Find out whether you can access the supplied path by
    //  trying to find some file in the directory.
    //
    hFindFile = QfsFindFirstFile( szDestPathName, &FindData ); 
    if ( !QfsIsHandleValid(hFindFile) )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Supplied path %1!ws! does not exist, Error=%2!d! !!!\n",
                szDestPathName,
                status);  
        goto FnExit;
    }
    //
    //  Check whether the log is open. It must be since we already 
    //  verified that the quorum resource is online on this node and
    //  quorum logging is turned on.
    //
    if ( ghQuoLog )
    {
        //
        //  Remove the '*' so the same variable can be used.
        //
        szDestPathName [dwLen-1] = L'\0';
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmBackupClusterDatabase: Attempting to take a checkpoint and then backup to %1!ws!..\n",
            szDestPathName); 

        //
        //  The gLockDmpRoot needs to be acquired here since otherwise
        //  you will get the log lock in the LogCheckPoint( )
        //  function and someone else could get the gLockDmpRoot. 
        //  After you get the log lock, you also try to acquire 
        //  the gLockDmpRoot in the function DmCommitRegistry. 
        //  This is a potential deadlock situation and is avoided here.
        //
        ACQUIRE_SHARED_LOCK(gLockDmpRoot);
        status = DmpLogCheckpointAndBackup ( ghQuoLog, szDestPathName );
        RELEASE_LOCK(gLockDmpRoot);

        if ( status == ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmBackupClusterDatabase: Successfully finished backing up to %1!ws!...\n",
                szDestPathName);
        }
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmBackupClusterDatabase: Quorum log could not be opened...\r\n");
        status = ERROR_QUORUMLOG_OPEN_FAILED;
    }

FnExit:
    QfsFindCloseIfValid ( hFindFile );
    LocalFree ( szDestPathName );
    return ( status );
}

/****
@func   DWORD | DmpLogCheckpointAndBackup | Takes a checkpoint, updates the
        quorum log and then copies the files to the supplied path. This
        function is called with the gQuoLock and the gLockDmpRoot held.

@parm   IN HLOG | hLogFile | An identifier for the quorum log file.

@parm   IN LPWSTR | lpszPathName | The path for storing the quorum log
        file, the recent checkpoint file, and the resource registry
        checkpoint files. This path must be visible from this node.

@comm   Called by DmpBackupQuorumLog() to take a checkpoint and then
        take a backup of the cluster database including resource
        registry checkpoint files.
        
@rdesc  Returns a Win32 error code on failure. ERROR_SUCCESS on success.
        
@xref   <f DmBackupClusterDatabase> 
****/
DWORD DmpLogCheckpointAndBackup(
    IN HLOG     hLogFile,    
    IN LPWSTR   lpszPathName)
{
    DWORD   dwError;
    DWORD   dwLen;
    WCHAR   szChkPointFilePrefix[MAX_PATH];
    WCHAR   szQuoLogPathName[MAX_PATH];
    LPWSTR  szDestFileName = NULL;
    WCHAR   szSourceFileName[MAX_PATH];
    LPWSTR  szDestPathName = NULL;
    LPWSTR  lpChkPointFileNameStart;
    LSN     Lsn;
    TRID    Transaction;
    QfsHANDLE  hFile = QfsINVALID_HANDLE_VALUE;

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //

    //
    //  Initiate a checkpoint process. Allow a log file reset, if necessary.
    //
    if ( ( dwError = LogCheckPoint( hLogFile, TRUE, NULL, 0 ) )
        != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Callback failed to return a checkpoint. Error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE( dwError );
        LogClose( hLogFile );
        goto FnExit;
    }

    //
    //  Get the name of the most recent checkpoint file
    //
    szChkPointFilePrefix[0] = TEXT('\0');
    if ( ( dwError = LogGetLastChkPoint( hLogFile, szChkPointFilePrefix, &Transaction, &Lsn ) )
        != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::No check point found in the log file. Error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE( dwError );
        LogClose( hLogFile );
        goto FnExit;
    }

    dwError = DmGetQuorumLogPath( szQuoLogPathName, sizeof( szQuoLogPathName ) );
    if ( dwError  != ERROR_SUCCESS )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::DmGetQuorumLogPath failed, Error = %1!d!\r\n",
              dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szDestPathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( lpszPathName ) + 1 ) *
                                   sizeof ( WCHAR ) );

    if ( szDestPathName == NULL )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckpointAndBackup: Error %1!d! in allocating memory for %2!ws! !!!\n",
              dwError,
              lpszPathName); 
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Get the user-supplied destination path name
    //
    lstrcpyW( szDestPathName, lpszPathName );

    szDestFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( szDestPathName ) + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                   sizeof ( WCHAR ) );

    if ( szDestFileName == NULL )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpLogCheckpointAndBackup: Error %1!d! in allocating memory for chkpt file name !!!\n",
              dwError); 
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Make an attempt to delete the CLUSBACKUP.DAT file
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, L"CLUSBACKUP.DAT" );
    //
    //  Set the file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to delete it.)
    //
    if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }
    
    if ( !QfsDeleteFile( szDestFileName ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::CLUSBACKUP.DAT exists, but can't delete it, Error = %1!d!\n",
                   dwError);
            CL_LOGFAILURE( dwError );
            goto FnExit;   
        }  
    }
    //
    //  Just get the checkpoint file name without any path added.
    //  Note that szQuoLogPathName includes the '\'
    //
    dwLen = lstrlenW ( szQuoLogPathName );
    lpChkPointFileNameStart = &szChkPointFilePrefix[dwLen];  

    //
    //  Now, create the path-included destination file name
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, lpChkPointFileNameStart );

    //
    //  And, the path-included source file name
    //
    lstrcpyW( szSourceFileName,  szChkPointFilePrefix );

    //
    //  Set the file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to overwrite it.)
    //
    if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }

    //
    //  Copy the checkpoint file to the destination
    //
    dwError = QfsClRtlCopyFileAndFlushBuffers( szSourceFileName, szDestFileName );
    if ( !dwError ) 
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                   szSourceFileName,
                   szDestFileName,
                   dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Set the file attribute to read-only. Continue even if you 
    //  fail in this step, but log an error. 
    //
    if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_READONLY ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to READONLY, Error = %2!d!\n",
                szDestFileName,
                dwError);    
    }
  
    //
    //  Now, create the path-included destination file name
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, cszQuoFileName );

    //
    //  And, the path-included source file name
    //
    lstrcpyW( szSourceFileName, szQuoLogPathName );
    lstrcatW( szSourceFileName, cszQuoFileName );

    //
    //  Set the destination file attribute to normal. Continue even if you 
    //  fail in this step, but log an error. (Note that you are
    //  countering the case in which a destination file with
    //  the same name exists in the backup directory already and
    //  you are trying to overwrite it.)
    //
    if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, Error = %2!d!\n",
                    szDestFileName,
                    dwError);
        }
    }

    //
    //  Copy the quorum log file to the destination
    //
    dwError = QfsCopyFile( szSourceFileName, szDestFileName, FALSE );
    if ( !dwError ) 
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmpLogCheckpointAndBackup::Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                   szSourceFileName,
                   szDestFileName,
                   dwError);
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }

    //
    //  Set the destination file attribute to read-only. Continue even 
    //  if you fail in this step, but log an error
    //
    if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_READONLY ) )
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to READONLY, Error = %2!d!\n",
                szDestFileName,
                dwError);    
    }

    //
    //  Now copy the resource chkpt files to the destination. Note that
    //  we call this function with both gQuoLock and gLockDmpRoot held.
    //  The former lock prevents any checkpoint being read or written
    //  via CppReadCheckpoint() and CppWriteCheckpoint() while the
    //  following function is executing. 
    //
    //  Note: However, the CpDeleteRegistryCheckPoint() function is 
    //  unprotected and poses a potential danger here.
    //
    //  Note: Also, currently the following function returns ERROR_SUCCESS
    //  in all cases. 
    //
    dwError = CpCopyCheckpointFiles( szDestPathName, TRUE );
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpLogCheckpointAndBackup::Unable to copy resource checkpoint files, Error = %1!d!\n",
               dwError);
        goto FnExit;
    }

    //
    //  Now create an empty READONLY, HIDDEN, file in the destination 
    //  directory which marks the successful ending of the backup.
    //
    lstrcpyW( szDestFileName, szDestPathName );
    lstrcatW( szDestFileName, L"CLUSBACKUP.DAT");
    hFile = QfsCreateFile(szDestFileName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_NEW,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                              NULL );
                                  
    if ( !QfsIsHandleValid(hFile) ) 
    {
        dwError = GetLastError();
        CL_LOGFAILURE( dwError );
        goto FnExit;
    }
    
    dwError = ERROR_SUCCESS;

FnExit:
    LocalFree ( szDestFileName );
    LocalFree ( szDestPathName );
    QfsCloseHandleIfValid ( hFile );
    return ( dwError );
}

/****
@func       DWORD | DmpRestoreClusterDatabase | Copy the quorum log and all the 
            checkpoint files from CsDatabaseRestorePath to the 
            quorum log path in the quorum disk.

@parm       IN LPCWSTR | lpszQuoLogPathName | The quorum directory path 
            where the backed up files have to be copied to. 
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@xref       <f CppRestoreCpFiles> <f DmBackupClusterDatabase>
****/
DWORD DmpRestoreClusterDatabase(
    IN LPCWSTR  lpszQuoLogPathName )
{
    QfsHANDLE           hFindFile = QfsINVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    DWORD               status;
    WCHAR               szDestFileName[MAX_PATH];
    LPWSTR              szSourceFileName = NULL;
    LPWSTR              szSourcePathName = NULL;
    DWORD               dwLen;
    WCHAR               szChkptFileNameStart[4];
    WCHAR               szTempFileName[MAX_PATH];

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //
    dwLen = lstrlenW ( CsDatabaseRestorePath );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own quorum disk path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 25 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpRestoreClusterDatabase: Error %1!d! in allocating memory for %2!ws! !!!\n",
              status,
              CsDatabaseRestorePath); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    
    lstrcpyW ( szSourcePathName,  CsDatabaseRestorePath );
  
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( szSourcePathName [dwLen-1] != L'\\' )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName[dwLen] = L'\0';
    }

    lstrcatW ( szSourcePathName, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = QfsFindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( !QfsIsHandleValid(hFindFile)  )
    {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND )
        {
	  ClRtlLogPrint(LOG_NOISE,
	               "[DM] DmpRestoreClusterDatabase: Path %1!ws! unavailable, Error = %2!d! !!!\n",
			szSourcePathName,
			status); 
        } else
        {
            status = ERROR_DATABASE_BACKUP_CORRUPT;
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpRestoreClusterDatabase: Backup procedure not fully successful, can't restore DB, Error = %1!d! !!!\n",
                    status); 
        }
        CL_LOGFAILURE( status );
        goto FnExit;
    }
    QfsFindClose ( hFindFile );
    
    szSourcePathName[dwLen++] = L'*';
    szSourcePathName[dwLen] = L'\0';

    //
    //  Try to find any file in the directory
    //
    hFindFile = QfsFindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen-1] = L'\0';
    if ( !QfsIsHandleValid(hFindFile) )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpRestoreClusterDatabase: Error %2!d! in trying to find file in path %1!ws!\r\n",
                    szSourcePathName,
                    status); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }

    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( lstrlenW ( szSourcePathName ) + 1 + LOG_MAX_FILENAME_LENGTH ) *
                                 sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpRestoreClusterDatabase: Error %1!d! in allocating memory for source file name !!!\n",
              status); 
        CL_LOGFAILURE( status );
        goto FnExit;
    }   
   
    status = ERROR_SUCCESS;

    //
    //  Now, find and copy all relevant files from the backup area
    //  to the quorum disk. Note that only one of the copied chk*.tmp
    //  files will be used as the valid checkpoint. However, we copy
    //  all chk*.tmp files to make this implementation simple and 
    //  straightforward to comprehend.
    //
    while ( status == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
        { 
            if ( FindData.cFileName[0] == L'.' )
            {
                if ( FindData.cFileName[1] == L'\0' ||
                         FindData.cFileName[1] == L'.' && FindData.cFileName[2] == L'\0' ) 
                {
                    goto skip;
                }
            }

            //  
            //  Since the found file is infact a directory, check 
            //  whether it is one of the resource checkpoint directories.
            //  If so copy the relevant checkpoint files to the quorum
            //  disk.
            //
            if ( ( status = CpRestoreCheckpointFiles( szSourcePathName, 
                                               FindData.cFileName,
                                               lpszQuoLogPathName ) )
                    != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[DM] DmpRestoreClusterDatabase: Error %1!d! in copying resource cp files !!!\n",
                    status); 
                CL_LOGFAILURE( status );
                goto FnExit;
            }
        } else
        {
            lstrcpyW ( szTempFileName, FindData.cFileName );
            szTempFileName[3] = L'\0';
            mbstowcs( szChkptFileNameStart, "chk", 4 );
            if ( ( lstrcmpW ( szTempFileName, szChkptFileNameStart ) == 0 ) 
                   || 
                 ( lstrcmpW ( FindData.cFileName, cszQuoFileName ) == 0 ) )
            {
                lstrcpyW( szSourceFileName, szSourcePathName );
                lstrcatW( szSourceFileName, FindData.cFileName );
                lstrcpyW( szDestFileName, lpszQuoLogPathName );
                lstrcatW( szDestFileName, FindData.cFileName );

                status = QfsCopyFile( szSourceFileName, szDestFileName, FALSE );
                if ( !status ) 
                {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpRestoreClusterDatabase: Unable to copy file %1!ws! to %2!ws!, Error = %3!d!\n",
                        szSourceFileName,
                        szDestFileName,
                        status);
                     CL_LOGFAILURE( status );
                     goto FnExit;
                } 
                //
                //  Set the file attribute to normal. There is no reason
                //  to fail in this step since the quorum disk is ours
                //  and we succeeded in copying the file.
                //
                if ( !QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
                {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[DM] DmpLogCheckpointAndBackup::Error in changing %1!ws! attribute to NORMAL, error = %2!u!\n",
                         szDestFileName,
                         status);
                    CL_LOGFAILURE( status );
                    goto FnExit;
                }
            }
        }
skip:                 
        if ( QfsFindNextFile( hFindFile, &FindData ) )
        {
            status = ERROR_SUCCESS;
        } else
        {
            status = GetLastError();
        }
    }
    
    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[DM] DmpRestoreClusterDatabase: FindNextFile failed! Error = %1!u!\n",
            status);
    }

FnExit:
    QfsFindCloseIfValid ( hFindFile );
    
    LocalFree ( szSourceFileName );
    LocalFree ( szSourcePathName );
    
    return ( status );
}

/****
@func       DWORD | DmpHandleNodeDownEvent | Handle the node down event
            for DM.

@parm       IN LPVOID | NotUsed | Unused parameter. 
            
@rdesc      Returns ERROR_SUCCESS.

@xref       <f DmpEventHandler> 
****/
DWORD DmpHandleNodeDownEvent(
    IN LPVOID  NotUsed )
{
    //
    // Chittur Subbaraman (chitturs) - 7/23/99
    //
    // This function handles the DM node down processing as a separate
    // thread. The reasons for creating this thread are outlined in
    // DmpEventHandler.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpHandleNodeDownEvent - Entry...\r\n");
    
    //
    // SS: I am not the owner of the quorum resource as yet, but I might
    // be after rearbitration, in that case, just set a flag saying we
    // need to checkpoint.  It will be looked at when the quorum resource
    // comes online. The following function in FM checks if the 
    // quorum is online on this node and if it is, it calls 
    // the checkpoint callback function.  If it is not, it sets the 
    // global boolean variable passed to TRUE.
    //
    FmCheckQuorumState( DmpLogCheckPointCb, &gbNeedToCheckPoint );

    ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpHandleNodeDownEvent - Exit...\r\n");

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmreg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmreg.c

Abstract:

    Contains the registry access routines for the Config Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

#include <align.h>

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE     gLockDmpRoot;
#endif

HDMKEY
DmGetRootKey(
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens the registry key at the root of the cluster registry database

Arguments:

    samDesired - Supplies requested security access

Return Value:

    A handle to the opened registry key.

    NULL on error. LastError will be set to the specific error code.

--*/

{
    DWORD Error;
    PDMKEY Key;

    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+sizeof(WCHAR));
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    //  Acquire DM root lock to synchronize with DmRollbackRegistry.
    //
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    Error = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          DmpClusterParametersKeyName,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Error != ERROR_SUCCESS) {
        LocalFree(Key);
        SetLastError(Error);
        Key = NULL;
        goto FnExit;
    }
    Key->Name[0] = '\0';
    Key->GrantedAccess = samDesired;
    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    return((HDMKEY)Key);

}


DWORD
DmCloseKey(
    IN HDMKEY hKey
    )

/*++

Routine Description:

    Closes a handle to an open HDMKEY key.

Arguments:

    hKey - Supplies the handle to be closed.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Error = ERROR_SUCCESS;
    PDMKEY Key;

    //
    // Nobody better EVER close one of the global keys.
    //
    CL_ASSERT(hKey != DmClusterParametersKey);
    CL_ASSERT(hKey != DmResourcesKey);
    CL_ASSERT(hKey != DmResourceTypesKey);
    CL_ASSERT(hKey != DmQuorumKey);
    CL_ASSERT(hKey != DmGroupsKey);
    CL_ASSERT(hKey != DmNodesKey);
    CL_ASSERT(hKey != DmNetworksKey);
    CL_ASSERT(hKey != DmNetInterfacesKey);

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //if the key was deleted and invalidated and couldnt be reopened
    // it will be set to NULL, in this case we dont call regclosekey

    if( Key == NULL ) goto FnExit;
        
    if (ISKEYDELETED(Key))
        goto CleanupKey;

    Error = RegCloseKey(Key->hKey);
    if (Error != ERROR_SUCCESS) 
    {
        CL_LOGFAILURE(Error);
        goto FnExit;
    }

CleanupKey:
    EnterCriticalSection(&KeyLock);
    RemoveEntryList(&Key->ListEntry);
    DmpRundownNotify(Key);
    LeaveCriticalSection(&KeyLock);
    LocalFree(Key);
    
FnExit:    
    RELEASE_LOCK(gLockDmpRoot);
    return(Error);
}


HDMKEY
DmCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:

    Creates a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, it is created on all nodes in
    the cluster.

Arguments:

    hKey - Supplies the key that the create is relative to.

    lpSubKey - Supplies the key name relative to hKey

    dwOptions - Supplies any registry option flags. 

    samDesired - Supplies desired security access mask

    lpSecurityDescriptor - Supplies security for the newly created key.

    Disposition - Returns whether the key was opened (REG_OPENED_EXISTING_KEY)
        or created (REG_CREATED_NEW_KEY)

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY Parent;
    PDMKEY Key=NULL;
    DWORD NameLength;
    DWORD Status = ERROR_SUCCESS;
    HDMKEY NewKey;
    PDM_CREATE_KEY_UPDATE CreateUpdate = NULL;
    DWORD SecurityLength;

    // if this is a request to create a volatile key, refuse it
    // we dont support volatile keys in the cluster hive since
    // we cant roll back the cluster hive then.
    if (dwOptions == REG_OPTION_VOLATILE)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    //
    // Issue a global update to create the key.
    //

    Parent = (PDMKEY)hKey;

    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    //get the length of the security structure
    if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
        SecurityLength = GetSecurityDescriptorLength(lpSecurityDescriptor);
    } else {
        SecurityLength = 0;
    }


    CreateUpdate = (PDM_CREATE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, sizeof(DM_CREATE_KEY_UPDATE));
    if (CreateUpdate == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Issue the update.
    //
    CreateUpdate->lpDisposition = lpDisposition;
    CreateUpdate->phKey = &Key->hKey;
    CreateUpdate->samDesired = samDesired;
    CreateUpdate->dwOptions = dwOptions;

    if (ARGUMENT_PRESENT(lpSecurityDescriptor)) {
        CreateUpdate->SecurityPresent = TRUE;
    } else {
        CreateUpdate->SecurityPresent = FALSE;
    }

    Status = GumSendUpdateEx(GumUpdateRegistry,
                             DmUpdateCreateKey,
                             3,
                             sizeof(DM_CREATE_KEY_UPDATE),
                             CreateUpdate,
                             (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                             Key->Name,
                             SecurityLength,
                             lpSecurityDescriptor);

    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    if (CreateUpdate) LocalFree(CreateUpdate);

    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
    {
        return ((HDMKEY)Key);
    }
}


HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY  Parent;
    PDMKEY  Key=NULL;
    DWORD   NameLength;
    DWORD   Status = ERROR_SUCCESS;

    Parent = (PDMKEY)hKey;

    //hold the shared lock
    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Parent))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // Open the key on the local machine.
    //
    Status = RegOpenKeyEx(Parent->hKey,
                          lpSubKey,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name. only append a trailing backslash
    // if a parent name and subkey are non-null
    //
    lstrcpyW(Key->Name, Parent->Name);
    if ((Key->Name[0] != UNICODE_NULL) && (lpSubKey[0] != UNICODE_NULL)) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
        return((HDMKEY)Key);


}



DWORD
DmEnumKey(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    OUT OPTIONAL PFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    Enumerates the subkeys of a cluster registry key.

Arguments:

    hKey - Supplies the registry key for which the subkeys should
           be enumerated.

    dwIndex - Supplies the index to be enumerated.

    KeyName - Returns the name of the dwIndex subkey. The memory
           allocated for this buffer must be freed by the client.

    lpLastWriteTime - Returns the last write time.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY Key;
    DWORD  Status;
    FILETIME LastTime;

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    Status = RegEnumKeyExW(Key->hKey,
                         dwIndex,
                         lpName,
                         lpcbName,
                         NULL,
                         NULL,
                         NULL,
                         &LastTime);

    if (lpLastWriteTime != NULL) {
        *lpLastWriteTime = LastTime;
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmSetValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key.

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DWORD Status= ERROR_SUCCESS;        //initialize to success
    PDMKEY Key;
    DWORD NameLength;
    DWORD ValueNameLength;
    DWORD UpdateLength;
    PDM_SET_VALUE_UPDATE Update;
    PUCHAR Dest;


    Key = (PDMKEY)hKey;

    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    //
    // round lengths such that pointers to the data trailing the structure are
    // aligned on the architecture's natural boundary
    //
    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));

    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
    ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));

    UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
                   NameLength +
                   ValueNameLength +
                   cbData;


    Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
    Update->DataOffset = Update->NameOffset + ValueNameLength;
    Update->DataLength = cbData;
    Update->Type = dwType;
    CopyMemory(Update->KeyName, Key->Name, NameLength);

    Dest = (PUCHAR)Update + Update->NameOffset;
    CopyMemory(Dest, lpValueName, ValueNameLength);

    Dest = (PUCHAR)Update + Update->DataOffset;
    CopyMemory(Dest, lpData, cbData);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateSetValue,
                  UpdateLength,
                  Update);


    LocalFree(Update);

    return(Status);

}


DWORD
DmDeleteValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY Key;
    DWORD NameLength;
    DWORD ValueNameLength;
    DWORD UpdateLength;
    PDM_DELETE_VALUE_UPDATE Update;
    PUCHAR Dest;
    DWORD Status;

    Key = (PDMKEY)hKey;
    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);


    //
    // round up length to align pointer to ValueName on natural architecture
    // boundary
    //
    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));

    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);

    UpdateLength = sizeof(DM_DELETE_VALUE_UPDATE) +
                   NameLength +
                   ValueNameLength;

        Update = (PDM_DELETE_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    Update->NameOffset = FIELD_OFFSET(DM_DELETE_VALUE_UPDATE, KeyName)+NameLength;

    CopyMemory(Update->KeyName, Key->Name, NameLength);

    Dest = (PUCHAR)Update + Update->NameOffset;
    CopyMemory(Dest, lpValueName, ValueNameLength);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateDeleteValue,
                  UpdateLength,
                  Update);
    LocalFree(Update);

    return(Status);
}


DWORD
DmQueryValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Queries a named value for the specified cluster registry subkey

Arguments:

    hKey - Supplies the subkey whose value should be queried

    lpValueName - Supplies the named value to be queried

    lpType - Returns the type of the value's data

    lpData - Returns the value's data

    lpcbData - Supplies the size (in bytes) of the lpData buffer
               Returns the number of bytes copied into the lpData buffer
               If lpData==NULL, cbData is set to the required buffer
               size and the function returns ERROR_SUCCESS

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Status;

    Key = (PDMKEY)hKey;
    //check if the key was deleted and invalidated

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegQueryValueEx(Key->hKey,
                           lpValueName,
                           NULL,
                           lpType,
                           lpData,
                           lpcbData);
FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmQueryDword(
    IN  HDMKEY  hKey,
    IN  LPCWSTR lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    )

/*++

Routine Description:

    Reads a REG_DWORD registry value. If the value is not present, then
    default to the value supplied in lpDefaultValue (if present).

Arguments:

    hKey        - Open key for the value to be read.

    lpValueName - Unicode name of the value to be read.

    lpValue     - Pointer to the DWORD into which to read the value.

    lpDefaultValue - Optional pointer to a DWORD to use as a default value.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Status;
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    Status = RegQueryValueEx(Key->hKey,
                             lpValueName,
                             NULL,
                             &ValueType,
                             (LPBYTE)lpValue,
                             &ValueSize);

    if ( Status == ERROR_SUCCESS ) {
        if ( ValueType != REG_DWORD ) {
            Status = ERROR_INVALID_PARAMETER;
        }
    } else {
        if ( ARGUMENT_PRESENT( lpDefaultValue ) ) {
            *lpValue = *lpDefaultValue;
            Status = ERROR_SUCCESS;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

} // DmQueryDword


DWORD
DmQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        if (*StringSize) status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = LocalAlloc(LMEM_FIXED, *StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            LocalFree(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // DmQueryString


VOID
DmEnumKeys(
    IN HDMKEY RootKey,
    IN PENUM_KEY_CALLBACK Callback,
    IN PVOID Context
    )

/*++

 Routine Description:

     Enumerates the subkeys of the given registry key. For each
     subkey, a string is allocated to hold the subkey name and
     the subkey is opened. The specified callback function is
     called and passed the subkey handle and subkey name.

     The callback function is responsible for closing the subkey
     handle and freeing the subkey name.

 Arguments:

    RootKey - Supplies a handle to the key whose subkeys are to
              be enumerated.

    Callback - Supplies the callback routine.

    Context - Supplies an arbitrary context to be passed to the
              callback routine.

 Return Value:

    None.

--*/
{
    PWSTR KeyName;
    HDMKEY SubKey;
    DWORD Index;
    DWORD Status;
    FILETIME FileTime;
    PWSTR NameBuf;
    DWORD NameBufSize;
    DWORD OrigNameBufSize;

    //
    // Find the length of the longest subkey name.
    //
    Status = DmQueryInfoKey(RootKey,
                            NULL,
                            &NameBufSize,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        return;
    }

    NameBufSize = (NameBufSize + 1)*sizeof(WCHAR);
    NameBuf = LocalAlloc(LMEM_FIXED, NameBufSize);
    if (NameBuf == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
    }
    OrigNameBufSize = NameBufSize;

    //
    // Enumerate the subkeys
    //
    Index = 0;
    do {
        NameBufSize = OrigNameBufSize;
        Status = DmEnumKey( RootKey,
                            Index,
                            NameBuf,
                            &NameBufSize,
                            NULL);

        if (Status == ERROR_SUCCESS) {
            KeyName = LocalAlloc(LMEM_FIXED, (wcslen(NameBuf)+1)*sizeof(WCHAR));
            if (KeyName != NULL) {

                wcscpy(KeyName, NameBuf);

                //
                // Open the key
                //
                SubKey = DmOpenKey( RootKey,
                                    KeyName,
                                    MAXIMUM_ALLOWED);
                if (SubKey == NULL) {
                    Status = GetLastError();
                    CL_UNEXPECTED_ERROR(Status);
                    LocalFree(KeyName);
                } else {
                    (Callback)(SubKey,
                               KeyName,
                               Context);
                }

            } else {
                CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        Index++;
    } while ( Status == ERROR_SUCCESS );

    LocalFree(NameBuf);

} // DmEnumKeys


VOID
DmEnumValues(
    IN HDMKEY RootKey,
    IN PENUM_VALUE_CALLBACK Callback,
    IN PVOID Context
    )

/*++

 Routine Description:

     Enumerates the values of the given registry key. For each
     value, a string is allocated to hold the value name and a
     buffer is allocated to hold its data. The specified callback
     function is called and passed the value name and data.

     The callback function must not free either the value name
     or its buffer. If it needs this data after the callback
     returns, it must copy it.

 Arguments:

    RootKey - Supplies a handle to the key whose values are to
              be enumerated.

    Callback - Supplies the callback routine.

    Context - Supplies an arbitrary context to be passed to the
              callback routine.

 Return Value:

    None.

--*/
{
    DWORD Index;
    DWORD Status;
    PWSTR NameBuf;
    DWORD NameBufSize;
    DWORD ValueCount;
    DWORD MaxValueLen;
    DWORD MaxNameLen;
    PVOID ValueBuf;
    DWORD cbName;
    DWORD cbData;
    DWORD dwType;
    BOOL Continue;

    //
    // Find the length of the longest value name and data.
    //
    Status = DmQueryInfoKey(RootKey,
                            NULL,
                            NULL,
                            &ValueCount,
                            &MaxNameLen,
                            &MaxValueLen,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR(Status);
        return;
    }

    NameBuf = CsAlloc((MaxNameLen+1)*sizeof(WCHAR));
    ValueBuf = CsAlloc(MaxValueLen);

    //
    // Enumerate the values
    //
    for (Index=0; Index<ValueCount; Index++) {
        cbName = MaxNameLen+1;
        cbData = MaxValueLen;
        Status = DmEnumValue(RootKey,
                             Index,
                             NameBuf,
                             &cbName,
                             &dwType,
                             ValueBuf,
                             &cbData);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] DmEnumValue for index %1!d! of key %2!ws! failed %3!d!\n",
                       Index,
                       ((PDMKEY)(RootKey))->Name,
                       Status);
        } else {
            Continue = (Callback)(NameBuf,
                                  ValueBuf,
                                  dwType,
                                  cbData,
                                  Context);
            if (!Continue) {
                break;
            }
        }
    }

    CsFree(NameBuf);
    CsFree(ValueBuf);

} // DmEnumValues


DWORD
DmQueryInfoKey(
    IN  HDMKEY  hKey,
    OUT LPDWORD SubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD Values,
    OUT LPDWORD MaxValueNameLen,
    OUT LPDWORD MaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME FileTime
    )

/*++

Routine Description:

Arguments:

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PDMKEY  Key;
    DWORD   Ignored;
    DWORD   Status;

    Key = (PDMKEY)hKey;  

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegQueryInfoKeyW( Key->hKey,
                             NULL,
                             &Ignored,
                             NULL,
                             SubKeys,
                             MaxSubKeyLen,
                             &Ignored,
                             Values,
                             MaxValueNameLen,
                             MaxValueLen,
                             lpcbSecurityDescriptor,
                             FileTime);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

} // DmQueryInfoKey


DWORD
DmDeleteKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY                      Key;
    DWORD                       NameLength;
    DWORD                       UpdateLength;
    PDM_DELETE_KEY_UPDATE Update;
    DWORD                       Status;

    Key = (PDMKEY)hKey;

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    NameLength = (lstrlenW(Key->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
        UpdateLength = NameLength + sizeof(DM_DELETE_KEY_UPDATE);

    Update = (PDM_DELETE_KEY_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);

    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    CopyMemory(Update->Name, Key->Name, (lstrlenW(Key->Name) + 1) * sizeof(WCHAR));
    if (Update->Name[0] != '\0') {
        lstrcatW(Update->Name, L"\\");
    }
    lstrcatW(Update->Name, lpSubKey);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateDeleteKey,
                  sizeof(DM_DELETE_KEY_UPDATE)+NameLength,
                  Update);

    LocalFree(Update);
    return(Status);
}


DWORD
DmDeleteTree(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    )
/*++

Routine Description:

    Deletes the specified registry subtree. All subkeys are
    deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL.
        Any subkeys of the specified key will also be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    HDMKEY Subkey;
    DWORD i;
    DWORD Status;
    LPWSTR KeyBuffer=NULL;
    DWORD MaxKeyLen;
    DWORD NeededSize;

    Subkey = DmOpenKey(hKey,
                       lpSubKey,
                       MAXIMUM_ALLOWED);
    if (Subkey == NULL) {
        Status = GetLastError();
        return(Status);
    }

    //
    // Get the size of name buffer we will need.
    //
    Status = DmQueryInfoKey(Subkey,
                            NULL,
                            &MaxKeyLen,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
        DmCloseKey(Subkey);
        return(Status);
    }
    KeyBuffer = LocalAlloc(LMEM_FIXED, (MaxKeyLen+1)*sizeof(WCHAR));
    if (KeyBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
        DmCloseKey(Subkey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate the subkeys and apply ourselves recursively to each one.
    //
    i=0;
    do {
        NeededSize = MaxKeyLen+1;
        Status = DmEnumKey(Subkey,
                           i,
                           KeyBuffer,
                           &NeededSize,
                           NULL);
        if (Status == ERROR_SUCCESS) {
            //
            // Call ourselves recursively on this keyname.
            //
            DmDeleteTree(Subkey, KeyBuffer);

        } else {
            //
            // Some odd error, keep going with the next key.
            //
            ++i;
        }

    } while ( Status != ERROR_NO_MORE_ITEMS );

    DmCloseKey(Subkey);

    Status = DmDeleteKey(hKey, lpSubKey);

    if (KeyBuffer != NULL) {
        LocalFree(KeyBuffer);
    }
    return(Status);
}


DWORD
DmEnumValue(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Enumerates the specified value of a registry subkey

Arguments:

    hKey - Supplies the registry key handle

    dwIndex - Supplies the index of the value to be enumerated

    lpValueName - Points to a buffer that receives the name of the value,
        including the terminating null character

    lpcbValueName - Points to a variable that specifies the size, in characters,
        of the buffer pointed to by the lpValueName parameter. This size should
        include the terminating null character. When the function returns, the
        variable pointed to by lpcbValueName contains the number of characters
        stored in the buffer. The count returned does not include the terminating
        null character.

    lpType - Returns the value data type

    lpData - Points to a buffer that receives the data for the value entry. This
        parameter can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the
        buffer pointed to by the lpData parameter. When the function returns, the
        variable pointed to by the lpcbData parameter contains the number of bytes
        stored in the buffer. This parameter can be NULL, only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PDMKEY  Key;
    DWORD   Status;
    DWORD   cbValueName = *lpcbValueName;

    Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }


    Status = RegEnumValueW(Key->hKey,
                         dwIndex,
                         lpValueName,
                         lpcbValueName,
                         NULL,
                         lpType,
                         lpData,
                         lpcbData);

    //
    //  The following code is to mask the registry behavior by which RegEnumValue does not necessarily 
    //  fill in lpValueName (even though we specify a large enough buffer) when lpData buffer is a 
    //  valid buffer but a little too small.
    //
    if ( Status == ERROR_MORE_DATA )
    {
        DWORD       dwError;
        
        dwError = RegEnumValueW( Key->hKey,
                                 dwIndex,
                                 lpValueName,
                                 &cbValueName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

        if ( ( dwError != ERROR_SUCCESS ) && 
             ( dwError != ERROR_MORE_DATA ) )  
        {
            Status = dwError;
        } else
        {
            *lpcbValueName = cbValueName;
        }
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);


}


DWORD
DmAppendToMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )

/*++

Routine Description:

    Adds another string to a REG_MULTI_SZ value. If the value does
    not exist, it will be created.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with KEY_READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be appended to the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD ValueLength = 512;
    DWORD ReturnedLength;
    LPWSTR ValueData;
    DWORD StringLength;
    DWORD Status;
    DWORD cbValueData;
    PWSTR s;
    DWORD Type;

    StringLength = (lstrlenW(lpString)+1)*sizeof(WCHAR);
retry:
    ValueData = LocalAlloc(LMEM_FIXED, ValueLength + StringLength);
    if (ValueData == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    cbValueData = ValueLength;
    Status = DmQueryValue(hKey,
                          lpValueName,
                          &Type,
                          (LPBYTE)ValueData,
                          &cbValueData);
    if (Status == ERROR_MORE_DATA) {
        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = cbValueData;
        LocalFree(ValueData);
        goto retry;
    }
    if (Status == ERROR_FILE_NOT_FOUND) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData;

    } else if (Status == ERROR_SUCCESS) {
        //
        // A value already exists. Append our string to the
        // MULTI_SZ.
        //
        s = (PWSTR)((PCHAR)ValueData + cbValueData) - 1;
    } else {
        LocalFree(ValueData);
        return(Status);
    }

    CopyMemory(s, lpString, StringLength);
    s += (StringLength / sizeof(WCHAR));
    *s++ = L'\0';

    Status = DmSetValue(hKey,
                        lpValueName,
                        REG_MULTI_SZ,
                        (CONST BYTE *)ValueData,
                        (DWORD)((s-ValueData)*sizeof(WCHAR)));
    LocalFree(ValueData);

    return(Status);
}


DWORD
DmRemoveFromMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    )
/*++

Routine Description:

    Removes a string from a REG_MULTI_SZ value.

Arguments:

    hKey - Supplies the key where the value exists. This key must
           have been opened with READ | KEY_SET_VALUE access

    lpValueName - Supplies the name of the value.

    lpString - Supplies the string to be removed from the REG_MULTI_SZ value

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    LPWSTR Buffer=NULL;
    DWORD BufferSize;
    DWORD DataSize;
    LPWSTR Current;
    DWORD CurrentLength;
    DWORD i;
    LPWSTR Next;
    PCHAR Src, Dest;
    DWORD NextLength;
    DWORD MultiLength;


    BufferSize = 0;
    Status = DmQueryString(hKey,
                           lpValueName,
                           REG_MULTI_SZ,
                           &Buffer,
                           &BufferSize,
                           &DataSize);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    MultiLength = DataSize/sizeof(WCHAR);
    Status = ClRtlMultiSzRemove(Buffer,
                                &MultiLength,
                                lpString);
    if (Status == ERROR_SUCCESS) {
        //
        // Set the new value back.
        //
        Status = DmSetValue(hKey,
                            lpValueName,
                            REG_MULTI_SZ,
                            (CONST BYTE *)Buffer,
                            MultiLength * sizeof(WCHAR));

    } else if (Status == ERROR_FILE_NOT_FOUND) {
        Status = ERROR_SUCCESS;
    }

FnExit:
    if (Buffer) LocalFree(Buffer);
    return(Status);
}


DWORD
DmGetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN LPDWORD lpcbSecurityDescriptor
    )
/*++

Routine Description:

    Retrieves a copy of the security descriptor protecting
    the specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key

    RequestedInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the requested security information.

    pSecurityDescriptor - Points to a buffer that receives a copy of the
        requested security descriptor.

    lpcbSecurityDescriptor - Points to a variable that specifies the size,
        in bytes, of the buffer pointed to by the pSecurityDescriptor parameter.
        When the function returns, the variable contains the number of bytes
        written to the buffer.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PDMKEY Key = (PDMKEY)hKey;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it
    if (ISKEYDELETED(Key))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }

    Status = RegGetKeySecurity(Key->hKey,
                               RequestedInformation,
                               pSecurityDescriptor,
                               lpcbSecurityDescriptor);

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmSetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    Sets the security on the specified registry key.

Arguments:

    hKey - Supplies a handle to a currently open key.

    SecurityInformation - Supplies the type of security information to
        be set.

    pRpcSecurityDescriptor - Supplies the security information

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PDMKEY Key = (PDMKEY)hKey;

    //make sure the key wasnt deleted/invalidated/reopened while we had a
    //handle open to it

    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    Status = GumSendUpdateEx(GumUpdateRegistry,
                             DmUpdateSetSecurity,
                             4,
                             sizeof(SecurityInformation),
                             &SecurityInformation,
                             (lstrlenW(Key->Name)+1)*sizeof(WCHAR),
                             Key->Name,
                             GetSecurityDescriptorLength(pSecurityDescriptor),
                             pSecurityDescriptor,
                             sizeof(Key->GrantedAccess),
                             &Key->GrantedAccess);

    return(Status);
}



DWORD
DmCommitRegistry(
    VOID
    )
/*++

Routine Description:

    Flushes the registry to disk, producing a new persistent cluster registry state.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    ACQUIRE_SHARED_LOCK(gLockDmpRoot);

    Status = RegFlushKey(DmpRoot);

    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmCommitRegistry failed to flush dirty data %1!d!\n",
                   Status);
    }
    return(Status);
}


DWORD
DmRollbackRegistry(
    VOID
    )
/*++

Routine Description:

    Rolls the registry back to the last previously committed state.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD       Status;
    BOOLEAN     WasEnabled;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    //hold the key lock as well
    EnterCriticalSection(&KeyLock);


    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmRollbackRegistry failed to restore privilege %1!d!\n",
               Status);
        goto FnExit;
    }

    //
    // Restart the registry watcher thread so it is not trying to use
    // DmpRoot while we are messing with things.
    //
    DmpRestartFlusher();

    //
    // Close any open handles
    //
    DmpInvalidateKeys();


    Status = NtRestoreKey(DmpRoot,
                              NULL,
                              REG_REFRESH_HIVE);

    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                       WasEnabled);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmRollbackRegistry: NtRestoreKey failed %1!d!\n",
               Status);
        goto FnExit;
    }

    //
    // Reopen handles
    //
    RegCloseKey(DmpRoot);
    RegCloseKey(DmpRootCopy);
    DmpRoot = DmpRootCopy = NULL;
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRootCopy);
    }
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmRollbackRegistry failed to reopen DmpRoot %1!d!\n",
                   Status);
        goto FnExit;
    }
    DmpReopenKeys();

FnExit:
    //release the locks
    LeaveCriticalSection(&KeyLock);
    RELEASE_LOCK(gLockDmpRoot);
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] DmRollbackRegistry failed to flush dirty data %1!d!\n",
                   Status);
    }

    return(Status);
}


DWORD
DmRtlCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY *  phkResult,
    OUT LPDWORD lpDisposition
    )

/*++

Routine Description:
    Wrapper function for DmCreateKey. Its definition corresponds to
    ClusterRegCreateKey.  This should be used instead of DmCreateKey
    when passing to ClRtl* funtions.
--*/
{
    DWORD status;
    
    *phkResult = DmCreateKey(
                        hKey,
                        lpSubKey,
                        dwOptions,
                        samDesired,
                        lpSecurityDescriptor,
                        lpDisposition
                   );
    if (*phkResult == NULL)
        status=GetLastError();
    else 
        status = ERROR_SUCCESS;    
    return status;
 }
                    


DWORD
DmRtlOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT HDMKEY * phkResult
    )

/*++

Routine Description:
    Wrapper function for DmOpenKey. Its definition corresponds to
    ClusterRegOpenKey.  This should be used instead of DmOpenKey when 
    passing to ClRtl* funtions. See DmOpenKey for argument description
--*/
{    
    DWORD   status;

    *phkResult = DmOpenKey(
                    hKey,
                    lpSubKey,
                    samDesired
                    );
    if (*phkResult == NULL)
        status=GetLastError();
    else
        status=ERROR_SUCCESS;
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmsync.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmsync.c

Abstract:

    Contains the registry synchronization code for the Cluster Database
    Manager.

Author:

    John Vert (jvert) 5/23/1996

Revision History:

--*/
#include "dmp.h"


#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

const WCHAR DmpClusterParametersKeyName[] = L"Cluster";
extern const UNICODE_STRING RegistryMachineClusterString = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Cluster");
extern const OBJECT_ATTRIBUTES RegistryMachineClusterObja = RTL_CONSTANT_OBJECT_ATTRIBUTES(&RegistryMachineClusterString, OBJ_CASE_INSENSITIVE);

//
// Private Constants
//
#define CHUNK_SIZE 4096

//
// Private macro
//
#define ClosePipe( _pipe )  \
(_pipe.push)(_pipe.state,   \
             NULL,          \
             0 )            \



//
// Client-Side Utility Routines
//
void
FilePipePush(
    FILE_PIPE_STATE *state,
    unsigned char *pBuffer,
    unsigned long BufferSize
    )
{
    DWORD   dwBytesWritten;
    DWORD   dwStatus;

    dwStatus = NmCryptor_Decrypt(&state->Cryptor, pBuffer, BufferSize);
    if (dwStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "FilePipePush :: Decryption failed with error %1!u!\n",
            dwStatus);
        RpcRaiseException(dwStatus);                
    }    

    if (BufferSize != 0) {
        if (!QfsWriteFile (state->hFile,
                   state->Cryptor.PayloadBuffer,
                   state->Cryptor.PayloadSize,
                   &dwBytesWritten,
                   NULL))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "FilePipePush :: Write file failed with error %1!u!\n",
                dwStatus);
            RpcRaiseException(dwStatus);                
        }
    }
}

void
FilePipePull(
    FILE_PIPE_STATE *state,
    unsigned char *pBuffer,
    unsigned long BufferSize,
    unsigned long __RPC_FAR *Written
    )
{
    DWORD dwBytesRead;
    BOOL Success;
    DWORD dwStatus;

    if (BufferSize != 0) {
        NmCryptor_PrepareEncryptionBuffer(
            &state->Cryptor, pBuffer,  BufferSize);

        Success = QfsReadFile (state->hFile,
                            state->Cryptor.PayloadBuffer,
                            state->Cryptor.PayloadSize,
                            &dwBytesRead,
                            NULL);

        if (!Success)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "FilePipePush :: Read file failed with error %1!u!\n",
                dwStatus);
            RpcRaiseException(dwStatus);                
        }

        dwStatus = NmCryptor_Encrypt(&state->Cryptor, dwBytesRead);
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "FilePipePush :: Encryption failed with error %1!u!\n",
                dwStatus);
            RpcRaiseException(dwStatus);                
        }
        
        *Written = state->Cryptor.EncryptedSize;

    }
}


void
PipeAlloc (
    FILE_PIPE_STATE *state,
    unsigned long   RequestedSize,
    unsigned char **buf,
    unsigned long  *ActualSize
    )
{
    *buf = state->pBuffer;

    *ActualSize = (RequestedSize < state->BufferSize ?
                   RequestedSize :
                   state->BufferSize);
}


VOID
DmInitFilePipe(
    IN PFILE_PIPE FilePipe,
    IN QfsHANDLE hFile
    )
/*++

Routine Description:

    Initializes a file pipe.

Arguments:

    FilePipe - Supplies a pointer to the file pipe to be initialized

    hFile - Supplies a handle to the file to be transmitted.

Return Value:

    None.

--*/

{
    FilePipe->State.hFile = hFile;
    FilePipe->State.BufferSize = CHUNK_SIZE;
    FilePipe->State.pBuffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);
    if (FilePipe->State.pBuffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    FilePipe->Pipe.state = (char __RPC_FAR *)&FilePipe->State;
    FilePipe->Pipe.alloc = (void __RPC_FAR *)PipeAlloc;
    FilePipe->Pipe.push = (void __RPC_FAR *)FilePipePush;
    FilePipe->Pipe.pull = (void __RPC_FAR *)FilePipePull;

    NmCryptor_Init(&FilePipe->State.Cryptor, TRUE);
}


VOID
DmFreeFilePipe(
    IN PFILE_PIPE FilePipe
    )
/*++

Routine Description:

    Frees a file pipe initialized by DmInitFilePipe

Arguments:

    FilePipe - Supplies the file pipe to be freed.

Return Value:

    None

--*/

{
    NmCryptor_Destroy(&FilePipe->State.Cryptor);
    LocalFree(FilePipe->State.pBuffer);
}


DWORD
DmPullFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    )
/*++

Routine Description:

    Creates a new file and pulls the data down the RPC pipe

Arguments:

    FileName - Supplies the name of the file.

    Pipe - Supplies the RPC pipe to pull the data from.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    QfsHANDLE File;
    DWORD Status = ERROR_SUCCESS;
    PUCHAR Buffer;
    DWORD BytesRead;
    NM_CRYPTOR Decryptor;

    NmCryptor_Init(&Decryptor, TRUE);
    
    //
    // Create a new file to hold the bits from the client.
    //
    File = QfsCreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      0,
                      NULL);

    if (!QfsIsHandleValid(File)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPullFile failed to create file %1!ws! error %2!d!\n",
                   FileName,
                   Status);
        return(Status);
    } 
    
    Buffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);

    if (Buffer == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        QfsCloseHandle(File);
        CL_UNEXPECTED_ERROR( Status );
        return (Status);
    } 

    try {
        do {
            (Pipe.pull)(Pipe.state,
                        Buffer,
                        CHUNK_SIZE,
                        &BytesRead);
            if (BytesRead == 0) {
                break;
            }

            Status = NmCryptor_Decrypt(&Decryptor, Buffer, BytesRead);
            if (Status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPullFile :: Failed to decrypt buffer for '%1!ws!' error %2!d!\n",
                   FileName, Status);
                break;                       
            }
            
            if (!QfsWriteFile(File,
                      Decryptor.PayloadBuffer,
                      Decryptor.PayloadSize,
                      &BytesRead,
                      NULL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPullFile :: WriteFile to file failed with error %1!ws! error %2!d!\n",
                   FileName, Status);
                break;                       
            }
        } while ( TRUE );
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_ERROR,
                    "[DM] DmPullFile :: Exception code 0x%1!08lx! raised for file %2!ws!\n",
                    Status, FileName);       
    }
    
    LocalFree(Buffer);

    QfsFlushFileBuffers(File);
    
    QfsCloseHandle(File);

    NmCryptor_Destroy(&Decryptor);

    return(Status);

}


 DWORD
DmPushFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe,
    IN BOOL EncryptData
    )
/*++

Routine Description:

    Opens a file and pushes it down the RPC pipe

Arguments:

    FileName - Supplies the name of the file.

    Pipe - Supplies the RPC pipe to push it down.

    EncryptData - If TRUE, data passed over the Rpc pipe will be encrypted
                  (If NT5 node is in the cluster, data won't be encrypted) 

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    QfsHANDLE File;
    DWORD Status = ERROR_SUCCESS;
    PUCHAR Buffer;
    DWORD BytesRead;
    NM_CRYPTOR Encryptor;

    NmCryptor_Init(&Encryptor, EncryptData);

    //
    // Got a file with the right bits in it. Push it down
    // to the client.
    //
    File = QfsCreateFile(FileName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL);

    if (!QfsIsHandleValid(File)) {
        Status = GetLastError();
        ClosePipe( Pipe );
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[DM] DmPushFile failed to open file %1!ws! error %2!d!\n",
                   FileName,
                   Status);
        return(Status);
    } 
    
    Buffer = LocalAlloc(LMEM_FIXED, CHUNK_SIZE);

    if (Buffer == NULL) {
        ClosePipe( Pipe );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        QfsCloseHandle(File);
        CL_UNEXPECTED_ERROR( Status );
        return(Status);
    } 

    try {
        do {
            NmCryptor_PrepareEncryptionBuffer(
                &Encryptor, Buffer,  CHUNK_SIZE);
            
            if (!QfsReadFile(File,
                     Encryptor.PayloadBuffer,
                     Encryptor.PayloadSize,
                     &BytesRead,
                     NULL))
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmPushFile failed to read file %1!ws! error %2!d!\n",
                    FileName, Status);
                break;
            }

            Status = NmCryptor_Encrypt(&Encryptor, BytesRead);
            if (Status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[DM] DmPushFile failed to encrypt file %1!ws! error %2!d!\n",
                    FileName, Status);
                break;
            }

            (Pipe.push)(Pipe.state,
                        Buffer,
                        Encryptor.EncryptedSize);

        } while ( BytesRead != 0 );
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_ERROR,
                    "[DM] DmPushFile :: Exception code 0x%1!08lx! raised for file %2!ws!\n",
                    Status, FileName);       
    }
    
    LocalFree(Buffer);

    QfsCloseHandle(File);
    NmCryptor_Destroy(&Encryptor);

    return(Status);
}


DWORD
DmpSyncDatabase(
    IN RPC_BINDING_HANDLE  RpcBinding,
    IN OPTIONAL LPCWSTR Directory
    )
/*++

Routine Description:

    Connects to a remote node and attempts to sync with its
    cluster database.

Arguments:

    RpcBinding - The RPC binding handle to use to sync the database.

    Directory - if present, supplies the directory where CLUSDB should
                be created.

Return Value:

    ERROR_SUCCESS if the database was successfully updated.

    Win32 error otherwise

--*/
{
    DWORD Status;
    WCHAR FileName[MAX_PATH+1];
    FILE_PIPE FilePipe;
    QfsHANDLE hFile;

    //
    // Issue conditional synchronization
    //
    Status = DmCreateTempFileName(FileName);

    if (Status == ERROR_SUCCESS) {
        hFile = QfsCreateFile(FileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL);

        if (!QfsIsHandleValid(hFile)) {
            Status = GetLastError();
            CL_UNEXPECTED_ERROR( Status );
        } else {
            DmInitFilePipe(&FilePipe, hFile);
            Status = DmSyncDatabase(RpcBinding,
                                    FilePipe.Pipe);

            DmFreeFilePipe(&FilePipe);
            //
            //  Flush the file buffers to avoid corrupting CLUSDB on a power failure.
            //
            QfsFlushFileBuffers(hFile);
            QfsCloseHandle(hFile);

            if (Status == ERROR_SUCCESS) {

                //
                // A new registry file was successfully downloaded.
                // Install it into the current registry.
                //
                ClRtlLogPrint(LOG_UNUSUAL,"[DM] Obtained new database.\n");

                //acquire the exclusive locks so that no new keys are opened while
                // the registry is being reinstated
                ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
                // hold the key lock as well
                EnterCriticalSection(&KeyLock);

                // Invalidate any open keys
                DmpInvalidateKeys();

                Status = DmInstallDatabase(FileName, Directory, TRUE);

                if (Status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[DM] DmpSyncDatabase failed, error %1!u!.\n",
                               Status);
                }
                // Reopen the keys for read/write access
                DmpReopenKeys();
                // release the locks
                LeaveCriticalSection(&KeyLock);
                RELEASE_LOCK(gLockDmpRoot);

            } else {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[DM] Failed to get a new database, status %1!u!\n",
                    Status
                    );
                CL_UNEXPECTED_ERROR(Status);
            }

            QfsDeleteFile(FileName);
        }
    }

    return(Status);
}


DWORD
DmInstallDatabase(
    IN LPWSTR   FileName,
    IN OPTIONAL LPCWSTR Directory,
    IN BOOL     bDeleteSrcFile
    )
/*++

Routine Description:

    Installs a new cluster registry database from the specified file

Arguments:

    FileName - The name of the file from which to read the registry database
               to install.

    Directory - if present, supplies the directory where the CLUSDB file should
                be created.
                if not present, the current directory is used.

    bDeleteSrcFile - Delete the Source file represented by FileName.                

Return Value:

    ERROR_SUCCESS if the installation completed successfully

    Win32 error code otherwise.

--*/

{
    DWORD    Status;
    BOOLEAN  WasEnabled;
    WCHAR Path[MAX_PATH];
    WCHAR *p;
    WCHAR BkpPath[MAX_PATH];
    
    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        return(Status);
    }

    //
    // Restart the registry watcher thread so it is not trying to use
    // DmpRoot while we are messing with things.
    //
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    DmpRestartFlusher();

    //
    // Close DmpRoot (it should be the only thing open) so that we can
    // unload the current cluster database.
    //
    RegCloseKey(DmpRoot);
    RegCloseKey(DmpRootCopy);
    DmpRoot = DmpRootCopy = NULL;

    Status = RegUnLoadKey(HKEY_LOCAL_MACHINE, DmpClusterParametersKeyName);
    
    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
        WasEnabled);
    if (Status == ERROR_SUCCESS) {
        //
        // Get the CLUSDB full pathname.
        //
        if (Directory == NULL) {
            Status = GetModuleFileName(NULL, Path, MAX_PATH);

            //
            //  GetModuleFileName may not NULL terminate the Path.
            //
            Path [ RTL_NUMBER_OF ( Path ) - 1 ] = UNICODE_NULL;

            if (Status == 0) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[DM] Couldn't find cluster database\n");
                Status = GetLastError();
            } else {
                Status = ERROR_SUCCESS;
                p=wcsrchr(Path, L'\\');
                if (p != NULL) {
                    *p = L'\0';
                    wcscpy(BkpPath, Path);
#ifdef   OLD_WAY
                    wcscat(Path, L"\\CLUSDB");
#else    // OLD_WAY
                    wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY
                    wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
                } else {
                    CL_UNEXPECTED_ERROR(ERROR_FILE_NOT_FOUND);
                }
            }
        } else {
            lstrcpyW(Path, Directory);
            lstrcpyW(BkpPath, Path);
#ifdef   OLD_WAY
            wcscat(Path, L"\\CLUSDB");
#else    // OLD_WAY
            wcscat(Path, L"\\"CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY
            wcscat(BkpPath, L"\\"CLUSTER_DATABASE_TMPBKP_NAME);
        }
        if (Status == ERROR_SUCCESS) {
            //
            // Now copy the supplied file to CLUSDB
            //
            Status = DmpSafeDatabaseCopy(FileName, Path, BkpPath, bDeleteSrcFile);
            if (Status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[DM] DmInstallDatabase :: DmpSafeDatabaseCopy() failed %1!d!\n",
                           Status);

                // SS:  BUG BUG - we should not reload the old hive
                //on a join, that would be catastrophic to continue
                //on a form, while uploading from a checkpoint file
                // it would be the same
                //
                // Try and reload the old hive
                //
                // Status = DmpLoadHive(Path);
                CL_UNEXPECTED_ERROR(Status);
            } else {
                //
                // Finally, reload the hive.
                //
                Status = DmpLoadHive(Path);
            }
        }
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] RegUnloadKey of existing database failed %1!d!\n",
                   Status);
        goto FnExit;                   
    }

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmInstallDatabase :: failed to load hive %1!d!\n",
               Status);
        goto FnExit;               
    }
    //
    // Reopen DmpRoot and DmpRootCopy
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRoot);
    if ( Status != ERROR_SUCCESS ) {
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         DmpClusterParametersKeyName,
                         &DmpRootCopy);
    if ( Status != ERROR_SUCCESS ) {
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // HACKHACK John Vert (jvert) 6/3/1997
    //      There is a bug in the registry with refresh
    //      where the Parent field in the root cell doesn't
    //      get flushed to disk, so it gets blasted if we
    //      do a refresh. Then we crash in unload. So flush
    //      out the registry to disk here to make sure the
    //      right Parent field gets written to disk.
    //
    if (Status == ERROR_SUCCESS) {
        DWORD Dummy=0;
        //
        // Make something dirty in the root
        //
        RegSetValueEx(DmpRoot,
                      L"Valid",
                      0,
                      REG_DWORD,
                      (PBYTE)&Dummy,
                      sizeof(Dummy));
        RegDeleteValue(DmpRoot, L"Valid");
        Status = RegFlushKey(DmpRoot);
        if (Status != ERROR_SUCCESS)
        {
            CL_UNEXPECTED_ERROR(Status);
            ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmInstallDatabase : RegFlushKey failed with error %1!d!\n",
               Status);
        }

    }

FnExit:    
    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmGetDatabase(
    IN HKEY hKey,
    IN LPWSTR  FileName
    )
/*++

Routine Description:

    Writes the registry database to a specified file.

Arguments:

    hKey - Supplies the root of the registry tree to get.

    FileName - The name of the file into which to write the current
               registry database.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    Win32 error code otherwise.

--*/

{
    BOOLEAN  WasEnabled;
    DWORD    Status;
    NTSTATUS Error;

    //
    // Make sure this file does not exist already.
    //
    QfsDeleteFile(FileName);

    Status = ClRtlEnableThreadPrivilege(SE_BACKUP_PRIVILEGE,
                               &WasEnabled);
    if ( Status != STATUS_SUCCESS ) {
        CL_LOGFAILURE( Status );
        goto FnExit;
    }
    Status = QfsRegSaveKey(hKey,
                         FileName,
                         NULL);
    // this is used for checkpointing and shouldnt fail, but if it does we
    // will log an event and delete the file
    if ( Status != ERROR_SUCCESS ) {
        CL_LOGFAILURE( Status );
        CsLogEventData1( LOG_CRITICAL,
                         CS_DISKWRITE_FAILURE,
                         sizeof(Status),
                         &Status,
                         FileName );
        QfsDeleteFile(FileName);
    }

    Error = ClRtlRestoreThreadPrivilege(SE_BACKUP_PRIVILEGE,
                       WasEnabled);

    if (Error != ERROR_SUCCESS)
    {
        CL_UNEXPECTED_ERROR(Error);
    }
FnExit:
    return(Status);
}

//
//
// Server-side join routines.
//
//
error_status_t
s_DmSyncDatabase(
    IN     handle_t IDL_handle,
    OUT    BYTE_PIPE Regdata
    )
/*++

Routine Description:

    Pushes a new configuration database to a joining node.

Arguments:

    IDL_handle - RPC binding handle, not used.

    Regdata  - The RPC data pipe to use to transfer the data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    Win32 error code otherwise.

--*/
{
    HANDLE File;
    DWORD Status;
    WCHAR FileName[MAX_PATH+1];

    ClRtlLogPrint(LOG_UNUSUAL, "[DM] Supplying database to joining node.\n");

    Status = DmCreateTempFileName(FileName);

    if (Status == ERROR_SUCCESS) {
        DmCommitRegistry();         // Ensure up-to-date snapshot

        //
        //  Chittur Subbaraman (chitturs) - 01/19/2001
        //
        //  Hold the root lock before trying to save the hive. This is necessary so that
        //  an NtRestoreKey/RegCloseKey on the root key is not in progress at the time
        //  the save is attempted.
        //
        ACQUIRE_EXCLUSIVE_LOCK( gLockDmpRoot );

        Status = DmGetDatabase(DmpRoot,FileName);

        RELEASE_LOCK ( gLockDmpRoot );
        
        if (Status != ERROR_SUCCESS) {
            ClosePipe(Regdata);
            CL_UNEXPECTED_ERROR( Status );
        } else {
            Status = DmPushFile(FileName, Regdata, FALSE); // FALSE == don't encrypt
            QfsDeleteFile(FileName);
        }
    } else {
        RpcRaiseException( Status );
        ClosePipe(Regdata);
        CL_UNEXPECTED_ERROR( Status );
    }


    ClRtlLogPrint(LOG_UNUSUAL, 
        "[DM] Finished supplying database to joining node.\n"
        );

    return(Status);
}


DWORD
DmCreateTempFileName(
    OUT LPWSTR FileName
    )
/*++

Routine Description:

    Creates a temporary filename for use by the cluster service.

Arguments:

    FileName - Returns the name of the temporary file. The buffer
               pointed to must be big enough for at least MAX_PATH
               characters.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise

--*/

{
    WCHAR   TempPath[MAX_PATH];
    DWORD   Status;

    GetTempPath(sizeof(TempPath)/sizeof(WCHAR),TempPath);

    Status = QfsGetTempFileName(TempPath,L"CLS",0,FileName);
    if (Status == 0) {
        //
        // Somebody has probably set the TMP variable incorrectly.
        // Just use the current directory.
        //
        Status = QfsGetTempFileName(L".", L"CLS",0,FileName);
        if (Status == 0) {
            Status = GetLastError();
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }

    //
    //  Set DACL on the file handle object granting full rights only to admin and owner.
    //
    Status = QfsSetFileSecurityInfo( FileName,
                                      GENERIC_ALL,      // for Admins
                                      GENERIC_ALL,      // for Owner
                                      0 );              // for Everyone

    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[DM] DmCreateTempFile: ClRtlSetObjSecurityInfo failed for file %1!ws!, Status=%2!u!\r\n",
                      FileName,
                      Status);
        return ( Status );
    }

    return( ERROR_SUCCESS );
}


DWORD
DmpLoadHive(
    IN LPCWSTR Path
    )
/*++

Routine Description:

    Loads the cluster database into HKLM\Cluster

Arguments:

    Path - Supplies the fully qualified filename of the cluster database.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    BOOLEAN  WasEnabled;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES SourceFile;
    UNICODE_STRING FileName;
    NTSTATUS Status;
    BOOLEAN ErrorFlag;
    LPWSTR FreeBuffer;

    //
    // If the cluster database is not loaded, load it now.
    //
    ClRtlLogPrint(LOG_NOISE,
               "[DM] Loading cluster database from %1!ws!\n", Path);

    ErrorFlag = RtlDosPathNameToRelativeNtPathName_U(Path,
                                                     &FileName,
                                                     NULL,
                                                     &RelativeName);
    if (!ErrorFlag) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[DM] RtlDosPathNameToRelativeNtPathName_U failed\n");
        return ERROR_INVALID_PARAMETER;
    }
    FreeBuffer = FileName.Buffer;
    if (RelativeName.RelativeName.Length) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }
    InitializeObjectAttributes(&SourceFile,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                                &WasEnabled);
    if (Status != ERROR_SUCCESS) {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Restore privilege not held by cluster service\n");
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[DM] Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
    } else {
        //
        //   Note : Sunitas
        //   There used to be a registry bug where if we set REG_NO_LAZY_FLUSH and the hive
        //   is corrupt, the system crashes. So we used to first try loading it without the
        //   REG_NO_LAZY_FLUSH. If that works, unload it and do it again with
        //   REG_NO_LAZY_FLUSH.  The registry folks claim that is fixed..so I am
        //   removing that hack
        //
        Status = NtLoadKey2((POBJECT_ATTRIBUTES)&RegistryMachineClusterObja,
                            &SourceFile,
                            REG_NO_LAZY_FLUSH);
        if (Status != STATUS_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpLoadHive: NtLoadKey2 failed with error, %1!u!\n",
                    Status);
            CL_UNEXPECTED_ERROR(Status);
        }        
        ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
                           WasEnabled);
    }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    return(Status);

}

DWORD DmpUnloadHive()
/*++

Routine Description:

    Unloads the cluster database from HKLM\Cluster.  This is called at initialization
    to make sure that the database is loaded with the correct flags.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    BOOLEAN  WasEnabled;
    NTSTATUS Status;

    ClRtlLogPrint(LOG_NOISE,
        "[DM] DmpUnloadHive: unloading the hive\r\n");

    Status = ClRtlEnableThreadPrivilege(SE_RESTORE_PRIVILEGE,
                &WasEnabled);
    if (Status != ERROR_SUCCESS) 
    {
        if (Status == STATUS_PRIVILEGE_NOT_HELD) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpUnloadHive:: Restore privilege not held by cluster service\n");
        } 
        else 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpUnloadHive: Attempt to enable restore privilege failed %1!lx!\n",Status);
        }
        goto FnExit;
    }

    Status = NtUnloadKey((POBJECT_ATTRIBUTES)&RegistryMachineClusterObja);
    if (Status != STATUS_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpUnloadHive: NtUnloadKey failed with error, %1!u!\n",
            Status);
        CL_UNEXPECTED_ERROR(Status);
    }

    ClRtlRestoreThreadPrivilege(SE_RESTORE_PRIVILEGE,
        WasEnabled);

FnExit:
    return(Status);

}

DWORD
DmpSafeDatabaseCopy(
    IN LPCWSTR  FileName,
    IN LPCWSTR  Path,
    IN LPCWSTR  BkpPath,
    IN BOOL     bDeleteSrcFile    
    )
/*++

Routine Description:

    Loads the cluster database into HKLM\Cluster

Arguments:
    FileName - Supplies the fully qualified filename of the new cluster database
    Path - Supplies the fully qualified filename of the cluster database.
    BkpPath - Supplies the fully qualified filename of the cluster database temporary
        backup
    bDeleteSrcFile - Specifies whether the source file may be deleted        

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;

    //set the file attributes of the bkp file to be normal so that we can
    //overwrite it if it exists
    if (!QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
               "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                BkpPath, GetLastError());
        //this may fail because the file doesnt exist but that is not fatal so we ignore the error                
    }

    //Save the database to a temp database that can be used for recovery
    //ClRtlCopyFileAndFlushBuffers preserves attributes of the old file
    if (!QfsClRtlCopyFileAndFlushBuffers(Path, BkpPath))
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: Failed to create a backup copy of database, Status=%1!u!\n",
            dwStatus);
        goto FnExit;
    }

    //hide the file since users are not supposed to know about it
    if (!QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY))
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
               "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
                BkpPath, dwStatus);
        goto FnExit;

    }

    //set DatabaseCopyInProgress key to  be TRUE
    dwStatus = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress",1);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: Failed to set ClusterDatabaseCopyInProgress, Status=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }
    

    //delete clusdb
    if (!QfsDeleteFile(Path))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
               "[DM] DmpSafeDatabaseCopy:: Couldnt delete the database file, Error=%1!u!\n",
               GetLastError());
        //this is not fatal, we will still try the move file
    }
    //copy the new database to clusdb
    if (bDeleteSrcFile)
    {
        //the source file may be deleted, this is true at join sync time
        //the source file is a temporary file
        if (!QfsMoveFileEx(FileName, Path, MOVEFILE_REPLACE_EXISTING |
                    MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[DM] DmpSafeDatabaseCopy:: Failed to move %1!ws! to %2!ws!, Status=%3!u!\n",
                FileName, Path, dwStatus);
            goto FnExit;                
        }
    }        
    else
    {
        //the source file must not be deleted use copy..this is true
        //when the logs are being rolled at form and we are uploading
        //the database from a checkpoint file
        if (!QfsClRtlCopyFileAndFlushBuffers(FileName, Path))
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[DM] DmpSafeDatabaseCopy:: Failed to copy %1!ws! to %2!ws!, Status=%3!u!\n",
                FileName, Path, dwStatus);
            goto FnExit;
        }
    }

    //set databaseCopyInProgress key to FALSE
    dwStatus = DmpSetDwordInClusterServer( L"ClusterDatabaseCopyInProgress", 0);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpSafeDatabaseCopy:: Failed to set ClusterDatabaseCopyInProgress, Status=%1!u!\n",
            dwStatus);
        goto FnExit;            
    }

    //now that clusdb is safely copied, we can delete the backup
    //for that we need to set the file attribute to normal
    if (!QfsSetFileAttributes(BkpPath, FILE_ATTRIBUTE_NORMAL))
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[DM] DmpSafeDatabaseCopy:: SetFileAttrib on BkpPath %1!ws! failed, Status=%2!u!\n", 
            BkpPath, GetLastError());
                               
    }

    //delete the backup
    if (!QfsDeleteFile(BkpPath))
    {
        ClRtlLogPrint(LOG_NOISE,
            "[DM] DmpSafeDatabaseCopy:: Failed to delete bkp database file %1!ws!, Status=%2!u!\n",
            BkpPath, GetLastError());
        //this is not fatal so ignore the error                        
    }

FnExit:
    return(dwStatus);

}

DWORD
DmpSetDwordInClusterServer(
    LPCWSTR lpszValueName,
    DWORD   dwValue
    )

/*++

Routine Description:

    Sets the value specified under  
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
    to the value specified by dwValue.  It flushes the change.

Arguments:

    lpszValueName : Sets the value for the name specified by lpszValueName
    dwValue : The value to set to.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/
{

    HKEY     hKey;
    DWORD    dwStatus = ERROR_SUCCESS;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the registry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    lpszValueName,
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwValue,
                                    dwDataBufferSize );

        //Flush the key
        RegFlushKey(hKey);
        
        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?
    }

    return(dwStatus);

} // DmpSetDwordInClusterServer


DWORD DmpGetDwordFromClusterServer(
    IN LPCWSTR lpszValueName,
    OUT LPDWORD pdwValue,
    IN  DWORD   dwDefaultValue
    )
/*++

Routine Description:

    Gets the DWORD value specified in lpszValueName.
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server".
    If the value doesnt exist, the default is returned.

Arguments:

    lpszValueName :  The Value to read.
    pdwValue : Returns the value of the key specified by lpszValueName
    dwDefaultValue: The value to be returned if the specified key doesnt exist
        or in case of error.

Return Value:

    ERROR_SUCCESS if everything worked ok or if the key wasnt present.

--*/
    
{
    HKEY  hKey = NULL;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *pdwValue = dwDefaultValue;
    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwValue = dwDefaultValue;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  lpszValueName,
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) pdwValue,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwValue = dwDefaultValue;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    return ( dwStatus );

} //*** DmpGetDwordFromClusterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\dm\dmupdate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dmupdate.c

Abstract:

    Contains the global update handlers for the Configuration Database Manager

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/
#include "dmp.h"

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

VOID
DmpUpdateSequence(
    VOID
    );


DWORD
DmpUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Update handler for registry updates

Arguments:

    Context - Supplies the update context. This is the message type

    SourceNode - Supplies whether or not the update originated on this node.

    BufferLength - Supplies the length of the update.

    Buffer - Supplies a pointer to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    if ( gbDmpShutdownUpdates ) return( ERROR_SUCCESS );


    switch (Context) {

        case DmUpdateDeleteKey:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteKey \n");
            Status = DmpUpdateDeleteKey(SourceNode,
                                        (PDM_DELETE_KEY_UPDATE)Buffer);
            break;

        case DmUpdateSetValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateSetValue \n");
            Status = DmpUpdateSetValue(SourceNode,
                                       (PDM_SET_VALUE_UPDATE)Buffer);
            break;

        case DmUpdateDeleteValue:
            ClRtlLogPrint(LOG_NOISE,"[DM] DmUpdateDeleteValue\n");
            Status = DmpUpdateDeleteValue(SourceNode,
                                          (PDM_DELETE_VALUE_UPDATE)Buffer);
            break;

        case DmUpdateJoin:
            ClRtlLogPrint(LOG_UNUSUAL,"[DM] DmUpdateJoin\n");
            Status = ERROR_SUCCESS;
            // Reset this variable now that another node is beginning a join.  If CsDmOrFmHasChanged is TRUE 
            // when we see the FmUpdateJoin, then we will reject the join.
            CsDmOrFmHasChanged = FALSE;
            break;

        default:
            Status = ERROR_INVALID_DATA;
            CL_UNEXPECTED_ERROR(ERROR_INVALID_DATA);
            break;
    }
    return(Status);
}


DWORD
DmpUpdateDeleteKey(
    IN BOOL SourceNode,
    IN PDM_DELETE_KEY_UPDATE Update
    )

/*++

Routine Description:

    Deletes the specified registry key on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_DELETE_KEY_UPDATE structure with the information necessary
        to delete the key.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Disposition;
    DWORD Status;
    HKEY Key;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegDeleteKeyW(DmpRoot, Update->Name);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->Name, CLUSTER_CHANGE_REGISTRY_NAME);
    }

    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmpUpdateSetValue(
    IN BOOL SourceNode,
    IN PDM_SET_VALUE_UPDATE Update
    )

/*++

Routine Description:

    Updates the specified registry value on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_SET_VALUE_UPDATE structure with the information necessary
        to set the value.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Status;
    HKEY Key;
    LPWSTR ValueName;
    CONST BYTE *lpData;

    ValueName = (LPWSTR)((PUCHAR)Update + Update->NameOffset);

    switch( Update->Type )
    {
        case REG_DWORD:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws! to 0x%3!08lx!\n",
               ValueName,
               Update->KeyName,
               *(PDWORD)((CONST BYTE *)Update + Update->DataOffset));
            break;

        case REG_SZ:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws! to %3!ws!\n",
               ValueName,
               Update->KeyName,
               (CONST BYTE *)Update + Update->DataOffset);
            break;

        default:
            ClRtlLogPrint(LOG_NOISE,
               "[DM] Setting value of %1!ws! for key %2!ws!\n",
               ValueName,
               Update->KeyName);
            break;
    }

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegOpenKeyExW(DmpRoot,
                           Update->KeyName,
                           0,
                           KEY_SET_VALUE,
                           &Key);

    if (Status != ERROR_SUCCESS) {
        if (SourceNode) {
            *Update->lpStatus = Status;
        }
        ClRtlLogPrint(LOG_NOISE,
                   "[DM] SetValue failed to open target key %1!ws!\n",
                   Update->KeyName);
        goto FnExit;
    }

    lpData = (CONST BYTE *)Update + Update->DataOffset;

    Status = RegSetValueExW(Key,
                            ValueName,
                            0,
                            Update->Type,
                            lpData,
                            Update->DataLength);
    RegCloseKey(Key);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->KeyName, CLUSTER_CHANGE_REGISTRY_VALUE);
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


DWORD
DmpUpdateDeleteValue(
    IN BOOL SourceNode,
    IN PDM_DELETE_VALUE_UPDATE Update
    )

/*++

Routine Description:

    Deletes the specified registry value on this node.

Arguments:

    SourceNode - Supplies whether or not this node is the one that originated
        the update.

    Buffer - Supplies the DM_DELETE_VALUE_UPDATE structure with the information necessary
        to delete the value.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD Status;
    HKEY Key;
    LPWSTR ValueName;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);
    Status = RegOpenKeyExW(DmpRoot,
                           Update->KeyName,
                           0,
                           KEY_SET_VALUE,
                           &Key);
    if (Status != ERROR_SUCCESS) {
        if (SourceNode) {
            *Update->lpStatus = Status;
        }
        goto FnExit;
    }

    ValueName = (LPWSTR)((PUCHAR)Update + Update->NameOffset);

    Status = RegDeleteValueW(Key, ValueName);
    RegCloseKey(Key);
    if (SourceNode) {
        *Update->lpStatus = Status;
    }
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(Update->KeyName, CLUSTER_CHANGE_REGISTRY_VALUE);
    }


FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);
}


VOID
DmpUpdateSequence(
    VOID
    )
/*++

Routine Description:

    Updates the sequence number stored in the registry.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD Sequence;
    DWORD Status;

    Sequence = GumGetCurrentSequence(GumUpdateRegistry);

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegSetValueExW(DmpRoot,
                            CLUSREG_NAME_CLUS_REG_SEQUENCE,
                            0,
                            REG_DWORD,
                            (BYTE CONST *)&Sequence,
                            sizeof(Sequence));

    RELEASE_LOCK(gLockDmpRoot);

    if (Status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( Status );
    }

}


DWORD
DmpUpdateCreateKey(
    IN BOOL SourceNode,
    IN PDM_CREATE_KEY_UPDATE CreateUpdate,
    IN LPCWSTR KeyName,
    IN OPTIONAL LPVOID lpSecurityDescriptor
    )
/*++

Routine Description:

    GUM dispatch routine for creating a registry key.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    CreateUpdate - Supplies key creation options.

    KeyName - Supplies the key name

    lpSecurityDescriptor - if present, supplies the security descriptor to be
        applied when the key is created.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Disposition;
    DWORD Status;
    HKEY Key;
    SECURITY_ATTRIBUTES SecurityAttributes;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;


    if (CreateUpdate->SecurityPresent) {
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = FALSE;
        SecurityAttributes.lpSecurityDescriptor = lpSecurityDescriptor;
        lpSecurityAttributes = &SecurityAttributes;
    } else {
        lpSecurityAttributes = NULL;
    }


    ClRtlLogPrint(LOG_NOISE,
               "[DM] DmpUpdateCreateKey: Creating key <%1!ws!>...\n",
               KeyName);

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegCreateKeyEx(DmpRoot,
                            KeyName,
                            0,
                            NULL,
                            CreateUpdate->dwOptions,
                            CreateUpdate->samDesired,
                            lpSecurityAttributes,
                            &Key,
                            &Disposition);
    if (SourceNode) {
        *CreateUpdate->lpDisposition = Disposition;
        *CreateUpdate->phKey = Key;
    } else {
        RegCloseKey(Key);
    }
    if ((Status == ERROR_SUCCESS) &&
        (Disposition == REG_CREATED_NEW_KEY)) {
        DmpUpdateSequence();
        DmpReportNotify(KeyName, CLUSTER_CHANGE_REGISTRY_NAME);
    }

    RELEASE_LOCK(gLockDmpRoot);

    return(Status);
}


DWORD
DmpUpdateSetSecurity(
    IN BOOL SourceNode,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN LPCWSTR KeyName,
    IN PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    IN LPDWORD pGrantedAccess
    )
/*++

Routine Description:

    GUM dispatch routine for creating a registry key.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    pSecurityInformation - Supplies a pointer to the security information

    KeyName - Supplies the key name

    lpSecurityDescriptor - Supplies the security descriptor to be
        applied.

    pGrantedAccess - Supplies the access that the key was opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    HKEY Key;

    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    Status = RegOpenKeyExW(DmpRoot,
                           KeyName,
                           0,
                           *pGrantedAccess,
                           &Key);
    if (Status != ERROR_SUCCESS) {
        if ((Status == ERROR_ACCESS_DENIED) ||
            (Status == ERROR_PRIVILEGE_NOT_HELD)) {
            BOOLEAN Enabled;

            Status = ClRtlEnableThreadPrivilege(SE_SECURITY_PRIVILEGE,
                                        &Enabled);
            if (Status == ERROR_SUCCESS) {
                Status = RegOpenKeyExW(DmpRoot,
                                       KeyName,
                                       0,
                                       *pGrantedAccess,
                                       &Key);
                ClRtlRestoreThreadPrivilege(SE_SECURITY_PRIVILEGE,
                                   Enabled);
            }

        }
        if (Status != ERROR_SUCCESS) {
            goto FnExit;
        }
    }

    Status = RegSetKeySecurity(Key,
                               *pSecurityInformation,
                               lpSecurityDescriptor);
    RegCloseKey(Key);
    if (Status == ERROR_SUCCESS) {
        DmpUpdateSequence();
        DmpReportNotify(KeyName, CLUSTER_CHANGE_REGISTRY_ATTRIBUTES);
    }

FnExit:
    RELEASE_LOCK(gLockDmpRoot);
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\ep\event.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.c

Abstract:

    Event Engine for the Event Processor component of the Cluster Service.

Author:

    Rod Gamache (rodga) 28-Feb-1996


Revision History:

--*/

#include "epp.h"

//
// Event Processor State.
//

ULONG EventProcessorState = EventProcessorStateIniting;


//
// Global data
//



//
// Local data
//

EVENT_DISPATCH_TABLE EventDispatchTable[NUMBER_OF_COMPONENTS] = {0};
EVENT_DISPATCH_TABLE SyncEventDispatchTable[NUMBER_OF_COMPONENTS] = {0};
PCLRTL_BUFFER_POOL   EventPool = NULL;
DWORD EventHandlerCount = 0;
DWORD SyncEventHandlerCount = 0;
DWORD EventBufferOffset = EpQuadAlign(sizeof(CLRTL_WORK_ITEM));


//
// Functions
//



DWORD
WINAPI
EpInitialize(
    VOID
    )

/*++

Routine Description:

     Event Processor Initialize routine.

Arguments:

    None.

Return Value:

     A Win32 status code.

--*/

{

    DWORD      status = ERROR_SUCCESS;
    DWORD      index;
    DWORD      i;
    PVOID      eventArray[EP_MAX_CACHED_EVENTS];


    ClRtlLogPrint(LOG_NOISE,"[EP] Initialization...\n");

    //
    // Create the event pool. The event structure must be quadword aligned.
    //
    EventPool = ClRtlCreateBufferPool(
                    EventBufferOffset + sizeof(EP_EVENT),
                    EP_MAX_CACHED_EVENTS,
                    EP_MAX_ALLOCATED_EVENTS,
                    NULL,
                    NULL
                    );

    if (EventPool == NULL) {
        ClRtlLogPrint(LOG_NOISE,"[EP] Unable to allocate event buffer pool\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Prime the event pool cache to minimize the chance of an allocation
    // failure.
    //
    ZeroMemory(&(eventArray[0]), sizeof(PVOID) * EP_MAX_CACHED_EVENTS);

    for (i=0; i<EP_MAX_CACHED_EVENTS; i++) {
        eventArray[i] = ClRtlAllocateBuffer(EventPool);

        if (eventArray[i] == NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[EP] Unable to prime event buffer cache, buf num %1!u!!!!\n",
                i
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            CsInconsistencyHalt( status );
        }
    }

    for (i=0; i<EP_MAX_CACHED_EVENTS; i++) {
        if (eventArray[i] != NULL) {
            ClRtlFreeBuffer(eventArray[i]);
        }
    }

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    return(ERROR_SUCCESS);

}  // EpInitialize


void
EppLogEvent(
    IN CLUSTER_EVENT Event
    )
{

    switch( Event ) {

    case CLUSTER_EVENT_ONLINE:
        ClRtlLogPrint(LOG_NOISE,"[EP] Cluster Service online event received\n");
        break;

    case CLUSTER_EVENT_SHUTDOWN:
        ClRtlLogPrint(LOG_NOISE,"[EP] Cluster Service shutdown event received\n");
        break;

    case CLUSTER_EVENT_NODE_UP:
        ClRtlLogPrint(LOG_NOISE,"[EP] Node up event received\n");
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        ClRtlLogPrint(LOG_NOISE,"[EP] Node down event received\n");
        break;

    case CLUSTER_EVENT_NODE_DOWN_EX:
        ClRtlLogPrint(LOG_NOISE,"[EP] Nodes down event received\n");
        break;

    default:
        break;

    }  // switch( Event )
}



VOID
EpEventHandler(
    IN PCLRTL_WORK_ITEM  WorkItem,
    IN DWORD             Ignored1,
    IN DWORD             Ignored2,
    IN ULONG_PTR         Ignored3
    )

/*++

--*/

{
    DWORD      index;
    PEP_EVENT  Event = (PEP_EVENT) (((char *) WorkItem) + EventBufferOffset);


    if (Event->Id == CLUSTER_EVENT_SHUTDOWN) {
        //
        // To shutdown, we just need to stop the service.
        //
        CsStopService();
    }
        
    //
    // Now deliver the event to all of the other components.
    // Eventually, we might filter events based on the mask
    // returned on the init call.
    //

    for ( index = 0; index < NUMBER_OF_COMPONENTS; index++ ) {
        if ( EventDispatchTable[index].EventRoutine == NULL ) {
            continue;
        }

        (EventDispatchTable[index].EventRoutine)(
                                                Event->Id,
                                                Event->Context
                                                );
    }

    //
    // Handle any post processing that might be required.
    //
    if (Event->Flags & EP_CONTEXT_VALID) {
        if (Event->Flags & EP_DEREF_CONTEXT) {
            OmDereferenceObject(Event->Context);
        }

        if (Event->Flags & EP_FREE_CONTEXT) {
            LocalFree(Event->Context);
        }
    }

    ClRtlFreeBuffer(WorkItem);

    return;
}

DWORD
WINAPI
EpPostSyncEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    )
/*++

Routine Description:

    Synchronously posts an event to the rest of the cluster

Arguments:

    Event - Supplies the type of event

    Flags - Supplies any post processing that should be done to the
            context after all dispatch handlers have been called

    Context - Supplies the context.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    If flags is NULL, then we assume Context points to a standard (OM known)
    object, and we'll reference and dereference that object appropriately.

    If flags is non-NULL, then don't reference/dereference the Context object.

--*/

{
    DWORD      index;

    // log event
    EppLogEvent(Event);

    //
    // Reference to keep the context object around.
    //
    if (Context) {
        if ( Flags == 0) {
	    OmReferenceObject( Context );
	    Flags = EP_DEREF_CONTEXT;
	}

	Flags |= EP_CONTEXT_VALID;
    }
    
    //
    // Now deliver the event to all of the other components.
    // Eventually, we might filter events based on the mask
    // returned on the init call.
    //

    for ( index = 0; index < NUMBER_OF_COMPONENTS; index++ ) {
        if ( SyncEventDispatchTable[index].EventRoutine == NULL ) {
            continue;
        }

        (SyncEventDispatchTable[index].EventRoutine)(
                                                Event,
                                                Context
                                                );
    }

    //
    // Handle any post processing that might be required.
    //
    if (Flags & EP_CONTEXT_VALID) {
        if (Flags & EP_DEREF_CONTEXT) {
            OmDereferenceObject(Context);
        }

        if (Flags & EP_FREE_CONTEXT) {
            LocalFree(Context);
        }
    }

    return (ERROR_SUCCESS);
}


DWORD
WINAPI
EpPostEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    )
/*++

Routine Description:

    Asynchronously posts an event to the rest of the cluster

Arguments:

    Event - Supplies the type of event

    Flags - Supplies any post processing that should be done to the
            context after all dispatch handlers have been called

    Context - Supplies the context.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    If flags is NULL, then we assume Context points to a standard (OM known)
    object, and we'll reference and dereference that object appropriately.

    If flags is non-NULL, then don't reference/dereference the Context object.

--*/

{
    PCLRTL_WORK_ITEM  workItem;
    PEP_EVENT         event;
    DWORD             status;

    // log event
    EppLogEvent(Event);

    // handle async handlers.
    workItem = ClRtlAllocateBuffer(EventPool);

    if (workItem != NULL) {

        ClRtlInitializeWorkItem(workItem, EpEventHandler, NULL);

        //
        // Reference to keep the context object around.
        //
        if (Context) {
            if ( Flags == 0) {
                OmReferenceObject( Context );
                Flags = EP_DEREF_CONTEXT;
            }

            Flags |= EP_CONTEXT_VALID;
        }

        event = (PEP_EVENT) ( ((char *) workItem) + EventBufferOffset );


        event->Id = Event;
        event->Flags = Flags;
        event->Context = Context;


        status = ClRtlPostItemWorkQueue(CsCriticalWorkQueue, workItem, 0, 0);

        if (status == ERROR_SUCCESS) {
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
            "[EP] Failed to post item to critical work queue, status %1!u!\n",
            status
            );

        ClRtlFreeBuffer(workItem);

        return(status);
    }

    ClRtlLogPrint(LOG_NOISE,"[EP] Failed to allocate an event buffer!!!\n");

    return(ERROR_NOT_ENOUGH_MEMORY);
}



VOID
EpShutdown(
   VOID
   )

/*++

Routine Description:

    This routine shuts down the components of the Cluster Service.

Arguments:

    None.

Returns:

    None.

--*/

{
    if ( EventPool ) {
        ClRtlDestroyBufferPool(EventPool);
    }

    // Now shutdown the event processor by just cleaning up.

}


DWORD
EpRegisterEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    )
/*++

Routine Description:

    Registers an event handler for the specified type of event.

Arguments:

    EventMask - Supplies the mask of events that should be delivered.

    EventRoutine - Supplies the event routine that should be called.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    CL_ASSERT(EventHandlerCount < NUMBER_OF_COMPONENTS);

    EventDispatchTable[EventHandlerCount].EventMask = EventMask;
    EventDispatchTable[EventHandlerCount].EventRoutine = EventRoutine;

    ++EventHandlerCount;
    return(ERROR_SUCCESS);
}


DWORD
EpRegisterSyncEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    )
/*++

Routine Description:

    Registers an event handler for the specified type of event. The handler
    is called in the context of the dispatcher. Sync event handlers are to
    be used by components that require a barrier semanitcs in handling
    events e.g. gum, dlm , ...etc.

Arguments:

    EventMask - Supplies the mask of events that should be delivered.

    EventRoutine - Supplies the event routine that should be called.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{

    CL_ASSERT(SyncEventHandlerCount < NUMBER_OF_COMPONENTS);

    // XXX: Do we need locking here in case this is not called from init() ?

    SyncEventDispatchTable[EventHandlerCount].EventMask = EventMask;
    SyncEventDispatchTable[EventHandlerCount].EventRoutine = EventRoutine;

    ++SyncEventHandlerCount;
    return(ERROR_SUCCESS);
}


DWORD EpInitPhase1()
{
    DWORD dwError=ERROR_SUCCESS;

//    ClRtlLogPrint(LOG_NOISE,"[EP] EpInitPhase1\n");

    return(dwError);
}


DWORD
WINAPI
EpGumUpdateHandler(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    )
{
    DWORD Status;

    switch (Context)
    {

        default:
            Status = ERROR_INVALID_DATA;
            CsInconsistencyHalt(ERROR_INVALID_DATA);
            break;
    }
    return(Status);

}



/****
@func   WORD| EpClusterWidePostEvent| This generates an event notification on
        all the cluster nodes.

@parm   IN EVENT | Event | The event to be posted.

@parm   IN DWORD | dwFlags | The flags associated with this event.
        If zero, pContext points to one of the om objects.

@parm   IN PVOID | pContext | A pointer to an object or a buffer.

@parm   IN DWORD | cbContext | The size of pContext if it is a buffer.

@rdesc  Returns ERROR_SUCCESS for success, else returns the error code.

@comm   <f EpClusWidePostEvent>
@xref
****/
DWORD
WINAPI
EpClusterWidePostEvent(
    IN CLUSTER_EVENT    Event,
    IN DWORD            dwFlags,
    IN PVOID            pContext,
    IN DWORD            cbContext
    )
{
    DWORD Status;
    DWORD cbObjectId = 0;
    PVOID pContext1 = pContext;
    DWORD cbContext1 = cbContext;
    PVOID pContext2 = NULL;
    DWORD cbContext2 = 0;


    //
    // We have do the work of EpPostEvent here because GUM
    // does not correctly pass a NULL pointer.
    //
    if (pContext) 
    {

        if (dwFlags == 0) 
        {
            //
            // The context is a pointer to a cluster object.
            // The caller is assumed to have a reference on the object
            // so it won't go away while we are using it.
            //
            DWORD dwObjectType = OmObjectType(pContext);
            LPCWSTR lpszObjectId = OmObjectId(pContext);

            cbContext1 = (lstrlen(lpszObjectId) + 1 ) * sizeof(WCHAR);
            pContext1 = (PVOID) lpszObjectId;

            pContext2 = &dwObjectType;
            cbContext2 = sizeof(dwObjectType);

            dwFlags = EP_DEREF_CONTEXT;

            
        }
        else
        {
            //the gumupdate handler must make a copy of the context
            cbContext2 = sizeof(DWORD);
            pContext2 = &cbContext;

        }
        dwFlags |= EP_CONTEXT_VALID;
        
    }

    Status = GumSendUpdateEx(GumUpdateFailoverManager,
                             EmUpdateClusWidePostEvent,
                             4,
                             sizeof(CLUSTER_EVENT),
                             &Event,
                             sizeof(DWORD),
                             &dwFlags,
                             cbContext1,
                             pContext1,
                             cbContext2,
                             pContext2
                             );

    return(Status);
}



/****
@func   WORD| EpUpdateClusWidePostEvent| The update handler for
        EmUpdateClusWidePostEvent.

@parm   IN BOOL | SourceNode | If this is the source of origin of the gum update.

@parm   IN EVENT | pEvent | A pointer to the event to be posted.

@parm   IN LPDWORD | pdwFlags | A pointer to the flags associated with this event.

@parm   IN PVOID | pContext1 | A pointer to an object or a buffer.

@parm   IN PVOID | pContext2 | A pointer to an object type if pContext1 is a
                               pointer to an object. Else unused.

@rdesc  Returns ERROR_SUCCESS for success, else returns the error code.

@comm   <f EpClusWidePostEvent>
@xref
****/
DWORD
EpUpdateClusWidePostEvent(
    IN BOOL             SourceNode,
    IN PCLUSTER_EVENT   pEvent,
    IN LPDWORD          pdwFlags,
    IN PVOID            pContext1,
    IN PVOID            pContext2
)
{
    DWORD   Status = ERROR_INVALID_PARAMETER;


    if (*pdwFlags & EP_CONTEXT_VALID)
    {
        if (*pdwFlags & EP_DEREF_CONTEXT) 
        {
            //
            // pContext1 is a pointer to an object ID.
            // pContext2 is a pointer to an object type.
            //
            LPCWSTR  lpszObjectId = (LPCWSTR) pContext1;
            DWORD    dwObjectType = *((LPDWORD) pContext2);
            PVOID    pObject = OmReferenceObjectById(
                                   dwObjectType,
                                   lpszObjectId
                                   );

            if (!pObject)
            {
                //
                // Return success if object is not found! The object was
                // probably deleted.
                //
                return(ERROR_SUCCESS);
            }

            Status  = EpPostEvent(*pEvent, *pdwFlags, pObject);
        }
        else 
        {
            PVOID   pContext;
            
            //
            // pContext1 is a buffer. If the FREE_BUFFER flag is on, we need
            // to make a copy since the caller will free the memory on return
            // pContext2 contains the size of the buffer.
            //
            *pdwFlags = (*pdwFlags) | EP_FREE_CONTEXT;


            //SS: we should make a copy here instead of unsetting the epfreecontext bit
            pContext = LocalAlloc(LMEM_FIXED, *((LPDWORD)pContext2));
            if (!pContext)
            {
                Status  = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[EP] EpUpdateCLusWidePostEvent: Failed to alloc memory, %1!u!...\n",
                    Status);
                goto FnExit;                    
            }                    

            //pContext is freed when the event is delivered
            //pContext1 is freed by the caller of GUM
            CopyMemory(pContext, pContext1, *((LPDWORD)pContext2));
            Status  = EpPostEvent(*pEvent, *pdwFlags, pContext);
        }
    }
    else
    {
        //there is no context with this event
        Status = EpPostEvent(*pEvent, 0, NULL);
    }
FnExit:    
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\ep\epp.h ===
#ifndef _EPP_H
#define _EPP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    epp.h

Abstract:

    Private header file for the cluster event processor.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_EP


//
// Local Constants
//
#define NUMBER_OF_COMPONENTS       5
#define EP_MAX_CACHED_EVENTS       20
#define EP_MAX_ALLOCATED_EVENTS    CLRTL_MAX_POOL_BUFFERS

#define EpQuadAlign(size)    ( (((size) / sizeof(DWORDLONG)) + 1) * \
                               sizeof(DWORDLONG) )


//
// Local Types
//
typedef struct {
    CLUSTER_EVENT   Id;
    DWORD           Flags;
    PVOID           Context;
} EP_EVENT, *PEP_EVENT;

#endif //ifndef _EPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\evtlog\evtlogp.h ===
#ifndef _EVTLOGP_H
#define _EVTLOGP_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.h

Abstract:

    Private header file for the eventlogging component for
    the NT Cluster Service

Author:

    Sunita Shrivastava (sunitas) 5-Dec-1996.

Revision History:

--*/
#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "service.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_EVTLOG


DWORD EvpPropPendingEvents(
	IN DWORD 			dwEventInfoSize,
	IN PPACKEDEVENTINFO	pPackedEventInfo);

DWORD
EvpClusterEventHandler(
    IN CLUSTER_EVENT  Event,
    IN PVOID          Context
    );
	

#endif //_EVTLOGP_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\evtlog\evtlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.c

Abstract:

    Contains all the routines for supporting cluster wide eventlogging.

Author:

    Sunita Shrivastava (sunitas) 24-Apr-1996

Revision History:

--*/
#include "evtlogp.h"
#include "simpleq.h"
#include "nm.h" // to get NmLocalNodeIdString //
#include "dm.h"
#include "clussprt.h"


//since the eventlog replication requires services.exe calling into the 
//cluster service
LPWSTR  g_pszServicesPath = NULL;
DWORD   g_dwServicesPid = 0;

//
// Local data
//
#define OUTGOING_PROPAGATION_ENABLED 0x00000001
//#define INCOMING_PROPAGATION_ENABLED 0x00000002
#define TRACE_EVERYTHING_ENABLED     0x00001000
#define PROPAGATION_ENABLED OUTGOING_PROPAGATION_ENABLED


static WORD     LastFailHour = -1;
static WORD     LastFailDay  = -1;

static BITSET   EvpUpNodeSet = 0;

static SIMPLEQUEUE IncomingQueue;
static SIMPLEQUEUE OutgoingQueue;
static CLRTL_WORK_ITEM EvtlogWriterWorkItem;
static CLRTL_WORK_ITEM EvtBroadcasterWorkItem;
static DWORD DefaultNodePropagate    = PROPAGATION_ENABLED;
static DWORD DefaultClusterPropagate = PROPAGATION_ENABLED;

#define EVTLOG_DELTA_GENERATION 1

#ifdef EVTLOG_DELTA_GENERATION


static DWORD g_dwGenerateDeltas = 1;
static DWORD g_dwVersionsAllowDeltaGeneration = 0;

static CLRTL_WORK_ITEM EvVersionCalcWorkItem;
INT64  EvtTimeDiff[ClusterMinNodeId + ClusterDefaultMaxNodes];

VOID
EvVersionCalcCb(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );

VOID
EvpVersionCalc(
    OUT LPDWORD pdwAllowDeltaGeneration
    );

#endif

#define AsyncEvtlogReplication CLUSTER_MAKE_VERSION(NT5_MAJOR_VERSION,1978)

#define OUTGOING_QUEUE_SIZE (256 * 1024) // Max size of the batched event buffer that can come in from eventlog service
#define OUTGOING_QUEUE_NAME L"System Event Replication Output Queue"

#define INCOMING_QUEUE_SIZE (OUTGOING_QUEUE_SIZE * 3)
#define INCOMING_QUEUE_NAME L"System Event Replication Input Queue"

#define DROPPED_DATA_NOTIFY_INTERVAL (2*60) // in seconds (2mins)
#define CHECK_CLUSTER_REGISTRY_EVERY 10 // seconds

#define EVTLOG_TRACE_EVERYTHING 1

#ifdef EVTLOG_TRACE_EVERYTHING
# define EvtlogPrint(__evtlogtrace__) \
     do { if (EventlogTraceEverything) {ClRtlLogPrint __evtlogtrace__;} } while(0)
#else
# define EvtLogPrint(x)
#endif

DWORD EventlogTraceEverything = 1;

RPC_BINDING_HANDLE EvtRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];

BOOLEAN EvInitialized = FALSE;

/////////////// Forward Declarations ////////////////
DWORD
InitializeQueues(
    VOID
    );
VOID
DestroyQueues(
    VOID);
VOID
ReadRegistryKeys(
    VOID);
VOID
PeriodicRegistryCheck(
    VOID);
///////////// End of forward Declarations ////////////


/****
@doc    EXTERNAL INTERFACES CLUSSVC EVTLOG
****/

/****
@func       DWORD | EvInitialize| This initializes the cluster
            wide eventlog replicating services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref       <f EvShutdown>
****/

DWORD EvInitialize()
{
    DWORD       i;
    WCHAR       wServicesName[] = L"services.exe";
    WCHAR       wCallerModuleName[] = L"\\system32\\";
    WCHAR       wCallerPath[MAX_PATH + 1];
    LPWSTR      pszServicesPath;
    DWORD       dwNumChar;
    DWORD       dwStatus = ERROR_SUCCESS;
    
    //
    // Initialize Per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        EvtRpcBindings[i] = NULL;
    }

#ifdef EVTLOG_DELTA_GENERATION
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        EvtTimeDiff[i] = 0;
    }
#endif
    //get the path name for %windir%\system32\services.exe
    
    dwNumChar = GetWindowsDirectoryW(wCallerPath, MAX_PATH);
    if(dwNumChar == 0)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }        

    
    //need to allocate more memory
    pszServicesPath = LocalAlloc(LMEM_FIXED, (sizeof(WCHAR) *
        (lstrlenW(wCallerPath) + lstrlenW(wCallerModuleName) + 
            lstrlenW(wServicesName) + 1)));
    if (!pszServicesPath)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    lstrcpyW(pszServicesPath, wCallerPath);
    lstrcatW(pszServicesPath, wCallerModuleName);
    lstrcatW(pszServicesPath, wServicesName);
    
    g_pszServicesPath = pszServicesPath;

    EvInitialized = TRUE;

FnExit:
    return(dwStatus);

} // EvInitialize


/****
@doc    EXTERNAL INTERFACES CLUSSVC EVTLOG
****/

/****
@func       DWORD | EvOnline| This finishes initializing the cluster
            wide eventlog replicating services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This calls ElfrRegisterClusterSvc() and calls EvpPropPendingEvents()
            to propagate events logged since the start of the eventlog service.

@xref       <f EvShutdown>
****/
DWORD EvOnline()
{
    DWORD               dwError=ERROR_SUCCESS;
    PPACKEDEVENTINFO    pPackedEventInfo=NULL;
    DWORD               dwEventInfoSize;
    DWORD               dwSequence;
    CLUSTER_NODE_STATE  state;
    DWORD               i;
    PNM_NODE            node;


    ClRtlLogPrint(LOG_NOISE, "[EVT] EvOnline\n");

#ifdef EVTLOG_DELTA_GENERATION
    //initialize the work item for version calculations
    ClRtlInitializeWorkItem(
        &EvVersionCalcWorkItem,
        EvVersionCalcCb,
        (PVOID) &g_dwVersionsAllowDeltaGeneration
        );

    //check whether the cluster version allows delta generation
    //this needs to be done for readregistrykeys() is invoked
    //by InitializeQueues() so that g_dwGenerateDeltas is setappropriately
    EvpVersionCalc(&g_dwVersionsAllowDeltaGeneration);

    ClRtlLogPrint(LOG_NOISE,
        "[EVT] EvOnline : Compiled with Delta generation enabled\n");

#endif

    dwError = InitializeQueues();
    if (dwError != ERROR_SUCCESS) {
        return dwError;
    }

    
    //
    // Register for node up/down events.
    //
    dwError = EpRegisterEventHandler(
                  (CLUSTER_EVENT_NODE_UP | CLUSTER_EVENT_NODE_DOWN_EX |
                  CLUSTER_EVENT_NODE_ADDED | CLUSTER_EVENT_NODE_DELETED),
                  EvpClusterEventHandler
                  );

    if (dwError != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
        "[EVT] EvOnline : Failed to register for cluster events, status %1!u!\n",
            dwError);
        return(dwError);
    }

    // Initialize Per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
    {
        if (i != NmLocalNodeId) {
            node = NmReferenceNodeById(i);

            if (node != NULL) {
                DWORD version = NmGetNodeHighestVersion(node);
                state = NmGetNodeState(node);

                if ( (state == ClusterNodeUp) ||
                     (state == ClusterNodePaused)
                   )
                {
                    if (version >= AsyncEvtlogReplication) {
                        BitsetAdd(EvpUpNodeSet, i);

                        ClRtlLogPrint(LOG_NOISE, 
                            "[EVT] Node up: %1!u!, new UpNodeSet: %2!04x!\n",
                            i,
                            EvpUpNodeSet
                            );
                    } else {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[EVT] Evtlog replication is not allowed for node %1!u! (version %2!x!)\n",
                            i,
                            version
                            );
                    }
                }

                OmDereferenceObject(node);
            }
        }
    }


    //TODO :: SS - currently the eventlog propagation api
    //has been added to clusapi.  In future, if we need
    //to define a general purpose interface for communication
    //with other services on the same system, then we need
    //to register and advertize that interface here.
    //call the event logger to get routines that have been logged so far.

    ClRtlLogPrint(LOG_NOISE, "[EVT] EvOnline : calling ElfRegisterClusterSvc\n");

    dwError = ElfRegisterClusterSvc(NULL, &dwEventInfoSize, &pPackedEventInfo);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[EVT] EvOnline : ElfRegisterClusterSvc returned %1!u!\n",
            dwError);
        return(dwError);                    
    }

    //post them to other nodes in the cluster
    if (pPackedEventInfo && dwEventInfoSize)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[EVT] EvOnline: pPackedEventInfo->ulSize=%1!d! pPackedEventInfo->ulNulEventsForLogFile=%2!d!\r\n",
            pPackedEventInfo->ulSize, pPackedEventInfo->ulNumEventsForLogFile);
        EvpPropPendingEvents(dwEventInfoSize, pPackedEventInfo);
        MIDL_user_free ( pPackedEventInfo );

    }

    return (dwError);

}

/****
@func       DWORD | EvCreateRpcBindings| This creates an RPC binding
            for a specified node.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref
****/
DWORD
EvCreateRpcBindings(
    PNM_NODE  Node
    )
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[EVT] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (EvtRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(EvtRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[EVT] Failed to verify 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(EvtRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[EVT] Failed to create 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // EvCreateRpcBindings


/****
@func       DWORD | EvShutdown| This deinitializes the cluster
            wide eventlog replication services.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       The cluster register deregisters with the eventlog service.

@xref       <f EvInitialize>
****/
DWORD EvShutdown(void)
{
    DWORD               dwError=ERROR_SUCCESS;


    if (EvInitialized) {
        PPACKEDEVENTINFO    pPackedEventInfo;
        DWORD               dwEventInfoSize;
        DWORD               i;


        ClRtlLogPrint(LOG_NOISE,
            "[EVT] EvShutdown\r\n");

        //call the event logger to get routines that have been logged so far.

        ElfDeregisterClusterSvc(NULL);
        DestroyQueues();

        // TODO [GorN 9/23/1999]
        //   When DestroyQueues starts doing what it is supposed to do,
        //   (i.e. flush/wait/destroy), enable the code below
        
        #if 0
        //
        // Free per-node information
        //
        for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
            if (EvtRpcBindings[i] != NULL) {
                ClMsgDeleteRpcBinding(EvtRpcBindings[i]);
                EvtRpcBindings[i] = NULL;
            }
        }
        #endif
    }

    return (dwError);

}

/****
@func       DWORD | EvpClusterEventHandler| Handler for internal cluster
            events.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm

@xref       <f EvInitialize>
****/
DWORD
EvpClusterEventHandler(
    IN CLUSTER_EVENT  Event,
    IN PVOID          Context
    )
{
    DWORD NodeId;


    switch(Event)
    {
#ifdef  EVTLOG_DELTA_GENERATION

        case CLUSTER_EVENT_NODE_DELETED:
        case CLUSTER_EVENT_NODE_ADDED:
        {
            //post a work item to delayed thread to calculate the versions
            //if it is less than whistler, 
            ClRtlPostItemWorkQueue(CsDelayedWorkQueue, &EvVersionCalcWorkItem, 0, 0);
        }
        break;                
        
#endif    
        case CLUSTER_EVENT_NODE_UP:
        {
            PNM_NODE   node = (PNM_NODE) Context;
            CL_NODE_ID  nodeId = NmGetNodeId(node);
            DWORD version = NmGetNodeHighestVersion(node);

            if ( version >= AsyncEvtlogReplication )
            {
                BitsetAdd(EvpUpNodeSet, nodeId);

                ClRtlLogPrint(LOG_NOISE, 
                    "[EVT] Node up: %1!u!, new UpNodeSet: %2!04x!\n",
                    nodeId,
                    EvpUpNodeSet
                    );
            } else {
                ClRtlLogPrint(LOG_NOISE, 
                    "[EVT] Evtlog replication is not allowed for node %1!u! (version %2!x!)\n",
                    nodeId,
                    version
                    );
            }
        }
        break;

       case CLUSTER_EVENT_NODE_DOWN_EX:
       {
            BITSET downedNodes = (BITSET)((ULONG_PTR)Context);

            BitsetSubtract(EvpUpNodeSet, downedNodes);

            ClRtlLogPrint(LOG_NOISE, 
                "[EVT] Nodes down: %1!04X!, new UpNodeSet: %2!04x!\n",
                downedNodes,
                EvpUpNodeSet
                );
                            
        }
        break;                

        default:
        break;
    }        
    return(ERROR_SUCCESS);
}

/****
@func       DWORD | s_EvPropEvents| This is the server entry point for
            receiving eventlog information from other nodes of the cluster
            and logging them locally.

@parm       IN handle_t | IDL_handle | The rpc binding handle. Unused.
@parm       IN DWORD | dwEventInfoSize | the size of the packed event info structure.
@parm       IN UCHAR | *pBuffer| A pointer to the packed
            eventinfo structure.
@rdesc      returns ERROR_SUCCESS if successful else returns the error code.

@comm       This function calls ElfWriteClusterEvents() to log the event propagted
            from another node.
@xref
****/
DWORD
s_EvPropEvents(
    IN handle_t IDL_handle,
    IN DWORD dwEventInfoSize,
    IN UCHAR *pBuffer
    )
{
    PUCHAR end = pBuffer + dwEventInfoSize;

    //should not come here at all
    //DebugBreak();

    if ( dwEventInfoSize >= sizeof(DWORD) && dwEventInfoSize == (*(PDWORD)pBuffer)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[EVT] Improperly formed packet received of size %1!u!.\n",
            dwEventInfoSize
            );
        return ERROR_SUCCESS;
    }


    /*
    ClRtlLogPrint(LOG_NOISE, 
        "[EVT] s_EvPropEvents.  dwEventInfoSize=%1!d!\r\n",
         dwEventInfoSize);
    */         
    
#if CLUSTER_BETA
    EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents.  dwEventInfoSize=%1!d!\r\n",
                 dwEventInfoSize));
#endif

    while (pBuffer < end) {
        BOOL success;

        success = SimpleQueueTryAdd(&IncomingQueue, SQB_PAYLOADSIZE(pBuffer), SQB_PAYLOAD(pBuffer));
        if ( !success ) {
            EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents.  Put(IncomingQ,%1!d!) failed. empty=%2!d!\n",
                    SQB_PAYLOADSIZE(pBuffer), IncomingQueue.Empty) );
        }

        pBuffer = SQB_NEXTBLOCK(pBuffer);
    }
    return(ERROR_SUCCESS);
}


DWORD
s_EvPropEvents2(
    IN handle_t IDL_handle,
    IN DWORD dwEventInfoSize,
    IN UCHAR *pBuffer,
    IN FILETIME ftSendTime,
    IN DWORD    dwSenderNodeId
    )
{
    PUCHAR end = pBuffer + dwEventInfoSize;
    FILETIME        ftReceiptTime;
    INT64           iTimeDiff;
    ULARGE_INTEGER  uliReceiptTime;
    ULARGE_INTEGER  uliSendTime;
    //SS: reliability teams wants the ignoredelta to be about 5 secs
    const INT64     iIgnoreDelta = Int32x32To64(5000 , ( 1000 * 10)) ;//5000 msecs(5secs) expressed as 100 nanoseconds
    PNM_NODE        pNmNode;
    LPCWSTR         pszSenderNodeName;
    WCHAR           szNodeId[16];
    
    if ( dwEventInfoSize >= sizeof(DWORD) && dwEventInfoSize == (*(PDWORD)pBuffer)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[EVT] Improperly formed packet received of size %1!u!.\n",
            dwEventInfoSize
            );
        return ERROR_SUCCESS;
    }

    //received an event, need a time stamp
    GetSystemTimeAsFileTime(&ftReceiptTime);
    
    //convert filetimes to large integers
    uliReceiptTime.LowPart = ftReceiptTime.dwLowDateTime;
    uliReceiptTime.HighPart = ftReceiptTime.dwHighDateTime;
    
    uliSendTime.LowPart = ftSendTime.dwLowDateTime;
    uliSendTime.HighPart = ftSendTime.dwHighDateTime;

    iTimeDiff = uliReceiptTime.QuadPart - uliSendTime.QuadPart;

    
    wsprintf(szNodeId, L"%u", dwSenderNodeId);
    
    /*
    ClRtlLogPrint(LOG_NOISE, 
          "[EVT] s_EvPropEvents2.  dwSenderNodeId=%1!u! pszSenderNodeId = %2!ws!\n",
          dwSenderNodeId, szNodeId);
    */
    
    //validate sender node id to see it doesnt cause an av!
    //and get the name of the sender machine
    pNmNode = OmReferenceObjectById(ObjectTypeNode, szNodeId);
    if (pNmNode)
    {
        pszSenderNodeName = OmObjectName(pNmNode);

       
        //compare with last time diff from this node
        //use the abs functions for 64 bit integers
        if (_abs64(EvtTimeDiff[dwSenderNodeId] - iTimeDiff) > iIgnoreDelta)
        {
            WCHAR szTimeDiff[64];
            
            //we need to write the deltas or the time diffs into the eventlog
            //if we have a stream d1, e1, e2, e3, d2, e4, e5 where d are time diffs
            //and e are propagated events, ideally we would like to write them in order
            //in this eventlog.
            //Alternatives
            //a)
            //Write it right here and let the events be lazily written by csdelayed worker
            //queue threads
            //this might appear as d1, e1, d2, e3, e2, e4, e5
            //or as d1, d2, e1, e2, e3, e4, e5
            //or as d1, d2, e1, e5, e3, e4, e2

            //UGH...UGH..worse still this batch can contain events from different
            //logs..for each of those the delta needs to go into the corresponding log
            //and only once too
            //That will require us to grovel through the simple queue payload structures,
            //dig inside the eventlog structure and find the logs we should put the delta
            //into
            //We dont have a handle to all the logs to write into them, that would have
            //to change as well - if dont write them into all appropriate logs then the general
            //usefulness of this stupid feature is further comprimised, in the sense
            //that it really cant be used for corelating events other than the ones
            //in the system log and even that would be incorrect.
            //Writing them into all logs means cluster service needs
            //to register against multiple logs as event source - with 
            //different names(event log wouldnt like it with the same name)
            //and that is ugly as hell as well
            
            _i64tow(iTimeDiff, szTimeDiff, 10);

            /*
            ClRtlLogPrint(LOG_NOISE, 
                "[EVT] s_EvPropEvents2.  Logging Delta %1!ws!",
                szTimeDiff);                        
            */
            
            CL_ASSERT( EVT_EVENT_TIME_DELTA_INFORMATION == CLUSSPRT_EVENT_TIME_DELTA_INFORMATION );
            CsLogEvent3(LOG_NOISE, EVT_EVENT_TIME_DELTA_INFORMATION, OmObjectName(NmLocalNode),
                pszSenderNodeName, szTimeDiff);
            
            //b) 
            // Call the eventlog to format the event but dont put it into the eventlog
            // but simply insert that into the event queue
            // If we dont change the simplequeuetryadd logic and the csdelayed worker queue
            // processing, the above stream may appear as d2, e1, d1, e3, e2, e4, e5
            // That dont make any sense but then nobody else seems to care about correctness
            // STRANGE WORLD !!!

            //save the last time logged
            EvtTimeDiff[dwSenderNodeId] = iTimeDiff;                            

            //c)Ideal -
            //change all the simple queue stuff to make it handle different payload types
            //batch events at the source(which is where they are generated) and propagate
            //them asynchronously and then simply write them in order as they arrive            
            //SimpleQ is simply the most worst suited abstraction for event
            //log propagation - it consumes space and yet causes lots of 
            //events to be dropped.

            
        }
        else
        {
            //ClRtlLogPrint(LOG_NOISE,
            //    "[EVT] s_EvPropEvents2.  Delta was too small to log\n");
        }
        OmDereferenceObject(pNmNode);
    }
    
#if CLUSTER_BETA
    EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents2.  dwEventInfoSize=%1!d!\r\n",
                 dwEventInfoSize));
#endif

    while (pBuffer < end) {
        BOOL success;

        success = SimpleQueueTryAdd(&IncomingQueue, SQB_PAYLOADSIZE(pBuffer), SQB_PAYLOAD(pBuffer));
        if ( !success ) {
            EvtlogPrint((LOG_NOISE, "[EVT] s_EvPropEvents2.  Put(IncomingQ,%1!d!) failed. empty=%2!d!\n",
                    SQB_PAYLOADSIZE(pBuffer), IncomingQueue.Empty) );
        }

        pBuffer = SQB_NEXTBLOCK(pBuffer);
    }
    return(ERROR_SUCCESS);
}


/****
@func       DWORD | EvpPropPendingEvents| This is called to propagate all the pending
            events since the start of the system.  And then to propagate any events
            generated during the life of the cluster.
@parm       IN DWORD | dwEventInfoSize | the size of the packed event info structure.
@parm       IN PPACKEDEVENTINFO | pPackedEventInfo| A pointer to the packed
            eventinfo structure.
@rdesc      returns ERROR_SUCCESS if successful else returns the error code.

@comm       This function is called during initialization when a cluster is being formed.
@xref
****/
DWORD EvpPropPendingEvents(
    IN DWORD            dwEventInfoSize,
    IN PPACKEDEVENTINFO pPackedEventInfo)
{
    BOOL success;

    success = SimpleQueueTryAdd(&OutgoingQueue, dwEventInfoSize, pPackedEventInfo);

    if ( !success ) {
        EvtlogPrint((LOG_NOISE, "[EVT] EvpPropPendingEvents:  Put(OutgoingQ,%1!d!) failed. empty=%2!d!\n",
                 dwEventInfoSize, OutgoingQueue.Empty));
    }

    return ERROR_SUCCESS;
}

/****
@func       DWORD | s_ApiEvPropEvents | This is called to propagate eventlogs from
            the local system to all other nodes of the cluster.

@parm       handle_t | IDL_handle | Not used.
@parm       DWORD | dwEventInfoSize | The number of bytes in the following structure.
@parm       UCHAR * | pPackedEventInfo | Pointer to a byte structure containing the
            PACKEDEVENTINFO structure.

@rdesc      Returns ERROR_SUCCESS if successfully propagated events,
            else returns the error code.

@comm       Currently this function is called for every eventlogged by the eventlog
            service.  Only the processes running in the SYSTEM account can call this
            function.
@xref
****/
error_status_t
s_ApiEvPropEvents(
    IN handle_t IDL_handle,
    IN DWORD dwEventInfoSize,
    IN UCHAR *pPackedEventInfo
    )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bIsLocalSystemAccount;

#if 0
    //
    // Chittur Subbaraman (chitturs) - 11/7/1999
    //
    // Modify this function to use ClRtlIsCallerAccountLocalSystemAccount
    // instead of GetUserName which 
    // (1) used to hang in security audit enabled systems if security 
    // audit log attempts to write to the event log at the time we 
    // made that API call since that API and the security audit log 
    // are mutually exclusive for some portions, and
    // (2) wrongly checked for an unlocalizable output value "SYSTEM"
    // from that API in order to grant access to the client.
    //
    
    //
    // Impersonate the client.
    //
    if ( ( dwError = RpcImpersonateClient( IDL_handle ) ) != RPC_S_OK )
    {
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Error %1!d! trying to impersonate caller...\n",
                    dwError 
                    );
        goto FnExit;
    }

    //
    // Check that the caller's account is local system account
    //
    if ( ( dwError = ClRtlIsCallerAccountLocalSystemAccount( 
                &bIsLocalSystemAccount ) != ERROR_SUCCESS ) )
    {
        RpcRevertToSelf();
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Error %1!d! trying to check caller's account...\n",
                    dwError);   
        goto FnExit;
    }

    if ( !bIsLocalSystemAccount )
    {
        RpcRevertToSelf();
        dwError = ERROR_ACCESS_DENIED;
        ClRtlLogPrint( LOG_ERROR, 
                    "[EVT] s_ApiEvPropEvents: Caller's account is not local system account, denying access...\n");   
        goto FnExit;
    }

    RpcRevertToSelf();
#endif
    //
    // All security checks have passed. Drop the eventlog info into
    // the queue.
    //
    if ( dwEventInfoSize && pPackedEventInfo ) 
    {
        dwError = EvpPropPendingEvents( dwEventInfoSize,
                                        ( PPACKEDEVENTINFO ) pPackedEventInfo );
    }

    return( dwError );
}

VOID
EvtlogWriter(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

     This work item reads events from the
     incoming queue and writes them to EventLog service


Arguments:

     Not used.

Return Value:

     None

--*/
{
    PVOID begin, end;
    SYSTEMTIME localTime;
    DWORD       eventsWritten = 0;

#if CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter Work Item fired.\n") );
#endif

    do {
        DWORD dwError;

        if ( !SimpleQueueReadOne(&IncomingQueue, &begin, &end) )
        {
            break;
        }
#if CLUSTER_BETA
        EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter got %1!d!.\n",
                     (PUCHAR)end - (PUCHAR)begin ) );
#endif

        dwError = ElfWriteClusterEvents(
                      NULL,
                      SQB_PAYLOADSIZE(begin),
                      (PPACKEDEVENTINFO)SQB_PAYLOAD(begin) );

        if ( dwError != ERROR_SUCCESS ) {
            GetLocalTime( &localTime );

// LastFailHour is initialized to -1, which should not equal any wHour!
// LastFailDay is initialized to -1, which should not equal any wDay!

            if ( (LastFailHour != localTime.wHour) || (LastFailDay != localTime.wDay) ) {
                LastFailHour = localTime.wHour;
                LastFailDay = localTime.wDay;
                ClRtlLogPrint(LOG_UNUSUAL,
                       "[EVT] ElfWriteClusterEvents failed: status = %1!u!\n",
                        dwError);
            }
        }
        PeriodicRegistryCheck();
    } while ( SimpleQueueReadComplete(&IncomingQueue, end) );

#if CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter: done.\n" ) );
#endif

    if ( eventsWritten > 0 ) {
        EvtlogPrint( (LOG_NOISE, "[EVT] EvtlogWriter: wrote %u events to system event log.\n", eventsWritten ) );
    }
    CheckForDroppedData(&IncomingQueue, FALSE);
}

#ifdef EVTLOG_DELTA_GENERATION
VOID
EvpVersionCalc(
    OUT LPDWORD pdwAllowDeltaGeneration
    )
/*++

Routine Description:

     This work item calculates the cluster versions and based
     on that returns whether delta generation can be enabled.
     
Arguments:

     Not used.

Return Value:

     None

--*/
{
    DWORD   dwClusterHighestVersion;

    NmGetClusterOperationalVersion(&dwClusterHighestVersion, NULL, NULL);
    if (CLUSTER_GET_MAJOR_VERSION(dwClusterHighestVersion) >= NT51_MAJOR_VERSION)
    {
        *pdwAllowDeltaGeneration = TRUE;
        ClRtlLogPrint(LOG_NOISE, 
                "[EVT] EvpVersionCalc: Delta generation allowed.\n");
    }
    else
    {
        *pdwAllowDeltaGeneration = FALSE;
        ClRtlLogPrint(LOG_NOISE, 
                "[EVT] EvpVersionCalc: Delta generation NOT allowed\n");
    }
}

VOID
EvVersionCalcCb(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

     This work item calculates the cluster versions on
     node up and node down notifications.

     
Arguments:

     Not used.

Return Value:

     None

--*/
{

    EvpVersionCalc(WorkItem->Context);
    
}


#endif


VOID
EvtBroadcaster(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

     This work item reads events from the
     outgoing queue and RPCs them to all active nodes

Arguments:

     Not used.

Return Value:

     None

--*/
{
    PVOID begin, end;

#if CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtBroadcaster Work Item fired.\n") );
#endif

    do {
        DWORD i;

        if( !SimpleQueueReadAll(&OutgoingQueue, &begin, &end) )
        {
            EvtlogPrint( (LOG_NOISE, "[EVT] EvtBroadcaster SimplQ read failed.\n") );
            break;
        }

#if CLUSTER_BETA
        EvtlogPrint((LOG_NOISE, "[EVT] EvtBroadcaster got %1!d!.\n",
                    (PUCHAR)end - (PUCHAR)begin ) );
#endif

#ifdef EVTLOG_DELTA_GENERATION
        {
        FILETIME    ftSendTime;

        for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
        {
            if (BitsetIsMember(i, EvpUpNodeSet) && (i != NmLocalNodeId))
            {
                DWORD dwError;

                CL_ASSERT(EvtRpcBindings[i] != NULL);

                NmStartRpc(i);

                if (g_dwGenerateDeltas)
                {
                    //ClRtlLogPrint(LOG_NOISE, 
                    //    "[EVT] EvtBroadcaster(delta) calling EvPropEvents2\n");
                
                    GetSystemTimeAsFileTime(&ftSendTime);
                    dwError = EvPropEvents2(EvtRpcBindings[i],
                                       (DWORD)((PUCHAR)end - (PUCHAR)begin),
                                       (PBYTE)begin,
                                       ftSendTime,
                                       NmLocalNodeId
                                       );
                }
                else
                {
                    //ClRtlLogPrint(LOG_NOISE, 
                    //    "[EVT] EvtBroadcaster(delta) calling EvPropEvents\n");
                    dwError = EvPropEvents(EvtRpcBindings[i],
                                       (DWORD)((PUCHAR)end - (PUCHAR)begin),
                                       (PBYTE)begin
                                       );
                }
                
                NmEndRpc(i);

                if ( dwError != ERROR_SUCCESS ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[EVT] EvtBroadcaster: EvPropEvents for node %1!u! "
                                "failed. status %2!u!\n",
                                i,
                                dwError);
                    NmDumpRpcExtErrorInfo(dwError);
                }
            }
        }
        }
#else
        for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
        {
            if (BitsetIsMember(i, EvpUpNodeSet) && (i != NmLocalNodeId))
            {
                DWORD dwError;

                CL_ASSERT(EvtRpcBindings[i] != NULL);

                NmStartRpc(i);
                //ClRtlLogPrint(LOG_NOISE, 
                //    "[EVT] EvtBroadcaster(delta) calling EvPropEvents"\n);

                dwError = EvPropEvents(EvtRpcBindings[i],
                                       (DWORD)((PUCHAR)end - (PUCHAR)begin),
                                       (PBYTE)begin
                                       );
                NmEndRpc(i);

                if ( dwError != ERROR_SUCCESS ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[EVT] Evtbroadcaster: EvPropEvents for node %1!u! "
                                "failed. status %2!u!\n",
                                i,
                                dwError);
                    NmDumpRpcExtErrorInfo(dwError);
                }
            }
        }
#endif                                       
        PeriodicRegistryCheck();
    } while ( SimpleQueueReadComplete(&OutgoingQueue, end) );

#if CLUSTER_BETA
    EvtlogPrint( (LOG_NOISE, "[EVT] EvtBroadcaster: done.\n" ) );
#endif

    CheckForDroppedData(&OutgoingQueue, FALSE);
}

VOID
OutgoingQueueDataAvailable(
    IN PSIMPLEQUEUE q
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that there are data in the queue available for processing

Arguments:

     q - which queue has data

Return Value:

     None

--*/
{
    DWORD status = ClRtlPostItemWorkQueue(
                        CsDelayedWorkQueue,
                        &EvtBroadcasterWorkItem,
                        0,
                        0
                        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[EVT] OutgoingQueueDataAvailable, PostWorkItem failed, error %1!u! !\n",
            status);
    }
}

VOID
IncomingQueueDataAvailable(
    IN PSIMPLEQUEUE q
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that there are data in the queue available for processing

Arguments:

     q - which queue has data

Return Value:

     None

--*/
{
    DWORD status = ClRtlPostItemWorkQueue(
                        CsDelayedWorkQueue,
                        &EvtlogWriterWorkItem,
                        0,
                        0
                        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[EVT] IncomingQueueDataAvailable, PostWorkItem failed, error %1!u! !\n",
            status);
    }
}

VOID
DroppedDataNotify(
    IN PWCHAR QueueName,
    IN DWORD DroppedDataCount,
    IN DWORD DroppedDataSize
    )
/*++

Routine Description:

     This routine is called by the queue to notify
     that some data were lost because the queue was full

Arguments:

     QueueName - Queue Name
     DataCount - How many chunks of data were lost
     DataSize  - Total size fo the lost data

Return Value:

     None

--*/
{
    WCHAR  count[32];
    WCHAR  size[32];
    ClRtlLogPrint(LOG_UNUSUAL,
        "[EVT] %1!ws!: dropped %2!d!, total dropped size %3!d!.\n",
        QueueName,
        DroppedDataCount,
        DroppedDataSize );


    wsprintfW(count+0, L"%u", DroppedDataCount);
    wsprintfW(size+0, L"%u", DroppedDataSize);

    ClusterLogEvent3(LOG_UNUSUAL,
                LOG_CURRENT_MODULE,
                __FILE__,
                __LINE__,
                EVTLOG_DATA_DROPPED,
                0,
                NULL,
                QueueName,
                count,
                size);
}

////////////////////////////////////////////////////////////////////////////


LARGE_INTEGER RegistryCheckInterval;
LARGE_INTEGER NextRegistryCheckAt;

DWORD
InitializeQueues(
    VOID)
{
    DWORD status, OutgoingQueueStatus;
    status =
        SimpleQueueInitialize(
            &OutgoingQueue,
            OUTGOING_QUEUE_SIZE,
            OUTGOING_QUEUE_NAME,

            OutgoingQueueDataAvailable,
            DroppedDataNotify,
            DROPPED_DATA_NOTIFY_INTERVAL // seconds //
        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[EVT] Failed to create '%1!ws!', error %2!u!.\n",
                      OUTGOING_QUEUE_NAME, status );
    }
    OutgoingQueueStatus = status;
    status =
        SimpleQueueInitialize(
            &IncomingQueue,
            INCOMING_QUEUE_SIZE,
            INCOMING_QUEUE_NAME,

            IncomingQueueDataAvailable,
            DroppedDataNotify,
            DROPPED_DATA_NOTIFY_INTERVAL // seconds //
        );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[EVT] Failed to create '%1!ws!', error %2!u!.\n",
                      INCOMING_QUEUE_NAME, status );
    }

    ClRtlInitializeWorkItem(
        &EvtBroadcasterWorkItem,
        EvtBroadcaster,
        (PVOID) &OutgoingQueue
        );
    ClRtlInitializeWorkItem(
        &EvtlogWriterWorkItem,
        EvtlogWriter,
        (PVOID) &IncomingQueue
        );
    RegistryCheckInterval.QuadPart = Int32x32To64(10 * 1000 * 1000, CHECK_CLUSTER_REGISTRY_EVERY);
    NextRegistryCheckAt.QuadPart = 0;

    ReadRegistryKeys();
    return OutgoingQueueStatus;
}

////////////////////////////////////////////////////////////////////////////

VOID
DestroyQueues(
    VOID)
{
    CheckForDroppedData(&IncomingQueue, TRUE);
    CheckForDroppedData(&OutgoingQueue, TRUE);

    // [GN] TODO
    // Add proper destruction of queues
}

VOID
ReadRegistryKeys(
    VOID)
/*
 *
 */
{
    HDMKEY nodeKey;
    DWORD NodePropagate;
    DWORD ClusterPropagate;
    static DWORD OldPropagateState = 0xCAFEBABE;
    DWORD status;

    nodeKey = DmOpenKey(
                  DmNodesKey,
                  NmLocalNodeIdString,
                  KEY_READ
                  );

    if (nodeKey != NULL) {
        status = DmQueryDword(
                     nodeKey,
                     CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
                     &NodePropagate,
                     &DefaultNodePropagate
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[EVT] Unable to query propagation mode for local node, status %1!u!.\n",
                status
                );
        }



        DmCloseKey(nodeKey);
    }
    else {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Unable to open database key to local node, status %1!u!. Assuming default settings.\n",
            GetLastError());
        NodePropagate = DefaultNodePropagate;
    }

    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
                 &ClusterPropagate,
                 &DefaultClusterPropagate
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Unable to query global propagation mode, status %1!u!.\n",
            status
            );
    }

    NodePropagate &= ClusterPropagate;

    if (NodePropagate != OldPropagateState) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Set propagation state to %1!04x!\n", NodePropagate
            );
        if (NodePropagate & OUTGOING_PROPAGATION_ENABLED) {
            if (OutgoingQueue.Begin) {
                OutgoingQueue.Enabled = 1;
            }
        } else {
            OutgoingQueue.Enabled = 0;
        }
#if 0
        if (NodePropagate & INCOMING_PROPAGATION_ENABLED) {
            if (IncomingQueue.Begin) {
                IncomingQueue.Enabled = 1;
            }
        } else {
            IncomingQueue.Enabled = 0;
        }
#endif
        if(NodePropagate & TRACE_EVERYTHING_ENABLED) {
            EventlogTraceEverything = 1;
        } else {
            EventlogTraceEverything = 0;
        }
        OldPropagateState = NodePropagate;
    }

#ifdef EVTLOG_DELTA_GENERATION
    {
    DWORD   dwDefaultGenerateDeltas;

    dwDefaultGenerateDeltas = TRUE;
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_EVTLOGDELTA_GENERATION,
                 &g_dwGenerateDeltas,
                 &dwDefaultGenerateDeltas
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[EVT] Unable to query global propagation mode, status %1!u!.\n",
            status
            );
    }

    //if delta generation is true, also check the mixed mode status
    //if this is less than a pure whistler cluster, turn off the delta
    //generation since it doesnt make any sense unless all nodes can
    //generate the time deltas.
    
    if (g_dwGenerateDeltas)
    {
        if (!g_dwVersionsAllowDeltaGeneration)
            g_dwGenerateDeltas = FALSE;
    }
    }
#endif    
    
}

VOID
PeriodicRegistryCheck(
    VOID)
{
    LARGE_INTEGER currentTime;
    GetSystemTimeAsFileTime( (LPFILETIME)&currentTime);
    if( currentTime.QuadPart > NextRegistryCheckAt.QuadPart ) {
        ReadRegistryKeys();
        NextRegistryCheckAt.QuadPart = currentTime.QuadPart + RegistryCheckInterval.QuadPart;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\evtlog\simpleq.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    simpleq.c

Abstract:

    Simple non-blocking queue, that allows
    multiple concurrent data providers
    and singe data consumer

Author:

    GorN 9-Feb-1999

Revision History:

--*/

#include "evtlogp.h"
#include "simpleq.h"

DWORD SimpleQueueInitialize(
    IN OUT PSIMPLEQUEUE q, 
    IN DWORD cbSize, 
    IN PWCHAR Name,

    IN DATA_AVAILABLE_CALLBACK DataAvailableCallback,
    IN DROPPED_DATA_NOTIFY Callback,
    IN DWORD NotifyInterval
    ) 
/*++

Routine Description:

    Initializes a queue
    
Arguments:

    q      - a queue to be initialized
    cbSize - size of the queue in bytes 
    Name   - Name of the queue. It will be supplied to DroppedDataNotifyCallback

    DataAvailableCallback     - This function will be called if there are data available
                                in the queue. This function will not be called again until
                                Read/CompleteRead operations empty the queue.
                                
    DroppedDataNotifyCallback - This function will be called if there are dropped data and
                                the last time we reported dropped data was NotifyInterval 
                                or more seconds before.
    
    NotifyInterval            - We will not report dropped data unless it has been longer
                                than NotifyInterval seconds since the last report
             
Return Value:

    ERROR_SUCCESS - success
    error code    - called failed
    
 */
{
    cbSize = SQB_INFLATE_SIZE(cbSize);
    ZeroMemory(q, sizeof(SIMPLEQUEUE) );

    q->Begin = LocalAlloc(LPTR, cbSize);
    if (q->Begin == 0) {
        return GetLastError();
    }
    q->End = q->Begin + cbSize;
    q->Head = q->Begin;
    q->Tail = q->Begin;
    q->Wrap = 0;

    q->Empty = TRUE;

    q->Name = Name;
    q->ReadInProgress = 0;
    q->DataAvailableCallback = DataAvailableCallback;

#ifdef COUNT_DROPPED_PACKETS
    GetSystemTimeAsFileTime( (LPFILETIME)&q->NextDroppedDataNotify );
    q->DroppedDataNotifyInterval.QuadPart = Int32x32To64(NotifyInterval, 10000000);
    q->NextDroppedDataNotify.QuadPart += q->DroppedDataNotifyInterval.QuadPart;
    q->DroppedDataNotifyCallback = Callback;

    q->DroppedDataCount = 0;
    q->DroppedDataSize  = 0;
#endif

    InitializeCriticalSection(&q->Lock);
    q->Enabled = TRUE;
    return ERROR_SUCCESS;
}

VOID SimpleQueueDelete(
    IN PSIMPLEQUEUE q
    ) 
/*++

Routine Description:

    Destroys a queue
    
Arguments:

    q      - a queue to be destroyed
             
Return Value:

    None
    
Comments:

    This routine will destroy queue's CriticalSection
    and deallocate queue's memory. It is the responsibility of
    the caller to guarantee that nobody will be using the queue
    after this function is called
    
 */
{
    if (q->Begin) {
        LocalFree(q->Begin);
        DeleteCriticalSection(&q->Lock);
    }
}

BOOL SimpleQueueTryAdd(
    IN PSIMPLEQUEUE q, 
    IN DWORD      PayloadSize, 
    IN PVOID      Payload) 
/*++

Routine Description:

    Tries to add data in a queue
    
Arguments:

    q           - a queue
    PayloadSise - size of the chunk to be added to a queue
    Payload     - pointer to a buffer that countains data to be added
             
Return Value:

    TRUE - if the data were put into the queue successfully
    FALSE - otherwise
    
Comments:

    DataAvailableCallback will be called 
    if there are data available. DataAvailableCallback will not be called 
    during subsequent add requests until Read/CompleteRead 
    operations empty the queue.
    
 */
{
    BOOL DataAvailableCallRequired = FALSE;
    DWORD BlockSize = SQB_PAYLOADSIZE_TO_BLOCKSIZE(PayloadSize);

    if (!q->Enabled) {
        return FALSE;
    }

    EnterCriticalSection(&q->Lock);

    if (q->Wrap) {
        if (q->Head + BlockSize > q->Tail) {
            goto NoRoom;
        }
    } else {
        if (q->End - q->Head < (INT)BlockSize) {
            // not enough room for this data at the
            // end of the queue.
            // Let's see whether we have enough room at the front
            if (q->Tail - q->Begin < (INT)BlockSize) {
                goto NoRoom;
            }
            q->Wrap = q->Head;
            q->Head = q->Begin;
        }
    }

    SQB_HEADER(q->Head)->PayloadSize = PayloadSize;
    CopyMemory( SQB_PAYLOAD(q->Head), Payload, PayloadSize);

    q->Head += BlockSize;

    q->Empty = FALSE;

    if ( !q->ReadInProgress ) {
        DataAvailableCallRequired = TRUE;
        q->ReadInProgress = TRUE;
    }
    
    LeaveCriticalSection(&q->Lock);

    if (DataAvailableCallRequired) {
        q->DataAvailableCallback(q); // Post a worker item in the queue //
    }
    return TRUE;

NoRoom:

#ifdef COUNT_DROPPED_PACKETS
    (q->DroppedDataCount) += 1;
    (q->DroppedDataSize)  += PayloadSize;
#endif
    LeaveCriticalSection(&q->Lock);
    return FALSE;
}

BOOL
SimpleQueueReadAll(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
   )
/*++

Routine Description:

    Allows to read all available blocks
    
Arguments:

    q     - a queue
    begin - receives a pointer to the first queue block
    end   - receives a pointer past the end of the last queue block
             
Return Value:

    TRUE - if we get at least one block
    FALSE - if the queue is empty
    
Comments:

    This function not always give you ALL available blocks in the 
    queue. It gives you all blocks up until the hard end of the queue buffer or
    the writing head of the queue, whatever is smaller.
    If the function returns success, it guarantees that begin < end.
    
    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
    
    You can walk over these block using SQB_NEXTBLOCK macro.

 */
{
    EnterCriticalSection(&q->Lock);
    if (q->Empty) {
        q->ReadInProgress = 0;
        LeaveCriticalSection(&q->Lock);
        return FALSE;
    }
    if (q->Wrap) {
        if (q->Tail == q->Wrap) {
            q->Tail = q->Begin;
            *begin = q->Begin;
            *end   = q->Head;
            q->Wrap = 0;
        } else {
            *begin = q->Tail;
            *end   = q->Wrap;
        }
    } else {
        *begin = q->Tail;
        *end   = q->Head;
    }
    LeaveCriticalSection(&q->Lock);
    return TRUE;
}

BOOL
SimpleQueueReadOne(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
    )
/*++

Routine Description:

    Allows to read a single block of data
    
Arguments:

    q     - a queue
    begin - receives a pointer to the beginning of the first available queue block
    end   - receives a pointer past the end of this block
             
Return Value:

    TRUE  - success
    FALSE - if the queue is empty
    
Comments:

    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
 */
{
    EnterCriticalSection(&q->Lock);
    if (q->Empty) {
        q->ReadInProgress = 0;
        LeaveCriticalSection(&q->Lock);
        return FALSE;
    }
    if (q->Wrap) {
        if (q->Tail == q->Wrap) {
            q->Tail = q->Begin;
            *begin = q->Begin;
            q->Wrap = 0;
        } else {
            *begin = q->Tail;
        }
    } else {
        *begin = q->Tail;
    }
    // we have one or more items //
    *end = SQB_NEXTBLOCK(q->Tail);
    LeaveCriticalSection(&q->Lock);
    return TRUE;
}

BOOL 
SimpleQueueReadComplete(
    IN PSIMPLEQUEUE q,
    IN PVOID newtail
    )
/*++

Routine Description:

    Use this function to signal that the block of data was
    consumed
    
Arguments:

    q     - a queue
    end   - receives a pointer past the end of the last consumed block.
            Usually this is a value returned by the PVOID end parameter of
            ReadOne and ReadAll
             
Return Value:

    TRUE  - There are more data
    FALSE - if the queue is empty
    
Important!!!
     
    If the result of this function is TRUE, the caller should consume the data
    using ReadOne or ReadAll functions followed by the calls 
    to ReadComplete until it returns FALSE.
    
    Otherwise, no futher DataAvailable notifications will be produced bu
    SimpleQueueTryAdd
    
 */
{
    BOOL moreData;
    EnterCriticalSection(&q->Lock);
    q->Tail = newtail;
    if (q->Tail == q->Head) {
        q->Empty = TRUE;
        moreData = FALSE;
    } else {
        moreData = TRUE;
    }
    q->ReadInProgress = moreData;
    LeaveCriticalSection(&q->Lock);
    return moreData;
}

#ifdef COUNT_DROPPED_PACKETS
VOID
CheckForDroppedData(
    IN PSIMPLEQUEUE q, 
    IN BOOL Now
    )
/*++

Routine Description:

    This function checks whether there were
    some data dropped and if the time is right,
    calls DropNotifyCallback function.
    
Arguments:

    q     - a queue
    Now   - If TRUE, than DropNotifyCallback will be called 
            immediately if there are dropped data.
            If FALSE, DropNotifyCallback will be called
            only if it is more then DroppedNotifyInterval
            seconds elapsed, since the last time we called
            DropNotifyCallback
            
Return Value:

    None
 */
{
    if (q->DroppedDataNotifyCallback) {
        ULARGE_INTEGER current;
        GetSystemTimeAsFileTime( (LPFILETIME)&current );
        EnterCriticalSection(&q->Lock);
        if ( q->DroppedDataCount &&
             (Now || CompareFileTime( (LPFILETIME)&current,
                                      (LPFILETIME)&q->NextDroppedDataNotify) > 0 ) 
           )
        {
            DWORD DroppedCount, DroppedSize;
            DroppedCount = q->DroppedDataCount;
            DroppedSize = q->DroppedDataSize;
            q->DroppedDataCount = 0;
            q->DroppedDataSize = 0;

            q->NextDroppedDataNotify.QuadPart = 
                current.QuadPart + q->DroppedDataNotifyInterval.QuadPart;

            LeaveCriticalSection(&q->Lock);
            q->DroppedDataNotifyCallback(q->Name, DroppedCount, DroppedSize);
        } else {
            LeaveCriticalSection(&q->Lock);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmapi.c
    
Abstract:

    Cluster manager api service routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE FMAPI

//
// Local Functions
//
DWORD
FmpCanonicalizePath(
    IN OUT LPWSTR lpszPath,
    OUT PBOOL pfIsPathUNC
    );


//
// Functions Exported to the rest of the Cluster Manager
//



////////////////////////////////////////////////////////
//
// Group management functions.
//
////////////////////////////////////////////////////////

DWORD
WINAPI
FmOnlineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Bring the specified group online.  This means bringing all of the
    individual resources contained within the group online.  This is an
    atomic operation - so either all resources contained within the group
    are brought online, or none of them are.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

Retruns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;

    FmpMustBeOnline( );

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Make sure the owning node is not paused.
    //
    if (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SHARING_PAUSED);
    }

    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalGroupLock( Group );
        return(FmcOnlineGroupRequest(Group));
    }

    //
    // Set the PersistentState for this Group - the PersistentState is persistent.
    //
    FmpSetGroupPersistentState( Group, ClusterGroupOnline );

    status = FmpOnlineGroup( Group, TRUE );

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmOnlineGroup


DWORD
WINAPI
FmOfflineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Bring the specified group offline.  This means bringing all of the
    individual resources contained within the group offline.

Arguments:

    Group - Supplies a pointer to the group structure to bring offline.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;

    FmpMustBeOnline( );

    //
    // Check if we are the owner... if not, ship the request off to some
    // other place.
    //

    if ( Group->OwnerNode != NmLocalNode ) {
        return(FmcOfflineGroupRequest(Group));
    }

    //
    // Set the PersistentState for this Group - the PersistentState is persistent.
    //
    FmpSetGroupPersistentState( Group, ClusterGroupOffline );

    status = FmpOfflineGroup( Group, FALSE, TRUE);


    return(status);

} // FmOfflineGroup


DWORD
WINAPI
FmMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Failover the specified Group.  This means taking all of the individual
    resources contained within the group offline and requesting the
    DestinationNode to bring the Group Online.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to THE OTHER node.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    The Group may or may not be online on the DestinationNode, depending on
    whether the online request succeeded.  This means that the status return
    is merely the status return for the Online request for the DestinationNode.

--*/

{
    FmpMustBeOnline( );

    return(FmpDoMoveGroup( Group, DestinationNode, TRUE ));

} // FmMoveGroup



PFM_GROUP
WINAPI
FmCreateGroup(
    IN LPWSTR GroupId,
    IN LPCWSTR GroupName
    )

/*++

Routine Description:

    Create the specified GroupId.  This requires verifying that the
    specified GroupId does not already exist and then creating an
    empty Group container into which resources can be added.

    Note that the returned PFM_GROUP will have already been referenced.
    This prevents somebody from deleting the group before the caller
    gets a chance to reference it.

Arguments:

    GroupId - Supplies the Id of the Group to create.

    GroupName - Supplies the 'user-friendly' name of the Group.

Returns:

    Pointer to the newly created group if successful.

    NULL if unsuccessful. GetLastError() will return the specific error.

--*/

{
    DWORD Status;
    PFM_GROUP Group;
    PGUM_CREATE_GROUP GumGroup;
    DWORD BufSize;
    DWORD GroupIdLen;
    DWORD GroupNameLen;

    FmpMustBeOnlineEx( NULL );

    //
    // Allocate a message buffer.
    //
    GroupIdLen = (lstrlenW(GroupId)+1)*sizeof(WCHAR);
    GroupNameLen = (lstrlenW(GroupName)+1)*sizeof(WCHAR);
    BufSize = sizeof(GUM_CREATE_GROUP) - sizeof(WCHAR) + GroupIdLen +
              GroupNameLen + (lstrlenW( OmObjectId(NmLocalNode) ) + 1) * sizeof(WCHAR);
    GumGroup = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumGroup == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmCreateGroup: Unable to alloc mem for group <%1!ws!>....\n",
                     GroupName);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Fill in message buffer.
    //
    GumGroup->Group = NULL;
    GumGroup->GroupIdLen = GroupIdLen;
    GumGroup->GroupNameLen = GroupNameLen;
    wcscpy(GumGroup->GroupId, GroupId);
    CopyMemory((PCHAR)GumGroup->GroupId + GroupIdLen,
               GroupName,
               GroupNameLen);
    CopyMemory((PCHAR)GumGroup->GroupId + GroupIdLen + GroupNameLen,
               OmObjectId(NmLocalNode),
               (lstrlenW( OmObjectId(NmLocalNode) ) + 1) * sizeof(WCHAR));

    //
    // Send message.
    //
    Status = GumSendUpdate(GumUpdateFailoverManager,
                           FmUpdateCreateGroup,
                           BufSize,
                           GumGroup);

    if ((GumGroup->Group == NULL) && (FmpShutdown)) {
        Status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
    }
    
    if (Status != ERROR_SUCCESS) {
        LocalFree(GumGroup);
        SetLastError(Status);
        return(NULL);
    }

    Group = GumGroup->Group;
    CL_ASSERT(Group != NULL);
    LocalFree(GumGroup);
    return(Group);
} // FmCreateGroup


DWORD
WINAPI
FmDeleteGroup(
    IN PFM_GROUP pGroup
    )

/*--

Routine Description:

    Delete the specified Group.  This means verifying that the specified
    Group does not contain any resources (resources must be removed
    by a separate call to remove the resources), and then deleting the
    Group.

Arguments:

    Group - Supplies the Group to delete.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD   dwStatus;

    FmpMustBeOnline( );

    FmpAcquireLocalGroupLock( pGroup );

    if (pGroup->OwnerNode == NmLocalNode)
    {
        dwStatus = FmpDeleteGroup(pGroup);
    }
    else
    {
        //
        // FmcDeleteGroup releases the group lock
        //
        dwStatus = FmcDeleteGroupRequest(pGroup);
        goto FnExit;
    }

    FmpReleaseLocalGroupLock(pGroup);
    
FnExit:    
    return(dwStatus);

}  // FmDeleteGroup



DWORD
WINAPI
FmSetGroupName(
    IN PFM_GROUP Group,
    IN LPCWSTR FriendlyName
    )

/*++

Routine Description:

    Set the user-friendly name for the specified Group.

    Note that the Group must have already been created. It is also
    assumed that the caller of this routine (the cluster API) has already
    verified that the name is NOT a duplicate.

Arguments:

    Group - Supplies the Group to enter a new name.

    FriendlyName - Supplies the user-friendly name for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPCWSTR GroupId;
    DWORD Status;

    GroupId = OmObjectId(Group);

    Status = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateChangeGroupName,
                             2,
                             (lstrlenW(GroupId)+1)*sizeof(WCHAR),
                             GroupId,
                             (lstrlenW(FriendlyName)+1)*sizeof(WCHAR),
                             FriendlyName);
    return(Status);

} // FmSetGroupName



CLUSTER_GROUP_STATE
WINAPI
FmGetGroupState(
    IN PFM_GROUP Group,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength OPTIONAL
    )

/*++

Routine Description:

    Get the current state for the specified Group. The Group state
    consists of state of the group, along with the current node that is
    hosting the Group (if the state of the Group is anything but
    ClusterGroupOffline.

Arguments:

    Group - Supplies the group object to get the state.

    NodeName - Supplies a pointer to a buffer into which the name of
        the node in the cluster the specified Group is currently hosted.
        This field can be NULL, if NameLength is zero.

    NameLength - Supplies a pointer to a DWORD containing the number of
        characters available to the NodeName buffer (including the terminating
        NULL character. On return, it is the number of characters written
        into the NodeName buffer not including the NULL character.

Returns:

    Returns the current state of the group:

        ClusterGroupOnline
        ClusterGroupOffline
        ClusterGroupPending
        ClusterGroupPartialOnline
        ClusterGroupFailed

    If the function fails, then the return value is ClusterGroupStateUnknown.

--*/

{
    CLUSTER_GROUP_STATE state;
    DWORD nameLength=0;
    DWORD length;

    if ( ARGUMENT_PRESENT( NameLength ) ) {
        nameLength = *NameLength;
        *NodeName = (WCHAR)0;
        *NameLength = 0;
    }

    FmpMustBeOnlineEx( ClusterGroupStateUnknown );

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Check if the OwnerNodes exists 
    //
    // SS: dont filter out the node if it not in the preferred list
    // how is the poor user going to know who the current owner is??
    if (Group->OwnerNode != NULL) {
        //
        // The Group is 'owned' by some system
        //
        if ( ARGUMENT_PRESENT( NameLength ) ) {
            length = lstrlenW( OmObjectName(Group->OwnerNode) ) + 1;
            if ( nameLength < length ) {
                length = nameLength;
            }
            lstrcpynW( NodeName, OmObjectName(Group->OwnerNode), length );
            *NameLength = length;
        }
    }

    //
    // Get the group state which is not normalized
    //
    state = FmpGetGroupState( Group, FALSE );

    FmpReleaseLocalGroupLock( Group );

    if ( state == ClusterGroupStateUnknown ) {
        SetLastError(ERROR_INVALID_STATE);
    }

    return(state);

} // FmGetGroupState



DWORD
WINAPI
FmEnumerateGroupResources(
    IN PFM_GROUP Group,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    Enumerate all the resources in a group.

Arguments:

    Group - Supplies the group which must be enumerated.

    EnumerationRoutine - The enumeration function.

    Context1 - The enumeration list (allocated by the caller).

    Context2 - Size of the enumerated list.

Returns:

    ERROR_SUCCESS on success.

    A Win32 error code otherwise.

Comments:

    This function executes only when the FM is fully online.

--*/
{
    FmpMustBeOnline();

    FmpEnumerateGroupResources( Group,
                                EnumerationRoutine,
                                Context1,
                                Context2 );

    return(ERROR_SUCCESS);
} // FmEnumerateGroupResources

DWORD
FmpEnumerateGroupResources(
    IN PFM_GROUP pGroup,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE pfnEnumerationRoutine,
    IN PVOID pContext1,
    IN PVOID pContext2
    )
/*++

Routine Description:

    Enumerate all the resources in a group.

Arguments:

    pGroup - Supplies the group which must be enumerated.

    pfnEnumerationRoutine - The enumeration function.

    pContext1 - The enumeration list (allocated by the caller).

    pContext2 - Size of the enumerated list.

Returns:

    ERROR_SUCCESS.

Comments:

    This function executes even when the FM is not fully online. This is
    necessary for a joining node to query the resource states while the
    owner node of the group is shutting down.

--*/
{
    PFM_RESOURCE pResource;
    PLIST_ENTRY  pListEntry;
    
    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpEnumerateGroupResources: Entry for group <%1!ws!>....\n",
              OmObjectId(pGroup));

    FmpAcquireLocalGroupLock( pGroup );

    //
    // If the group has been marked for delete, then fail this call
    //
    if ( !IS_VALID_FM_GROUP( pGroup ) )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
              "[FM] FmpEnumerateGroupResources: Group <%1!ws!> marked for deletion....\n",
              OmObjectId(pGroup));
        goto FnExit;
    }

    //
    // Run through contains list, then find all resources under that tree.
    //
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &(pGroup->Contains);
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );

        if ( !pfnEnumerationRoutine( pContext1,
                                     pContext2,
                                     pResource,
                                     OmObjectId( pResource ) ) ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpEnumerateGroupResources: Enumeration routine for group <%1!ws!> fails....\n",
                      OmObjectId(pGroup));
            break;
        }
    }
    
FnExit:
    FmpReleaseLocalGroupLock( pGroup );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpEnumerateGroupResources: Exit for group <%1!ws!>....\n",
              OmObjectId(pGroup));
    return( ERROR_SUCCESS );
} // FmpEnumerateGroupResources




////////////////////////////////////////////////////////
//
// Resource management functions.
//
////////////////////////////////////////////////////////

PFM_RESOURCE
WINAPI
FmCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Create the specified resource.

    Note that the returned PFM_RESOURCE will have already been referenced.
    This prevents somebody from deleting the resource before the caller
    gets a chance to reference it.

Arguments:

    Group - Supplies the group in which this resource belongs.

    ResourceId - Supplies the Id of the resource to create.

    ResourceName - Supplies the 'user-friendly' name of the resource.

    ResourceType - Supplies the 'user-friendly' name of the resource type.

    dwFlags - The flags for the resource.

Returns:

    Pointer to the newly created resource if successful.

    NULL if unsuccessful. GetLastError() will return the specific error.

--*/

{
    DWORD Status;
    PFM_RESOURCE Resource;
    LPCWSTR GroupId;
    PGUM_CREATE_RESOURCE GumResource;
    DWORD GroupIdLen;
    DWORD ResourceIdLen;
    DWORD ResourceNameLen;
    DWORD ResourceTypeLen;
    DWORD BufSize;
    HDMKEY ResourceKey;
    HDMKEY ParamsKey;
    DWORD  Disposition;

    FmpMustBeOnlineEx( NULL );

    FmpAcquireLocalGroupLock( Group );

    //
    // If we own the group then we can issue the Gum request to create
    // the resource. Otherwise, request the owner to initiate the request.
    //
    if ( Group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        GroupId = OmObjectId(Group);
        GroupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        ResourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        ResourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        ResourceTypeLen = (lstrlenW(ResourceType)+1) * sizeof(WCHAR);
        BufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  GroupIdLen + ResourceIdLen + ResourceNameLen + ResourceTypeLen + 2 * sizeof( DWORD );
        GumResource = LocalAlloc(LMEM_FIXED, BufSize);
        if (GumResource == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmCreateResource: Unable to allocate memory for resource <%1!ws!>....\n",
                          ResourceName);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        //
        // Fill in message buffer.
        //
        GumResource->Resource = NULL;
        GumResource->GroupIdLen = GroupIdLen;
        GumResource->ResourceIdLen = ResourceIdLen;
        CopyMemory(GumResource->GroupId, GroupId, GroupIdLen);
        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen,
                   ResourceId,
                   ResourceIdLen);
        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen,
                   ResourceName,
                   ResourceNameLen);

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen,
                   &ResourceTypeLen,
                   sizeof( DWORD ) );

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen + sizeof( DWORD ),
                   ResourceType,
                   ResourceTypeLen );

        CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen + ResourceNameLen + sizeof( DWORD ) + ResourceTypeLen,
                   &dwFlags,
                   sizeof( DWORD ) );

        //
        // Send message.
        //
        Status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               BufSize,
                               GumResource);

        //
        //  If the GUM call was successful, ensure that the resource DLL initialization stuff is
        //  also done so that APIs following the CreateClusterResource API can make assumptions
        //  that the resource is fully created. Note that the GUM call above will post a work item
        //  for the FM worker thread to initialize a resource but there is no guarantee when the
        //  FM worker thread will act on the work item. The following call will make sure we 
        //  won't return from this API until the initialization is fully done thus not giving any
        //  chance for APIs such as ChangeClusterResourceGroup that follow this API to screw things
        //  up. For backward compatibility reasons (consider a create call originating from a
        //  W2K node), we still keep the work item posting in GUM and it won't do any harm since
        //  the FmpInitializeResource call is idempotent.
        //
        if ( ( Status == ERROR_SUCCESS ) &&
             ( GumResource->Resource != NULL ) )
        {
            FmpClusterWideInitializeResource ( GumResource->Resource );
        }

        FmpReleaseLocalGroupLock( Group );
        if (Status != ERROR_SUCCESS) {
            LocalFree(GumResource);
            SetLastError(Status);
            return(NULL);
        }
        //The create resource by default adds all nodes
        //as possible nodes for a resource without filtering
        //out the nodes that dont support the resource type
        if( GumResource->Resource != NULL ) {
            FmpCleanupPossibleNodeList(GumResource->Resource);
       	}
        Resource = GumResource->Resource;
        if( ( Resource == NULL ) && FmpShutdown ) {
            SetLastError( ERROR_CLUSTER_NODE_SHUTTING_DOWN );
        }
        LocalFree(GumResource);
    } else {
        //
        // The Group lock is released by FmcCreateResource
        //
        Resource = FmcCreateResource( Group,
                                      ResourceId,
                                      ResourceName,
                                      ResourceType,
                                      dwFlags );
    }


    //giving a reference to the client, increment ref count
    if ( Resource ) {
        OmReferenceObject(Resource);
    }

    return(Resource);

} // FmCreateResource



DWORD
WINAPI
FmDeleteResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Delete the specified resource.

Arguments:

    Resource - Supplies the resource to delete.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD Status;
    LPCWSTR ResourceId;
    DWORD ResourceLen;

    FmpMustBeOnline( );

    FmpAcquireLocalResourceLock( Resource );

    //
    // Check if this is the quorum resource.
    //
    if ( Resource->QuorumResource ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_QUORUM_RESOURCE);
    }

    //other core resources cannot be deleted either
    if (Resource->ExFlags & CLUS_FLAG_CORE)
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_CORE_RESOURCE);
    }

    //
    // If we own the resource then we can issue the Gum request to delete
    // the resource. Otherwise, request the owner to initiate the request.
    //
    if ( Resource->Group->OwnerNode == NmLocalNode ) {

        //
        // Check the state of the resource, before attempting to delete it.
        // It must be offline or failed in order to perform the delete.
        //
        if ((Resource->State != ClusterResourceOffline) &&
            (Resource->State != ClusterResourceFailed)) {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_RESOURCE_ONLINE);
        }

        //
        // Check whether this resource provides for any other resources.
        // If so, it cannot be deleted.
        //
        if (!IsListEmpty(&Resource->ProvidesFor)) {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_DEPENDENT_RESOURCE_EXISTS);
        }

        if (Resource->Group->MovingList)
        {
            FmpReleaseLocalResourceLock( Resource );
            return(ERROR_INVALID_STATE);
        }
        
        Status = FmpBroadcastDeleteControl(Resource);
        if ( Status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(Status);
        }
        ResourceId = OmObjectId( Resource );
        ResourceLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);

        //
        // Send message.
        //
        Status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateDeleteResource,
                                 1,
                                 ResourceLen,
                                 ResourceId);
        FmpReleaseLocalResourceLock( Resource );
    } else {
        Status = FmcDeleteResource( Resource );
    }

    return(Status);

} // FmDeleteResource



DWORD
WINAPI
FmSetResourceName(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR FriendlyName
    )

/*++

Routine Description:

    Set the user-friendly name for the specified resource.

    Note that the resource must have already been created. It is also
    assumed that the caller of this routine (the cluster API) has already
    verified that the name is NOT a duplicate.

Arguments:

    Resource - Supplies the resource to enter a new name.

    FriendlyName - Supplies the user-friendly name for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    dwStatus = FmpSetResourceName( Resource, FriendlyName );
    
    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmSetResourceName: FmpSetResourceName for resource %1!ws! fails, Status = %2!d!...\n",
                   OmObjectId(Resource),
                   dwStatus);
    }
  
    return( dwStatus );
} // FmSetResourceName



DWORD
WINAPI
FmOnlineResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine brings a resource online. It also updates the registry to
    indicate the new persistent, desired state of the resource.


Arguments:

    Resource - A pointer to the resource to bring online.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD       status;

    FmpMustBeOnline( );

    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_RESOURCE_NOT_AVAILABLE);
    }


    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalResourceLock( Resource );
        status = FmcOnlineResourceRequest( Resource );
        return(status);
    }

    //
    // Check if the resource has been initialized. If not, attempt
    // to initialize the resource now.
    //
    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    }

    //
    //  Chittur Subbaraman (chitturs) - 08/04/2000
    //
    //  If the group is moving, fail this operation.
    //
    if ( Resource->Group->MovingList != NULL )
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Try to bring the resource online.
    //
    status = FmpDoOnlineResource( Resource, TRUE );
    FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmOnlineResource



DWORD
WINAPI
FmOfflineResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine takes a resource offline. It also updates the registry
    to indicate the new persistent, desired state of the resource.


Arguments:

    Resource - A pointer to the resource to take offline.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpMustBeOnline( );


    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Check if this is the quorum resource.
    //
    if ( Resource->QuorumResource ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_QUORUM_RESOURCE);
    }


    //
    //  Chittur Subbaraman (chitturs) - 4/8/99
    //  
    //  Don't attempt to do anything if the resource has failed. You could
    //  get into some funny cases in which the resource switches between
    //  offline pending and failed states for ever.
    //
    if ( Resource->State == ClusterResourceFailed ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }
    
    //
    // Check if we are the owner... if not, ship the request off someplace
    // else.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalResourceLock( Resource );
        return(FmcOfflineResourceRequest(Resource));
    }

    //
    // Check if the resource has been initialized. If not, return
    // success because the resource is not online.
    //
    if ( Resource->Monitor == NULL ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    //  Chittur Subbaraman (chitturs) - 08/04/2000
    //
    //  If the group is moving, fail this operation.
    //
    if ( Resource->Group->MovingList != NULL )
    {
        FmpReleaseLocalResourceLock( Resource );
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    //
    // Take the resource offline.
    //
    FmpReleaseLocalResourceLock( Resource );
    return(FmpDoOfflineResource( Resource, TRUE));

} // FmOfflineResource



CLUSTER_RESOURCE_STATE
WINAPI
FmGetResourceState(
    IN PFM_RESOURCE Resource,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength OPTIONAL
    )

/*++

Routine Description:

    Get the current state for the specified resource. The resource state
    consists of state of the resource, along with the current node that is
    hosting the resource.

Arguments:

    Resource - Supplies the resource object to get the state.

    NodeName - Supplies a pointer to a buffer into which the name of
        the node in the cluster the specified resource is currently hosted.
        This field can be NULL, if NameLength is zero.

    NameLength - Supplies a pointer to a DWORD containing the number of
        characters available to the NodeName buffer (including the terminating
        NULL character. On return, it is the number of characters written
        into the NodeName buffer not including the NULL character.

Returns:

    Returns the current state of the resource:

        ClusterResourceOnline
        ClusterResourceOffline
        ClusterResourceFailed
        etc.

    If the function fails, then the return value is ClusterResourceStateUnknown.

--*/

{
    WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD nameLength;
    DWORD length;
    PNM_NODE OwnerNode;
    CLUSTER_RESOURCE_STATE state;
    BOOL    acquired;

    CL_ASSERT( OmObjectSignature(Resource) == FMP_RESOURCE_SIGNATURE );
    if ( ARGUMENT_PRESENT( NameLength ) ) {
        nameLength = *NameLength;
        *NodeName = (WCHAR)0;
        *NameLength = 0;
    }

    FmpMustBeOnlineEx( ClusterResourceStateUnknown );

    //
    // Try to acquire the lock to perform this work, so that resources
    // can query their current status and where the resource should be run.
    //
    // This does leave a potential window though if we can't get the lock,
    // some other thread could be changing the data!
    //

    FmpTryAcquireLocalResourceLock( Resource, acquired );

    OwnerNode = Resource->Group->OwnerNode;
    if ( OwnerNode != NULL ) {
        //
        // The Group is 'owned' by some system
        //
        if ( ARGUMENT_PRESENT( NameLength ) ) {
            length = lstrlenW( OmObjectName(OwnerNode) ) + 1;
            if ( nameLength < length ) {
                length = nameLength;
            }
            lstrcpynW( NodeName,
                       OmObjectName(OwnerNode),
                       length );
            *NameLength = length;
        }
    }

    state = Resource->State;

    if ( acquired ) {
        FmpReleaseLocalResourceLock( Resource );
    }

    if ( state == ClusterGroupStateUnknown ) {
        SetLastError(ERROR_INVALID_STATE);
    }

    return(state);

} // FmGetResourceState



DWORD
WINAPI
FmAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Add a dependency from one resource to another.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    LPCWSTR     pszResourceId;
    DWORD       dwResourceLen;
    LPCWSTR     pszDependsOnId;
    DWORD       dwDependsOnLen;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Modify this API to route requests to owner node. Handle the
    //  mixed mode case as well.
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmAddResourceDependency : Resource <%1!ws!>, DependentResource <%2!ws!>...\n",
               OmObjectId( pResource ),
               OmObjectId( pDependentResource ));

    FmpAcquireLocalResourceLock( pResource );
    
    //
    //  Check if we are the owner... if not, ship the request off some place
    //  else.
    //   
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        //
        // FmcAddResourceDependency releases the local resource lock
        //
        dwStatus = FmcAddResourceDependency( pResource, pDependentResource );
        goto FnExit;
    }
    
    dwStatus = FmpValAddResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnUnlock;
    }


    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) +1 ) * sizeof( WCHAR) ;

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );

    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateAddDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      FALSE );
    }

FnUnlock:
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmAddResourceDependency Exit: Status = <%1!u!>...\n",
               dwStatus);

    return( dwStatus  );

}
 // FmAddResourceDependency



DWORD
WINAPI
FmRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Remove a dependency from a resource.

Arguments:

    Resource - The resource to remove the dependent resource.
    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{

    LPCWSTR     pszResourceId;
    DWORD       dwResourceLen;
    LPCWSTR     pszDependsOnId;
    DWORD       dwDependsOnLen;
    DWORD       dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Modify this API to route requests to owner node. Handle the
    //  mixed mode case as well.
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency : Resource <%1!ws!>, DependentResource <%2!ws!>...\n",
               OmObjectId( pResource ),
               OmObjectId( pDependentResource ));

    FmpAcquireLocalResourceLock( pResource );

    //
    //  Check if we are the owner... if not, ship the request off some place
    //  else.
    //   
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        //
        // FmcRemoveResourceDependency releases the local resource lock
        //
        dwStatus = FmcRemoveResourceDependency( pResource, pDependentResource );
        goto FnExit;
    }

    dwStatus = FmpValRemoveResourceDependency( pResource, pDependentResource );
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency: FmpValRemoveResourceDependency returns status = <%1!u!>...\n",
               dwStatus);  
        goto FnUnlock;
    }

    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );


    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateRemoveDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      TRUE );
    }

FnUnlock:    
    FmpReleaseLocalResourceLock( pResource );
FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmRemoveResourceDependency Exit: Status = <%1!u!>...\n",
               dwStatus);

    return( dwStatus );

}

 // FmRemoveResourceDependency



DWORD
WINAPI
FmEnumResourceDependent(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PFM_RESOURCE *DependentResource
    )

/*++

Routine Description:

    Enumerate the dependencies of a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    DependentResource - The dependent resource. The returned resource
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PDEPENDENCY Dependency;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        CL_ASSERT(Dependency->DependentResource == Resource);
        CL_ASSERT(Dependency->ProviderResource != Resource);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(Dependency->ProviderResource);
            *DependentResource = Dependency->ProviderResource;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);
} // FmEnumResourceDependent



DWORD
WINAPI
FmEnumResourceProvider(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PFM_RESOURCE *DependentResource
    )

/*++

Routine Description:

    Enumerate the providers for a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    DependentResource - The provider resource. The returned resource
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PDEPENDENCY Dependency;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();

    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    ListEntry = Resource->ProvidesFor.Flink;
    while (ListEntry != &Resource->ProvidesFor) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       ProviderLinkage);
        CL_ASSERT(Dependency->DependentResource != Resource);
        CL_ASSERT(Dependency->ProviderResource == Resource);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(Dependency->DependentResource);
            *DependentResource = Dependency->DependentResource;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);

} // FmEnumResourceProvider


DWORD
WINAPI
FmEnumResourceNode(
    IN  PFM_RESOURCE Resource,
    IN  DWORD        Index,
    OUT PNM_NODE     *PossibleNode
    )

/*++

Routine Description:

    Enumerate the possible nodes for a resources.

Arguments:

    Resource - The resource to enumerate.

    Index - The index for this enumeration.

    PossibleNode - The possible node. The returned node
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY ListEntry;
    DWORD i = 0;
    PFM_RESOURCE Current;
    PPOSSIBLE_ENTRY PossibleEntry;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline( );

    FmpAcquireResourceLock();
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        Status = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    
    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD(ListEntry,
                                          POSSIBLE_ENTRY,
                                          PossibleLinkage);
        if (i==Index) {
            //
            // Got the right index
            //
            OmReferenceObject(PossibleEntry->PossibleNode);
            *PossibleNode = PossibleEntry->PossibleNode;
            Status = ERROR_SUCCESS;
            break;
        }
        ListEntry = ListEntry->Flink;
        ++i;
    }

FnExit:
    FmpReleaseResourceLock();

    return(Status);

} // FmEnumResourceNode



DWORD
WINAPI
FmFailResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Cause the specified resource to fail.

Arguments:

    Resource - The resource to make fail.

Returns:

    ERROR_SUCCESS - if successful.

    A Win32 error code on failure.

--*/

{
    FmpMustBeOnline( );

    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        return(FmcFailResource( Resource ));
    }

    return(FmpRmFailResource( Resource ));

} // FmFailResource



DWORD
WINAPI
FmChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    )
/*++

Routine Description:

    Changes the list of nodes where the specified resource
    can be brought online.

Arguments:

    Resource - Supplies the resource whose list of possible nodes is
        to be modified.

    Node - Supplies the node to be added to the resource's list.

    Add - Supplies whether the specified node is to be added (TRUE) or
          deleted (FALSE) from the resource's node list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD Status;

    FmpAcquireLocalResourceLock( Resource );

    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        // Note: FmcChangeResourceNode must release the resource lock.
        Status = FmcChangeResourceNode( Resource, Node, Add );
    } 
    else 
    {

        Status = FmpChangeResourceNode(Resource, OmObjectId(Node), Add);
        FmpReleaseLocalResourceLock( Resource );
    }
    return(Status);
} // FmChangeResourceNode




DWORD
WINAPI
FmSetQuorumResource(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      pszClusFileRootPath,
    IN DWORD        dwMaxQuorumLogSize
    )

/*++

Routine Description:

    Set the specified resource as the quorum resource. This requires making
    sure that the specified resource can perform an arbitrate. We do this
    by asking the owner node to perform an arbitrate of the resource.

Arguments:

    Resource - Supplies the resource that must be arbitrated.

    pszLogPathName - The root path where the log files will be moved. "Microsoft
        Cluster Manager Directory" is created under the root path provided. If NULL,
        a partition on the shared quorum device is picked up randomly. And
        the log files are placed in the directory specified by the
        CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE constant at the root of that partition.

    dwMaxQuorumLogSize - The maximum size of the quorum logs.  If 0, the default
        used.  If smaller that 32K, 32K is used.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           resourceIdLen;
    PFM_RESOURCE    quorumResource = NULL;
    PFM_RESOURCE    pOldQuoResource = NULL;
    PVOID           gumResource = NULL;
    DWORD           dwBytesReturned;
    DWORD           dwRequired;
    DWORD           dwBufSize;
    WCHAR           szQuoLogPath[MAX_PATH] = L"\0";
    WCHAR           szLogRootPath[MAX_PATH];
    CLUS_RESOURCE_CLASS_INFO   resClassInfo;
    PUCHAR          pBuf = NULL;
    LPWSTR          pszOldQuoLogPath = NULL;
    LPWSTR          pszNext = NULL;
    LPWSTR          pszExpClusFileRootPath = NULL;
    DWORD           dwCharacteristics;
    BOOL            fIsPathUNC;
    DWORD           dwCurrentNodeCnt;
    DWORD           dwClusterHighestVersion;
    
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Entry, pszClusFileRootPath=%1!ws!\r\n",
               ((pszClusFileRootPath)? pszClusFileRootPath:szQuoLogPath));

    dwCurrentNodeCnt = NmGetCurrentNumberOfNodes();
    // find the old quorum resource
    status  =  FmFindQuorumResource(&pOldQuoResource);
    if (status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //
    // Synchronize access to Quorum Resource changes.
    //
    //
    // Synchronize both the old and the new resource.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // if the old and new resource belong to the same group
    // the comparison will be be equal!
    //
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);

    if ( lstrcmpiW( OmObjectId( pOldQuoResource->Group ), 
        OmObjectId( Resource->Group ) )  <= 0 ) {
        FmpAcquireLocalGroupLock( pOldQuoResource->Group );
        FmpAcquireLocalGroupLock( Resource->Group );
    } else {
        FmpAcquireLocalGroupLock( Resource->Group );
        FmpAcquireLocalGroupLock( pOldQuoResource->Group );
    }

    status = FmpGetResourceCharacteristics(Resource, &dwCharacteristics);

    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: getresourcecharacteristics failed, status=%1!u!\n",
               status);
        goto FnExit;
    }

    //
    //  If the resource doesn't advertise itself as quorum-capable, no point in proceeding.
    //
    if ( !( dwCharacteristics & CLUS_CHAR_QUORUM ) )
    {
        status = ERROR_NOT_QUORUM_CAPABLE;
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: Resource %1!ws! can't be quorum, status %2!u!\n",
                      OmObjectName(Resource),
                      status);
        goto FnExit;
    }

    if (dwCurrentNodeCnt > 1)
    {
        //if the cluster is a multinode cluster, dont allow a switch to 
        //local quorum type resources unless the debug characteristic is set
        if ((dwCharacteristics  & CLUS_CHAR_LOCAL_QUORUM) &&
            !(dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM_DEBUG))
        {
            status = ERROR_INVALID_PARAMETER;
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: No debug property for local quorum resource %1!ws!, status %2!u!\n",
                          OmObjectName(Resource),
                          status);
            goto FnExit;
        }
        
    }
    if (Resource->State != ClusterResourceOnline)
    {
        status = ERROR_RESOURCE_NOT_ONLINE;
        goto FnExit;

    }
    
    if (!IsListEmpty(&Resource->DependsOn)) 
    {
        status = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }

    //
    // Get the old log path.
    //
    dwBytesReturned = 0;
    dwRequired = 0;

    status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        (LPWSTR*)&pszOldQuoLogPath,
                        &dwRequired,
                        &dwBytesReturned);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmSetQuorumResource Failed to get the old quo log path, error %1!u!.\n",
                   status);
        goto FnExit;
    }
    //SS: if you want to have a sub dir for logging files

    //check the resource class
    status = FmResourceControl(Resource, NULL, CLUSCTL_RESOURCE_GET_CLASS_INFO, NULL, 0,
        (PUCHAR)&resClassInfo, sizeof(resClassInfo), &dwBytesReturned, &dwRequired);
    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: Unable to get class info for resource %1!ws!, status %2!u!\n",
                      OmObjectName(Resource),
                      status);
        goto FnExit;
    }

    if ( ( resClassInfo.SubClass & CLUS_RESSUBCLASS_SHARED ) == 0 )
    {
        status = ERROR_NOT_QUORUM_CLASS;
        goto FnExit;
    }

    //allocate info for the disk info
    //get disk info
    dwBufSize = 2048;
Retry:
    pBuf = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pBuf == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    status = FmResourceControl(Resource, NULL, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
        NULL, 0, pBuf, dwBufSize, &dwBytesReturned, &dwRequired);
    if ((status == ERROR_MORE_DATA) && (dwBufSize < dwRequired))
    {
        dwBufSize = dwRequired;
        LocalFree(pBuf);
        goto Retry;
    }

    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: Unable to get disk info for resource %1!ws!, status %2!u!\n",
                      OmObjectName(Resource),
                      status);
        goto FnExit;
    }

    if (pszClusFileRootPath)
        pszExpClusFileRootPath = ClRtlExpandEnvironmentStrings(pszClusFileRootPath);

    //use the expanded path name for validation
    if (pszExpClusFileRootPath)
    {
        WCHAR   cColon=L':';

        //
        //  The quorum management code assumes that the quorum path + file names such as quolog.log can all fit in MAX_PATH
        //  sized buffers.  It is too much code churn to fix all places in which this assumption is made.  Let us reject paths that
        //  are too long right here.
        //
        if ( lstrlen ( pszExpClusFileRootPath ) + 20 > MAX_PATH  ) 
        {
            status = ERROR_BAD_PATHNAME;
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmSetQuorumResource: Path specified is too long, status %1!u!\n",
                               status);          
            goto FnExit;
        }
        
        pszNext = wcschr(pszExpClusFileRootPath, cColon);    
        //pick up just the drive letter
        if (pszNext)
        {
            lstrcpynW(szLogRootPath, pszExpClusFileRootPath, 
                      (UINT)(pszNext-pszExpClusFileRootPath+2));
        }
        else
        {
            //if there is no drive letter, pick up a drive letter at random
            szLogRootPath[0] = L'\0';
        }

    }
    else
    {
        szLogRootPath[0] = L'\0';
    }        

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szLogRootPath=%1!ws!\r\n",
               szLogRootPath);

    //save the drive letter for the new quorum path
    status = FmpGetDiskInfoParseProperties(pBuf, dwBytesReturned, szLogRootPath);

    //if the status was invalid parameter for a local quorum, ignore the local
    //quorum path setting..what is specified through this api overrides
    if ((status == ERROR_INVALID_PARAMETER) && 
        (dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM))
    {
        status = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_NOISE,
           "[FM] FmSetQuorumResource: LocalQuorum force success, szLogRootPath=%1!ws!\r\n",
                szLogRootPath);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szLogRootPath=%1!ws!\r\n",
               szLogRootPath);
    
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: Unable to parse disk info for resource %1!ws!, status %2!u!\n",
                  OmObjectName(Resource),
                  status);
        goto FnExit;
    }

    if (szLogRootPath[0] == L'\0')
    {
        //no valid drive letter is found
        status = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: No valid drive letter for resource %1!ws!, status %2!u!\n",
                  OmObjectName(Resource),
                  status);
        goto FnExit;
    }
    //got the drive letter
    lstrcpyW(szQuoLogPath, szLogRootPath);
    if (pszNext)
    {
        // if the driver letter was supplied, append the rest of the path
        lstrcatW(szQuoLogPath, pszNext+1);
    }            
    else
    {
        //if no drive letter was supplied 
        // if a path was supplied, append the path 
        if ( pszExpClusFileRootPath ) 
        {
            //
            // If the user specifies an SMB path, we override whatever the resource told us.
            //
            if ( ( lstrlenW( pszExpClusFileRootPath ) >=2 ) &&
                 ( pszExpClusFileRootPath[0] == L'\\' ) &&
                 ( pszExpClusFileRootPath[1] == L'\\' ) &&
                 ( dwCharacteristics & CLUS_CHAR_QUORUM ) ) 
            {
                lstrcpyW( szQuoLogPath, pszExpClusFileRootPath );
            } 
            else if ( pszExpClusFileRootPath[0] == L'\\' )
            {
                lstrcatW( szQuoLogPath, pszExpClusFileRootPath );
            }                
            else
            {
                lstrcatW( szQuoLogPath, L"\\" );
                lstrcatW( szQuoLogPath, pszExpClusFileRootPath );
            }
        }                    
        else
        {
            // else append the default path
            lstrcatW( szQuoLogPath, L"\\" );
            lstrcatW(szQuoLogPath, CLUS_NAME_DEFAULT_FILESPATH);
        }            
    }   
    
    //if the path name is provided, check if it is terminated with '\'
    //if not, terminate it
    if (szQuoLogPath[lstrlenW(szQuoLogPath) - 1] != L'\\')
    {
        lstrcatW( szQuoLogPath, L"\\" );
    }

    //
    //  If the path is of UNC form, then prepend a \\?\UNC\ to it.
    //
    status = FmpCanonicalizePath( szQuoLogPath, &fIsPathUNC );

    if ( status != ERROR_SUCCESS ) goto FnExit;
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: szQuoLogPath=%1!ws!\r\n",
               szQuoLogPath);
        
    //
    // Allocate a message buffer.
    //
    resourceIdLen = (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR);
    gumResource = LocalAlloc(LMEM_FIXED, resourceIdLen);
    if (gumResource == NULL)
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    //
    // Fill in message buffer.
    //
    CopyMemory(gumResource, OmObjectId(Resource), resourceIdLen);

    //
    // Make sure that we can arbitrate the new quorum resource.
    //
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        status = FmcArbitrateResource( Resource );
    } else {
        status = FmpRmArbitrateResource( Resource );
    }

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmSetQuorumResource: Arbitrate for resource %1!ws! failed, status %2!u!\n",
                  OmObjectName(Resource),
                  status);
        goto FnExit;
    }

    //check the log size, if it not zero but less than the min
    //limit set it to 32K.
    if ((dwMaxQuorumLogSize) && (dwMaxQuorumLogSize < CLUSTER_QUORUM_MIN_LOG_SIZE))
    {
        dwMaxQuorumLogSize = CLUSTER_QUORUM_MIN_LOG_SIZE;
    }
    //Prepare to move to a new quorum resource
    //create a new quorum log file and
    //move the registry files there.
    if ( Resource->Group->OwnerNode != NmLocalNode ) {
        status = FmcPrepareQuorumResChange( Resource, szQuoLogPath, dwMaxQuorumLogSize );
    } else {
        status = FmpPrepareQuorumResChange( Resource, szQuoLogPath, dwMaxQuorumLogSize );
    }

    if ( status != ERROR_SUCCESS ) {
        if ((dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM) && (fIsPathUNC == FALSE))
        {
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Local quorum, map FmpPrepareQuorumResChange to success\n");
            status = ERROR_SUCCESS;               
        }
        else
            goto FnExit;
    }

    //
    //  If we are dealing with the mixed mode cluster then dont set the arbitration
    //  timeouts
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ((CLUSTER_GET_MAJOR_VERSION(dwClusterHighestVersion) < NT51_MAJOR_VERSION ))
    {
        //
        // This is a mixed mode cluster, send the old gum message.
        //
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                               FmUpdateChangeQuorumResource,
                               3,
                               resourceIdLen,
                               gumResource,
                               (lstrlenW(szQuoLogPath) + 1 ) * sizeof(WCHAR),
                               szQuoLogPath,
                               sizeof(DWORD),
                               &dwMaxQuorumLogSize
                               );
    }
    else
    {
        DWORD               dwArbTimeout;
        CLUSPROP_DWORD      ClusPropArbTimeout;
      
        // Read and set the new arbitration timeout
        status = FmResourceTypeControl(OmObjectId(Resource->Type), NULL, CLUSCTL_RESOURCE_TYPE_GET_ARB_TIMEOUT,
            NULL, 0, (CHAR *)&ClusPropArbTimeout, sizeof(ClusPropArbTimeout), &dwBytesReturned, &dwRequired);
        if ( status != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: couldnt get RESTYPE arbitration timeout, defaulting to 60 seconds. Status = %1!u!\n", 
               status);
            dwArbTimeout = CLUSTER_QUORUM_DEFAULT_ARBITRATION_TIMEOUT; 
            //map to success, since we dont want to fail the request in this case
            status = ERROR_SUCCESS;               
        } else {
            dwArbTimeout = ClusPropArbTimeout.dw;
        }
     
        ClRtlLogPrint(LOG_NOISE,
           "[FM] FmSetQuorumResource: setting arbitration timeout to %1!u! seconds.\n", dwArbTimeout );
        
        //
        // Send the message.
        //
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                               FmUpdateChangeQuorumResource2,
                               5,
                               resourceIdLen,
                               gumResource,
                               (lstrlenW(szQuoLogPath) + 1 ) * sizeof(WCHAR),
                               szQuoLogPath,
                               sizeof(DWORD),
                               &dwMaxQuorumLogSize,
                               sizeof(DWORD),
                               &dwArbTimeout,
                               sizeof(DWORD),
                               &dwCharacteristics
                               );
    }                           

    //if the old path is not the same as the new path
    //create a tombstone for the quorum log files on the old path
    //this is to prevent nodes that are not present in this update
    //from doing a form.
    if ( (status == ERROR_SUCCESS) &&
         (lstrcmpiW(szQuoLogPath, pszOldQuoLogPath)) ) {
        //
        // delete the old quorum log files on the old resource and create a tombstone file
        // in there.
        //
        if ( pOldQuoResource->Group->OwnerNode != NmLocalNode ) {
            status = FmcCompleteQuorumResChange( pOldQuoResource, pszOldQuoLogPath );
        } else {
            status = FmpCompleteQuorumResChange( OmObjectId(pOldQuoResource), pszOldQuoLogPath );
        }

    }
       
FnExit:
    //not the order of release is not important
    FmpReleaseLocalGroupLock(pOldQuoResource->Group);
    FmpReleaseLocalGroupLock(Resource->Group);
    RELEASE_LOCK(gQuoChangeLock);
    
    if (pBuf) LocalFree(pBuf);
    if (gumResource) LocalFree(gumResource);
    if (pOldQuoResource) OmDereferenceObject(pOldQuoResource);
    if (pszOldQuoLogPath) LocalFree(pszOldQuoLogPath);
    if (pszExpClusFileRootPath) LocalFree(pszExpClusFileRootPath);
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmSetQuorumResource: Exit, status=%1!u!\r\n",
               status);
    
    return(status);

} // FmSetQuorumResource


DWORD
FmCreateResourceType(
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Issues a GUM update to instantiate a resource type on every
    node. The registry update as well as the FM in-memory state
    update is done as a transaction within the GUM handler (NT5
    clusters only).

Arguments:

    lpszTypeName - Supplies the name of the new cluster resource type.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators.

    lpszDllName - Supplies the name of the new resource types DLL.

    dwLooksAlive - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlive - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.   

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    PFM_RESTYPE pResType = NULL;
    DWORD       dwTypeNameLen;
    DWORD       dwDisplayNameLen;
    DWORD       dwDllNameLen;
    DWORD       dwBufferLen;
    LPVOID      Buffer = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  Rewrite this API to use a GUM handler which performs a local 
    //  transaction for NT5.1
    //
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmCreateResourceType: Entry for %1!ws!...\r\n",
               lpszTypeName);

    //
    //  If the resource type already exists, do not issue a GUM and have it fail.
    //
    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      lpszTypeName );
    if ( pResType )
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        OmDereferenceObject( pResType );
        goto FnExit;
    }

    dwTypeNameLen = ( lstrlenW( lpszTypeName ) + 1 ) * sizeof( WCHAR );
    dwDisplayNameLen = ( lstrlenW( lpszDisplayName ) + 1 ) * sizeof( WCHAR );
    dwDllNameLen = ( lstrlenW( lpszDllName ) + 1 ) * sizeof( WCHAR );
    dwBufferLen = dwTypeNameLen + dwDisplayNameLen + dwDllNameLen +
                         2 * sizeof( DWORD );

    Buffer = LocalAlloc( LMEM_FIXED, dwBufferLen );

    if ( Buffer == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmCreateResourceType: FmUpdateCreateResourceType for %1!ws! returned %2!u! on mem alloc...\n",
                    lpszTypeName,
                    dwStatus);
        goto FnExit;
    }

    CopyMemory( Buffer, lpszTypeName, dwTypeNameLen );
    CopyMemory( ( PCHAR ) Buffer + dwTypeNameLen, lpszDisplayName, dwDisplayNameLen );
    CopyMemory( ( PCHAR ) Buffer + dwTypeNameLen + dwDisplayNameLen, lpszDllName, dwDllNameLen );
    CopyMemory( ( PCHAR ) Buffer + 
                dwTypeNameLen + 
                dwDisplayNameLen + 
                dwDllNameLen, &dwLooksAlive, sizeof( DWORD ) );
    CopyMemory( ( PCHAR ) Buffer + 
                dwTypeNameLen + 
                dwDisplayNameLen + 
                dwDllNameLen + sizeof( DWORD ), &dwIsAlive, sizeof( DWORD ) );
              
    dwStatus = GumSendUpdate( GumUpdateFailoverManager,
                              FmUpdateCreateResourceType,
                              dwBufferLen,
                              Buffer );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmCreateResourceType: FmUpdateCreateResourceType for %1!ws! returned %2!u!...\r\n",
                    lpszTypeName,
                    dwStatus);
        goto FnExit;
    }

    dwStatus = FmpSetPossibleNodeForResType( lpszTypeName , FALSE );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmCreateResourceType: FmpSetPossibleNodeForResType for %2!ws! returned <%1!u!>...\r\n",
                    lpszTypeName,
                    dwStatus);
        goto FnExit;
    }

    pResType = OmReferenceObjectById( ObjectTypeResType, lpszTypeName );

    if ( pResType )
    {
        ClusterWideEvent( CLUSTER_EVENT_RESTYPE_ADDED, pResType );
        OmDereferenceObject( pResType );
    } else
    {
        if ( !FmpFMGroupsInited )
        {
            dwStatus = ERROR_CLUSTER_NODE_NOT_READY;
        } else if ( FmpShutdown )
        {
            dwStatus = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
        } else
        {
            dwStatus = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        }
    }
    
FnExit:
    LocalFree( Buffer );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmCreateResourceType: Exit for %1!ws!, Status=%2!u!...\r\n",
               lpszTypeName,
               dwStatus);
    
    return( dwStatus );   
} // FmCreateResourceType



DWORD
FmDeleteResourceType(
    IN LPCWSTR TypeName
    )
/*++

Routine Description:

    Issues a GUM update to delete a resource type on every
    node.

Arguments:

    TypeName - Supplies the name of the cluster resource type
        to delete

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PFM_RESTYPE     pResType;
    BOOL            fResourceExists = FALSE;

    //
    //  Chittur Subbaraman (chitturs) - 5/9/2001
    //  
    //  Make sure the resource type exists so that you can avoid a GUM if 
    //  that is not necessary. This also takes care of the case in which one node was
    //  shutting down and so the GUM returns success and another node fails in the GUM
    //  and gets evicted since the resource type does not exist.
    //
    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      TypeName );

    if ( pResType == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[FM] FmDeleteResourceType: Resource type %1!ws! does not exist...\n",
                      TypeName);
        return( ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND );
    }

    //
    //  Check if any resources of this type exist, we do this to avoid a GUM since at shutdown
    //  or startup we return ERROR_SUCCESS from the common GUM handler and that triggers
    //  the deletion of the type from the cluster database. Ideally, we should have made the
    //  API transactional and do this check inside GUM but for lack of time, this is the best 
    //  we can do now.
    //
    OmEnumObjects( ObjectTypeResource,
                   FmpFindResourceType,
                   pResType,
                   &fResourceExists );

    if ( fResourceExists ) 
    {
        OmDereferenceObject ( pResType );
        return ( ERROR_DIR_NOT_EMPTY );
    }

    OmDereferenceObject ( pResType );
    
    return(GumSendUpdate( GumUpdateFailoverManager,
                          FmUpdateDeleteResourceType,
                          (lstrlenW(TypeName)+1)*sizeof(WCHAR),
                          (PVOID)TypeName ));
} // FmDeleteResourceType

/****
@func       DWORD | FmEnumResTypeNode | Enumerate the possible nodes for
            a resource type

@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type
@parm       IN DWORD | dwIndex | The index for this enumeration.
@parm       OUT PNM_NODE | pPossibleNode | The possible node. The returned node
            pointer will be referenced by this routine and should
            be dereferenced when the caller is done with it.

@comm       This routine helps enumerating all the nodes that a particular
            resource type can be supported on.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       
****/
DWORD
FmEnumResourceTypeNode(
    IN  PFM_RESTYPE  pResType,
    IN  DWORD        dwIndex,
    OUT PNM_NODE     *pPossibleNode
    )
{
    PLIST_ENTRY pListEntry;
    DWORD i = 0;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
    DWORD Status = ERROR_NO_MORE_ITEMS;

    FmpMustBeOnline();

    // 
    // Chittur Subbaraman (chitturs) - 09/06/98
    //
    // The creation and deletion of resource types are done
    // via atomic GUM operations. Hence these two operations
    // (i.e. API's) are guaranteed to be mutually exclusive.
    // In contrast, the resource type enumeration operation
    // is not mutually exclusive with either the create
    // or the delete operation. Thus, when a resource type is
    // being created/deleted, there is nothing that prevents a 
    // client from trying to enumerate the same resource type 
    // in a concurrent fashion, thus producing a potential race
    // condition. Thus, it is advisable to consider some form 
    // of locking to avoid this situation !
    //
    
    // update the list to include all nodes that now support 
    // the resource type
    if (dwIndex == 0) 
        FmpSetPossibleNodeForResType(OmObjectId(pResType), TRUE);

    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = pResType->PossibleNodeList.Flink;
    while (pListEntry != &pResType->PossibleNodeList) {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry,
                                          RESTYPE_POSSIBLE_ENTRY,
                                          PossibleLinkage);
        if (i==dwIndex) {
            //
            // Got the right index
            //
            OmReferenceObject(pResTypePosEntry->PossibleNode);
            *pPossibleNode = pResTypePosEntry->PossibleNode;
            Status = ERROR_SUCCESS;
            break;
        }
        pListEntry = pListEntry->Flink;
        ++i;
    }

    RELEASE_LOCK(gResTypeLock);

    return(Status);

} // FmEnumResTypeNode


DWORD
FmChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    Resource - Supplies the resource to move.

    Group - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD               dwStatus;
    PFM_GROUP           pOldGroup;
    
    FmpMustBeOnline( );
  
    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeResourceGroup : Resource <%1!ws!> NewGroup %2!lx!\n",
       OmObjectId( pResource ),
       OmObjectId( pNewGroup));

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pResource->Group ), OmObjectId( pNewGroup ) ) <= 0 ) {
        FmpAcquireLocalGroupLock( pResource->Group );
        FmpAcquireLocalGroupLock( pNewGroup );
    } else {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pResource->Group );
    }


    //remember the old group for freeing locks
    pOldGroup = pResource->Group;
    
    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnUnlock;
    }

    
    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnUnlock;
    }


    if ( pResource->Group->OwnerNode != NmLocalNode ) {
        // Note: FmcChangeResourceNode must release the both resource lock.
        dwStatus = FmcChangeResourceGroup( pResource, pNewGroup);
        goto FnExit;
    } 
    else 
    {
        dwStatus = FmpChangeResourceGroup(pResource, pNewGroup );
    }


FnUnlock:
    FmpReleaseLocalGroupLock(pNewGroup);
    FmpReleaseLocalGroupLock(pOldGroup);
FnExit:
    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeResourceGroup : returned <%1!u!>\r\n",
       dwStatus);
    return(dwStatus);

} // FmChangeResourceGroup


DWORD
FmChangeClusterName(
    IN LPCWSTR pszNewName,
    IN LPCWSTR pszOldName
    )
/*++

Routine Description:

    Changes the name of the cluster

Arguments:

    pszNewName - Supplies the new cluster name.
    lpszOldName - Supplies the current name

Return Value:

    ERROR_SUCCESS if successful. ERROR_RESOURCE_PROPERTIES STORED if the name
    has been changed but wont be effective until the core network name resource
    is brought online again.

    Win32 error code otherwise

--*/

{
    DWORD           dwStatus=ERROR_INVALID_PARAMETER;
    BOOL            bNameUpdated = FALSE;  
    PFM_RESOURCE    pCoreNetNameResource = NULL;
    PVOID           pPropList = NULL;
    DWORD           dwPropListSize = 0;
    LPWSTR          pszBuffer;
    DWORD           dwLength;
    DWORD           dwClusterHighestVersion;

    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeClusterName : Entry NewName=%1!ws! OldName=%2!ws!\r\n",
       pszNewName, pszOldName);

    //get all the info to be able to change the name
    dwStatus = FmpGetClusterNameChangeParams(pszNewName, &pCoreNetNameResource, 
                    &pPropList, &dwPropListSize);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmChangeClusterName : Failed to prepare params to set new name, Status=%1!u!\r\n",
            dwStatus);
        goto FnExit;            
    }

                           
    //first validate the name
    dwStatus = FmpValidateCoreNetNameChange( pCoreNetNameResource, pPropList,
        dwPropListSize);
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmChangeClusterName : Failed validate the name, Status=%1!u!\r\n",
            dwStatus);
        goto FnExit;            
    }


    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateChangeClusterName,
                             1,
                             (lstrlenW(pszNewName)+1)*sizeof(WCHAR),
                             pszNewName);

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmChangeClusterName : GumUpdate to set new name failed with staus=%1!u!\r\n",
            dwStatus);
        goto FnExit;            
        
    }

    bNameUpdated = TRUE;
    //Now notify the resource dll of the  change via the set private properties call
    //the resource dll will try to commit the change, if it fails it will undo the change
    //and return failure
    //SS : what if it not online
    dwStatus = FmpCoreNetNameChange(pCoreNetNameResource, pPropList, dwPropListSize);

    //the core network name property/cluster name has been set
    //but the name change isnt effective till the resource is brought
    //offline and then online again, the netname dll is expected to return the correct error
    //ie we dont do any mapping
    if ((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_RESOURCE_PROPERTIES_STORED))
    {
        //if the resource properties have been stored or have been handled
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmChangeClusterName : FmpCoreNetNameChange failed status=%1!u!\r\n",
            dwStatus);
        goto FnExit;        
    }

    //the name change was successful generate the event notifications
    //ignore the errors caused due to notifications, it is hard enough to 
    //recover from changes spanning the service and netname that at this point
    //we wont bother with event notification problems
    //dont issue the event notification in a mixed mode cluster..a bug in win2K
    //cluster wide notification might result in an av
    //
    //  If we are dealing with the mixed mode cluster or if the group does not have the antiaffinity
    //  property set, then don't do anything.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < NT51_MAJOR_VERSION ))
    {
        //there is a lower version(lower than whistler) node in the cluster
        //we could issue a local event here but that doesnt help if the 
        //cluster has more than two nodes..who would issue the event on other
        //whistler nodes?
        goto FnExit;
    }
    else
    {
        ClusterWideEventEx(CLUSTER_EVENT_PROPERTY_CHANGE, EP_CONTEXT_VALID|EP_FREE_CONTEXT, (PVOID)pszNewName,
                   ((lstrlenW(pszNewName) + 1) * sizeof(WCHAR)));
    }
   
FnExit:
    if (((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_RESOURCE_PROPERTIES_STORED))
            && (bNameUpdated))
    {
        DWORD dwError;
        
        //we need to revert the change, netname doesnt like it
        //and doesnt return success or properties stored.
        //netname should not set the registry to revert to the old name
        //it should leave that to FM
        //If the locker fails to revert it back(hopefully that doesnt happen
        //often, then the admin needs to fix the problem since now we will 
        //have a new cluster name that perhaps wont ever come online
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmChangeClusterName : Making the GumUpdate to revert to old name.\r\n");
        
        dwError = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateChangeClusterName,
                             1,
                             (lstrlenW(pszOldName)+1)*sizeof(WCHAR),
                             pszOldName);

        if (dwError != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmChangeClusterName : GumUpdate to revert to old name failed, status=%1!u!\r\n",
                dwError);
            //log an ominous message in the event log to say the network name
            //change didnt happen successfully but the name has been changed and this might require administrative
            //action to fix the problems
            CL_LOGCLUSWARNING(SERVICE_NETNAME_CHANGE_WARNING);
        }
    }

    if (pCoreNetNameResource)
        OmDereferenceObject(pCoreNetNameResource);
    if (pPropList)
        LocalFree(pPropList);
        
    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmChangeClusterName : Exit dwStatus=%1!u!\r\n",
       dwStatus);
    
    return(dwStatus);

} // FmChangeClusterName




DWORD
FmpSetResourceName(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      lpszFriendlyName
    )

/*++

Routine Description:

    Updates the resource name consistently in the fm databases across
    the cluster.

Arguments:

    pResource - The resource whose name is changed.

    lpszFriendlyName - The new name of the resource.


Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPCWSTR ResourceId;
    DWORD Status;

    ResourceId = OmObjectId(pResource);

    return(GumSendUpdateEx( GumUpdateFailoverManager,
                            FmUpdateChangeResourceName,
                            2,
                            (lstrlenW(ResourceId)+1)*sizeof(WCHAR),
                            ResourceId,
                            (lstrlenW(lpszFriendlyName)+1)*sizeof(WCHAR),
                            lpszFriendlyName ));

} // FmpSetResourceName




DWORD
FmpRegUpdateClusterName(
    IN LPCWSTR szNewClusterName
    )

/*++

Routine Description:

    This routine updates the cluster name in the cluster database.

Arguments:

    szNewClusterName - A pointer to the new cluster name string.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{

    return(DmSetValue( DmClusterParametersKey,
                       CLUSREG_NAME_CLUS_NAME,
                       REG_SZ,
                       (CONST BYTE *)szNewClusterName,
                       (lstrlenW(szNewClusterName)+1)*sizeof(WCHAR) ));

} // FmpRegUpdateClusterName



DWORD
FmEvictNode(
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Removes any references to the specified node that the FM might
    have put on.

Arguments:

    Node - Supplies the node that is being evicted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    //add a reference to the node object, the worker thread will remove this
    OmReferenceObject(Node);
    FmpPostWorkItem(FM_EVENT_NODE_EVICTED,
                    Node,
                    0);


    return(ERROR_SUCCESS);

} // FmEvictNode



BOOL
FmCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    )

/*++

Routine Description:

    Check if any IP Address resource has a dependency on a given network.

Arguments:

    DependentNetwork - the GUID for the network to check.

Return Value:

    TRUE - if an IP Address resource depends on the given network.
    FALSE otherwise.

--*/

{

    return( FmpCheckNetworkDependency( DependentNetwork ) );

} // FmCheckNetworkDependency

DWORD
WINAPI
FmBackupClusterDatabase(
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    Attempts a backup of the quorum log files.
    
Arguments:

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PFM_RESOURCE    pQuoResource = NULL;

    FmpMustBeOnline( ); 

    //
    //  Chittur Subbaraman (chitturs) - 10/12/98
    //
    //  Find the quorum resource
    //
    status  =  FmFindQuorumResource( &pQuoResource );
    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmBackupQuorumLog: Could not find quorum resource...\r\n");
        goto FnExit;
    }
    // 
    //  Acquire the local resource lock
    //
    FmpAcquireLocalResourceLock( pQuoResource );
    
    //
    //  Handle the request here if this node is the owner of the
    //  quorum resource, else redirect it to the appropriate node.
    //
    if ( pQuoResource->Group->OwnerNode != NmLocalNode ) 
    {
        // 
        //  This function will release the resource lock
        //
        status = FmcBackupClusterDatabase( pQuoResource, lpszPathName );
    } else 
    {
        status = FmpBackupClusterDatabase( pQuoResource, lpszPathName );
        FmpReleaseLocalResourceLock( pQuoResource );
    }

    OmDereferenceObject ( pQuoResource );

FnExit:
    return( status );
} // FmBackupClusterDatabase

DWORD
FmpBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    This routine first waits until the quorum resource becomes
    online. Then, it attempts to backup the quorum log file and the
    checkpoint file to the specified directory path. This function
    is called with the local resource lock held.

Arguments:

    pQuoResource - Pointer to the quorum resource.

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Comments:

    The order in which the locks are acquired is very crucial here.
    Carelessness in following this strict order of acquisition can lead 
    to potential deadlocks. The order that is followed is
        (1) Local resource lock - pQuoResource->Group->Lock acquired 
            outside this function.
        (2) Global quorum resource lock - gQuoLock acquired here
        (3) Global Dm root lock - gLockDmpRoot acquired in 
            DmBackupClusterDatabase( ).

--*/

{
    DWORD   retry = 200;
    DWORD   Status = ERROR_SUCCESS;

    CL_ASSERT( pQuoResource->Group->OwnerNode == NmLocalNode );

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //  
    //  If quorum logging is not turned on, then log an error
    //  and exit immediately.
    //
    if ( CsNoQuorumLogging )
    {        
        Status = ERROR_QUORUMLOG_OPEN_FAILED;
        CL_LOGFAILURE( ERROR_QUORUMLOG_OPEN_FAILED );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Quorum logging is not turned on, can't backup...\r\n");
        goto FnExit;
    }

CheckQuorumState:
    ACQUIRE_EXCLUSIVE_LOCK( gQuoLock );
    //
    //  Check the state of the quorum resource. If it has failed or is
    //  offline, release the lock and exit immediately !
    //
    if ( pQuoResource->State == ClusterResourceFailed )
    {
        Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
        CL_LOGFAILURE( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Quorum resource is in failed state, exiting...\r\n");
        RELEASE_LOCK( gQuoLock );
        goto FnExit;
    }

    //
    //  Check if the quorum resource is online. If the quorum resource 
    //  is marked as waiting and offlinepending, it is actually online.
    //  If the quorum resource still needs to come online, release the 
    //  lock and wait.
    //
    if ( ( ( pQuoResource->State != ClusterResourceOnline ) &&
          ( ( pQuoResource->State != ClusterResourceOfflinePending ) ||
           ( !( pQuoResource->Flags & RESOURCE_WAITING ) ) ) )
            ) 
    {
        //
        //  We release the lock here since the quorum resource
        //  state transition from pending needs to acquire the lock.
        //  In general it is a bad idea to do a wait holding locks.
        //
        RELEASE_LOCK( gQuoLock );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: Release ghQuoLock and wait on ghQuoOnlineEvent...\r\n");
        Status = WaitForSingleObject( ghQuoOnlineEvent, 500 );
        if ( Status == WAIT_OBJECT_0 ) 
        {
            //
            //  If we are going to retry, wait a little bit and retry.
            //
            Sleep( 500 );
        }
        if ( retry-- ) 
        {
            goto CheckQuorumState;
        }

        CL_LOGFAILURE( ERROR_QUORUM_RESOURCE_ONLINE_FAILED ) ;
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpBackupClusterDatabase: All retries to check for quorum resource online failed, exiting...\r\n");
        return( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );
    }
    
    Status = DmBackupClusterDatabase( lpszPathName ); 
    
    RELEASE_LOCK( gQuoLock );
FnExit:
    return ( Status );
} // FmpBackupClusterDatabase



/****
@func       WORD| FmCheckQuorumState| If the quorum resource is online
            on this node right now, it calls the callback and the boolean
            value passed in is set to FALSE.  If not, the boolean is 
            set to TRUE.

@parm       LPWSTR | szQuorumLogPath | A pointer to a wide string of size MAX_PATH.
@parm       DWORD | dwSize | The size of szQuorumLogPath in bytes.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
void FmCheckQuorumState(
    FM_ONLINE_ONTHISNODE_CB OnlineOnThisNodeCb, 
    PBOOL pbOfflineOnThisNode)
{
    BOOL    bLocked = FALSE;
    DWORD   dwRetryCount = 1200; // Wait 10 min max
    
    // 
    // SS: The mutual exclusion between this event handler and
    // the synchronous resource online/offline callback is 
    // achieved by using the quorum change lock(gQuoChangeLock)
    //

    //
    // Chittur Subbaraman (chitturs) - 7/5/99
    // 
    // Modify group lock acquisition to release gQuoChangeLock and 
    // retry lock acquisition. This is necessary to take care of the
    // case in which the quorum online notification is stuck in
    // FmpHandleResourceTransition waiting for the gQuoChangeLock and
    // some other resource in the quorum group is stuck in FmpRmOnlineResource
    // holding the quorum group lock and waiting for the quorum resource
    // to go online.
    //
try_acquire_lock:

    ACQUIRE_EXCLUSIVE_LOCK( gQuoChangeLock );

    FmpTryAcquireLocalGroupLock( gpQuoResource->Group, bLocked );

    if ( bLocked == FALSE )
    {
        RELEASE_LOCK( gQuoChangeLock );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - Release gQuoChangeLock, sleep and retry group lock acquisition...\r\n");
        if ( dwRetryCount == 0 )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmCheckQuorumState - Unable to get quorum group lock for 10 min, halting...\r\n");
            CsInconsistencyHalt( ERROR_LOCK_FAILED );
        }
        dwRetryCount --;
        Sleep( 500 );
        goto try_acquire_lock;
    }

    CL_ASSERT( bLocked == TRUE );

    *pbOfflineOnThisNode = FALSE;
    if (gpQuoResource->Group->OwnerNode == NmLocalNode)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - I am owner, check the state of the resource .\r\n");

        //if the quorum resource is not online right now
        //it might be in the middle of a move and this node
        //might be the target of the move 
        //set a flag to indicate that a checkpoint is necessary
        //when it does come online
        if(gpQuoResource->State != ClusterResourceOnline)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmCheckQuorumState - Quorum is owned but not online on this node.\r\n");
            *pbOfflineOnThisNode = TRUE;
        }
        else
        {
            (*OnlineOnThisNodeCb)();
        }
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmCheckQuorumState - Quorum is owned by another node.\r\n");
        *pbOfflineOnThisNode = TRUE;
    }

    FmpReleaseLocalGroupLock(gpQuoResource->Group);
    
    RELEASE_LOCK(gQuoChangeLock);            
}

/****
@func       WORD| FmDoesQuorumAllowJoin| If the quorum resource doesnt support
            multiple nodes, return error.  Added to officially support local quorum resources.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD FmDoesQuorumAllowJoin(
    IN PCWSTR pszJoinerNodeId )
{


    DWORD dwStatus = ERROR_SUCCESS;

    ACQUIRE_SHARED_LOCK(gQuoChangeLock);

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowJoin - Entry\r\n");

    //get the characteristics for the new quorum resource
    dwStatus = FmpGetResourceCharacteristics(gpQuoResource, 
                    &(gpQuoResource->Characteristic));
    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[FM] FmDoesQuorumAllowJoin - couldnt get quorum characteristics %1!u!\r\n",
            dwStatus);
        goto FnExit;
    }

    if ((gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM) &&
        !(gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM_DEBUG))
    {
        //Note :: we need an error code?
        dwStatus = ERROR_OPERATION_ABORTED;    
        goto FnExit;
    }

    // JAF: RAID 513705: if a site is being started with ForceQuorum, and a 2nd site
    // comes online automatically after, e.g., a power failure, they will attempt to join 
    // and will have a different idea of what constitutes a majority.
    // Do not allow them to join if ForceQuorum is true.
    if ( CsForceQuorum && ( CsForceQuorumNodes != NULL ))
    {
        if ( !FmpIsNodeInForceQuorumNodes( pszJoinerNodeId ))
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] Disallowing join of %1!ws! since it is not in the list of forceQuorum nodes.\n",
                pszJoinerNodeId );
            dwStatus = ERROR_OPERATION_ABORTED;
            goto FnExit;
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] Node %1!ws! is in the list of forceQuorum nodes; allowing join to proceed.\n",
                pszJoinerNodeId );
        }
    }
    

FnExit:    
    RELEASE_LOCK(gQuoChangeLock);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowJoin - Exit, Status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}


/****
@func       WORD| FmDoesQuorumAllowLogging| If the quorum resource doesnt support
            multiple nodes, return error.  Added to officially support local quorum resources.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       If the quorum resource is not cabaple of logging this should not be set.
@xref
****/
DWORD FmDoesQuorumAllowLogging(
    IN DWORD dwQuorumResourceCharacteristics    OPTIONAL
    )
{

    DWORD dwStatus = ERROR_SUCCESS;

    ACQUIRE_SHARED_LOCK(gQuoChangeLock);

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowLogging - Entry\r\n");

    if ( dwQuorumResourceCharacteristics == CLUS_CHAR_UNKNOWN )
    {
        //get the characteristics for the new quorum resource
        dwStatus = FmpGetResourceCharacteristics(gpQuoResource, 
                        &(gpQuoResource->Characteristic));
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmDoesQuorumAllowLogging - couldnt get quorum characteristics %1!u!\r\n",
                dwStatus);
            goto FnExit;            
        }
    } else
    {
        gpQuoResource->Characteristic = dwQuorumResourceCharacteristics;
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmDoesQuorumAllowLogging - Using passed in characteristics 0x%1!08lx!\n",
                      dwQuorumResourceCharacteristics);
    }
    
    if (gpQuoResource->Characteristic & CLUS_CHAR_LOCAL_QUORUM) 
    {
        WCHAR szQuorumFileName[MAX_PATH];
        
        //Note :: we need an error code?
        //if the path is an smb path name, we should allow logging
        //else we should disable it
        dwStatus = DmGetQuorumLogPath(szQuorumFileName, sizeof(szQuorumFileName));
        if ((szQuorumFileName[0] == L'\\') && (szQuorumFileName[1] == L'\\'))
        {
            //assume this is an smb path
            //allow logging
            dwStatus = ERROR_SUCCESS;
        }
        else
        {
            dwStatus = ERROR_OPERATION_ABORTED;    
        }            
    }


FnExit:    
    RELEASE_LOCK(gQuoChangeLock);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmDoesQuorumAllowLogging - Exit, status=%1!u!\r\n",
        dwStatus);

    return(dwStatus);
}

DWORD
FmpCanonicalizePath(
    IN OUT LPWSTR lpszPath,
    OUT PBOOL pfIsPathUNC
    )

/*++

Routine Description:

    This routine converts a path of the form \\xyz\share to \\?\UNC\xyz\share.

Arguments:

    lpszPathName - The path that must be converted.

    pfIsPathUNC - Is the path of UNC type.

Return value:

    None.

--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    WCHAR       szUNC[] = L"\\\\?\\UNC\\";
    WCHAR       szSlash[] = L"\\\\";
    WCHAR       szTempPath[MAX_PATH];
    LPCWSTR     lpszUNCStart, lpszSlashStart;

    //
    //  Optimistically assume it is a UNC path. If it is not a UNC path, we set it back to
    //  FALSE. In a failure case, we don't care about the value of the boolean variable.
    //
    *pfIsPathUNC = TRUE;

    //
    //  First check if the path starts with a "\\". If not, you are done.
    //
    lpszSlashStart = wcsstr( lpszPath, szSlash );

    if ( lpszSlashStart == NULL )
    {
        *pfIsPathUNC = FALSE;
        goto FnExit;
    } 

    //
    //  Next, make sure there are not more than 2 slashes any where in the path except at
    //  the start.
    //
    lpszSlashStart = wcsstr( lpszPath+1, szSlash );

    if ( lpszSlashStart != NULL )
    {
        ClRtlLogPrint(LOG_ERROR, "[FM] FmpCanonicalizePath: Supplied path %1!ws! is invalid...\n",
                      lpszPath);
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;       
    }

    //
    //  Next, check if the path already has UNC at the beginning. If so, you are done.
    //
    lpszUNCStart = wcsstr( lpszPath, szUNC );

    if ( lpszUNCStart != NULL ) 
    {
        if ( lpszUNCStart != lpszPath ) 
        {
            ClRtlLogPrint(LOG_ERROR, "[FM] FmpCanonicalizePath: Supplied path %1!ws! is invalid...\n",
                          lpszPath);
            dwStatus = ERROR_INVALID_PARAMETER;
        }
        goto FnExit;
    }

    lstrcpy( szTempPath, szUNC );
    lstrcat( szTempPath, lpszPath+2 );
    lstrcpy( lpszPath, szTempPath );
   
FnExit:
    ClRtlLogPrint(LOG_NOISE, "[FM] FmpCanonicalizePath: Exit Status %1!u!, Return path = %2!ws!\n",
                  dwStatus,
                  lpszPath);
    return ( dwStatus );
} // FmpCanonicalizePath


DWORD FmpGetClusterNameChangeParams(
    IN  LPCWSTR          lpszNewName,
    OUT PFM_RESOURCE    *ppCoreNetNameResource,
    OUT PVOID           *ppPropList,
    OUT LPDWORD         pdwPropListSize   
    )
{

    PFM_RESOURCE            pResource = NULL;
    DWORD                   dwSize = 0;
    DWORD                   dwStatus;
    LPWSTR                  lpszClusterNameResource = NULL;        
    CLUSPROP_BUFFER_HELPER  ListEntry;
    PVOID                   pPropList = NULL;
    DWORD                   cbListSize = 0;
    DWORD                   dwBufferSize;

    //initialize the returns
    *ppCoreNetNameResource = NULL;
    *pdwPropListSize = 0;
    *ppPropList = NULL;
    

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpGetClusterNameChangeParams: Entry !\n");
  
    dwStatus = DmQuerySz( DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                          &lpszClusterNameResource,
                          &dwSize,
                          &dwSize );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpGetClusterNameChangeParams: Failed to get cluster name resource from registry, error %1!u!...\n",
            dwStatus);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, 
                                       lpszClusterNameResource );

    if ( pResource == NULL ) 
    {
        dwStatus =  ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmGetClusterNameChangeParams: Failed to find cluster name resource, %1!u!...\n",
                   dwStatus);
        goto FnExit;
    }

    dwBufferSize = sizeof( ListEntry.pList->nPropertyCount ) +
                   sizeof( *ListEntry.pName ) + 
                        ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_NET_NAME ) + 1 ) * sizeof( WCHAR ) ) +
                   sizeof( *ListEntry.pStringValue ) + 
                        ALIGN_CLUSPROP( ( lstrlenW( lpszNewName ) + 1 ) * sizeof( WCHAR ) ) +
                   sizeof( *ListEntry.pSyntax );
                   
    ListEntry.pb = (PBYTE) LocalAlloc( LPTR, dwBufferSize );

    if ( ListEntry.pb == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmGetClusterNameChangeParams: Error %1!u! in allocating memory...\n",
                   dwStatus);
        goto FnExit;
    }

    pPropList = ListEntry.pb;

    ListEntry.pList->nPropertyCount = 1;  
    cbListSize += sizeof( ListEntry.pList->nPropertyCount );            
    ListEntry.pb += sizeof( ListEntry.pList->nPropertyCount );

    ListEntry.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
    ListEntry.pName->cbLength  = ( lstrlenW( CLUSREG_NAME_NET_NAME ) + 1 ) * sizeof( WCHAR );
    lstrcpyW( ListEntry.pName->sz, CLUSREG_NAME_NET_NAME );
    cbListSize += sizeof( *ListEntry.pName ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );
    ListEntry.pb += sizeof( *ListEntry.pName ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );

    ListEntry.pStringValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_SZ;
    ListEntry.pStringValue->cbLength  = ( lstrlenW( lpszNewName ) + 1 ) * sizeof( WCHAR );    
    lstrcpyW( ListEntry.pStringValue->sz, lpszNewName );
    cbListSize += sizeof( *ListEntry.pStringValue ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );
    ListEntry.pb += sizeof( *ListEntry.pStringValue ) + ALIGN_CLUSPROP( ListEntry.pName->cbLength );

    ListEntry.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
    cbListSize   += sizeof( *ListEntry.pSyntax );
    ListEntry.pb += sizeof( *ListEntry.pSyntax );



    *ppCoreNetNameResource = pResource;
    *ppPropList = pPropList;
    *pdwPropListSize = dwBufferSize;

FnExit:
    if (lpszClusterNameResource) 
        LocalFree(lpszClusterNameResource);
    if (dwStatus != ERROR_SUCCESS)
    {
        if (pResource) OmDereferenceObject(pResource);
        if (pPropList) LocalFree(pPropList);
    }
    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpGetClusterNameChangeParams: Exit !\n");
    
    return(dwStatus);
}




/****
@func       DWORD| FmpValideCoreNetNameChange| Send a control code to the core
            netname resource to validate the change.

@param      IN PFM_RESOURCE | pResource | A pointer to the  core netname resource.

@param      IN PVOID | pPropList | Pointer to a property list.

@param      IN DWORD | cbListSize | Size of the property list.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       
@xref
****/
DWORD FmpValidateCoreNetNameChange(
    IN PFM_RESOURCE pResource, 
    IN PVOID pPropList,
    IN DWORD cbListSize
    )
{
    DWORD   dwBytesReturned;
    DWORD   dwRequired;
    DWORD   dwStatus;

    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmpValidateCoreNetNameChange : Calling Core netname to validate\r\n");
    
    dwStatus = FmResourceControl( pResource, 
                                  NULL, 
                                  CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES, 
                                  (PUCHAR)pPropList, 
                                  cbListSize,
                                  NULL, 
                                  0, 
                                  &dwBytesReturned, 
                                  &dwRequired );
    return(dwStatus);                                  

}

/****
@func       WORD| FmCoreNetNameChange| Asks the core network name resource
            to perform all the network name change related operations.

@param      IN PFM_RESOURCE | pResource | A pointer to the  core netname resource.

@param      IN PVOID | pPropList | Pointer to a property list.

@param      IN DWORD | cbListSize | Size of the property list.

@rdesc      Returns ERROR_SUCCESS for success, else returns the error code.

@comm       
@xref
****/
DWORD FmpCoreNetNameChange(
    IN PFM_RESOURCE pResource, 
    IN PVOID pPropList,
    IN DWORD cbListSize
    )
{
    DWORD   dwBytesReturned;
    DWORD   dwRequired;
    DWORD   dwStatus;

    ClRtlLogPrint(LOG_NOISE,
       "[FM] FmpCoreNetNameChange : Invoking the core netname resource dll\r\n");

    dwStatus = FmResourceControl( pResource, 
                                  NULL, 
                                  CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED, 
                                  (PUCHAR)pPropList, 
                                  cbListSize,
                                  NULL, 
                                  0, 
                                  &dwBytesReturned, 
                                  &dwRequired );
    return(dwStatus);                                  

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmgum.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmgum.c

Abstract:

    Cluster FM Global Update processing routines.

Author:

    Rod Gamache (rodga) 24-Apr-1996


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#if NO_SHARED_LOCKS
extern CRITICAL_SECTION gLockDmpRoot;
#else
extern RTL_RESOURCE gLockDmpRoot;
#endif

#define     NODE_ID_SZ  6
#define     LOG_MODULE FMGUM


DWORD
WINAPI
FmpGumReceiveUpdates(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    )

/*++

Routine Description:

    Updates the specified resource (contained within Buffer) with a new
    state.

Arguments:

    Context - The message update type.
    SourceNode - TRUE if this is the source node for this update.
                 FALSE otherwise.
    BufferLength - Length of the received buffer.
    Buffer - The actual buffer

Returns:

    ERROR_SUCCESS

--*/

{
    PFM_RESOURCE resource;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    switch ( Context ) {


        case FmUpdateFailureCount:
        {
            PGUM_FAILURE_COUNT failureCount;
            PFM_GROUP group;

            //
            // This update type is always sent.
            // On the originating node, all of the work must be done by
            // the sending thread.
            // On the non-originating nodes, no locks can be acquired! This
            // would cause hang situations with operations like move.
            // ... this is okay, since the locking must be done on the sending
            // node anyway, which owns the group.
            //
            if ( SourceNode == FALSE ) {
                if ( BufferLength <= sizeof(GUM_FAILURE_COUNT) ) {
                    ClRtlLogPrint(LOG_UNUSUAL, "[FM] Gum FailureCount receive buffer too small!\n");
                    return(ERROR_SUCCESS);
                }

                failureCount = (PGUM_FAILURE_COUNT)Buffer;
                group = OmReferenceObjectById( ObjectTypeGroup,
                                               (LPCWSTR)&failureCount->GroupId[0] );

                if ( group == NULL ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Gum FailureCount failed to find group %1!ws!\n",
                               failureCount->GroupId);
                    return(ERROR_SUCCESS);
                }

                ClRtlLogPrint(LOG_NOISE,
                           "[FM] GUM update failure count %1!ws!, count %2!u!\n",
                           failureCount->GroupId,
                           failureCount->Count);

                //FmpAcquireLocalGroupLock( group );

                if ( group->OwnerNode == NmLocalNode ) {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Gum FailureCount wrong owner for %1!ws!\n",
                               failureCount->GroupId);
                } else {
                    group->NumberOfFailures = failureCount->Count;
                    if ( failureCount->NewTime ) {
                        group->FailureTime = GetTickCount();
                    }
                }

                //FmpReleaseLocalGroupLock( group );

                OmDereferenceObject( group );

            }

            break;
        }

        case FmUpdateCreateGroup:
            {
                PGUM_CREATE_GROUP GumGroup;
                DWORD Status = ERROR_SUCCESS;

                GumGroup = (PGUM_CREATE_GROUP)Buffer;

                Status = FmpUpdateCreateGroup( GumGroup, SourceNode );
                
                return(Status);
            }

        case FmUpdateCreateResource:
            {
                DWORD dwStatus = ERROR_SUCCESS;
                PGUM_CREATE_RESOURCE GumResource = 
                                (PGUM_CREATE_RESOURCE)Buffer;

                dwStatus = FmpUpdateCreateResource( GumResource );

                return( dwStatus );
            }



        case FmUpdateAddPossibleNode:
        case FmUpdateRemovePossibleNode:
            {

                PGUM_CHANGE_POSSIBLE_NODE pGumChange;
                PFM_RESOURCE              pResource;
                LPWSTR                    pszResourceId;
                LPWSTR                    pszNodeId;
                PNM_NODE                  pNode;
                DWORD                     dwStatus;
                DWORD                     dwControlCode;
                PFMP_POSSIBLE_NODE        pPossibleNode;

                pGumChange = (PGUM_CHANGE_POSSIBLE_NODE)Buffer;
                pszResourceId = pGumChange->ResourceId;
                pszNodeId = (LPWSTR)((PCHAR)pszResourceId +
                                         pGumChange->ResourceIdLen);
                                         
                pResource = OmReferenceObjectById(ObjectTypeResource,pszResourceId);
                pNode = OmReferenceObjectById(ObjectTypeNode, pszNodeId);
                CL_ASSERT(pResource != NULL);
                CL_ASSERT(pNode != NULL);
                pPossibleNode = LocalAlloc( LMEM_FIXED,
                    sizeof(FMP_POSSIBLE_NODE) );
                if ( pPossibleNode == NULL ) 
                {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
                
                if (Context == FmUpdateAddPossibleNode) 
                {
                    dwControlCode = CLUSCTL_RESOURCE_ADD_OWNER;
                } 
                else 
                {
                    dwControlCode = CLUSCTL_RESOURCE_REMOVE_OWNER;
                }
                
                dwStatus = FmpUpdateChangeResourceNode(SourceNode, 
                    pResource, pNode, dwControlCode);
                //if status is not successful then return, else notify
                //resource dlls
                if (dwStatus != ERROR_SUCCESS)
                {
                    //dereference the objects
                    OmDereferenceObject(pResource);
                    OmDereferenceObject(pNode);
                    //free the memory
                    LocalFree(pPossibleNode);
                    return(dwStatus);
                }

                pPossibleNode->Resource = pResource;
                pPossibleNode->Node = pNode;
                pPossibleNode->ControlCode = dwControlCode;

                //
                // Tell the resource about the ADD/REMOVE in a worker thread.
                //

                FmpPostWorkItem( FM_EVENT_RESOURCE_CHANGE,
                                 pPossibleNode,
                                 0 );

                //
                //  Chittur Subbaraman (chitturs) - 6/7/99
                //  
                //  Don't reference pPossibleNode any more. It could have
                //  been freed by the worker thread by the time you get
                //  here.
                //
                ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                              pResource );

                // Let the worker thread perform the derefs/Frees
                return(dwStatus);
            }                

        case FmUpdateJoin:
            if ( CsDmOrFmHasChanged )
            {
                //
                // We can only send back SEQMISMATCH if we're a pure Windows Server 2003 (or later) environment.
                // In a mixed mode cluster, a W2K node would end up infinitely retrying the FM join.
                //
                DWORD dwClusterHighestVersion;
                NmGetClusterOperationalVersion( &dwClusterHighestVersion, NULL, NULL );
                if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < NT51_MAJOR_VERSION )
                {
                    ClRtlLogPrint(LOG_UNUSUAL,"[FM] DM or FM update has occured during join; rejecting FmUpdateJoin.\n" );
                    return ERROR_CLUSTER_DATABASE_SEQMISMATCH;                        
                }
            // Don't need to reset CsDmOrFmHasChanged here -- we will reset it when we see the DmUpdateJoin.
            }
            break;

            
        case FmUpdateCreateResourceType:
            {
                DWORD dwStatus;

                dwStatus = FmpUpdateCreateResourceType( Buffer );

                return( dwStatus );
            }
            break;
            
        case FmUpdateDeleteResourceType:
            {
                BOOL ResourceExists = FALSE;
                PFM_RESTYPE Type;

                Type = OmReferenceObjectById( ObjectTypeResType,
                                              (LPWSTR)Buffer);
                if (Type == NULL) {
                    return(ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND);
                }
                //
                // Make sure no resources exist of this type.
                //
                OmEnumObjects( ObjectTypeResource,
                               FmpFindResourceType,
                               Type,
                               &ResourceExists);
                if (ResourceExists) {
                    OmDereferenceObject(Type);
                    return(ERROR_DIR_NOT_EMPTY);
                }

                //
                // We need to dereference the object twice to get
                // rid of it. But then any notification handlers will
                // not get a chance to see the object by the time
                // the handler gets called. So we use the EP_DEREF_CONTEXT
                // flag to get the event processor to do the second deref
                // once everything has been dispatched.
                //
                FmpDeleteResType(Type);
                ClusterEventEx( CLUSTER_EVENT_RESTYPE_DELETED,
                                EP_DEREF_CONTEXT,
                                Type );
            }
            break;

        case FmUpdateChangeGroup:
            {
                PGUM_CHANGE_GROUP   pGumChange;
                PFM_RESOURCE        pResource;
                LPWSTR              pszResourceId;
                LPWSTR              pszGroupId;
                PFM_GROUP           pNewGroup;
                DWORD               dwStatus;
                DWORD               dwClusterHighestVersion;
                
                pGumChange = (PGUM_CHANGE_GROUP)Buffer;

                pszResourceId = pGumChange->ResourceId;
                pszGroupId = (LPWSTR)((PCHAR)pszResourceId +
                                          pGumChange->ResourceIdLen);
                //
                // Find the specified resource and group.
                //
                pResource = OmReferenceObjectById(ObjectTypeResource,
                                                 pszResourceId);
                if (pResource == NULL) {
                    return(ERROR_RESOURCE_NOT_FOUND);
                }
                pNewGroup = OmReferenceObjectById(ObjectTypeGroup, 
                                                    pszGroupId);
                if (pNewGroup == NULL) {
                    OmDereferenceObject(pResource);
                    return(ERROR_SUCCESS);
                }

                dwStatus = FmpUpdateChangeResourceGroup(SourceNode,
                              pResource, pNewGroup);

                OmDereferenceObject(pNewGroup);
                OmDereferenceObject(pResource);

                return(dwStatus);
            }
            break;

            
        default:
            {

            }
            ClRtlLogPrint(LOG_UNUSUAL,"[FM] Gum received bad context, %1!u!\n",
                Context);

    }

    return(ERROR_SUCCESS);

} // FmpGumReceiveUpdates


DWORD
FmpUpdateChangeQuorumResource2(
    IN BOOL     SourceNode,
    IN LPCWSTR  NewQuorumResourceId,
    IN LPCWSTR  szRootClusFilePath,
    IN LPDWORD  pdwMaxQuorumLogSize,
    IN LPDWORD  pdwQuorumArbTimeout,
    IN LPDWORD  pdwNewQuorumResourceCharacterictics OPTIONAL
    )

/*++

Routine Description:

    Perform updates related to changing of the quorum resource.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    pResource;
    PFM_RESOURCE    pOldQuoResource=NULL;
    DWORD           dwStatus;
    DWORD           dwChkPtSeq;
    HDMKEY          ResKey;
    HLOCALXSACTION  hXsaction = NULL;
    HLOG            hNewQuoLog=NULL;
    WCHAR           szQuorumLogPath[MAX_PATH];

    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    lstrcpyW(szQuorumLogPath, szRootClusFilePath);
    //lstrcatW(szQuorumLogPath, cszClusLogFileRootDir);

    pResource = OmReferenceObjectById( ObjectTypeResource,
                                      NewQuorumResourceId );
    if (pResource == NULL) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeQuorumResource: Resource <%1!ws!> could not be found....\n",
                   NewQuorumResourceId);
        return(ERROR_SUCCESS);
    }

    DmPauseDiskManTimer();

    //since the resource->quorum is going to change, acquire the quocritsec
    //always acquire the gQuoCritsec before gQuoLock
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    
    //prevent any resources from going online at this time
    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);

    //pause any changes to the cluster database
    //always acquire this lock after gQuoLock(refer to the ordering of locks
    // in fminit.c)
    ACQUIRE_EXCLUSIVE_LOCK(gLockDmpRoot);

    //if this resource was already a quorum resource
    if (!pResource->QuorumResource)
    {

        //
        // Now find the current quorum resource.
        //
        OmEnumObjects( ObjectTypeResource,
                       FmpFindQuorumResource,
                       &pOldQuoResource,
                       NULL );
        if ( pOldQuoResource != NULL )
        {
            CL_ASSERT( pOldQuoResource->QuorumResource );
            // Stop the quorum reservation thread!
            pOldQuoResource->QuorumResource = FALSE;
        }
        //set the new resource to be the quorum resource
        pResource->QuorumResource = TRUE;

    }

    //writes to the old log file
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                cszPath,
                                REG_SZ,
                                (LPBYTE)szQuorumLogPath,
                                (lstrlenW(szQuorumLogPath)+1) * sizeof(WCHAR));

    if (dwStatus != ERROR_SUCCESS)
        goto FnExit;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailLocalXsaction) {
        LPWSTR  pszStr = szQuorumLogPath;
        dwStatus = (MAX_PATH * sizeof(WCHAR));
        dwStatus = DmQuerySz( DmQuorumKey,
                        cszPath,
                        &pszStr,
                        &dwStatus,
                        &dwStatus);
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Testing failing a local transaction midway- new quorum path %1!ws!\r\n",
                    szQuorumLogPath);
        dwStatus = 999999;
        goto FnExit;
    }
#endif

    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                cszMaxQuorumLogSize,
                                REG_DWORD,
                                (LPBYTE)pdwMaxQuorumLogSize,
                                sizeof(DWORD));

    if (dwStatus != ERROR_SUCCESS)
        goto FnExit;


    //if the old quorum resource is different from the new quorum resource
    if ((pOldQuoResource) && (pOldQuoResource != pResource))
    {
        //get/set the new/old resource's flags
        //set the core flag on the new quorum resource
        ResKey = DmOpenKey( DmResourcesKey,
                            NewQuorumResourceId,
                            KEY_READ | KEY_SET_VALUE);
        if (!ResKey)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        pResource->ExFlags |= CLUS_FLAG_CORE;
        dwStatus = DmLocalSetValue( hXsaction,
                                    ResKey,
                                    CLUSREG_NAME_FLAGS,
                                    REG_DWORD,
                                    (LPBYTE)&(pResource->ExFlags),
                                    sizeof(DWORD));

        DmCloseKey( ResKey );

        if (dwStatus != ERROR_SUCCESS)
            goto FnExit;

        //unset the core flag on the old quorum resource
        ResKey = DmOpenKey( DmResourcesKey,
                            OmObjectId(pOldQuoResource),
                            KEY_READ | KEY_SET_VALUE);
        if (!ResKey)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        pOldQuoResource->ExFlags &= ~CLUS_FLAG_CORE;

        //unset the core flag on the old quorum resource
        dwStatus = DmLocalSetValue( hXsaction,
                                    ResKey,
                                    CLUSREG_NAME_FLAGS,
                                    REG_DWORD,
                                    (LPBYTE)&(pOldQuoResource->ExFlags),
                                    sizeof(DWORD));

        DmCloseKey( ResKey );

        if (dwStatus != ERROR_SUCCESS)
            goto FnExit;


    }
    //
    // Set the quorum resource value.
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                DmQuorumKey,
                                CLUSREG_NAME_QUORUM_RESOURCE,
                                REG_SZ,
                                (CONST BYTE *)OmObjectId(pResource),
                                (lstrlenW(OmObjectId(pResource))+1)*sizeof(WCHAR));


    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    if (pdwQuorumArbTimeout)
    {
        //if this is a mixed mode cluster pdwQourumArbTimeout will be NULL
        // Update the cluster registry from there
        // MM reads this location on startup
        dwStatus = DmLocalSetValue( hXsaction,
                            DmClusterParametersKey,
                           CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                           REG_DWORD,
                           (CONST PUCHAR)pdwQuorumArbTimeout,
                           sizeof(DWORD) );
        if ( dwStatus != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
               "[FM] FmSetQuorumResource: failed to set the cluster arbitration timeout, status = %1!u!\n", 
               dwStatus);
            goto FnExit;
        }
        
        ClRtlLogPrint(LOG_NOISE,
           "[FM] FmSetQuorumResource: setting QuorumArbitratrionTimeout to be = %1!u!\n", 
           *pdwQuorumArbTimeout);
        // Tell MM about the change...
        MmQuorumArbitrationTimeout = *pdwQuorumArbTimeout;
    }


FnExit:
    if (dwStatus == ERROR_SUCCESS)
    {
        LPWSTR  szClusterName=NULL;
        DWORD   dwSize=0;
        DWORD   dwCharacteristics = CLUS_CHAR_UNKNOWN;

        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);

        if ( !ARGUMENT_PRESENT ( pdwNewQuorumResourceCharacterictics ) )
        {
            pdwNewQuorumResourceCharacterictics = &dwCharacteristics;
        }

        //
        //  If the caller has passed in characteristics, then don't bother to drop a control
        //  code into a resource dll to find the characteristics in the following function. 
        //  Dropping a control code from within a GUM handler is disaster waiting to happen.
        //
        
        //
        //close the old log file, open the new one and take a checkpoint
        DmSwitchToNewQuorumLog(szQuorumLogPath, *pdwNewQuorumResourceCharacterictics);

        // SS:the buffer should contain the current cluster name ?

        DmQuerySz( DmClusterParametersKey,
                        CLUSREG_NAME_CLUS_NAME,
                        &szClusterName,
                        &dwSize,
                        &dwSize);

        if (szClusterName)
            ClusterEventEx(CLUSTER_EVENT_PROPERTY_CHANGE,
                   EP_FREE_CONTEXT,
                   szClusterName);
        if ((pOldQuoResource) && (pOldQuoResource != pResource))
        {
            //generate the resource property change events
            ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, 
                pResource );
            ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, 
                pOldQuoResource );
            
        }            

    }
    else
    {
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
        //reinstall the tombstone
        DmReinstallTombStone(szQuorumLogPath);
        //
        //  Make sure the flags are reset back
        //
        if ((pOldQuoResource) && (pOldQuoResource != pResource))
        {
            pOldQuoResource->QuorumResource = TRUE;
            pResource->QuorumResource = FALSE;
        }
    }
    if (pOldQuoResource) OmDereferenceObject(pOldQuoResource);
    OmDereferenceObject(pResource);
    //release locks
    RELEASE_LOCK(gLockDmpRoot);
    RELEASE_LOCK(gQuoLock);
    RELEASE_LOCK(gQuoChangeLock);

    DmRestartDiskManTimer();

    return(dwStatus);
}

DWORD
FmpUpdateChangeQuorumResource(
    IN BOOL     SourceNode,
    IN LPCWSTR  NewQuorumResourceId,
    IN LPCWSTR  szRootClusFilePath,
    IN LPDWORD  pdwMaxQuorumLogSize
    )

/*++

Routine Description:

    Perform updates related to changing of the quorum resource.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code otherwise.

--*/

{
    return(FmpUpdateChangeQuorumResource2(SourceNode, NewQuorumResourceId, szRootClusFilePath,
        pdwMaxQuorumLogSize, NULL, NULL));

}



DWORD
FmpUpdateResourceState(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN PGUM_RESOURCE_STATE ResourceState
    )
/*++

Routine Description:

    GUM update handler for resource state changes.

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    ResourceId - Supplies the id of the resource whose state is changing

    ResourceState - Supplies the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE resource;

    if ( !FmpFMGroupsInited ) {
        return(ERROR_SUCCESS);
    }

    //
    // This update type is always sent.
    // On the originating node, all of the work must be done by
    // the sending thread.
    // On the non-originating nodes, no locks can be acquired! This
    // would cause some hang situations with operations like move.
    // ... this is okay, since the locking must be done on the sending
    // node anyway, which owns the group.
    //
    if ( SourceNode == FALSE ) {
        resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

        if ( resource == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Gum ResourceState failed to find resource %1!ws!\n",
                       ResourceId);
            CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Gum update resource %1!ws!, state %2!u!, current state %3!u!.\n",
                   ResourceId,
                   ResourceState->State,
                   ResourceState->PersistentState);

        //FmpAcquireLocalResourceLock( resource );

        if ( resource->Group->OwnerNode == NmLocalNode ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Gum ResourceState wrong owner for %1!ws!\n",
                       ResourceId);
        } else {
            resource->State = ResourceState->State;
            resource->PersistentState = ResourceState->PersistentState;
            resource->StateSequence = ResourceState->StateSequence;

            switch ( ResourceState->State ) {
                case ClusterResourceOnline:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_ONLINE, resource );
                    break;
                case ClusterResourceOffline:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_OFFLINE, resource );
                    break;
                case ClusterResourceFailed:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_FAILED, resource );
                    break;
                case ClusterResourceOnlinePending:
                case ClusterResourceOfflinePending:
                    ClusterEvent( CLUSTER_EVENT_RESOURCE_CHANGE, resource );
                    break;
                default:
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Gum update resource state, bad state %1!u!\n",
                               ResourceState->State);
                    break;
            }
        }

        OmDereferenceObject( resource );
    }
    return(ERROR_SUCCESS);
}



DWORD
FmpUpdateGroupState(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId,
    IN PGUM_GROUP_STATE GroupState
    )
/*++

Routine Description:

    GUM update handler for group state changes.

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    GroupId - Supplies the id of the resource whose state is changing

    NodeId - Supplies the node id of the group owner.

    GroupState - Supplies the new state of the group.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP group;
    PWSTR     nodeId;
    PNM_NODE  node;

    if ( !FmpFMGroupsInited ) {
        return(ERROR_SUCCESS);
    }

    //
    // This update type is always sent.
    // On the originating node, all of the work must be done by
    // the sending thread.
    // On the non-originating nodes, no locks can be acquired! This
    // would cause some hang situations with operations like move.
    // ... this is okay, since the locking must be done on the sending
    // node anyway, which owns the group.
    //
    if ( SourceNode == FALSE ) {
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       GroupId );

        if ( group == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Gum GroupState failed to find group %1!ws!\n",
                       GroupId);
            return(ERROR_SUCCESS);
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] GUM update group %1!ws!, state %2!u!\n",
                   GroupId,
                   GroupState->State);

        if ( group->OwnerNode == NmLocalNode ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Gum GroupState wrong owner for %1!ws!\n",
                       GroupId);
        } else {
            group->State = GroupState->State;
            group->PersistentState = GroupState->PersistentState;
            group->StateSequence = GroupState->StateSequence;
            node = OmReferenceObjectById( ObjectTypeNode,
                                          NodeId );
            if ( node == NULL ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Owner of Group %1!ws! cannot be found %2!ws!\n",
                           GroupId,
                           NodeId);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                       "[FM] New owner of Group %1!ws! is %2!ws!, state %3!u!, curstate %4!u!.\n",
                       OmObjectId( group ),
                       OmObjectId( node ),
                       group->State,
                       group->PersistentState);
                if ( !FmpInPreferredList( group, node, FALSE,  NULL ) ) {
                    ClRtlLogPrint( LOG_UNUSUAL,
                                "[FM] New owner %1!ws! is not in preferred list for group %2!ws!.\n",
                                OmObjectId( node ),
                                OmObjectId( group ));
                }
            }
            group->OwnerNode = node;

            switch ( GroupState->State ) {
            case ClusterGroupOnline:
            case ClusterGroupPartialOnline:
                ClusterEvent( CLUSTER_EVENT_GROUP_ONLINE, group );
                break;
            case ClusterGroupOffline:
                ClusterEvent( CLUSTER_EVENT_GROUP_OFFLINE, group );
                break;
            default:
                ClRtlLogPrint(LOG_UNUSUAL,"[FM] Gum update group state, bad state %1!u!\n", GroupState->State);
                break;
            }
        }

        OmDereferenceObject( group );

    }

    return(ERROR_SUCCESS);
}

DWORD
FmpUpdateGroupNode(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId
    )
/*++

Routine Description:

    GUM update handler for group node changes. This is required for 
notification
    when a group moves between nodes but does not change state (i.e. it was
    already offline)

Arguments:

    SourceNode - Supplies whether or not this node was the source of the update

    GroupId - Supplies the id of the resource whose state is changing

    NodeId - Supplies the node id of the group owner.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP pGroup;
    DWORD     dwStatus = ERROR_SUCCESS;
    PNM_NODE  pNode = NULL;
    PNM_NODE  pPrevNode = NULL;
    
    if ( !FmpFMGroupsInited ) 
    {
        return(ERROR_SUCCESS);
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    GroupId );

    if (pGroup == NULL)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateGroupNode: GroupID = %1!ws! could not be found...\n",
                   GroupId);
        //
        //  Chittur Subbaraman (chitturs) - 6/12/99
        //
        //  Return ERROR_SUCCESS here since this is what NT4 side does.
        //  Compatibility pain !
        //
        goto FnExit;
    }


    pNode = OmReferenceObjectById(ObjectTypeNode,
                                    NodeId);

    if (pNode == NULL)
    {
        dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto FnExit;
    }
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpAcquireLocalGroupLock(pGroup);
    
    pPrevNode = pGroup->OwnerNode;

    //set the new owner node, incr ref count
    OmReferenceObject(pNode);
    pGroup->OwnerNode = pNode;

    //decr ref count on previous owner
    OmDereferenceObject(pPrevNode);
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpReleaseLocalGroupLock(pGroup);

    //generate an event to signify group owner node change
    ClusterEvent(CLUSTER_EVENT_GROUP_CHANGE, pGroup);
    
FnExit:
    if (pGroup) OmDereferenceObject(pGroup);
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}


DWORD
FmpUpdateChangeClusterName(
    IN BOOL     SourceNode,
    IN LPCWSTR  szNewName
    )
/*++

Routine Description:

    GUM update routine for changing the name of the cluster.

    This changes the name property of the core network name resource
    as well.  The resource is notified about it by a worker thread that
    the name has been changed.

Arguments:

    SourceNode - Supplies whether or not this node originated the update.

    NewName - Supplies the new name of the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR          Buffer;
    DWORD           Length;
    DWORD           Status = ERROR_SUCCESS;
    LPWSTR          ClusterNameId=NULL;
    DWORD           idMaxSize = 0;
    DWORD           idSize = 0;
    PFM_RESOURCE    Resource=NULL;
    HDMKEY          ResKey = NULL;
    HDMKEY          ParamKey = NULL;
    HLOCALXSACTION  hXsaction=NULL;
    DWORD           cbNewClusterName;
    LPWSTR          lpszNewClusterName;

    if ( !FmpFMGroupsInited ||
         FmpShutdown ) 
    {
        return(ERROR_SUCCESS);
    }

    cbNewClusterName = ( lstrlen ( szNewName ) + 1 ) * sizeof ( WCHAR );

    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        Status = ERROR_SUCCESS;
        goto FnExit;

    }
    //find the core network name resource, set its private properties
    Status = DmQuerySz( DmClusterParametersKey,
                        CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                        (LPWSTR*)&ClusterNameId,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeClusterName: failed to get cluster name resource, status=%1!u!.\n",
                   Status);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    Resource = OmReferenceObjectById( ObjectTypeResource, ClusterNameId );
    if (Resource == NULL) {
        Status = ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeClusterName: failed to find the cluster name resource, status=%1!u!\n",
                   Status);
        goto FnExit;
    }


    ResKey = DmOpenKey(DmResourcesKey, ClusterNameId, KEY_READ | KEY_SET_VALUE);
    if (!ResKey)
    {
        Status = GetLastError();
        goto FnExit;
    }
    ParamKey = DmOpenKey(ResKey, cszParameters, KEY_READ | KEY_SET_VALUE);

    if (!ParamKey)
    {
        Status = GetLastError();
        goto FnExit;
    }

    Status = DmLocalSetValue(hXsaction,
                ParamKey,
                CLUSREG_NAME_NET_NAME,
                REG_SZ,
                (CONST BYTE *)szNewName,
                cbNewClusterName);

    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeClusterName: failed to set the Name property, Status=%1!u!\n",
                   Status);
        goto FnExit;
    }
    
    //update the default cluster name
    Status = DmLocalSetValue(hXsaction,
                    DmClusterParametersKey,
                    CLUSREG_NAME_CLUS_NAME,
                    REG_SZ,
                    (CONST BYTE *)szNewName,
                    cbNewClusterName);

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeClusterName: failed to set the cluster name property,Status=%1!u!\n",
                   Status);
        goto FnExit;
    }

    //
    //  Update the CsClusterName variable. 
    // TODO: Need synchronization on CsClusterName
    //
    lpszNewClusterName = LocalAlloc ( LPTR, cbNewClusterName );

    if ( lpszNewClusterName == NULL )
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpUpdateChangeClusterName: Alloc for name failed, Status=%1!u!\n",
                      Status);
        goto FnExit;
    }
    
    LocalFree ( CsClusterName );

    CsClusterName = lpszNewClusterName;
    
    lstrcpy ( CsClusterName, szNewName );
    
    //the cluster_event_property_change is generated by the api itself using 
    //the cluster wide event after netname has finished the applying the changes

FnExit:
    if (ClusterNameId) LocalFree(ClusterNameId);
    if (ParamKey) DmCloseKey(ParamKey);
    if (ResKey) DmCloseKey(ResKey);
    if (Resource) OmDereferenceObject(Resource);
    if (hXsaction) 
    {
        if (Status == ERROR_SUCCESS) 
            DmCommitLocalUpdate(hXsaction);
        else 
            DmAbortLocalUpdate(hXsaction);
    }
    return(Status);
}


DWORD
FmpUpdateChangeResourceName(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId,
    IN LPCWSTR lpszNewName
    )
/*++

Routine Description:

    GUM dispatch routine for changing the friendly name of a resource.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    lpszResourceId - Supplies the resource ID.

    lpszNewName - Supplies the new friendly name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE pResource = NULL;
    DWORD dwStatus;
    HDMKEY      hKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    PFM_RES_CHANGE_NAME  pResChangeName = NULL; 

    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return( ERROR_SUCCESS );
    }

    //
    //  Chittur Subbaraman (chitturs) - 6/28/99
    //
    //  Restructure this GUM update as a local transaction.
    //
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, lpszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Resource <%1!ws!> could not be found....\n",
                   lpszResourceId);
        return( ERROR_RESOURCE_NOT_FOUND );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Entry for resource <%1!ws!>, New name = <%2!ws!>...\n",
                lpszResourceId,
                lpszNewName);

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Open the resources key.
    //
    hKey = DmLocalCreateKey( hXsaction,
                             DmResourcesKey,
                             lpszResourceId,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &dwDisposition );
                            
    if ( hKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Failed in opening the resources key for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
    CL_ASSERT( dwDisposition != REG_CREATED_NEW_KEY ); 

    //
    // Set the resource name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hKey,
                                CLUSREG_NAME_RES_NAME,
                                REG_SZ,
                                ( CONST BYTE * ) lpszNewName,
                                ( lstrlenW( lpszNewName ) + 1 ) * 
                                    sizeof( WCHAR ) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateChangeResourceName: DmLocalSetValue for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;     
    }

    pResChangeName = LocalAlloc( LMEM_FIXED,
                                 lstrlenW( lpszNewName ) * sizeof ( WCHAR ) + 
                                   sizeof( FM_RES_CHANGE_NAME ) );

    if ( pResChangeName == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateChangeResourceName: Unable to allocate memory for ResChangeName structure for resource <%1!ws!>, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;    
    }

    dwStatus = OmSetObjectName( pResource, lpszNewName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateChangeResourceName: Unable to set name <%3!ws!> for resource <%1!ws!>, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus,
                   lpszNewName );
        LocalFree( pResChangeName );
        goto FnExit;
    }

    pResChangeName->pResource = pResource;

    lstrcpyW( pResChangeName->szNewResourceName, lpszNewName );

    //
    //  The FM worker thread will free the memory for the pResChangeName
    //  structure as well as dereference the pResource object.
    //
    FmpPostWorkItem( FM_EVENT_RESOURCE_NAME_CHANGE, pResChangeName, 0 );   

    pResource = NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Successfully changed name of resource <%1!ws!> to <%2!ws!>...\n",
                lpszResourceId,
                lpszNewName);

FnExit:
    if ( pResource != NULL )
    {
        OmDereferenceObject( pResource );
    }

    if ( hKey != NULL ) 
    {
        DmCloseKey( hKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && ( hXsaction ) ) 
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateChangeResourceName: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
}


/****
@func       DWORD | FmpUpdatePossibleNodesForResType| This update is called to 
            update the possible nodes for a resource type.  

@parm       IN BOOL | SourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN LPCWSTR | lpszResTypeName | The name of the resource type.

@parm       IN DWORD | dwBufLength | The size of the multi-sz string pointed
            to by pBuf

@parm       IN PVOID | pBuf | A pointer to the buffer containing the names of 
            the nodes that support this resource type.

@comm       The possible list of nodes that supports the given resource type is 
            updated with the list provided.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpDecisionPossibleDmSwitchToNewQuorumLog>
****/
DWORD
FmpUpdatePossibleNodeForResType(
    IN BOOL         SourceNode,
    IN LPCWSTR      lpszResTypeName,
    IN LPDWORD      pdwBufLength,
    IN PVOID        pBuf
    )
{
    PFM_RESTYPE         pResType;
    DWORD               dwStatus;
    HDMKEY              hResTypeKey = NULL;
    HLOCALXSACTION      hXsaction = NULL;
    LIST_ENTRY          NewPosNodeList;
    PLIST_ENTRY         pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 5/13/99
    // 
    //  Don't check for FmpFMGroupsInited condition since this GUM
    //  handler is called by the forming node before that variable
    //  is set to TRUE. This update always comes after the 
    //  corresponding restypes have been created and is made
    //  internally by the clussvc following this order. Note that
    //  a joining node cannot receive this update until groups are
    //  inited since GUM receive updates are turned on only after 
    //  the FmpFMGroupsInited variable is set to TRUE. Also, the
    //  intracluster RPC is fired up in a forming node only after
    //  the groups are inited. Hence, there is no major danger 
    //  of this GUM handler being called if the corresponding 
    //  restype is not created.
    //
    if ( FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    InitializeListHead(&NewPosNodeList);

    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      lpszResTypeName);



    if (!pResType)
    {
        dwStatus = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto FnExit;
    }

    dwStatus = FmpAddPossibleNodeToList(pBuf, *pdwBufLength, &NewPosNodeList);

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }


    //writes to the old log file
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    hResTypeKey = DmOpenKey(DmResourceTypesKey,
                   lpszResTypeName,
                   KEY_READ | KEY_WRITE);
    if (hResTypeKey == NULL) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //if there are no possible owners, delete the value
    if (pBuf && *pdwBufLength)
    {
        dwStatus = DmLocalSetValue( hXsaction,
                                hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                                REG_MULTI_SZ,
                                (LPBYTE)pBuf,
                                *pdwBufLength);
    }
    else
    {
        dwStatus = DmLocalDeleteValue( hXsaction,
                                hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES);
                                
        if (dwStatus == ERROR_FILE_NOT_FOUND)
        {
            dwStatus = ERROR_SUCCESS;
        }
    }


FnExit:
    if (dwStatus == ERROR_SUCCESS)
    {
        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);

        ACQUIRE_EXCLUSIVE_LOCK(gResTypeLock);
        
        //free the old list
        while (!IsListEmpty(&pResType->PossibleNodeList))
        {
            pListEntry = RemoveHeadList(&pResType->PossibleNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }
        //now switch the possible owners list for the
        //resource type
        while (!IsListEmpty(&(NewPosNodeList)))
        {
            //remove from the new prepared list and hang
            //it of the restype structure
            pListEntry = RemoveHeadList(&NewPosNodeList);
            InsertTailList(&pResType->PossibleNodeList, pListEntry);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpUpdatePossibleNodesForRestype:Adding node  %1!ws! to %2!ws! resource type's possible node list...\n",
                        OmObjectId(pResTypePosEntry->PossibleNode),
                        lpszResTypeName);
            

        }

        RELEASE_LOCK(gResTypeLock);
        
        ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE,
                                pResType );

    
    }
    else
    {
        //free up the NewPostNodeList
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
        //if a new list was prepared, free it
        while (!IsListEmpty(&(NewPosNodeList)))
        {
            pListEntry = RemoveHeadList(&NewPosNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }

        
    }
    if (hResTypeKey) DmCloseKey(hResTypeKey);
    if (pResType) OmDereferenceObject(pResType);

    return(dwStatus);
}


/****
@func       DWORD | FmpDecidePossibleNodeForResType| When the quorum resource is changed,
            the FM invokes this api on the owner node of the new quorum resource
            to create a new quorum log file.

@parm       IN PVOID | pResource | The new quorum resource.
@parm       IN LPCWSTR | lpszPath | The path for temporary cluster files.
@parm       IN DWORD | dwMaxQuoLogSize | The maximum size limit for the quorum log file.

@comm       When a quorum resource is changed, the fm calls this funtion before it
            updates the quorum resource.  If a new log file needs to be created,
            a checkpoint is taken.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD FmpDecidePossibleNodeForResType
(
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD dwVoteBufLength,
    IN PVOID pVoteBuf,
    IN DWORD dwNumVotes,
    IN BOOL  bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *ppOutputBuf
)
{
    DWORD                               dwStatus = ERROR_SUCCESS;
    DWORD                               i;
    PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE pFmpVote;
    LPWSTR                              lpmszPossibleNodes = NULL;
    DWORD                               dwlpmszLen = 0;
    PVOID                               pGumBuffer = NULL;
    DWORD                               dwNodeId;
    WCHAR                               szNodeId[NODE_ID_SZ];
    LPWSTR                              lpmszCurrentPossibleNodes=NULL;
    BOOL                                bChange = FALSE;
    HDMKEY                              hResTypeKey = NULL;
    DWORD                               dwSize;
    DWORD                               dwStringBufSize = 0;
    BOOL                                bAssumeSupported;
    LPWSTR                              TypeName = NULL;

    //First get the type name from pDecisionContext
    
    TypeName=(LPWSTR)LocalAlloc(LMEM_FIXED,pDecisionContext->dwInputBufLength);

    if(TypeName==NULL)
    {
        ClRtlLogPrint(LOG_CRITICAL,"[FM] FmpDecidePossibleNodeForResType: Not Enough Memory, error= %1!d!\r\n",
                     GetLastError());
        goto FnExit;                             
    }

    CopyMemory(TypeName,pDecisionContext->pInputBuf,pDecisionContext->dwInputBufLength);

    //initialize the out params
    *ppOutputBuf = NULL;
    *pdwOutputBufSize = 0;

    bAssumeSupported= *((BOOL*)pDecisionContext->pContext);

    if (bAssumeSupported)
    {
        hResTypeKey = DmOpenKey(DmResourceTypesKey,
                   TypeName,
                   KEY_READ | KEY_WRITE);
        if (hResTypeKey == NULL) 
        {
            dwStatus = GetLastError();
            CL_LOGFAILURE(dwStatus);
            goto FnExit;
        }

        //pass the current possible node list to the decider
        dwStatus = DmQueryString(hResTypeKey,
                                CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                                REG_MULTI_SZ,
                                &lpmszCurrentPossibleNodes,
                                &dwStringBufSize,
                                &dwSize);
        if (dwStatus != ERROR_SUCCESS)
        {
            //if the possible node list is not found this is ok
            //ie. only if there is some other error we give up
            if ( dwStatus != ERROR_FILE_NOT_FOUND ) 
            {
                CL_LOGFAILURE(dwStatus);
                goto FnExit;
            }
            
        }
        DmCloseKey(hResTypeKey);
        hResTypeKey = NULL;
    }
    
    //if the current list is passed in, dont remove any possible
    //nodes from the list if they dont vote, simply add the new ones
    if (lpmszCurrentPossibleNodes)
    {
        DWORD   dwStrLen;
        
        //make a copy of the multi-sz
        dwlpmszLen = ClRtlMultiSzLength(lpmszCurrentPossibleNodes);

        dwStrLen = dwlpmszLen * sizeof(WCHAR);
        lpmszPossibleNodes = LocalAlloc(LMEM_FIXED, dwStrLen);
        if (!lpmszPossibleNodes)
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_LOGFAILURE(dwStatus);
            goto FnExit;
        }
        CopyMemory(lpmszPossibleNodes, lpmszCurrentPossibleNodes, dwStrLen);
    }        
    for (i = 0; i< dwNumVotes; i++)
    {
        pFmpVote = (PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE) 
            GETVOTEFROMBUF(pVoteBuf, pDecisionContext->dwVoteLength, i+1 , &dwNodeId);         
        //if not a valid vote, skip
        if (!pFmpVote)
            continue;
        CL_ASSERT((PBYTE)pFmpVote <= ((PBYTE)pVoteBuf + dwVoteBufLength - 
            sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE)));
        szNodeId[ NODE_ID_SZ-1 ] = UNICODE_NULL;
        _snwprintf( szNodeId, NODE_ID_SZ-1, L"%d" , dwNodeId );
        if (pFmpVote->bPossibleNode)
        {
            if (lpmszCurrentPossibleNodes)
            {
                //if the string is already there, dont append it again
                if (ClRtlMultiSzScan(lpmszCurrentPossibleNodes, szNodeId))
                    continue;

            }
            dwStatus = ClRtlMultiSzAppend(&lpmszPossibleNodes,
                    &dwlpmszLen, szNodeId);
            bChange = TRUE;                    
            if (dwStatus != ERROR_SUCCESS)
                goto FnExit;
                    
        }
        else
        {
            //if a current list was specified
            //this node is not a possible node anymore, remove it from the list
            if (lpmszCurrentPossibleNodes)
            {
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpDecidePossibleNodesForRestype: Removing node %1!ws! from  %2!ws! restype possibleowner list \r\n",
                            szNodeId,TypeName);
                dwStatus = ClRtlMultiSzRemove(lpmszPossibleNodes, &dwlpmszLen, szNodeId);
                if (dwStatus == ERROR_SUCCESS)
                {
                    //if the node is successfully removed
                    bChange = TRUE;
                }
                else if (dwStatus != ERROR_FILE_NOT_FOUND)
                {
                    //if the node exists but cannot be removed return with error
                    //if the node didnt exist, we dont do anything bChange remains
                    //set at FALSE
                    goto FnExit;
                }
                else
                {
                    dwStatus = ERROR_SUCCESS;
                }
                
            }                
        }
    }

    //if nothing has changed dont issue a gum update
    if (!bChange)
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //dwlpmszLen contains the size of the multi-sz string in the
    //number of characters, make it the number of bytes
    dwlpmszLen *= sizeof(WCHAR);
    
    pGumBuffer = GumMarshallArgs(pdwOutputBufSize, 3, 
        pDecisionContext->dwInputBufLength, pDecisionContext->pInputBuf, 
        sizeof(DWORD), &dwlpmszLen, dwlpmszLen, lpmszPossibleNodes);

    *ppOutputBuf = pGumBuffer;
        
FnExit:
    if (lpmszPossibleNodes) LocalFree(lpmszPossibleNodes);
    if (hResTypeKey)
        DmCloseKey(hResTypeKey);
    if (lpmszCurrentPossibleNodes)
        LocalFree(lpmszCurrentPossibleNodes);
    if(TypeName)
        LocalFree(TypeName);

    return(dwStatus);
}



/****
@func       DWORD | FmpUpdateChangeResourceNode| This update is called to 
            update the possible nodes for a resource.  

@parm       IN BOOL | SourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN PFM_RESOURCE | pResource | A pointer to the resource whose
            possible node list is being updated.

@parm       IN PNM_NODE | pNode | A pointer to the node to be added/removed
            from the possible node lis.

@parm       IN  DWORD | dwControlCode | If CLUSCTL_RESOURCE_ADD_OWNER then
            the node is added to the possible node list, else it is removed.

@comm       The possible list of nodes for a resource is updated.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD
FmpUpdateChangeResourceNode(
    IN BOOL         SourceNode,
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode,
    IN DWORD        dwControlCode
    )
{
    DWORD               dwStatus;
    HDMKEY              hResKey = NULL;
    HLOCALXSACTION      hXsaction = NULL;

    //Dont acquire the local resource lock since acquiring that
    //within gum updates causes deadlock
    //use the global resource lock to synchronize this call
    //with the enumeration of possible nodes
    FmpAcquireResourceLock();

    //start a transaction
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //
    //  BUGBUG:  What if in-memory stuff succeeds and registry stuff fails ? We get into
    //  inconsistent state. Better to move this code to the end after succeeding in
    //  registry changes.
    //
    if (dwControlCode == CLUSCTL_RESOURCE_ADD_OWNER) 
    {
        dwStatus = FmpAddPossibleNode(pResource,
                                    pNode);
    } else 
    {
        dwStatus = FmpRemovePossibleNode(pResource,
                                       pNode,
                                       FALSE);
    }
    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint( LOG_NOISE,
                    "[FM] FmpUpdateChangeResourceNode, failed possible node updatefor resource <%1!ws!>, error %2!u!\n",
                    OmObjectName(pResource),
                    dwStatus );
        goto FnExit;                    
    }
                
    //fix the registry
    //SS - do we need to fix the preferred node list
    hResKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(pResource),
                       KEY_READ | KEY_WRITE);
    if (hResKey == NULL) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    if (dwControlCode == CLUSCTL_RESOURCE_ADD_OWNER) 
    {
        dwStatus = DmLocalAppendToMultiSz(
                            hXsaction,
                            hResKey,
                            CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                            OmObjectId(pNode));
    }
    else
    {
        dwStatus = DmLocalRemoveFromMultiSz(
                            hXsaction,
                            hResKey,
                            CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                            OmObjectId(pNode));
        if (dwStatus == ERROR_FILE_NOT_FOUND) 
        {
            DWORD       i;
            DWORD       Result;
            PNM_NODE    pEnumNode;                

            //
            // Possible nodes did not exist, so create a new entry
            // with every possible node in it. FM will already have
            // removed the passed in node from the possible node list.
            //
            i=0;
            do {
                Result = FmEnumResourceNode(pResource,
                                            i,
                                            &pEnumNode);
                if (Result == ERROR_SUCCESS) 
                {
                    dwStatus = DmLocalAppendToMultiSz(
                                    hXsaction,
                                    hResKey,
                                    CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                                    OmObjectId(pEnumNode));
                    OmDereferenceObject(pEnumNode);

                } 
                else if ((Result == ERROR_NO_MORE_ITEMS) &&
                           (i == 0)) 
                {
                    //
                    // This is a funny corner case where there is a one
                    // node cluster and a resource with no possibleowners
                    // entry, and somebody removes the only node in the cluster
                    // from the possible owners list. Set PossibleOwners to
                    // the empty set.
                    //
                    dwStatus = DmLocalSetValue(
                                    hXsaction,
                                    hResKey,
                                    CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                                    REG_MULTI_SZ,
                                    (CONST BYTE *)L"\0",
                                    2);

                }
                ++i;
            } while ( Result == ERROR_SUCCESS );
            //map the error to success
            dwStatus = ERROR_SUCCESS;
        }
    }
    
    DmCloseKey(hResKey);
            

FnExit:        
    //release the lock
    FmpReleaseResourceLock();
    if (dwStatus == ERROR_SUCCESS)
    {
        //commit the update on the old log file,
        //any nodes that were done, will get this change
        //I cant delete this file
        DmCommitLocalUpdate(hXsaction);

    }
    else
    {
        //SS: BUGBUG :: validation for possible node should
        //be done before the registry is switched
        //the inmemory structure should be changed only on success
        //if there is a failure in the registry apis..the
        //in memory structure will be out of sync with registry
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
    }

    return(dwStatus);
}


/****
@func       DWORD | FmpUpdateChangeResourceGroup| This update is called to 
            update the group to which the resource belongs.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at this
            node.
            
@parm       IN PFM_RESOURCE | pResource | A pointer to the resource whose
            possible node list is being updated.

@parm       IN PFM_GROUP | pNewGroup | A pointer to the node to be added/removed
            from the possible node lis.

@comm       The possible list of nodes for a resource is updated.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD FmpUpdateChangeResourceGroup(
    IN BOOL         bSourceNode,
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup)
{
    DWORD               dwStatus = ERROR_SUCCESS;
    PFM_GROUP           pOldGroup;
    PFM_DEPENDENCY_TREE pTree = NULL;
    HLOCALXSACTION      hXsaction = NULL;
    HDMKEY              hOldGroupKey = NULL;
    HDMKEY              hNewGroupKey = NULL;
    PLIST_ENTRY         pListEntry;
    PFM_DEPENDTREE_ENTRY pEntry;

    pOldGroup = pResource->Group;

    //
    // Check to make sure the resource is not already in the group.
    //
    if (pOldGroup == pNewGroup) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pOldGroup ), OmObjectId( pNewGroup ) ) <= 0 ) 
    {
        FmpAcquireLocalGroupLock( pOldGroup );
        FmpAcquireLocalGroupLock( pNewGroup );
    } 
    else 
    {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pOldGroup );
    }

    //start a transaction
    hXsaction = DmBeginLocalUpdate();

    if (!hXsaction)
    {
        dwStatus = GetLastError();
        goto FnUnlock;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnUnlock;
    }


    //
    // Create a full dependency tree, 
    //
    pTree = FmCreateFullDependencyTree(pResource);
    if ( pTree == NULL )
    {
        dwStatus = GetLastError();        
        goto FnUnlock;
    }
   

    //
    // Add each resource in the dependency tree to its new group's list.
    //
    hNewGroupKey = DmOpenKey(DmGroupsKey,
                            OmObjectId(pNewGroup),
                            KEY_READ | KEY_WRITE);
    if (hNewGroupKey == NULL) {
        dwStatus = GetLastError();
        goto FnUnlock;
    }
    hOldGroupKey = DmOpenKey(DmGroupsKey,
                            OmObjectId(pOldGroup),
                            KEY_READ | KEY_WRITE);
    if (hOldGroupKey == NULL) {
        dwStatus = GetLastError();
        goto FnUnlock;
    }

    //
    // For each resource in the dependency tree, remove it from the
    // old group list and add it to the new group list
    //
    pListEntry = pTree->ListHead.Flink;
    while (pListEntry != &pTree->ListHead) {
        pEntry = CONTAINING_RECORD(pListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        pListEntry = pListEntry->Flink;

        dwStatus = DmLocalRemoveFromMultiSz(hXsaction,
                        hOldGroupKey,
                        CLUSREG_NAME_GRP_CONTAINS,
                        OmObjectId(pEntry->Resource));

        if (dwStatus != ERROR_SUCCESS) {
            goto FnUnlock;
        }

        dwStatus = DmLocalAppendToMultiSz(hXsaction,
                        hNewGroupKey,
                        CLUSREG_NAME_GRP_CONTAINS,
                        OmObjectId(pEntry->Resource));

        if (dwStatus != ERROR_SUCCESS) {
            goto FnUnlock;
        }

    }
    
    //
    // Passed all the checks, do the in-memorymove.
    //
    pListEntry = pTree->ListHead.Flink;
    while (pListEntry != &pTree->ListHead) 
    {
        pEntry = CONTAINING_RECORD(pListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        pListEntry = pListEntry->Flink;

        //
        // Move this resource
        //
        RemoveEntryList(&pEntry->Resource->ContainsLinkage);

        InsertHeadList(&pNewGroup->Contains,
                       &pEntry->Resource->ContainsLinkage);
        OmReferenceObject(pNewGroup);
        pEntry->Resource->Group = pNewGroup;
        ++pEntry->Resource->StateSequence;

        ClusterEvent(CLUSTER_EVENT_RESOURCE_CHANGE,pEntry->Resource);
        OmDereferenceObject(pOldGroup);
    }

FnUnlock:
    //
    // Now release all locks.
    //
    FmpReleaseLocalGroupLock( pNewGroup );
    FmpReleaseLocalGroupLock( pOldGroup );

FnExit:
    if (pTree) FmDestroyFullDependencyTree(pTree);
    if (hOldGroupKey) DmCloseKey(hOldGroupKey);
    if (hNewGroupKey) DmCloseKey(hNewGroupKey);
    if (dwStatus == ERROR_SUCCESS)
    {
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,pNewGroup);
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,pOldGroup);
        DmCommitLocalUpdate(hXsaction);
    }
    else
    {
        if (hXsaction) DmAbortLocalUpdate(hXsaction);
    }

    
    return(dwStatus);

}

DWORD
FmpUpdateAddDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    )
/*++

Routine Description:

    GUM dispatch routine for adding a dependency

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the resource ID of the resource that should have a
        dependency added.

    DependsOnId - Supplies the resource ID of the resource that should provide
        for ResourceId.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    PDEPENDENCY dependency;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    dependency = LocalAlloc(LMEM_FIXED, sizeof(DEPENDENCY));
    if (dependency == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Resource = OmReferenceObjectById(ObjectTypeResource,
                                     ResourceId);
    if (Resource == NULL) {
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        LocalFree(dependency);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DependsOn = OmReferenceObjectById(ObjectTypeResource,
                                      DependsOnId);
    if (DependsOn == NULL) {
        OmDereferenceObject(Resource);
        LocalFree(dependency);
        CL_LOGFAILURE( ERROR_DEPENDENCY_NOT_FOUND );
        return(ERROR_DEPENDENCY_NOT_FOUND);
    }

    dependency->DependentResource = Resource;
    dependency->ProviderResource = DependsOn;
    FmpAcquireResourceLock();
    InsertTailList( &DependsOn->ProvidesFor,
                    &dependency->ProviderLinkage );
    InsertTailList( &Resource->DependsOn,
                    &dependency->DependentLinkage );
    FmpReleaseResourceLock();

    ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                  Resource );

    //SS: we leave the reference counts on both the objects
    //as a dependency referrring to them has been created.
    return(ERROR_SUCCESS);

} // FmpUpdateAddDependency



DWORD
FmpUpdateRemoveDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    )
/*++

Routine Description:

    GUM dispatch routine for adding a dependency

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the resource ID of the resource that should have a
        dependency removed.

    DependsOnId - Supplies the resource ID of the resource that provides
        for ResourceId.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE Resource;
    PFM_RESOURCE DependsOn;
    PDEPENDENCY dependency;
    PLIST_ENTRY ListEntry;
    DWORD       Status=ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    Resource = OmReferenceObjectById(ObjectTypeResource,
                                     ResourceId);
    if (Resource == NULL) {
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DependsOn = OmReferenceObjectById(ObjectTypeResource,
                                      DependsOnId);
    if (DependsOn == NULL) {
        OmDereferenceObject(Resource);
        CL_LOGFAILURE( ERROR_RESOURCE_NOT_FOUND );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Walk through the dependency list of the resource searching
    // for a match.
    //
    FmpAcquireResourceLock();
    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        CL_ASSERT(dependency->DependentResource == Resource);
        if (dependency->ProviderResource == DependsOn) {
            //
            // Found a match. Remove it from its list and
            // free it up.
            //
            RemoveEntryList(&dependency->ProviderLinkage);
            RemoveEntryList(&dependency->DependentLinkage);
            // dereference the providor and dependent resource
            OmDereferenceObject(dependency->DependentResource);
            OmDereferenceObject(dependency->ProviderResource);
            LocalFree(dependency);
            break;
        }
        ListEntry = ListEntry->Flink;
    }
    FmpReleaseResourceLock();

    if (ListEntry != &Resource->DependsOn) {
        //
        // A match was found. Dereference the provider resource
        // to account for the dependency removal and return success.
        //
        ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                      Resource );
        Status = ERROR_SUCCESS;
    } else {
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }

    //SS: dereference the objects earlier referenced
    OmDereferenceObject(Resource);
    OmDereferenceObject(DependsOn);
    return(Status);

} // FmpUpdateRemoveDependency

DWORD
FmpUpdateDeleteGroup(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId
    )
/*++

Routine Description:

    GUM dispatch routine for deleting a group.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    GroupId - Supplies the group ID.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD           dwStatus = ERROR_SUCCESS;
    PFM_GROUP       pGroup = NULL;
    PLIST_ENTRY     listEntry;
    PPREFERRED_ENTRY preferredEntry;
    BOOL            bLocked = FALSE;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    //
    // Find the specified Group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    GroupId );
    if ( pGroup == NULL ) {
        dwStatus = ERROR_GROUP_NOT_FOUND;
        return(dwStatus);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] DeleteGroup %1!ws!, address = %2!lx!.\n",
               OmObjectId(pGroup),
               pGroup );
    //
    // Chittur Subbaraman (chitturs) - 1/12/99
    //
    // Try to acquire lock, and make sure the Contains list is empty.
    //
    // Most of the calls to manipulate groups make calls to the owner
    // node of the group and this operation is serialized by GUM. So,
    // there is no major danger if we do the operations in this function
    // without holding the group lock. However, we can't rule out
    // corruption 100% as of now.
    //
    // If you block within the GUM handler here, then no events in
    // the cluster proceed forward and things come to a grinding halt.
    //
    // A case in point:
    // (1) Thread 1 (the thread that calls this function) grabs the 
    // GUM lock and waits for the group lock.
    // (2) Thread 2 (FmWorkerThread) grabs the group lock and calls
    // resmon attempting to close a resource. It gets blocked on
    // the resmon eventlist lock.
    // (3) Thread 3 calls RmResourceControl to set the resource name
    // which grabs the resmon eventlist lock and then in turn calls 
    // ClusterRegSetValue and then gets blocked on the GUM lock.
    //
    FmpTryAcquireLocalGroupLock( pGroup, bLocked );

    if ( !IsListEmpty( &pGroup->Contains ) ) 
    {
        dwStatus = ERROR_DIR_NOT_EMPTY;
        goto FnExit;
    }

    //
    // Close the Group's registry key.
    //
    DmRundownList( &pGroup->DmRundownList );
    if ( pGroup->RegistryKey != NULL ) {
        DmCloseKey( pGroup->RegistryKey );
        pGroup->RegistryKey = NULL;
    }

    //
    // Remove from the node list
    //
    dwStatus = OmRemoveObject( pGroup );
    
    ClusterEvent( CLUSTER_EVENT_GROUP_DELETED, pGroup );
    //
    // This dereference would normally cause the group to eventually disappear,
    // however the event notification above will keep a ref on the object
    // until all notifications have been delivered.
    //
    OmDereferenceObject( pGroup );

    //
    // Make sure the preferred owners list is drained.
    //
    while ( !IsListEmpty( &pGroup->PreferredOwners ) ) {
        listEntry = RemoveHeadList(&pGroup->PreferredOwners);
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }

    //
    //  Free the string associated with the AntiAffinityClassName field.
    //
    LocalFree ( pGroup->lpszAntiAffinityClassName );

    pGroup->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_DELETE;
    
FnExit:
    if( bLocked ) 
    {
        FmpReleaseLocalGroupLock( pGroup );
    }

    //
    // Dereference for reference above.
    //
    if (pGroup) OmDereferenceObject( pGroup );

    return(dwStatus);

} // FmpUpdateDeleteGroup

/****
@func       DWORD | FmpUpdateGroupIntendedOwner| This update is called on
            a move just before the source node requests the target node
            to take over the group.  

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN PFM_GROUP | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpUpdateAssignOwnerToGroups

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD
FmpUpdateGroupIntendedOwner(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszGroupId,
    IN PDWORD   pdwNodeId
    )
{
    PFM_GROUP   pGroup = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pNode = NULL;
    PNM_NODE    pPrevNode;
    WCHAR       pszNodeId[ NODE_ID_SZ ];
    
    if ( !FmpFMGroupsInited ) 
    {
        return(ERROR_SUCCESS);
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                   pszGroupId );

    if (pGroup == NULL)
    {
        dwStatus =  ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    if (*pdwNodeId != ClusterInvalidNodeId)
    {
        pszNodeId [ NODE_ID_SZ - 1 ] = UNICODE_NULL;
        _snwprintf(pszNodeId, NODE_ID_SZ-1, L"%u", *pdwNodeId);

        pNode = OmReferenceObjectById(ObjectTypeNode,
                                        pszNodeId);

        if (pNode == NULL)
        {
            dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
            goto FnExit;
        }
    } else if (pGroup->pIntendedOwner == NULL)
    {
        dwStatus = ERROR_CLUSTER_INVALID_NODE;
        ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateGroupIntendedOwner: Group <%1!ws!> intended owner is already invalid, not setting....\n",
              pszGroupId);
        goto FnExit;
    }
    
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpAcquireLocalGroupLock(pGroup);
    
    pPrevNode = pGroup->pIntendedOwner;

    //set the new owner node, incr ref count
    if (pNode) OmReferenceObject(pNode);
    pGroup->pIntendedOwner = pNode;

    //decr ref count on previous owner
    if (pPrevNode) OmDereferenceObject(pPrevNode);
    //
    // HACKHACK: Chittur Subbaraman (chitturs) - 5/20/99
    // Comment out as a temporary solution to avoid deadlocks.
    //
    // FmpReleaseLocalGroupLock(pGroup);
    
FnExit:
    if (pGroup) OmDereferenceObject(pGroup);
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}


/****
@func       DWORD | FmpUpdateAssignOwnerToGroups| This update is made when
            a node goes down to take ownership of all the orphaned groups.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN LPCWSTR | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
, 
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpClaimNodeGroups algorithm.

@rdesc      returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateAssignOwnerToGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    )
{
    PNM_NODE    pNode = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       dwNodeId;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return(ERROR_SUCCESS);
    }

    //
    //  In a node evict, the NM GUM handler gets rids of the dead node from the OM list.
    //  This node down FM GUM handler could follow the NM evict GUM handler since NM
    //  lets an evict through once *it* declares a node as down. At that time, there is no
    //  guarantee that the FM node down GUM has executed since that GUM is issued in the
    //  async phase of node down processing and could very well follow the NM evict GUM
    //  handler.  Thus, this GUM handler and associated functions CANNOT call OM to get
    //  a node object from the node ID string.  Thus, this GUM handler and associated
    //  functions are carefully written to work with a node ID as opposed to a node object.
    //
    dwNodeId = wcstoul( pszNodeId, NULL, 10 );

    //if this update has already been seen after the node down
    //ignore this one
    if (gFmpNodeArray[dwNodeId].dwNodeDownProcessingInProgress == 0)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpUpdateAssignOwnersToGroups, %1!ws! node down has been processed already\n",
                   pszNodeId);
        goto FnExit;                   
    }
    //
    // Assign ownership to all groups owned by the dead node
    //
    dwStatus = FmpAssignOwnersToGroups(pszNodeId, NULL, NULL);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateAssignOwnersToGroups failed %1!d!\n",
                   dwStatus);
    }                   
    
    //mark that the node down processing has been done
    gFmpNodeArray[dwNodeId].dwNodeDownProcessingInProgress = 0;
    
FnExit:        
    return(dwStatus);
}

/****
@func       DWORD | FmpUpdateApproveJoin| The joining node
            makes this update call.

@parm       IN BOOL | bSourceNode | set to TRUE, if the update originated at 
this
            node.
            
@parm       IN LPCWSTR | pszGroupId | The ID of the group that is about 
            to move.

@parm       IN PDWORD | pdwNodeId| A pointer to a DWORD that contains the
            ID of the node that is the destination of this move.  It is 
            set to ClusterInvalidNodeId by the destination node when it has 
            accepted the group.

@comm       The purpose of this update is to let all nodes know that a move
            is impending.  If the source node dies while a move is in progress
, 
            then preference is given to the target of the move rather than the
            node that is chosen by the FmpClaimNodeGroups algorithm.

@rdesc      returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateApproveJoin(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    )
{

    PNM_NODE    pNode = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/99
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return(ERROR_SUCCESS);
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   pszNodeId );

    if (!pNode)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateAssignOwnersToGroups, %1!ws! node not found\n",
                   pszNodeId);
        //should we return failure here
        //is evict of a node synchronized with everything
        goto FnExit;                   
    }

    if (pNode == NmLocalNode)
    {
        // SS: can I become the locker now
        // If so, there what do I do
        //i approve of my own join
        goto FnExit;
    }
    //if a node is trying to join before the processing
    //for its last death has been completed, ask it to retry
    if (gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingInProgress == 1)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateApproveJoin, %1!ws! node down hasnt been processed as yet\n",
                   pszNodeId);
        dwStatus = ERROR_RETRY;                   
        goto FnExit;                   
    }
FnExit:        
    if (pNode) OmDereferenceObject(pNode);
    return(dwStatus);
}

/****
@func       DWORD | FmpUpdateCreateGroup | GUM update handler for creating
            a group.
           
@parm       IN OUT PGUM_CREATE_GROUP | pGumGroup | Buffer containing group info

@parm       IN BOOL | bSourceNode | Indicates whether this call originated
            from this node.

@comm       This GUM update creates a group and is structured as a local 
            transaction so that both registry entries and in-memory
            structures are updated consistently.

@rdesc      Returns ERROR_SUCCESS on success. A Win32 error code otherwise.
****/
DWORD
FmpUpdateCreateGroup(
    IN OUT PGUM_CREATE_GROUP pGumGroup,
    IN BOOL    bSourceNode
    )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    HDMKEY      hKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    LPCWSTR     lpszNodeId = NULL;
    PNM_NODE    pNode = NULL;
    DWORD       dwGroupIdLen = 0;
    DWORD       dwGroupNameLen = 0;
    LPWSTR      lpszGroupId = NULL;
    LPCWSTR     lpszGroupName = NULL;
    BOOL        bLocked = FALSE;

    //
    //  Chittur Subbaraman (chitturs) - 5/27/99
    //
    //  Restructure this GUM update as a local transaction.
    //
    dwGroupIdLen = pGumGroup->GroupIdLen;  
    dwGroupNameLen = pGumGroup->GroupNameLen;  
    lpszGroupId = pGumGroup->GroupId; 
    lpszGroupName = (PWSTR)((PCHAR)lpszGroupId +
                                   dwGroupIdLen );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateGroup: Entry for group %1!ws!...\n",
                lpszGroupId);
    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, Failed in starting a transaction for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        return( dwStatus );
    }

    //
    // Create the new group key.
    //
    hKey = DmLocalCreateKey( hXsaction,
                             DmGroupsKey,
                             lpszGroupId,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &dwDisposition );
                            
    if ( hKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, Failed in creating the group key for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;
    }
    
    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateGroup used GUID %1!ws! that already existed! This is impossible.\n",
                   lpszGroupId);
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    CL_ASSERT( dwDisposition == REG_CREATED_NEW_KEY );

    //
    // Set the group name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hKey,
                                CLUSREG_NAME_GRP_NAME,
                                REG_SZ,
                                ( CONST BYTE * ) lpszGroupName,
                                ( lstrlenW( lpszGroupName ) + 1 ) * 
                                    sizeof( WCHAR ) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateGroup: DmLocalSetValue for group %1!ws! fails, Status = %2!d!...\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;     
    }
    
    //
    // We really shouldn't be acquiring locks here... but
    // we'll try anyway. If we fail, we must return an error
    // because we have nothing to return.
    //
    FmpTryAcquireGroupLock( bLocked, 500 );
    if ( !bLocked ) 
    {
        pGumGroup->Group = NULL;
        dwStatus = ERROR_SHARING_VIOLATION;
        goto FnExit;
    }

    pGumGroup->Group = FmpCreateGroup( lpszGroupId, TRUE );
    
    if ( pGumGroup->Group == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateGroup, FmpCreateFroup failed for group %1!ws!, Status =%2!d!....\n",
                   lpszGroupId,
                   dwStatus);
        goto FnExit;
    } else 
    {
        if ( bSourceNode ) 
        {
            OmReferenceObject( pGumGroup->Group );
            OmReferenceObject( NmLocalNode );
            pNode = NmLocalNode;
        } else {
            lpszNodeId = (PWSTR)((PCHAR)lpszGroupId +
                                   dwGroupIdLen +
                                   dwGroupNameLen );
            pNode = OmReferenceObjectById( ObjectTypeNode, lpszNodeId );
            if ( pNode == NULL ) 
            {
                CL_LOGFAILURE( ERROR_CLUSTER_NODE_NOT_FOUND );
                dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
                ClRtlLogPrint(LOG_UNUSUAL,
                            "[FM] FmpUpdateCreateGroup, Could not find node for group %1!ws!, Status =%2!d!....\n",
                            lpszGroupId,
                            dwStatus);
                CsInconsistencyHalt( ERROR_CLUSTER_NODE_NOT_FOUND );
            }
        }

        CL_ASSERT( pGumGroup->Group->OwnerNode == NULL );

        if ( !FmpInPreferredList( pGumGroup->Group, pNode , FALSE, NULL) ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                        "[FM] FmpUpdateCreateGroup, node %1!ws! is not in preferred list for group %2!ws!.\n",
                         OmObjectId( pNode ),
                         OmObjectId( pGumGroup->Group ));
        }

        pGumGroup->Group->OwnerNode = pNode;
              
        if ( OmSetObjectName( pGumGroup->Group, lpszGroupName ) != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                        "[FM] FmpUpdateCreateGroup, Cannot set name for group %1!ws!...\n",
                        OmObjectId( pGumGroup->Group ));
        }
        
        ClusterEvent( CLUSTER_EVENT_GROUP_ADDED, pGumGroup->Group );
    }
                           
FnExit:
    if ( bLocked ) 
    {
        FmpReleaseGroupLock( );
    }
    
    if ( hKey != NULL ) 
    {
        DmCloseKey( hKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateGroup: Exit for group %1!ws!, Status=%2!u!...\n",
                lpszGroupId,
                dwStatus);

    return( dwStatus );
}

/****
@func       DWORD | FmpUpdateCompleteGroupMove | This update is made when
            FmpTakeGroupRequest fails with an RPC error.

@parm       IN BOOL | bSourceNode | Set to TRUE, if the update originated at 
            this node. Not used.
            
@parm       IN LPCWSTR | pszNodeId | The ID of the dead node.

@parm       IN LPCWSTR | pszGroupId | The ID of the group which was in the
            middle of the move.

@comm       The purpose of this update is to let the ownership of the
            group which was in the middle of the move determined consistently.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD
FmpUpdateCompleteGroupMove(
    IN BOOL     bSourceNode,
    IN LPCWSTR  pszNodeId,
    IN LPCWSTR  pszGroupId
    )
{
    PFM_GROUP   pGroup = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/2/2000
    // 
    //  If FM groups are not fully initialized, then  don't do anything.
    //  Don't check for shutdown since we need to handle take group
    //  exceptions for the quorum group even during a shutdown.
    //
    if ( !FmpFMGroupsInited ) 
    {
        return( ERROR_SUCCESS );
    }

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    pszGroupId );

    if ( !pGroup )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpUpdateCompleteGroupMove, %1!ws! group not found\n",
                   pszGroupId);
        goto FnExit;                   
    }

    //
    // Assign ownership to this group which was in the middle of a move
    //
    dwStatus = FmpAssignOwnersToGroups( pszNodeId, pGroup, NULL );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCompleteGroupMove failed with error %1!d!\n",
                   dwStatus);
    }                   
    
FnExit:           
    if ( pGroup ) OmDereferenceObject( pGroup );

    return( dwStatus );
}

DWORD
FmpUpdateCheckAndSetGroupOwner(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszGroupId,
    IN LPCWSTR lpszNodeId
    )
/*++

Routine Description:

    GUM update handler called from FmpTakeGroupRequest for NT5 cluster
    to set the group owner ONLY IF its intended owner is the future
    owner node.

Arguments:

    bSourceNode - Supplies whether or not this node was the source of the update

    lpszGroupId - Supplies the id of the resource whose state is changing

    lpszNodeId - Supplies the node id of the group owner.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP pGroup = NULL;
    DWORD     dwStatus = ERROR_SUCCESS;
    PNM_NODE  pNode = NULL;
    PNM_NODE  pPrevNode = NULL;

    //dont check for shutdown - we cant afford to lose ownership notifications
    //while we are shutting down
    //since we dont destroy any fm structures - there shouldnt be a problem in
    //handling these
    if ( !FmpFMGroupsInited ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCheckAndSetGroupOwner: Entry for Group = <%1!ws!>....\n",
              lpszGroupId);
    //
    //  Chittur Subbaraman (chitturs) - 7/27/99
    //
    //  This GUM handler sets the group ownership only if the future owner
    //  node is the group's intended owner. If the intended owner is NULL, 
    //  it means the node down processing GUM handler has taken charge 
    //  of this group. If the intended owner is not NULL and not the 
    //  future owner node, then it means that the node down processing 
    //  GUM handler has assigned ownership to the group and the group 
    //  started moving to a different target before the FmpTakeGroupRequest 
    //  that issued this GUM due as a part of the first move operation 
    //  got a chance to execute. In both cases, lay your hands off the 
    //  group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    lpszGroupId );

    if ( pGroup == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: GroupID = %1!ws! could not be found...\n",
                   lpszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    pNode = OmReferenceObjectById( ObjectTypeNode,
                                   lpszNodeId );

    if ( pNode == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: NodeID = %1!ws! could not be found, Group = %2!ws!...\n",
                   lpszNodeId,
                   lpszGroupId);
        dwStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
        goto FnExit;
    }

    if ( pGroup->pIntendedOwner != pNode )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCheckAndSetGroupOwner: Group = <%1!ws!> intended owner is invalid, not setting group ownership...\n",
                   lpszGroupId);
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }
    
    pPrevNode = pGroup->OwnerNode;

    //
    // Set the new owner node, incr ref count
    //
    OmReferenceObject( pNode );
    
    pGroup->OwnerNode = pNode;

    //
    // Decrement the ref count on previous owner
    //
    OmDereferenceObject( pPrevNode );

    //
    // Generate an event to signify group owner node change
    //
    ClusterEvent( CLUSTER_EVENT_GROUP_CHANGE, pGroup );
    
FnExit:
    if ( pGroup ) OmDereferenceObject( pGroup );
    
    if ( pNode ) OmDereferenceObject( pNode );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCheckAndSetGroupOwner: Exit for Group = <%1!ws!>, Status=%2!u!....\n",
              lpszGroupId,
              dwStatus);
    
    return( dwStatus );
}

DWORD
FmpUpdateCreateResourceType(
    IN PVOID Buffer    
    )
/*++

Routine Description:

    GUM update handler called for creating a resource type. For
    NT5.1 clusters, this GUM handler does both the registry and
    in-memory updates as a local transaction.

Arguments:

    Buffer - Buffer containing resource type information.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESTYPE         pResType = NULL;
    LPWSTR              lpszTypeName;
    LPWSTR              lpszDisplayName;
    LPWSTR              lpszDllName;
    DWORD               dwStatus = ERROR_SUCCESS;
    DWORD               dwLooksAlive;
    DWORD               dwIsAlive;
    DWORD               dwDllNameLen;
    DWORD               dwDisplayNameLen;
    DWORD               dwTypeNameLen;
    DWORD               dwClusterHighestVersion;
    DWORD               dwDisposition;
    HLOCALXSACTION      hXsaction = NULL;
    HDMKEY              hTypeKey = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 2/8/2000
    //
    //  Rewrite this GUM handler as a local transaction (for NT5.1 only)
    //
    lpszTypeName = ( LPWSTR ) Buffer;

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpUpdateCreateResourceType, Entry for resource type %1!ws!...\n",
               lpszTypeName);       

    pResType = OmReferenceObjectById( ObjectTypeResType,
                                      lpszTypeName );
    if ( pResType )
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Resource type %1!ws! already exists, Status = %2!d!...\n",
                  lpszTypeName,
                  dwStatus);       
        OmDereferenceObject( pResType );
        return( dwStatus );
    }

    dwTypeNameLen = ( lstrlenW( lpszTypeName ) + 1 ) * sizeof( WCHAR );

    lpszDisplayName = ( LPWSTR ) ( ( PCHAR ) Buffer + dwTypeNameLen );

    dwDisplayNameLen = ( lstrlenW( lpszDisplayName ) + 1 ) * sizeof( WCHAR );

    lpszDllName = ( LPWSTR ) ( ( PCHAR ) Buffer +
                               dwTypeNameLen +
                               dwDisplayNameLen );

    dwDllNameLen = ( lstrlenW( lpszDllName ) + 1 ) * sizeof( WCHAR );

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION ) 
    {   
        goto skip_registry_updates;
    }

    dwLooksAlive = *( DWORD UNALIGNED * ) ( ( ( PCHAR ) Buffer +
                               dwTypeNameLen +
                               dwDisplayNameLen + 
                               dwDllNameLen ) );
                              
    dwIsAlive = *( DWORD UNALIGNED * ) ( ( ( PCHAR ) Buffer +
                            dwTypeNameLen +
                            dwDisplayNameLen + 
                            dwDllNameLen + 
                            sizeof( DWORD ) ) );

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in starting a transaction for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);
        return( dwStatus );
    }

    hTypeKey = DmLocalCreateKey( hXsaction,
                                 DmResourceTypesKey,
                                 lpszTypeName,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &dwDisposition );
    if ( hTypeKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in creating the resource types key for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);       
        goto FnExit;
    }

    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Duplicate resource types key exists for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_DLL_NAME,
                                REG_SZ,
                                ( CONST BYTE * )lpszDllName,
                                dwDllNameLen );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the DLL name for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_IS_ALIVE,
                                REG_DWORD,
                                ( CONST BYTE * )&dwIsAlive,
                                sizeof( DWORD ) );


    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the Is Alive interval for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                                REG_DWORD,
                                ( CONST BYTE * )&dwLooksAlive,
                                sizeof( DWORD ) );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the Looks Alive interval for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hTypeKey,
                                CLUSREG_NAME_RESTYPE_NAME,
                                REG_SZ,
                                ( CONST BYTE * )lpszDisplayName,
                                dwDisplayNameLen );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateCreateResourceType, Failed in setting the display name for resource type %1!ws!, Status =%2!d!....\n",
                   lpszTypeName,
                   dwStatus);              
        goto FnExit;
    }
    
skip_registry_updates:
    pResType = FmpCreateResType( lpszTypeName );

    if ( pResType != NULL ) 
    {
        dwStatus = FmpRmLoadResTypeDll( pResType );
        if ( dwStatus == ERROR_SUCCESS )
        {
            pResType->State = RESTYPE_STATE_LOADS;
        } else
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpUpdateCreateResourceType: Unable to load dll for resource type %1!ws!, Status=%2!u!...\n",
                       lpszTypeName,
                       dwStatus);
            //
            //  Some nodes may not support this resource type. So, consider
            //  the loading failure as success. However, log the error.
            //
            dwStatus = ERROR_SUCCESS;
        }
    } else
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpUpdateCreateResourceType: Unable to create resource type %1!ws!, Status=%2!u!...\n",
                   lpszTypeName,
                   dwStatus);
    }

FnExit:
    if ( hTypeKey != NULL ) 
    {
        DmCloseKey( hTypeKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResourceType: Exit for resource type %1!ws!, Status=%2!u!...\n",
                lpszTypeName,
                dwStatus);

    return( dwStatus ); 
}

DWORD
FmpUpdateCreateResource(
    IN OUT PGUM_CREATE_RESOURCE pGumResource
    )
{
/*++

Routine Description:

    GUM update handler called for creating a resource. For
    NT5.1 clusters, this GUM handler does both the registry and
    in-memory updates as a local transaction.

Arguments:

    pGumResource - Structure containing resource information.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
    DWORD       dwStatus = ERROR_SUCCESS;
    HDMKEY      hResourceKey = NULL;
    HDMKEY      hGroupKey = NULL;
    DWORD       dwDisposition;
    HLOCALXSACTION      
                hXsaction = NULL;
    DWORD       dwClusterHighestVersion;
    PGUM_CREATE_RESOURCE GumResource;
    LPWSTR      lpszResourceId = NULL;
    LPWSTR      lpszResourceName = NULL;
    LPWSTR      lpszResourceType = NULL;
    PFM_GROUP   pGroup = NULL;
    PFM_RESTYPE pResType = NULL;
    DWORD       dwpollIntervals = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
    DWORD       dwPersistentState = 0;
    DWORD       dwResourceTypeLen = 0;
    DWORD       dwFlags = 0;
    HDMKEY      hParamKey = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 1/30/2000
    //
    //  Restructure this GUM update as a local transaction.
    //

    lpszResourceId = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                       pGumResource->GroupIdLen );

    lpszResourceName = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen );

    pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                    pGumResource->GroupId );

    if ( pGroup == NULL ) 
    {
        CL_LOGFAILURE( ERROR_GROUP_NOT_FOUND );
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: Group for resource %1!ws! not found.\n",
                   lpszResourceId);
        return( ERROR_GROUP_NOT_FOUND );
    }
 
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Entry for resource %1!ws!...\n",
                lpszResourceId);
    //
    //  If we are dealing with the mixed mode cluster, don't bother to
    //  do these registry updates since the API layer would do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Skipping registry updates for resource %1!ws!...\n",
                lpszResourceId);
        goto skip_registry_updates;
    }

    dwResourceTypeLen = *( DWORD UNALIGNED * )( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen +
                                         (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) );

    lpszResourceType = (LPWSTR)( (PCHAR) pGumResource->GroupId +
                                         pGumResource->GroupIdLen +
                                         pGumResource->ResourceIdLen +
                                         (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) + 
                                         sizeof( DWORD ) );
    
    dwFlags = *( DWORD UNALIGNED * )( (PCHAR) pGumResource->GroupId +
                               pGumResource->GroupIdLen +
                               pGumResource->ResourceIdLen +
                               (lstrlenW(lpszResourceName)+1) * sizeof(WCHAR) +
                               sizeof( DWORD ) + 
                               dwResourceTypeLen );

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateResource, Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        OmDereferenceObject( pGroup );
        return( dwStatus );
    }

    //
    // Create the new resources key.
    //
    hResourceKey = DmLocalCreateKey( hXsaction,
                                     DmResourcesKey,
                                     lpszResourceId,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &dwDisposition );
                            
    if ( hResourceKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                  "[FM] FmpUpdateCreateResource, Failed in creating the resource key for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
    if ( dwDisposition != REG_CREATED_NEW_KEY ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource used GUID %1!ws! that already existed! This is impossible.\n",
                   lpszResourceId);
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    CL_ASSERT( dwDisposition == REG_CREATED_NEW_KEY );

    //
    // Set the resource name in the registry
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_NAME,
                                REG_SZ,
                                (CONST BYTE *)lpszResourceName,
                                (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR) );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (resource name) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;     
    }

    //
    // Set the resource's type in the registry
    // Note we reference the resource type and use its ID
    // so that the case is correct.
    //
    pResType = OmReferenceObjectById( ObjectTypeResType, lpszResourceType );
    CL_ASSERT( pResType != NULL );
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_TYPE,
                                REG_SZ,
                                (CONST BYTE *) OmObjectId( pResType ),
                                (lstrlenW( lpszResourceType ) + 1 )*sizeof(WCHAR) );
    OmDereferenceObject( pResType );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (resource type) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Set the resource's poll intervals in the registry.
    //
    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_LOOKS_ALIVE,
                                REG_DWORD,
                                (CONST BYTE *)&dwpollIntervals,
                                4 );
                              
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (looks alive) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    dwStatus = DmLocalSetValue( hXsaction,
                                hResourceKey,
                                CLUSREG_NAME_RES_IS_ALIVE,
                                REG_DWORD,
                                (CONST BYTE *)&dwpollIntervals,
                                4);

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (is alive) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // If this resource should be started in a separate monitor, set that
    // parameter now.
    //
    if ( dwFlags & CLUSTER_RESOURCE_SEPARATE_MONITOR ) 
    {
        DWORD dwSeparateMonitor = 1;

        dwStatus = DmLocalSetValue( hXsaction,
                                    hResourceKey,
                                    CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                    REG_DWORD,
                                    (CONST BYTE *)&dwSeparateMonitor,
                                    sizeof( dwSeparateMonitor ) );
                                  
        if ( dwStatus != ERROR_SUCCESS) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (separate monitor) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
            goto FnExit;
        }
    }

    //
    // Create a Parameters key for the resource.
    //
    hParamKey = DmLocalCreateKey( hXsaction,
                                  hResourceKey,
                                  CLUSREG_KEYNAME_PARAMETERS,                   
                                  0,
                                  KEY_READ,
                                  NULL,
                                  &dwDisposition );
    if ( hParamKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalCreateKey (parameters) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        CL_LOGFAILURE( dwStatus );
        goto FnExit;
    } else 
    {
        DmCloseKey( hParamKey );
    }

    hGroupKey = DmOpenKey( DmGroupsKey, 
                           OmObjectId(pGroup), 
                           KEY_READ | KEY_WRITE);

    if ( hGroupKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmOpenKey (group key) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 5/25/99
    //
    //  Make sure you set the persistent state of the resource to 
    //  ClusterResourceOffline before you create the resource. If
    //  this is not done, if you create a resource in a group which
    //  is online, the group's persistent state value (i.e., 1 in
    //  this case) is inherited by the resource in FmpQueryResourceInfo
    //  (only the memory state is set and not the registry state and
    //  this was a problem as well) and if you move such a group to 
    //  another node, it will bring the newly created resource online.
    //
    dwStatus = DmLocalSetValue(  hXsaction,
                                 hResourceKey,
                                 CLUSREG_NAME_RES_PERSISTENT_STATE,
                                 REG_DWORD,
                                 ( CONST BYTE * )&dwPersistentState,
                                 sizeof( DWORD ) );
                         
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalSetValue (persistent state) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
         goto FnExit;
    }

    //
    // Add the resource to the Contains value of the specified group.
    //      
    dwStatus = DmLocalAppendToMultiSz( hXsaction,
                                       hGroupKey,
                                       CLUSREG_NAME_GRP_CONTAINS,
                                       lpszResourceId );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: DmLocalAppendToMultiSz (contains key) for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }
    
skip_registry_updates:
    FmpAcquireResourceLock();

    pGumResource->Resource = FmpCreateResource( pGroup,
                                                lpszResourceId,
                                                lpszResourceName,
                                                FALSE );
                                               
    if ( pGumResource->Resource == NULL ) 
    {
       dwStatus = GetLastError();
       ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpUpdateCreateResource: FmpCreateResource for resource %1!ws! fails, Status = %2!d!...\n",
                   lpszResourceId,
                   dwStatus);      
    } else 
    {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
                                  pGroup );
        ClusterEvent( CLUSTER_EVENT_RESOURCE_ADDED,
                                  pGumResource->Resource );
        if ( pGumResource->Resource ) 
        {
            OmReferenceObject( pGumResource->Resource );
            FmpPostWorkItem( FM_EVENT_RESOURCE_ADDED,
                             pGumResource->Resource,
                             0 );
        }
    }

    FmpReleaseResourceLock();

FnExit:
    if ( pGroup != NULL )
    {
        OmDereferenceObject( pGroup );
    }
    
    if ( hResourceKey != NULL ) 
    {
        DmCloseKey( hResourceKey );
    }

    if ( hGroupKey != NULL ) 
    {
        DmCloseKey( hGroupKey );
    }

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateCreateResource: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
}

DWORD
FmpUpdateDeleteResource(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId
    )
/*++

Routine Description:

    GUM dispatch routine for deleting a resource.  For NT5.1 clusters, this is structured as
    as local transaction.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    lpszResourceId - Supplies the resource ID.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/
{
    PFM_RESOURCE    pResource = NULL;
    PFM_GROUP       pGroup = NULL;
    PLIST_ENTRY     pListEntry = NULL;
    PDEPENDENCY     pDependency = NULL;
    PPOSSIBLE_ENTRY pPossibleEntry = NULL;
    DWORD           dwStatus;
    HLOCALXSACTION      
                    hXsaction = NULL;
    DWORD           dwClusterHighestVersion;
    HDMKEY          pGroupKey;

    //
    //  Chittur Subbaraman (chitturs) - 9/7/2000
    //  
    //  Structure this GUM update as a local transaction.
    //
    
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return( ERROR_SUCCESS );
    }

    pResource = OmReferenceObjectById( ObjectTypeResource, lpszResourceId );
    
    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                     "[FM] FmpUpdateDeleteResource: Resource %1!ws! cannot be found....\n",
                     lpszResourceId );
        return( ERROR_RESOURCE_NOT_FOUND );
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpUpdateDeleteResource: Delete resource %1!ws!, address %2!lx!....\n",
                 lpszResourceId,
                 pResource );

    //
    //  NOTE: It is difficult to include the checkpoint removal in a local transaction, so keep it 
    //  out for now.  Also, note that these functions MUST be called BEFORE the Resources key is
    //  deleted since they enumerate the values under "Resources\RegSync" and "Resources\CryptoSync".
    //
    if ( pResource->Group->OwnerNode == NmLocalNode ) 
    {
        CpckRemoveResourceCheckpoints( pResource );
        CpRemoveResourceCheckpoints( pResource );
    }

    //
    // Start a transaction
    //
    hXsaction = DmBeginLocalUpdate();

    if ( !hXsaction )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Failed in starting a transaction for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);
        goto FnExit;
    }

    //
    // Cannot acquire group lock here to avoid deadlocks with this current design.
    //
    
    //
    // Remove all registry entries corresponding to the DependsOn list.
    //
    pListEntry = pResource->DependsOn.Flink;
    while ( pListEntry != &pResource->DependsOn ) 
    {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         DependentLinkage );
        CL_ASSERT( pDependency->DependentResource == pResource );
        pListEntry = pListEntry->Flink;
        //
        //  Note that the removal of registry entries is done as a local transaction.
        //
        dwStatus = FmpRemoveResourceDependency( hXsaction, 
                                                pResource,
                                                pDependency->ProviderResource );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Unable to remove 'DependsOn' registry entries for resource %1!ws!, Status =%2!d!....\n",
                   lpszResourceId,
                   dwStatus);   
            goto FnExit;
        }
    }

    //
    // Remove all registry entries corresponding to the ProvidesFor list.
    //
    pListEntry = pResource->ProvidesFor.Flink;
    while ( pListEntry != &pResource->ProvidesFor ) 
    {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         ProviderLinkage );
        CL_ASSERT( pDependency->ProviderResource == pResource );
        pListEntry = pListEntry->Flink;
        //
        //  Note that the removal of registry entries is done as a local transaction.
        //
        dwStatus = FmpRemoveResourceDependency( hXsaction, 
                                                pDependency->DependentResource,
                                                pResource );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpUpdateDeleteResource: Unable to remove 'ProvidesFor' registry entries for resource %1!ws!, Status=%2!d!....\n",
                   lpszResourceId,
                   dwStatus);   
            goto FnExit;
        }
    }

    //
    //  If we are dealing with a Whistler-Win2K cluster, don't bother to
    //  do these registry updates since the API layer would do it.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateDeleteResource: Skipping registry updates for resource %1!ws!...\n",
                lpszResourceId);
        goto skip_registry_updates;
    }

    dwStatus = DmLocalDeleteTree( hXsaction, 
                                  DmResourcesKey, 
                                  OmObjectId( pResource ) );

    if ( ( dwStatus != ERROR_SUCCESS ) &&
         ( dwStatus != ERROR_FILE_NOT_FOUND ) ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateDeleteResource: Unable to remove 'Resources' tree for resource %1!ws!, Status=%2!d!....\n",
                      lpszResourceId,
                      dwStatus);   
        goto FnExit;
    }

    pGroupKey = DmOpenKey( DmGroupsKey,
                           OmObjectId( pResource->Group ),
                           KEY_READ | KEY_SET_VALUE );

    if ( pGroupKey == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateDeleteResource: Unable to find 'Groups' key for resource %1!ws!, Status=%2!d!....\n",
                      lpszResourceId,
                      dwStatus);   
        goto FnExit;
    }

    dwStatus = DmLocalRemoveFromMultiSz( hXsaction,
                                         pGroupKey,
                                         CLUSREG_NAME_GRP_CONTAINS,
                                         OmObjectId( pResource ) );

    DmCloseKey( pGroupKey );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                     "[FM] FmpUpdateDeleteResource: Unable to remove contains list for resource %1!ws! in group %2!ws!, Status=%3!d!....\n",
                      lpszResourceId,
                      OmObjectId( pResource->Group ),
                      dwStatus);   
        goto FnExit;
    }
    
skip_registry_updates:
    //
    // Remove all list entries corresponding to the DependsOn list.
    //
    pListEntry = pResource->DependsOn.Flink;
    while ( pListEntry != &pResource->DependsOn ) {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         DependentLinkage );
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDependency->ProviderLinkage );
        RemoveEntryList( &pDependency->DependentLinkage );
        OmDereferenceObject( pDependency->DependentResource );
        OmDereferenceObject( pDependency->ProviderResource );
        LocalFree( pDependency );
    }

    //
    // Remove all list entries corresponding to the ProvidesFor list.
    //
    pListEntry = pResource->ProvidesFor.Flink;
    while ( pListEntry != &pResource->ProvidesFor ) {
        pDependency = CONTAINING_RECORD( pListEntry,
                                         DEPENDENCY,
                                         ProviderLinkage );
        pListEntry = pListEntry->Flink;
        RemoveEntryList( &pDependency->ProviderLinkage );
        RemoveEntryList( &pDependency->DependentLinkage );
        OmDereferenceObject( pDependency->DependentResource );
        OmDereferenceObject( pDependency->ProviderResource );
        LocalFree( pDependency );
    }
    
    //
    // Remove all entries from the possible owners list.
    //
    while ( !IsListEmpty( &pResource->PossibleOwners ) ) 
    {
        pListEntry = RemoveHeadList( &pResource->PossibleOwners );
        pPossibleEntry = CONTAINING_RECORD( pListEntry,
                                            POSSIBLE_ENTRY,
                                            PossibleLinkage );
        OmDereferenceObject( pPossibleEntry->PossibleNode );
        LocalFree( pPossibleEntry );
    }

    //
    // Remove this resource from the Contains list.
    //
    RemoveEntryList( &pResource->ContainsLinkage );

    OmDereferenceObject( pResource );

    //
    // Close the resource's registry key.
    //
    DmRundownList( &pResource->DmRundownList );
    if ( pResource->RegistryKey != NULL ) 
    {
        DmCloseKey( pResource->RegistryKey );
        pResource->RegistryKey = NULL;
    }

    //
    // SS: we do not delete the reference to the resource here
    // since we will shortly have to add one before posting a notification
    // to the fm worker thread.
    //
    // Post a work item to close the resource in the resource handler.
    // Note that this must be done asynchronously as we cannot call
    // the resource monitor from a GUM handler. If we do, resources
    // do funny things and make deadlocks.
    //
    FmpPostWorkItem( FM_EVENT_RESOURCE_DELETED, pResource, 0 );

    //
    // Decrement resource type reference.
    //
    if ( pResource->Type != NULL ) {
        OmDereferenceObject( pResource->Type );
        pResource->Type = NULL;
    }

    //
    // Remove the resource from the resource list.
    //
    dwStatus = OmRemoveObject( pResource );

    ClusterEvent( CLUSTER_EVENT_RESOURCE_DELETED, pResource );
    ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
                  pResource->Group );

    //
    // Mark the resource as deleted
    //
    pResource->dwStructState = FM_RESOURCE_STRUCT_MARKED_FOR_DELETE;

FnExit:
    OmDereferenceObject( pResource );

    if ( ( dwStatus == ERROR_SUCCESS ) && 
         ( hXsaction != NULL ) )
    {
        DmCommitLocalUpdate( hXsaction );
    }
    else
    {
        if ( hXsaction ) DmAbortLocalUpdate( hXsaction );
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpUpdateDeleteResource: Exit for resource %1!ws!, Status=%2!u!...\n",
                lpszResourceId,
                dwStatus);

    return( dwStatus );
} // FmpUpdateDeleteResource

DWORD
FmpUpdateUseRandomizedNodeListForGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    )
/*++

Routine Description:

    GUM dispatch routine for using a randomized preferred list for group ownership on
    node down.

Arguments:

    bSourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    pszNodeId - Supplies the ID of the node that is down.

    pGroupNodeList - Randomized preferred node list for groups.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       dwNodeId;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2001
    // 
    //  If FM groups are not fully initialized or FM is shutting down, then
    //  don't do anything.
    //
    if ( !FmpFMGroupsInited || FmpShutdown ) 
    {
        return( ERROR_SUCCESS );
    }

    //
    //  In a node evict, the NM GUM handler gets rids of the dead node from the OM list.
    //  This node down FM GUM handler could follow the NM evict GUM handler since NM
    //  lets an evict through once *it* declares a node as down. At that time, there is no
    //  guarantee that the FM node down GUM has executed since that GUM is issued in the
    //  async phase of node down processing and could very well follow the NM evict GUM
    //  handler.  Thus, this GUM handler and associated functions CANNOT call OM to get
    //  a node object from the node ID string.  Thus, this GUM handler and associated
    //  functions are carefully written to work with a node ID as opposed to a node object.
    //
    dwNodeId = wcstoul( pszNodeId, NULL, 10 );
    
    //
    // If this update has already been seen after the node down, ignore this one
    //
    if ( gFmpNodeArray[dwNodeId].dwNodeDownProcessingInProgress == 0 )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpUpdateUseRandomizedNodeListForGroups: %1!ws! node down has been processed already...\n",
                      pszNodeId);
        goto FnExit;                   
    }

    //
    // Assign ownership to all groups owned by the dead node
    //
    dwStatus = FmpAssignOwnersToGroups( pszNodeId, 
                                        NULL,
                                        pGroupNodeList );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpdateUseRandomizedNodeListForGroups: FmpAssignOwnersToGroups failed %1!d!\n",
                      dwStatus);
    }                   

    //
    // Mark that the node down processing has been done
    //
    gFmpNodeArray[dwNodeId].dwNodeDownProcessingInProgress = 0;
    
FnExit:        
    return( dwStatus );
}// FmpUpdateUseRandomizedNodeListForGroups
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\dllupgd.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    DllUpgd.c

Abstract:

    Routines for supporting resource DLL upgrade.

Author:

    Chittur Subbaraman (chitturs) 18-March-2001

Revision History:

    18-March-2001       Created

--*/
#include "fmp.h"
#include "strsafe.h"

//
//  Defines used locally within this module
//
#define CLUSTER_RESDLL_BACKUP_FILE_EXTENSION    L".~WFPKDLLBKP$"
#define CLUSTER_RESDLL_RENAMED_FILE_EXTENSION   L".~WFPKDLLOLD$"
#define CLUSTER_RESDLL_BACKUP_FILES             L".~WFPKDLL*$"


DWORD
FmpUpgradeResourceDLL(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszInstallationPath
    )

/*++

Routine Description:

    Upgrades a resource DLL currently loaded in one or more monitors.

Arguments:

    pResource - A resource of the type implemented by the DLL.

    lpszInstallationPath - The full installation path of the DLL (including the full DLL name with
        extension)

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPWSTR          lpszNewDllName = NULL;
    LPWSTR          lpszCurrentDllPath = NULL;

    //
    //  Get the DLL file name from the installation path. Also, get rid of any trailing '\' in
    //  the supplied path.
    //
    //  IMPORTANT: Note that lpszNewDLLName points into lpszInstallationPath buffer and so
    //  we should not modify the lpszInstallation path buffer (there is really no reason to
    //  do that) while we use lpszNewDllName.
    //
    dwStatus = FmpParsePathForFileName( lpszInstallationPath,
                                        TRUE,   // Check for path existence
                                        &lpszNewDllName );

    //
    //  If the parse fails or if the supplied "path" is a filename, bail.
    //
    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszNewDllName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Unable to parse supplied path %1!ws! for file name, Status=%2!u!\n",
                      (lpszInstallationPath == NULL) ? L"NULL":lpszInstallationPath,
                      dwStatus);
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpUpgradeResourceDLL: Installation path %1!ws!, resource [%2!ws!] %3!ws!\n",
                  lpszInstallationPath,
                  OmObjectName(pResource),
                  OmObjectId(pResource));

    //
    //  Validate the supplied parameters. If validation is successful, get the full path of the
    //  currently loaded DLL.
    //
    dwStatus = FmpValidateResourceDLLReplacement( pResource, 
                                                  lpszNewDllName,
                                                  &lpszCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Validation for resource DLL replacement failed, Status=%1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Acquire the monitor lock so as to serialize one resource DLL upgrade process with
    //  others as well as with monitor restarts.
    //
    FmpAcquireMonitorLock();

    //
    //  Now, replace the DLL with the supplied DLL in a recoverable fashion.
    //
    dwStatus = FmpReplaceResourceDLL( lpszNewDllName,
                                      lpszCurrentDllPath,
                                      lpszInstallationPath );
  
    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Replacement of resource DLL failed, Status=%1!u!\n",
                      dwStatus);
        goto FnReleaseLockAndExit;
    }
    
    //
    //  Shutdown and restart the monitors that have the resource DLL loaded.
    //
    dwStatus = FmpRecycleMonitors( lpszNewDllName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpUpgradeResourceDLL: Recycling of resource DLL failed, Status=%1!u!\n",
                      dwStatus);
        goto FnReleaseLockAndExit;
    }

    //
    //  Attempt deletion of backup files in case all the steps are successful so far. Note that
    //  this attempt is necessary here since it is not possible to delete the .old file
    //  before we recycle the monitors since the monitors hold references to the DLL.
    //
    FmpDeleteBackupFiles ( lpszCurrentDllPath );  //  Delete backup files

FnReleaseLockAndExit:
    FmpReleaseMonitorLock();

FnExit:
    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpUpgradeResourceDLL: Exit with status %1!u!...\n",
                  dwStatus);
    LocalFree ( lpszCurrentDllPath );
    return ( dwStatus );   
} //  FmpUpgradeResourceDLL

DWORD
FmpParsePathForFileName(
    IN LPWSTR lpszPath,
    IN BOOL fCheckPathExists,
    OUT LPWSTR *ppszFileName
    )

/*++

Routine Description:

    Get the name of the file at the end of a supplied path.

Arguments:

    lpszPath - A path including the file name.

    fCheckPathExists - Check if the path exists.

    ppszFileName - The name of the file parsed from the path.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.

Note:

    This function will get rid of any trailing '\' in the supplied path. Also, this function
    will return a file name only if the input supplied is a valid path, else NULL file name
    will be returned.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LPWSTR      s;

    *ppszFileName = NULL;
   
    //
    //  Check for invalid parameter.
    //
    if ( lpszPath == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpParsePathForFileName: Input param is NULL, Status=%1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Make sure the last character is NULL if it is a '\'. This is to avoid getting confused
    //  with paths such as C:\windows\cluster\clusres.dll\
    //
    if ( lpszPath[lstrlen ( lpszPath ) - 1] == L'\\' ) lpszPath[lstrlen ( lpszPath ) - 1] = L'\0';
    
    //
    //  Parse the supplied path and look for the last occurrence of '\'. If there is no '\' at all,
    //  may be the caller supplied a file name, bail with NULL out param but with success status.
    //
    s = wcsrchr( lpszPath, L'\\' );

    if ( s == NULL )
    {
        goto FnExit;
    }

    //
    //  If the supplied parameter is a path (as opposed to a plain file name) and the caller
    //  requested to check for validity, do so.
    //
    if ( fCheckPathExists && !ClRtlPathFileExists( lpszPath ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpParsePathForFileName: Path %1!ws! does not exist, Status=%2!u!\n",
                      lpszPath,
                      dwStatus);       
        goto FnExit;
    }
    
    //
    //  Return the pointer to the char after the last '\'.
    //
    s++;
    *ppszFileName = s;

FnExit:
    return ( dwStatus );
}// FmpParsePathForFileName

DWORD
FmpValidateResourceDLLReplacement(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszNewDllName,
    OUT LPWSTR *ppszCurrentDllPath
    )

/*++

Routine Description:

    Validate the resource DLL replacement request.

Arguments:

    pResource - The resource which is implemeted by the DLL.
    
    lpszNewDllName - The name of the DLL.

    ppszCurrentDllPath - The full path of the currently loaded DLL.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LPWSTR      lpszDllName = NULL;
    LPWSTR      lpszDLLNameOfRes = NULL;
    BOOL        fDllPathFound = TRUE;
    DWORD       cchDllName;

    //
    //  Initialize return value
    //
    *ppszCurrentDllPath = NULL;

    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //
    //  IMPORTANT: Do not write stuff into szDllNameOfRes while lpszDllName is being used
    //  since lpszDllName points inside szDllNameOfRes.
    //
    cchDllName = lstrlen ( pResource->Type->DllName ) + 1;

    lpszDLLNameOfRes = LocalAlloc ( LPTR, cchDllName * sizeof ( WCHAR ) );

    if ( lpszDLLNameOfRes == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: Memory alloc for dll name %1!ws! failed, Status %2!u!\n",
                      pResource->Type->DllName,
                      dwStatus);                                                        
        goto FnExit;
    }
    
    ( void ) StringCchCopy( lpszDLLNameOfRes, cchDllName, pResource->Type->DllName );
    
    dwStatus = FmpParsePathForFileName ( lpszDLLNameOfRes, 
                                         TRUE,  // Check for path existence
                                         &lpszDllName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      lpszDLLNameOfRes,
                      dwStatus);                                                        
        goto FnExit;
    }

    //
    //  If the dll information in the resource type structure is a file name, then you need to
    //  search the path to find the full path of the DLL. Otherwise, you can merely copy the
    //  information from the resource type structure and expand any environment strings in it.
    //
    if ( lpszDllName == NULL ) 
    {
        lpszDllName = pResource->Type->DllName;
        fDllPathFound = FALSE;
    } else
    {      
        //
        // Expand any environment variables included in the DLL path name.
        //
        *ppszCurrentDllPath = ClRtlExpandEnvironmentStrings( pResource->Type->DllName );

        if ( *ppszCurrentDllPath == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpValidateResourceDLLReplacement: Resource's DLL name %1!ws! cannot be expanded, Status=%2!u!\n",
                   pResource->Type->DllName,
                   dwStatus);       
            goto FnExit;
        }
    }
    
    if ( lstrcmpi( lpszDllName, lpszNewDllName ) != 0 ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpValidateResourceDLLReplacement: Resource's DLL name %1!ws! does not match supplied name, Status=%2!u!\n",
                     lpszDllName,
                     dwStatus);       
        goto FnExit;    
    }

    //
    //  Search all the paths specified in the environment variable and get the full current
    //  path of the DLL that is loaded into the monitor.
    //
    if ( fDllPathFound == FALSE )
    {
        DWORD   cchPathLen;
        
        //
        // First find the size of the buffer needed to hold the full path
        //
        if ( ( cchPathLen = SearchPath ( NULL,                        // Search all paths as LoadLibrary does
                                         lpszNewDllName,              // File name to search for
                                         NULL,                        // No extension required
                                         0,                           // Size of out buffer
                                         NULL,                        // Buffer to receive full Dll path with file name
                                         NULL ) ) == 0 )              // Filename at the end of the path
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpValidateResourceDLLReplacement: SearchPath API (1st time) for file %1!ws! failed, Status=%2!u!\n",
                         lpszNewDllName,
                         dwStatus);          
            goto FnExit;
        }

        *ppszCurrentDllPath = LocalAlloc ( LPTR, cchPathLen * sizeof ( WCHAR ) );

        if ( *ppszCurrentDllPath == NULL )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpValidateResourceDLLReplacement: Memory alloc for path failed, Status=%1!u!\n",
                         dwStatus);          
            goto FnExit;
        }
        //
        // Now find the full path
        //
        if ( !SearchPath ( NULL,                        // Search all paths as LoadLibrary does
                           lpszNewDllName,              // File name to search for
                           NULL,                        // No extension required
                           cchPathLen,                  // Size of out buffer
                           *ppszCurrentDllPath,         // Buffer to receive full Dll path with file name
                           NULL ) )                     // Filename at the end of the path
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpValidateResourceDLLReplacement: SearchPath API (2nd time) for file %1!ws! failed, Status=%2!u!\n",
                         lpszNewDllName,
                         dwStatus);          
            goto FnExit;
        }
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpValidateResourceDLLReplacement: Current resource DLL full path %1!ws!\n",
                 *ppszCurrentDllPath);       

FnExit:
    LocalFree ( lpszDLLNameOfRes );
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        LocalFree ( *ppszCurrentDllPath );
        *ppszCurrentDllPath = NULL;
    }
    return ( dwStatus ); 
}// FmpValidateResourceDLLReplacement

DWORD
FmpReplaceResourceDLL(
    IN LPWSTR lpszNewDllName,
    IN LPWSTR lpszCurrentDllPath,
    IN LPWSTR lpszInstallationPath
    )

/*++

Routine Description:

    Replace the resource DLL with the one from the install path.

Arguments:
   
    lpszNewDllName - The name of the DLL.

    lpszCurrentDllPath - The full path of the currently loaded DLL.

    lpszInstallationPath - The installation path of the DLL.

Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    HKEY        hClussvcParamsKey = NULL;
    DWORD       cbListSize = 0, cchLen = 0;
    LPWSTR      lpmszUpgradeList = NULL;
    WCHAR       szBakFile[MAX_PATH], szOldFile[MAX_PATH];
    WCHAR       szClusterDirectory[MAX_PATH];
    DWORD       dwType, dwLen;

    //
    //
    //  This function works as follows. First we make a copy of the existing resource DLL file
    //  to a file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION extension. Then we set the registry
    //  value under the clussvc parameters key to indicate that an upgrade is starting. After
    //  this, the existing DLL file is renamed. If all steps are successful so far, we copy
    //  new DLL file from the supplied path. Once this is successful, the registry value set
    //  above is deleted.
    //
    //  This algorithm gives us the following guarantees:
    //
    //  1. If the registry value is set, then a good backup file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION
    //     must exist.
    //
    //  2. If the registry value is not set, then the existing DLL file was not touched by
    //     the upgrade process or the DLL upgrade was completely successful.
    //
    //  Thus, only if the registry value is set at the time FmpCreateMonitor is invoked, it
    //  will go through the elaborate recovery process implemented in FmpRecoverResourceDLLFiles.
    //  At recovery time, we can be sure that the backup file with CLUSTER_RESDLL_BACKUP_FILE_EXTENSION 
    //  is a perfectly good backup. Also, at recovery time we cannot be sure of the state (good/bad)
    //  of the existing DLL file (if it exists at all) or the renamed file with 
    //  CLUSTER_RESDLL_RENAMED_FILE_EXTENSION. So, the recovery process is pessimistic and just
    //  copies the backup file wit CLUSTER_RESDLL_BACKUP_FILE_EXTENSION over any existing DLL
    //  file.
    //
    //  Sideeffect: Even if the registry value is not set, there could be a stale backup file
    //  left. Thus wheneever FmpCreateMonitor is invoked, it has to cleanup those files.
    //  This is done by invoking FmpDeleteBackupFiles(NULL) from FmpRecoverResourceDLLFiles.
    //
    
    //
    //  Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClussvcParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegOpenKeyEx on %1!ws! failed, Status=%2!u!\n",
                     CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                     dwStatus);             
        goto FnExit;
    }

    //
    //  See whether a past failed upgrade has left any values in the upgrade progress list
    //
    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 NULL,
                                 &cbListSize );

    if ( ( dwStatus != ERROR_SUCCESS ) &&
         ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegQueryValueEx (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                
        goto FnExit;
    }

    if ( cbListSize != 0 )
    {
        //
        //  Found some values left out from past upgrade. Read those values.
        //
        lpmszUpgradeList = LocalAlloc ( LPTR, cbListSize );

        if ( lpmszUpgradeList == NULL )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Mem alloc failure, Status=%1!u!\n",
                      dwStatus);                       
            goto FnExit;
        }

        dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                     CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                     0,
                                     &dwType,
                                     ( LPBYTE ) lpmszUpgradeList,
                                     &cbListSize );

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpReplaceResourceDLL: RegQueryValueEx (2nd time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                          CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                          dwStatus);                       
            goto FnExit;
        }       
    }

    //
    //  Check whether a failed upgrade of the same DLL has occurred in the past.
    //
    if ( ClRtlMultiSzScan( lpmszUpgradeList,
                           lpszCurrentDllPath ) != NULL )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzScan detected %1!ws! in the multi-sz, skip append...\n",
                      lpszCurrentDllPath);                          
        goto skip_multisz_append;
    }
    
    //
    //  Append the current DLL path to the REG_MULTI_SZ
    //
    cchLen = cbListSize/sizeof( WCHAR );
    
    dwStatus = ClRtlMultiSzAppend( &lpmszUpgradeList,
                                   &cchLen,
                                   lpszCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzAppend failed for %1!ws!, Status=%2!u!\n",
                      lpszCurrentDllPath,
                      dwStatus);                          
        goto FnExit;
    }
    
    //
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDirectory, RTL_NUMBER_OF ( szClusterDirectory ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    ( void ) StringCchCopy( szBakFile, RTL_NUMBER_OF ( szBakFile ), szClusterDirectory );

    dwLen = lstrlenW( szBakFile );

    if ( szBakFile[dwLen-1] != L'\\' )
    {
        szBakFile[dwLen++] = L'\\';
        szBakFile[dwLen] = L'\0';
    }

    ( void ) StringCchCat( szBakFile, RTL_NUMBER_OF ( szBakFile ), lpszNewDllName );
    ( void ) StringCchCat( szBakFile, RTL_NUMBER_OF ( szBakFile ), CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    //
    //  Copy the current DLL to a bak file and save it into the cluster installation directory.
    //  This needs to be done BEFORE the registry value is set so that you can be sure that once you
    //  perform a recovery, the file that you use from the backup is good.
    //
    if ( !CopyFileEx( lpszCurrentDllPath,   //  Source file
                      szBakFile,               //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      szBakFile,
                      dwStatus);                          
        goto FnExit;
    }

    //
    //  Set the file attributes to RO and hidden. Continue even if an error occurs since it is
    //  not fatal.
    //
    if ( !SetFileAttributes( szBakFile, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpReplaceResourceDLL: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szBakFile,
                dwStatus);                                 
    }
    
    //
    //  Set the new upgrade list
    //
    dwStatus = RegSetValueExW( hClussvcParamsKey,
                               CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                               0,
                               REG_MULTI_SZ,
                               ( LPBYTE ) lpmszUpgradeList,
                               cchLen * sizeof ( WCHAR ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: RegSetValueExW (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                          
        goto FnExit;
    }
    
skip_multisz_append:
    ( void ) StringCchCopy( szOldFile, RTL_NUMBER_OF ( szOldFile ), szClusterDirectory );

    dwLen = lstrlenW( szOldFile );

    if ( szOldFile[dwLen-1] != L'\\' )
    {
        szOldFile[dwLen++] = L'\\';
        szOldFile[dwLen] = L'\0';
    }

    ( void ) StringCchCat( szOldFile, RTL_NUMBER_OF ( szOldFile ), lpszNewDllName );
    ( void ) StringCchCat( szOldFile, RTL_NUMBER_OF ( szOldFile ), CLUSTER_RESDLL_RENAMED_FILE_EXTENSION );

    //
    //  Rename the currently loaded DLL to the a .old file in the cluster installation directory
    //
    if ( !MoveFileEx( lpszCurrentDllPath,   // Source file 
                      szOldFile,              // Destination file
                      MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: MoveFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      szOldFile,
                      dwStatus);                          
        goto FnExit;                
    }

    //
    //  Set the file attributes to RO and hidden. Continue even if an error occurs since it is
    //  not fatal.
    //
    if ( !SetFileAttributes( szOldFile, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpReplaceResourceDLL: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szOldFile,
                dwStatus);                                 
    }

    //
    //  Copy the new DLL from the installation path to the current DLL path. This should succeed
    //  since the current DLL has been renamed.
    //
    if ( !CopyFileEx( lpszInstallationPath,  //  Source file
                      lpszCurrentDllPath,    //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      lpszInstallationPath,
                      lpszCurrentDllPath,
                      dwStatus);                          
        goto FnExit;
    }   
   
    //
    //  Now get rid of the value we set in the registry. The BAK and OLD files are deleted later.
    //
    dwStatus =  FmpResetMultiSzValue ( hClussvcParamsKey,
                                       lpmszUpgradeList,
                                       &cchLen,
                                       CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                       lpszCurrentDllPath );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: Unable to remove %1!ws! from value %2!ws!, Status=%3!u!\n",
                      lpszCurrentDllPath,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                          
    
        goto FnExit;
    }
                              
FnExit:
    LocalFree( lpmszUpgradeList );

    if ( hClussvcParamsKey != NULL )
    {
        RegCloseKey( hClussvcParamsKey );
    }
    return ( dwStatus );
}//  FmpReplaceResourceDLL

DWORD
FmpRecycleMonitors(
    IN LPCWSTR lpszDllName
    )

/*++

Routine Description:

    Recycle all the monitors that have the specified resource DLL loaded.
Arguments:
   
    lpszDllName - The name of the loaded resource DLL.
    
Return Value:

    ERROR_SUCCESS on success.

    Win32 error code otherwise.
--*/
{
    DWORD                   i, dwStatus = ERROR_SUCCESS;
    FM_MONITOR_ENUM_HEADER  MonitorEnumHeader;

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpRecycleMonitors: Attempting to recycle all monitors that have loaded the DLL %1!ws!\n",
                 lpszDllName);                                     

    MonitorEnumHeader.ppMonitorList = NULL;
    MonitorEnumHeader.fDefaultMonitorAdded = FALSE;

    //
    //  Create a list of monitors that have the resource DLL loaded.
    //
    dwStatus = FmpCreateMonitorList( lpszDllName, &MonitorEnumHeader );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecycleMonitors: FmpCreateMonitorList failed with status %1!u!\n",
                      dwStatus);                                         
        goto FnExit;
    }

    //
    //  Now, shutdown and restart the monitors identified above. Shutdown and restart of each
    //  monitor is done one by one so that the long shutdown time of some monitors will not affect
    //  the restart of others. The FmpRestartMonitor function invokes a shutdown on the monitor,
    //  waits until the monitor is fully shutdown and then restarts all the resources in the
    //  old monitor in the new monitor.
    //
    for ( i=0; i<MonitorEnumHeader.cEntries; i++ )
    {
        //
        //  Increment the ref count. It will be decremented by the restart function.
        //
        InterlockedIncrement( &MonitorEnumHeader.ppMonitorList[i]->RefCount );
        FmpRestartMonitor( MonitorEnumHeader.ppMonitorList[i], FALSE, NULL );
    } // for
    
FnExit:   
    LocalFree( MonitorEnumHeader.ppMonitorList );

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpRecycleMonitors: Return with status %1!u!\n",
                 dwStatus);                                        

    return ( dwStatus );
}// FmpRecycleMonitors

DWORD
FmpCreateMonitorList(
    IN LPCWSTR lpszDllName,
    OUT PFM_MONITOR_ENUM_HEADER pMonitorHeader
    )

/*++

Routine Description:

    Create a list of monitors that have the resource DLL implementing the resource loaded.

Arguments:

    lpszDllName - The resource DLL that is being upgraded.

    pMonitorHeader - The enumeration list header which points to a list of monitors that have 
        the DLL loaded.
    
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD                   dwStatus = ERROR_SUCCESS;

    pMonitorHeader->cEntries = 0;
    pMonitorHeader->cAllocated = ENUM_GROW_SIZE;

    pMonitorHeader->ppMonitorList = LocalAlloc( LPTR, ENUM_GROW_SIZE * sizeof ( PRESMON ) );

    if ( pMonitorHeader->ppMonitorList == NULL ) 
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCreateMonitorList: Mem alloc failed with status %1!u!\n",
                      dwStatus);                                                        
        goto FnExit;
    }

    //
    //  Go through all the cluster resources to identify the monitors that have loaded the
    //  specified DLL.
    //
    OmEnumObjects( ObjectTypeResource,
                   FmpFindHostMonitors,
                   ( PVOID ) lpszDllName,
                   ( PVOID ) pMonitorHeader );
FnExit:
    return ( dwStatus );

}// FmpCreateMonitorList

BOOL
FmpFindHostMonitors(
    IN LPCWSTR lpszDllName,
    IN OUT PFM_MONITOR_ENUM_HEADER pMonitorEnumHeader,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR lpszResourceId
    )

/*++

Routine Description:

    Callback routine for enumerating all resources in the cluster. This routine will build a list
    of monitors that have loaded the specified DLL.

Arguments:

    lpszDllName - The DLL whose host processes have to be determined.

    pMonitorEnumHeader - The monitor list enumeration header

    pResource - The resource being enumerated.

    lpszResourceId - The Id of the resource object being enumerated.

Returns:

    TRUE - The enumeration should continue.

    FALSE - The enumeration must stop

--*/

{
    BOOL        fStatus = TRUE;
    PRESMON     *ppMonitorList;
    DWORD       i;
    LPWSTR      lpszDllNameOfRes = NULL;
    LPWSTR      lpszDLLPathOfRes = NULL;
    DWORD       dwStatus;
    DWORD       cchDllName;

    //
    //  Check whether the currently allocated monitor list has reached capacity. If so,
    //  create a new bigger list, copy the contents of the old list to the new one and 
    //  free the old list.
    //
    if ( pMonitorEnumHeader->cEntries == pMonitorEnumHeader->cAllocated )
    {
        ppMonitorList = LocalAlloc( LPTR,  pMonitorEnumHeader->cAllocated * 2 * sizeof ( PRESMON ) );

        if ( ppMonitorList == NULL )
        {
            fStatus = FALSE;
            ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpFindHostMonitors: Mem alloc failed with status %1!u!\n",
                      GetLastError());                                                               
            goto FnExit;
        }

        for ( i=0; i<pMonitorEnumHeader->cEntries; i++ )
        {
            ppMonitorList[i] = pMonitorEnumHeader->ppMonitorList[i];    
        }
        
        pMonitorEnumHeader->cAllocated *= 2;
        LocalFree( pMonitorEnumHeader->ppMonitorList );
        pMonitorEnumHeader->ppMonitorList = ppMonitorList;
    }

    
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //
    //  IMPORTANT: Do not write stuff into szDllNameOfRes while lpszDllName is being used
    //  since lpszDllName points inside szDllNameOfRes.
    //
    cchDllName = lstrlen ( pResource->Type->DllName ) + 1;

    lpszDLLPathOfRes = LocalAlloc ( LPTR, cchDllName * sizeof ( WCHAR ) );

    if ( lpszDLLPathOfRes == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpFindHostMonitors: Memory alloc for dll name %1!ws! failed, Status %2!u!\n",
                      pResource->Type->DllName,
                      dwStatus);                                                        
        goto FnExit;
    }
    
    ( void ) StringCchCopy( lpszDLLPathOfRes, cchDllName, pResource->Type->DllName );

    dwStatus = FmpParsePathForFileName ( lpszDLLPathOfRes, 
                                         TRUE,  // Check for path existence
                                         &lpszDllNameOfRes );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpFindHostMonitors: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      lpszDLLPathOfRes,
                      dwStatus);                                                        
        fStatus = FALSE;
        goto FnExit;
    }

    if ( lpszDllNameOfRes == NULL ) lpszDllNameOfRes = pResource->Type->DllName;

    //
    //  If this resource is not implemented in the specified DLL, you are done.
    //
    if ( lstrcmpi( lpszDllNameOfRes, lpszDllName ) != 0 )
    {
        fStatus = TRUE;
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpFindHostMonitors: Resource DLL %1!ws! for resource %2!ws! [%3!ws!] is loaded currently in %4!ws! monitor...\n",
                 lpszDllName,
                 OmObjectId(pResource),
                 OmObjectName(pResource),
                 (pResource->Monitor == FmpDefaultMonitor) ? L"default":L"separate");                                                               

    //
    //  Since multiple resources can be loaded in the default monitor, you don't want to add
    //  the default monitor multiple times in the list. Use a global static variable to indicate
    //  that the default monitor has been added in the list. Also, note that only one resource can
    //  be loaded in a separate monitor process and so there is no question of adding the separate
    //  monitor multiple times in the list.
    //
    if ( pResource->Monitor == FmpDefaultMonitor ) 
    {
        if ( pMonitorEnumHeader->fDefaultMonitorAdded == TRUE ) 
        {
            fStatus = TRUE;
            goto FnExit;
        }
        pMonitorEnumHeader->fDefaultMonitorAdded = TRUE;
    }

    pMonitorEnumHeader->ppMonitorList[pMonitorEnumHeader->cEntries] = pResource->Monitor;
    pMonitorEnumHeader->cEntries ++;    
    
FnExit:
    LocalFree ( lpszDLLPathOfRes );
    return ( fStatus );
} // FmpFindHostMonitors

DWORD
FmpRecoverResourceDLLFiles(
    VOID
    )

/*++

Routine Description:

    Check whether any resource DLLs need to be recovered due to a crash during an upgrade.

Arguments:

    None.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPWSTR          lpszDllPath = NULL;
    LPCWSTR         lpmszUpgradeList = NULL;
    LPWSTR          lpmszBegin = NULL;
    DWORD           cbListSize = 0, cchLen = 0;
    DWORD           dwType, dwIndex;
    HKEY            hClussvcParamsKey = NULL;
    
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClussvcParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecoverResourceDLLFiles: RegOpenKeyEx on %1!ws! failed, Status=%2!u!\n",
                     CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                     dwStatus); 
        goto FnExit;
    }

    //
    //  See whether a past failed upgrade has left any values in the upgrade progress list
    //
    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 NULL,
                                 &cbListSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND ) 
        {
            dwStatus = ERROR_SUCCESS;
            //
            //  Delete any backup files left over from past failed upgrades.
            //
            FmpDeleteBackupFiles( NULL );
        }
        else
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] FmpRecoverResourceDLLFiles: RegQueryValueEx (1st time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                          CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                          dwStatus);  
        goto FnExit;
    }

    if ( cbListSize == 0 )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Value size is 0 for %1!ws! key, value %2!ws!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST);    
        goto FnExit;
    }
    
    //
    //  Found some values left out from past upgrade. Read those values. Also, copy
    //  those values into a temp buffer for allowing easy MULTI_SZ removal.
    //
    lpmszUpgradeList = LocalAlloc ( LPTR, 
                                    2 * cbListSize ); // Twice size needed for temp buffer below
   
    if ( lpmszUpgradeList == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpRecoverResourceDLLFiles: Mem alloc failure, Status=%1!u!\n",
                  dwStatus);                       
        goto FnExit;
    }

    lpmszBegin = ( LPWSTR ) lpmszUpgradeList;

    dwStatus = RegQueryValueExW( hClussvcParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                 0,
                                 &dwType,
                                 ( LPBYTE ) lpmszUpgradeList,
                                 &cbListSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpRecoverResourceDLLFiles: RegQueryValueEx (2nd time) on %1!ws! key, value %2!ws! failed, Status=%3!u!\n",
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                      dwStatus);                       
        goto FnExit;
    } 

    CopyMemory( lpmszBegin + cbListSize/sizeof(WCHAR), lpmszUpgradeList, cbListSize );

    cchLen = cbListSize/sizeof(WCHAR);

    //
    //  This loop walks through the multi strings read from the registry and tries to
    //  see if the file exists in the path. If not, it tries to copy the file from 
    //  a backup. Once it succeeds in copying a file from the backup, it tries to
    //  delete the value from the MULTI_SZ and the appropriate backup files from the
    //  cluster directory.
    //
    for ( dwIndex = 0;  ; dwIndex++ )
    {       
        lpszDllPath = ( LPWSTR ) ClRtlMultiSzEnum( lpmszUpgradeList,
                                                   cbListSize/sizeof(WCHAR),
                                                   dwIndex );
        //
        //  If you reached the end of the multi-string, bail.
        //
        if ( lpszDllPath == NULL ) 
        {
            break;
        }

        //
        //  Assume the worst and copy the DLL file from the good backup.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Resource DLL binary %1!ws! cannot be trusted due to a failure during upgrade...\n",
                      lpszDllPath);      
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRecoverResourceDLLFiles: Attempting to use a copy from backup...\n",
                      lpszDllPath);      

        dwStatus = FmpCopyBackupFile( lpszDllPath );

        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            //  The copy went fine. So, reset the registry value set during the upgrade.
            //
            dwStatus = FmpResetMultiSzValue ( hClussvcParamsKey,
                                              lpmszBegin + cbListSize/sizeof(WCHAR),
                                              &cchLen,
                                              CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST,
                                              lpszDllPath );

            if ( dwStatus == ERROR_SUCCESS )
                //
                //  The registry value reset went fine, so get rid of the backup files
                //
                FmpDeleteBackupFiles( lpszDllPath );
        } 
    } // for

FnExit:
    LocalFree( lpmszBegin );

    if ( hClussvcParamsKey != NULL )
    {
        RegCloseKey( hClussvcParamsKey );
    }

    return ( dwStatus );
}// FmpRecoverResourceDLLFiles

DWORD
FmpResetMultiSzValue(
    IN  HKEY hKey,
    IN  LPWSTR lpmszList,
    IN  OUT LPDWORD pcchLen,
    IN  LPCWSTR lpszValueName,
    IN  LPCWSTR lpszString 
    )

/*++

Routine Description:

    Gets rid of a specified string from a multi-string and sets the string to the given value name
    in the registry. The value is deleted if on the string removal the multi-string becomes
    empty.

Arguments:

    hKey - An open registry handle.

    lpmszList - A multi-string.

    pcchLen - A pointer to the length of the multi string. On return, it will be set to the
        new length of the multi-string.

    lpszValueName - The value name to be modified.

    lpszString - The string to be removed from the multi-string.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    //
    //  Remove the supplied string from the multi-sz
    //
    dwStatus = ClRtlMultiSzRemove( lpmszList,
                                   pcchLen,
                                   lpszString );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpReplaceResourceDLL: ClRtlMultiSzRemove failed for %1!ws!, Status=%2!u!\n",
                      lpszString,
                      dwStatus);                             
        goto FnExit;
    }

    //
    //  ClRtlMultiSzRemove will return a size of 1 character if the string is empty
    //
    if ( *pcchLen <= 2 )
    {
        //
        //  After removal from the multi-sz, there is nothing left, so delete the value
        //
        dwStatus = RegDeleteValue( hKey,
                                   lpszValueName ); 

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] FmpResetMultiSzValue: RegDeleteValue on %1!ws! value failed, Status=%2!u!\n",
                         lpszValueName,
                         dwStatus);                              
            goto FnExit;
        }      
    } else
    {
        //
        //  Put the rest of the values back into the registry.
        //
        dwStatus = RegSetValueExW( hKey,
                                   lpszValueName,
                                   0,
                                   REG_MULTI_SZ,
                                   ( LPBYTE ) lpmszList,
                                   ( *pcchLen ) * sizeof ( WCHAR ) );

        if ( dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] FmpResetMultiSzValue: RegSetValueEx on %1!ws! value failed, Status=%2!u!\n",
                         lpszValueName,
                         dwStatus);                                     
            goto FnExit;
        } 
    }

FnExit:
    return ( dwStatus );
}// FmpResetMultiSzValue

DWORD
FmpCopyBackupFile(
    IN LPCWSTR  lpszPath
    )

/*++

Routine Description:

    Parse the path for the DLL file name and copy the backup version of the file.

Arguments:

    lpszPath - Path including the DLL file name.

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

Note:

    We can only trust CLUSTER_RESDLL_BACKUP_FILE_EXTENSION file as the good backup since that
    backup was made prior to setting the CLUSREG_NAME_SVC_PARAM_RESDLL_UPGD_PROGRESS_LIST value.
    So, we don't look at the CLUSTER_RESDLL_RENAMED_FILE_EXTENSION file in this function.

--*/
{
    WCHAR       szSourceFile[MAX_PATH];
    WCHAR       szTempFile[MAX_PATH];
    WCHAR       szClusterDir[MAX_PATH];
    LPWSTR      lpszFileName;
    DWORD       dwStatus = ERROR_SUCCESS, i, dwLen;
   
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //  IMPORTANT: Dont write into szTempFile after you parse the file name since lpszFileName
    //  points into szTempFile.
    //
    ( void ) StringCchCopy( szTempFile, RTL_NUMBER_OF ( szTempFile ), lpszPath );

    dwStatus = FmpParsePathForFileName ( szTempFile, 
                                         FALSE,       // Don't check for existence
                                         &lpszFileName ); 

    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszFileName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      szTempFile,
                      dwStatus);                                                        
        goto FnExit;
    }

    //    
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDir, RTL_NUMBER_OF ( szClusterDir ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    ( void ) StringCchCopy( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), lpszFileName );
    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    //
    //  Change the file attributes to normal
    //
    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCopyBackupFile: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    //
    //  Copy the backup file to the DLL path.
    //
    if ( !CopyFileEx( szSourceFile,            //  Source file
                      lpszPath,               //  Destination file
                      NULL,                    //  No progress routine
                      NULL,                    //  No data to progress routine
                      NULL,                    //  No cancel variable
                      0 ) )                    //  No flags
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpCopyBackupFile: CopyFileEx of %1!ws! to %2!ws! failed, Status=%3!u!\n",
                      szSourceFile,
                      lpszPath,
                      dwStatus);                          
    } else
    {
        dwStatus = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpCopyBackupFile: CopyFileEx of %1!ws! to %2!ws! successful...\n",
              szSourceFile,
              lpszPath,
              dwStatus);
        goto FnExit;
    }

FnExit:
    return ( dwStatus );
}// FmpCopyBackupFile

VOID
FmpDeleteBackupFiles(
    IN LPCWSTR  lpszPath    OPTIONAL
    )

/*++

Routine Description:

    Parse the path for the DLL file name and delete the backup files corresponding to it OR
    delete all files with the known backup extension in the %windir%\cluster directory.

Arguments:

    lpszPath - Path including the DLL file name.    OPTIONAL

Returns:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    WCHAR               szSourceFile[MAX_PATH];
    WCHAR               szClusterDir[MAX_PATH];
    LPWSTR              lpszFileName = L"*";    // Use in case IN param is NULL
    DWORD               dwStatus = ERROR_SUCCESS, i, dwLen;
    HANDLE              hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    DWORD               cchPath;
    LPWSTR              lpszTempFile = NULL;
    
    if ( lpszPath == NULL ) goto skip_path_parse;
    
    //
    //  Get the plain file name from the DLL name stored in the restype structure. Since the 
    //  parse function can potentially get rid of the trailing '\', make a copy of the DLL 
    //  name.
    //
    //  IMPORTANT: Dont write into szTempFile after you parse the file name since lpszFileName
    //  points into szTempFile.
    //
    cchPath = lstrlen ( lpszPath ) + 1;
    
    lpszTempFile = LocalAlloc ( LPTR, cchPath * sizeof ( WCHAR ) );

    if ( lpszTempFile == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpDeleteBackupFiles: Memory allocation for path %1!ws! failed, Status %2!u!\n",
                      lpszPath,
                      dwStatus);                                                        
        goto FnExit;
    }

    ( void ) StringCchCopy( lpszTempFile, cchPath, lpszPath );

    dwStatus = FmpParsePathForFileName ( lpszTempFile, 
                                         FALSE,       // Don't check for existence
                                         &lpszFileName ); 

    if ( ( dwStatus != ERROR_SUCCESS ) || ( lpszFileName == NULL ) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpDeleteBackupFiles: Unable to parse path %1!ws! for filename, Status %2!u!\n",
                      lpszTempFile,
                      dwStatus);                                                        
        goto FnExit;
    }

skip_path_parse:
    //    
    //  Get the cluster bits installed directory
    //
    dwStatus = ClRtlGetClusterDirectory( szClusterDir, RTL_NUMBER_OF ( szClusterDir ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmpDeleteBackupFiles: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    if ( lpszPath == NULL )
    {
        //
        //  Delete all files that match the backup file pattern.
        //
        ( void ) StringCchCopy( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), szClusterDir );

        dwLen = lstrlenW( szSourceFile );

        if ( szSourceFile[dwLen-1] != L'\\' )
        {
            szSourceFile[dwLen++] = L'\\';
            szSourceFile[dwLen] = L'\0';
        }

        ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), lpszFileName );
        ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), CLUSTER_RESDLL_BACKUP_FILES );

        if ( ( hFind = FindFirstFile( szSourceFile, &FindData ) ) == INVALID_HANDLE_VALUE ) 
        {
            dwStatus = GetLastError();
            if ( dwStatus != ERROR_FILE_NOT_FOUND )
                ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpDeleteBackupFiles: Failed in FindFirstFile for %1!ws!, Status=%2!u!\n",
                       szSourceFile,
                       dwStatus);                              
            goto FnExit;
        }

        do
        {
            //
            //  Get the file name matching the pattern above and get the full path including
            //  the file name. Then change the file attributes to normal for allowing deletion.
            //
            ( void ) StringCchCopy( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), szClusterDir );

            dwLen = lstrlenW( szSourceFile );

            if ( szSourceFile[dwLen-1] != L'\\' )
            {
                szSourceFile[dwLen++] = L'\\';
                szSourceFile[dwLen] = L'\0';
            }

            ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), FindData.cFileName );

            if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
            {
                dwStatus = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                        szSourceFile,
                        dwStatus);                                 
            }

            if ( !DeleteFile( szSourceFile ) )
            {
                dwStatus = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                        szSourceFile,
                        dwStatus);                                 
            }
        } while ( FindNextFile( hFind, &FindData ) );

        FindClose ( hFind );
        goto FnExit;
    }

    ( void ) StringCchCopy( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), lpszFileName );
    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), CLUSTER_RESDLL_BACKUP_FILE_EXTENSION );

    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    if ( !DeleteFile( szSourceFile ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    ( void ) StringCchCopy( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), szClusterDir );
    
    dwLen = lstrlenW( szSourceFile );

    if ( szSourceFile[dwLen-1] != L'\\' )
    {
        szSourceFile[dwLen++] = L'\\';
        szSourceFile[dwLen] = L'\0';
    }

    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), lpszFileName );
    ( void ) StringCchCat( szSourceFile, RTL_NUMBER_OF ( szSourceFile ), CLUSTER_RESDLL_RENAMED_FILE_EXTENSION );

    if ( !SetFileAttributes( szSourceFile, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in SetFileAttributes for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }

    if ( !DeleteFile( szSourceFile ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpDeleteBackupFiles: Failed in DeleteFile for %1!ws!, Status=%2!u!\n",
                szSourceFile,
                dwStatus);                                 
    }
    
FnExit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmevent.c

Abstract:

    Event Handler for the Failover Manager component of the
    NT Cluster Service

Author:

    Rod Gamache (rodga) 19-Mar-1996


Revision History:

--*/
#include "fmp.h"

#define LOG_MODULE EVENT

//
// Global data initialized in this module
//


//
// Local functions
//


DWORD
WINAPI
FmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles events for the Failover Manager.

    In many cases the request is posted to the FM's work queue, so
    that the mainline event process is not blocked.

Arguments:

    Event - The event to be processed. Only one event at a time.
            If the event is not handled, return ERROR_SUCCESS.

    Context - A pointer to context associated with the particular event.

Returns:

    ERROR_SHUTDOWN_CLUSTER - if the Cluster must be shutdown.

    A Win32 error code on other errors.

Notes:

    The conservation of energy, and laws of inertia apply here.

    If a resource comes online it is because someone requested it to be so.
    Therefore, the energy from that request goes into the state of the Group,
    by requesting the Group to go online.

    However, if a resource goes offline, it could be because of a failure.
    We therefore only mark the state of a Group as offline if all resources
    contained within the group are offline.

--*/

{
    DWORD status;

    switch ( Event ) {
       
    case CLUSTER_EVENT_NODE_ADDED:
        CL_ASSERT( Context != NULL );
        FmpPostWorkItem( FM_EVENT_NODE_ADDED, Context, 0 );
        break;

    case CLUSTER_EVENT_NODE_UP:
        ClRtlLogPrint(LOG_NOISE,"[FM] Node up event\n");
        //
        // FM no longer cares about node up events.
        //
        break;

    case CLUSTER_EVENT_NODE_DOWN:
        FmpMajorEvent = TRUE;           // Node Down is a major event.
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpEventHandler::Node down event\n");
        FmpHandleNodeDownEvent( Context );
        break;

    case CLUSTER_EVENT_NODE_DELETED:
        FmpHandleNodeEvictEvent( Context );
        break;

    default:
        break;

    }

    return(ERROR_SUCCESS);

} // FmEventHandler


DWORD
WINAPI
FmpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Update locker/locking nodes
    state and decide if we need to replay last update in async handler.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/
{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));


    ClRtlLogPrint(LOG_NOISE, 
        "[FM] FmpSyncEventHandler:: %1!04X!.\n",
        DownedNodes);

    //
    // mark the nodes that go down
    // till the worker thread finishes processing the groups that belonged
    // to this node, we will block a join from the same node
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) 
    {

       if (BitsetIsMember(NodeId, DownedNodes))
       {
            gFmpNodeArray[NodeId].dwNodeDownProcessingInProgress = 1;
        }            
    }


    return(ERROR_SUCCESS);
}


VOID
FmpHandleGroupFailure(
    IN PFM_GROUP    Group,
    IN PFM_RESOURCE pResource   OPTIONAL
    )

/*++

Routine Description:

    Handles Group failure notifications from the resource manager. If the
    Group can be moved to some other system and we are within the failover
    threshold, then move it. Otherwise, just leave the Group (partially)
    online on this system.

Arguments:

    Group - a pointer to the Group object for the failed Group.

    pResource - A pointer to the failed resource which caused the group failure. OPTIONAL

Returns:

    None.

--*/

{
    DWORD   status;
    DWORD   tickCount;
    DWORD   withinFailoverPeriod;
    DWORD   failoverPeriodInMs;
    BOOL    newTime;
    PFM_RESOURCE Resource;
    PLIST_ENTRY     listEntry;

    //
    //  Chittur Subbaraman (chitturs) - 6/10/2001
    //
    //  Changed the function to optionally take in a pResource and notify the group if we decide
    //  to failover the group
    //
 
    FmpAcquireLocalGroupLock( Group );

    if ( ( !IS_VALID_FM_GROUP( Group ) ) || ( Group->OwnerNode != NmLocalNode ) ) {
        FmpReleaseLocalGroupLock( Group );
        return;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleGroupFailure, Entry: Group failure for %1!ws!...\n",
               OmObjectId(Group));

    //
    // Convert Group's failover period from hours to milliseconds.
    //
    failoverPeriodInMs = Group->FailoverPeriod * (3600*1000);

    //
    // Get current time (in tick counts). We can save about 1193 hours worth
    // of milliseconds (or almost 50 days) in one DWORD.
    //
    tickCount = GetTickCount();

    //
    // Compute boolean that indicates if we are whithin the failover period.
    //
    withinFailoverPeriod = ( ((tickCount - Group->FailureTime) <=
                             failoverPeriodInMs ) ? TRUE : FALSE);

    //
    // Tally another failure.
    //
    if ( withinFailoverPeriod ) {
        ++Group->NumberOfFailures;
        newTime = FALSE;
    } else {
        Group->FailureTime = tickCount;
        Group->NumberOfFailures = 1;
        newTime = TRUE;
    }

    //
    // Tell everyone about our new FailureCount. Propagate failure
    // count
    //
    FmpPropagateFailureCount( Group, newTime );

    //
    // If this group is the same as the quorum group and the quorum 
    // resource has failed
    //
    if ( ( gpQuoResource->Group == Group ) && 
         ( gpQuoResource->State == ClusterResourceFailed ) ) 
    {
        if ( pResource != NULL ) FmpTerminateResource( pResource );
        FmpCleanupQuorumResource(gpQuoResource);
#if DBG
        if (IsDebuggerPresent())
        {
            DebugBreak();
        }
#endif            
        CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
    }

    //
    // First check if we can move the Group someplace else.
    //
    if ( FmpGroupCanMove( Group ) &&
         (Group->NumberOfFailures <= Group->FailoverThreshold) ) {
     
        //
        //  Chittur Subbaraman (chitturs) - 4/13/99
        //
        //  Now create the FmpDoMoveGroupOnFailure thread to handle the
        //  group move. The thread will wait until the group state becomes
        //  stable and then initiate the move.
        //
        if( !( Group->dwStructState & 
               FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) )
        {
            PMOVE_GROUP  pContext = NULL;
            DWORD        dwThreadId = 0;
            HANDLE       hThread = NULL;

            //
            //  The decision to failover the group has been made (more or less). So, notify
            //  all the group's resources of this decision.
            //
            FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonFailover );
            if ( pResource != NULL ) FmpTerminateResource( pResource );

            pContext = LocalAlloc( LMEM_FIXED, sizeof( MOVE_GROUP ) );
            if ( pContext == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Group failure for group <%1!ws!>. Unable to allocate memory.\n",
                           OmObjectId(Group));
                FmpReleaseLocalGroupLock( Group );
                return;
            }

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Group failure for group <%1!ws!>. Create thread to take offline and move.\n",
                       OmObjectId(Group));

            //
            // Reference the Group object. You don't want the group object
            // to be deleted at the time the FmpDoMoveGroupOnFailure thread
            // executes.
            //
            OmReferenceObject( Group );

            pContext->Group = Group;
            pContext->DestinationNode = NULL;

            hThread = CreateThread( NULL,
                                    0,
                                    FmpDoMoveGroupOnFailure,
                                    pContext,
                                    0,
                                    &dwThreadId );

            if ( hThread == NULL ) {
                status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                            "[FM] Failed to create FmpDoMoveGroupOnFailure thread for group <%1!ws!>. Error %2!u!.\n",
                            OmObjectId(Group),
                            status);
                LocalFree( pContext );
                OmDereferenceObject( Group );
            } else {
                CloseHandle( hThread );
                //
                //  Mark the group as being moved on failure. This is necessary
                //  so that you don't spawn new FmpDoMoveGroupOnFailure threads 
                //  which try to concurrently move the group. Note that the
                //  worker thread which calls this function may deliver multiple
                //  failure notifications.
                //
                Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL;
            }
        }
        else {
            if ( pResource != NULL ) FmpTerminateResource( pResource );
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Group failure for %1!ws!, but can't move. Failure count = %2!d!.\n",
                   OmObjectId(Group), Group->NumberOfFailures);

        if ( pResource != NULL ) FmpTerminateResource( pResource );

        // All attempts to bring group online failed - start the watchdog timer
        // to attempt a restart of all failed resources in this group.
        for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) 
        {
            Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
            FmpDelayedStartRes(Resource);
        }       
    }
    
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleGroupFailure, Exit: Group failure for %1!ws!...\n",
               OmObjectId(Group));

    return;

} // FmpHandleGroupFailure



BOOL
FmpGroupCanMove(
    IN PFM_GROUP    Group
    )

/*++

Routine Description:

    Indicates whether there is another system that is in the preferred owner
    list that can take a Group.

Arguments:

    Group - the Group to check if it can move.

Returns:

    TRUE - the Group can (probably) move to another system.
    FALSE - there is no place to move this Group.

--*/

{
    DWORD   status;
    PNM_NODE node;

    node = FmpFindAnotherNode( Group, FALSE );
    if (node != NULL ) {
        return(TRUE);
    }

    return(FALSE);

} // FmpGroupCanMove



DWORD
FmpNodeDown(
    PVOID Context
    )

/*++

Routine Description:

    This routine handles a node down event from the NM layer.

Arguments:

    Context - The node that went down.

Returns:

    ERROR_SUCCESS if everything was handled okay.

    ERROR_SHUTDOWN_CLUSTER if catastrophy happens.

    Win32 error code otherwise (???).

--*/
{
    PNM_NODE            pNode = (PNM_NODE)Context;
    DWORD               dwStatus;
    LPCWSTR             pszNodeId;
    DWORD               dwNodeLen;
    DWORD               dwClusterHighestVersion;
    
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpNodeDown::Node down %1!ws!\n",
                    OmObjectId(pNode));

    //
    //  Chittur Subbaraman (chitturs) - 3/30/99
    //
    //  Acquire the global group lock to synchronize with the shutdown
    //
    FmpAcquireGroupLock();
    
    if (!FmpFMOnline || FmpShutdown) 
    {
        //
        // We don't care about membership changes until we have finished
        // initializing and we're not shutting down.
        //
        FmpReleaseGroupLock();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpNodeDown - ignore node down event.\n" );
        goto FnExit;
    }
    
    FmpReleaseGroupLock();

    //SS: Note all nodes will send this update
    //The latter updates should not find any groups that belong to 
    //this node
    //We cant rely on only the locker node making this update
    //since the locker node may die before it is able to do this and
    //that can result in these groups being orphaned
    pszNodeId = OmObjectId(pNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    //
    //  If this is a non Win2k-Whistler mixed mode cluster, attempt to randomize the
    //  group preferred owners list and send it as a part of node down GUM.
    //
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) >= 
                NT51_MAJOR_VERSION ) 
    {
        PFM_GROUP_NODE_LIST pGroupNodeList = NULL;

        //
        //  Attempt to get a contiguous buffer containing the list of group IDs and suggested
        //  owners for them.
        //
        dwStatus = FmpPrepareGroupNodeList( &pGroupNodeList );

        if ( dwStatus != ERROR_SUCCESS )
        {
            //
            //  If the call returns ERROR_CLUSTER_INVALID_REQUEST, it means a user has turned
            //  off the randomization algorithm.
            //
            if ( dwStatus != ERROR_CLUSTER_INVALID_REQUEST )
                ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpNodeDown: FmpPrepareGroupNodeList returns %1!u!...\n",
                            dwStatus); 
            LocalFree( pGroupNodeList );
            goto use_old_gum;
        }

        //
        //  If the list does not even contain any entries, just switch to the old gum. No point in
        //  sending the list header around.
        //
        if ( pGroupNodeList->cbGroupNodeList < sizeof ( FM_GROUP_NODE_LIST ) )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpNodeDown: FmpPrepareGroupNodeList returns empty list...\n"); 
            LocalFree( pGroupNodeList );
            goto use_old_gum;
        }

        //
        //  Invoke GUM to pass around the dead node ID and the randomized group node list
        //
        dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                    FmUpdateUseRandomizedNodeListForGroups,
                                    2,
                                    dwNodeLen,
                                    pszNodeId,
                                    pGroupNodeList->cbGroupNodeList,
                                    pGroupNodeList );

        if ( dwStatus != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpNodeDown: GUM update FmUpdateUseRandomizedNodeListForGroups failed %1!d!\n",
                       dwStatus);
        }

        LocalFree( pGroupNodeList );
        goto FnExit;
    }

use_old_gum:      
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                   FmUpdateAssignOwnerToGroups,
                   1,
                   dwNodeLen,
                   pszNodeId);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpNodeDown: Gumupdate failed %1!d!\n",
                   dwStatus);
    }

FnExit:
    gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingThreadId = 0;
    OmDereferenceObject ( pNode );   
    return(ERROR_SUCCESS);
} // FmpNodeDown



BOOL
WINAPI
FmVerifyNodeDown(
    IN  PNM_NODE Node,
    OUT LPBOOL   IsDown
    )

/*++

Routine Description:

    This routine attempts to verify whether a given node is down. This can
    only be done if there is some shared resource that the other system
    currently 'owns'.  We will attempt to negotiate the shared resource and
    if we 'win' the negotiation we'll declare that other system down. If we
    loose arbitration, we declare the other system as still up.

Arguments:

    Node - A pointer to the node structure for the other system.

    IsDown - A we can perform the verification, this indicates the results of
            that verification.

Returns:
    TRUE - If we can perform the verification.
    FALSE - If we can't perform the verification.

--*/

{
    return(FALSE);

} // FmVerifyNodeDown

DWORD
FmpHandleNodeDownEvent(
    IN  PVOID pContext
    )

/*++

Routine Description:

    This function creates a thread to handle the node down event.

Arguments:

    pContext - Pointer to the context structure
	
Returns:

    ERROR_SUCCESS
--*/

{
    HANDLE          hThread = NULL;
    DWORD           dwError;

    //
    //  Chittur Subbaraman (chitturs) - 7/31/99
    //
    //  Create a thread to handle the FM node down event. Let us not
    //  rely on the FM worker thread to handle this. This is because
    //  the FM worker thread could be trying to online some resource
    //  and that could get stuck for some time since the quorum resource 
    //  is not online. Now in some cases, only after the node down event 
    //  is processed the quorum resource could come online. (This is 
    //  highly likely especially in a 2 node cluster.)
    //
    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpHandleNodeDownEvent - Create thread to handle node down event....\n"
              );

    //
    //  Reference the node object
    //
    OmReferenceObject( pContext );
    
    hThread = CreateThread( NULL, 
                            0, 
                            FmpNodeDown,
                            pContext, 
                            0, 
                            &gFmpNodeArray[NmGetNodeId(pContext)].dwNodeDownProcessingThreadId );


    if ( hThread == NULL )
    {
        OmDereferenceObject( pContext );
        dwError = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                  "[FM] FmpHandleNodeDownEvent - Unable to create thread to handle node down event. Error=0x%1!08lx!\r\n",
        	     dwError);
        CsInconsistencyHalt( dwError );
    }
        
    CloseHandle( hThread );

    return( ERROR_SUCCESS );
} // FmpHandleNodeDownEvent

VOID
FmpHandleNodeEvictEvent(
    IN  PVOID pContext
    )

/*++

Routine Description:

    This function synchronizes the FM evict processing with the node down event handler.

Arguments:

    pContext - Pointer to the context structure (just contains the node object)
	
Returns:

    None
    
--*/

{
    HANDLE              hThread;
    PNM_NODE            pNode = ( PNM_NODE ) pContext;
    DWORD               dwWaitStatus;

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpHandleNodeEvictEvent: Handle node %1!u! evict event\n",
    	          NmGetNodeId(pNode));

    //
    //  Chittur Subbaraman (chitturs) - 10/8/2001
    //
    //  This event handler was designed to solve the synchronization problem between FM node down processing
    //  and FM node evict processing. In the past, NM evict GUM handler used to directly post a work item to
    //  FM worker thread to perform the evict processing. NM posts the node down event to FM via the 
    //  event processing mechanism. Since these two activities were independent of each other, the node
    //  evict processing could complete before the node down processing began. This caused the node down
    //  processing to fail (and hence claim groups on the evicted down node) horribly since it could no
    //  longer reference the evicted node. To solve this problem, NM no longer posts any work item to
    //  the FM worker thread to perform evict processing. Instead, it uses the event processing mechanism
    //  to post the CLUSTER_EVENT_NODE_DELETED event to the FmpEventHandler. That function invokes this
    //  function. In this function, we detect if the node down processing is in progress and if so we wait
    //  until the node down processing thread completes its job. Then we go ahead and do the FM evict
    //  processing (which involves posting a work item to the FM worker thread). This function is designed
    //  based on the assumption that NM ALWAYS posts the CLUSTER_EVENT_NODE_DOWN event BEFORE the
    //  CLUSTER_EVENT_NODE_DELETED event. Note also that since the FmpEventHandler handles both these
    //  cluster events serially one after another, we are guaranteed not to have any races between
    //  the evict processing code and then node down handling code.
    //
    
    //
    //  Check if the FM node down handler is working on a node down event for the node that is being
    //  evicted
    //
    if ( gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingThreadId != 0 )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpHandleNodeEvictEvent: Thread 0x%1!08lx! is currently processing node down, try opening it for wait\n",
    	              gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingThreadId);

        //
        //  Get a handle to that thread
        //
        hThread = OpenThread ( SYNCHRONIZE,             // Desired access
                               FALSE,                   // Inherit handles
                               gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingThreadId ); // Thread ID

        if ( hThread != NULL )
        {
            //
            //  Wait until that thread terminates. Is it better to wait until a timeout and do an
            //  inconsistency halt if the thread doesn't terminate ? If so, how well can you determine the
            //  time for the node down processing (including GUMs) to complete ?
            //
            dwWaitStatus = WaitForSingleObject ( hThread, INFINITE );
            CloseHandle ( hThread );

            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmpHandleNodeEvictEvent: Returning from wait, wait status %1!u!, continue with eviction\n",
    	                  dwWaitStatus);
        } else
        {
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmpHandleNodeEvictEvent: Unable to open thread 0x%1!08lx!, proceed with eviction\n",
        	              gFmpNodeArray[NmGetNodeId(pNode)].dwNodeDownProcessingThreadId);     
        }
    }// if ( gFmpNodeArray[NmGetNodeId(pContext)]

    //
    //  Invoke the FM API to evict the node
    //
    FmEvictNode ( pNode );   
} // FmpHandleEvictEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\evtlog\simpleq.h ===
#ifndef _SIMPLE_QUEUE_H
#define _SIMPLE_QUEUE_H 1

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    simpleq.h

Abstract:

    Simple non-blocking queue, that allows
    multiple concurrent data providers
    and singe data consumer

Author:

    GorN 9-Feb-1999

Revision History:

--*/

#define COUNT_DROPPED_PACKETS 1 // Enable dropped packet counting 

// The queue can store blocks of variable sizes
// each block is prefixed by this structure

typedef struct _SIMPLEQUEUE_BLOCK_HEADER
{
    DWORD PayloadSize; // this is the size of the block 
                       // as it was passed to us by the client
} 
SIMPLEQUEUE_BLOCK_HEADER, *PSIMPLEQUEUE_BLOCK_HEADER;

#define SQB_ALIGNMENT           ( sizeof(DWORD) )
#define SQB_INFLATE_SIZE( size )( (size + SQB_ALIGNMENT - 1) & ~(SQB_ALIGNMENT - 1) )
#define SQB_PAYLOADSIZE_TO_BLOCKSIZE( size )( SQB_INFLATE_SIZE(size + sizeof(SIMPLEQUEUE_BLOCK_HEADER)) )

#define SQB_HEADER( ptr )       ( (PSIMPLEQUEUE_BLOCK_HEADER)(ptr) )
#define SQB_PAYLOADSIZE( ptr )  ( SQB_HEADER(ptr)->PayloadSize )
#define SQB_BLOCKSIZE( ptr )    ( SQB_PAYLOADSIZE_TO_BLOCKSIZE( SQB_PAYLOADSIZE( ptr ) ) )
#define SQB_NEXTBLOCK( ptr )    ( (PVOID)( (PUCHAR)(ptr) + SQB_BLOCKSIZE( ptr ) ) )
#define SQB_PAYLOAD( ptr )      ( (PVOID)(SQB_HEADER(ptr) + 1) )

typedef struct _SIMPLEQUEUE *PSIMPLEQUEUE;

// The following function will be called if there are dropped data and
// the last time we reported dropped data was NotifyInterval 
// or more seconds before.
typedef void (*DROPPED_DATA_NOTIFY) (
    IN PWCHAR QueueName, 
    IN DWORD DroppedDataCount, 
    IN DWORD DroppedDataSize);

// The following function will be called if there are data available
// in the queue. It will not be called again until
// Read/CompleteRead operations empty the queue.
typedef void (*DATA_AVAILABLE_CALLBACK)(
    IN PSIMPLEQUEUE q);

DWORD SimpleQueueInitialize(
    IN OUT PSIMPLEQUEUE q, 
    IN DWORD cbSize, 
    IN PWCHAR Name,

    IN DATA_AVAILABLE_CALLBACK DataAvailableCallback,
    IN DROPPED_DATA_NOTIFY DroppedDataNotifyCallback,
    IN DWORD NotifyInterval // in seconds //
    );
/*++

Routine Description:

    Initializes a queue
    
Arguments:

    q      - a queue to be initialized
    cbSize - size of the queue in bytes 
    Name   - Name of the queue. It will be supplied to DroppedDataNotifyCallback

    DataAvailableCallback     - This function will be called if there are data available
                                in the queue. This function will not be called again until
                                Read/CompleteRead operations empty the queue.
                                
    DroppedDataNotifyCallback - This function will be called if there are dropped data and
                                the last time we reported dropped data was NotifyInterval 
                                or more seconds before.
    
    NotifyInterval            - We will not report dropped data unless it has been longer
                                than NotifyInterval seconds since the last report
             
Return Value:

    ERROR_SUCCESS - success
    error code    - called failed
    
 */


VOID
SimpleQueueDelete(
    IN PSIMPLEQUEUE q
    );
/*++

Routine Description:

    Destroys a queue
    
Arguments:

    q      - a queue to be destroyed
             
Return Value:

    None
    
Comments:

    This routine will destroy queue's CriticalSection
    and deallocate queue's memory. It is the responsibility of
    the caller to guarantee that nobody will be using the queue
    after this function is called
    
 */

BOOL
SimpleQueueTryAdd(
    IN PSIMPLEQUEUE q, 
    IN DWORD      PayloadSize, 
    IN PVOID      Payload
    );
/*++

Routine Description:

    Tries to add data in a queue
    
Arguments:

    q           - a queue
    PayloadSise - size of the chunk to be added to a queue
    Payload     - pointer to a buffer that countains data to be added
             
Return Value:

    TRUE - if the data were put into the queue successfully
    FALSE - otherwise
    
Comments:

    DataAvailableCallback will be called 
    if there are data available. DataAvailableCallback will not be called 
    during subsequent add requests until Read/CompleteRead 
    operations empty the queue.
    
 */

BOOL
SimpleQueueReadAll(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
   );
/*++

Routine Description:

    Allows to read all available blocks
    
Arguments:

    q     - a queue
    begin - receives a pointer to the first queue block
    end   - receives a pointer past the end of the last queue block
             
Return Value:

    TRUE - if we get at least one block
    FALSE - if the queue is empty
    
Comments:

    This function not always give you ALL available blocks in the 
    queue. It gives you all blocks up until the hard end of the queue buffer or
    the writing head of the queue, whatever is smaller.
    If the function returns success, it guarantees that begin < end.
    
    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
    
    You can walk over these block using SQB_NEXTBLOCK macro.

 */

BOOL
SimpleQueueReadOne(
    IN PSIMPLEQUEUE q,
    OUT PVOID* begin,
    OUT PVOID* end
    );
/*++

Routine Description:

    Allows to read a single block of data
    
Arguments:

    q     - a queue
    begin - receives a pointer to the beginning of the first available queue block
    end   - receives a pointer past the end of this block
             
Return Value:

    TRUE  - success
    FALSE - if the queue is empty
    
Comments:

    When you finished processing of the data, you need to call 
    SimpleQueueReadComplete function.
 */

BOOL 
SimpleQueueReadComplete(
    IN PSIMPLEQUEUE q,
    IN PVOID newtail
    );
/*++

Routine Description:

    Use this function to signal that the block of data was
    consumed
    
Arguments:

    q     - a queue
    end   - receives a pointer past the end of the last consumed block.
            Usually this is a value returned by the PVOID end parameter of
            ReadOne and ReadAll
             
Return Value:

    TRUE  - There are more data
    FALSE - if the queue is empty
    
Important!!!
     
    If the result of this function is TRUE, the caller should consume the data
    using ReadOne or ReadAll functions followed by the calls 
    to ReadComplete until it returns FALSE.
    
    Otherwise, no futher DataAvailable notifications will be produced bu
    SimpleQueueTryAdd
    
 */

#ifdef COUNT_DROPPED_PACKETS
VOID
CheckForDroppedData(
    IN PSIMPLEQUEUE q, 
    IN BOOL Now
    );
/*++

Routine Description:

    This function checks whether there were
    some data dropped and if the time is right,
    calls DropNotifyCallback function.
    
Arguments:

    q     - a queue
    Now   - If TRUE, than DropNotifyCallback will be called 
            immediately if there are dropped data.
            If FALSE, DropNotifyCallback will be called
            only if it is more then DroppedNotifyInterval
            seconds elapsed, since the last time we called
            DropNotifyCallback
            
Return Value:

    None
 */

#else

#define CheckForDroppedData(x,y) 

#endif


typedef struct _SIMPLEQUEUE {
    CRITICAL_SECTION Lock;
    PWCHAR           Name;  // arbitrary string
    PUCHAR           Begin; // queue buffer start
    PUCHAR           End;   // queue buffer end

    PUCHAR           Head;  // writing head
    PUCHAR           Tail;  // consuming end

    PUCHAR           Wrap;  // wrap == 0, if tail < head
                            // otherwise if it points past the end of 
                            // the last block before queue buffer end

    BOOL             Empty; // This flag is properly maintained by the queue,
                            // but not required for the queue to operate
                            // Can be removed if nobody needs it

    BOOL             Enabled; // Add operation to the queue will fail
                              // if the enabled flag is not set

    UINT32           ReadInProgress; // DataAvailableCallback notification
                                     // was issued and processing is not
                                     // complete.
                                     //
                                     // This flag is reset by ReadComplete
                                     // when there are no more data

    DATA_AVAILABLE_CALLBACK DataAvailableCallback;

#ifdef COUNT_DROPPED_PACKETS
    ULARGE_INTEGER   NextDroppedDataNotify;
    DROPPED_DATA_NOTIFY DroppedDataNotifyCallback;
    ULARGE_INTEGER   DroppedDataNotifyInterval;

    DWORD            DroppedDataCount; // These two variable are reset each time
    DWORD            DroppedDataSize;  // we call DroppedDataNotifyCallback
#endif
    //
} SIMPLEQUEUE;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmclient.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmclient.c

Abstract:

    Cluster client side routines for RPC remote calls.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE FMCLIENT


DWORD
FmcOnlineGroupRequest(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    This routine requests (THE) remote system to bring the Group Online.

Arguments:

    Group - The Group to bring online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);
    status = FmsOnlineGroupRequest( Session[OwnerId],
                                    OmObjectId(Group) );

    return(status);

} // FmcOnlineGroupRequest



DWORD
FmcOfflineGroupRequest(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    This routine requests a remote system to take the Group Offline.

Arguments:

    Group - The Group to take online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);
    CL_ASSERT(Session[OwnerId] != NULL);
    status = FmsOfflineGroupRequest( Session[OwnerId],
                                     OmObjectId(Group) );

    return(status);

} // FmcOfflineGroupRequest



DWORD
FmcMoveGroupRequest(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    This routine requests (THE) remote system to move the Group there.

Arguments:

    Group - The Group to bring online.
    DestinationNode - The node to move the Group to.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Group lock must be held on entry.
    The Group lock is releaseed before returning.

--*/

{
    DWORD status;
    DWORD OwnerId;

    CL_ASSERT(Group->OwnerNode != NmLocalNode);
#if 1
    if ( Group ->OwnerNode == NULL ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] MoveRequest for group with no owner!\n");
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }
#endif
    CL_ASSERT(Group->OwnerNode != NULL);

    OwnerId = NmGetNodeId(Group->OwnerNode);

    FmpReleaseLocalGroupLock( Group );

    if (DestinationNode != NULL) {
        status = FmsMoveGroupRequest( Session[OwnerId],
                                      OmObjectId(Group ),
                                      OmObjectId(DestinationNode));
    } else {
        status = FmsMoveGroupRequest( Session[OwnerId],
                                      OmObjectId(Group ),
                                      NULL);
    }

    return(status);

} // FmcMoveGroupRequest



DWORD
FmcTakeGroupRequest(
    IN PNM_NODE DestinationNode,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    This routine requests a remote system to move the Group there.

Arguments:

    DestinationNode - The destination node
    GroupId - The Id of the Group to be moved.
    ResourceList - The list of the resources and their states.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status=ERROR_SUCCESS;
    RPC_BINDING_HANDLE Binding;
    PFM_GROUP group = NULL;
    DWORD nodeId;

    //
    // If the remote session is not established, then return failure.
    //
    if ( gpQuoResource == NULL ) {
        CsInconsistencyHalt(ERROR_INVALID_OPERATION_ON_QUORUM);
    }

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );
    if ( group == NULL ) {
        CsInconsistencyHalt(ERROR_GROUP_NOT_AVAILABLE);
    }

    if ( gpQuoResource->Group == group ) {
        // Quorum group
        // We don't need a lock on this usage, since there is only one
        Binding = FmpRpcQuorumBindings[NmGetNodeId(DestinationNode)];
        if ( Binding == NULL ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] TakeRequest and no remote binding available\n");
            OmDereferenceObject( group );
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }

        OmDereferenceObject( group );
        nodeId = NmGetNodeId(DestinationNode);
        try {
            NmStartRpc(nodeId);
            status = FmsTakeGroupRequest( Binding,
                                          GroupId,
                                          ResourceList );
        } finally {
            NmEndRpc(nodeId);
            if( status != RPC_S_OK ) {
                NmDumpRpcExtErrorInfo(status);
            }
        }

    } else {
        // Non-quorum group
        OmDereferenceObject( group );
        Binding = FmpRpcBindings[NmGetNodeId(DestinationNode)];
        if ( Binding == NULL ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] TakeRequest and no remote binding available\n");
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }

        // This is a shared binding, so serialize usage.
        //
        // Charlie Wickham (charlwi) - 10/30/00
        //
        // 185575: removing use of unique RPC binding handles hence no longer
        // any need to serialize take group requests.
        //
//        FmpAcquireBindingLock();

        //
        //  Chittur Subbaraman (chitturs) - 9/30/99
        //
        //  Enclose the RPC within a "try-finally" block so that the
        //  lock is released regardless of whether the RPC succeeds.
        //  Note that the caller of FmcTakeGroupRequest encloses
        //  that function in a "try-except" block.
        //
        nodeId = NmGetNodeId(DestinationNode);
        try {
            NmStartRpc(nodeId);
            status = FmsTakeGroupRequest( Binding,
                                          GroupId,
                                          ResourceList );
        } finally {
            NmEndRpc(nodeId);
            if( status != RPC_S_OK ) {
                NmDumpRpcExtErrorInfo(status);
            }

//            FmpReleaseBindingLock();
        }
    }

    return(status);

} // FmcTakeGroupRequest



DWORD
FmcOnlineResourceRequest(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests (THE) remote system to bring the Resource Online.

Arguments:

    Resource - The resource to bring online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsOnlineResourceRequest( Session[NodeId],
                                       OmObjectId(Resource) );

    return(status);

} // FmcOnlineResourceRequest



DWORD
FmcOfflineResourceRequest(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests (THE) remote system to take the Resource Offline.

Arguments:

    Resource - The resource to take offline.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsOfflineResourceRequest( Session[NodeId],
                                        OmObjectId(Resource) );
    return(status);

} // FmcOfflineResourceRequest


DWORD
FmcChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    )

/*++

Routine Description:

    This routine requests the owner of the resource to perform the change
    resource node operation.

Arguments:

    Resource - The resource to change the resource node.

    Node - The node to be added/removed from the resource list.

    Add - Specifies whether to add or remove the given node.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Note:

    The resource's lock must be held on entry. It is released prior to
    returning.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    FmpReleaseLocalResourceLock( Resource );
    status = FmsChangeResourceNode( Session[NodeId],
                                    OmObjectId(Resource),
                                    OmObjectId(Node),
                                    Add );

    return(status);

} // FmcChangeResourceNode



DWORD
FmcArbitrateResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to arbitrate a resource.

Arguments:

    Resource - The resource to arbitrate.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsArbitrateResource( Session[nodeId],
                                   OmObjectId(Resource) );
    return(status);

} // FmcArbitrateResource



VOID
FmcDeleteEnum(
    IN PGROUP_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an GROUP_ENUM and associated name strings.

Arguments:

    Enum - The GROUP_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        MIDL_user_free(Enum->Entry[i].Id);
    }

    MIDL_user_free(Enum);
    return;

} // FmcDeleteEnum



DWORD
FmcFailResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to fail a resource.

Arguments:

    Resource - The resource to fail.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsFailResource( Session[nodeId],
                              OmObjectId(Resource) );
    return(status);

} // FmcFailResource



PFM_RESOURCE
FmcCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    This routine requests a remote system to create a resource. The
    remote system should 'own' the group.

Arguments:

    Group - The group that the resource should be created inside.

    ResourceId - The id of the resource to create.

    ResourceName - The name of the resource to create.

    ResourceType - Resource type name

    dwFlags - Flags for the resource.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Group lock should be held... and is released by this routine.

--*/

{
    DWORD status;
    DWORD nodeId;
    PFM_RESOURCE resource = NULL;
    DWORD dwClusterHighestVersion;

    CL_ASSERT(Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    FmpReleaseLocalGroupLock( Group );

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );
                                    
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT51_MAJOR_VERSION )
    {   
        status = FmsCreateResource( Session[nodeId],
                                    OmObjectId(Group),
                                    ResourceId,
                                    ResourceName );
    } else
    {
        status = FmsCreateResource2( Session[nodeId],
                                     OmObjectId(Group),
                                     ResourceId,
                                     ResourceName,
                                     ResourceType,
                                     dwFlags );
    }

    if ( status == ERROR_SUCCESS ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceId );
        if ( resource != NULL ) {
            OmDereferenceObject( resource );
        }
    } else {
        SetLastError(status);
    }

    return(resource);

} // FmcCreateResource



DWORD
FmcDeleteResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine requests a remote system to delete a resource.

Arguments:

    Resource - The resource to delete.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Notes:

    The Resource lock should be held... and is released by this routine.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    FmpReleaseLocalResourceLock( Resource );

    status = FmsDeleteResource( Session[nodeId],
                                OmObjectId(Resource) );

    return(status);

} // FmcDeleteResource



DWORD
FmcResourceControl(
    IN PNM_NODE Node,
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    Resource - the resource to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;

    NodeId = NmGetNodeId(Node);
    if ((NmGetNodeState(Node) != ClusterNodeUp) &&
        ( NmGetNodeState(Node) != ClusterNodePaused))
    {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;

    status = FmsResourceControl( Session[NodeId],
                                 OmObjectId(Resource),
                                 ControlCode,
                                 InBuffer,
                                 InBufferSize,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );
    return(status);

} // FmcResourceControl



DWORD
FmcResourceTypeControl(
    IN PNM_NODE Node,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource type control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    ResourceTypeName - the name of the resource type to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    NodeId = NmGetNodeId(Node);
    if (( NmGetNodeState(Node) != ClusterNodeUp ) &&
        ( NmGetNodeState(Node) != ClusterNodePaused )) {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsResourceTypeControl( Session[NodeId],
                                     ResourceTypeName,
                                     ControlCode,
                                     InBuffer,
                                     InBufferSize,
                                     OutBuffer,
                                     OutBufferSize,
                                     BytesReturned,
                                     Required );
    return(status);

} // FmcResourceTypeControl



DWORD
FmcGroupControl(
    IN PNM_NODE Node,
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request to a remote system.

Arguments:

    Node - the remote node to send the request to.

    Group - the group to handle the request.

    ControlCode - the control code for this request.

    InBuffer - the input buffer.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBuffer - the size of the output buffer.

    BytesReturned - the length of the returned data.

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    NodeId = NmGetNodeId(Node);
    if (( NmGetNodeState(Node) != ClusterNodeUp ) &&
        ( NmGetNodeState(Node) != ClusterNodePaused )) {
        return(ERROR_HOST_NODE_NOT_AVAILABLE);
    }

    CL_ASSERT(Session[NodeId] != NULL);
    status = FmsGroupControl( Session[NodeId],
                              OmObjectId(Group),
                              ControlCode,
                              InBuffer,
                              InBufferSize,
                              OutBuffer,
                              OutBufferSize,
                              BytesReturned,
                              Required );
    return(status);

} // FmcGroupControl


DWORD
FmcPrepareQuorumResChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    )

/*++

Routine Description:

    This routine requests a the owner of a potential quorum resource
    to prepare for quorum logging and registry replication.

Arguments:

    Resource - The resource to on which we want to start logging.

    lpszQuoLogPath - The Path where the cluster log files should be created.

    dwMaxQuoLogSize - The new max Quorum Log Size.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(Resource->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(Resource->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsPrepareQuorumResChange( Session[nodeId],
                            OmObjectId(Resource),
                            lpszQuoLogPath,
                            dwMaxQuoLogSize );
    return(status);

} // FmcPrepareQuorumResChange


DWORD
FmcCompleteQuorumResChange(
    IN PFM_RESOURCE pOldQuoRes,
    IN LPCWSTR      lpszOldQuoLogPath
    )

/*++

Routine Description:

    This routine requests a the owner of the previous quorum resource
    to clean up after quorum resource change is complete.

Arguments:

    pOldQuoRes - The resource to on which we want to start logging.

    lpszOldQuoLogPath - The Path where the cluster log files should be created.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT(pOldQuoRes->Group->OwnerNode != NULL);

    nodeId = NmGetNodeId(pOldQuoRes->Group->OwnerNode);
    CL_ASSERT(Session[nodeId] != NULL);

    status = FmsCompleteQuorumResChange( Session[nodeId],
                            OmObjectId(pOldQuoRes),
                            lpszOldQuoLogPath);
    return(status);

} // FmcCompleteQuorumResChange




DWORD
FmcChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    This routine requests the owner of the resource to move the resource
    from one group to another.

Arguments:

    Resource - The resource whose group is to be changed.

    pNewGroup - The group to which the resource should be moved to.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

Note:

    The group locks for both the old and the new group must be held on entry.
    They are release before making the rpc call.

--*/

{
    DWORD   status;
    DWORD   NodeId;

    CL_ASSERT(pResource->Group->OwnerNode != NULL);

    NodeId = NmGetNodeId(pResource->Group->OwnerNode);
    CL_ASSERT(Session[NodeId] != NULL);
    FmpReleaseLocalGroupLock( pResource->Group );
    FmpReleaseLocalGroupLock( pNewGroup );
    status = FmsChangeResourceGroup( Session[NodeId],
                                    OmObjectId(pResource),
                                    OmObjectId(pNewGroup));

    return(status);

} // FmcChangeResourceNode

DWORD
FmcBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    )

/*++

Routine Description:

    This routine requests the owner of a potential quorum resource
    to backup the quorum log and the checkpoint file to the
    specified path. This function is called with the resource lock
    held.

Arguments:

    pQuoResource - The quorum resource.

    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    DWORD status;
    DWORD nodeId;

    CL_ASSERT( pQuoResource->Group->OwnerNode != NULL );

    nodeId = NmGetNodeId( pQuoResource->Group->OwnerNode );
    CL_ASSERT( Session[nodeId] != NULL );

    //
    //  Chittur Subbaraman (chitturs) - 10/16/98
    //
    //  Release the resource lock. Releasing the resource lock
    //  here can create a window during which this node thinks
    //  the other node is the owner and the other node thinks
    //  this node is the owner. But, unfortunately we've to treat 
    //  this as an error case so that we don't run into deadlocks 
    //  across multiple machines due to the lock being held while
    //  making the RPC.
    //
    FmpReleaseLocalResourceLock( pQuoResource );

    status = FmsBackupClusterDatabase( Session[nodeId],
                                 OmObjectId( pQuoResource ),
                                 lpszPathName );

    return( status );
} // FmcBackupClusterDatabase


/****
@func       DWORD | FmcDeleteGroup| This makes a rpc call to the owner
            of the group to handle the delete group request.

@parm       IN PFM_GROUB | pGroup | The group that must be deleted.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD
FmcDeleteGroupRequest(
    IN PFM_GROUP pGroup
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId(pGroup->OwnerNode);

    CL_ASSERT(dwOwnerId != NmLocalNodeId);

    //release the lock before making the rpc call
    FmpReleaseLocalGroupLock( pGroup );
    
    dwStatus = FmsDeleteGroupRequest( Session[dwOwnerId],
                    OmObjectId(pGroup) 
                    );
    return(dwStatus);                                   


}
    

/****
@func       DWORD | FmcAddResourceDependency | This makes an RPC to the 
            owner of the resource to handle the dependency addition.

@parm       IN PFM_RESOURCE | pResource | The resource to add the 
            dependent resource.

@parm       IN PFM_RESOURCE | pDependentResource | The dependent resource.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns an error code. ERROR_SUCCESS on success.
****/
DWORD
FmcAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId( pResource->Group->OwnerNode );

    CL_ASSERT( dwOwnerId != NmLocalNodeId );
    //
    // Release the lock before making the RPC call
    //
    FmpReleaseLocalResourceLock( pResource );
    
    dwStatus = FmsAddResourceDependency( Session[dwOwnerId],
                                         OmObjectId( pResource ),
                                         OmObjectId( pDependentResource )
                                       );
    return( dwStatus );                                   
}

/****
@func       DWORD | FmcRemoveResourceDependency | This makes an RPC to the 
            owner of the resource to handle the dependency removal.

@parm       IN PFM_RESOURCE | pResource | The resource to remove the 
            dependent resource from.

@parm       IN PFM_RESOURCE | pDependentResource | The dependent resource.
            
@comm       The owner node should make the GUM request to avoid deadlocks.

@rdesc      Returns an error code. ERROR_SUCCESS on success.
****/
DWORD
FmcRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
)
{
    DWORD   dwOwnerId;
    DWORD   dwStatus;
    
    dwOwnerId = NmGetNodeId( pResource->Group->OwnerNode );

    CL_ASSERT( dwOwnerId != NmLocalNodeId );
    //
    // Release the lock before making the RPC call
    //
    FmpReleaseLocalResourceLock( pResource );
    
    dwStatus = FmsRemoveResourceDependency( Session[dwOwnerId],
                                            OmObjectId( pResource ),
                                            OmObjectId( pDependentResource )
                                          );
    return( dwStatus );                                   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fminit.c

Abstract:

    Initialization for the Failover Manager component of the
    NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996
    Rod Gamache (rodga) 14-Mar-1996


Revision History:

--*/
#include "..\nm\nmp.h"                /* For NmpEnumNodeDefinitions */
#ifdef LOG_CURRENT_MODULE
#undef LOG_CURRENT_MODULE
#endif
#include "fmp.h"


#define LOG_MODULE FMINIT

// The order in which the locks should be acquired is
// 1) gQuoChangeLock
// 2) GroupLock
// 3) gQuoLock
// 4) GumLocks
// 4*) gResTypeLock - this lock is acquired inside gum updates 
// 5) gLockDmpRoot
// 6) pLog->Lock


//A lock for synchronizing online/offline with respect to the quorum
//resource
//This lock is held in exclusive mode when bringing the quorum resource
//online/offline and in shared mode when other resources are brought online
//offline
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gQuoLock;
#else
    RTL_RESOURCE        gQuoLock;
#endif    

//A lock for synchronizing changes to the resource->quorumresource field   
//and allowing changes to the quorum resource's group in form phase1
// and phase 2 of fm.
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gQuoChangeLock;
#else
    RTL_RESOURCE        gQuoChangeLock;
#endif    

//A lock for synchronizing changes to the resource type field entries.
//shared by all resource types.
#if NO_SHARED_LOCKS
    CRITICAL_SECTION    gResTypeLock;
#else
    RTL_RESOURCE        gResTypeLock;
#endif    


GUM_DISPATCH_ENTRY FmGumDispatchTable[] = {
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeResourceName},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeGroupName},
    {1, FmpUpdateDeleteResource},
    {1, FmpUpdateDeleteGroup},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateAddDependency},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateRemoveDependency},
    {1, FmpUpdateChangeClusterName},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeQuorumResource},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateResourceState},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupState},
    {4, (PGUM_DISPATCH_ROUTINE1)EpUpdateClusWidePostEvent},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupNode},
    {3, (PGUM_DISPATCH_ROUTINE1)FmpUpdatePossibleNodeForResType},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateGroupIntendedOwner},
    {1, (PGUM_DISPATCH_ROUTINE1)FmpUpdateAssignOwnerToGroups},
    {1, (PGUM_DISPATCH_ROUTINE1)FmpUpdateApproveJoin},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateCompleteGroupMove},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateCheckAndSetGroupOwner},
    {2, (PGUM_DISPATCH_ROUTINE1)FmpUpdateUseRandomizedNodeListForGroups},
    {5, (PGUM_DISPATCH_ROUTINE1)FmpUpdateChangeQuorumResource2},
    };


#define WINDOW_TIMEOUT (15*60*1000)    // Try every 15 minutes

//
// Global data initialized in this module
//

PRESMON FmpDefaultMonitor = NULL;
DWORD FmpInitialized = FALSE;
DWORD FmpFMOnline = FALSE;
DWORD FmpFMGroupsInited = FALSE;
DWORD FmpFMFormPhaseProcessing = FALSE; //this is set to true when form new cluster phase processing starts
BOOL FmpShutdown = FALSE;
BOOL FmpMajorEvent = FALSE;     // Signals a major event while joining
DWORD FmpQuorumOnLine = FALSE;

HANDLE FmpShutdownEvent;
HANDLE FmpTimerThread;

HANDLE  ghQuoOnlineEvent = NULL;    // the event that is signalled when the quorum res is online
DWORD   gdwQuoBlockingResources = 0; // the number of resources in pending stated which prevent the quorum res state change

PFM_NODE    gFmpNodeArray = NULL;

// 185575: remove unique RPC binding handles
//CRITICAL_SECTION FmpBindingLock;

//
// Local functions
//
BOOL
FmpEnumNodes(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    );

DWORD
FmpJoinPendingThread(
    IN LPVOID Context
    );


DWORD FmpGetJoinApproval();

static 
DWORD 
FmpBuildForceQuorumInfo(
    IN LPCWSTR pszNodesIn,
    OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    );

static 
void
FmpDeleteForceQuorumInfo(
    IN OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    );


DWORD
WINAPI
FmInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the failover manager

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    OM_OBJECT_TYPE_INITIALIZE ObjectTypeInit;
    DWORD NodeId;

    CL_ASSERT(!FmpInitialized);

    if ( FmpInitialized ) {
        return(ERROR_SUCCESS);
    }
    Status = EpRegisterEventHandler(CLUSTER_EVENT_ALL,FmpEventHandler);
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt( Status );
    }

    //register for synchronous node down notifications
    Status = EpRegisterSyncEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    FmpSyncEventHandler);

    if (Status != ERROR_SUCCESS){
        CsInconsistencyHalt( Status );
    }

    //
    // Initialize Critical Sections.
    //

    InitializeCriticalSection( &FmpResourceLock );
    InitializeCriticalSection( &FmpGroupLock );
    InitializeCriticalSection( &FmpMonitorLock );

    //
    // Initialize the monitor list head
    //
    InitializeListHead ( &g_leFmpMonitorListHead );

// 185575: remove unique RPC binding handles
//    InitializeCriticalSection( &FmpBindingLock );

    // initialize the quorum lock
    // This is used to synchronize online/offlines of other resources
    // with respect to the quorum resource
    INITIALIZE_LOCK(gQuoLock);
    //this is used to check/change the resource->quorum value
    //This synchronization is needed between the resource transition
    //processing that needs to do special processing for quorum 
    //resource and the gum update handler to change the quorum resource
    INITIALIZE_LOCK(gQuoChangeLock);

    //Initialize the restype lock
    INITIALIZE_LOCK(gResTypeLock);
    
    // create a unnamed event that is used for waiting for quorum resource
    // to go online
    // This is a manual reset event and is initialized to unsignalled state.
    // When the quorum resource goes to pending state this is manually reset 
    // to unsignalled state. When the quorum resource goes online it is set 
    // to signalled state
    ghQuoOnlineEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ghQuoOnlineEvent)
    {
        CL_UNEXPECTED_ERROR((Status = GetLastError()));
        return(Status);

    }

    gFmpNodeArray = (PFM_NODE)LocalAlloc(LMEM_FIXED,
                     (sizeof(FM_NODE) * (NmGetMaxNodeId() + 1))
                     );

    if (gFmpNodeArray == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //initialize it and the RPC binding table
    for (NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) 
    {
        FmpRpcBindings[NodeId] = NULL;
        FmpRpcQuorumBindings[NodeId] = NULL;
        gFmpNodeArray[NodeId].dwNodeDownProcessingInProgress = 0;
        gFmpNodeArray[NodeId].dwNodeDownProcessingThreadId = 0;
    }

    //
    // Initialize the FM work queue.
    //
    Status = ClRtlInitializeQueue( &FmpWorkQueue );
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Create a pending event notification.
    //
    FmpShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( FmpShutdownEvent == NULL ) {
        return(GetLastError());
    }

    //
    // Initialize Group Types.
    //
    ObjectTypeInit.Name = FMP_GROUP_NAME;
    ObjectTypeInit.Signature = FMP_GROUP_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_GROUP);
    ObjectTypeInit.DeleteObjectMethod = FmpGroupLastReference;

    Status = OmCreateType( ObjectTypeGroup,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize Resource Types.
    //
    ObjectTypeInit.Name = FMP_RESOURCE_NAME;
    ObjectTypeInit.Signature = FMP_RESOURCE_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_RESOURCE);
    ObjectTypeInit.DeleteObjectMethod = FmpResourceLastReference;

    Status = OmCreateType( ObjectTypeResource,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize ResType Types.
    //
    ObjectTypeInit.Name = FMP_RESOURCE_TYPE_NAME;
    ObjectTypeInit.Signature = FMP_RESOURCE_TYPE_SIGNATURE;
    ObjectTypeInit.ObjectSize = sizeof(FM_RESTYPE);
    ObjectTypeInit.DeleteObjectMethod = FmpResTypeLastRef;

    Status = OmCreateType( ObjectTypeResType,
                           &ObjectTypeInit );

    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    //
    // Initialize the Notify thread.
    //
    Status = FmpInitializeNotify();
    if (Status != ERROR_SUCCESS) {
        CsInconsistencyHalt(Status);
        return(Status);
    }



    //
    // Initialize the FM worker thread.
    //
    Status = FmpStartWorkerThread();
    if ( Status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(Status);
        return(Status);
    }

    FmpInitialized = TRUE;

    return(ERROR_SUCCESS);

} // FmInitialize



BOOL
FmpEnumGroupsInit(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. This phase completes initialization
    of every group.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{


    //
    // Finish initializing the group.
    //
    FmpCompleteInitGroup( Group );


    return(TRUE);

} // FmpEnumGroupsInit

BOOL
FmpEnumFixupResources(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. This phase completes initialization
    of every group.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;

    FmpAcquireLocalGroupLock( Group );

    //
    // For each resource in the Group, make sure it gets an
    // opportunity to do fixups.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        FmpRmResourceControl( Resource,
                    CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED, 
                    (LPBYTE)pClusterVersionInfo,
                    pClusterVersionInfo->dwVersionInfoSize,
                    NULL,
                    0,
                    NULL,
                    NULL
                    );
                  

    }

    FmpReleaseLocalGroupLock( Group);

    return(TRUE);

} // FmpEnumFixupResources


BOOL
FmpEnumJoinGroupsMove(
    IN LPBOOL Deferred,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. Queries the preferred owners
    groups and moves those that belong on this system and that can move.

Arguments:

    Deferred - TRUE if a move was deferred because of Failback Window. Must
               be FALSE on first call.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY listEntry;
    PPREFERRED_ENTRY preferredEntry;
    SYSTEMTIME  localTime;
    BOOL        failBackWindowOkay = FALSE;
    DWORD       threadId;
    DWORD       status;

    GetLocalTime( &localTime );

    FmpAcquireLocalGroupLock( Group );

    //
    // Adjust ending time if needed.
    //
    if ( Group->FailbackWindowStart > Group->FailbackWindowEnd ) {
        Group->FailbackWindowEnd += 24;
        if ( Group->FailbackWindowStart > localTime.wHour ) {
            localTime.wHour += 24;
        }
    }

    //
    // If the Failback start and end times are valid, then check if we need
    // to start a timer thread to move the group at the appropriate time.
    //
    if ( (Group->FailbackType == GroupFailback) &&
         ((Group->FailbackWindowStart != Group->FailbackWindowEnd) &&
         (localTime.wHour >= Group->FailbackWindowStart) &&
         (localTime.wHour < Group->FailbackWindowEnd)) ||
         (Group->FailbackWindowStart == Group->FailbackWindowEnd) ) {
        failBackWindowOkay = TRUE;
    }

    //
    // Check if we need to move the group.
    //
    if ( !IsListEmpty( &Group->PreferredOwners ) ) {
        listEntry = Group->PreferredOwners.Flink;
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        //
        // Move group if:
        //  0. Remote system is paused, and we're not OR
        //  1. Our system is in the preferred list and the owner node is not OR
        //  2. Group is Offline or Group is Online/PartialOnline and it can
        //     failback AND
        //  3. Group's preferred list is ordered and our system is higher
        //

        if ( Group->OwnerNode == NULL ) {
            // Should we shoot ourselves because we got an incomplete snapshot
            // of the joint attempt.
            CsInconsistencyHalt(ERROR_CLUSTER_JOIN_ABORTED);
        } else if ( Group->OwnerNode != NmLocalNode) {
            if (((NmGetNodeState(NmLocalNode) != ClusterNodePaused) &&
                    (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused)) ||

                (FmpInPreferredList(Group, NmLocalNode, FALSE, NULL) &&
                    !FmpInPreferredList( Group, Group->OwnerNode, FALSE, NULL)) ||

                 ((((Group->State == ClusterGroupOnline) ||
                    (Group->State == ClusterGroupPartialOnline)) &&
                      (Group->FailbackType == FailbackOkay) ||
                      (Group->State == ClusterGroupOffline)) &&
                     ((Group->OrderedOwners) &&
                     (FmpHigherInPreferredList(Group, NmLocalNode, Group->OwnerNode)))) ) {
                if ( failBackWindowOkay ) {
                    PNM_NODE OwnerNode = Group->OwnerNode;
                    
                    status = FmcMoveGroupRequest( Group, NmLocalNode );
                    if ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) ) {
                        //
                        //  Chittur Subbaraman (chitturs) - 7/31/2000
                        //
                        //  Log an event indicating an impending failback.
                        //
                        CsLogEvent3( LOG_NOISE,
                                     FM_EVENT_GROUP_FAILBACK,
                                     OmObjectName(Group),
                                     OmObjectName(OwnerNode), 
                                     OmObjectName(NmLocalNode) );
                    }
                    FmpAcquireLocalGroupLock( Group );
                } else {
                    //
                    // Start timer thread if not already running. If it fails,
                    // what possibly can we do?
                    //
                    if ( FmpTimerThread == NULL ) {
                        FmpTimerThread = CreateThread( NULL,
                                                       0,
                                                       FmpJoinPendingThread,
                                                       NULL,
                                                       0,
                                                       &threadId );
                    }
                    *Deferred = TRUE;
                }
            }                
        }
    }

    FmpReleaseLocalGroupLock( Group );

    return(TRUE);

} // FmpEnumJoinGroups



BOOL
FmpEnumSignalGroups(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback to indicate state change on all groups
    and resources.

    For the quorum resource, if we're forming a cluster, we'll also
    fixup information that was not available when the resource was created.

Arguments:

    Context1 - Pointer to a BOOL that is TRUE if this is a FormCluster.
               FALSE otherwise.

    Context2 - Not used.

    Group - Supplies the group.

    Name - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PLIST_ENTRY listEntry;
    PFM_RESOURCE resource;
    BOOL    formCluster = *(PBOOL)Context1;
    DWORD   status;
    BOOL    quorumGroup = FALSE;

    //
    // For each resource in the group, generate an event notification.
    //

    for (listEntry = Group->Contains.Flink;
         listEntry != &(Group->Contains);
         listEntry = listEntry->Flink ) {
        resource = CONTAINING_RECORD( listEntry,
                                      FM_RESOURCE,
                                      ContainsLinkage );
        //
        // If this is the quorum resource and we're performing a Form
        // Cluster, then fixup the quorum resource info.
        //
        if ( resource->QuorumResource ) {
            status = FmpFixupResourceInfo( resource );
            quorumGroup = TRUE;
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint( LOG_NOISE,
                            "[FM] Warning, failed to fixup quorum resource %1!ws!, error %2!u!.\n",
                            OmObjectId(resource),
                            status );
            }
        }

        if ( resource->State == ClusterResourceOnline ) {
            ClusterEvent( CLUSTER_EVENT_RESOURCE_ONLINE, resource );
        } else {
            ClusterEvent( CLUSTER_EVENT_RESOURCE_OFFLINE, resource );
        }
    }

    if ( quorumGroup ) {
        status = FmpFixupGroupInfo( Group );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_NOISE,
                        "[FM] Warning, failed to fixup quorum group %1!ws!, error %2!u!.\n",
                        OmObjectId( Group ),
                        status );
        }
    }

    if ( Group->State == ClusterGroupOnline ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_ONLINE, Group );
    } else {
        ClusterEvent( CLUSTER_EVENT_GROUP_OFFLINE, Group );
    }

    return(TRUE);

} // FmpEnumSignalGroups



DWORD
FmpJoinPendingThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Thread to keep trying to move groups, as long we are blocked by a
    FailbackWindow problem. This thread runs every 15 minutes to attempt to
    move Groups.

Arguments:

    Context - Not used.

Return Value:

    ERROR_SUCCESS.

--*/

{
    DWORD   status;
    BOOL    deferred;

    //
    // As long as we have deferred Group moves, keep going.
    do {

        status = WaitForSingleObject( FmpShutdownEvent, WINDOW_TIMEOUT );

        if ( FmpShutdown ) {
            goto finished;
        }

        deferred = FALSE;

        //
        // For each group, see if it should be moved to the local system.
        //
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumJoinGroupsMove,
                       &deferred,
                       NULL );

    } while ( (status != WAIT_FAILED) && deferred );

finished:

    CloseHandle( FmpTimerThread );
    FmpTimerThread = NULL;

    return(ERROR_SUCCESS);

} // FmpJoinPendingThread



DWORD
WINAPI
FmGetQuorumResource(
    OUT PFM_GROUP   *ppQuoGroup,
    OUT LPDWORD     lpdwSignature  OPTIONAL
    )

/*++

Routine Description:

    Find the quorum resource, arbitrate it and return a name that can be
    used to open the device in order to perform reads. Optionally,
    return the signature of the quorum disk.

    There are 3 items that we need:

        1. The name of the quorum resource.
        2. The name of the Group that the quorum resource is a member of.
        3. The resource type for the quorum resource.

Arguments:

    ppQuoGroup - Supplies a pointer to a buffer into which the 
        quorum group info is returned.

    lpdwSignature - An optional argument which is used to return
        the signature of the quorum disk from the cluster hive.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    LPWSTR  quorumId = NULL;
    LPWSTR  groupId = NULL;
    LPCWSTR stringId;
    LPWSTR  containsString = NULL;
    PFM_GROUP group = NULL;
    PFM_RESOURCE resource = NULL;
    HDMKEY  hGroupKey;
    DWORD   groupIdSize = 0;
    DWORD   idMaxSize = 0;
    DWORD   idSize = 0;
    DWORD   status;
    DWORD   keyIndex;
    DWORD   stringIndex;

    *ppQuoGroup = NULL;

    //
    // Get the quorum resource value.
    //
    status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        (LPWSTR*)&quorumId,
                        &idMaxSize,
                        &idSize );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Failed to get quorum resource, error %1!u!.\n",
                   status);
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    //  If the user is forcing a database restore operation, you
    //  also need to verify whether the quorum disk signature in
    //  the registry matches that in the disk itself. So, go get 
    //  the signature from the Cluster\Resources\quorumId\Parameters
    //  key
    //
    if ( lpdwSignature != NULL ) {
        status = FmpGetQuorumDiskSignature( quorumId, lpdwSignature );
        if ( status != ERROR_SUCCESS ) {
            //
            //  This is not a fatal error. So log an error and go on.
            //
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] Failed to get quorum disk signature, error %1!u!.\n",
                   status);
        }
    }

    //
    // Initialize the default Resource Monitor
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }

    if (FmpDefaultMonitor == NULL) {
        status = GetLastError();
        CsInconsistencyHalt(status);
        goto FnExit;
    }

    //
    // Now find the group that the quorum resource is a member of.
    //
    idMaxSize = 0;
    idSize = 0;
    for ( keyIndex = 0;  ; keyIndex++ )
    {
        status = FmpRegEnumerateKey( DmGroupsKey,
                                     keyIndex,
                                     &groupId,
                                     &groupIdSize );

        if ( status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmGetQuorumResource: FmpRegEnumerateKey returns %1!u!\n",
                         status);
            break;
        }

        //open the group key
        hGroupKey = DmOpenKey( DmGroupsKey,
                              groupId,
                              KEY_READ );
        if (!hGroupKey)
            continue;
        //
        // Get the contains string.
        //
        status = DmQueryMultiSz( hGroupKey,
                                 CLUSREG_NAME_GRP_CONTAINS,
                                 &containsString,
                                 &idMaxSize,
                                 &idSize );
        DmCloseKey(hGroupKey);

        if ( status != ERROR_SUCCESS )
            continue;
        for ( stringIndex = 0;  ; stringIndex++ )
        {
            stringId = ClRtlMultiSzEnum( containsString,
                                         idSize/sizeof(WCHAR),
                                         stringIndex );
            if ( stringId == NULL ) {
                break;
            }
            if ( lstrcmpiW( stringId, quorumId ) == 0 )
            {
                // We will now create the group, which will also
                // create the resource, and the resource type.
                //
                // TODO - this will also create all resources
                // within the group. What should we do about that?
                // We could require the quorum resource to be in
                // a group by itself! (rodga) 17-June-1996.
                //
                group = FmpCreateGroup( groupId,
                                        FALSE );
                if (CsNoQuorum)
                    FmpSetGroupPersistentState(group, ClusterGroupOffline);
                                        
                break;
            }
        }
        //if we found the group, thre is no need to search for more
        if (group != NULL)
            break;
    }

    //
    // Check if we found the Quorum resource's group.
    //
    if ( group == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Did not find group for quorum resource.\n");
        status = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    //
    // Get the quorum resource structure.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, quorumId );
    if ( resource == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Failed to find quorum resource object.\n");
        status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    resource->QuorumResource = TRUE;

    if (!CsNoQuorum)
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Arbitrate for quorum resource id %1!ws!.\n",
                   OmObjectId(resource));

        //
        // First finish initializing the quorum resource.
        //
        if ( resource->Monitor == NULL )
        {
            status = FmpInitializeResource( resource, TRUE );
            if ( status != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Error completing initialization of quorum resource '%1!ws!, error %2!u!.\n",
                           OmObjectId(resource),
                           status );
                goto FnExit;
            }
        }

        if ( CsForceQuorum ) {
            status = FmpSendForceQuorumControlToResource( resource );
            if ( status != ERROR_SUCCESS ) {
                // The routine does its own logging.  Just bail.
                goto FnExit;
            }
        }

        
        //
        // Now arbitrate for the resource.
        //
        status = FmpRmArbitrateResource( resource );

    }

FnExit:
    if ( status == ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmGetQuorumResource successful\n");
        *ppQuoGroup = group;
    }
    else
    {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmGetQuorumResource failed, error %1!u!.\n",
                   status);
        //the group will be cleaned by fmshutdown()

    }
    if (resource) OmDereferenceObject(resource);
    if (quorumId) LocalFree(quorumId);
    if (groupId) LocalFree(groupId);
    //
    //  Chittur Subbaraman (chitturs) - 10/05/98
    //  Fix memory leak
    //
    if (containsString) LocalFree(containsString);
    return(status);
} // FmGetQuorumResource



DWORD 
WINAPI
FmpSendForceQuorumControlToResource(
    PFM_RESOURCE resource )
{
    PCLUS_FORCE_QUORUM_INFO pForceQuorumInfo = NULL;
    DWORD status;
    
    //
    // If we have a force quorum (Majority Node Set) then drop a control code to the
    // resource with the list of nodes.  This must be done before
    // arbitrate.  First we build force quorum info - this makes sure that the node list is valid etc.
    // Note that the list can be NULL.
    //
    status = FmpBuildForceQuorumInfo( CsForceQuorumNodes,
                                      &pForceQuorumInfo );
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] Error building force quorum info for resource '%1!ws!, error %2!u!.\n",
                      OmObjectId(resource),
                      status );
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] sending CLUSCTL_RESOURCE_FORCE_QUORUM\n" );

    status = FmpRmResourceControl( resource,
                                   CLUSCTL_RESOURCE_FORCE_QUORUM,
                                   (LPBYTE)pForceQuorumInfo,
                                   pForceQuorumInfo->dwSize,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL );
    //
    // Tolerate ERROR_INVALID_FUNCTION since this just means that the
    // resource doesn't handle it.
    //
    if ( status == ERROR_INVALID_FUNCTION )
        status = ERROR_SUCCESS;
    
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] Resource control for Force Quorum for resource '%1!ws! encountered error %2!u!.\n",
                      OmObjectId(resource),
                      status );
    }

FnExit:
    if (pForceQuorumInfo) FmpDeleteForceQuorumInfo( &pForceQuorumInfo );

    return status;
}



BOOL
WINAPI
FmpIsNodeInForceQuorumNodes(
    IN LPCWSTR lpszNodeId )
{
    BOOL    result = FALSE;
    PCLUS_FORCE_QUORUM_INFO pForceQuorumInfo = NULL;
    DWORD dwNodeId;
    PNM_NODE pNmNode = NULL;
    DWORD status;
    
    status = FmpBuildForceQuorumInfo( CsForceQuorumNodes,
                                      &pForceQuorumInfo );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] Error building force quorum info, error %1!u!.\n",
                      status );
        goto FnExit;
    }

    pNmNode = OmReferenceObjectById(
                     ObjectTypeNode,
                     lpszNodeId );

    if (pNmNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint( LOG_UNUSUAL, 
            "[FM] Node %1!ws! is not a member of this cluster. Cannot join.\n",
            lpszNodeId );
        goto FnExit;
    }

    dwNodeId = NmGetNodeId( pNmNode );
    
    result = ( pForceQuorumInfo->dwNodeBitMask & ( 1 << dwNodeId )) != 0;

    ClRtlLogPrint( LOG_NOISE,
        "[FM] Node %1!ws! is %2!ws!in the ForceQuorumNodes list.\n",
        lpszNodeId,
        ( result ? L"" : L"not " ));
    
FnExit:
    if (pForceQuorumInfo) FmpDeleteForceQuorumInfo( &pForceQuorumInfo );
    if ( pNmNode ) OmDereferenceObject( pNmNode );

    return result;
}


DWORD
WINAPI
FmFindQuorumResource(
    OUT PFM_RESOURCE *ppResource
    )
/*++

Routine Description:

    Finds the quorum resource and returns a pointer to the resource
    object.

Arguments:

    *ppResource - A pointer to the Quorum resource object is returned in this.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    //enumerate all the resources
    *ppResource = NULL;

    OmEnumObjects( ObjectTypeResource,
                   FmpFindQuorumResource,
                   ppResource,
                   NULL );

    if ( *ppResource == NULL )
    {
        dwError = ERROR_RESOURCE_NOT_FOUND;
        CL_LOGCLUSERROR(FM_QUORUM_RESOURCE_NOT_FOUND);
    }

    return(dwError);
}


DWORD WINAPI FmFindQuorumOwnerNodeId(IN PFM_RESOURCE pResource)
{
    DWORD dwNodeId;

    CL_ASSERT(pResource->Group->OwnerNode != NULL);
    dwNodeId = NmGetNodeId(pResource->Group->OwnerNode);

    return (dwNodeId);
}



BOOL
FmpReturnResourceType(
    IN OUT PFM_RESTYPE *FoundResourceType,
    IN LPCWSTR ResourceTypeName,
    IN PFM_RESTYPE ResourceType,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM join. Queries the preferred owners
    groups and moves those that belong on this system and that can move.

Arguments:

    ResourceType - Returns the found ResourceType, if found.

    Context2 - The input resource type name to find.

    Resource - Supplies the current ResourceType.

    Name - Supplies the ResourceType's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{

    if ( lstrcmpiW( Name, ResourceTypeName ) == 0 ) {
        OmReferenceObject( ResourceType );
        *FoundResourceType = ResourceType;
        return(FALSE);
    }

    return(TRUE);

} // FmpReturnResourceType


DWORD
WINAPI
FmFormNewClusterPhase1(
    IN PFM_GROUP pQuoGroup
    )

/*++

Routine Description:

    Destroys the quorum group that was created.  The quorum resource is left
    behind and its group adjusted according to the new logs.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD           status;


    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmFormNewClusterPhase1, Entry.  Quorum quorum will be deleted\n");

    //
    // Enable the GUM.
    //
    GumReceiveUpdates(FALSE,
                      GumUpdateFailoverManager,
                      FmpGumReceiveUpdates,
                      NULL,
                      sizeof(FmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      FmGumDispatchTable,
                      FmpGumVoteHandler);

    //Acquire the exclusive lock for the quorum
    // This is done so that we can ignore any resource transition events from
    // the quorum resource between phase 1 and phase 2 of FM initialization on Form
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);

    FmpFMFormPhaseProcessing = TRUE;

    //release the quorum lock
    RELEASE_LOCK(gQuoChangeLock);

    //the group lock will be freed by FmpDestroyGroup
    FmpAcquireLocalGroupLock( pQuoGroup );

    //destroy the quorum group object, dont bring the quorum resource online/offline
    //All resources in the quorum group must get deleted, except the quorum resource
    //All resources in the quorum group must get recreated in FmFormNewClusterPhase2.
    //The quorum group is removed from the group list, hence it will be recreated in phase2.
    //Since the quorum resource must not get deleted we will increment its ref count
    //This is because in phase 2 it is not created and its ref count is not incremented at create
    //By the time it is put on the contains list, we expect the resource count to be 2.
    OmReferenceObject(gpQuoResource);
    status = FmpDestroyGroup(pQuoGroup, TRUE);

    //We prefer that the quorum group is deleted
    //since after rollback the old group may no longer exist and we
    //dont want it to be on the group list
    gpQuoResource->Group = NULL;
    OmDereferenceObject(pQuoGroup);
    
    return(status);

} // FmFormNewClusterPhase1



DWORD
WINAPI
FmFormNewClusterPhase2(
    VOID
    )

/*++

Routine Description:

    Bring the Failover Manager Online, this means claiming all groups and
    finishing the initialization of resources.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD           status;
    BOOL            formCluster = TRUE;
    PFM_GROUP       group;
    PFM_RESOURCE    pQuoResource=NULL;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    PCLUSTERVERSIONINFO pClusterVersionInfo = NULL;
    PGROUP_ENUM     MyGroups = NULL;
    BOOL            QuorumGroup;



    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmFormNewClusterPhase2, Entry.\n");


    //
    // Initialize resource types
    //
    status = FmpInitResourceTypes();
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        goto error_exit;
    }

    //
    // Initialize Groups, 
    //
    status = FmpInitGroups( FALSE );
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    // refigure out the state for the quorum group
    status = FmFindQuorumResource(&pQuoResource);
    if (status != ERROR_SUCCESS)
    {
        goto error_exit;
    }
    //
    // Set the state of the quorum group depending upon the state of 
    // the quorum resource
    //
    //now we should enable resource events to come in for the quorum resource as well
    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    FmpFMFormPhaseProcessing = FALSE;

    group = pQuoResource->Group;
    group->State = FmpGetGroupState(group, TRUE);
    OmDereferenceObject(pQuoResource);

    //if the noquorum flag is set, dont bring the quorum group online 
    if (CsNoQuorum)
        FmpSetGroupPersistentState(pQuoResource->Group, ClusterGroupOffline);

    RELEASE_LOCK(gQuoChangeLock);

    //
    // Check if resource dll deadlock detection is enabled. This must be called only
    // after FmpInitialized is set to TRUE.
    //
    FmCheckIsDeadlockDetectionEnabled (); 
   
    //
    // Initialize the default Resource Monitor
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }

    if (FmpDefaultMonitor == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Failed to create default resource monitor on Form.\n");
        goto error_exit;
    }

    
    if (NmLocalNodeVersionChanged)
    {
        //initialize the version information
        CsGetClusterVersionInfo(&ClusterVersionInfo);
        pClusterVersionInfo = &ClusterVersionInfo;
    }


    //enable votes and gum updates since the fixups for
    //resource types require that
    FmpFMGroupsInited = TRUE;

    //
    // The resource type possible node list is built
    // using a voting protocol, hence we need to
    // fix it up since the vote could have been conducted
    // while this node was down.
    // Also call the resource type control code if the
    // local node version has changed
    //
    status = FmpFixupResourceTypesPhase1(FALSE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        goto error_exit;
    }


    //
    // Find and sort all known groups
    //
    status = FmpEnumSortGroups(&MyGroups, NULL, &QuorumGroup);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }


    //
    // Find the state of the Groups.
    //
    FmpGetGroupListState( MyGroups );

    //
    // Set the Group owner.
    //
    FmpSetGroupEnumOwner( MyGroups, NmLocalNode, NULL, QuorumGroup, NULL );


    //
    // For each group, finish initialization of all groups and resources.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumGroupsInit,
                   NULL,
                   NULL );

    // if the resource type is not supported, remove it from the possible 
    // owners list of all resources of that type
    status = FmpFixupPossibleNodesForResources(FALSE);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    if (NmLocalNodeVersionChanged)
    {

        //
        // For each group, allow all resources to do any fixups
        // they might need to do to the cluster registry to
        // run in a mixed mode cluster.
        //
        // Get the version info
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumFixupResources,
                       &ClusterVersionInfo,
                       NULL );

    }
    

    
    //
    // Take ownership of all the groups in the system. This also completes
    // the initialization of all resources.
    //
    status = FmpClaimAllGroups(MyGroups);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,"[FM] FmpClaimAllGroups failed %1!d!\n",status);
        goto error_exit;
    }

    //
    // Cleanup
    //
    FmpDeleteEnum(MyGroups);

    FmpFMOnline = TRUE;

    //
    // Signal a state change for every group and resource!
    //
    OmEnumObjects( ObjectTypeGroup,
                  FmpEnumSignalGroups,
                  &formCluster,
                  NULL );

    //
    //  Chittur Subbaraman (chitturs) - 5/3/2000
    //
    //  Make sure the phase 2 notifications are delivered only after all initialization is
    //  complete. This includes fixing up the possible owners of the quorum resource by
    //  FmpEnumSignalGroups. Once phase 2 notifications are delivered, resource type DLLs
    //  would be free to issue cluster API calls into FM and the lack of possible owners should
    //  not be the reason to reject these calls.
    //
    status = FmpFixupResourceTypesPhase2(FALSE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);

    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt( status );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,"[FM] FmFormNewClusterPhase2 complete.\n");
    return(ERROR_SUCCESS);


error_exit:

    if (MyGroups) FmpDeleteEnum(MyGroups);
    
    FmpShutdown = TRUE;
    FmpFMOnline = FALSE;

    FmpCleanupGroups(FALSE);
    if (FmpDefaultMonitor != NULL) {
        FmpShutdownMonitor( FmpDefaultMonitor );
        FmpDefaultMonitor = NULL;
    }

    FmpShutdown = FALSE;

    return(status);



} // FmFormNewClusterPhase2



DWORD
WINAPI
FmJoinPhase1(
    OUT DWORD *EndSeq
    )
/*++

Routine Description:

    Performs the FM initialization and join procedure. This creates skeletal
    groups and resources, which are not fully initialized. After the API is
    fully enabled (in Phase 2) we will finish initialization of the groups
    and resources (which causes the resource monitors to run and opens
    the resource DLL's.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD   status;
    DWORD   sequence;
    int           retries = 0;

    //
    // Enable Gum updates.
    //
    GumReceiveUpdates(TRUE,
                      GumUpdateFailoverManager,
                      FmpGumReceiveUpdates,
                      NULL,
                      sizeof(FmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      FmGumDispatchTable,
                      FmpGumVoteHandler);

retry:
    status = GumBeginJoinUpdate(GumUpdateFailoverManager, &sequence);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] GumBeginJoinUpdate failed %1!d!\n",
                   status);
        return(status);
    }

    //
    // Build up all the FM data structures for resource types.
    //
    //
    // Initialize resource types
    //
    status = FmpInitResourceTypes();
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    //
    // Initialize Groups, but don't fully initialize them yet.
    //
    status = FmpInitGroups( FALSE );
    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Initialize the default Resource Monitor. This step must be done before end join update
    // since this node can receive certain updates such as s_GumCollectVoteFromNode immediately
    // after GumEndJoinUpdate which may need the services of the default monitor.
    //
    if ( FmpDefaultMonitor == NULL ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
    }
    if ( FmpDefaultMonitor == NULL ) {
        status = GetLastError();
        CsInconsistencyHalt(status);
        return(status);
    }

    //
    // Get the group and resource state from each node which is online.
    //
    status = ERROR_SUCCESS;
    OmEnumObjects( ObjectTypeNode,
                   FmpEnumNodes,
                   &status,
                   NULL );
    if (status == ERROR_SUCCESS) {
        FmpFMGroupsInited = TRUE;
        // Gum Update handlers for resource and group state changes
        // can process the updates now.
        status = GumEndJoinUpdate(sequence,
                                  GumUpdateFailoverManager,
                                  FmUpdateJoin,
                                  0,
                                  NULL);
        if (status == ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] GumEndJoinUpdate with sequence %1!d! failed with a sequence mismatch\n",
                       sequence);
        } else if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] GumEndJoinUpdate with sequence %1!d! failed with status %2!d!\n",
                       sequence,
                       status);
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmJoin: FmpEnumNodes failed %1!d!\n",
                   status);
        return(status);
    }

    if (status != ERROR_SUCCESS) {
        //
        // clean up resources
        //
        FmpShutdown = TRUE;
        FmpCleanupGroups(FALSE);
        FmpShutdown = FALSE;

        if ( retries++ < 3 ) {
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmJoinPhase1: retry %1!d!\n", retries);
            goto retry;
        }
    }   
    else {
        ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase1 complete.\n");

        // Update EndSeq on success
        *EndSeq = sequence;

        //
        // Check if resource dll deadlock detection is enabled. This must be called only
        // after FmpInitialized is set to TRUE.
        //
        FmCheckIsDeadlockDetectionEnabled (); 
    }

    return(status);

} // FmJoinPhase1


DWORD
WINAPI
FmJoinPhase2(
    VOID
    )
/*++

Routine Description:

    Performs the second phase of FM initialization and join procedure.
    Finish creation of resources by allowing the resource monitors to be
    created. Claim any groups which should failback to this node.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise.

--*/

{
    DWORD   status;
    CLUSTERVERSIONINFO ClusterVersionInfo;
    PCLUSTERVERSIONINFO pClusterVersionInfo = NULL;
    DWORD   dwRetryCount=60;//try for atleast a minute


GetJoinApproval:
    status = FmpGetJoinApproval();

    if (status == ERROR_RETRY)
    {
        // if the other nodes have pending work to do 
        //after this node last died and are not willing
        // to accept it back till that is over, we will stall
        // the join
        //sleep for a second
        dwRetryCount--;
        if (dwRetryCount)
        {
            Sleep(1000);
            goto GetJoinApproval;
        }
        else
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmJoinPhase2 : timed out trying to get join approval.\n");
            CsInconsistencyHalt(status);                
        }
    }

    
    if (NmLocalNodeVersionChanged)
    {
        //initialize the cluster versioninfo structure
        CsGetClusterVersionInfo(&ClusterVersionInfo);
        pClusterVersionInfo = &ClusterVersionInfo;
    }
    //
    // The resource type possible node list is built
    // using a voting protocol, hence we need to
    // fix it up since the vote could have been conducted
    // while this node was down.
    //
    status = FmpFixupResourceTypesPhase1(TRUE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    
    //
    // For each group, finish initialization of all groups and resources.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumGroupsInit,
                   NULL,
                   NULL );


    // if the resource type is not supported, remove it from the possible 
    // owners list of all resources of that type
    status = FmpFixupPossibleNodesForResources(TRUE);
    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    if (NmLocalNodeVersionChanged)
    {
        //
        // For each group, allow all resources to do any fixups
        // they might need to do to the cluster registry to
        // run in a mixed mode cluster.
        //
        OmEnumObjects( ObjectTypeGroup,
                       FmpEnumFixupResources,
                       &ClusterVersionInfo,
                       NULL );
    }
    //
    // The FM is now in sync with everybody else.
    //
    FmpFMOnline = TRUE;

    if ( FmpMajorEvent ) {
        return(ERROR_NOT_READY);
    }

    // RAID 513705.  Need to send force quorum control to the quorum resource at this point.
    if ( CsForceQuorum ) {
        ASSERT( gpQuoResource );  // Should I assert here, or add "gpQuoResource != NULL" to the 
                                  // if expression?
        status = FmpSendForceQuorumControlToResource( gpQuoResource );
        if ( status != ERROR_SUCCESS ) {
            // The routine does its own logging.  Just bail.
            return status;
        }
    }

    
    status = FmpFixupResourceTypesPhase2(TRUE, NmLocalNodeVersionChanged,
                pClusterVersionInfo);

    if (status != ERROR_SUCCESS) {
        CsInconsistencyHalt(status);
        return(status);
    }

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase2 complete, now online!\n");

    return(ERROR_SUCCESS);

} // FmJoinPhase2

VOID
FmJoinPhase3(
    VOID
    )
/*++

Routine Description:

    Handles any group moves and resource/group state change signaling as
    a part of join. This MUST be done only AFTER the extended node state
    is UP.
    
Arguments:

    None.

Return Value:

    None.
--*/
{
    BOOL    formCluster = FALSE;
    DWORD   deferred = FALSE;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase3 entry...\n");

    //
    // Chittur Subbaraman (chitturs) - 10/28/99
    //
    //
    // For each group, see if it should be moved to the local system.
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumJoinGroupsMove,
                   &deferred,
                   NULL );

    //
    // Signal a state change for every group and resource!
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumSignalGroups,
                   &formCluster,
                   NULL );

    ClRtlLogPrint(LOG_NOISE,"[FM] FmJoinPhase3 exit...\n");
} // FmJoinPhase3

BOOL
FmpFindQuorumResource(
    IN OUT PFM_RESOURCE *QuorumResource,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Group enumeration callback for FM findquorumresource.

Arguments:

    QuorumResource - Returns the found quorum resource, if found.

    Context2 - Not used.

    Resource - Supplies the current resource.

    Name - Supplies the Resource's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{

    if ( Resource->QuorumResource ) {
        OmReferenceObject( Resource );
        *QuorumResource = Resource;
        return(FALSE);
    }

    return(TRUE);

} // FmpFindQuorumResource



BOOL
FmArbitrateQuorumResource(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

    TRUE - if the quorum resource was successfully arbitrated and acquired.

    FALSE - it the quorum resource was not successfully arbitrated.

--*/

{
    PFM_RESOURCE resource = NULL;
    DWORD       status;
    WCHAR       localComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD       localComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // Next try to find the Quorum resource.
    //

    FmFindQuorumResource(&resource);

    if ( resource == NULL ) {
        SetLastError(ERROR_RESOURCE_NOT_FOUND);
        return(FALSE);
    }

    //
    // Now arbitrate for the resource.
    //
    status = FmpRmArbitrateResource( resource );

    if ( status == ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Successfully arbitrated quorum resource %1!ws!.\n",
                   OmObjectId(resource));
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FMArbitrateQuoRes: Current State %1!u! State=%2!u! Owner %3!u!\n",
                           resource->PersistentState,
                           resource->State,
                           NmGetNodeId((resource->Group)->OwnerNode));
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FMArbitrateQuoRes: Group state :Current State %1!u! State=%2!u! Owner %3!u!\n",
                           resource->Group->PersistentState,
                           resource->Group->State,
                           NmGetNodeId((resource->Group)->OwnerNode));
        //
        // The quorum resource will be brought online by REGROUP.
        //
        // RNG: what happens if we can't online the quorum resource?
        // A: The node will halt.

        //SS: dereference the object referenced by fmfindquorumresource
        OmDereferenceObject(resource);

        return(TRUE);
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Failed to arbitrate quorum resource %1!ws!, error %2!u!.\n",
                   OmObjectId(resource),
                   status);
        //SS: dereference the object referenced by fmfindquorumresource
        OmDereferenceObject(resource);
        return(FALSE);
    }

} // FmArbitrateQuorumResource



BOOL
FmpEnumHoldIO(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Send a HOLD_IO control code to all resource types of class STORAGE.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    ResType - Supplies the Resource Type.

    Name - Supplies the Resource Type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   dwStatus;
    DWORD   bytesReturned;
    DWORD   bytesRequired;

    if ( ResType->Class == CLUS_RESCLASS_STORAGE ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Hold IO for storage resource type: %1!ws!\n",
                   Name );

        // Hold IO for this resource type
        dwStatus = FmpRmResourceTypeControl(
                        Name,
                        CLUSCTL_RESOURCE_TYPE_HOLD_IO,
                        NULL,
                        0,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource DLL Hold IO returned status %1!u!\n",
                   dwStatus );
    }

    return(TRUE);

} // FmpEnumHoldIO



VOID
FmHoldIO(
    VOID
    )
/*++

Routine Description:

    This routine holds all I/O for all storage class resource types.
    It does this by calling the resource dll with a 
    CLUSCTL_RESOURCE_TYPE_HOLD_IO resource type control code.

Inputs:

    None

Outputs:

    None

--*/
{
    OmEnumObjects( ObjectTypeResType,
                  FmpEnumHoldIO,
                  NULL,
                  NULL );
    return;

} // FmHoldIO



BOOL
FmpEnumResumeIO(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PFM_RESTYPE ResType,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Send a RESUME_IO control code to all resource types of class STORAGE.

Arguments:

    Context1 - Not used.

    Context2 - Not used.

    ResType - Supplies the Resource Type.

    Name - Supplies the Resource Type's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   dwStatus;
    DWORD   bytesReturned;
    DWORD   bytesRequired;

    if ( ResType->Class == CLUS_RESCLASS_STORAGE ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resume IO for storage Resource Type %1!ws!\n",
                   Name );

        // Resume IO for this resource type
        dwStatus = FmpRmResourceTypeControl(
                        Name,
                        CLUSCTL_RESOURCE_TYPE_RESUME_IO,
                        NULL,
                        0,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource DLL Resume IO returned status %1!u!\n",
                   dwStatus );
    }

    return(TRUE);

} // FmpEnumResumeIO



VOID
FmResumeIO(
    VOID
    )
/*++

Routine Description:

    This routine resumes all I/O for all storage class resource types.
    It does this by calling the resource dll with a
    CLUSCTL_RESOURCE_TYPE_RESUME_IO resource type control code.

Inputs:

    None

Outputs:

    None

--*/
{

    OmEnumObjects( ObjectTypeResType,
                  FmpEnumResumeIO,
                  NULL,
                  NULL );
    return;

} // FmResumeIO



BOOL
FmpEnumNodes(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for FM join. Queries the state
    of owned groups and resources for each online node.

Arguments:

    pStatus - Returns any error that may occur.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    DWORD Status;
    DWORD NodeId;
    PGROUP_ENUM NodeGroups = NULL;
    PRESOURCE_ENUM NodeResources = NULL;
    DWORD i;
    PFM_GROUP Group;
    PFM_RESOURCE Resource;

    if (Node == NmLocalNode) {
        CL_ASSERT(NmGetNodeState(Node) != ClusterNodeUp);
        return(TRUE);
    }

    //
    // Enumerate all other node's group states. This includes all nodes
    // that are up, as well as nodes that are paused.
    //
    if ((NmGetNodeState(Node) == ClusterNodeUp) ||
        (NmGetNodeState(Node) == ClusterNodePaused)){
        NodeId = NmGetNodeId(Node);
        CL_ASSERT(Session[NodeId] != NULL);

        Status = FmsQueryOwnedGroups(Session[NodeId],
                                     &NodeGroups,
                                     &NodeResources);
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] FmsQueryOwnedGroups to node %1!ws! failed %2!d!\n",
                       OmObjectId(Node),
                       Status);
            *pStatus = Status;
            return(FALSE);
        }

        //
        // Enumerate the groups and set their owner and state.
        //
        for (i=0; i < NodeGroups->EntryCount; i++) {
            Group = OmReferenceObjectById(ObjectTypeGroup,
                                          NodeGroups->Entry[i].Id);
            if (Group == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpEnumNodes: group %1!ws! not found\n",
                           NodeGroups->Entry[i].Id);
            } else {
                if ( FmpInPreferredList( Group, Node, FALSE, NULL ) ) {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Setting group %1!ws! owner to node %2!ws!, state %3!d!\n",
                               OmObjectId(Group),
                               OmObjectId(Node),
                               NodeGroups->Entry[i].State);
                } else {
                    ClRtlLogPrint(LOG_NOISE,
                               "[FM] Init, Node %1!ws! is not in group %2!ws!.\n",
                               OmObjectId(Node),
                               OmObjectId(Group));
                }
                OmReferenceObject( Node );
                Group->OwnerNode = Node;
                Group->State = NodeGroups->Entry[i].State;
                Group->StateSequence = NodeGroups->Entry[i].StateSequence;
                OmDereferenceObject(Group);
            }

            MIDL_user_free(NodeGroups->Entry[i].Id);
        }
        MIDL_user_free(NodeGroups);

        //
        // Enumerate the resources and set their current state.
        //
        for (i=0; i < NodeResources->EntryCount; i++) {
            Resource = OmReferenceObjectById(ObjectTypeResource,
                                             NodeResources->Entry[i].Id);
            if (Resource == NULL) {

                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] FmpEnumNodes: resource %1!ws! not found\n",
                           NodeResources->Entry[i].Id);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Setting resource %1!ws! state to %2!d!\n",
                           OmObjectId(Resource),
                           NodeResources->Entry[i].State);
                Resource->State = NodeResources->Entry[i].State;
                Resource->StateSequence = NodeResources->Entry[i].StateSequence;
                OmDereferenceObject(Resource);
            }
            MIDL_user_free(NodeResources->Entry[i].Id);
        }
        MIDL_user_free(NodeResources);

    }

    return(TRUE);

} // FmpEnumNodes



VOID
WINAPI
FmShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Failover Manager

Arguments:

    None

Return Value:

    None.

--*/

{
    DWORD   i;

    if ( !FmpInitialized ) {
        return;
    }

    FmpInitialized = FALSE;

    ClRtlLogPrint(LOG_UNUSUAL,
               "[FM] Shutdown: Failover Manager requested to shutdown.\n");

    //
    // For now, we really can't delete these critical sections. There is a
    // race condition where the FM is shutting down and someone is walking
    // the lists. Keep this critical sections around... just in case.
    //
    //DeleteCriticalSection( &FmpResourceLock );
    //DeleteCriticalSection( &FmpGroupLock );
    //DeleteCriticalSection( &FmpMonitorLock );

    if ( FmpDefaultMonitor != NULL ) {
        FmpShutdownMonitor(FmpDefaultMonitor);
        FmpDefaultMonitor = NULL;
    }

    CloseHandle( FmpShutdownEvent );

#if 0 // RNG - don't run the risk of other threads using these handles
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        if ( FmpRpcBindings[i] != NULL ) {
            ClMsgDeleteRpcBinding( FmpRpcBindings[i] );
            FmpRpcBindings[i] = NULL;
        }
        if ( FmpRpcQuorumBindings[i] != NULL ) {
            ClMsgDeleteRpcBinding( FmpRpcQuorumBindings[i] );
            FmpRpcQuorumBindings[i] = NULL;
        }
    }
#endif
    
    ClRtlDeleteQueue( &FmpWorkQueue );

    return;

} // FmShutdown


VOID
WINAPI
FmShutdownGroups(
    VOID
    )

/*++

Routine Description:

    Moves or takes offline all groups owned by this node.

Arguments:

    None

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_UNUSUAL,
               "[FM] Shutdown: Failover Manager requested to shutdown groups.\n");

    //if we didnt initialize, we dont have to do anything
    if (!FmpInitialized)
        return;
    //
    // Use the Group Lock to synchronize the shutdown
    //
    FmpAcquireGroupLock();

    //if shutdown is already in progress, return
    if ( FmpShutdown) {
        FmpReleaseGroupLock();
        return;
    }


    FmpShutdown = TRUE;
    FmpFMOnline = FALSE;

    FmpReleaseGroupLock();

    //
    // Now cleanup all Groups/Resources.
    // 
    FmpCleanupGroups(TRUE);


    return;

} // FmShutdownGroups



/****
@func           DWORD | FmBringQuorumOnline| This routine finds the quorum resource and
                        brings it online.

@comm           This is called by the FmFormClusterPhase 1.
@xref
****/
DWORD FmBringQuorumOnline()
{
    PFM_RESOURCE pQuoResource;
    DWORD        dwError=ERROR_SUCCESS;

    //
    // Synchronize with shutdown.
    //
    FmpAcquireGroupLock();
    if ( FmpShutdown ) {
        FmpReleaseGroupLock();
        return(ERROR_SUCCESS);
    }

    if ((dwError = FmFindQuorumResource(&pQuoResource)) != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[Fm] FmpBringQuorumOnline : failed to find resource 0x%1!08lx!\n",
                        dwError);
        goto FnExit;
    }

    //mark yourself as owner
    if ( pQuoResource->Group->OwnerNode != NULL ) 
    {
        OmDereferenceObject( pQuoResource->Group->OwnerNode );
    }

    OmReferenceObject( NmLocalNode );
    pQuoResource->Group->OwnerNode = NmLocalNode;

    //prepare the group for onlining it
    FmpPrepareGroupForOnline(pQuoResource->Group);
    dwError = FmpOnlineResource(pQuoResource, TRUE);
    //SS:decrement the ref count on the quorum resource object
    //provided by fmfindquorumresource
    OmDereferenceObject(pQuoResource);

FnExit:
    FmpReleaseGroupLock();
    return(dwError);

}

/****
@func       DWORD | FmpGetQuorumDiskSignature | Get the signature of
            the quorum disk from the cluster hive.

@parm       IN LPWSTR | lpQuorumId | Identifier of the quorum resource.

@parm       OUT LPDWORD | lpdwSignature | Quorum disk signature.
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to open the Resources\lpQuorumId\Parameters
            key under the cluster hive and read the quorum disk signature.

@xref       <f FmGetQuorumResource> 
****/
DWORD 
FmpGetQuorumDiskSignature(
    IN  LPCWSTR lpQuorumId,
    OUT LPDWORD lpdwSignature
    )
{
    HDMKEY  hQuorumResKey = NULL;
    HDMKEY  hQuorumResParametersKey = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    hQuorumResKey = DmOpenKey( DmResourcesKey,
                               lpQuorumId,
                               KEY_READ );
    if ( hQuorumResKey != NULL ) 
    {
        //
        //  Open up the Parameters key
        //
        hQuorumResParametersKey = DmOpenKey( hQuorumResKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             KEY_READ );
        DmCloseKey( hQuorumResKey );
        if ( hQuorumResParametersKey != NULL ) 
        {
            //
            //  Read the disk signature value
            //
            dwStatus = DmQueryDword( hQuorumResParametersKey,
                                   CLUSREG_NAME_PHYSDISK_SIGNATURE,
                                   lpdwSignature,
                                   NULL );
            DmCloseKey( hQuorumResParametersKey );
        } else
        {
            dwStatus = GetLastError();
        }
    } else
    {
        dwStatus = GetLastError();
    }

    //
    //  If you failed, then reset the signature to 0 so that the
    //  caller won't take any actions based on an invalid signature.
    //
    if ( dwStatus != ERROR_SUCCESS )
    {
        *lpdwSignature = 0;
    }
    
    return( dwStatus );
}


DWORD FmpGetJoinApproval()
{
    DWORD       dwStatus;
    LPCWSTR     pszNodeId;
    DWORD       dwNodeLen;
    

    pszNodeId = OmObjectId(NmLocalNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    dwStatus = GumSendUpdateEx(
                GumUpdateFailoverManager,
                FmUpdateApproveJoin, 
                1,
                dwNodeLen,
                pszNodeId);
                
    return(dwStatus);                

}

/****
@func       DWORD | FmpBuildForceQuorumInfo | Build the force quorum info that
            will be passed to the resource DLL via a control code.  This
            involves enumerating nodes and checking that the nodes that make up
            the list passed on the command line are all valid cluster nodes.

@parm       IN LPCWSTR | pszNodesIn | Comma separated list of node names.  If 
            this is NULL then the routine just fills the quorum info structure
            with 0 and a NULL node list.

@parm       OUT PCLUS_FORCE_QUORUM_INFO | pForceQuorumInfo | Structure that gets
            filled in with info
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       Assumes NmInitialize was called prior to calling this routine.

@xref       <f FmpBuildForceQuorumInfo> 
****/
static 
DWORD 
FmpBuildForceQuorumInfo(
    IN LPCWSTR pszNodesIn,
    OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    )
{
    WCHAR *pszOut = NULL;
    WCHAR *pszComma = NULL;
    DWORD status = ERROR_SUCCESS;
    PNM_NODE_ENUM2 pNodeEnum = NULL;
    int iCurrLen = 0, iOffset = 0;
    DWORD dwNodeIndex;
    DWORD dwSize;
    PCLUS_FORCE_QUORUM_INFO pForceQuorumInfo = NULL;

    // Need to allocate a structure that can hold the nodes list.
    //
    dwSize = sizeof( CLUS_FORCE_QUORUM_INFO ) + sizeof( WCHAR ) * (wcslen( pszNodesIn ) + 1);
    pForceQuorumInfo = LocalAlloc( LMEM_FIXED, dwSize );
    if ( pForceQuorumInfo == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto ErrorExit;
    }
    ZeroMemory( pForceQuorumInfo, dwSize );

    pForceQuorumInfo->dwSize = dwSize;
    pForceQuorumInfo->dwNodeBitMask = 0;
    pForceQuorumInfo->dwMaxNumberofNodes = 0;

    if ( pszNodesIn == NULL ) {
        pForceQuorumInfo->multiszNodeList[0] = L'\0';
        goto ret;
    }

    ClRtlLogPrint( LOG_NOISE, "[Fm] FmpBuildForceQuorumInfo: pszNodesIn is %1!ws!\n",
                   pszNodesIn );

    // Now get the enumeration of all cluster nodes so we can check we have
    // valid nodes in the list.
    //
    status = NmpEnumNodeDefinitions( &pNodeEnum );
    if ( status != ERROR_SUCCESS )
        goto ErrorExit;

    // Go through all the nodes we have and ensure that they are cluster nodes.
    // Get the corresponding ID and incorporate in the bitmask
    //
    do {
        pszComma = wcschr( pszNodesIn, (int) L',');
        if ( pszComma == NULL ) 
            iCurrLen = wcslen( pszNodesIn );
        else
            iCurrLen = (int) (pszComma - pszNodesIn);
        
        // At this point pszNodesIn is the start of a node name, iCurrLen chars long
        // or iCurrLen is 0 in which case we have ,, in the input stream.
        //
        if (iCurrLen > 0) {
            
            // Work out if this node is part of the cluster and if so get its
            // ID and setup the bitmask.
            //
            for ( dwNodeIndex = 0; dwNodeIndex < pNodeEnum->NodeCount; dwNodeIndex++ ) {
                int iNodeNameLen = wcslen( pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                ClRtlLogPrint( LOG_NOISE, "[Fm] FmpBuildForceQuorumInfo: trying %1!ws!\n",
                               pNodeEnum->NodeList[ dwNodeIndex ].NodeName );

                if ( ClRtlStrNICmp( pNodeEnum->NodeList[ dwNodeIndex ].NodeName, 
                                pszNodesIn, 
                                max(iCurrLen, iNodeNameLen) ) == 0 ) {
                    // Using wcstoul here to get the nodeId rather than using 
                    PWSTR ignore;
                    DWORD nodeId = wcstoul( pNodeEnum->NodeList[ dwNodeIndex ].NodeId, &ignore, 10 );

                    ClRtlLogPrint( LOG_NOISE, "[Fm] FmpBuildForceQuorumInfo: got match %1!ws!\n",
                                   pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                    
                    // Set the mask and max nodes and break - ignore duplicates.
                    //
                    if ( !( pForceQuorumInfo->dwNodeBitMask & ( 1 << nodeId )) ) {
                        pForceQuorumInfo->dwMaxNumberofNodes += 1;
                        pForceQuorumInfo->dwNodeBitMask |= ( 1 << nodeId );
                        wcscpy( &pForceQuorumInfo->multiszNodeList[iOffset], pNodeEnum->NodeList[ dwNodeIndex ].NodeName );
                        iOffset += wcslen( pNodeEnum->NodeList[ dwNodeIndex ].NodeName ) + 1;
                    }
                    break;
                }
            }
            if ( dwNodeIndex == pNodeEnum->NodeCount ) {
                ClRtlLogPrint( LOG_UNUSUAL, "[Fm] FmpBuildForceQuorumInfo: no match for %1!ws!\n", pszNodesIn );
                status = ERROR_INVALID_PARAMETER;
                goto ErrorExit;
            }
        } else if ( pszComma != NULL ) {
            ClRtlLogPrint( LOG_UNUSUAL,
                           "[Fm] FmpBuildForceQuorumInfo: iCurrLen was 0 so ,, was in node list: %1!ws!\n", 
                           CsForceQuorumNodes );
            status = ERROR_INVALID_PARAMETER;
            goto ErrorExit;
        }
        pszNodesIn = pszComma + 1;
    } while ( pszComma != NULL);
    pForceQuorumInfo->multiszNodeList[ iOffset ] = L'\0';
    goto ret;

ErrorExit:
    if ( pForceQuorumInfo != NULL ) {
        LocalFree( pForceQuorumInfo );
        pForceQuorumInfo = NULL;
    }
ret:
    if ( pNodeEnum != NULL ) {
        ClNetFreeNodeEnum( pNodeEnum );
    }
    
    if ( status == ERROR_SUCCESS ) {
        *ppForceQuorumInfo = pForceQuorumInfo;

        ClRtlLogPrint( LOG_NOISE,
                       "[Fm] FmpBuildForceQuorumInfo: success; mask is 0x%1!08x!\n", 
                       pForceQuorumInfo->dwNodeBitMask );
    }
    return status;
}

static 
void
FmpDeleteForceQuorumInfo(
    IN OUT PCLUS_FORCE_QUORUM_INFO* ppForceQuorumInfo
    )
{
    (void) LocalFree( *ppForceQuorumInfo );
    *ppForceQuorumInfo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmreg.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    fmreg.c

Abstract:

    Object Manager registry query routines for the Failover Manager
    component of the NT Cluster Service.

Author:

    Rod Gamache (rodga) 14-Mar-1996

Revision History:

--*/
#include "fmp.h"
#include <stdlib.h>
#include <search.h>

#define LOG_MODULE FMREG

//
// Global data initialized in this module
//
ULONG   FmpUnknownCount = 0;

//
// Local functions
//

VOID
FmpGroupChangeCallback(
    IN DWORD_PTR    Context1,
    IN DWORD_PTR    Context2,
    IN DWORD        CompletionFilter,
    IN LPCWSTR      RelativeName
    );

VOID
FmpResourceChangeCallback(
    IN DWORD_PTR    Context1,
    IN DWORD_PTR    Context2,
    IN DWORD        CompletionFilter,
    IN LPCWSTR      RelativeName
    );




/////////////////////////////////////////////////////////////////////////////
//
// Configuration Database Access Routines
//
/////////////////////////////////////////////////////////////////////////////

DWORD
FmpRegEnumerateKey(
    IN     HDMKEY     ListKey,
    IN     DWORD      Index,
    OUT    LPWSTR    *Name,
    IN OUT LPDWORD    NameMaxSize
    )

/*++

Routine Description:

Arguments:

Returns:

--*/

{
    DWORD           status;
    FILETIME        fileTime;


    status = DmEnumKey( ListKey,
                        Index,
                        *Name,
                        NameMaxSize,
                        NULL );

    if ( status == ERROR_SUCCESS ) {
        return(ERROR_SUCCESS);
    }

    if ( status == ERROR_MORE_DATA ) {
        PWCHAR   nameString = NULL;
        DWORD    maxSubkeyNameSize = 0;
        DWORD    temp = 0;

        //
        // The name string isn't big enough. Reallocate it.
        //

        //
        // Find out the length of the longest subkey name.
        //
        status = DmQueryInfoKey( ListKey,
                                 &temp,
                                 &maxSubkeyNameSize,
                                 &temp,
                                 &temp,
                                 &temp,
                                 NULL,
                                 &fileTime );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_MORE_DATA) ) {
            ClRtlLogPrint(LOG_NOISE,"[FM] DmQueryInfoKey returned status %1!u!\n",
                status);
            return(status);
        }

        CL_ASSERT(maxSubkeyNameSize != 0);

        //
        // The returned subkey name size does not include the terminating null.
        // It is also an ANSI string count.
        //
        maxSubkeyNameSize *= sizeof(WCHAR);
        maxSubkeyNameSize += sizeof(UNICODE_NULL);

        nameString = LocalAlloc( LMEM_FIXED,
                                 maxSubkeyNameSize );

        if ( nameString == NULL ) {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] Unable to allocate key name buffer of size %1!u!\n",
                maxSubkeyNameSize
                );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        LocalFree(*Name);
        *Name = nameString;
        *NameMaxSize = maxSubkeyNameSize;

        status = DmEnumKey( ListKey,
                            Index,
                            *Name,
                            NameMaxSize,
                            NULL );

        CL_ASSERT(status != ERROR_MORE_DATA);
        CL_ASSERT(status != ERROR_NO_MORE_ITEMS);
    }

    return(status);

} // FmpRegEnumerateKey


VOID
FmpPruneGroupOwners(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Prunes the entire preferred group list based on the possible
    nodes of each resource in the group.

Arguments:

    Group - Supplies the group object to be pruned

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PFM_RESOURCE Resource;

    ListEntry = Group->Contains.Flink;
    while (ListEntry != &Group->Contains) {
        Resource = CONTAINING_RECORD(ListEntry,
                                     FM_RESOURCE,
                                     ContainsLinkage);
        FmpPrunePreferredList(Resource);
        ListEntry = ListEntry->Flink;
    }

    return;
}


VOID
FmpPrunePreferredList(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Prune out nodes from the preferred owners list, if the resource cannot
    run on that node.

Arguments:

    Resource - Pointer to the resource object with a possible owners list.

Return Value:

    None.

--*/

{
    PFM_GROUP        group;
    PLIST_ENTRY      listEntry;
    PLIST_ENTRY      entry;
    PPREFERRED_ENTRY preferredEntry;
    PPOSSIBLE_ENTRY   possibleEntry;
    DWORD            orderedEntry = 0;

    group = Resource->Group;

    //
    // For each entry in the Preferred list, it must exist in the possible
    // list.
    //

    for ( listEntry = group->PreferredOwners.Flink;
          listEntry != &(group->PreferredOwners);
          ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        //
        // Scan the Possible owners list in the resource to make sure that
        // the group can run on all of the preferred owners.
        //
        for ( entry = Resource->PossibleOwners.Flink;
              entry != &(Resource->PossibleOwners);
              entry = entry->Flink ) {
            possibleEntry = CONTAINING_RECORD( entry,
                                               POSSIBLE_ENTRY,
                                               PossibleLinkage );
            if ( preferredEntry->PreferredNode == possibleEntry->PossibleNode ) {
                break;
            }
        }

        listEntry = listEntry->Flink;

        //
        // If we got to the end of the possible owners list and didn't find
        // an entry, then remove the current preferred entry.
        //
        if ( entry == &(Resource->PossibleOwners) ) {
            ClRtlLogPrint( LOG_NOISE,
                        "[FM] Removing preferred node %1!ws! because of resource %2!ws!\n",
                        OmObjectId(preferredEntry->PreferredNode),
                        OmObjectId(Resource));

            //
            // If this was an ordered entry, then decrement count.
            //
            if ( orderedEntry < group->OrderedOwners ) {
                --group->OrderedOwners;
            }
            RemoveEntryList( &preferredEntry->PreferredLinkage );
            OmDereferenceObject(preferredEntry->PreferredNode);
            LocalFree(preferredEntry);
            if ( IsListEmpty( &group->PreferredOwners ) ) {
                ClRtlLogPrint( LOG_ERROR,
                            "[FM] Preferred owners list is now empty! No place to run group %1!ws!\n",
                            OmObjectId(group));
            }
        } else {
            orderedEntry++;
        }
    }

} // FmpPrunePreferredList



BOOL
FmpAddNodeToPrefList(
    IN PNM_NODE     Node,
    IN PFM_GROUP    Group
    )
/*++

Routine Description:

    Node enumeration callback for including all remaining nodes
    in a group's preferred owners list.

Arguments:

    Group - a pointer to the group object to add this node as a preferred owner.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    //if it is already in the list FmpSetPrefferedEntry returns ERROR_SUCCESS
    if ( FmpSetPreferredEntry( Group, Node ) != ERROR_SUCCESS ) {
        return(FALSE);
    }

    return(TRUE);

} // FmpAddNodeToPrefList

BOOL
FmpAddNodeToListCb(
    IN OUT PNM_NODE_ENUM2 *ppNmNodeEnum,
    IN LPDWORD  pdwAllocatedEntries,
    IN PNM_NODE pNode,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of nodes.
    This routine adds the specified node to the list that is being
    generated.

Arguments:

    ppNmNodeEnum - The node Enumeration list. Can be an output if a new list is
            allocated.

    EnumData - Supplies the current enumeration data structure.

    Group - The Group object being enumerated.

    Id - The Id of the node object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

Side Effects:

    Makes the quorum group first in the list.

--*/

{
    PNM_NODE_ENUM2  pNmNodeEnum;
    PNM_NODE_ENUM2  pNewNmNodeEnum;
    DWORD           dwNewAllocated;
    DWORD           dwStatus;



    pNmNodeEnum = *ppNmNodeEnum;

    if ( pNmNodeEnum->NodeCount >= *pdwAllocatedEntries ) 
    {
        //
        // Time to grow the GROUP_ENUM
        //

        dwNewAllocated = *pdwAllocatedEntries + ENUM_GROW_SIZE;
        pNewNmNodeEnum = LocalAlloc(LMEM_FIXED, NODE_SIZE(dwNewAllocated));
        if ( pNewNmNodeEnum == NULL ) 
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_UNEXPECTED_ERROR(dwStatus);
            return(FALSE);
        }

        CopyMemory(pNewNmNodeEnum, pNmNodeEnum, NODE_SIZE(*pdwAllocatedEntries));
        *pdwAllocatedEntries = dwNewAllocated;
        *ppNmNodeEnum = pNewNmNodeEnum;
        LocalFree(pNmNodeEnum);
        pNmNodeEnum = pNewNmNodeEnum;
    }

    //
    // Dont copy more than the size
    //
    lstrcpyn( pNmNodeEnum->NodeList[pNmNodeEnum->NodeCount].NodeId, 
              Id, 
              RTL_NUMBER_OF ( pNmNodeEnum->NodeList[pNmNodeEnum->NodeCount].NodeId ) );

    ++pNmNodeEnum->NodeCount;

    return(TRUE);

} // FmpAddNodeToListCb

int
__cdecl
SortNodesInAscending(
    const PVOID Elem1,
    const PVOID Elem2
    )
{
    PNM_NODE_INFO2 El1 = (PNM_NODE_INFO2)Elem1;
    PNM_NODE_INFO2 El2 = (PNM_NODE_INFO2)Elem2;

    return(lstrcmpiW( El1->NodeId, El2->NodeId ));

}// SortNodesInAsceding


DWORD
FmpEnumNodesById(
    IN DWORD    dwOptions, 
    OUT PNM_NODE_ENUM2 *ppNodeEnum
    )

/*++

Routine Description:

    Enumerates and sorts the list of Groups.

Arguments:

    *ppNodeEnum - Returns the requested objects.

    dwOptions - 
    
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD               dwStatus;
    PNM_NODE_ENUM2      pNmNodeEnum = NULL;
    DWORD               dwAllocatedEntries;

    //
    // initialize output params to NULL
    //
    *ppNodeEnum = NULL;

    dwAllocatedEntries = ENUM_GROW_SIZE;

    pNmNodeEnum = LocalAlloc( LMEM_FIXED, NODE_SIZE(ENUM_GROW_SIZE) );
    if ( pNmNodeEnum == NULL ) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    pNmNodeEnum->NodeCount = 0;

    //
    // Enumerate all nodes
    //

    OmEnumObjects( ObjectTypeNode,
                FmpAddNodeToListCb,
                &pNmNodeEnum,
                &dwAllocatedEntries );

    CL_ASSERT( pNmNodeEnum->NodeCount != 0 );
    //
    // Sort the groups by their collating sequence number.
    //
    
    qsort( (PVOID)(&pNmNodeEnum->NodeList[0]),
           (size_t)pNmNodeEnum->NodeCount,
           sizeof(NM_NODE_INFO2),          
           (int (__cdecl *)(const void*, const void*)) SortNodesInAscending
           );

    *ppNodeEnum = pNmNodeEnum;
    return( ERROR_SUCCESS );

error_exit:
    if ( pNmNodeEnum != NULL ) {
        LocalFree( pNmNodeEnum );
    }

    return( dwStatus );

} // FmpEnumNodesById


BOOL
FmpEnumAddAllOwners(
    IN PFM_RESOURCE Resource,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for adding all nodes to a resource's
    list of possible nodes.

Arguments:

    Resource - a pointer to the resource object to add this node as a possible owner.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    if ( !Resource->PossibleList ) {
        FmpAddPossibleEntry(Resource, Node);
    }
    return(TRUE);

} // FmpEnumAddAllOwners


DWORD
FmpQueryGroupNodes(
    IN PFM_GROUP Group,
    IN HDMKEY hGroupKey
    )
/*++

Routine Description:

    Rebuilds and orders the list of preferred nodes associated with
    a group.

Arguments:

    Group - Supplies the group whose list of preferred nodes should
            be rebuilt.

    hGroupKey - Supplies a handle to the group's registry key

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    LPWSTR          preferredOwnersString = NULL;
    DWORD           preferredOwnersStringSize = 0;
    DWORD           preferredOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    PPREFERRED_ENTRY preferredEntry;
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PNM_NODE_ENUM2  pNmNodeEnum = NULL;
    PNM_NODE        pNmNode;
    DWORD           i;
    //
    // First, delete the old list.
    //
    while ( !IsListEmpty(&Group->PreferredOwners) ) {
        listEntry = Group->PreferredOwners.Flink;
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        RemoveEntryList( &preferredEntry->PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }
    Group->OrderedOwners = 0;

    CL_ASSERT ( IsListEmpty(&Group->PreferredOwners) );

    status = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &preferredOwnersString,
                             &preferredOwnersStringMaxSize,
                             &preferredOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Preferred Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    preferredNode;

            nameString = ClRtlMultiSzEnum( preferredOwnersString,
                                           preferredOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }

            //
            // Create the Preferred Owners List entry
            //

            preferredEntry = LocalAlloc( LMEM_FIXED, sizeof(PREFERRED_ENTRY) );

            if ( preferredEntry == NULL ) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                return(status);
            }

            //
            // Create the preferred owners. This will implicitly create
            // additional reference required for the preferred owner nodes.
            //

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Group %1!ws! preferred owner %2!ws!.\n",
                       OmObjectId(Group),
                       nameString);

            preferredNode = OmReferenceObjectById( ObjectTypeNode,
                                                   nameString );

            if ( preferredNode == NULL ) {
                LocalFree(preferredEntry);
                status = GetLastError();
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Failed to find node %1!ws! for Group %2!ws!\n",
                           nameString,
                           OmObjectId(Group));
            } else {
                Group->OrderedOwners++;
                preferredEntry->PreferredNode = preferredNode;
                InsertTailList( &Group->PreferredOwners,
                                &preferredEntry->PreferredLinkage );
            }

        }
        LocalFree( preferredOwnersString );
    }

    //
    // We now include all remaining nodes in the preferred owners list.
    //
    // Every node must maintain the same ordering for the preferred list
    // for the multi-node cluster to work
    //
    status = FmpEnumNodesById( 0, &pNmNodeEnum );

    if ( status != ERROR_SUCCESS )
    {
        CL_UNEXPECTED_ERROR( status );
        ClRtlLogPrint(LOG_UNUSUAL, 
        	   "[FM] FmpQueryGroupNodes: FmpEnumNodesById failed, status = %1!u!\r\n",
        	    status);
        // return error                    
    }

    for ( i=0; i<pNmNodeEnum->NodeCount; i++ )
    {
        pNmNode = OmReferenceObjectById( ObjectTypeNode, 
                        pNmNodeEnum->NodeList[i].NodeId );
        CL_ASSERT( pNmNode != NULL );
        FmpAddNodeToPrefList( pNmNode, Group );
        OmDereferenceObject( pNmNode );     
    }

    //
    // Now prune out all the unreachable nodes.
    //
    FmpPruneGroupOwners( Group );

    //
    //  Chittur Subbaraman (chitturs) - 12/11/98
    //
    //  Free the memory allocated for pNmNodeEnum.
    //  (Fix memory leak)
    //
    LocalFree( pNmNodeEnum );

    return( ERROR_SUCCESS );

} // FmpQueryGroupNodes



DWORD
WINAPI
FmpQueryGroupInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    )

/*++

Routine Description:

    Queries Group info from the registry when creating a Group Object.

Arguments:

    Object - A pointer to the Group object being created.

    Initialize - TRUE if the resource objects should be initialized. FALSE
                 otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_GROUP       Group = (PFM_GROUP)Object;
    PFM_RESOURCE    Resource;
    DWORD           status;
    LPWSTR          containsString = NULL;
    DWORD           containsStringSize = 0;
    DWORD           containsStringMaxSize = 0;
    DWORD           temp;
    DWORD           mszStringIndex;
    DWORD           failoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
    DWORD           failoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
    DWORD           autoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
    DWORD           zero = 0;
    PLIST_ENTRY     listEntry;
    HDMKEY          groupKey;
    DWORD           groupNameStringMaxSize = 0;
    DWORD           groupNameStringSize = 0;
    LPWSTR          groupName;
    PPREFERRED_ENTRY preferredEntry;
    DWORD           dwBufferSize = 0;
    DWORD           dwStringSize;


    //
    // Initialize the Group object from the registry info.
    //
    if ( Group->Initialized ) {
        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Initializing group %1!ws! from the registry.\n",
                OmObjectId(Group));

    //
    // Open the group key.
    //
    groupKey = DmOpenKey( DmGroupsKey,
                          OmObjectId(Group),
                          MAXIMUM_ALLOWED );

    if ( groupKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Unable to open group key %1!ws!, %2!u!\n",
                    OmObjectId(Group),
                    status);

        return(status);
    }

    //
    // Read the required group values. The strings will be allocated
    // by the DmQuery* functions.
    //

    //
    // Get the Name.
    //
    status = DmQuerySz( groupKey,
                        CLUSREG_NAME_GRP_NAME,
                        &groupName,
                        &groupNameStringMaxSize,
                        &groupNameStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read name for Group %1!ws!\n",
                    OmObjectId(Group));
        goto error_exit;
    }

    status = OmSetObjectName( Group, groupName );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Unable to set name %1!ws! for group %2!ws!, error %3!u!.\n",
                    groupName,
                    OmObjectId(Group),
                    status );
        LocalFree(groupName);
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Name for Group %1!ws! is '%2!ws!'.\n",
                OmObjectId(Group),
                groupName);

    LocalFree(groupName);
    //
    // Get the PersistentState.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_PERSISTENT_STATE,
                           &temp,
                           &zero );

    //
    // If the group state is non-zero then we go online.
    //
    if ( temp ) {
        Group->PersistentState = ClusterGroupOnline;
    } else {
        Group->PersistentState = ClusterGroupOffline;
    }

    //
    // Get the OPTIONAL PreferredOwners list.
    // *** NOTE *** This MUST be done before processing the contains list!
    //
    status = FmpQueryGroupNodes(Group, groupKey);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,"[FM] Error %1!d! creating preferred owners list\n",status);
        goto error_exit;
    }


    //
    // Get the Contains string.
    //
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_CONTAINS,
                             &containsString,
                             &containsStringMaxSize,
                             &containsStringSize );

    if ( status != NO_ERROR ) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Unable to read Contains for group %1!ws!\n",
                       OmObjectId(Group));
        }
    } else {
        //
        // Now Create the Contains list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR      nameString;
            PFM_RESOURCE containedResource;

            nameString = ClRtlMultiSzEnum( containsString,
                                           containsStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Group %1!ws! contains Resource %2!ws!.\n",
                       OmObjectId(Group),
                       nameString);

            //
            // Try to create the object.
            //
            FmpAcquireResourceLock();
            FmpAcquireLocalGroupLock( Group );

            containedResource = FmpCreateResource( Group,
                                                   nameString,
                                                   NULL,
                                                   Initialize );
            FmpReleaseLocalGroupLock( Group );
            FmpReleaseResourceLock();

            //
            // Check if we got a resource.
            //
            if ( containedResource == NULL ) {
                //
                // This group claims to contain a non-existent resource.
                // Log an error, but keep going. This should not tank the
                // whole group. Also, let the arbitration code know about
                // the failure of a resource.
                //
                Group->InitFailed = TRUE;
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Failed to find resource %1!ws! for Group %2!ws!\n",
                           nameString,
                           OmObjectId(Group));
            }
        }
        LocalFree(containsString);

    }

    //
    // Get the AutoFailbackType.
    //

    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_TYPE,
                           &temp,
                           &autoFailbackType );

    //
    // Verify that AutoFailbackType is okay.
    //

    if ( temp >= FailbackMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal value for AutoFailbackType on %1!ws!, setting to default\n",
                   OmObjectId(Group));
        temp = autoFailbackType;
    }

    Group->FailbackType = (UCHAR)temp;

    //
    // Get the FailbackWindowStart.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_START,
                           &temp,
                           &zero );

    //
    // Verify that FailbackWindowStart is okay.
    //
    if ( temp > 24 ) {
        if ( temp != CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START ) {
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] Illegal value for FailbackWindowStart on %1!ws!,setting to default\n",
                      OmObjectId(Group));
            temp = zero;
        }
    }
    Group->FailbackWindowStart = (UCHAR)temp;

    //
    // Get the FailbackWindowEnd.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_END,
                           &temp,
                           &zero );

    //
    // Verify that FailbackWindowEnd is okay.
    //

    if ( temp > 24 ) {
        if ( temp != CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Illegal value for FailbackWindowEnd on %1!ws!, setting to default\n",
                       OmObjectId(Group));
            temp = zero;
        }
    }
    Group->FailbackWindowEnd = (UCHAR)temp;

    //
    // Get the FailoverPeriod.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_PERIOD,
                           &temp,
                           &failoverPeriod );

    //
    // Verify that FailoverPeriod is okay. Take any value up to UCHAR max.
    // In theory we could take any value... but in practice we have to convert
    // this time to milliseconds (currently). That means that 1193 hours can
    // fit in a DWORD - so that is the maximum we can take. (We are limited
    // because we use GetTickCount, which returns a DWORD in milliseconds.)
    //

    if ( temp > CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD ) {      // Keep it positive?
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal value for FailolverPeriod on %1!ws!. Max is 1193\n",
                   OmObjectId(Group));
        temp = failoverPeriod;                   
    } 

    Group->FailoverPeriod = (UCHAR)temp;
    

    //
    // Get the FailoverThreshold.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,
                           &(Group->FailoverThreshold),
                           &failoverThreshold );

    //
    // Verify that FailoverThreshold is okay. Take any value.
    //

    //
    // Get the AntiAffinityClassName property if present.
    //
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME,
                             &Group->lpszAntiAffinityClassName,
                             &dwBufferSize,
                             &dwStringSize );

    //
    //  Handle the case in which the string is empty.
    //
    if ( ( status == ERROR_SUCCESS ) &&
         ( Group->lpszAntiAffinityClassName != NULL ) &&
         ( Group->lpszAntiAffinityClassName[0] == L'\0' ) )
    {
        LocalFree( Group->lpszAntiAffinityClassName );
        Group->lpszAntiAffinityClassName = NULL;
    }
         
    //
    // We're done. We should only get here if Group->Initialized is FALSE.
    //
    CL_ASSERT( Group->Initialized == FALSE );
    Group->Initialized = TRUE;
    Group->RegistryKey = groupKey;

    //
    // Now register for any changes to the resource key.
    //

    status = DmNotifyChangeKey(
                    groupKey,
                    (DWORD) CLUSTER_CHANGE_ALL,
                    FALSE,              // Only watch the top of the tree
                    &Group->DmRundownList,
                    FmpGroupChangeCallback,
                    (DWORD_PTR)Group,
                    0 );

    if ( status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Error registering for DM change notify on group %1!ws!, error %2!u!.\n",
                    OmObjectId(Group),
                    status);
        goto error_exit;
    }

    return(ERROR_SUCCESS);


error_exit:

    Group->Initialized = FALSE;
    Group->RegistryKey = NULL;

    DmCloseKey(groupKey);

    //
    // Cleanup any contained resources
    //
    while ( !IsListEmpty(&Group->Contains) ) {
        listEntry = RemoveHeadList(&Group->Contains);
        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        OmDereferenceObject(Resource);
    }

    //
    // Cleanup any preferred nodes
    //
    while ( !IsListEmpty(&Group->PreferredOwners) ) {
        listEntry = RemoveHeadList(&Group->PreferredOwners);
        preferredEntry = CONTAINING_RECORD(listEntry, PREFERRED_ENTRY, PreferredLinkage);
        OmDereferenceObject(preferredEntry->PreferredNode);
        LocalFree(preferredEntry);
    }

    return(status);

} // FmpQueryGroupInfo



DWORD
WINAPI
FmpFixupGroupInfo(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Re-queries Group info from the registry to fixup items that may have
    changed since the quorum resource (and the Group that it is in) was
    first created.

    This routine exists because we may have created the quorum resource
    (and its Group) early in the 'life' of the cluster, before all the node
    objects (for example) were created. We then would have failed generating
    the list of possible owners for the resource. This in turn would have
    caused some entries from the preferred list to get pruned. We need to
    redo this operation again here.

Arguments:

    Group - A pointer to the Group object to fix up.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

Notes:

    It is assumed that the quorum resource fixup already has happened.

--*/

{
    DWORD   status;

    status = FmpQueryGroupNodes(Group, Group->RegistryKey);

    return(status);

} // FmpFixupGroupInfo



DWORD
WINAPI
FmpQueryResourceInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    )

/*++

Routine Description:

    Queries Resource info from the registry when creating a Resource Object.

Arguments:

    Object - A pointer to the Resource object being created.

    Initialize - TRUE if the resource should be fully initialized.
                 FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESOURCE    Resource = (PFM_RESOURCE)Object;
    DWORD           status;
    DWORD           dllNameStringSize = 0;
    DWORD           dllNameStringMaxSize = 0;
    LPWSTR          resourceTypeString = NULL;
    DWORD           resourceTypeStringMaxSize = 0;
    DWORD           resourceTypeStringSize = 0;
    DWORD           dependenciesStringMaxSize = 0;
    DWORD           restartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    DWORD           restartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    DWORD           pendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
    DWORD           RetryPeriodOnFailure = CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE;
    DWORD           defaultRestartAction = RestartGroup;
    DWORD           DefaultExFlags = 0;
    DWORD           zero = 0;
    DWORD           temp;
    DWORD           separateMonitor;
    HDMKEY          resourceKey;
    DWORD           resourceNameStringMaxSize = 0;
    DWORD           resourceNameStringSize = 0;
    LPWSTR          resourceName = NULL;
    LPWSTR          possibleOwnersString = NULL;
    DWORD           possibleOwnersStringSize = 0;
    DWORD           possibleOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    PPOSSIBLE_ENTRY possibleEntry;
    PLIST_ENTRY     listEntry;
    WCHAR           unknownName[] = L"_Unknown9999";
    DWORD           nameSize = 0;
    DWORD           stringSize;

    //if the key is non null, this resource has already been initialized
    if (Resource->RegistryKey != NULL)
        return(ERROR_SUCCESS);

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Initializing resource %1!ws! from the registry.\n",
                OmObjectId(Resource));

    //
    // Begin initializing the resource from the registry.
    //
    //
    // Open the resource key.
    //
    resourceKey = DmOpenKey( DmResourcesKey,
                             OmObjectId(Resource),
                             MAXIMUM_ALLOWED );

    if ( resourceKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to open resource key %1!ws!, %2!u!\n",
                   OmObjectId(Resource),
                   status);
        return(ERROR_INVALID_NAME);
    }

    //
    // Read the required resource values. The strings will be allocated
    // by the DmQuery* functions.
    //

    //
    // Get the Name.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_NAME,
                        &resourceName,
                        &resourceNameStringMaxSize,
                        &resourceNameStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read name for resource %1!ws!\n",
                   OmObjectId(Resource));
        if ( OmObjectName( Resource ) == NULL ) {
            wsprintf( unknownName,
                      L"_Unknown%u",
                      InterlockedIncrement( &FmpUnknownCount ));
            status = OmSetObjectName( Resource, unknownName );
        } else {
            status = ERROR_SUCCESS;
        }
    } else {
        status = OmSetObjectName( Resource, resourceName );
    }
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_ERROR,
                   "[FM] Unable to set name %1!ws! for resource %2!ws!, error %3!u!.\n",
                   resourceName,
                   OmObjectId(Resource),
                   status );
        LocalFree(resourceName);
        status = ERROR_INVALID_NAME;
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] Name for Resource %1!ws! is '%2!ws!'.\n",
                OmObjectId(Resource),
                resourceName);

    LocalFree(resourceName);

    //
    // Get the dependencies list.
    //

    status = DmQueryMultiSz( resourceKey,
                             CLUSREG_NAME_RES_DEPENDS_ON,
                             &(Resource->Dependencies),
                             &dependenciesStringMaxSize,
                             &(Resource->DependenciesSize) );

    if (status != NO_ERROR) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read Dependencies for resource %1!ws!\n",
                   OmObjectId(Resource));
        }
    }

    //
    // Get the OPTIONAL PossibleOwners list.
    //
    // We do this here, because we must have a possible owners list for the
    // CluAdmin to start the resource.
    //

    status = DmQueryMultiSz( resourceKey,
                             CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                             &possibleOwnersString,
                             &possibleOwnersStringMaxSize,
                             &possibleOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Possible Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    possibleNode;

            nameString = ClRtlMultiSzEnum( possibleOwnersString,
                                           possibleOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }
            possibleNode = OmReferenceObjectById( ObjectTypeNode,
                                                  nameString );

            if ( possibleNode == NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Warning, failed to find node %1!ws! for Resource %2!ws!\n",
                           nameString,
                           OmObjectId(Resource));
            } else {
                Resource->PossibleList = TRUE;
                status = FmpAddPossibleEntry(Resource, possibleNode);
                OmDereferenceObject(possibleNode);
                if (status != ERROR_SUCCESS) {
                    goto error_exit;
                }
            }
        }
        LocalFree(possibleOwnersString);

        //
        // Now prune out unusable nodes from the preferred owners list.
        //
        FmpPrunePreferredList( Resource );

    } else {
        //
        // No possible owners value was specified. Add all the nodes
        // to the possible owners list. Note there is no point in pruning
        // the preferred list after this since this resource can run
        // anywhere.
        //
        OmEnumObjects( ObjectTypeNode,
                       FmpEnumAddAllOwners,
                       Resource,
                       NULL );
    }

    //
    // Get the resource type.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_TYPE,
                        &resourceTypeString,
                        &resourceTypeStringMaxSize,
                        &resourceTypeStringSize );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read ResourceType for resource %1!ws!\n",
                   OmObjectId(Resource));
        goto error_exit;
    }

    //
    // Open (and reference) the resource type.
    //
    if (Resource->Type == NULL)
    {
        Resource->Type = OmReferenceObjectById( ObjectTypeResType,
                                            resourceTypeString );
    }                                            
    if (Resource->Type == NULL) {

        PFM_RESTYPE pResType;
        //
        // If we can't find a resource type, then try to create it.
        //
        pResType = FmpCreateResType(resourceTypeString );

        if (pResType == NULL) {
            status = ERROR_INVALID_PARAMETER;
            LocalFree(resourceTypeString);
            goto error_exit;
        }

        //bump the ref count before saving a pointer to it in the
        //resource structure.
        OmReferenceObject(pResType);
        Resource->Type = pResType;
    }

    LocalFree(resourceTypeString);

    if ( !Initialize ) {
        //
        // We're not supposed to fully initialize the resource. This is
        // when we're early in the init process. We need to keep the registry
        // key closed when leaving.
        //
        DmCloseKey(resourceKey);
        return(ERROR_SUCCESS);
    }


    //
    // Get the IsAlive poll interval
    //
    CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_IS_ALIVE,
                           &Resource->IsAlivePollInterval,
                           &Resource->Type->IsAlivePollInterval );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read IsAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

        goto error_exit;
    }

    if ( Resource->IsAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
        Resource->IsAlivePollInterval = Resource->Type->IsAlivePollInterval;
    }

    //
    // Get the LooksAlive poll interval
    //
    CL_ASSERT( Resource->Type->LooksAlivePollInterval != 0 );
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_LOOKS_ALIVE,
                           &Resource->LooksAlivePollInterval,
                           &Resource->Type->LooksAlivePollInterval );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read LooksAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        goto error_exit;
    }

    if ( Resource->LooksAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
        Resource->LooksAlivePollInterval = Resource->Type->LooksAlivePollInterval;
    }

    //
    // Get the current persistent state of the resource.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PERSISTENT_STATE,
                           &temp,
                           NULL );

    //
    // Save the current resource state.
    //

    if ( ( status == ERROR_FILE_NOT_FOUND )  || 
         ( ( status == ERROR_SUCCESS ) && ( temp == CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE ) ) ) {
        switch ( Resource->Group->PersistentState ) {
        case ClusterGroupOnline:
            Resource->PersistentState = ClusterResourceOnline;
            break;
        case ClusterGroupOffline:
            Resource->PersistentState = ClusterResourceOffline;
            break;
        default:
            break;
        }
    } else if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read PersistentState for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        goto error_exit;
    } else if ( temp ) {
        Resource->PersistentState = ClusterResourceOnline;
    } else {
        Resource->PersistentState = ClusterResourceOffline;
    }

    //
    // Determine the monitor to run this in.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_SEPARATE_MONITOR,
                           &separateMonitor,
                           &zero );
    if ( separateMonitor ) {
        Resource->Flags |= RESOURCE_SEPARATE_MONITOR;
    }

    //
    // Get the RestartThreshold.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_THRESHOLD,
                           &Resource->RestartThreshold,
                           &restartThreshold );

    // Verify the RestartThreshold. Take any value.

    //
    // Get the RestartPeriod.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_PERIOD,
                           &Resource->RestartPeriod,
                           &restartPeriod );

    // Verify the RestartPeriod. Take any value.

    //
    // Get the RestartAction.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_ACTION,
                           &Resource->RestartAction,
                           &defaultRestartAction );

    // Verify the RestartAction.

    if ( Resource->RestartAction >= RestartMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal RestartAction for resource %1!ws!\n",
                   OmObjectId(Resource));
        goto error_exit;
    }

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,
                           &Resource->RetryPeriodOnFailure,
                           &RetryPeriodOnFailure );

    // make sure that RetryPeriodOnFailure >= RestartPeriod
    if (Resource->RetryPeriodOnFailure < Resource->RestartPeriod)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Specified RetryPeriodOnFailure value is less than RestartPeriod value - setting RetryPeriodOnFailure equal to RestartPeriod \n");
        Resource->RetryPeriodOnFailure = Resource->RestartPeriod;              
        
    }    

                           
    //
    // Get the extrinsic Flags
    //
    DefaultExFlags = 0;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_FLAGS,
                           &Resource->ExFlags,
                           &DefaultExFlags );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read Extrinsic Flags for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

        goto error_exit;
    }

    //
    // Get the PendingTimeout value.
    //

    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PENDING_TIMEOUT,
                           &Resource->PendingTimeout,
                           &pendingTimeout );

    // Verify the PendingTimeout. Take any value.

    //
    // Now register for any changes to the resource key.
    //

    if (IsListEmpty(&Resource->DmRundownList))
    {
        status = DmNotifyChangeKey(
                    resourceKey,
                    (DWORD) CLUSTER_CHANGE_ALL,
                    FALSE,              // Only watch the top of the tree
                    &Resource->DmRundownList,
                    FmpResourceChangeCallback,
                    (DWORD_PTR)Resource,
                    0 );

        if ( status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] Error registering for DM change notify on resource %1!ws!, error %2!u!.\n",
                    OmObjectId(Resource),
                    status);
            goto error_exit;
        }
    }
    //
    // Get the DebugPrefix string... this is on the resource type.
    //
    status = DmQuerySz( resourceKey,
                        CLUSREG_NAME_RES_DEBUG_PREFIX,
                        &Resource->DebugPrefix,
                        &nameSize,
                        &stringSize );

    //
    // Finally save the resource key for registry updates of the
    // PersistentState.
    //
    Resource->RegistryKey = resourceKey;

    return(ERROR_SUCCESS);


error_exit:

    DmCloseKey(resourceKey);

    if ( Resource->Type != NULL ) {
        OmDereferenceObject(Resource->Type);
    }

    //
    // Cleanup any dependencies
    //
    if ( Resource->Dependencies != NULL ) {
        LocalFree(Resource->Dependencies);
        Resource->Dependencies = NULL;
    }

    //
    // Cleanup any possible nodes
    //
    while ( !IsListEmpty(&Resource->PossibleOwners) ) {
        listEntry = RemoveHeadList(&Resource->PossibleOwners);
        possibleEntry = CONTAINING_RECORD(listEntry, POSSIBLE_ENTRY, PossibleLinkage);
        OmDereferenceObject(possibleEntry->PossibleNode);
        LocalFree(possibleEntry);
    }

    return(status);

} // FmpQueryResourceInfo



DWORD
WINAPI
FmpFixupResourceInfo(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Re-queries Resource info from the registry to fixup items that may have
    changed since the quorum resource was first created.

    This routine exists because we may have created the quorum resource early
    in the 'life' of the cluster, before all the node objects (for example)
    were created. We then would have failed generating the list of possible
    owners for the resource. In FmpQueryResourceInfo, we treat failures to
    find node objects as non-fatal errors, which we will now cleanup.

Arguments:

    Resource - A pointer to the Resource object to fix up.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    LPWSTR          possibleOwnersString = NULL;
    DWORD           possibleOwnersStringSize = 0;
    DWORD           possibleOwnersStringMaxSize = 0;
    DWORD           mszStringIndex;
    DWORD           status;


    if ( Resource->RegistryKey == NULL ) {
        return(ERROR_NOT_READY);
    }

    //
    // Get the OPTIONAL PossibleOwners list.
    //

    status = DmQueryMultiSz( Resource->RegistryKey,
                             CLUSREG_NAME_RES_POSSIBLE_OWNERS,
                             &possibleOwnersString,
                             &possibleOwnersStringMaxSize,
                             &possibleOwnersStringSize );

    if ( status == NO_ERROR ) {

        //
        // Now Create the Possible Owners list.
        //

        for ( mszStringIndex = 0; ; mszStringIndex++ ) {
            LPCWSTR     nameString;
            PNM_NODE    possibleNode;

            nameString = ClRtlMultiSzEnum( possibleOwnersString,
                                           possibleOwnersStringSize/sizeof(WCHAR),
                                           mszStringIndex );

            if ( nameString == NULL ) {
                break;
            }
            possibleNode = OmReferenceObjectById( ObjectTypeNode,
                                                  nameString );

            if ( possibleNode == NULL ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] Warning, failed to find node %1!ws! for Resource %2!ws!\n",
                           nameString,
                           OmObjectId(Resource));
            } else {
                Resource->PossibleList = TRUE;
                status = FmpAddPossibleEntry(Resource, possibleNode);
                OmDereferenceObject(possibleNode);
                if (status != ERROR_SUCCESS) {
                    return(status);
                }
            }
        }
        LocalFree(possibleOwnersString);

        //
        // Now prune out unusable nodes from the preferred owners list.
        //
        FmpPrunePreferredList( Resource );

    } else {
        //
        // No possible owners value was specified. Add all the nodes
        // to the possible owners list. Note there is no point in pruning
        // the preferred list after this since this resource can run
        // anywhere.
        //
        OmEnumObjects( ObjectTypeNode,
                       FmpEnumAddAllOwners,
                       Resource,
                       NULL );

    }

    return(ERROR_SUCCESS);

} // FmpFixupQuorumResourceInfo



DWORD
WINAPI
FmpQueryResTypeInfo(
    IN PVOID Object
    )

/*++

Routine Description:

    Queries Resource Type info from the registry when creating a ResType Object.

Arguments:

    Object - A pointer to the Resource Type object being created.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_RESTYPE     resType = (PFM_RESTYPE)Object;
    DWORD           status;
    DWORD           dwSize = 0;
    DWORD           stringSize;
    HDMKEY          resTypeKey;
    DWORD           temp;
    LPWSTR          pmszPossibleNodes = NULL;
    
    //
    // Open the resource type key.
    //
    resTypeKey = DmOpenKey( DmResourceTypesKey,
                            OmObjectId(resType),
                            MAXIMUM_ALLOWED );

    if ( resTypeKey == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to open resource type key %1!ws!, %2!u!\n",
                   OmObjectId(resType),
                   status);

        return(status);
    }

    //
    // Read the required resource type DLL name. The strings will be allocated
    // by the DmQuery* functions.
    //

    status = DmQuerySz( resTypeKey,
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &resType->DllName,
                        &dwSize,
                        &stringSize );
    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type does not exist. "
                          "Resources of this type will not be monitored.\n",
                          OmObjectId(resType));
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type could not be read "
                          "from the registry. Resources of this type will not be monitored. "
                          "The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
        }

        goto error_exit;
    }


    //
    // Get the optional LooksAlive poll interval
    //
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                           &resType->LooksAlivePollInterval,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            resType->LooksAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The LooksAlive poll interval for the %1!ws! resource type could "
                          "not be read from the registry. Resources of this type will not be "
                          "monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    //
    // Get the optional IsAlive poll interval
    //
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_IS_ALIVE,
                           &resType->IsAlivePollInterval,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            resType->IsAlivePollInterval = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The IsAlive poll interval for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    //
    // Get the optional DebugPrefix string... this is on the resource type.
    //
    dwSize = 0;
    status = DmQuerySz( resTypeKey,
                        CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
                        &resType->DebugPrefix,
                        &dwSize,
                        &stringSize );

    //
    // Get the optional DebugControlFunctions registry value
    //
    resType->Flags &= ~RESTYPE_DEBUG_CONTROL_FUNC;
    temp = 0;
    status = DmQueryDword( resTypeKey,
                           CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
                           &temp,
                           NULL );

    if ( status != NO_ERROR ) {
        if ( status != ERROR_FILE_NOT_FOUND ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The Debug control functions for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    if ( temp ) {
        resType->Flags |= RESTYPE_DEBUG_CONTROL_FUNC;
    }


    //ss: bug make sure you free the old memory
    InitializeListHead(&(resType->PossibleNodeList));
    
    //
    // Get the Possible Nodes
    //
    dwSize = 0;
    status = DmQueryMultiSz( resTypeKey,
                           CLUSREG_NAME_RESTYPE_POSSIBLE_NODES,
                           &pmszPossibleNodes,
                           &dwSize,
                           &stringSize);


    if ( status != NO_ERROR ) 
    {
        //if the possible node list is not found this is ok
        if ( status != ERROR_FILE_NOT_FOUND ) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The Possible nodes list for the %1!ws! resource type "
                          "could not be read from the registry. Resources of this type "
                          "will not be monitored. The error was %2!d!.\n",
                          OmObjectId(resType),
                          status);
            goto error_exit;
        }
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpQueryResTypeInfo: Calling FmpAddPossibleNodeToList for restype %1!ws!\r\n",
        OmObjectId(resType));

    status = FmpAddPossibleNodeToList(pmszPossibleNodes, stringSize, 
        &resType->PossibleNodeList);
    if ( status != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmpCreateResType: FmpAddPossibleNodeToList() failed, status=%1!u!\r\n",
            status);
        goto error_exit;
    }


error_exit:
    if (pmszPossibleNodes) LocalFree(pmszPossibleNodes);
    DmCloseKey(resTypeKey);

    return(status);

} // FmpQueryResTypeInfo



VOID
FmpGroupChangeCallback(
    IN DWORD_PTR  Context1,
    IN DWORD_PTR  Context2,
    IN DWORD      CompletionFilter,
    IN LPCWSTR    RelativeName
    )

/*++

Routine Description:

    This routine basically flushes our cached data for the given group.

Arguments:

    Context1 - A pointer to the Group object that was modified.

    Context2 - Not used.

    CompletionFilter - Not used.

    RelativeName - The registry path relative to the entry that was modified.
                   Not used.

Return Value:

    None.

--*/

{
    PFM_GROUP   Group = (PFM_GROUP)Context1;
    HDMKEY      groupKey;
    DWORD       status;
    DWORD       temp;
    BOOL        notify = FALSE;
    DWORD       dwBufferSize = 0;
    DWORD       dwStringSize;

    groupKey = Group->RegistryKey;
    if ( groupKey == NULL ) {
        return;
    }

    //
    // Re-fetch all of the data for the group.
    //
    // Name changes are managed elsewhere.
    // The Contains list is managed elsewhere.
    //

    //
    // Get the OPTIONAL PreferredOwners list.
    // *** NOTE *** This MUST be done before processing the contains list!
    //
    status = FmpQueryGroupNodes(Group, groupKey);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,"[FM] Error %1!d! refreshing preferred owners list\n",status);
    }

    //
    // Get the AutoFailbackType.
    //
    temp = Group->FailbackType;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_TYPE,
                           &temp,
                           &temp );

    //
    // Verify that AutoFailbackType is okay.
    //

    if ( temp >= FailbackMaximum ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for AutoFailbackType on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackType ) {
            notify = TRUE;
        }
        Group->FailbackType = (UCHAR)temp;
    }

    //
    // Get the FailbackWindowStart.
    //
    temp = Group->FailbackWindowStart;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_START,
                           &temp,
                           &temp );

    //
    // Verify that FailbackWindowStart is okay.
    //

    if ( temp > 24 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailbackWindowStart on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackWindowStart ) {
            notify = TRUE;
        }
        Group->FailbackWindowStart = (UCHAR)temp;
    }

    //
    // Get the FailbackWindowEnd.
    //
    temp = Group->FailbackWindowEnd;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILBACK_WIN_END,
                           &temp,
                           &temp );

    //
    // Verify that FailbackWindowEnd is okay.
    //

    if ( temp > 24 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailbackWindowEnd on %1!ws!\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailbackWindowEnd ) {
            notify = TRUE;
        }
        Group->FailbackWindowEnd = (UCHAR)temp;
    }

    //
    // Get the FailoverPeriod.
    //
    temp = Group->FailoverPeriod;
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_PERIOD,
                           &temp,
                           &temp );

    //
    // Verify that FailoverPeriod is okay. Take any value up to UCHAR max.
    // In theory we could take any value... but in practice we have to convert
    // this time to milliseconds (currently). That means that 1193 hours can
    // fit in a DWORD - so that is the maximum we can take. (We are limited
    // because we use GetTickCount, which returns a DWORD in milliseconds.)
    //

    if ( temp > (1193) ) {    // we dont bother Keeping it positive?
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Illegal refresh value for FailolverPeriod on %1!ws!. Max is 596\n",
                   OmObjectId(Group));
    } else {
        if ( (UCHAR)temp != Group->FailoverPeriod ) {
            notify = TRUE;
        }
        Group->FailoverPeriod = (UCHAR)temp;
    }

    //
    // Get the FailoverThreshold.
    //
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,
                           &(Group->FailoverThreshold),
                           &(Group->FailoverThreshold) );

    //
    // Verify that FailoverThreshold is okay. Take any value.
    //

    //
    // Get the current persistent state of the group.
    //
    if ( Group->PersistentState == ClusterGroupOnline ) {
        temp = 1;
    } else {
        temp = 0;
    }
    status = DmQueryDword( groupKey,
                           CLUSREG_NAME_GRP_PERSISTENT_STATE,
                           &temp,
                           &temp );
    //
    // If the group state is non-zero then we go online.
    //
    // Don't bother with change notifications... they should happen elsewhere.
    //
    if ( temp ) {
        if ( ClusterGroupOnline != Group->PersistentState ) {
            //notify = TRUE;
        }
        Group->PersistentState = ClusterGroupOnline;
    } else {
        if ( ClusterGroupOffline != Group->PersistentState ) {
            //notify = TRUE;
        }
        Group->PersistentState = ClusterGroupOffline;
    }

    //
    // Get the AntiAffinityClassName property if present.
    //
    LocalFree( Group->lpszAntiAffinityClassName );
    Group->lpszAntiAffinityClassName = NULL;
    status = DmQueryMultiSz( groupKey,
                             CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME,
                             &Group->lpszAntiAffinityClassName,
                             &dwBufferSize,
                             &dwStringSize );

    //
    //  Handle the case in which the string is empty.
    //
    if ( ( status == ERROR_SUCCESS ) &&
         ( Group->lpszAntiAffinityClassName != NULL ) &&
         ( Group->lpszAntiAffinityClassName[0] == L'\0' ) )
    {
        LocalFree( Group->lpszAntiAffinityClassName );
        Group->lpszAntiAffinityClassName = NULL;
    }

    // We're done!
    if ( !FmpShutdown &&
         notify ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group );
    }

    return;

} // FmpGroupChangeCallback



VOID
FmpResourceChangeCallback(
    IN DWORD_PTR  Context1,
    IN DWORD_PTR  Context2,
    IN DWORD      CompletionFilter,
    IN LPCWSTR    RelativeName
    )

/*++

Routine Description:

    This routine basically flushes our cached data for the given resource.

Arguments:

    Context1 - A pointer to the resource object that was modified.

    Context2 - Not used.

    CompletionFilter - Not used.

    RelativeName - The registry path relative to the entry that was modified.
                   Not used.

Return Value:

    None.

--*/

{
    PFM_RESOURCE Resource = (PFM_RESOURCE)Context1;
    HDMKEY      resourceKey;
    DWORD       status;
    DWORD       separateMonitor;
    DWORD       zero = 0;
    DWORD       temp;
    BOOL        notify = FALSE;
    DWORD       dwDefault;

    resourceKey = Resource->RegistryKey;
    if ( resourceKey == NULL ) {
        return;
    }

    //
    // Re-fetch all of the data for the resource.
    //
    // Name changes are managed elsewhere.
    // The dependency list is managed elsewhere.
    //
    // We can't change the resource type here!
    // We can't stop the resource to start it in a separate monitor either.
    //

    //
    // Get the IsAlive poll interval
    //
    temp = Resource->IsAlivePollInterval;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_IS_ALIVE,
                           &Resource->IsAlivePollInterval,
                           &dwDefault );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to refresh IsAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);

    } else {
        CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
        if ( temp != Resource->IsAlivePollInterval ) {
            notify = TRUE;
        }
        if ( Resource->IsAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
            Resource->IsAlivePollInterval = Resource->Type->IsAlivePollInterval;
        }
    }

    //
    // Get the LooksAlive poll interval
    //
    temp = Resource->LooksAlivePollInterval;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_LOOKS_ALIVE,
                           &Resource->LooksAlivePollInterval,
                           &dwDefault );

    if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to refresh LooksAlivePollInterval for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
    } else {
        CL_ASSERT( Resource->Type->IsAlivePollInterval != 0 );
        if ( temp != Resource->LooksAlivePollInterval ) {
            notify = TRUE;
        }
        if ( Resource->LooksAlivePollInterval == CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL ) {
            Resource->LooksAlivePollInterval = Resource->Type->LooksAlivePollInterval;
        }
    }

    //
    // Get the RestartThreshold.
    //
    temp = Resource->RestartThreshold;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_THRESHOLD,
                           &Resource->RestartThreshold,
                           &dwDefault);

    // Verify the RestartThreshold. Take any value.
    if ( (status == NO_ERROR) &&
         (temp != Resource->RestartThreshold) ) {
        notify = TRUE;
    }

    //
    // Get the RestartPeriod.
    //
    temp = Resource->RestartPeriod;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_PERIOD,
                           &Resource->RestartPeriod,
                           &dwDefault );

    if ( (status ==  NO_ERROR) &&
         (temp != Resource->RestartPeriod) ) {
        notify = TRUE;
    }

    // Verify the RestartPeriod. Take any value.

    //
    // Get the RestartAction.
    //
    temp = Resource->RestartAction;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RESTART_ACTION,
                           &Resource->RestartAction,
                           &dwDefault);

    // Verify the RestartAction.

    if ( status == NO_ERROR ) {
        if ( temp != Resource->RestartAction ) {
            notify = TRUE;
        }
        if ( Resource->RestartAction >= RestartMaximum ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] Illegal RestartAction refresh for resource %1!ws!\n",
                       OmObjectId(Resource));
        }
    }

    temp = Resource->RetryPeriodOnFailure;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,
                           &Resource->RetryPeriodOnFailure,
                           &dwDefault );

    // make sure that RetryPeriodOnFailure >= RestartPeriod
    if (Resource->RetryPeriodOnFailure < Resource->RestartPeriod)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Specified RetryPeriodOnFailure value is less than RestartPeriod value - setting RetryPeriodOnFailure equal to RestartPeriod \n");
        Resource->RetryPeriodOnFailure = Resource->RestartPeriod;              
        
    }   
    if( temp != Resource->RetryPeriodOnFailure)
        notify = TRUE;
    
    //
    // Get the PendingTimeout value.
    //
    temp = Resource->PendingTimeout;
    dwDefault = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PENDING_TIMEOUT,
                           &Resource->PendingTimeout,
                           &dwDefault);

    // Verify the PendingTimeout. Take any value.

    if ( (status == NO_ERROR) &&
         (temp != Resource->PendingTimeout) ) {
        notify = TRUE;
    }


    //
    // Get the current persistent state of the resource.
    //
    // Don't bother with change notifications... they should happen elsewhere.
    //
    status = DmQueryDword( resourceKey,
                           CLUSREG_NAME_RES_PERSISTENT_STATE,
                           &temp,
                           NULL );

    //
    // Save the current resource state.
    //

    if ( ( status == ERROR_FILE_NOT_FOUND )  || 
       ( ( status == ERROR_SUCCESS ) && ( temp == CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE ) ) ) {
        switch ( Resource->Group->PersistentState ) {
        case ClusterGroupOnline:
            Resource->PersistentState = ClusterResourceOnline;
            break;
        case ClusterGroupOffline:
            Resource->PersistentState = ClusterResourceOffline;
            break;
        default:
            break;
        }
    } else if ( status != NO_ERROR ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Unable to read PersistentState for resource %1!ws!. Error %2!u!\n",
                   OmObjectId(Resource),
                   status);
        return;
    } else if ( temp ) {
        Resource->PersistentState = ClusterResourceOnline;
    } else {
        Resource->PersistentState = ClusterResourceOffline;
    }

    if ( !FmpShutdown &&
         notify ) {
        //
        // Comments from sunitas: Tell the resource monitor about the 
        // changes but do this from the worker thread. Originally, this
        // used to be a post notification to the FmpRmWorkerThread
        // which posts resmon notifications to clussvc.
        //
        OmReferenceObject(Resource);
        FmpPostWorkItem(FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS,
                        Resource,
                        0);
    }

    return;

} // FmpResourceChangeCallback



DWORD
FmpChangeResourceMonitor(
    IN PFM_RESOURCE Resource,
    IN DWORD        SeparateMonitor
    )

/*++

Routine Description:

    This routine switches the resource from one resource monitor to another.

Arguments:

    Resource - pointer to the resource that was modified.

    SeparateMonitor - flag to indicate whether to run in a separate monitor;

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

Notes:

    The resource should be offline.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       separateMonitor;
    DWORD       zero = 0;

    if ( Resource->RegistryKey == NULL ) {
        return(ERROR_INVALID_STATE);
    }

    if ( (Resource->State != ClusterResourceOffline) &&
         (Resource->State != ClusterResourceFailed) ) {
        return(ERROR_INVALID_STATE);
    }

    //
    // Determine the monitor to run this in. This is only updated from
    // the node that owns the resource.
    //
    if ( (!SeparateMonitor &&
         (Resource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
         (SeparateMonitor &&
         ((Resource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) {

        //
        // The separate monitor flag has changed... tell ResMon to close
        // the resource and then create it again.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Changing Separate Resource Monitor state\n");

        status = FmpRmCloseResource( Resource );
        if ( status == ERROR_SUCCESS ) {
            if ( Resource->Flags & RESOURCE_SEPARATE_MONITOR ) {
                Resource->Flags &= ~RESOURCE_SEPARATE_MONITOR;
            } else {
                Resource->Flags |= RESOURCE_SEPARATE_MONITOR;
            }
            status = FmpRmCreateResource( Resource );
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] Separate resource monitor changed for '%1!ws!', but failed to re-open the resource, error %2!u!.\n",
                           OmObjectId(Resource),
                           status );
            }
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] Separate resource monitor changed for '%1!ws!', but failed to close the resource, error %2!u!.\n",
                       OmObjectId(Resource),
                       status );
            return(status);
        }
    }

    return(status);

} // FmpChangeResourceMonitor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmp.h ===
#ifndef _FMP_H
#define _FMP_H

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmp.h

Abstract:

    Private data structures and procedure prototypes for
    the Failover Manager subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

#define UNICODE 1
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#define QFS_DO_NOT_UNMAP_WIN32
#include "service.h"

#include "clusudef.h"
#include "rm_rpc.h"
#include "stdlib.h"

#define LOG_CURRENT_MODULE LOG_MODULE_FM

#define FMGUM        1
#define RMNOTIFY     2
#define RESOURCE     3
#define FMAPI        4
#define GROUP        5
#define RECV         6
#define EVENT        7
#define FMCLIENT     8
#define TREE         9
#define FMINIT      10
#define IOCTL       11
#define FMREG       12
#define RESMONF     13  //for resmon.c
#define WORKER      14
#define RESFAIL     15
#define GROUPARB    16
#define MONITOR     17

//
// RPC timeout constant (borrowed from nmp.h)
// Node Intracluster RPC record/cancellation routines.
// Useful to terminate outstanding RPCs to failed nodes.
//

#define FM_RPC_TIMEOUT 45000  // 45 secs

//
//  Monitor shutdown timeout
//
#define FM_MONITOR_SHUTDOWN_TIMEOUT  15 * 60 * 1000    //  15 min

typedef CLUSTER_EVENT FM_EVENT;

//fm event handling
//events generated by the service
#define FM_EVENT_NODE_DOWN                  1
#define FM_EVENT_SHUTDOWN                   2
#define FM_EVENT_RESOURCE_ADDED             3
#define FM_EVENT_RESOURCE_DELETED           4
#define FM_EVENT_GROUP_FAILED               5
#define FM_EVENT_NODE_ADDED                 6
#define FM_EVENT_CLUSTER_PROPERTY_CHANGE    7
#define FM_EVENT_RESOURCE_PROPERTY_CHANGE   8
//#define FM_EVENT_GROUP_PROPERTY_CHANGE      9
#define FM_EVENT_RESOURCE_CHANGE            10
#define FM_EVENT_NODE_EVICTED               11

//events generated due to resource dll's
#define FM_EVENT_RES_RESOURCE_TRANSITION    128
#define FM_EVENT_RES_RESOURCE_FAILED        129

//generated when DealyedRestart timer fires
#define FM_EVENT_RES_RETRY_TIMER            131

#define FM_EVENT_INTERNAL_PROP_GROUP_STATE  256

#define FM_EVENT_INTERNAL_SHUTDOWN_CLEANUP  258
#define FM_EVENT_INTERNAL_RETRY_ONLINE      259
#define FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS    260
#define FM_EVENT_INTERNAL_ONLINE_GROUPLIST  261
#define FM_EVENT_RESOURCE_NAME_CHANGE       262

// timer activities ( in msec)
#define FM_TIMER_RESLIST_ONLINE_RETRY  1 * 60 * 1000 //( 1 minute)
//
// Global defines
//

#define FMP_GROUP_NAME L"Group"
#define FMP_RESOURCE_NAME L"Resource"
#define FMP_RESOURCE_TYPE_NAME L"ResType"

#define FMP_GROUP_SIGNATURE 'rGmF'
#define FMP_RESOURCE_SIGNATURE 'sRmF'
#define FMP_RESOURCE_TYPE_SIGNATURE 'tRmF'
#define FMP_RESMON_SIGNATURE 'mRmF'

#define PENDING_TIMEOUT     (4*1000)    // retry pending operations every 4 secs

//
// Globals
//
extern HANDLE FmpShutdownEvent;
extern DWORD FmpFMOnline;
extern DWORD FmpFMFormPhaseProcessing;
extern DWORD FmpFMGroupsInited;
extern BOOL FmpShutdown;
extern BOOL FmpMajorEvent;

extern CRITICAL_SECTION FmpResourceLock;
extern CRITICAL_SECTION FmpGroupLock;
extern CRITICAL_SECTION FmpMonitorLock;

//
// 185575: remove use of unique RPC binding handles.
//
//extern CRITICAL_SECTION FmpBindingLock;

extern CL_QUEUE FmpWorkQueue;

//global data relating to the quorum resource
#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION gQuoLock;
#else
    extern RTL_RESOURCE     gQuoLock;
#endif    

#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION    gQuoChangeLock;
#else
    extern RTL_RESOURCE        gQuoChangeLock;
#endif    

#if NO_SHARED_LOCKS
    extern CRITICAL_SECTION    gResTypeLock;
#else
    extern RTL_RESOURCE        gResTypeLock;
#endif    

extern  PFM_RESOURCE        gpQuoResource;
extern  HANDLE              ghQuoOnlineEvent;
extern  DWORD               gdwQuoBlockingResources;

extern  RPC_BINDING_HANDLE  FmpRpcBindings[];
extern  RPC_BINDING_HANDLE  FmpRpcQuorumBindings[];

extern  RESUTIL_PROPERTY_ITEM FmpGroupCommonProperties[];

typedef struct FM_NODE{
    DWORD       dwNodeDownProcessingInProgress;
    PNM_NODE    pNode;
    DWORD       dwNodeDownProcessingThreadId;
}FM_NODE, *PFM_NODE;    

extern  PFM_NODE            gFmpNodeArray;
extern  LIST_ENTRY          g_leFmpMonitorListHead;
extern  DWORD               FmpInitialized;

//
// Macros
//

#define FmpMustBeOnline( )                              \
        if ( !FmpFMOnline ) {                           \
            if ( FmpShutdown ) {                        \
                return(ERROR_CLUSTER_NODE_SHUTTING_DOWN); \
            } else {                                    \
                return(ERROR_CLUSTER_NODE_NOT_READY);   \
            }                                           \
        }

#define FmpMustBeOnlineEx( ReturnValue )                \
        if ( !FmpFMOnline ) {                           \
            if ( FmpShutdown ) {                        \
                SetLastError(ERROR_CLUSTER_NODE_SHUTTING_DOWN); \
            } else {                                    \
                SetLastError(ERROR_CLUSTER_NODE_NOT_READY); \
            }                                           \
            return(ReturnValue);                        \
        }

#define FmpLogGroupInfoEvent1( MsgId, Group)         \
    {                                                   \
        if (!CsNoGroupInfoEvtLogging)                   \
            CsLogEvent1(LOG_NOISE, MsgId, Group);       \
    }                                                   \
            
#define FmpLogGroupInfoEvent2( MsgId, Resource, Group)          \
    {                                                               \
        if (!CsNoGroupInfoEvtLogging)                               \
            CsLogEvent2(LOG_NOISE, MsgId, Resource, Group);         \
    }        



typedef struct WORK_ITEM {
    LIST_ENTRY      ListEntry;
    CLUSTER_EVENT   Event;
    PVOID           Context1;
    ULONG_PTR       Context2;
} WORK_ITEM, *PWORK_ITEM;

// structures for timer activity
typedef struct _FM_RESLIST_ONLINE_RETRY_INFO{
    PFM_GROUP       pGroup;
    RESOURCE_ENUM   ResourceEnum;
}FM_RESLIST_ONLINE_RETRY_INFO, *PFM_RESLIST_ONLINE_RETRY_INFO;

    
//structure for cleanup at shutdown
typedef struct FM_CLEANUP_INFO{
    PGROUP_ENUM     pGroupEnum;
    BOOL            bContainsQuorumGroup;
    DWORD           dwTimeOut;
}FM_CLEANUP_INFO, *PFM_CLEANUP_INFO;


//
// Wait block used for waiting on completion of pending
// events
//
typedef struct FM_WAIT_BLOCK {
    LIST_ENTRY ListEntry;
    HANDLE hEvent;
    DWORD Status;
} FM_WAIT_BLOCK, *PFM_WAIT_BLOCK;

//
// Group Move structure
//

typedef struct MOVE_GROUP {
    PFM_GROUP   Group;
    PNM_NODE    DestinationNode;
} MOVE_GROUP, *PMOVE_GROUP;

//
//  Information for group affinity calculation.
//
typedef struct GROUP_AFFINITY_NODE_INFO {
    PFM_GROUP   pGroup;
    PNM_NODE    *ppNmNodeList;
    BOOL        fDidPruningOccur;
} GROUP_AFFINITY_NODE_INFO, *PGROUP_AFFINITY_NODE_INFO;

//
// Define types of pending routines
//

typedef enum {
    OfflinePending
} PENDING_ROUTINE;


//
// Define types of Group failbacks
//

typedef enum {
    FailbackNot,
    FailbackOkay,
    FailbackMaximum
} FAILBACK_TYPE;

//
// Define resource restart actions
//

typedef enum {
    RestartNot,
    RestartLocal,
    RestartGroup,
    RestartMaximum
} RESTART_ACTION;


//
// Define FM to Resmon event types.
//

typedef enum {
    ResourceTransition,
    ResourceResuscitate,
    RmWorkerTerminate,
    RmUpdateResource,
    RmRestartResource
} RM_EVENT_TYPE;

//
//  Macro for easy dereferencing of a quorum target node
//
#define FM_DEREF_QUORUM_TARGET( pQuorumTargetNode )     \
{                                                       \
    if ( pQuorumTargetNode )                            \
    {                                                   \
        OmDereferenceObject( pQuorumTargetNode );       \
        pQuorumTargetNode = NULL;                       \
    }                                                   \
}

DWORD
WINAPI
FmpGumReceiveUpdates(
    IN DWORD    Context,
    IN BOOL     SourceNode,
    IN DWORD    BufferLength,
    IN PVOID    Buffer
    );

DWORD
WINAPI
FmpGumVoteHandler(
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
);

//
// Gum update message buffers.
//

// UpdateResourceState

typedef struct GUM_RESOURCE_STATE {
    CLUSTER_RESOURCE_STATE  State;
    CLUSTER_RESOURCE_STATE  PersistentState;
    DWORD                   StateSequence;
} GUM_RESOURCE_STATE, *PGUM_RESOURCE_STATE;

// UpdateGroupState

typedef struct GUM_GROUP_STATE {
    CLUSTER_GROUP_STATE State;
    CLUSTER_GROUP_STATE PersistentState;
    DWORD               StateSequence;
} GUM_GROUP_STATE, *PGUM_GROUP_STATE;

// UpdateGroupFailureCount

typedef struct GUM_FAILURE_COUNT {
    DWORD   Count;
    DWORD   NewTime;
    WCHAR   GroupId[1];
} GUM_FAILURE_COUNT, *PGUM_FAILURE_COUNT;

typedef struct GUM_CREATE_GROUP {
    PFM_GROUP Group;
    DWORD GroupIdLen;
    DWORD GroupNameLen;
    WCHAR GroupId[1];
    // WCHAR GroupName[1];
    // WCHAR NodeName[1];
} GUM_CREATE_GROUP, *PGUM_CREATE_GROUP;

typedef struct GUM_DELETE_GROUP {
    WCHAR GroupId[1];
} GUM_DELETE_GROUP, *PGUM_DELETE_GROUP;

typedef struct GUM_CREATE_RESOURCE {
    PFM_RESOURCE Resource;
    DWORD GroupIdLen;
    DWORD ResourceIdLen;
    WCHAR GroupId[1];
    // WCHAR ResourceId[1];
    // WCHAR ResourceName[1];
} GUM_CREATE_RESOURCE, *PGUM_CREATE_RESOURCE;

typedef struct GUM_INIT_RESOURCE {
    DWORD   ResourceIdLen;
    WCHAR   ResourceId[1];
} GUM_INIT_RESOURCE, *PGUM_INIT_RESOURCE;

typedef struct GUM_CHANGE_POSSIBLE_NODE {
    DWORD ResourceIdLen;
    WCHAR ResourceId[1];
    // WCHAR NodeName[1];
} GUM_CHANGE_POSSIBLE_NODE, *PGUM_CHANGE_POSSIBLE_NODE;

typedef struct GUM_CREATE_RESOURCE_TYPE {
    WCHAR TypeName[1];
} GUM_CREATE_RESOURCE_TYPE, *PGUM_CREATE_RESOURCE_TYPE;

typedef struct GUM_DELETE_RESOURCE_TYPE {
    WCHAR TypeName[1];
} GUM_DELETE_RESOURCE_TYPE, *PGUM_DELETE_RESOURCE_TYPE;

typedef struct GUM_CHANGE_GROUP {
    DWORD ResourceIdLen;
    WCHAR ResourceId[1];
    // WCHAR GroupName[1];
} GUM_CHANGE_GROUP, *PGUM_CHANGE_GROUP;

#if 0
typedef struct GUM_SET_POSSIBLE_NODE_FORRESTYPE{
    DWORD ResTypeNameLen;
    WCHAR ResTypeName[1];
} GUM_SET_POSSIBLE_OWNER_FORRESTYPE, *PGUM_SET_POSSIBLE_OWNER_FORRESTYPE;
#endif

typedef struct _FMP_POSSIBLE_NODE {
    PFM_RESOURCE    Resource;
    PNM_NODE        Node;
    DWORD           ControlCode;
} FMP_POSSIBLE_NODE, *PFMP_POSSIBLE_NODE;


//VOTE STRUCTURES
typedef struct _FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE{
    DWORD   dwSize;
    DWORD   dwNodeId;
    BOOL    bPossibleNode;
}FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE, *PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE;    

typedef struct _FM_RES_CHANGE_NAME {
    PFM_RESOURCE    pResource;
    WCHAR           szNewResourceName[1];
} FM_RES_CHANGE_NAME, *PFM_RES_CHANGE_NAME;

//
// Monitor resource enumeration
//

typedef struct MONITOR_RESOURCE_ENUM {
    DWORD       EntryCount;
    DWORD       CurrentIndex;
    BOOL        fCreateMonitors;
    PFM_RESOURCE Entry[1];
} MONITOR_RESOURCE_ENUM, *PMONITOR_RESOURCE_ENUM;

#define ENUM_GROW_SIZE 16

//
// Resource enumeration interface
//

#define RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(RESOURCE_ENUM_ENTRY) + sizeof(RESOURCE_ENUM))

#define MONITOR_RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(PFM_GROUP) + \
            sizeof(MONITOR_RESOURCE_ENUM))

//
// Group and resource enumeration entries.
//

#define GROUP_SIZE(Entries) ((Entries-1) * sizeof(GROUP_ENUM_ENTRY) + sizeof(GROUP_ENUM))

#define NODE_SIZE(Entries) ((Entries-1) * sizeof (NM_NODE_INFO2) + sizeof(NM_NODE_ENUM2))

#define RESOURCE_SIZE(Entries) ((Entries-1) * sizeof(RESOURCE_ENUM_ENTRY) + sizeof(RESOURCE_ENUM))

//
// Define structure for a Resource Monitor process
//
typedef struct RESMON {
    DWORD                   Signature;
    HANDLE                  Process;
    HANDLE                  NotifyThread;
    BOOL                    Shutdown;
    DWORD                   RefCount;
    RPC_BINDING_HANDLE      Binding;
    struct MONITOR_STATE    *SharedState;
    LIST_ENTRY              leMonitor;  // Link to the next monitor
    DWORD                   dwDeadlockTimeoutSecs;// Tells us what exactly the monitor has 
} RESMON, *PRESMON;

//
//  Monitor list enumeration info used for resource DLL upgrade.
//
typedef struct _FM_MONITOR_ENUM_HEADER 
{
    DWORD   cEntries;
    DWORD   cAllocated;
    BOOL    fDefaultMonitorAdded;
    PRESMON *ppMonitorList;
} FM_MONITOR_ENUM_HEADER, *PFM_MONITOR_ENUM_HEADER;

//
//  Structure definitions for passing around group preferred node list info on a node
//  down.
//
typedef struct _FM_GROUP_NODE_LIST_ENTRY
{
    DWORD                       dwPreferredNodeId;
    WCHAR                       szGroupId[1]; //  Always at the end to help marshalling
} FM_GROUP_NODE_LIST_ENTRY, *PFM_GROUP_NODE_LIST_ENTRY;

typedef struct _FM_GROUP_NODE_LIST
{
    DWORD                       cbGroupNodeList;
    FM_GROUP_NODE_LIST_ENTRY    leGroupNodeList[1]; // Always at the end to help marshalling
} FM_GROUP_NODE_LIST, *PFM_GROUP_NODE_LIST;

//flags for cluster propery change
#define     CLUSTER_NAME_CHANGE     0x00000001
#define     CLUSTER_QUORUM_CHANGE   0x00000002

// FM event handling structures
typedef struct CLUSTER_EVENT_PROPERTY_CONTEXT{
    DWORD   dwFlags;    
    PVOID   pContext1;
    PVOID   pContext2;
} CLUSTER_EVENT_PROPERTY_CONTEXT, *PCLUSTER_EVENT_PROPERTY_CONTEXT;

typedef struct RESOURCE_STATE_CHANGE{
    PFM_RESOURCE            pResource;
    CLUSTER_RESOURCE_STATE  OldState;
    CLUSTER_RESOURCE_STATE  NewState;
} RESOURCE_STATE_CHANGE, *PRESOURCE_STATE_CHANGE;

typedef struct {
    LIST_ENTRY Linkage;
    RM_EVENT_TYPE  EventType;
    union {
        struct {
            RM_NOTIFY_KEY           NotifyKey;
            CLUSTER_RESOURCE_STATE  NewState;
        } ResourceTransition;
        struct {
            RM_NOTIFY_KEY   NotifyKey;
        } ResourceResuscitate;
    } Parameters;
} RM_EVENT, *PRM_EVENT;

//Cluster Name management
DWORD
FmpRegUpdateClusterName(
    IN LPCWSTR szNewClusterName
    );

//
// Quorum resource Arbitration.
//

DWORD
FmpRmArbitrateResource(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpRmReleaseResource(
    IN PFM_RESOURCE Resource
    );

//
// Interfaces for managing the registry.
//

DWORD
FmpRegEnumerateKey(
    IN     HDMKEY   ListKey,
    IN     DWORD    Index,
    IN     LPWSTR  *Name,
    IN OUT LPDWORD  NameMaxSize
    );

//
// Gum interfaces
//

DWORD
FmpEnableGum(
    );

//
// Interfaces for managing Resource Monitor processes
//

PRESMON
FmpCreateMonitor(
    LPWSTR DebugPrefix,
    BOOL   SeparateMonitor
    );

VOID
FmpShutdownMonitor(
    IN PRESMON Monitor
    );

BOOL
FmpRestartMonitor(
    IN PRESMON OldMonitor,
    IN BOOL fCreateResourcesOnly,
    OUT OPTIONAL PMONITOR_RESOURCE_ENUM *ppMonitorResourceEnum
    );

DWORD 
FmpCreateMonitorRestartThread(
    IN PRESMON pMonitor
);

//
// Interfaces for managing resources via the Resource Monitors
//

DWORD
FmpRmCreateResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmCloseResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmOnlineResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmOfflineResource(
    PFM_RESOURCE    Resource
    );

VOID
FmpRmTerminateResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmFailResource(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmChangeResourceParams(
    PFM_RESOURCE    Resource
    );

DWORD
FmpRmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpRmResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD FmpRmLoadResTypeDll(
    IN PFM_RESTYPE  pResType
    );

DWORD
FmpPostProcessResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Interfaces for managing resources
//

DWORD
FmpInitResource(
    VOID
    );

VOID
FmpCleanupResource(
    VOID
    );

PFM_RESOURCE
FmpCreateResource(
    IN  PFM_GROUP   Group,
    IN  LPCWSTR     ResourceId,
    IN  LPCWSTR     ResourceName,
    IN  BOOL        Initialize
    );

VOID
FmpDestroyResource(
    IN PFM_RESOURCE Resource,
    IN BOOL         bDeleteObjOnly
    );

VOID
FmpResourceLastReference(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpInitializeResource(
    IN PFM_RESOURCE Resource,
    IN BOOL         Initialize
    );

DWORD
FmpOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    );

DWORD
FmpArbitrateResource(
    IN PFM_RESOURCE pResource
    );

DWORD
FmpOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    );

DWORD
FmpDoOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    );

DWORD
FmpDoOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    );

VOID
FmpSetResourcePersistentState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    );

VOID
FmpCallResourceNotifyCb(
    IN PFM_RESOURCE Resource, 
    IN CLUSTER_RESOURCE_STATE State
    );

DWORD
FmpPropagateResourceState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    );

DWORD
FmpGetResourceList(
    OUT PRESOURCE_ENUM *ReturnEnum,
    IN PFM_GROUP Group
    );

DWORD FmpSubmitRetryOnline(
    IN PRESOURCE_ENUM   pResourceEnum,
    IN PFM_GROUP        pGroup
    );

VOID
FmpDeleteResourceEnum(
    IN PRESOURCE_ENUM Enum
    );

DWORD
FmpOnlineResourceList(
    IN PRESOURCE_ENUM   Enum,
    IN PFM_GROUP        pGroup
    );

DWORD
FmpOfflineResourceList(
    IN PRESOURCE_ENUM Enum,
    IN BOOL Restore
    );

DWORD
FmpTerminateResourceList(
    IN PRESOURCE_ENUM Enum
    );

VOID
FmpPrunePreferredList(
    IN PFM_RESOURCE Resource
    );

DWORD 
FmpCleanupPossibleNodeList(
    IN PFM_RESOURCE pResource
    );

DWORD
FmpSetPreferredEntry(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node
    );

DWORD
FmpAddPossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    );

DWORD
FmpAddPossibleEntry(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    );

DWORD
FmpRemovePossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL RemoveQuorum
    );

DWORD
FmpRemoveResourceDependency(
    IN HXSACTION hXsaction,
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependsOn
    );

BOOL
FmpFindQuorumResource(
    IN OUT PFM_RESOURCE *QuorumResource,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

DWORD 
FmpGetQuorumDiskSignature(
    IN LPCWSTR lpQuorumId,
    OUT LPDWORD lpdwSignature
    );

BOOL
FmpReturnResourceType(
    IN OUT PFM_RESTYPE *FoundResourceType,
    IN LPCWSTR ResourceTypeName,
    IN PFM_RESTYPE ResourceType,
    IN LPCWSTR Name
    );

DWORD
FmpChangeResourceMonitor(
    IN PFM_RESOURCE Resource,
    IN DWORD        SeparateMonitor
    );

DWORD
FmpChangeResourceGroup(
    IN PFM_RESOURCE Resource,
    IN PFM_GROUP Group
    );

DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );

DWORD
FmpValRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    ); 

DWORD
FmpUpdateChangeResourceName(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszResourceId,
    IN LPCWSTR lpszNewName
    );

DWORD
FmpUpdateDeleteResource(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId
    );

DWORD
FmpUpdateAddDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    );

DWORD
FmpUpdateRemoveDependency(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR DependsOnId
    );

DWORD
FmpUpdateAssignOwnerToGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    );

DWORD
FmpUpdateApproveJoin(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId
    );

DWORD
FmpUpdateCreateGroup(
    IN PGUM_CREATE_GROUP pGumGroup,
    IN BOOL    bSourceNode
    );

DWORD
FmpUpdateCreateResource(
    IN OUT PGUM_CREATE_RESOURCE pGumResource
    );

DWORD
FmpUpdateCompleteGroupMove(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN LPCWSTR  pszGroupId
    );

DWORD
FmpUpdateCheckAndSetGroupOwner(
    IN BOOL bSourceNode,
    IN LPCWSTR lpszGroupId,
    IN LPCWSTR lpszNodeId
    );

DWORD
FmpUpdateCreateResourceType(
    IN PVOID Buffer    
    );

DWORD FmpSetResourceName(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      lpszFriendlyName
    );

DWORD
FmpClusterEventPropHandler(
    IN PFM_RESOURCE pResource
    );

BOOL
FmpEnumResourceNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD FmpPrepareQuorumResChange(
    IN PFM_RESOURCE pNewQuoRes,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    );

DWORD
FmpCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszQuoLogPath
    );

DWORD
FmpBackupClusterDatabase(
    IN PFM_RESOURCE pQuoRes,
    IN LPCWSTR      lpszPathName
    );

VOID FmpCheckForGroupCompletionEvent(
    IN PFM_GROUP pGroup);

//
// Interfaces for handling pending online/offline requests.
//
VOID
FmpSignalGroupWaiters(
    IN PFM_GROUP Group
    );

DWORD
FmpWaitForGroup(
    IN PFM_GROUP Group
    );

#define FmpIsGroupPending(_group_) (!IsListEmpty(&((_group_)->WaitQueue)))

//
// There is currently one default monitor process, and resources
// with the SeparateMonitor property have a monitor created for them.
//

extern PRESMON FmpDefaultMonitor;

//
// Interface for notification module
//
DWORD
FmpInitializeNotify(
    VOID
    );

BOOL
FmpPostNotification(
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD  NotifyEvent,
    IN CLUSTER_RESOURCE_STATE CurrentState
    );


//
// Event processing routines
//

DWORD
FmpStartWorkerThread(
    VOID
    );

VOID
FmpPostWorkItem(
    IN CLUSTER_EVENT Event,
    IN PVOID Context1,
    IN ULONG_PTR Context2
    );

VOID
FmpHandleGroupFailure(
    IN PFM_GROUP    Group,
    IN PFM_RESOURCE pResource   OPTIONAL
    );

DWORD
FmpNodeUp(
    PVOID Context
    );

DWORD
FmpNodeDown(
    PVOID Context
    );

VOID
FmpPropagateState(
    VOID
    );

DWORD
FmpSetPossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN BOOL    bAssumeSupported
    );


DWORD
FmpRemovePossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN PNM_NODE pNode
    );

//
// Object Manager callback routines.
//

DWORD
WINAPI
FmpQueryGroupInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    );

DWORD
WINAPI
FmpQueryResourceInfo(
    IN PVOID Object,
    IN BOOL  Initialize
    );

DWORD
WINAPI
FmpQueryResTypeInfo(
    IN PVOID Object
    );

DWORD
WINAPI
FmpFixupGroupInfo(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmpFixupResourceInfo(
    IN PFM_RESOURCE Resource
    );

//
// Synchronization macros
//
#define FmpAcquireResourceLock()  EnterCriticalSection(&FmpResourceLock)

#define FmpReleaseResourceLock()  LeaveCriticalSection(&FmpResourceLock)

#define FmpAcquireGroupLock()  EnterCriticalSection(&FmpGroupLock)

#define FmpReleaseGroupLock()  LeaveCriticalSection(&FmpGroupLock)

#define FmpAcquireMonitorLock()  EnterCriticalSection(&FmpMonitorLock)

#define FmpReleaseMonitorLock()  LeaveCriticalSection(&FmpMonitorLock)

#if 0
// 185575: remove unique RPC binding handles
#define FmpAcquireBindingLock()  EnterCriticalSection(&FmpBindingLock)

#define FmpReleaseBindingLock()  LeaveCriticalSection(&FmpBindingLock)
#endif

#define FmpTryAcquireGroupLock( Locked, Timeout )       \
{                                                       \
    DWORD   _retry = (Timeout + 19) / 20;               \
    do {                                                \
        Locked = TryEnterCriticalSection(&FmpGroupLock); \
        if ( !Locked ) Sleep( 20 );                     \
    } while (_retry-- && !Locked );                     \
}    

// Group and Resource Specific locks

#if 1 // DBG

#define FmpAcquireLocalGroupLock( Group )   \
{                                           \
    DWORD _fmpLockIndx;                     \
    EnterCriticalSection( &Group->Lock );   \
    _fmpLockIndx = Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;     \
    Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Group->LockIndex = ++_fmpLockIndx;      \
}    

#define FmpTryAcquireLocalGroupLock( Group, Locked )   \
{                                               \
    DWORD _fmpLockIndx;                         \
    Locked = TryEnterCriticalSection( &Group->Lock );   \
    if ( Locked ) {                             \
      _fmpLockIndx = Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
      Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;   \
      Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
      Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
      Group->LockIndex = ++_fmpLockIndx;        \
    }                                           \
}    

#define FmpReleaseLocalGroupLock( Group )   \
{                                           \
    DWORD _fmpLockIndx;                     \
    CL_ASSERT(HandleToUlong(Group->Lock.OwningThread) == GetCurrentThreadId()); \
    _fmpLockIndx = Group->UnlockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Group->UnlockTable[_fmpLockIndx].Module = LOG_MODULE;   \
    Group->UnlockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Group->UnlockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Group->UnlockIndex = ++_fmpLockIndx;    \
    LeaveCriticalSection( &Group->Lock );   \
}    

#define FmpAcquireLocalResourceLock( Resource )     \
{                                           \
    DWORD _fmpLockIndx;                     \
    PFM_GROUP pGroup;                       \
    while( 1 ) {                            \
        pGroup = Resource->Group;           \
        EnterCriticalSection( &pGroup->Lock );\
        if( pGroup == Resource->Group ) break;   \
        LeaveCriticalSection( &pGroup->Lock );  \
    }                                       \
    _fmpLockIndx = Resource->Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Resource->Group->LockTable[_fmpLockIndx].Module = LOG_MODULE;   \
    Resource->Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Resource->Group->LockTable[_fmpLockIndx].LineNumber =  __LINE__; \
    Resource->Group->LockIndex = ++_fmpLockIndx;    \
}    

#define FmpReleaseLocalResourceLock( Resource ) \
{                                           \
    DWORD _fmpLockIndx;                     \
    CL_ASSERT(HandleToUlong(Resource->Group->Lock.OwningThread) == GetCurrentThreadId()); \
    _fmpLockIndx = Resource->Group->UnlockIndex & (FM_MAX_LOCK_ENTRIES - 1);   \
    Resource->Group->UnlockTable[_fmpLockIndx].Module = LOG_MODULE;     \
    Resource->Group->UnlockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
    Resource->Group->UnlockTable[_fmpLockIndx].LineNumber = __LINE__; \
    Resource->Group->UnlockIndex = ++_fmpLockIndx;    \
    LeaveCriticalSection( &Resource->Group->Lock );  \
}    

#define FmpTryAcquireLocalResourceLock( Resource, _Status_ )     \
{                                                                \
    (_Status_) = TryEnterCriticalSection(&Resource->Group->Lock); \
    if ( !(_Status_) ) { \
        Sleep(100);                                               \
        (_Status_) = TryEnterCriticalSection( &Resource->Group->Lock ); \
    }                                                               \
    if (_Status_) {                                                 \
        DWORD _fmpLockIndx;                                         \
        _fmpLockIndx = Resource->Group->LockIndex & (FM_MAX_LOCK_ENTRIES - 1); \
        Resource->Group->LockTable[_fmpLockIndx].Module = LOG_MODULE; \
        Resource->Group->LockTable[_fmpLockIndx].ThreadId = GetCurrentThreadId(); \
        Resource->Group->LockTable[_fmpLockIndx].LineNumber = __LINE__; \
        Resource->Group->LockIndex = ++_fmpLockIndx;                \
    }   \
}    
    

#else // DBG

#define FmpAcquireLocalGroupLock( Group )   \
    EnterCriticalSection( &Group->Lock )

#define FmpTryAcquireLocalGroupLock( Group, Locked )   \
    Locked = TryEnterCriticalSection( &Group->Lock )

#define FmpReleaseLocalGroupLock( Group )   \
    LeaveCriticalSection( &Group->Lock )

#define FmpAcquireLocalResourceLock( Resource )     \
{                                           \
    PFM_GROUP pGroup;                       \
    while( 1 ) {                            \
        pGroup = Resource->Group;           \
        EnterCriticalSection( &pGroup->Lock );\
        if( pGroup == Resource->Group ) break;   \
        LeaveCriticalSection( &pGroup->Lock );  \
    }                                             \
}                                 

#define FmpReleaseLocalResourceLock( Resource )     \
    LeaveCriticalSection( &Resource->Group->Lock )

#define FmpTryAcquireLocalResourceLock( Resource, _result_ )     \
    if ( !((_result_) = TryEnterCriticalSection(&Resource->Group->Lock)) ) { \
        sleep(100);                                               \
        (_result_) = TryEnterCriticalSection( &Resource->Group->Lock ); \
    }

#endif // DBG

//
// Global Data
//
extern CRITICAL_SECTION FmpResourceLock;


//
// Resource Management Routines
//


//
// Interfaces for managing resource trees.
//


DWORD
FmpRestartResourceTree(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpOnlineWaitingTree(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpOfflineWaitingTree(
    IN PFM_RESOURCE Resource
    );


//++
//
// Routine Description:
//
//     Processes the Cluster resource list in the registry. For each
//     resource key found, a cluster resource is created.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--
DWORD
FmpInitResources(
    VOID
    );

VOID
FmpCleanupResources(
    VOID
    );

BOOL
FmpInPossibleListForResource(
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode
    );

    
DWORD
FmpInitResourceTypes(
    VOID
    );

PFM_RESTYPE
FmpCreateResType(
    IN LPWSTR ResTypeName
    );

DWORD
FmpDeleteResType(
    IN PFM_RESTYPE pResType
    );

BOOL
FmpFindResourceType(
    IN PFM_RESTYPE Type,
    IN PBOOL ResourceExists,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    );

BOOL
FmpInPossibleListForResType(
    IN PFM_RESTYPE pResType,
    IN PNM_NODE     pNode
    );

DWORD
FmpHandleResourceTypeControl(
    IN PFM_RESTYPE Type,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

BOOL
FmpEnumResTypeNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

VOID
FmpResTypeLastRef(
    IN PFM_RESTYPE Resource
    );

DWORD FmpAddPossibleNodeToList(
    IN LPCWSTR      pmszPossibleNodes,
    IN DWORD        dwStringSize,         
    IN PLIST_ENTRY  pPosNodeList
);    

BOOL
FmpFixupPossibleNodesForResTypeCb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      ResTypeName
);

BOOL
FmpFixupResTypePhase2Cb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
);


DWORD
FmpFixupResourceTypesPhase1(
    BOOL    bJoin,
    BOOL    bNmLocalNodeVersionChanged,
    PCLUSTERVERSIONINFO pClusterVersionInfo
);

DWORD
FmpFixupResourceTypesPhase2(
    BOOL    bJoin,
    BOOL    bNmLocalNodeVersionChanged,
    PCLUSTERVERSIONINFO pClusterVersionInfo
);

DWORD FmpDecidePossibleNodeForResType
(
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD dwVoteBufLength,
    IN PVOID pVoteBuf,
    IN DWORD dwNumVotes,
    IN BOOL  bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *ppOutputBuf
);
    

PFM_RESOURCE
FmpFindResourceByNotifyKey(
    RM_NOTIFY_KEY  NotifyKey
    );

DWORD
FmpTerminateResource(
    IN PFM_RESOURCE  Resource
    );


DWORD
WINAPI
FmpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
FmpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
FmpSyncArbitration(
    IN DWORD NewPhase,
    OUT LPDWORD CurrentPhase
    );

DWORD
FmpEnumSortGroups(
    OUT PGROUP_ENUM *ReturnEnum,
    IN LPCWSTR pszOwnerNodeId OPTIONAL,
    OUT PBOOL QuorumGroup
    );

VOID
FmpPrepareGroupForOnline(
    IN PFM_GROUP Group
    );

DWORD
FmpSetGroupEnumOwner(
    IN PGROUP_ENUM  pGroupEnum,
    IN PNM_NODE     pDefaultOwnerNode,
    IN LPCWSTR      pszDeadNodeId,
    IN BOOL         bQuorumGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    );

DWORD
FmpOnlineGroupList(
    IN PGROUP_ENUM GroupEnum,
    IN BOOL bPrepareQuoForOnline
    );

DWORD FmpOnlineGroupFromList(
    IN PGROUP_ENUM GroupEnum,
    IN DWORD       Index,
    IN BOOL bPrepareQuoForOnline
    );

DWORD FmpOnlineResourceFromList(
    IN PRESOURCE_ENUM GroupEnum,
    IN PFM_GROUP      pGroup
    );

BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    );

DWORD
FmpOnlineGroup(
    IN PFM_GROUP    Group,
    IN BOOL         ForceOnline
    );

DWORD
FmpOfflineGroup(
    IN PFM_GROUP    Group,
    IN BOOL         OfflineQuorum,
    IN BOOL         SetPersistent
    );

DWORD 
FmpDeleteGroup(
    IN PFM_GROUP pGroup
    );

DWORD
FmpMoveGroup(
    IN  PFM_GROUP    Group,
    IN  PNM_NODE     DestinationNode,
    IN  BOOL         ShutdownHandler,
    OUT PNM_NODE     *pChosenDestinationNode,
    IN BOOL          bChooseMostPreferredNode
    );

DWORD
FmpCompleteMoveGroup(
    IN PFM_GROUP    Group,
    IN PNM_NODE     DestinationNode
    );

DWORD
FmpDoMoveGroup(
    IN PFM_GROUP    Group,
    IN PNM_NODE     DestinationNode,
    IN BOOL         bChooseMostPreferredNode
    );

BOOL
FmpGroupCanMove(
    IN PFM_GROUP    Group
    );

DWORD
FmpUpdateChangeGroupName(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NewName
    );


DWORD
FmpUpdateDeleteGroup(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId
    );

BOOL
FmpEnumGroupNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

PNM_NODE
FmpFindAnotherNode(
    IN PFM_GROUP Group,
    IN BOOL  bChooseMostPreferredNode
    );

PNM_NODE
FmpGetPreferredNode(
    IN PFM_GROUP Group
    );

//++
//
// Routine Description:
//
//     Takes appropriate action based on resource state transitions indicated
//     by the Resource Monitor.
//
// Arguments:
//
//     Resource   - The resource which has transitioned.
//
//     NewState   - The new state of Resource.
//
// Return Value:
//
//     None.
//
//--
VOID
FmpHandleResourceTransition(
    IN PFM_RESOURCE   Resource,
    IN CLUSTER_RESOURCE_STATE NewState
    );

DWORD FmpCreateResStateChangeHandler(
    IN PFM_RESOURCE pResource, 
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    );

VOID
FmpProcessResourceEvents(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    );
    


VOID
FmpHandleResourceFailure(
    IN PFM_RESOURCE Resource
    );

//
// Group Management Routines
//


//++
//
// Routine Description:
//
//     Processes the Cluster Group list in the registry. For each
//     Group key found, a cluster Group is created.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--

DWORD
FmpInitGroups(
    IN BOOL Initialize
    );

DWORD
FmpCompleteInitGroup(
    IN PFM_GROUP Group
    );

VOID
FmpCleanupGroups(
    IN BOOL  ClusterShutDownEvent 
    );

DWORD
FmpCleanupGroupPhase1(
    IN PFM_GROUP Group,
    IN DWORD     dwTimeOut
    );

DWORD
FmpCleanupGroupsWorker(
    IN PFM_CLEANUP_INFO pFmCleanupInfo
    );

DWORD
FmpCleanupGroupPhase2(
    IN PFM_GROUP Group
    );

DWORD  FmpCleanupQuorumResource(
    IN PFM_RESOURCE Resource
    );

BOOL
FmpInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node,
    IN BOOL      bRecalc,
    IN PFM_RESOURCE pRefResource
    );

BOOL
FmpHigherInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node1,
    IN PNM_NODE  Node2
    );


PFM_GROUP
FmpCreateGroup(
    IN LPWSTR   GroupId,
    IN BOOL     Initialize
    );

DWORD FmpInitializeGroup(
    IN PFM_GROUP Group, 
    IN BOOL Initialize
    );

DWORD
FmpDestroyGroup(
    IN PFM_GROUP Group,
    IN BOOL      bDeleteObjOnly
    );


VOID
FmpSetGroupPersistentState(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE State
    );

DWORD
FmpPropagateGroupState(
    IN PFM_GROUP    Group
    );

DWORD
FmpPropagateFailureCount(
    IN PFM_GROUP    Group,
    IN BOOL         NewTime
    );

DWORD
FmpGetGroupListState(
    IN PGROUP_ENUM GroupEnum
    );


DWORD
FmpOfflineGroupList(
    IN PGROUP_ENUM GroupEnum
    );

VOID
FmpGroupLastReference(
    IN PFM_GROUP pGroup
    );


//
// Stuff previously in fmclient.h
//
typedef
DWORD
(WINAPI *PSEND_MSG_ROUTINE) (
    IN PGROUP_ENUM MyGroups,
    IN PGROUP_ENUM OtherGroups,
    OUT PGROUP_ENUM *ResponseOtherGroups,
    OUT PGROUP_ENUM *ResponseMyGroups
    );
//
// Global function prototypes
//

DWORD
FmcOnlineGroupRequest(
    IN PFM_GROUP Group
    );

DWORD
FmcOfflineGroupRequest(
    IN PFM_GROUP Group
    );

DWORD
FmcMoveGroupRequest(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    );

DWORD
FmcTakeGroupRequest(
    IN PNM_NODE DestinationNode,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    );

DWORD
FmcDeleteGroupRequest(
    IN PFM_GROUP pGroup
);
    

DWORD
FmcOnlineResourceRequest(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcOfflineResourceRequest(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcArbitrateResource(
    IN PFM_RESOURCE Resource
    );

DWORD
FmcFailResource(
    IN PFM_RESOURCE Resource
    );

PFM_RESOURCE
FmcCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD dwFlags
    );

DWORD
FmcDeleteResource(
    IN PFM_RESOURCE Resource
    );

CLUSTER_GROUP_STATE
FmcGetGroupState(
    IN LPCWSTR GroupId,
    OUT LPWSTR *NodeName
    );

DWORD
FmcChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    );

DWORD
FmcResourceControl(
    IN PNM_NODE Node,
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcResourceTypeControl(
    IN PNM_NODE Node,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcGroupControl(
    IN PNM_NODE Node,
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmcPrepareQuorumResChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    );


DWORD
FmcCompleteQuorumResChange(
    IN PFM_RESOURCE pOldQuoRes,
    IN LPCWSTR      lpszOldQuoLogPath
    );

DWORD
FmcBackupClusterDatabase(
    IN PFM_RESOURCE pQuoResource,
    IN LPCWSTR      lpszPathName
    );

DWORD
FmcChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    );

DWORD
FmcAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );

DWORD
FmcRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    );
    

DWORD
FmpGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpHandleGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
FmpTakeGroupRequest(
    IN PFM_GROUP Group,
    IN PRESOURCE_ENUM ResourceList
    );

CLUSTER_GROUP_STATE
FmpGetGroupState(
    IN PFM_GROUP Group,
    IN BOOL      IsNormalized
    );

VOID
FmpDeleteEnum(
    IN PGROUP_ENUM Enum
    );

DWORD
FmpClaimAllGroups(
    PGROUP_ENUM MyGroups
    );

DWORD
FmpAssignOwnersToGroups(
    IN LPCWSTR pszDeadNodeId,
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    );


VOID
FmpPruneGroupOwners(
    IN PFM_GROUP Group
    );

DWORD
FmpQueryGroupNodes(
    IN PFM_GROUP Group,
    IN HDMKEY hGroupKey
    );

DWORD
FmpUpdateChangeClusterName(
    IN BOOL SourceNode,
    IN LPCWSTR NewName
    );

DWORD
FmpUpdateChangeQuorumResource(
    IN BOOL SourceNode,
    IN LPCWSTR  NewQuorumResId,
    IN LPCWSTR  pszQuorumLogPath,
    IN LPDWORD  pdwMaxQuorumLogSize
    );

DWORD
FmpUpdateChangeQuorumResource2(
    IN BOOL SourceNode,
    IN LPCWSTR  NewQuorumResId,
    IN LPCWSTR  pszQuorumLogPath,
    IN LPDWORD  pdwMaxQuorumLogSize,
    IN LPDWORD  pdwQuorumArbTimeout,
    IN LPDWORD  pdwNewQuorumResourceCharacteristics OPTIONAL
    );

DWORD
FmpUpdateResourceState(
    IN BOOL SourceNode,
    IN LPCWSTR ResourceId,
    IN PGUM_RESOURCE_STATE ResourceState
    );

DWORD
FmpUpdateGroupState(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId,
    IN PGUM_GROUP_STATE ResourceState
    );

DWORD
FmpUpdateGroupNode(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NodeId
    );

DWORD
FmpUpdateGroupIntendedOwner(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszGroupId,
    IN PDWORD   pdwNodeId
    );
    
//
// Handle group property requests
//

DWORD
FmpGroupEnumCommonProperties(
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupEnumPrivateProperties(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupGetCommonProperties(
    IN PFM_GROUP    Group,
    IN BOOL         ReadOnly,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupValidateCommonProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupSetCommonProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupGetPrivateProperties(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

DWORD
FmpGroupValidatePrivateProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupSetPrivateProperties(
    IN PFM_GROUP    Group,
    IN PVOID        InBuffer,
    IN DWORD        InBufferSize
    );

DWORD
FmpGroupGetFlags(
    IN PFM_GROUP    Group,
    OUT PVOID       OutBuffer,
    IN DWORD        OutBufferSize,
    OUT LPDWORD     BytesReturned,
    OUT LPDWORD     Required
    );

//property parse routines
DWORD FmpGetDiskInfoParseProperties(
    IN PUCHAR   InBuffer,
    IN DWORD    InBufferSize,
    IN OUT LPWSTR  pszPath
    );

DWORD
FmpBroadcastDeleteControl(
    IN PFM_RESOURCE Resource
    );

DWORD
FmpBroadcastDependencyChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR DependsOnId,
    IN BOOL Remove
    );

BOOL
FmpCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    );


DWORD 
FmpVotePossibleNodeForResType(
    IN  DWORD dwInputBufLength,
    IN  LPCWSTR lpszResType,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
);

DWORD
FmpUpdatePossibleNodeForResType(
    IN BOOL         SourceNode,
    IN LPCWSTR      lpszResTypeName,
    IN LPDWORD      pdwBufLength,
    IN PVOID        pBuf
    );

DWORD
FmpUpdateChangeResourceNode(
    IN BOOL         SourceNode,
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode,
    IN DWORD        dwControlCode
    );

DWORD 
FmpUpdateChangeResourceGroup(
    IN BOOL         bSourceNode,
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    );

DWORD 
FmpChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR NodeId,
    IN BOOL Add

    );

DWORD
FmpFixupPossibleNodesForResources(
    BOOL    bJoin
    );

BOOL
FmpEnumFixupPossibleNodesForResource(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszResName
    );

DWORD
FmpQueueTimerActivity(
    IN DWORD                dwInterval,
    IN PFN_TIMER_CALLBACK   pfnTimerCb, 
    IN PVOID                pContext    
);    

DWORD
FmpDelayedStartRes(
    IN PFM_RESOURCE pResource
    );

//timer callback functions
void
WINAPI
FmpReslistOnlineRetryCb(
    IN HANDLE   hTimer,
    IN PVOID    pContext
);

VOID 
FmpDelayedRestartCb(
    IN HANDLE hTimer, 
    IN PVOID pContext
);

DWORD
FmpDoMoveGroupOnFailure(
    IN LPVOID pContext
    );

DWORD   
FmpSetOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN PNM_NODE  pNode
    );

DWORD   
FmpSetIntendedOwnerForGroup(
    IN PFM_GROUP    pGroup,
    IN DWORD        dwNodeId
    );

VOID
FmpResetGroupIntendedOwner(
    IN PGROUP_ENUM  pGroupEnum
    );

DWORD
FmpGetGroupInNodeGroupList(
    OUT PGROUP_ENUM *pReturnEnum,
    IN PFM_GROUP pGroup,
    IN LPCWSTR pszDeadNodeId,
    OUT PBOOL pbQuorumGroup
    );
    
VOID
FmpPrepareGroupEnumForOnline(
    IN PGROUP_ENUM pGroupEnum
    );

DWORD
FmpRmExceptionFilter(
    DWORD ExceptionCode
    );

DWORD
FmpBringQuorumGroupListOnline(
    IN LPVOID pContext
    );

DWORD
FmpHandleNodeDownEvent(
    IN  PVOID pContext
    );

DWORD
FmpEnumerateGroupResources(
    IN PFM_GROUP pGroup,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE pfnEnumerationRoutine,
    IN PVOID pContext1,
    IN PVOID pContext2
    );

PNM_NODE
FmpGetNonLocalPreferredNode(
    IN PFM_GROUP Group
    );

DWORD 
FmpGetResourceCharacteristics(
    IN PFM_RESOURCE pQuoResource, 
    OUT LPDWORD pdwCharacteristics
    );
    
BOOL
FmpIsAnyResourcePersistentStateOnline(
    IN PFM_GROUP pGroup
    );

PNM_NODE
FmpGetNodeNotHostingUndesiredGroups(
    IN PFM_GROUP pGroup,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fChooseMostPreferredNode
    );

BOOL
FmpCheckForAntiAffinityProperty(
    IN LPCWSTR lpszLimitOneGroupPerName,
    IN PGROUP_AFFINITY_NODE_INFO pGroupAffinityNodeInfo,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupName
    );

DWORD
FmpUpgradeResourceDLL(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszInstallationPath
    );

DWORD
FmpParsePathForFileName(
    IN LPWSTR lpszPath,
    IN BOOL fCheckPathExists,
    OUT LPWSTR *ppszFileName
    );

DWORD
FmpValidateResourceDLLReplacement(
    IN PFM_RESOURCE pResource,
    IN LPWSTR lpszNewDllName,
    OUT LPWSTR *ppszCurrentDllPath
    );

DWORD
FmpReplaceResourceDLL(
    IN LPWSTR lpszNewDllName,
    IN LPWSTR lpszCurrentDllPath,
    IN LPWSTR lpszInstallationPath
    );

DWORD
FmpRecycleMonitors(
    IN LPCWSTR lpszDllName
    );

DWORD
FmpCreateMonitorList(
    IN LPCWSTR lpszDllName,
    OUT PFM_MONITOR_ENUM_HEADER pMonitorHeader
    );

BOOL
FmpFindHostMonitors(
    IN LPCWSTR lpszDllName,
    IN OUT PFM_MONITOR_ENUM_HEADER pMonitorEnumHeader,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR lpszResourceId
    );

DWORD
FmpRecoverResourceDLLFiles(
    VOID
    );

DWORD
FmpResetMultiSzValue(
    IN  HKEY hKey,
    IN  LPWSTR lpmszList,
    IN  OUT LPDWORD pcchLen,
    IN  LPCWSTR lpszValueName,
    IN  LPCWSTR lpszString 
    );

DWORD
FmpCopyBackupFile(
    IN LPCWSTR  lpszPath
    );

VOID
FmpDeleteBackupFiles(
    IN LPCWSTR  lpszPath    OPTIONAL
    );

PNM_NODE
FmpPickNodeFromPreferredListAtRandom(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pSuggestedPreferredNode  OPTIONAL,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fCheckForDisablingRandomization
    );

BOOL
FmpIsNodeUserPreferred(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pPreferredNode
    );

DWORD
FmpPrepareGroupNodeList(
    OUT PFM_GROUP_NODE_LIST *ppGroupNodeList
    );

DWORD
FmpAddGroupNodeToList(
    IN PFM_GROUP_NODE_LIST *ppGroupNodeList,
    IN LPDWORD pcbBuffer,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupId
    );

PNM_NODE
FmpParseGroupNodeListForPreferredOwner(
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList,
    IN PNM_NODE pSuggestedPreferredNode
    );

DWORD
FmpUpdateUseRandomizedNodeListForGroups(
    IN BOOL     SourceNode,
    IN LPCWSTR  pszNodeId,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    );

VOID
FmpClusterWideInitializeResource(
    IN PFM_RESOURCE pResource
    );

VOID
FmpNotifyResourceStateChangeReason(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    );

VOID
FmpNotifyGroupStateChangeReason(
    IN PFM_GROUP pGroup,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    );

DWORD FmpGetClusterNameChangeParams(
    IN  LPCWSTR          lpszNewName,
    OUT PFM_RESOURCE    *ppCoreNetNameResource,
    OUT PVOID           *ppPropList,
    OUT LPDWORD         pdwPropListSize   
    );

DWORD FmpValidateCoreNetNameChange(
    IN PFM_RESOURCE pResource, 
    IN PVOID pPropList,
    IN DWORD cbListSize
    );

DWORD FmpCoreNetNameChange(
    IN PFM_RESOURCE pResource, 
    IN PVOID pPropList,
    IN DWORD cbListSize
    );

VOID
FmpHandleNodeEvictEvent(
    IN  PVOID pContext
    );

DWORD
FmpRmDoHandleCriticalResourceStateChange(
    IN PRM_EVENT pEvent,
    IN OPTIONAL PFM_RESOURCE pTransitionedResource,
    IN CLUSTER_RESOURCE_STATE NewState
    );

BOOL
FmpHandleMonitorCrash(
    IN PRESMON pCrashedMonitor
    );

VOID
FmpHandleResourceRestartOnMonitorCrash(
    IN PFM_RESOURCE pResource
    );

VOID
FmpCheckAndUpdateMonitorForDeadlockDetection(
    IN PRESMON  pMonitor
    );

VOID
FmpHandleMonitorDeadlock(
    IN PRESMON  pMonitor
    );

#endif //ifndef _FMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmprop.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmprop.c

Abstract:

    Implements the management of group properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

--*/
#include "fmp.h"
//#include "stdio.h"

#define MAX_DWORD ((DWORD)-1)

//
// Group Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
FmpGroupCommonProperties[] = {
    { CLUSREG_NAME_GRP_DESC,               NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0 },
    { CLUSREG_NAME_GRP_PERSISTENT_STATE,   NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0 },
    { CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD, 0, MAX_DWORD, 0 },
    { CLUSREG_NAME_GRP_FAILOVER_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD, 0, CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD, 0 },
    { CLUSREG_NAME_GRP_FAILBACK_TYPE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE, 0, CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE, 0 },
    { CLUSREG_NAME_GRP_FAILBACK_WIN_START, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START, RESUTIL_PROPITEM_SIGNED },
    { CLUSREG_NAME_GRP_FAILBACK_WIN_END,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END, RESUTIL_PROPITEM_SIGNED },
    { CLUSREG_NAME_GRP_LOADBAL_STATE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_LOADBAL_STATE, 0, 1, 0 },
    { CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME, NULL, CLUSPROP_FORMAT_MULTI_SZ,    0, 0, 0, 0 },
    { 0 }
};

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
FmpGroupROCommonProperties[] = {
    { CLUSREG_NAME_GRP_NAME, NULL, CLUSPROP_FORMAT_SZ,
      0, 0, 0,
      RESUTIL_PROPITEM_READ_ONLY,
      0
    },
//    { CLUSREG_NAME_GRP_CONTAINS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY, 0 },
//    { CLUSREG_NAME_GRP_PREFERRED_OWNERS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY, 0 },
    { 0 }
};



//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
FmpClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};



DWORD
FmpGroupEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given group.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ClRtlEnumProperties( FmpGroupCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // FmpGroupEnumCommonProperties



DWORD
FmpGroupGetCommonProperties(
    IN PFM_GROUP Group,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given group.

Arguments:

    Group - Supplies the group.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    DWORD           outBufferSize = OutBufferSize;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Get the common properties.
    //
    if ( ReadOnly ) {
        //
        // We have to be particularly careful about the group name.
        // If a remote node owns the group, and changes the name, then
        // the registry field is updated after the name is set into OM.
        // Therefore, we must read the OM info, rather than the registry
        // which could be stale.
        //
        status = ClRtlPropertyListFromParameterBlock(
                            FmpGroupROCommonProperties,
                            OutBuffer,
                            &outBufferSize,
                            (LPBYTE) &OmObjectName(Group),
                            BytesReturned,
                            Required );
    } else {
        status = ClRtlGetProperties(
                            Group->RegistryKey,
                            &FmpClusterRegApis,
                            FmpGroupCommonProperties,
                            OutBuffer,
                            OutBufferSize,
                            BytesReturned,
                            Required );
    }

    return(status);

} // FmpGroupGetCommonProperties



DWORD
FmpGroupValidateCommonProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( FmpGroupCommonProperties,
                                       NULL,   // Reserved
                                       FALSE,  // Don't allow uknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_ERROR,
                    "[FM] ValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // FmpGroupValidateCommonProperties



DWORD
FmpGroupSetCommonProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( FmpGroupCommonProperties,
                                       NULL,   // Reserved
                                       FALSE,  // Don't allow uknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status == ERROR_SUCCESS ) {

        status = ClRtlSetPropertyTable( NULL, 
                                        Group->RegistryKey,
                                        &FmpClusterRegApis,
                                        FmpGroupCommonProperties,
                                        NULL,   // Reserved
                                        FALSE,  // Don't allow unknowns
                                        InBuffer,
                                        InBufferSize,
                                        FALSE,  // bForceWrite
                                        NULL );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_ERROR,
                       "[FM] SetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_ERROR,
                    "[FM] SetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // FmpGroupSetCommonProperties



DWORD
FmpGroupEnumPrivateProperties(
    PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given group.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster group parameters key.
    //
    groupKey = DmOpenKey( Group->RegistryKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED );
    if ( groupKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enumerate the private properties.
    //
    status = ClRtlEnumPrivateProperties( groupKey,
                                         &FmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );
    DmCloseKey( groupKey );

    return(status);

} // FmpGroupEnumPrivateProperties



DWORD
FmpGroupGetPrivateProperties(
    IN PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given group.

Arguments:

    Group - Supplies the group.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster group parameters key.
    //
    groupKey = DmOpenKey( Group->RegistryKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED );
    if ( groupKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the group.
    //
    status = ClRtlGetPrivateProperties( groupKey,
                                        &FmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( groupKey );

    return(status);

} // FmpGroupGetPrivateProperties



DWORD
FmpGroupValidatePrivateProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // FmpGroupValidatePrivateProperties



DWORD
FmpGroupSetPrivateProperties(
    IN PFM_GROUP Group,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given group.

Arguments:

    Group - Supplies the group.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      groupKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster group\parameters key
        //
        groupKey = DmOpenKey( Group->RegistryKey,
                              CLUSREG_KEYNAME_PARAMETERS,
                              MAXIMUM_ALLOWED );
        if ( groupKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                groupKey = DmCreateKey( Group->RegistryKey,
                                        CLUSREG_KEYNAME_PARAMETERS,
                                        0,
                                        KEY_READ | KEY_WRITE,
                                        NULL,
                                        &disposition );
                if ( groupKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              groupKey,
                                              &FmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );
        DmCloseKey( groupKey );

    }

    return(status);

} // FmpGroupSetPrivateProperties



DWORD
FmpGroupGetFlags(
    IN PFM_GROUP Group,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given group.

Arguments:

    Group - Supplies the group.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the group.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( Group->RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // FmpGroupGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\group.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Cluster group management routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996

Notes:

    WARNING: All of the routines in this file assume that the group
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE GROUP

//
// Global Data
//

CRITICAL_SECTION  FmpGroupLock;



//
// Local function prototypes
//


/////////////////////////////////////////////////////////////////////////////
//
// Group Management Routines
//
/////////////////////////////////////////////////////////////////////////////

BOOL
FmpInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node,
    IN BOOL      bRecalc,
    IN PFM_RESOURCE pRefResource
    )

/*++

Routine Description:

    Check if a node is in the preferred list for the Group.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node - The Node to check for.

    bRecalc - If set to TRUE, we recalculate the preferred list for the group 
        based on the possible node list for the reference resource.

    pRefResource - If NULL, we walk all the resources in the
        group and calculate their possible node list to see
        if it has since expanded due to the fact that dlls
        were copied to nodes.
        
Return Value:

    TRUE - if the node is in the list.
    FALSE - if the node is NOT in the list.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    BOOL             bRet = FALSE;
    //
    // For each entry in the Preferred list, it must exist in the possible
    // list.
    //
ChkInPrefList:
    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node ) {
            return(TRUE);
        }
    }

    if (bRecalc)
    {
        PFM_RESOURCE    pResource;
        DWORD           dwStatus;
        LPWSTR          lpszOwners = NULL;
        DWORD           dwMaxSize=0;
        HDMKEY          hGroupKey;
        DWORD           dwSize = 0;

        hGroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group),
                        KEY_READ);
        if (hGroupKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmInPreferredList: Couldnt open group key\r\n",
                dwStatus);
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        //the group preferred list must not be set by the user
        //if it is then there is no point in doing this recalculation
        dwStatus = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &lpszOwners,
                             &dwMaxSize,
                             &dwSize );
        if (lpszOwners) 
            LocalFree(lpszOwners);
        DmCloseKey(hGroupKey);            
        if (dwStatus == ERROR_FILE_NOT_FOUND)
        {
            DWORD   dwUserModified;
            
            for (listEntry = Group->Contains.Flink;
                listEntry != &(Group->Contains);
                listEntry = listEntry->Flink)
            {            
                pResource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

                //the resource possible node list must not be set by the user
                //if it is, then we can skip this resource
                dwStatus = DmQueryDword( pResource->RegistryKey,
                             CLUSREG_NAME_RES_USER_MODIFIED_POSSIBLE_LIST,
                             &dwUserModified,
                             NULL );
                if (dwStatus == ERROR_FILE_NOT_FOUND)
                {
                    FmpSetPossibleNodeForResType(OmObjectId(pResource->Type), 
                        TRUE);
                    if (FmpInPossibleListForResType(pResource->Type,Node) && 
                        !FmpInPossibleListForResource(pResource, Node))
                    {
                        //add to the resource possible node list
                        //this will or add to the pref list of the group
                        FmChangeResourceNode(pResource, Node, TRUE);
                    }
                }
            }     
            //set bRecalc to be FALSE so that we dont evaluate this again
            bRecalc = FALSE;
            goto ChkInPrefList;
        }        
    }
FnExit: 
    return(bRet);

} // FmpInPreferredList



BOOL
FmpHigherInPreferredList(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node1,
    IN PNM_NODE  Node2
    )

/*++

Routine Description:

    Check if Node1 is higher (in priority) in the preferred owners list than
    Node1.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node1 - The Node that should be higher in the list.

    Node2 - The Node that should be lower in the list.

Return Value:

    TRUE - if Node1 is higher in the list.
    FALSE - if Node2 is higher in the list, or Node1 is not in the list at all.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    DWORD            orderedOwners = 0;

    //
    // For each entry in the Preferred list, check whether Node1 or Node2 is
    // higher.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners),
            orderedOwners < Group->OrderedOwners;
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node1 ) {
                return(TRUE);
        }
        if ( preferredEntry->PreferredNode == Node2 ) {
                return(FALSE);
        }
        orderedOwners++;
    }

    return(FALSE);

} // FmpHigherInPreferredList



DWORD
FmpSetPreferredEntry(
    IN PFM_GROUP Group,
    IN PNM_NODE  Node
    )

/*++

Routine Description:

    Add a node to the preferred list for the Group.

Arguments:

    Group - Pointer to the group object with the preferred owners list.

    Node - The Node to add.

Return Value:

    ERROR_SUCCESS if node is added.
    ERROR_NOT_ENOUGH_MEMORY on failure.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    //
    // Make sure entry is not already present in list.
    //
    if ( FmpInPreferredList( Group, Node, FALSE, NULL ) ) {
        return(ERROR_SUCCESS);
    }

    //
    // Create the Preferred Owners List entry.
    //
    preferredEntry = LocalAlloc( LMEM_FIXED, sizeof(PREFERRED_ENTRY) );

    if ( preferredEntry == NULL ) {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[FM] Error allocating preferred owner entry for group %1!ws!. Stopped adding.\n",
                    OmObjectId(Group));
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Create the preferred owner entry and keep a reference on the node object.
    //
    OmReferenceObject( Node );

    preferredEntry->PreferredNode = Node;
    InsertTailList( &Group->PreferredOwners,
                    &preferredEntry->PreferredLinkage );

    return(ERROR_SUCCESS);

} // FmpSetPreferredEntry

BOOL FmpFindNodeThatMightBeAddedToPrefList(
    IN PFM_GROUP    pGroup,
    IN PNM_NODE     *pDestNode,
    IN PVOID pNode, 
    IN LPCWSTR szName)
{
    BOOL    bRet = TRUE;   //assume we will continue enumeration

    *pDestNode = NULL;
    //if this node is not up or if this is the local node, continue
    if ((pNode == NmLocalNode) || (NmGetNodeState(pNode) != ClusterNodeUp))
    {
        return(bRet);
    }
    if (FmpInPreferredList(pGroup, pNode, TRUE, NULL))
    {    
        bRet = FALSE;
        *pDestNode = pNode;
    }        
    return(bRet);
}



PNM_NODE
FmpFindAnotherNode(
    IN PFM_GROUP Group,
    IN BOOL  bChooseMostPreferredNode
    )

/*++

Routine Description:

    Check if another node is up that can take the group.

Arguments:

    Group - Pointer to the group object we're checking.

    bChooseMostPreferredNode - Whether to choose the most preferred node or not.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;
    PNM_NODE	first = NULL;
    BOOLEAN	flag = FALSE;

    //
    //  First, let us give the anti-affinity algorithm a shot at picking the node.
    //
    first = FmpGetNodeNotHostingUndesiredGroups ( Group, 
                                                  TRUE, // Rule out local node
                                                  bChooseMostPreferredNode ); 

    if ( first != NULL )
    {
        goto FnExit;
    }

    //
    // For each entry in the Preferred list, find a system (other than the
    // local system that is up).
    //

    if ( bChooseMostPreferredNode )
    {
        first = FmpGetNonLocalPreferredNode( Group );

        //
        //  In this case in which you are doing a user-initiated move, give the randomized
        //  preferred list algorithm a chance to pick the node. Note that if the randomized
        //  algorithm could not pick a node, it will return the supplied suggested node itself.
        //
        if ( first != NULL )
        {
            first = FmpPickNodeFromPreferredListAtRandom ( Group, 
                                                           first,   // Suggested default
                                                           TRUE,    // Dont choose local node
                                                           TRUE );  // Check whether randomization 
                                                                    // should be disabled
        }
    }
    else
    {
        for ( listEntry = Group->PreferredOwners.Flink;
            listEntry != &(Group->PreferredOwners);
            listEntry = listEntry->Flink ) {

            preferredEntry = CONTAINING_RECORD( listEntry,
                                                PREFERRED_ENTRY,
                                                PreferredLinkage );

            if ( (preferredEntry->PreferredNode != NmLocalNode) &&
                (NmGetExtendedNodeState(preferredEntry->PreferredNode) == ClusterNodeUp) ) {
	        if (flag == TRUE)
	            return(preferredEntry->PreferredNode);
	        else if (first == NULL)
	            first = preferredEntry->PreferredNode;
            } else if (preferredEntry->PreferredNode == NmLocalNode) {
	            flag = TRUE;
	        }
        }
    }

    //if we couldnt find a node, we retry again since the user might have
    //expanded the possible node list for resource type since then
    //if the group preferred list is not set by the user,
    //we recalculate it since it could have 
    if (first == NULL)
    {
        LPWSTR          lpszOwners = NULL;
        DWORD           dwMaxSize=0;
        HDMKEY          hGroupKey;
        DWORD           dwSize = 0;
        DWORD           dwStatus;
        
        hGroupKey = DmOpenKey(DmGroupsKey, OmObjectId(Group),
                        KEY_READ);
        if (hGroupKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmInPreferredList: Couldnt open group key\r\n",
                dwStatus);
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        //the group preferred list must not be set by the user
        //if it is then there is no point in doing this recalculation
        dwStatus = DmQueryMultiSz( hGroupKey,
                             CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                             &lpszOwners,
                             &dwMaxSize,
                             &dwSize );
        if (lpszOwners) 
            LocalFree(lpszOwners);
        DmCloseKey(hGroupKey);            

    
        if (dwStatus == ERROR_FILE_NOT_FOUND)
            OmEnumObjects(ObjectTypeNode, FmpFindNodeThatMightBeAddedToPrefList,
                Group, &first);
    }
    
FnExit:        
    return(first);

} // FmpFindAnotherNode


PNM_NODE
FmpGetPreferredNode(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Find best node that can take the group

Arguments:

    Group - Pointer to the group object we're checking.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY         listEntry;
    PPREFERRED_ENTRY    preferredEntry;
    PNM_NODE            pNode = NULL;

    //
    //  First, let us give the anti-affinity algorithm a shot at picking the node.
    //
    pNode = FmpGetNodeNotHostingUndesiredGroups ( Group, 
                                                  FALSE,    // Don't rule out local node
                                                  TRUE );   // Choose preferred node if possible 

    if ( pNode != NULL )
    {
        return ( pNode );
    }

    //
    // For each entry in the Preferred list, find a system that is up.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );

        if (NmGetNodeState(preferredEntry->PreferredNode) == ClusterNodeUp ) {
            return(preferredEntry->PreferredNode);
        }
    }

    return(NULL);

} // FmpGetPreferredNode


PNM_NODE
FmpGetNonLocalPreferredNode(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Find best node that can take the group which is not the local node.

Arguments:

    Group - Pointer to the group object we're checking.

Return Value:

    Pointer to node object that the group can move to.

    NULL if another system is not found.

--*/

{
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    //
    // For each entry in the Preferred list, find a system (other than the
    // local system that is up).
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );

        if ( preferredEntry->PreferredNode == NmLocalNode ) {
            continue;
        }
        
        if (NmGetNodeState(preferredEntry->PreferredNode) == ClusterNodeUp ) {
            return(preferredEntry->PreferredNode);
        }
    }

    return(NULL);

} // FmpGetNonLocalPreferredNode

BOOL
FmpIsGroupQuiet(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE WantedState
    )

/*++

Routine Description:

    Checks if the group has any pending resources.

Arguments:

    Group - the Group to check.

    WantedState - the state the Group wants to get to.

Return Value:

    TRUE - if the Group is not doing anything now.

    FALSE otherwise.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;


    if ( Group->MovingList ) {
        return(FALSE);
    }

    //
    // Check all of the resources contained within this group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

        switch ( WantedState ) {
        case ClusterGroupOnline:
            // if resource is pending, then offline pending is bad
            if ( Resource->State == ClusterResourceOfflinePending ) {
                return(FALSE);
            }
            break;

        case ClusterGroupOffline:
            // if resource is pending, then online pending is bad
            if ( Resource->State == ClusterResourceOnlinePending ) {
                return(FALSE);
            }
            break;

        default:
            // any pending state is bad
            if ( Resource->State >= ClusterResourcePending ) {
                return(FALSE);
            }
            break;
        }
    }

    return(TRUE);

} // FmpIsGroupQuiet



VOID
FmpSetGroupPersistentState(
    IN PFM_GROUP Group,
    IN CLUSTER_GROUP_STATE State
    )

/*++

Routine Description:

    Sets the PersistentState of a Group. This includes the registry.

Arguments:

    Group - The Group to set the state for.
    State - The new state for the Group.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    The LocalGroupLock must be held.

--*/

{
    DWORD   persistentState;
    LPWSTR  persistentStateName = CLUSREG_NAME_GRP_PERSISTENT_STATE;

    if (!gbIsQuoResEnoughSpace)
        return;

    FmpAcquireLocalGroupLock( Group );

    //
    // If the current state has changed, then do the work. Otherwise,
    // skip the effort.
    //
    if ( Group->PersistentState != State ) {
        Group->PersistentState = State;
        CL_ASSERT( Group->RegistryKey != NULL );
        //
        // Set the new value, but only if it is online or offline.
        //
        if ( State == ClusterGroupOnline ) {
            persistentState = 1;
            DmSetValue( Group->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        } else if ( State == ClusterGroupOffline ) {
            persistentState = 0;
            DmSetValue( Group->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        }
    }

    FmpReleaseLocalGroupLock( Group );

} // FmpSetGroupPersistentState



DWORD
FmpOnlineGroup(
    IN PFM_GROUP Group,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    Bring the specified group online.  This means bringing all of the
    individual resources contained within the group online.  This is an
    atomic operation - so either all resources contained within the group
    are brought online, or none of them are.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

    ForceOnline - TRUE if all resources in the Group should be forced online.

Retruns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status, retstatus = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;
    BOOL            bPending = FALSE;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OnlineGroup for %1!ws! owner %2!ws!\n",
               OmObjectId(Group), OmObjectId(Group->OwnerNode));

    FmpAcquireLocalGroupLock( Group );

    //
    // Check if we are the owner... if not, return failure.
    //
    if ( gpQuoResource->Group != Group && 
	  ((Group->OwnerNode != NmLocalNode) ||
         !FmpInPreferredList( Group, Group->OwnerNode, TRUE, NULL) ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // Make sure the group is quiet
    //
    if ( !FmpIsGroupQuiet( Group, ClusterGroupOnline ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_INVALID_STATE);
    }


    //log an event saying we are trying on online a group
    FmpLogGroupInfoEvent1( FM_EVENT_GROUP_START_ONLINE, OmObjectName(Group));
    
    //if the quorum group is in this group bring it online first
    //This is called when a node goes down and its groups are
    //being reclaimed, the order in which the resoures are brought
    //online is important
    if ( gpQuoResource->Group == Group)
    {
        //SS:: if the quorum resource is in the group, it must be
        //brought online irrespective of the persistent state
        //so we will pass in true here
        //Apps can mess with persistent state via the common
        //properties and then cause havoc so we need to force the
        //quorum resource online despite that
        status = FmpDoOnlineResource( gpQuoResource,
                                      TRUE );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineGroup: Failed on resource %1!ws!. Status %2!u!\n",
                       OmObjectId(gpQuoResource),
                       status);
            CL_UNEXPECTED_ERROR(status);
        }


    }
    //
    // Bring online all of the resources contained within this group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        status = FmpDoOnlineResource( Resource,
                                      ForceOnline );

        if (status == ERROR_IO_PENDING) {
            bPending = TRUE;
        }

        if ( (status != ERROR_SUCCESS) &&
	     (status != ERROR_NODE_CANT_HOST_RESOURCE) &&
             (status != ERROR_IO_PENDING) ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineGroup: Failed on resource %1!ws!. Status %2!u!\n",
                       OmObjectId(Resource),
                       status);
            retstatus = status;
        }
    }

    //
    // Normally bringing the resources online propagates the group state,
    // but in order to get the state right for a group with no resources,
    // manually propagate the state here.
    //
    FmpPropagateGroupState(Group);

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OnlineGroup: setting group state to Online for %1!ws!\n",
               OmObjectId(Group));

    if (retstatus == ERROR_SUCCESS) {
        if (bPending) 
        {
            Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT; 
            retstatus = ERROR_IO_PENDING;
        }
        else
        {
            //log an event saying we are the onlinegroup request was completed
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_ONLINE, OmObjectName(Group));
        }
    }
    else
    {
        //log an event saying we are the onlinegroup request was completed
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(Group));
    }
    FmpReleaseLocalGroupLock( Group );


    return(retstatus);

} // FmpOnlineGroup



DWORD
FmpOfflineGroup(
    IN PFM_GROUP Group,
    IN BOOL OfflineQuorum,
    IN BOOL SetPersistent
    )

/*++

Routine Description:

    Bring the specified group offline.  This means bringing all of the
    individual resources contained within the group offline.

Arguments:

    Group - Supplies a pointer to the group structure to bring offline.

    OfflineQuorum - TRUE if any quorum resource in this group should
            be taken offline. FALSE if the quorum resource should be left online.

    SetPersistent - TRUE if the persistent state of each resource should be
            updated.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

--*/

{
    DWORD           status;
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE    Resource;
    DWORD           returnStatus = ERROR_SUCCESS;
    PRESOURCE_ENUM  ResourceEnum=NULL;
    DWORD           i;

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineGroup, Group=%1!ws!\n",
               OmObjectId(Group));

    //
    // Check if we are the owner... if not, return failure.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        returnStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto error_exit;
    }

    //
    // Make sure the group is quiet
    //
    if ( !FmpIsGroupQuiet( Group, ClusterGroupOffline ) ) {
        returnStatus = ERROR_INVALID_STATE;
        goto error_exit;
    }


    //
    // Get the list of resources in the group and their states.
    //
    returnStatus = FmpGetResourceList( &ResourceEnum, Group );
    if ( returnStatus != ERROR_SUCCESS ) {
        goto error_exit;
    }


    //log an event saying we are trying on offline a group
    FmpLogGroupInfoEvent1( FM_EVENT_GROUP_START_OFFLINE, OmObjectName(Group));

    // offline all resources except the quorum resource
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        Resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( Resource == NULL ) {
            returnStatus = ERROR_RESOURCE_NOT_FOUND;
            goto error_exit;
        }

        //quorum resource is brought offline last
        if (Resource->QuorumResource)
        {
            OmDereferenceObject(Resource);
            continue;
        }
        if (SetPersistent) {
            FmpSetResourcePersistentState( Resource, ClusterResourceOffline );
        }

        status = FmpOfflineResource( Resource, FALSE);

        OmDereferenceObject( Resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
             returnStatus = status;
            goto error_exit;
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }

    }

    // bring the quorum resource offline now, if asked to bring quorum offline
    // This allows other resources to come offline and save their checkpoints
    // The quorum resource offline should block till the resources have
    // finished saving the checkpoint
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        if (!OfflineQuorum)
        {
            //if the quorum resource should not be taken offline
            returnStatus = ERROR_QUORUM_RESOURCE;
        }
        else if (returnStatus == ERROR_SUCCESS)
        {
            CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);

            Resource = OmReferenceObjectById( ObjectTypeResource,
                    ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );

            if ( Resource == NULL ) {
                returnStatus = ERROR_RESOURCE_NOT_FOUND;
                goto error_exit;
            }

            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpOfflineGroup: Bring quorum resource offline\n");

            if ( !(Resource->Flags & RESOURCE_WAITING) ) {
                if (Resource->State != ClusterResourceOffline) {
                    Resource->State = ClusterResourceOnline; // [HACKHACK]
                }
                status = FmpOfflineResource( Resource , FALSE);

                OmDereferenceObject( Resource );

                if ( (status != ERROR_SUCCESS) &&
                     (status != ERROR_IO_PENDING) )
                {
                    returnStatus = status;
                    goto error_exit;
                }
                if ( status == ERROR_IO_PENDING )
                    returnStatus = ERROR_IO_PENDING;
            } else {
                OmDereferenceObject( Resource );
            }
        }
    }

    //
    // Normally bringing the resources offline propagates the group state,
    // but in order to get the state right for a group with no resources,
    // manually propagate the state here.
    //
    if (SetPersistent)
        FmpPropagateGroupState(Group);

error_exit:
    if (returnStatus == ERROR_SUCCESS)
    {
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_OFFLINE, OmObjectName(Group));
    }
    else if (returnStatus == ERROR_IO_PENDING)
    {
        Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT; 
    }
    else
    {
        //log an event saying that we failed to offline the group
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(Group));

    }
    
    FmpReleaseLocalGroupLock( Group );
    if (ResourceEnum)
            FmpDeleteResourceEnum( ResourceEnum );

    return(returnStatus);

} // FmpOfflineGroup



CLUSTER_GROUP_STATE
FmpGetGroupState(
    IN PFM_GROUP Group,
    IN BOOL      IsNormalized
    )

/*++

Routine Description:

    Get the Group state, either normalized to ClusterGroupOnline or
    ClusterGroupOffline or not normalized.

Arguments:

    Group - The Group we're interested in.

    IsNormalized - Should the Group state be normalized ?

Returns:

    The current Group state which is one of (in increasing order of
    precedence)

        ClusterGroupOnline, ClusterGroupOffline
        ClusterGroupPartialOnline 
        ClusterGroupPending (only if IsNormalized is FALSE)
        ClusterGroupFailed  (only if IsNormalized is FALSE)

--*/

{
    PLIST_ENTRY                 listEntry;
    PFM_RESOURCE                resource;
    CLUSTER_GROUP_STATE         state;
    CLUSTER_RESOURCE_STATE      firstResourceState;
    CLUSTER_RESOURCE_STATE      resourceState;

    // Chittur Subbaraman (chitturs) - 09/16/98 (Modified this function
    // to work with IsNormalized flag)

    FmpAcquireLocalGroupLock( Group );

    if ( !IsListEmpty(&Group->Contains) ) {
        listEntry = Group->Contains.Flink;
        resource = CONTAINING_RECORD(listEntry,
                         FM_RESOURCE,
                         ContainsLinkage);
        //
        // Get the first resource's state
        //
        firstResourceState = resource->State;

        if ( IsNormalized == FALSE ) {
            BOOL    IsPending = FALSE;
            BOOL    IsPartialOnline = FALSE;
            //
            // First check whether any resource in the group has
            // failed. If so, set the group state to ClusterGroupFailed
            // and exit immediately. If no resource in the group has
            // failed, but at least one of them is in the pending state,
            // then set the group state to ClusterGroupPending and exit
            // immediately. If no resource in the group is in either
            // the failed or in the pending state, then check whether 
            // some resources in the group are in online and some in the
            // offline state. Then, set the group state to 
            // ClusterGroupPartialOnline and exit immediately.
            //  
            for ( ;
                  listEntry != &(Group->Contains);
                  listEntry = listEntry->Flink ) {
                resource = CONTAINING_RECORD(listEntry,
                                     FM_RESOURCE,
                                     ContainsLinkage);

                resourceState = resource->State;

                if ( resourceState == ClusterResourceFailed ) {
                    state = ClusterGroupFailed;
                    //
                    // This state has the highest precedence, so
                    // exit immediately.
                    //
                    goto FnExit;
                } else if ( (resourceState == ClusterResourceOnlinePending) ||
                            (resourceState == ClusterResourceOfflinePending) ) {
                    IsPending = TRUE;
                } else {
                    CL_ASSERT( (resourceState == ClusterResourceOffline) ||
                       (resourceState == ClusterResourceOnline) ||
                       (resourceState == ClusterResourceInitializing) );
                    if ( resourceState == ClusterResourceInitializing ) {
                        //
                        // Normalize this state to offline state
                        //
                        resourceState = ClusterResourceOffline;
                    }
                    if ( firstResourceState == ClusterResourceInitializing ) {
                        //
                        // Normalize this state to offline state
                        //
                        firstResourceState = ClusterResourceOffline;
                    }
                    if ( firstResourceState != resourceState ) {
                        IsPartialOnline = TRUE;
                    }           
                }
            }   

            if ( IsPending == TRUE ) {
                state = ClusterGroupPending;
                //
                // This state has the next highest precedence after
                // ClusterGroupFailed state
                //
                goto FnExit;
            }
            if ( IsPartialOnline == TRUE ) {
                state = ClusterGroupPartialOnline;
                //
                // This state has the next highest precedence after
                // ClusterGroupFailed and ClusterGroupPending states
                //
                goto FnExit;
            }
            if ( firstResourceState == ClusterResourceOnline ) {
                state = ClusterGroupOnline;
                //
                // If the first resource is in an online state,
                // then the group state should be online.
                //
                goto FnExit;
            }
            if ( firstResourceState == ClusterResourceOffline ) {
                state = ClusterGroupOffline;
                //
                // If the first resource is in an offline state,
                // then the group state should be offline.
                //
                goto FnExit;
            }           
        }

        //
        // The control gets here only if IsNormalized is TRUE 
        //
        if ( (firstResourceState == ClusterResourceOnline) ||
             (firstResourceState == ClusterResourceOnlinePending) ) {
            state = ClusterGroupOnline;
            firstResourceState = ClusterResourceOnline;
        } else {
            CL_ASSERT( (firstResourceState == ClusterResourceOffline) ||
                       (firstResourceState == ClusterResourceFailed) ||
                       (firstResourceState == ClusterResourceOfflinePending) ||
                       (firstResourceState == ClusterResourceInitializing) );
            state = ClusterGroupOffline;
            firstResourceState = ClusterResourceOffline;
        }

        //
        // Now check each resource to see if they match the first.
        // 

        for (listEntry = Group->Contains.Flink;
              listEntry != &(Group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage);

            resourceState = resource->State;

            //
            // Normalize pending states to their final state, and Failed and Initializing
            // to Offline.
            //

            if ( resourceState == ClusterResourceOnlinePending ) {
                resourceState = ClusterResourceOnline;
            } else if ( (resourceState == ClusterResourceOfflinePending) ||
                        (resourceState == ClusterResourceFailed) ||
                        (resourceState == ClusterResourceInitializing) ) {
                resourceState = ClusterResourceOffline;
            }

            //
            // We only need 1 resource that is not the same as the first resource
            // to be in a partially online state.
            //
            if ( firstResourceState != resourceState ) {
                state = ClusterGroupPartialOnline;
                break;
            }
        }
    } else {
        //
        // The group is empty, so I guess it must be offline.
        //
        state = Group->PersistentState;
    }
    
FnExit:    
    FmpReleaseLocalGroupLock( Group );

    return(state);

} // FmpGetGroupState



DWORD
FmpPropagateGroupState(
    IN PFM_GROUP    Group
    )

/*++

Routine Description:

    Set and propagate the state of the group to other components on the
    local system and to other systems in the cluster.

Arguments:

    Group - The Group to propagate the state.

Return:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    We will use the first resource's state to determine what should be the
    state for the whole group. If all resources match the state of the first
    resource, then that is the state of the Group. If any resource disagrees
    with the first resource, then the state is PartialOnline.

--*/

{
    GUM_GROUP_STATE         groupState;
    LPCWSTR                 groupId;
    DWORD                   groupIdSize;
    DWORD                   status;
    PLIST_ENTRY             listEntry;
    CLUSTER_RESOURCE_STATE  firstResourceState;
    CLUSTER_GROUP_STATE     state;

    FmpAcquireLocalGroupLock( Group );

    //
    // If we no longer own the Group, then just return now.
    //
    // This can happen when a resource goes offline (via a terminate), but
    // the group ownership has already migrated to another system.
    // We will assume that returning success is okay in this case.
    //
    if ( Group->OwnerNode != NmLocalNode ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }

    //
    //  Chittur Subbaraman (chitturs) - 6/28/99
    //
    //  If the group is marked for deletion, then don't do anything.
    //
    if ( !IS_VALID_FM_GROUP( Group ) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }


    state = FmpGetGroupState( Group, TRUE );

    //
    // If the state has changed, then update the local system.
    //
    ++Group->StateSequence;
    if ( state != Group->State ) {

        Group->State = state;

        switch ( state ) {
        case ClusterGroupOnline:
        case ClusterGroupPartialOnline:
            ClusterEvent(CLUSTER_EVENT_GROUP_ONLINE, Group);
            break;

        case ClusterGroupOffline:
        case ClusterGroupFailed:
            ClusterEvent(CLUSTER_EVENT_GROUP_OFFLINE, Group);
            break;

        default:
            break;
        }

        //
        // Prepare to notify the other systems.
        //
        groupId = OmObjectId( Group );
        groupIdSize = (lstrlenW( groupId ) + 1) * sizeof(WCHAR);

        //
        // Set Group state
        //
        groupState.State = state;
        groupState.PersistentState = Group->PersistentState;
        groupState.StateSequence = Group->StateSequence;

        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateGroupState,
                                 3,
                                 groupIdSize,
                                 groupId,
                                 (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR),
                                 OmObjectId(NmLocalNode),
                                 sizeof(groupState),
                                 &groupState);

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateGroupState: Group %1!ws! state = %2!u!, persistent state = %3!u!\n",
                   OmObjectId(Group),
                   groupState.State,
                   groupState.PersistentState);

    } else {
        //
        // Assume that the state didn't change, but the owning node did.
        //
        //
        // Prepare to notify the other systems.
        //
        groupId = OmObjectId( Group );
        groupIdSize = (lstrlenW( groupId ) + 1) * sizeof(WCHAR);
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateGroupNode,
                                 2,
                                 groupIdSize,
                                 groupId,
                                 (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR),
                                 OmObjectId(NmLocalNode));
    }

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpPropagateGroupState



DWORD
FmpPropagateFailureCount(
    IN PFM_GROUP    Group,
    IN BOOL         NewTime
    )

/*++

Routine Description:

    Propagate NumberOfFailures for the group to other systems in the cluster.

Arguments:

    Group - The Group to propagate the state.

    NewTime - TRUE if last failure time should be reset also. FALSE otherwise.

Return:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    The Local Group lock must be held.

--*/

{
    PGUM_FAILURE_COUNT  failureCount;
    DWORD               failureCountSize;
    LPCWSTR             groupId;
    DWORD               status;

    //
    // Prepare to notify the other systems.
    //

    groupId = OmObjectId( Group );

    failureCountSize = sizeof(GUM_FAILURE_COUNT) - 1 +
                       ((lstrlenW(groupId) + 1) * sizeof(WCHAR));

    failureCount = LocalAlloc(LMEM_FIXED, failureCountSize);

    if ( failureCount == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    failureCount->Count = Group->NumberOfFailures;
    failureCount->NewTime = (DWORD)NewTime;
    wcscpy(&failureCount->GroupId[0], groupId);


    status = GumSendUpdate( GumUpdateFailoverManager,
                            FmUpdateFailureCount,
                            failureCountSize,
                            failureCount );

    LocalFree( failureCount );

    return(status);

} // FmpPropagateFailureCount



PFM_GROUP
FmpCreateGroup(
    IN  LPWSTR         GroupId,
    IN  BOOL           Initialize
    )

/*++

Routine Description:

    Creates a new Group object.

Arguments:

    GroupId - The Id of the new Group.

    Initialize - TRUE if the Group should be initialized, FALSE otherwise.

Returns:

    A non-NULL pointer to the Group if successful.
    NULL - The Group could not be created.

Notes:

    1) Passing Initialize as FALSE allows for creating the group and it
    resources, but complete initialization can happen later.

    2) The Group List lock must be held.

    3) If the Group is created, the reference count on the object is 1. If
    the group is not create (i.e., it already exists) then the reference count
    is not incremented and the caller may add a reference as needed.

--*/

{
    PFM_GROUP       group = NULL;
    DWORD           status = ERROR_SUCCESS;
    BOOL            Created;


    //
    // Open an existing group or create a new one.
    //

    group = OmCreateObject( ObjectTypeGroup,
                            GroupId,
                            NULL,
                            &Created);
    if (group == NULL) {
        return(NULL);
    }

    if (!Created) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Opened existing group %1!ws!\n",
                   GroupId);
        //this is the quorum group being recreated again,
        if ((!FmpFMOnline) && (group->RegistryKey == NULL))
        {
            status = FmpInitializeGroup(group, Initialize);
        }
        OmDereferenceObject( group );
        goto FnExit;
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] Creating group %1!ws!\n",
               GroupId);


        group->State = ClusterGroupOffline;
        InitializeCriticalSection( &group->Lock );
        group->dwStructState = FM_GROUP_STRUCT_CREATED;

        //
        // Insert the group into its list.
        //
        status = FmpInitializeGroup( group , Initialize);

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }

        //
        // Insert the group into its list.
        //
        status = OmInsertObject( group );

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }


    }

FnExit:
    if (status != ERROR_SUCCESS)
    {
        FmpAcquireLocalGroupLock( group );

        FmpDestroyGroup( group, FALSE );

        SetLastError(status);
        group = NULL;
    }
    return(group);

} // FmpCreateGroup


DWORD FmpInitializeGroup(
    IN PFM_GROUP Group,
    IN BOOL Initialize
    )
{

    DWORD   status;

    //
    // Initialize the Group
    //
    InitializeListHead( &(Group->Contains) );
    InitializeListHead( &(Group->PreferredOwners) );
    InitializeListHead( &(Group->DmRundownList) );
    InitializeListHead( &(Group->WaitQueue) );
    Group->MovingList = NULL;

    //
    // Read the registry information if directed to do so.
    //
    status = FmpQueryGroupInfo( Group, Initialize );
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpInitializeGroup: FmpQueryGroupInfo failed, status=%1!u!\n",
           status);

    }

    return(status);
}





DWORD
FmpDestroyGroup(
    IN PFM_GROUP  Group,
    IN BOOL       bDeleteObjOnly
    )
/*++

Routine Description:

    Closes a group.

    First, this routine verifies that all resources contained within
    the Group are closed.

    If the group is online, it is brought offline.

    Note that the group object itself is not dereferenced here. This is
    done so that FmpCleanupGroups can simply enumerate all the groups,
    destroying each one in turn. This approach means a group may be
    destroyed multiple times if there are outstanding references to it, but
    that is not a problem since no work will be done on subsequent calls.

    IF bDeleteObjOnly is TRUE, then the resource monitor is not invoked and
    group state is not touched.

Arguments:

    FoundGroup - Returns the found group.

    Group - Supplies the current group.

    Name - Supplies the current group's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching group is returned in
        *FoundGroup

Notes:

    The LocalGroupLock MUST be held! This routine will release that lock
    as part of cleanup.

--*/
{
    PLIST_ENTRY   listEntry;
    PFM_RESOURCE  Resource;
    PPREFERRED_ENTRY preferredEntry;
    DWORD         status = ERROR_SUCCESS;



    ClRtlLogPrint(LOG_NOISE,
               "[FM] DestroyGroup: destroying %1!ws!\n",
               OmObjectId(Group));



    //
    // Make sure there are no resources in the Group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
           ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        listEntry = listEntry->Flink;
        RemoveEntryList( &Resource->ContainsLinkage );
        //dereference for removing from the contains list
        OmDereferenceObject( Resource );
        FmpAcquireLocalResourceLock( Resource );
        if (!bDeleteObjOnly)
            Resource->QuorumResource = FALSE;
        FmpDestroyResource( Resource, bDeleteObjOnly );
        //the reference count on the group wrt to being
        //referenced by the resource is handled in FmpDestroyResource
    }

    CL_ASSERT(IsListEmpty(&Group->Contains));

    //
    //
    // Make sure the preferred owners list is drained.
    //
    while ( !IsListEmpty( &Group->PreferredOwners ) ) {
        listEntry = RemoveHeadList(&Group->PreferredOwners);
        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        OmDereferenceObject( preferredEntry->PreferredNode );
        LocalFree( preferredEntry );
    }

    //
    // Now that there are no remaining resources in this group
    // we're done, so remove it from it's object type list.
    //

    status = OmRemoveObject( Group );


    //
    // Close the Group's registry key.
    //
    DmRundownList( &Group->DmRundownList );
    if ( Group->RegistryKey != NULL ) {
        DmCloseKey( Group->RegistryKey );
        Group->RegistryKey = NULL;
        Group->Initialized = FALSE;
    }


    //
    // We must release the lock prior to the dereference, in case this is
    // the last dereference of the object!
    //
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDestroyGroup: Group %1!ws! destroyed.\n",
               OmObjectId(Group));

    OmDereferenceObject( Group );

    return(status);
} // FmpDestroyGroup




///////////////////////////////////////////////////////////////////////////
//
// Initialization/Cleanup Routines
//
///////////////////////////////////////////////////////////////////////////

DWORD
FmpInitGroups(
    IN BOOL Initialize
    )
/*++

Routine Description:

    Processes the Cluster group list in the registry. For each
    group key found, a cluster group is created.

Arguments:

    Initialize - TRUE if resources should be initialized. FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD          status;
    DWORD          keyIndex = 0;
    LPWSTR         groupId = NULL;
    DWORD          groupIdMaxSize = 0;
    PFM_GROUP      ignored;


    ClRtlLogPrint(LOG_NOISE,"[FM] Processing groups list.\n");

    FmpAcquireGroupLock();

    //
    // Enumerate the subkeys. Each subkey name corresponds to a group name.
    //

    for (keyIndex = 0; ; keyIndex++) {
        status = FmpRegEnumerateKey( DmGroupsKey,
                                     keyIndex,
                                     &groupId,
                                     &groupIdMaxSize
                                    );

        if (status == NO_ERROR) {
            ignored = FmpCreateGroup( groupId,
                                      Initialize );
            continue;
        }

        if (status == ERROR_NO_MORE_ITEMS) {
            status = NO_ERROR;
        } else {
            ClRtlLogPrint(LOG_NOISE,"[FM] EnumGroup error %1!u!\n", status);
        }

        break;
    }

    FmpReleaseGroupLock();

    ClRtlLogPrint(LOG_NOISE,"[FM] All groups created.\n");

    if (groupId != NULL) {
        LocalFree(groupId);
    }

    return(status);

} // FmpInitGroups



DWORD
FmpCompleteInitGroup(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Finish initialization of all resources within the group.

Arguments:

    Group - The group to finish initializing.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PLIST_ENTRY     listEntry;
    PFM_RESOURCE Resource;

    FmpAcquireLocalGroupLock(Group);

    //
    // For each resource in the Group, make sure that it has been fully
    // initialized.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {

        Resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);
        FmpInitializeResource( Resource, TRUE );

    }

    FmpReleaseLocalGroupLock(Group);

    return(ERROR_SUCCESS);

} // FmpCompleteInitGroup


DWORD
FmpCleanupGroupsWorker(
    IN PFM_CLEANUP_INFO pFmCleanupInfo
    )
/*++

Routine Description:

    This routine walks through an enumerated list of  all the groups
    owned by the local node and tries to shut them down cleanly.

    In the first phase it tries to bring
    all resources offline except the quorum one.

    In the second phase it waits for the group to reach stable state
    and then move it.  It tries to bring the quorum resource offline as
    well by moving the quorum group.

Arguments:

    pFmCleanupInfo - ptr to a strucuture containing the groups to be
    offlined/moved and the timelimit in which to do so.

Returns:

    None.

Assumptions:


--*/
{


    DWORD       Status = ERROR_SUCCESS;
    DWORD       i;
    PFM_GROUP   pGroup;
    PGROUP_ENUM pGroupEnum;
    BOOL        bContainsQuorumGroup;
    BOOL        bQuorumGroup = FALSE;
    DWORD       CleanupStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsWorker: Entry\r\n");


    //
    // This is done in two passes. In the first pass, we offline/move all
    // resources except the quorum resource. In the second pass, we offline/move
    // everything and then destroy the group. This allows resources that are
    // being shutdown to write to the registry and have the updates logged to
    // the quorum disk.
    //

    pGroupEnum = pFmCleanupInfo->pGroupEnum;
    bContainsQuorumGroup = pFmCleanupInfo->bContainsQuorumGroup;


    // Now offline all of the non-quorum resources...
    // but don't wait for them to finish. I.E. get as much work done as
    // possible as fast as possible.
    //
    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                               pGroupEnum->Entry[i].Id );

        //try and offline all resources except the quorum
         //resource
        Status = FmpCleanupGroupPhase1(pGroup, pFmCleanupInfo->dwTimeOut);

        if ((Status != ERROR_IO_PENDING) && (Status != ERROR_SUCCESS) &&
            (Status != ERROR_QUORUM_RESOURCE))
            CleanupStatus = Status;
        OmDereferenceObject(pGroup);
    }

    //this finishes the second phase of the cleanup on shutdown
    //if the quorum group is in this list, skip it and process it
    //at the end
    if (CleanupStatus == ERROR_SUCCESS)
    {
        for ( i = 0; i < pGroupEnum->EntryCount; i++ )
        {
            pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                   pGroupEnum->Entry[i].Id );

            if (gpQuoResource->Group == pGroup)
            {

                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpCleanupGroupsWorker: Quorum group belongs to this node, process phase 2 later\r\n");
                bQuorumGroup = TRUE;
                OmDereferenceObject(pGroup);
                continue;
            }

            //try and offline all groups, including the quorum resource
            //also try and move the resource to other nodes
            Status = FmpCleanupGroupPhase2(pGroup);

            OmDereferenceObject(pGroup);
        }
        if (bQuorumGroup)
            Status = FmpCleanupGroupPhase2(gpQuoResource->Group);

    }
    else
    {
        //phase 1 didnt work for some reason
        //try and offline the quorum resource alone.
        //TODO::Should we also terminate all resources
        // No way to terminate services ???
        if (bContainsQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);


    }
    return(Status);

} // FmpCleanupGroupsWorker



DWORD
FmpCleanupGroupPhase1(
    IN PFM_GROUP Group,
    IN DWORD     dwTimeOut
    )
/*++

Routine Description:

    This routine is the first phase for clean up all groups owned by the node
    on shutdown.

    In this phase, we try and bring all resources offline except the quorum
    resource.  In this phase we dont block for the resources to reach a stable
    state

    We give the group the shutdown timeout specified for the cluster
    to reach a stable state before we try to offline it. If it doesnt
    reach a stable state in this period then we shut it down abruptly.


Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD Status = ERROR_SUCCESS;
    DWORD dwRetryCount = (2 * dwTimeOut)/1000;//we check after every 1/2 sec

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase1: Entry, Group = %1!ws!\r\n",
        OmObjectId(Group));

ChkGroupState:
    FmpAcquireLocalGroupLock( Group );

    //
    // Just offline the group
    //
    if ( Group->OwnerNode == NmLocalNode )
    {
        //
        // Make sure the group is quiet
        //
        if ( !FmpIsGroupQuiet( Group, ClusterGroupOffline ) )
        {
            FmpReleaseLocalGroupLock( Group );
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCleanupGroupsPhase1: Group is not quiet, wait\r\n");
            //we give it a minute to recover totally
            Sleep(500);
            if (dwRetryCount--)
                goto ChkGroupState;
            else
            {
                Status = ERROR_REQUEST_ABORTED;
                goto FnExit;
            }

        }

        //
        // Notify the group's resources that the cluster service is shutting down. This must be
        // done BEFORE any of the resources are brought offline.
        //
        FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonShutdown );
        
        //
        // Just take the group offline. Don't wait, don't pass go...
        //
        // Dont take the quorum resource offline in phase 1
        // The quorum resource must be the last one to be taken offline
        Status = FmpOfflineGroup(Group, FALSE, FALSE);
    }

    FmpReleaseLocalGroupLock( Group );
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase1: Exit, status=%1!u!\r\n",
        Status);

    return(Status);

} // FmpCleanupGroupsPhase1



DWORD
FmpCleanupGroupPhase2(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    This routine is the second phase for clean up all groups owned by the node
    on shutdown.

    In this phase, we try and bring all resources offline including the quorum
    resource.  We also try to move the quorum resource

    We give the group 10 seconds to reach a stable state before we try to
    move it.

Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwRetryCount= 120 * 12;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase2: Entry, Group = %1!ws!\r\n",
        OmObjectId(Group));

    FmpAcquireLocalGroupLock( Group );

    //
    // Try to move the Group before destroying it if we own it.
    //
    if ( Group->OwnerNode == NmLocalNode )
    {
        //
        // First make sure the group is really offline.
        // In phase 1 we began the offline process... we need to check it here.
        //
WaitSomeMore:

        //
        // [GorN] [10/05/1999]
        // We need to wait for the quorum to go offline, otherwise
        // the surviving node will not be able to arbitrate.
        //
        // FmpWaitForGroup keeps issuing RmOffline for the quorum,
        // resrcmon returns ERROR_INVALID_STATE, for the second offline,
        // since offline is already in progress.
        //
        // This causes us to break out of this look while the quorum resource
        // is still being offline.
        //
        // [HACKHACK] The following fix for the problem is a hack.
        // It would be better either to make resmon return IO_PENDING when
        // somebody is trying to offline the resource that is in offline pending
        //
        // Or not to call FmRmOffline the second time in FM.
        //

        Status = FmpOfflineGroup(Group, TRUE, FALSE);
        if (Status == ERROR_IO_PENDING ||
            (Status == ERROR_INVALID_STATE 
          && Group == gpQuoResource->Group) )
        {
            //FmpWaitForGroup() will release the lock
            Status = FmpWaitForGroup(Group);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCleanupGroupsPhase2: Sleep and retry\r\n");
            Sleep(2*1000);
            //Reacquire the group lock and check if the group is offline
            FmpAcquireLocalGroupLock(Group);
            if (dwRetryCount--)
                goto WaitSomeMore;

        }
        else if (Status != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        else
        {
            // The Move routine frees the LocalGroupLock!
            FmpMoveGroup( Group, NULL, TRUE, NULL, TRUE );
            FmpAcquireLocalGroupLock( Group );
        }
    }
FnExit:
    FmpReleaseLocalGroupLock(Group);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroupsPhase2: Exit\n");

    return(TRUE);

} // FmpCleanupGroupsPhase2



BOOL
FmpEnumNodeState(
    OUT DWORD *pStatus,
    IN PVOID Context2,
    IN PNM_NODE Node,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback for FM shutdown. Queries the state
    of other nodes to see if any are up.

Arguments:

    pStatus - Returns TRUE if other node is up.

    Context2 - Not used

    Node - Supplies the node.

    Name - Supplies the node's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    DWORD Status;
    DWORD NodeId;
    PGROUP_ENUM NodeGroups = NULL;
    PRESOURCE_ENUM NodeResources = NULL;
    DWORD i;
    PFM_GROUP Group;
    PFM_RESOURCE Resource;

    if (Node == NmLocalNode) {
        return(TRUE);
    }

    //
    // Enumerate all other node's group states. This includes all nodes
    // that are up, as well as nodes that are paused.
    //
    if ((NmGetNodeState(Node) == ClusterNodeUp) ||
        (NmGetNodeState(Node) == ClusterNodePaused)){
        *pStatus = TRUE;
        return(FALSE);
    }

    return(TRUE);

} // FmpEnumNodeState



VOID
FmpCleanupGroups(
    IN BOOL ClusterShutDownEvent
    )
/*++

Routine Description:

    This routine kicks off the cleanup of the FM layer.

Arguments:

    None.

Returns:

    None.

--*/
{
    DWORD           Status;
    DWORD           dwTimeOut;
    DWORD           dwDefaultTimeOut;
    HANDLE          hCleanupThread;
    DWORD           otherNodesUp = FALSE;
    DWORD           dwThreadId;
    DWORD           i,dwTimeOutCount;
    PGROUP_ENUM     pGroupEnum;
    BOOL            bQuorumGroup = FALSE;
    PFM_CLEANUP_INFO pFmCleanupInfo;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroups: Entry\r\n");

    //
    // If we don't know the quorum resource or we are not online,
    // then leave immediately
    //
    if ( !gpQuoResource )  {
        goto FnExit;
    }

    ACQUIRE_EXCLUSIVE_LOCK(gQuoChangeLock);
    //if this is called when fmformphaseprocessing is going on
    //then the quorum group doesnt exist, other groups dont exist
    //either
    if (FmpFMFormPhaseProcessing)
            FmpCleanupQuorumResource(gpQuoResource);
    else
        CL_ASSERT(gpQuoResource->Group != NULL)
    RELEASE_LOCK(gQuoChangeLock);


    //
    // Find and sort all known groups, hold the group lock while enumerating
    //
    FmpAcquireGroupLock();

    Status = FmpEnumSortGroups(&pGroupEnum, OmObjectId(NmLocalNode), &bQuorumGroup);

    FmpReleaseGroupLock();

    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }


    //
    // See if any other node in the cluster is up...
    // If so, we will use the default timeout value.
    // Otherwise, we will use what we believe is a more reasonable time.
    //
    OmEnumObjects( ObjectTypeNode,
                   FmpEnumNodeState,
                   &otherNodesUp,
                   NULL );

    dwDefaultTimeOut = CLUSTER_SHUTDOWN_TIMEOUT * 60; // default timeout (secs)

    switch ( CsShutdownRequest ) {
    case CsShutdownTypeShutdown:
        if ( otherNodesUp ) {
            dwTimeOut = 15;   // other node will time us out quickly - say 15 secs
        } else {
            dwTimeOut = 30;  // otherwise use 30 seconds
        }
        break;

    default:
        // apply default value to registry
        dwDefaultTimeOut = CLUSTER_SHUTDOWN_TIMEOUT; // default timeout (mins)
        Status = DmQueryDword( DmClusterParametersKey,
                               CLUSREG_NAME_CLUS_SHUTDOWN_TIMEOUT,
                               &dwTimeOut,
                               &dwDefaultTimeOut);
        dwTimeOut *= 60;         // convert to secs.
        break;
    }

    //convert to msecs
    dwTimeOut *= 1000;

    pFmCleanupInfo = (PFM_CLEANUP_INFO)LocalAlloc(LMEM_FIXED, sizeof(FM_CLEANUP_INFO));
    if (!pFmCleanupInfo)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;

    }

    pFmCleanupInfo->pGroupEnum = pGroupEnum;
    pFmCleanupInfo->dwTimeOut = dwTimeOut; //in msecs
    pFmCleanupInfo->bContainsQuorumGroup = bQuorumGroup;

    //
    // Start the worker thread to perform cleanup.
    //
    hCleanupThread = CreateThread( NULL,
                                   0,
                                   FmpCleanupGroupsWorker,
                                   pFmCleanupInfo,
                                   0,
                                   &dwThreadId );

    if ( hCleanupThread == NULL ) {
        //SS: if we own the quorum resource should we cleanup the quorum resource
        //this will avoid corruption
        if (bQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);
        goto FnExit;
    }

    // Rohit (rjain): This path is taken when Cluster Service is shutting 
    // down. ServiceStatus checkpoint is incremented after every WaitHint
    // units of time. For this the waiting period of dwTimeOut is divided into
    // multiple waiting periods of dwWaitHint units each.
    
    
    if((ClusterShutDownEvent==TRUE) && (dwTimeOut > CsServiceStatus.dwWaitHint))
    {
        dwTimeOutCount=dwTimeOut/((CsServiceStatus.dwWaitHint == 0)?1:CsServiceStatus.dwWaitHint);
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpCleanupGroups: dwTimeOut=%1!u! dwTimoutCount=%2!u! waithint =%3!u! \r\n",
                dwTimeOut,dwTimeOutCount, CsServiceStatus.dwWaitHint);
 
        for(i=0;i<dwTimeOutCount;i++){
            Status = WaitForSingleObject(hCleanupThread, CsServiceStatus.dwWaitHint);
            switch(Status) {
                case WAIT_OBJECT_0:
                    //everything is fine
                    ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpCleanupGroups: Cleanup thread finished in time\r\n");
                    break;

                case WAIT_TIMEOUT:
                    //should we terminate the thread
                    //try and clean up the quorum resource
                    //this will avoid corruption on the quorum disk
                    //TODO::Should we also terminate all resources
                    // No way to terminate services ???
                    if(i == (dwTimeOutCount-1)){
                        ClRtlLogPrint(LOG_UNUSUAL,
                                "[FM] FmpCleanupGroups: Timed out on the CleanupThread\r\n");
                        if (bQuorumGroup)
                            FmpCleanupQuorumResource(gpQuoResource);
                    }
                    break;
                case WAIT_FAILED:
                    ClRtlLogPrint(LOG_UNUSUAL,
                            "[DM] FmpCleanupGroups: wait on CleanupEvent failed 0x%1!08lx!\r\n",
                            GetLastError());
                    break;
            }
            if(Status== WAIT_OBJECT_0 || Status==WAIT_FAILED)
                break;
            CsServiceStatus.dwCheckPoint++;
            CsAnnounceServiceStatus();
        }
        goto FnExit;
    }

    //
    // Wait for the thread to complete or a timeout.
    //
    Status = WaitForSingleObject(hCleanupThread, dwTimeOut);

    switch(Status) {
    case WAIT_OBJECT_0:
        //everything is fine
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpCleanupGroups: Cleanup thread finished in time\r\n");
        break;

    case WAIT_TIMEOUT:
        //should we terminate the thread
        //try and clean up the quorum resource
        //this will avoid corruption on the quorum disk
        //TODO::Should we also terminate all resources
        // No way to terminate services ???
        ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpCleanupGroups: Timed out on the CleanupThread\r\n");
        if (bQuorumGroup)
            FmpCleanupQuorumResource(gpQuoResource);
        break;

    case WAIT_FAILED:
        ClRtlLogPrint(LOG_UNUSUAL,
                "[DM] FmpCleanupGroups: wait on CleanupEvent failed 0x%1!08lx!\r\n",
                GetLastError());
        break;
    }

FnExit:
    //SS: dont bother cleaning up, we are going to exit after this
#if 0
    if (pGroupEnum) LocalFree(GroupEnum);
#endif

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCleanupGroups: Exit\r\n");

    return;

} // FmpCleanupGroups



DWORD
FmpCleanupQuorumResource(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    This routine is for emergency clean up of the quorum resource.

    In this phase, we dont try and acquire any locks.  We just try to
    bring the quorum resource offline.  Hopefully the api is offline and
    nothing funky is attempted on the quorum group/resource during this
    time.  This should only be called during the shutdown of FM.


Arguments:

    Group - The Group to offline.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/
{
    DWORD       status = ERROR_SUCCESS;
    DWORD       state;


    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpCleanupQuorum: Offline resource <%1!ws!> <%2!ws!>\n",
               OmObjectName(Resource),
               OmObjectId(Resource) );

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't, then we will return because the pre-initialized
    // state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        FmpRmTerminateResource( Resource );
        return(ERROR_SUCCESS);
    }


    if (Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpCleanupQuorum: Offline resource <%1!ws!> is in pending state\n",
                   OmObjectName(Resource) );
        FmpRmTerminateResource( Resource );
        return(ERROR_SUCCESS);
    }

    //make sure the quorum logs can be flushed and closed
    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);

    //it may not be prudent to call offline without holding any locks
    //just call terminate
    FmpRmTerminateResource( Resource );


    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpCleanupQuorum: RmOfflineResource returns %1!u!\r\n",
               status);

    return(status);
}


DWORD
FmpMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL,
    IN BOOL ShutdownHandler,
    OUT PNM_NODE *pChosenDestinationNode OPTIONAL,
    IN  BOOL bChooseMostPreferredNode
    )

/*++

Routine Description:

    Move the specified Group.  This means taking all of the individual
    resources contained within the group offline and requesting the
    DestinationNode to bring the Group Online.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to 'highest' entry in the preferred list.

    ShutdownHandler - TRUE if the shutdown handler is invoking this function.

    pChosenDestinationNode - Set to the destination node of the move and
        will be passed on to FmpCompleteMoveGroup, if necessary.

    bChooseMostPreferredNode - If the destination node is not supplied,
        indicates whether to choose the most preferred node or not.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the Group and all contained resources are offline
    from the requesting node when this call returns.  The Group may or
    may not be online on the DestinationNode, depending on whether the
    online request succeeded.  This means that the status return is merely
    the status return for the Online request for the DestinationNode.

    The LocalGroupLock MUST also be held. The LocalGroupLock is released
    by this routine.

--*/
{
    PNM_NODE                node, pQuorumTargetNode = NULL;
    DWORD                   status;
    PFM_RESOURCE            resource;
    PLIST_ENTRY             listEntry;
    PRESOURCE_ENUM          resourceList=NULL;
    DWORD                   dwMoveStatus = ERROR_SUCCESS;
    BOOL                    fMoveUserInitiated;
    BOOL                    fStateChangeReasonNotified;
    
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMoveGroup: Entry\r\n");

    //
    //  Move is user initiated if it doesn't originate from the shutdown handler and it doesn't
    //  originate from the failover move call FmpDoMoveGroupOnFailure.
    //
    fMoveUserInitiated = ( ( ShutdownHandler == FALSE ) &&
                           ( bChooseMostPreferredNode == TRUE ) );
    //
    //  If this move is not user-initiated, then we should NOT have notified the state change reason,
    //  else we definitely should have.
    //
    fStateChangeReasonNotified = ( fMoveUserInitiated == TRUE ) ? FALSE:TRUE;

    if ( !ShutdownHandler ) 
    {
        if ( !FmpFMOnline ) 
        {
            status = ERROR_CLUSTER_NODE_NOT_READY;
            goto FnExit;
        }

        if ( FmpShutdown ) 
        {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            goto FnExit;
        }
    }

    //
    // See which system owns the group in order to control the move request.
    //
    if ( Group->OwnerNode != NmLocalNode ) 
    {
        if ( Group->OwnerNode == NULL ) 
        {
            status = ERROR_HOST_NODE_NOT_AVAILABLE;
            goto FnExit;
        }
        //
        // The other system owns the Group ... let them do the work.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpMoveGroup: Request node %1!ws! to move Group %2!ws!\n",
                   OmObjectId(Group->OwnerNode),
                   OmObjectId(Group));
        // FmcMoveGroupRequest must release the Group lock.
        status = FmcMoveGroupRequest( Group,
                                      DestinationNode );
        if ( status != ERROR_SUCCESS ) 
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: Requested system %1!ws! to move group %2!ws! failed with status %3!u!.\n",
                       OmObjectId(Group->OwnerNode),
                       OmObjectId(Group),
                       status);
        }
        FmpAcquireLocalGroupLock( Group );
        goto FnExit;
    } 
    else 
    {
        //
        // We control the move.
        //
        if ( !FmpIsGroupQuiet(Group, ClusterGroupStateUnknown) ) 
        {
            //
            // If a move is pending or resources are pending,
            // then return now.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: Request to move group <%1!ws!> when it is busy.\n",
                       OmObjectName(Group) );
            status = ERROR_INVALID_STATE;
            goto FnExit;
        }

        if ( ARGUMENT_PRESENT( DestinationNode ) ) 
        {
            //
            // Check if we are the destination... if so, we're done.
            //
            if ( NmLocalNode == DestinationNode ) 
            {
                status = ERROR_SUCCESS;
                goto FnExit;
            }
            node = DestinationNode;
        } 
        else 
        {
            node = FmpFindAnotherNode( Group, bChooseMostPreferredNode );
            if ( node == NULL ) 
            {
                status = ERROR_HOST_NODE_NOT_AVAILABLE;
                goto FnExit;
            }

        }

        if ( ARGUMENT_PRESENT ( pChosenDestinationNode ) )
        {
            *pChosenDestinationNode = node;
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpMoveGroup: Moving group %1!ws! to node %2!ws! (%3!d!)\n",
                   OmObjectId(Group),
                   OmObjectId(node),
                   NmGetNodeId(node));

        //
        // If the other system is not up, then fail now.
        //
        if ( NmGetExtendedNodeState(node) != ClusterNodeUp ) 
        {
            status = ERROR_HOST_NODE_NOT_AVAILABLE;
            goto FnExit;
        }

        //
        // If the other system is not in the preferred list, then fail this
        // now.
        //
        if ( !FmpInPreferredList( Group, node, TRUE, NULL) ) 
        {
            status = ERROR_CLUSTER_NODE_NOT_FOUND;
            goto FnExit;
        }

        //
        // Get the list of resources in the group and their states.
        //
        status = FmpGetResourceList( &resourceList, Group );
        if ( status != ERROR_SUCCESS ) 
        {
            goto FnExit;
        }

        Group->MovingList = resourceList;

        //SS: log an eventlog to say we are going to offline the group
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_START_OFFLINE, OmObjectName(Group));
        Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;

        //
        //  If this call is made as a part of a user-initiated move, then notify the group's
        //  resources of the impending move. Mark the state change reason flag so that you will 
        //  notify of a failed move correctly.
        //
        if ( fMoveUserInitiated )
        {
            FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonMove );
            fStateChangeReasonNotified = TRUE;
        }
            
        //
        // At this point the other system should be up!
        //
        status = FmpOfflineResourceList( resourceList, TRUE );

        //SS: avoid the window when the group lock is released
        //and the moving flag is not set true
        //moving will be continued in another thread context if pending is
        //returned

        if ( status != ERROR_SUCCESS ) 
        {
            goto FnRestore;
        }


        //SS:the group is offline, log an eventlog to mark the completion
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_OFFLINE, OmObjectName(Group));
        //unmask the bit so that we dont log an error again on some other failure
        //after this point in time
        Group->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
       
        // for now make sure that the group state is propagated here
        // In general it is propagated by the worker thread. Since
        // the ownership is going to change, we want to make sure that the
        // last known state is propagated from this node to others before
        // that.
        FmpPropagateGroupState(Group);
       
        //
        // Assume the other node is going to take ownership. This is done
        // before, in case the Group state changes. We want to accept the
        // Group/resource state changes from the remote system when they
        // arrive. We've already verified that node is in the preferred list!
        //

        TESTPT(TpFailPreMoveWithNodeDown) 
        {
            ClusterEvent( CLUSTER_EVENT_NODE_DOWN, node );
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/18/99
        //
        //  Modified to handle the move group request of a quorum group in 
        //  case the destination node could not arbitrate for the quorum
        //  resource.
        //
        do
        {
            //
            // Before making the RPC, set the intended owner of the group
            //
            FmpSetIntendedOwnerForGroup( Group, NmGetNodeId( node ) );

            try {
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpMoveGroup: Take group %2!ws! request to remote node %1!ws!\n",
                            OmObjectId(node),
                            OmObjectId(Group));

                dwMoveStatus = status = FmcTakeGroupRequest( node, OmObjectId( Group ), resourceList );                                 
            } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                LPCWSTR     pszNodeId;
                LPCWSTR     pszGroupId;

                status = GetExceptionCode ();
                
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpMoveGroup: Exception in FmcTakeGroupRequest %2!ws! request to remote node %1!ws!, status=%3!u!\n",
                    OmObjectId(node),
                    OmObjectId(Group),
                    status);

                //
                // An exception from RPC indicates that the other node is either dead
                // or insane. We dont know whether it took ownership or not.
                // So, let the FM node down handler handle the group.
                //
                GumCommFailure( GumUpdateFailoverManager,
                                NmGetNodeId(node),
                                GetExceptionCode(),
                                TRUE );
                //
                // The new owner node that is now dead might have set the intended
                // owner as NULL or it might not have set this. It might have 
                // set the owner node to himself or might not have.
                // If it has set the owner node for this group as himself, then
                // the FM node down handler will assume responsibility for this
                // group. If the target node dies before it sets himself as the owner,
                // then again, the FM node down handler will assume responsibility
                // for the group. We wake up when the gum sync handling is over.
                // Right now, the gum update for the owner node may still be in
                // progress so we cant be sure if that update was completed on
                // all nodes.
                //

                //
                //  Chittur Subbaraman (chitturs) - 6/7/99
                //
                //  Issue a GUM update to handle this group. Using this
                //  GUM update prevents any race condition with the
                //  node down processing code. 
                //
                //  TODO: This does not cover the case in which 
                //  FmpTakeGroupRequest crashes after setting the
                //  intended owner to invalid ID. In such a case, 
                //  the following handler won't take ownership of the
                //  group. Also, claim handler will not touch the
                //  group.
                //
                pszNodeId = OmObjectId( node );
                pszGroupId = OmObjectId( Group );
    
                GumSendUpdateEx( GumUpdateFailoverManager,
                                 FmUpdateCompleteGroupMove,
                                 2,
                                 (lstrlenW(pszNodeId)+1)*sizeof(WCHAR),
                                 pszNodeId,
                                 (lstrlenW(pszGroupId)+1)*sizeof(WCHAR),
                                 pszGroupId);

                status = ERROR_HOST_NODE_NOT_AVAILABLE;
                FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );
                goto FnExit;
            }

            //
            //  If this group is the quorum group, map the error to retry in case the remote node is
            //  not ready. This will let this node retry the group move request.
            //
            if ( ( Group == gpQuoResource->Group ) &&
                  ( ( status == ERROR_CLUSTER_NODE_SHUTTING_DOWN ) ||
                  ( status == ERROR_CLUSTER_NODE_NOT_READY ) ) )
            {
                status = ERROR_RETRY;
                //
                //  Give a chance for the remote node to startup or shutdown. Don't murder
                //  the same remote node with RPCs.
                //
                Sleep ( 3000 );
            }
                
            if ( status == ERROR_RETRY )
            {
                //
                //  The destination refused to take the quorum group since it
                //  did not win the arbitration. So let us see who won the
                //  arbitration.
                //
                DWORD  dwSelectedQuorumOwnerId;

                CL_ASSERT( Group == gpQuoResource->Group ); 

                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpMoveGroup: Remote node asked us to resend take group request for group %1!ws! to another node ...\n",
                           OmObjectId( Group ));

                //
                //  Get the ID of the node which the MM believes is the best
                //  candidate to own the quorum resource. This is a call that
                //  blocks while RGP is in progress.
                //
                MMApproxArbitrationWinner( &dwSelectedQuorumOwnerId );

                if ( ( dwSelectedQuorumOwnerId == NmGetNodeId( NmLocalNode ) )  ||
                     ( dwSelectedQuorumOwnerId == MM_INVALID_NODE ) )
                {
                    //
                    //  The local node is chosen by MM or no node is chosen by
                    //  the MM. The latter case will happen if no RGP has
                    //  occurred at the time this call is made. Let us see if we 
                    //  can arbitrate for the quorum resource.
                    //
                    status = FmpRmArbitrateResource( gpQuoResource );
         
                    if ( status != ERROR_SUCCESS ) 
                    {
                        //
                        //  Too bad. We will halt and let FmpNodeDown handler
                        //  handle the quorum group.
                        //
                        ClRtlLogPrint(LOG_CRITICAL,
                                "[FM] FmpMoveGroup: Local node %1!u! cannot arbitrate for quorum, Status = %1!u!...\n",
                                dwSelectedQuorumOwnerId,
                                status);
                        CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                    }
                    status = ERROR_RETRY;
                    break;
                } 

                FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );

                pQuorumTargetNode = node = NmReferenceNodeById( dwSelectedQuorumOwnerId );

                if ( node == NULL )
                {
                    ClRtlLogPrint(LOG_CRITICAL,
                                "[FM] FmpMoveGroup: Selected node %1!u! cannot be referenced...\n",
                                dwSelectedQuorumOwnerId);
                    CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                } 
            } // if
        } while ( status == ERROR_RETRY );

        FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );
    
        TESTPT(TpFailPostMoveWithNodeDown)
        {
            ClusterEvent( CLUSTER_EVENT_NODE_DOWN, node );
        }
        

        CL_ASSERT( status != ERROR_IO_PENDING );
        if ( status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpMoveGroup: FmcTakeGroupRequest to node %1!ws! to take group %2!ws! failed, status %3!u!.\n",
                       OmObjectId(node),
                       OmObjectId(Group),
                       status );
            goto FnRestore;                       
        }


        //
        // If the group is empty, then generate a Group state change event.
        //
        if ( IsListEmpty( &Group->Contains ) ) 
        {
            ClusterWideEvent( CLUSTER_EVENT_GROUP_OFFLINE,
                              Group );
        }
    }
    
FnRestore:
    if ((status != ERROR_SUCCESS) && (status != ERROR_IO_PENDING))
    {
        //
        //
        //  Notify the group's resources that this is a failed move. Note that this should be
        //  done BEFORE any future onlines. Also, mark the fStateChangeReasonNotified to be FALSE
        //  so that we won't drop the failed move reason down below also.
        //
        FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonFailedMove );
        fStateChangeReasonNotified = FALSE;

        if (Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT)
        {
            //SS: log an event saying we failed the last offline request
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(Group));
            //unmask the bit so that we dont log a non-corresponding event again
            Group->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;            
        }
        //
        //  Chittur Subbaraman (chitturs) - 3/22/2000
        //
        //  Reset the group's intended owner to invalid node ID if the
        //  node down handler did not do that.
        //
        if ( dwMoveStatus != ERROR_SUCCESS )
        {
            if ( FmpSetIntendedOwnerForGroup( Group, ClusterInvalidNodeId )
                  == ERROR_CLUSTER_INVALID_NODE )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpMoveGroup: Group <%1!ws!> has already been processed by node down handler....\r\n",
                    OmObjectName(Group));
                goto FnExit;
            }
        }
       
        // the move failed
        // In all failure cases we want to bring the resources
        // back online
        // if it is pending, then we let FmpCompleteMoveGroup finish
        // the work
        if (resourceList)
        {
            //
            // Terminate all of the resources in the group.
            //
            FmpTerminateResourceList( resourceList );

            //
            //  Chittur Subbaraman (chitturs) - 4/10/2000
            //
            //  Make sure to online the quorum group even if this node is
            //  shutting down. This is necessary so that other groups
            //  can be brought offline during this node's shutdown. Note
            //  that FmpOnlineResourceList would only online a group
            //  during a shutdown if the group is the quorum group.
            //
            if ( FmpFMGroupsInited )
                FmpOnlineResourceList( resourceList, Group );
        }

    }

FnExit:
    ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpMoveGroup: Exit group <%1!ws!>, status = %2!u!\r\n",
            OmObjectName(Group),
            status);

    if ( status != ERROR_IO_PENDING ) 
    {
        if (resourceList) 
        {
            FmpDeleteResourceEnum( resourceList );
            Group->MovingList = NULL;
        }
    }
    else
    {
        //if the state is pending mark for completion event
        Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
    }

    if ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) )
    {
        //
        //  Chittur Subbaraman (chitturs) - 4/13/99
        //
        //  If the FmpDoMoveGroupOnFailure thread is also waiting to do the
        //  move, then tell that thread to take its hands off.
        //
        if ( Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL )
        {
            Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE;
        }
    } else if ( fStateChangeReasonNotified == TRUE )
    {
        //
        //
        //  Notify the group's resources that this is a failed move.
        //
        FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonFailedMove );
    }

    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpMoveGroup



DWORD
FmpCompleteMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode
    )

/*++

Routine Description:

    This completes the move of a group by asking the other node to take
    ownership.
    This function is called by FmpMovePendingThread() after all the resources
    are offline.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to 'highest' entry in the preferred list.

Returns:

    ERROR_SUCCESS if the request was successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the Group and all contained resources are offline
    when this is called.

    The LocalGroupLock MUST also be held. The LocalGroupLock is released
    by this routine, especially before requesting a remote system to move
    a group!

--*/

{
    PNM_NODE                node, pQuorumTargetNode = NULL;
    DWORD                   status = ERROR_SUCCESS;
    PFM_RESOURCE            resource;
    PLIST_ENTRY             listEntry;
    PRESOURCE_ENUM          resourceList=NULL;
    DWORD                   dwMoveStatus = ERROR_SUCCESS;
    BOOL                    fStateChangeReasonNotified = TRUE; // In this function == reason notified already

    resourceList = Group->MovingList;

    if ( resourceList == NULL ) {
        ClRtlLogPrint( LOG_NOISE,
                    "[FM] FmpCompleteMoveGroup: No moving list!\n" );
        status = ERROR_SUCCESS;
        goto FnRestore;
    }

    node = DestinationNode;

    CL_ASSERT( node != NULL );
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpCompleteMoveGroup: Completing the move for group %1!ws! to node %2!ws! (%3!d!)\n",
               OmObjectName(Group),
               OmObjectId(node),
               NmGetNodeId(node));


    status = FmpOfflineResourceList( resourceList, TRUE );

    if ( status != ERROR_SUCCESS )  {
        //by now the group must be offline!
        //if not, mail the move, the resource that fails to go
        //offline will force the other resources to come online
        //again.
        //how do we handle shutdowns
        goto FnRestore;
    }

    // for now make sure that the group state is propagated here
    // In general it is propagated by the worker thread. Since
    // the ownership is going to change, we want to make sure that the
    // last known state is propagated from this node to others before
    // that.
    FmpPropagateGroupState(Group);

    //
    // Chittur Subbaraman (chitturs) - 10/01/1999
    //
    // If the other system is not up, then fail now. Note that this
    // check must be done only AFTER ensuring that the group state
    // is stable. Otherwise some funny corner cases can result.
    // E.g., If the complete move operation is aborted when one or
    // more resources are in offline pending state since the destination
    // node went down, then you first terminate the resource list and
    // then online the list. As a part of all this, the online pending
    // or the online states of the resources could be propagated
    // synchronously. Now, the offline notification from the previous
    // offline attempt could come in and be processed by the FM worker
    // thread way too late and you could have spurious resource states
    // in FM while the real resource state is different. Another
    // issue here is during the lengthy offline operation here, the
    // destination node could go down and come back up soon after and
    // so aborting the move may not be prudent in such a case.
    //
    // But, don't do this optimization for the quorum group. This is
    // because once the quorum group is made offline, then MM
    // could decide who the group owner is. So, you may not be able to
    // bring the group online necessarily in this node. To avoid such
    // a case, we let FmcTakeGroupRequest fail and then let either the
    // retry loop here move the group somewhere else or let the
    // FM node down handler decide on the group's owner consulting
    // with MM.
    //
    if ( ( NmGetExtendedNodeState(node) != ClusterNodeUp ) &&
         ( Group != gpQuoResource->Group ) )  
    {
        status = ERROR_HOST_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpCompleteMoveGroup: Restoring group <%1!ws!> on local node due to destination node unavailability...\n",
                      OmObjectName(Group));
        goto FnRestore;
    }

    // SS::
    // After this point the responsibility of failing the group
    // back due to resource failures is with the destination code.
    // If there is a failure to bring the resources online,
    // the local restart policy on the destination node must kick
    // in.
    //
    // if there is an rpc failure to communicate with the other node
    // I suppose we should bring the resources online here again
    // However, rpc failures can be pretty non descriptive - there is
    // no way to determine from rpc errors if the rpc call actually
    // executed on the remote side
    //
    // but unless we are pretty careful about this and do what gum does
    // on rpc failures(banish the destination node) there is no way to
    // guarantee that both nodes dont retry to restart the group

    // If the destination node begins the process of bringing resources
    // in the group online, FmsTakeGroupRequest must return success(note
    // it should not return ERROR_IO_PENDING), else
    // it returns an error code and this node will bring the group back
    // to its previous state.

    // Assume the other node is going to take ownership. This is done
    // before, in case the Group state changes. We want to accept the
    // Group/resource state changes from the remote system when they
    // arrive. We've already verified that node is in the preferred list!
    //
    //we will reacquire the lock after making the rpc call

    // SS::
    // After this point the responsibility of failing the group
    // back due to resource failures is with the destination code.
    // If there is a failure to bring the resources online,
    // the local restart policy on the destination node must kick
    // in.
    //
    // if there is an rpc failure to communicate with the other node
    // I suppose we should bring the resources online here again
    // However, rpc failures can be pretty non descriptive - there is
    // no way to determine from rpc errors if the rpc call actually
    // executed on the remote side
    //
    // but unless we are pretty careful about this and do what gum does
    // on rpc failures(banish the destination node) there is no way to
    // guarantee that both nodes dont retry to restart the group

    // If the destination node begins the process of bringing resources
    // in the group online, FmsTakeGroupRequest must return success(note
    // it should not return ERROR_IO_PENDING), else
    // it returns an error code and this node will bring the group back
    // to its previous state.

    // Assume the other node is going to take ownership. This is done
    // before, in case the Group state changes. We want to accept the
    // Group/resource state changes from the remote system when they
    // arrive. We've already verified that node is in the preferred list!
    //

    //
    //  Chittur Subbaraman (chitturs) - 5/18/99
    //
    //  Modified to handle the move group request of a quorum group in 
    //  case the destination node could not arbitrate for the quorum
    //  resource.
    //
    do
    {
        //
        // Before making the RPC, set the intended owner of the group
        //
        FmpSetIntendedOwnerForGroup( Group, NmGetNodeId( node ) );

        try {
            ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpCompleteMoveGroup: Take group %2!ws! request to remote node %1!ws!\n",
                        OmObjectId(node),
                        OmObjectId(Group));

            dwMoveStatus = status = FmcTakeGroupRequest( node, OmObjectId( Group ), resourceList );
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            LPCWSTR     pszNodeId;
            LPCWSTR     pszGroupId;

            status = GetExceptionCode ();

            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpCompleteMoveGroup: Exception in FmcTakeGroupRequest %2!ws! request to remote node %1!ws!, status=%3!u!\n",
                OmObjectId(node),
                OmObjectId(Group),
                status);

            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. We dont know whether it took ownership or not.
            // So, let the FM node down handler handle the group.
            //
            GumCommFailure( GumUpdateFailoverManager,
                            NmGetNodeId(node),
                            GetExceptionCode(),
                            TRUE );
            //
            // The new owner node that is now dead might have set the intended
            // owner as NULL or it might not have set this. It might have 
            // set the owner node to himself or might not have.
            // If it has set the owner node for this group as himself, then
            // the FM node down handler will assume responsibility for this
            // group. If the target node dies before it sets himself as the owner,
            // then again, the FM node down handler will assume responsibility
            // for the group. We wake up when the gum sync handling is over.
            // Right now, the gum update for the owner node may still be in
            // progress so we cant be sure if that update was completed on
            // all nodes.
            //

            //
            //  Chittur Subbaraman (chitturs) - 6/7/99
            //
            //  Issue a GUM update to handle this group. Using this
            //  GUM update prevents any race condition with the
            //  node down processing code.
            //

            //
            //  TODO: This does not cover the case in which 
            //  FmpTakeGroupRequest crashes after setting the
            //  intended owner to invalid ID. In such a case, 
            //  the following handler won't take ownership of the
            //  group. Also, claim handler will not touch the
            //  group.
            //
            pszNodeId = OmObjectId( node );
            pszGroupId = OmObjectId( Group );
            
            GumSendUpdateEx( GumUpdateFailoverManager,
                             FmUpdateCompleteGroupMove,
                             2,
                             (lstrlenW(pszNodeId)+1)*sizeof(WCHAR),
                             pszNodeId,
                             (lstrlenW(pszGroupId)+1)*sizeof(WCHAR),
                             pszGroupId);
                             
            status = ERROR_HOST_NODE_NOT_AVAILABLE;                     
            FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );
            goto FnExit;
        }

        //
        //  If this group is the quorum group, map the error to retry in case the remote node is
        //  not ready. This will let this node retry the group move request.
        //
        if ( ( Group == gpQuoResource->Group ) &&
              ( ( status == ERROR_CLUSTER_NODE_SHUTTING_DOWN ) ||
              ( status == ERROR_CLUSTER_NODE_NOT_READY ) ) )
        {
            status = ERROR_RETRY;
            //
            //  Give a chance for the remote node to startup or shutdown. Don't murder
            //  the same remote node with RPCs.
            //
            Sleep ( 3000 );
        }

        if ( status == ERROR_RETRY )
        {
            //
            //  The destination refused to take the quorum group since it
            //  did not win the arbitration. So let us see who won the
            //  arbitration.
            //
            DWORD  dwSelectedQuorumOwnerId;

            CL_ASSERT( Group == gpQuoResource->Group ); 

            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpCompleteMoveGroup: Remote node asked us to resend take group request for group %1!ws! to another node ...\n",
                       OmObjectId( Group ));

            //
            //  Get the ID of the node which the MM believes is the best
            //  candidate to own the quorum resource. This is a call that
            //  blocks while RGP is in progress.
            //
            MMApproxArbitrationWinner( &dwSelectedQuorumOwnerId );

            if ( ( dwSelectedQuorumOwnerId == NmGetNodeId( NmLocalNode ) ) ||
                 ( dwSelectedQuorumOwnerId == MM_INVALID_NODE ) )
            {
                //
                //  The local node is chosen by MM or no node is chosen by
                //  the MM. The latter case will happen if no RGP has
                //  occurred at the time this call is made. Let us see if we 
                //  can arbitrate for the quorum resource.
                //
                status = FmpRmArbitrateResource( gpQuoResource );
         
                if ( status != ERROR_SUCCESS ) 
                {
                    //
                    //  Too bad. We will halt and let FmpNodeDown handler
                    //  handle the quorum group.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                              "[FM] FmpCompleteMoveGroup: Local node %1!u! cannot arbitrate for quorum group %3!ws!, Status = %2!u!...\n",
                               dwSelectedQuorumOwnerId,
                               status,
                               OmObjectId( Group ));
                    CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
                }
                status = ERROR_RETRY;
                break;
            } 

            FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );
                           
            pQuorumTargetNode = node = NmReferenceNodeById( dwSelectedQuorumOwnerId );

            if ( node == NULL )
            {
                ClRtlLogPrint(LOG_CRITICAL,
                            "[FM] FmpCompleteMoveGroup: Selected node %1!u! cannot be referenced...\n",
                            dwSelectedQuorumOwnerId);
                CsInconsistencyHalt( ERROR_QUORUM_RESOURCE_ONLINE_FAILED );  
            }           
        } // if
    } while ( status == ERROR_RETRY );

    FM_DEREF_QUORUM_TARGET ( pQuorumTargetNode );
        
    // At this point, the onus of taking care of the group is with the
    // destination node whether it means restarting the group or
    // failing it back

FnRestore:
    //if there is any failure try and restore the previous states
    if ((status != ERROR_IO_PENDING) && (status != ERROR_SUCCESS))
    {
        //
        //
        //  Notify the group's resources that this is a failed move. Note that this should be
        //  done BEFORE any future onlines. Also, mark the fStateChangeReasonNotified to be FALSE
        //  so that we won't drop the failed move reason down below also.
        //
        FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonFailedMove );
        fStateChangeReasonNotified = FALSE;

        //
        //  Chittur Subbaraman (chitturs) - 3/22/2000
        //
        //  Reset the group's intended owner to invalid node ID if the
        //  node down handler did not do that.
        //
        if ( dwMoveStatus != ERROR_SUCCESS )
        {
            if ( FmpSetIntendedOwnerForGroup( Group, ClusterInvalidNodeId )
                  == ERROR_CLUSTER_INVALID_NODE )
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpCompleteMoveGroup: Group <%1!ws!> has already been processed by node down handler....\r\n",
                    OmObjectName(Group));
                goto FnExit;
            }
        }
      
        if (resourceList)
        {           
            FmpTerminateResourceList( resourceList );
            //
            //  Chittur Subbaraman (chitturs) - 4/10/2000
            //
            //  Make sure to online the quorum group even if this node is
            //  shutting down. This is necessary so that other groups
            //  can be brought offline during this node's shutdown. Note
            //  that FmpOnlineResourceList would only online a group
            //  during a shutdown if the group is the quorum group.
            //
            if ( FmpFMGroupsInited )
                FmpOnlineResourceList( resourceList, Group );
        }
    } else
    {
        //
        //  Chittur Subbaraman (chitturs) - 4/19/99
        //
        //  If the FmpDoMoveGroupOnFailure thread is also waiting to do the
        //  move, then tell that thread to take its hands off.
        //
        if ( Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL )
        {
            Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE;
        }
    }
    
FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCompleteMoveGroup: Exit, status = %1!u!\r\n",
            status);

    //if the status is success or some other error, clean up the resource list
    if (status != ERROR_IO_PENDING)
    {
        if ( ( status != ERROR_SUCCESS ) && ( fStateChangeReasonNotified == TRUE ) )
        {
            //
            //
            //  Notify the group's resources that this is a failed move.
            //
            FmpNotifyGroupStateChangeReason( Group, eResourceStateChangeReasonFailedMove );
        }
        if (resourceList)
        {
            FmpDeleteResourceEnum( resourceList );
            Group->MovingList = NULL;
        }

    }
    FmpReleaseLocalGroupLock( Group );

    return(status);

} // FmpCompleteMoveGroup



DWORD
FmpMovePendingThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Continue trying to move a group if ERROR_IO_PENDING is returned.
    We need to perform this operation, because part way through a move
    request, we could get a pending return status. The processing of the
    request is halted and the pending status is returned. However, the
    remainder of the move operation needs to be performed.

Arguments:

    Context - Pointer to the MOVE_GROUP structure to move.

Returns:

    ERROR_SUCCESS.

--*/

{
    PMOVE_GROUP moveGroup = (PMOVE_GROUP)Context;
    PFM_GROUP group;
    PNM_NODE node;
    DWORD   status;
    DWORD   loopCount = 100;   // Only try this so many times and then give up
    HANDLE  waitArray[2];

    group = moveGroup->Group;
    node = moveGroup->DestinationNode;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMovePendingThread Entry.\n");

    //
    // We must attempt to finish the move request for this Group.
    //
    // We are waiting for a resource to go offline and it finally goes
    // offline and the Group's pending event is set.
    //
    // Or we are waiting for cluster shutdown (FmpShutdownEvent)
    //
WaitSomeMore:
    //acquire the lock since fmpwaitforgroup() releases it
    FmpAcquireLocalGroupLock( group );
    status = FmpWaitForGroup(group);
    if (status == ERROR_SHUTDOWN_IN_PROGRESS) {
        //
        // We've been asked to shutdown
        //

    } else if (status == ERROR_SUCCESS) {
        //acquire the group lock before calling FmpCompleteMoveGroup
        FmpAcquireLocalGroupLock( group );
        status = FmpCompleteMoveGroup( group, node );
        if ( status == ERROR_IO_PENDING ) {
            Sleep(500); // [HACKHACK] kludgy, I know, but nice solution might break something else
            goto WaitSomeMore;
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmpMovePendingThread got error %1!d! waiting for group to shutdown.\n",
                   status);
    }
    //
    // We're done with the move now.
    //
    if ( status != ERROR_IO_PENDING ) {
        CL_ASSERT( group->MovingList == NULL );
    }

    //
    // Now dereference the Group and node object (if non-NULL) and
    // free our local context.
    //
    OmDereferenceObject( group );
    if ( node != NULL ) {
        OmDereferenceObject( node );
    }
    LocalFree( Context );

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpMovePendingThread Exit.\n");

    return(ERROR_SUCCESS);
} // FmpMovePendingThread



DWORD
FmpCreateMovePendingThread(
    IN PFM_GROUP Group,
    IN PNM_NODE  DestinationNode
    )

/*++

Routine Description:

    Crate a thread that will continue to call the move routine for a given
    Group.

Arguments:

    Group - A pointer to the Group to move.

    DestinationNode - The destination node for the move request.

Returns:

    ERROR_IO_PENDING if the thread was created successfully. This assumes
        that this routine was called because of this error return.

    A Win32 error code on failure.

--*/
{
    HANDLE          threadHandle=NULL;
    DWORD           threadId;
    PMOVE_GROUP     context=NULL;
    DWORD           status=ERROR_IO_PENDING;    //assume success

    FmpAcquireLocalGroupLock( Group );

    if ( Group->OwnerNode != NmLocalNode ) {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    }
    //
    // If there is a pending event, then the group is not available for any
    // new requests.
    //
    if ( FmpIsGroupPending(Group) ) {
        status = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    context = LocalAlloc(LMEM_FIXED, sizeof(MOVE_GROUP));
    if ( context == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Keep reference on the Group and node object (if present) while we
    // retain pointers.
    //
    OmReferenceObject( Group );
    if ( DestinationNode != NULL ) {
        OmReferenceObject( DestinationNode );
    }

    //
    // Fill in context fields
    //
    context->Group = Group;
    context->DestinationNode = DestinationNode;

    threadHandle = CreateThread( NULL,
                                 0,
                                 FmpMovePendingThread,
                                 context,
                                 0,
                                 &threadId );

    if ( threadHandle == NULL )
    {
        OmDereferenceObject( Group );
        if ( DestinationNode != NULL ) {
            OmDereferenceObject( DestinationNode );
        }
        status = GetLastError();
        LocalFree(context);
        goto FnExit;
    }


FnExit:
    if (threadHandle) CloseHandle( threadHandle );
    FmpReleaseLocalGroupLock( Group );
    return(status);

} // FmpCreateMovePendingThread



DWORD
FmpDoMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode,
    IN BOOL bChooseMostPreferredNode
    )

/*++

Routine Description:

    This routine performs the action of moving a Group. This requires taking
    a Group offline and then bringing the Group online. The Offline and
    Online requests may pend, so we have to pick up the work in order to
    complete the request. This means handling the offline pending case, since
    the online pending request will eventually complete.

Arguments:

    Group - The Group to move.

    DestinationNode - The destination node for the move request.

    bChooseMostPreferredNode - If the destination node is not supplied,
        indicates whether to choose the most preferred node or not.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    PNM_NODE    node;
    PNM_NODE    ChosenDestinationNode = NULL;

    //
    // We can only support one request on this Group at a time.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroup: Entry\r\n");

    FmpAcquireLocalGroupLock( Group );

    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        FmpReleaseLocalGroupLock( Group);
        return (ERROR_GROUP_NOT_AVAILABLE);
    }

    if ( FmpIsGroupPending(Group) ) {
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_GROUP_NOT_AVAILABLE);
    }

    node = Group->OwnerNode;
    // Note: the local group lock is released by the FmpMoveGroup routine.
    status = FmpMoveGroup( Group, DestinationNode, FALSE, &ChosenDestinationNode, bChooseMostPreferredNode );

    //
    // If we were the owner of the group and the request is pending, then
    // start a thread to complete the move request.
    //
    if ( (node == NmLocalNode) &&
         (status == ERROR_IO_PENDING) ) {
        status = FmpCreateMovePendingThread( Group, ChosenDestinationNode );
    }

    //
    //  Chittur Subbaraman (chitturs) - 7/31/2000
    //
    //  Log an event to the eventlog if the group is moving due to a failure.
    //
    if ( ( bChooseMostPreferredNode == FALSE ) &&
         ( ( status == ERROR_SUCCESS ) || ( status == ERROR_IO_PENDING ) ) )
    {
        CsLogEvent3( LOG_NOISE,
                     FM_EVENT_GROUP_FAILOVER,
                     OmObjectName(Group),
                     OmObjectName(NmLocalNode), 
                     OmObjectName(ChosenDestinationNode) );
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroup: Exit, status = %1!u!\r\n",
        status);
    return(status);

} // FmpDoMoveGroup



DWORD
FmpTakeGroupRequest(
    IN PFM_GROUP Group,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    Performs a Take Group Request from (THE) remote system and returns
    status for that request.

Arguments:

    Group - The Group to take online locally.
    ResourceList - The list of resources and their states.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    DWORD   status = ERROR_SUCCESS;
   
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpTakeGroupRequest: To take group '%1!ws!'.\n",
               OmObjectId(Group) );

    FmpAcquireLocalGroupLock( Group );

    if ( !FmpFMOnline ) 
    {
        if (FmpShutdown)
            status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
        else
            status = ERROR_CLUSTER_NODE_NOT_READY;
        CL_LOGFAILURE(status);

        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpTakeGroupRequest: Group '%1!ws!' cannot be accepted, status=%2!u!...\n",
                    OmObjectId(Group),
                    status);       
        goto FnExit;            
    }


    //every body should be able to host the quorum group
    //so we dont check the prefferred owner list for this group
    if ( ( gpQuoResource->Group != Group) && 
        !FmpInPreferredList( Group, NmLocalNode, FALSE, NULL) ) 
    {

        //
        // Nobody should ever ask us to take a group that can't run here.
        //
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        CL_LOGFAILURE( status);
        goto FnExit;
    }

    //
    // Take ownership of the Group.
    //
    if ( Group->OwnerNode == NmLocalNode ) {
        //SS:://We are alreay the owner ?? How did this happen
        status = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 5/18/99
    //
    //  Handle quorum group in a special way. Make sure you can arbitrate
    //  for the quorum resource. If not, you could get killed when you
    //  try to bring it online and you fail.
    //
    if ( Group == gpQuoResource->Group )
    {      
        //call FmpArbitrateResource() instead of FmpRmArbitrateResource() in order to give
        //the chance to initialize incase move is called immediately after an install of a
        //third party quorum resource dll
        status = FmpArbitrateResource( gpQuoResource );

        if ( status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpTakeGroupRequest: MM did not select local node %1!u! as the arbitration winner, Status %2!u!\n",
                      NmLocalNodeId,
                      status);
            status = ERROR_RETRY;
            goto FnExit;
        }
    }

    status = FmpSetOwnerForGroup( Group, NmLocalNode );

    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpTakeGroupRequest: Set owner GUM update returns %1!u! for group <%2!ws!>...\n\r",
                      status,
                      OmObjectId(Group)); 
        if ( status == ERROR_GROUP_NOT_AVAILABLE )
        {
            //
            // If the node down processing GUM handler has claimed ownership
            // of this group, consider everything as being fine.
            //
            status = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    FmpSetIntendedOwnerForGroup(Group, ClusterInvalidNodeId);

    // prepare to bring this group online
    FmpPrepareGroupForOnline( Group );

    //
    // Online what needs to be online.
    //
    //  SS: Note that we ignore the error from FmpOnlineResourceList
    //  This is because at this point the onus of taking care of the group
    //  is with us.
    //
    FmpOnlineResourceList( ResourceList, Group );

FnExit:
    FmpReleaseLocalGroupLock( Group );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpTakeGroupRequest: Exit for group <%1!ws!>, Status = %2!u!...\n",
               OmObjectId(Group),
               status);

    return(status);

} // FmpTakeGroupRequest


DWORD
FmpUpdateChangeGroupName(
    IN BOOL SourceNode,
    IN LPCWSTR GroupId,
    IN LPCWSTR NewName
    )
/*++

Routine Description:

    GUM dispatch routine for changing the friendly name of a group.

Arguments:

    SourceNode - Supplies whether or not this node initiated the GUM update.
        Not used.

    ResourceId - Supplies the group ID.

    NewName - Supplies the new friendly name.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PFM_GROUP Group;
    DWORD Status;

    //
    // Chittur Subbaraman (chitturs) - 4/19/98
    //
    // If FM groups are not initialized or FM is shutting down, don't
    // do anything.
    //
    if ( !FmpFMGroupsInited ||
         FmpShutdown ) {
        return(ERROR_SUCCESS);
    }

    Group = OmReferenceObjectById(ObjectTypeGroup, GroupId);
    if (Group == NULL) {
        return(ERROR_GROUP_NOT_FOUND);
    }

    Status = OmSetObjectName( Group, NewName);
    if (Status == ERROR_SUCCESS) {
        ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group);
    }
    OmDereferenceObject(Group);

    return(Status);

} // FmpUpdateChangeGroupName



BOOL
FmpEnumGroupNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Group enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the group object

    Name - Supplies the object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_GROUP Group = (PFM_GROUP)Object;
    PNM_NODE Node = (PNM_NODE)Context1;
    PLIST_ENTRY      listEntry;
    PPREFERRED_ENTRY preferredEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] EnumGroupNodeEvict: Removing references to node %1!ws! from group %2!ws!\n",
               OmObjectId(Node),
               OmObjectId(Group));

    FmpAcquireLocalGroupLock(Group);

    //
    // Walk the list of preferred owners. If this node is in the list, remove it.
    //

    for ( listEntry = Group->PreferredOwners.Flink;
          listEntry != &(Group->PreferredOwners);
          listEntry = listEntry->Flink ) {

        preferredEntry = CONTAINING_RECORD( listEntry,
                                            PREFERRED_ENTRY,
                                            PreferredLinkage );
        if ( preferredEntry->PreferredNode == Node ) {
            RemoveEntryList(&preferredEntry->PreferredLinkage);
            OmDereferenceObject(preferredEntry->PreferredNode);
            LocalFree(preferredEntry);
            break;
        }
    }

    FmpReleaseLocalGroupLock(Group);
    ClusterEvent(CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group);

    return(TRUE);

} // FmpEnumGroupNodeEvict

VOID FmpCheckForGroupCompletionEvent(
    IN PFM_GROUP pGroup)
{
    CLUSTER_GROUP_STATE GroupState;
    
    //check the struct state to see if an event log needs to be logged
    if (pGroup->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT)
    {
        //find the state of the group and log it
        GroupState = FmpGetGroupState(pGroup, FALSE);
        switch(GroupState)
        {
            case ClusterGroupOnline:
                FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_ONLINE, OmObjectName(pGroup));
                //reset the state
                pGroup->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
                break;
                
            case ClusterGroupOffline:
                FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_OFFLINE, OmObjectName(pGroup));
                //reset the state
                pGroup->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
                break;

            case ClusterGroupPartialOnline:
                //SS: treat partial online as failing to bring a group completely online
                FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(pGroup));
                //reset the state
                pGroup->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
                break;
                
            case ClusterGroupFailed:
                FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(pGroup));
                //reset the state
                pGroup->dwStructState &= ~FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT;
                break;
            
            case ClusterGroupPending:
                //it is not time to log an event as yet
                //wait for another signal to log the event and reset the bit
                break;
                
            default: 
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpCheckForGroupCompletionEvent: The state %1!u! for Group %2!ws! is unexpected\r\n",
                    GroupState, OmObjectId(pGroup));
                CL_ASSERT(FALSE);
                
        }
    }
}

VOID
FmpSignalGroupWaiters(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Wakes up any threads waiting for this group to achieve a
    stable state.

Arguments:

    Group - Supplies the group.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PFM_WAIT_BLOCK WaitBlock;

    FmpAcquireLocalGroupLock( Group );

    while (!IsListEmpty(&Group->WaitQueue)) {
        ListEntry = RemoveHeadList(&Group->WaitQueue);
        WaitBlock = CONTAINING_RECORD(ListEntry,
                                      FM_WAIT_BLOCK,
                                      ListEntry);
        WaitBlock->Status = ERROR_SUCCESS;
        SetEvent(WaitBlock->hEvent);
    }

    FmpReleaseLocalGroupLock( Group );
}


DWORD
FmpWaitForGroup(
    IN PFM_GROUP Group
    )
/*++

Routine Description:

    Waits for a group to reach a stable state.

Arguments:

    Group - supplies the group

Comments - Assumption, is that the group lock is held when this is called.
    This function releases the group lock before the wait

Return Value:

    ERROR_SUCCESS if successful

    ERROR_SHUTDOWN_IN_PROGRESS if the cluster is being shutdown

    Win32 error code otherwise

--*/

{
    FM_WAIT_BLOCK WaitBlock;
    HANDLE WaitArray[2];
    DWORD Status;
    CLUSTER_GROUP_STATE GroupState;

    WaitBlock.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (WaitBlock.hEvent == NULL) {
        FmpReleaseLocalGroupLock( Group );
        return(GetLastError());
    }


    //
    // Check to see if it transitioned before we got the lock.
    //
    GroupState = FmpGetGroupState( Group , TRUE );
    if ((GroupState == ClusterGroupOffline) ||
        (GroupState == ClusterGroupOnline) ||
        (GroupState == ClusterGroupFailed)) {

        CloseHandle( WaitBlock.hEvent );
        FmpReleaseLocalGroupLock( Group );
        return(ERROR_SUCCESS);
    }

    //
    // Chittur Subbaraman (chitturs) - 10/31/1999
    //
    // Now before waiting, really make sure one or more resources in the 
    // group is in pending state.
    //
    GroupState = FmpGetGroupState( Group, FALSE );

    if ( GroupState != ClusterGroupPending ) {
        CloseHandle( WaitBlock.hEvent );
        FmpReleaseLocalGroupLock( Group );
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpWaitForGroup: Group <%1!ws!> state is %2!d!, not waiting for event...\r\n",
            OmObjectName(Group),
            GroupState );
        return( ERROR_SUCCESS );       
    }

    //
    // Add this wait block to the queue.
    //

    InsertTailList(&Group->WaitQueue, &WaitBlock.ListEntry);

    FmpReleaseLocalGroupLock( Group );

    //
    // Wait for the group to become stable or for the cluster to shutdown.
    //
    WaitArray[0] = FmpShutdownEvent;
    WaitArray[1] = WaitBlock.hEvent;

    Status = WaitForMultipleObjects(2, WaitArray, FALSE, INFINITE);
    CloseHandle(WaitBlock.hEvent);
    if (Status == 0) {
        return(ERROR_SHUTDOWN_IN_PROGRESS);
    } else {
        return(WaitBlock.Status);
    }
}

/****
@func       DWORD | FmpDeleteGroup| This makes the gum call to delete the
            group.

@parm       IN PFM_GROUP | pGroup | The group that must be deleted.
            
@comm       The group lock must be held when calling this api.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD 
FmpDeleteGroup(
    IN PFM_GROUP pGroup)
{
    PCWSTR  pszGroupId;
    DWORD   dwBufSize;
    DWORD   dwGroupLen;
    DWORD   dwStatus;

    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateDeleteGroup,
                             1,
                             dwGroupLen,
                             pszGroupId);


    return(dwStatus);

}


VOID
FmpGroupLastReference(
    IN PFM_GROUP pGroup
    )

/*++

Routine Description:

    Last dereference to group object processing routine.
    All cleanup for a group should really be done here!

Arguments:

    Resource - pointer the group being removed.

Return Value:

    None.

--*/

{
    if ( pGroup->OwnerNode != NULL )
        OmDereferenceObject(pGroup->OwnerNode);
    if (pGroup->dwStructState  & FM_GROUP_STRUCT_CREATED)
        DeleteCriticalSection(&pGroup->Lock);
    
    return;

} // FmpGroupLastReference

DWORD
FmpDoMoveGroupOnFailure(
    IN LPVOID pContext
    )

/*++

Routine Description:

    Move a group after ensuring that all resources in the group are
    in stable state. This thread is forked from FmpHandleGroupFailure.

Arguments:

    pContext - Pointer to the MOVE_GROUP structure to move.

Returns:

    ERROR_SUCCESS.

--*/

{
    PMOVE_GROUP     pMoveGroup = ( PMOVE_GROUP ) pContext;
    PFM_GROUP       pGroup;
    DWORD           dwStatus;
    PLIST_ENTRY     pListEntry;
    PFM_RESOURCE    pResource;

    //
    //  Chittur Subbaraman (chitturs) - 4/13/99
    //
    //  This thread first waits until all the resources within the
    //  failed group are in stable state and then initiates the
    //  move.
    //
    pGroup = pMoveGroup->Group;

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpDoMoveGroupOnFailure: Entry for Group <%1!ws!>...\n",
        OmObjectId(pGroup));

TryAgain:
    FmpAcquireLocalGroupLock( pGroup );

    //
    //  This thread must yield if someone else takes responsibility for
    //  the move. 
    //
    //  Condition 1: Protects against the case in which someone moves
    //  the group to another node and back to you while this thread is
    //  sleeping (very rare, I agree).
    //
    //  Condition 2: Protects against the common move case.
    //
    //  Condition 3: Protects against the case in which the 
    //  FmpMovePendingThread is waiting in FmpWaitForGroup while
    //  this thread got the resource lock and reached here.
    //
    if ( ( pGroup->dwStructState & 
           FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE ) ||
         ( pGroup->OwnerNode != NmLocalNode ) ||
         ( pGroup->MovingList != NULL ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Group <%1!ws!> move being yielded to someone else who is moving it...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    } 

    //
    //  If FM is shutting down, just exit.
    //
    if ( FmpShutdown )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Giving up Group <%1!ws!> move. FM is shutting down ...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    } 
    
    //
    // If the group has been marked for delete, then also exit. This is 
    // just an optimization. FmpDoMoveGroup does this check also.
    //
    if ( !IS_VALID_FM_GROUP( pGroup ) )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpDoMoveGroupOnFailure: Group <%1!ws!> marked for delete. Exiting ...\n",
                  OmObjectId(pGroup));      
        goto FnExit;
    }
    
    //
    // Wait until all resources within the group become stable.
    //
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &(pGroup->Contains);
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );
        if ( pResource->State > ClusterResourcePending )
        {
            FmpReleaseLocalGroupLock( pGroup );
            Sleep ( 200 );
            goto TryAgain;
        }
    }    

    //
    //  Initiate a move now that the group is quiet.
    //
    dwStatus = FmpDoMoveGroup( pGroup, NULL, FALSE );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDoMoveGroupOnFailure: FmpDoMoveGroup returns %1!u!\n",
                 dwStatus);

FnExit:     
    LocalFree( pContext );

    pGroup->dwStructState &= 
        ~( FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL | FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE );
                 
    FmpReleaseLocalGroupLock( pGroup ); 

    OmDereferenceObject( pGroup );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDoMoveGroupOnFailure Exit.\n");

    return( ERROR_SUCCESS );
} // FmpDoMoveGroupOnFailure


/****
@func       DWORD | FmpSetIntendedOwnerForGroup| This makes the gum call
            to set the intended owner for the group before a move.

@parm       IN PFM_GROUP | pGroup | The group whose intended owner 
            is to be set.

@comm       The local group lock is held while making this call.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD   FmpSetIntendedOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN DWORD     dwNodeId)
{

    PCWSTR  pszGroupId;
    DWORD   dwGroupLen;
    DWORD   dwStatus;


    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateGroupIntendedOwner,
                             2,
                             dwGroupLen,
                             pszGroupId,
                             sizeof(DWORD),
                             &dwNodeId
                             );


    return(dwStatus);
}

/****
@func       DWORD | FmpSetOwnerForGroup | On a move the new owner
            node makes this gum call to inform all nodes that it
            owns this particular group.

@parm       IN PFM_GROUP | pGroup | The group whose owner must be set.

@parm       IN PNM_NODE | pNode | The group's owner node.

@comm       The local group lock is held while making this call.

@rdesc      Returns a result code. ERROR_SUCCESS on success.
****/
DWORD   FmpSetOwnerForGroup(
    IN PFM_GROUP pGroup,
    IN PNM_NODE  pNode
    )
{

    PCWSTR  pszGroupId;
    PCWSTR  pszNodeId;
    DWORD   dwGroupLen;
    DWORD   dwNodeLen;
    DWORD   dwStatus;

    pszGroupId = OmObjectId( pGroup );
    dwGroupLen = (lstrlenW(pszGroupId)+1) * sizeof(WCHAR);
    pszNodeId = OmObjectId(pNode);
    dwNodeLen = (lstrlenW(pszNodeId)+1) * sizeof(WCHAR);

    //
    // Send message.
    //
    dwStatus = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateCheckAndSetGroupOwner,
                             2,
                             dwGroupLen,
                             pszGroupId,
                             dwNodeLen,
                             pszNodeId
                             );


    return(dwStatus);
}

PNM_NODE
FmpGetNodeNotHostingUndesiredGroups(
    IN PFM_GROUP pGroup,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fChooseMostPreferredNode
    )

/*++

Routine Description:

    Find a preferred node that does not host groups with CLUSREG_NAME_GRP_ANTI_AFFINITY_CLASS_NAME
    property set to the same value as the supplied group.

Arguments:

    pGroup - Pointer to the group object we're checking.

    fRuleOutLocalNode - Should the local node be considered or not.

    fChooseMostPreferredNode - Should the most preferred node be chosen after antiaffinity needs
                               are satisfied ?

Return Value:

    Pointer to node object that satisfies the anti-affinity condition.

    NULL if a node cannot be not found.

Note:

    The antiaffinity property value is defined as a MULTI_SZ property. However for this implementation
    we ignore all the string values beyond the first value. The MULTI_SZ definition is to allow
    future expansion of the algorithm implemented by this function.

--*/

{
    PLIST_ENTRY                 plistEntry;
    PPREFERRED_ENTRY            pPreferredEntry;
    GROUP_AFFINITY_NODE_INFO    GroupAffinityNodeInfo;
    PNM_NODE                    pNode = NULL;
    DWORD                       dwIndex = 0, i, j;
    DWORD                       dwClusterHighestVersion;
    BOOL                        fFoundLocalNode = FALSE;
    DWORD                       dwIndexStart = 0;

    GroupAffinityNodeInfo.ppNmNodeList = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 3/6/2001
    //
    //  This function works as follows.  First, it makes a list of possible candidate nodes that the
    //  group can be hosted on.  Next, it enumerates all groups in the cluster and for those
    //  groups that have the AntiAffinityClassName property set, it will remove those group's
    //  current owner nodes from the list of possible candidate nodes if they are present there.
    //  Note that this function will return a node only if the pruning has positively taken place.
    //  Else, it will return NULL. 
    //
    //  IMPORTANT NOTE: This function is called by all nodes from the node down processing FM
    //  GUM handler. For all nodes to reach exactly the same decision on the group placement,
    //  it is crucial that all nodes call this function for groups in exactly the same order.
    //  E.g., if node 1 was hosting groups A, B and C and it died, then all the remaining nodes
    //  must call this function first for group A, then for group B and finally for group C.
    //  This is because once group A is placed by this function, then group B's placement is
    //  influenced by group A's placement and similarly for groups B and C. This order is 
    //  ensured since all nodes OM will maintain groups in the same order since OM creates this
    //  list based on enumerating the group key (under Cluster\Groups) and that must occur in the
    //  same order in all nodes.
    //
    
    //
    //  It is too bad that we can't hold any locks while enumerating groups and looking at the
    //  property field since that will soon result in a deadlock (since we can't hold group locks
    //  from within a GUM and this function is invoked from a GUM).
    //
    
    //
    //  If we are dealing with the mixed mode cluster or if the group does not have the antiaffinity
    //  property set, then don't do anything.
    //
    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    if ( ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < NT51_MAJOR_VERSION ) ||
         ( pGroup->lpszAntiAffinityClassName == NULL ) )
    {
        goto FnExit;
    }
    
    //
    //  Initialize the node list.
    //
    GroupAffinityNodeInfo.ppNmNodeList = LocalAlloc ( LPTR, 
                                                      ClusterDefaultMaxNodes * sizeof ( PNM_NODE ) );

    if ( GroupAffinityNodeInfo.ppNmNodeList == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpGetNodeNotHostingUndesiredGroups: Failed in alloc, Status %1!d!\n",
                      GetLastError());
        goto FnExit;
    }
    
    //
    //  For each entry in the preferred list, find a system that is up and that does not
    //  host any groups with an anti-affinity to the supplied group.
    //
    for ( plistEntry = pGroup->PreferredOwners.Flink;
          plistEntry != &(pGroup->PreferredOwners);
          plistEntry = plistEntry->Flink ) 
    {
        pPreferredEntry = CONTAINING_RECORD( plistEntry,
                                             PREFERRED_ENTRY,
                                             PreferredLinkage );

        if ( NmGetNodeState( pPreferredEntry->PreferredNode ) == ClusterNodeUp ) 
        {
            //
            //  If you are not required to choose the most preferred node, note down the
            //  index of the node next to the local node so that our search can begin
            //  from that index.
            //
            if ( ( fChooseMostPreferredNode == FALSE ) && ( fFoundLocalNode == TRUE ) )
            {
                fFoundLocalNode = FALSE;
                dwIndexStart = dwIndex;
            }

            if ( pPreferredEntry->PreferredNode == NmLocalNode ) 
            {
                fFoundLocalNode = TRUE;
                if ( fRuleOutLocalNode ) continue;  
            }

            GroupAffinityNodeInfo.ppNmNodeList[dwIndex] = pPreferredEntry->PreferredNode;
            dwIndex ++;
        }// if
    } // for

    //
    //  Initialize the other fields in the GroupAffinityNodeInfo structure.
    //
    GroupAffinityNodeInfo.pGroup = pGroup;
    GroupAffinityNodeInfo.fDidPruningOccur = FALSE;

    //
    //  Enumerate all the groups and rule out nodes that host groups with the supplied
    //  anti-affinity property set.
    //
    OmEnumObjects ( ObjectTypeGroup,
                    FmpCheckForAntiAffinityProperty,
                    pGroup->lpszAntiAffinityClassName,
                    &GroupAffinityNodeInfo );

    //
    //  No pruning occurred so far. So, don't proceed further and let the caller decide on
    //  a best node for the group using some other algorithm.
    //
    if ( GroupAffinityNodeInfo.fDidPruningOccur == FALSE )
    {
        goto FnExit;
    }

    //
    //  Now, pick the first node from the list that is a valid node. Note that the start index
    //  from which we start a search varies depending on the input parameter to this function.
    //
    j = dwIndexStart;
    
    for ( i=0; i<ClusterDefaultMaxNodes; i++ )
    {        
        if ( GroupAffinityNodeInfo.ppNmNodeList[j] != NULL )
        {
            pNode = GroupAffinityNodeInfo.ppNmNodeList[j];
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpGetNodeNotHostingUndesiredGroups: Choosing node %1!d! for group %2!ws! [%3!ws!]...\n",
                          NmGetNodeId(pNode),
                          OmObjectId(pGroup),
                          OmObjectName(pGroup));       
            goto FnExit;
        }
        j = ( j+1 ) % ClusterDefaultMaxNodes;
    } // for

FnExit:
    LocalFree( GroupAffinityNodeInfo.ppNmNodeList );
    return( pNode );
} // FmpGetNodeNotHostingUndesiredGroups

BOOL
FmpCheckForAntiAffinityProperty(
    IN LPCWSTR lpszAntiAffinityClassName,
    IN PGROUP_AFFINITY_NODE_INFO pGroupAffinityNodeInfo,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Remove a node from the supplied node list if it hosts the supplied group with the supplied
    anti-affinity property set.

Arguments:

    lpszAntiAffinityClassName - The name property to check for.

    pGroupAffinityNodeInfo - Structure containing a list of nodes that is to be pruned possibly.

    pGroup - Supplies the group.

    lpszGroupName - Supplies the group's name.

Return Value:

    TRUE - to indicate that the enumeration should continue.
    
    FALSE - to indicate that the enumeration should not continue.

--*/
{
    DWORD   i;
    
    //
    //  If the supplied group has the anti-affinity property not set or if it has the
    //  property set but is not same as the one we are checking against or if it is same
    //  as the group we are interested in placing, then just return specifying that the 
    //  enum should continue.
    //
    if ( ( pGroup->lpszAntiAffinityClassName == NULL ) ||
         ( pGroup == pGroupAffinityNodeInfo->pGroup ) ||
         ( lstrcmp ( lpszAntiAffinityClassName, pGroup->lpszAntiAffinityClassName ) != 0 ) )
    {
        goto FnExit;
    }

    //
    //  If you reached here, this means that the supplied group has the anti-affinity property
    //  set and is same as the property we are checking against. So, prune the node list.
    //
    for ( i=0; i<ClusterDefaultMaxNodes; i++ )
    {
        if ( ( pGroupAffinityNodeInfo->ppNmNodeList[i] != NULL ) &&
             ( pGroup->OwnerNode == pGroupAffinityNodeInfo->ppNmNodeList[i] ) )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpCheckForAntiAffinityProperty: Pruning node %1!d! for group %2!ws! due to "
                          "group %3!ws!, AntiAffinityClassName=%4!ws!...\n",
                          NmGetNodeId(pGroupAffinityNodeInfo->ppNmNodeList[i]),
                          OmObjectId(pGroupAffinityNodeInfo->pGroup),
                          OmObjectId(pGroup),
                          lpszAntiAffinityClassName);                  
            pGroupAffinityNodeInfo->ppNmNodeList[i] = NULL;
            //
            //  Mark that pruning was attempted. 
            //
            pGroupAffinityNodeInfo->fDidPruningOccur = TRUE; 
            goto FnExit;
        } // if
    } // for

FnExit:    
    return( TRUE );
} // FmpCheckForAntiAffinityProperty

PNM_NODE
FmpPickNodeFromPreferredListAtRandom(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pSuggestedPreferredNode  OPTIONAL,
    IN BOOL fRuleOutLocalNode,
    IN BOOL fCheckForDisablingRandomization
    )

/*++

Routine Description:

    Find a preferred node for the group that is UP in a random fashion.

Arguments:

    pGroup - Pointer to the group object we're interested in.

    pSuggestedPreferredNode - Suggested fallback option in case this random result is undesired. OPTIONAL

    fRuleOutLocalNode - Should the local node be ruled out from consideration.

    fCheckForDisablingRandomization - Check whether randomization should be disabled.

Return Value:

    The preferred node that is picked.

    NULL if a node cannot be not found.

Comments:

    This function is called from both FmpMoveGroup as well as from FmpNodeDown. In the former case,
    we will have a non-NULL suggested preferred node, rule out local node option, check
    for property setting disabling randomization and check for mixed mode clusters to disable
    randomization. In the latter case, these parameters are the opposite.

--*/
{
    UUID                uuId;
    USHORT              usHashValue;
    PNM_NODE            pNode = NULL, pSelectedNode = pSuggestedPreferredNode;
    DWORD               dwNodeId;
    DWORD               dwRetry = 0;
    DWORD               dwStatus;
    DWORD               dwDisabled = 0;
    DWORD               dwClusterHighestVersion;

    //
    //  Chittur Subbaraman (chitturs) - 4/18/2001
    //
    if ( fCheckForDisablingRandomization )
    {
        //
        //  If you are here, this means you are coming as a part of a user-initiated move.
        //  Check whether the randomization applies.
        //
        
        //
        //  First, check if are operating in a mixed version cluster. If so, don't randomize.
        //
        NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                        NULL, 
                                        NULL );

        if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                    NT51_MAJOR_VERSION ) 
        {
            return ( pSelectedNode );
        }

        //
        //  Next check if the user has turned off the randomization algorithm by setting
        //  HKLM\Cluster\DisableGroupPreferredOwnersRandomization DWORD to 1.
        //      
        dwStatus = DmQueryDword( DmClusterParametersKey,
                                 CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                                 &dwDisabled,
                                 NULL );
       
        if ( ( dwStatus == ERROR_SUCCESS ) &&
             ( dwDisabled == 1 ) )
        {
            return ( pSelectedNode );
        }
    }
    
    //
    //  This function will attempt to pick a node at random from the group's preferred owners list
    //  in case the caller does not suggest a preferred node which is set by the user. So, first
    //  this function checks this case and bails out if the condition is met. Otherwise, it
    //  will generate a random number between 1 and NmMaxNodeId and see if (a) that node is in
    //  the group's preferred list, and (b) that node is UP. If so, it picks up the node. Note
    //  that the function will try 10 times to pick a node and then gives up. If no
    //  node is found, this function will return the suggested node which in some cases could be
    //  NULL.
    //
    ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Picking node for group %1!ws! [%2!ws!], suggested node %3!u!...\n",
                  OmObjectId(pGroup),
                  OmObjectName(pGroup),
                  (pSuggestedPreferredNode == NULL) ? 0:NmGetNodeId(pSuggestedPreferredNode));


    if ( ( pSuggestedPreferredNode != NULL ) &&
         ( FmpIsNodeUserPreferred ( pGroup, pSuggestedPreferredNode ) ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Node %2!u! for group %1!ws! is user preferred...\n",
                      OmObjectId(pGroup),
                      NmGetNodeId(pSuggestedPreferredNode));
        goto FnExit;
    }

    if ( pGroup->lpszAntiAffinityClassName != NULL )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Group %1!ws! has antiaffinity property set...\n",
                      OmObjectId(pGroup));
        goto FnExit;
    }

    //
    //  Retry 25 times so that we can have a good chance of getting a valid node. Note that we
    //  supply NmMaxNodeId to the srand() function and its value is equal to the node limit of 
    //  16. So, to get a valid node in a smaller size cluster, we have to have the retry count
    //  to be reasonable.
    //
    while ( dwRetry++ < 25 )
    {
        dwStatus = UuidFromString( ( LPWSTR ) OmObjectId(pGroup), &uuId );
        
        if ( dwStatus != RPC_S_OK ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPickNodeFromPreferredListAtRandom: Unable to get UUID from string %1!ws!, Status %2!u!...\n",
                          OmObjectId(pGroup),
                          dwStatus);
            goto FnExit;
        }

        usHashValue = UuidHash( &uuId, &dwStatus );

        if ( dwStatus != RPC_S_OK ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPickNodeFromPreferredListAtRandom: Unable to get hash value for UUID %1!ws!, Status %2!u!...\n",
                          OmObjectId(pGroup),
                          dwStatus);
            goto FnExit;
        }

        //
        //  Seed the random number generate with a value that is as random as it gets.
        //
        srand( GetTickCount() * usHashValue * ( dwRetry + 1 ) );

        //
        //  Find the node ID that is between ClusterMinNodeId and NmMaxNodeId. We use NmMaxNodeId 
        //  here since there is no simple way to get the count of configured nodes. Note that we
        //  have to ensure that the node ID falls within this range, otherwise assertion trips
        //  in NmReferenceNodeById.
        //       
        dwNodeId  = ( DWORD ) ( ( double ) rand() / ( double ) ( RAND_MAX ) * NmMaxNodeId ) + 1;

        if ( dwNodeId > NmMaxNodeId ) dwNodeId = NmMaxNodeId;
        if ( dwNodeId < ClusterMinNodeId ) dwNodeId = ClusterMinNodeId;

        //
        //  In case the caller asks you to rule out local node, do so.
        //
        if ( ( fRuleOutLocalNode ) && ( dwNodeId == NmLocalNodeId ) ) continue;

        //
        //  Reference and dereference the node objects. Note that we are only interested in
        //  getting a pointer to the node object and we use the fact that the node in the preferred 
        //  list must be referenced.
        //
        pNode = NmReferenceNodeById ( dwNodeId );

        if ( pNode == NULL ) continue;           
       
        if ( ( FmpInPreferredList( pGroup, pNode, FALSE, NULL ) ) && 
             ( NmGetExtendedNodeState( pNode ) == ClusterNodeUp ) )
        {
            pSelectedNode = pNode;
            break;
        }
        
        OmDereferenceObject ( pNode );
        pNode = NULL;
    }// while

FnExit:
    if ( pNode != NULL ) OmDereferenceObject ( pNode );

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpPickNodeFromPreferredListAtRandom: Selected node %2!u! for group %1!ws!...\n",
                  OmObjectId(pGroup),
                  (pSelectedNode == NULL) ? 0:NmGetNodeId(pSelectedNode));   
    
    return ( pSelectedNode );
}// FmpPickNodeFromPreferredNodeAtRandom

BOOL
FmpIsNodeUserPreferred(
    IN PFM_GROUP pGroup,
    IN PNM_NODE pPreferredNode
    )

/*++

Routine Description:

    Check whether the supplied node is set as a preferred node by the user.

Arguments:

    pGroup - Pointer to the group object we're interested in.

    pPreferredNode - Preferred node to check for.

Return Value:

    TRUE - The supplied preferred node is user set.

    FALSE otherwise

--*/
{
    DWORD               dwStatus;
    BOOL                fPreferredByUser = FALSE;        
    LPWSTR              lpmszPreferredNodeList = NULL;
    LPCWSTR             lpszPreferredNode;
    DWORD               cbPreferredNodeList = 0;
    DWORD               cbBuffer = 0;
    DWORD               dwIndex;
    PNM_NODE            pNode;

    //
    //  Look for any preferred owners set by the user
    //
    dwStatus = DmQueryMultiSz( pGroup->RegistryKey,
                               CLUSREG_NAME_GRP_PREFERRED_OWNERS,
                               &lpmszPreferredNodeList,
                               &cbBuffer,
                               &cbPreferredNodeList );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //
    //  Parse the multisz and check whether the supplied node exists in the list
    //
    for ( dwIndex = 0; ; dwIndex++ ) 
    {
        lpszPreferredNode = ClRtlMultiSzEnum( lpmszPreferredNodeList,
                                              cbPreferredNodeList/sizeof(WCHAR),
                                              dwIndex );

        if ( lpszPreferredNode == NULL ) 
        {
            break;
        }

        pNode = OmReferenceObjectById( ObjectTypeNode,
                                       lpszPreferredNode );

        if ( pNode == NULL )
        {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpIsNodeUserPreferred: Unable to reference node %1!ws!, Status %2!u!...\n",
                          lpszPreferredNode,
                          dwStatus);      
            continue;
        }

        if ( pNode == pPreferredNode )
        {
            fPreferredByUser = TRUE;
            OmDereferenceObject ( pNode );
            break;
        }

        OmDereferenceObject ( pNode );
    } // for

FnExit:
    LocalFree ( lpmszPreferredNodeList );

    return ( fPreferredByUser );
}// FmpIsNodeUserPreferred

DWORD
FmpPrepareGroupNodeList(
    OUT PFM_GROUP_NODE_LIST *ppGroupNodeList
    )

/*++

Routine Description:

    Prepares a buffer containing the group ID and preferred owner node ID of all groups.

Arguments:

    ppGroupNodeList - Pointer to a buffer containing group IDs and preferred nodes.

Return Value:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    DWORD       cbBuffer = 512; // Let us try a 512 byte buffer to start with.
    DWORD       dwStatus;
    DWORD       dwDisabled = 0;

    //
    //  First check if the user has turned off the randomization algorithm by setting
    //  HKLM\Cluster\DisableGroupPreferredOwnersRandomization DWORD to 1.
    //      
    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                             &dwDisabled,
                             NULL );
   
    if ( ( dwStatus == ERROR_SUCCESS ) &&
         ( dwDisabled == 1 ) )
    {
        dwStatus = ERROR_CLUSTER_INVALID_REQUEST;
        return ( dwStatus );
    }
    
    //
    //  This function allocates contiguous memory for a list so that the entire buffer
    //  can be passed on to GUM.
    //
    *ppGroupNodeList = LocalAlloc( LPTR, cbBuffer );

    if ( *ppGroupNodeList == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpPrepareGroupNodeList: Memory alloc failed, Status %1!u!...\n",
                      dwStatus);      
        return ( dwStatus );
    }

    //
    //  Initialize the size of the list to the size of the header minus first element.
    //
    ( *ppGroupNodeList )->cbGroupNodeList = sizeof ( FM_GROUP_NODE_LIST ) - 
                                                sizeof ( FM_GROUP_NODE_LIST_ENTRY );
    
    //
    //  Enumerate all the groups, find a possibly random preferred owner for each group and
    //  return all the info in the buffer.
    //
    return OmEnumObjects ( ObjectTypeGroup,
                            FmpAddGroupNodeToList,
                            ppGroupNodeList,
                            &cbBuffer );
    
}// FmpPrepareGroupNodeList

DWORD
FmpAddGroupNodeToList(
    IN PFM_GROUP_NODE_LIST *ppGroupNodeList,
    IN LPDWORD pcbBuffer,
    IN PFM_GROUP pGroup,
    IN LPCWSTR lpszGroupId
    )

/*++

Routine Description:

    Find a random preferred owner for the given group and add the info to a buffer.

Arguments:

    ppGroupNodeList - Pointer to a buffer containing group IDs and preferred nodes.

    pcbBuffer - Size of the buffer.

    pGroup - Group whose preferred node is to be found.

    lpszGroupId - ID of the group.

Return Value:

    ERROR_SUCCESS on success

    Win32 error code otherwise

--*/
{
    PNM_NODE                    pNode;
    PFM_GROUP_NODE_LIST_ENTRY   pGroupNodeListEntry;
    PFM_GROUP_NODE_LIST         pBuffer;
    PLIST_ENTRY                 pListEntry;
    DWORD                       dwStatus;
    BOOL                        fLocked;
    DWORD                       dwRetryCount = 10;   //  5 secs retry

    //
    //  Try to get the group lock since you access group lists here. Note that you won't be 
    //  able to get the group lock in case some resource is stuck waiting for the quorum resource
    //  to come online and this thread called as a part of FmpNodeDown is responsible for sending
    //  the node down GUM which in turn will bring the quorum group online. In such a case, do not 
    //  add this group to the list. The FM node down GUM handler will handle cases in which one 
    //  or more groups is not in the supplied list and will fallback to the static preferred 
    //  owners list for deciding on a group owner.
    //
    
try_acquire_lock:    
    FmpTryAcquireLocalGroupLock( pGroup, fLocked );

    if ( fLocked == FALSE )
    {
        if ( dwRetryCount == 0 )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[FM] FmpAddGroupNodeToList: Can't get lock for group %1!ws! [%2!ws!], skip including the group in list...\n",
                          OmObjectId(pGroup),
                          OmObjectName(pGroup));
            return ( TRUE );
        }
        dwRetryCount --;
        Sleep( 500 );
        goto try_acquire_lock;
    }

    CL_ASSERT( fLocked == TRUE );
    
    //
    //  Skip the quorum group since we cannot randomize its preferred owners list since MM has a
    //  choke hold on the placement of quorum group.
    //
    if ( pGroup == gpQuoResource->Group )  goto FnExit;

    //
    //  Try to pick a preferred node list for the group at random.
    //
    pNode = FmpPickNodeFromPreferredListAtRandom( pGroup, 
                                                  NULL,     // No suggested preferred owner
                                                  FALSE,    // Can choose local node
                                                  FALSE );  // Check whether randomization should be
                                                            // disabled

    //
    //  If no node could be picked, bail out
    //
    if ( pNode == NULL ) goto FnExit;        

    //
    //  Check whether the allocated buffer is big enough to hold the new entry. Note that the
    //  RHS of the equality need not contain the NULL char size since we allocate 1 WCHAR for it in
    //  the FM_GROUP_NODE_LIST_ENTRY structure.  Also, note that we have to see if the current
    //  buffer size is big enough to hold the padding for DWORD alignment.
    //
    if ( *pcbBuffer < ( ( *ppGroupNodeList )->cbGroupNodeList + 
                                ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                  lstrlenW ( lpszGroupId ) * sizeof ( WCHAR ) +
                                  sizeof ( DWORD ) - 1 
                                ) & ~( sizeof ( DWORD ) - 1 ) 
                        ) )
    {
        //
        //  Reallocate a bigger buffer
        //
        pBuffer = LocalAlloc( LPTR, 2 * ( *pcbBuffer ) );

        if ( pBuffer == NULL )
        {       
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpAddGroupNodeToList: Memory alloc failed, Status %1!u!...\n",
                          dwStatus);      
            goto FnExit;            
        }

        ( *pcbBuffer ) *= 2;

        //
        //  Copy the contents of the old list to the new list. 
        //
        CopyMemory( pBuffer, *ppGroupNodeList, ( *ppGroupNodeList )->cbGroupNodeList );
                
        LocalFree ( *ppGroupNodeList );

        *ppGroupNodeList = pBuffer;    
    }

    //
    //  Find the pointer to the beginning of the new list entry
    //
    pGroupNodeListEntry = ( PFM_GROUP_NODE_LIST_ENTRY )
                                ( ( LPBYTE ) ( *ppGroupNodeList ) + 
                                  ( *ppGroupNodeList )->cbGroupNodeList );

    //
    //  Adjust the size of the list.  As above, size of NULL char is excluded. Align the length
    //  to a multiple of DWORD since we want the PFM_GROUP_NODE_LIST_ENTRY structure to be
    //  DWORD aligned since the structure starts with a DWORD.
    //
    ( *ppGroupNodeList )->cbGroupNodeList += ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                                    lstrlenW ( lpszGroupId ) * sizeof ( WCHAR ) +
                                                    sizeof ( DWORD ) - 1 ) & ~( sizeof ( DWORD ) - 1 );
    //
    //  Set the contents of the list entry
    //
    pGroupNodeListEntry->dwPreferredNodeId = NmGetNodeId ( pNode );
    lstrcpy( pGroupNodeListEntry->szGroupId, lpszGroupId );

FnExit:
    FmpReleaseLocalGroupLock( pGroup );
    
    return ( TRUE );                
}// FmpPrepareGroupNodeList

PNM_NODE
FmpParseGroupNodeListForPreferredOwner(
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList,
    IN PNM_NODE pSuggestedPreferredNode
    )

/*++

Routine Description:

    Parse the supplied group node list looking for a preferred node for the supplied group.
    
Arguments:

    pGroup - The group whose preferred node must be found.

    pGroupNodeList - The list contains preferred nodes of the group.

    pSuggestedPreferredNode - Suggested preferred node fallback option.
    
Return Value:

    The preferred node for the group.
    
--*/
{
    PNM_NODE                    pSelectedNode = pSuggestedPreferredNode;
    PFM_GROUP_NODE_LIST_ENTRY   pGroupNodeListEntry;
    BOOL                        fFoundGroup = FALSE;
    PNM_NODE                    pNode = NULL;
    DWORD                       dwStatus;
    DWORD                       cbGroupNodeList;

    //
    //  If the suggested node is user preferred or if it has an anti-affinity class name
    //  property set, don't do anything else. Just return the suggested owner.
    //
    if ( ( FmpIsNodeUserPreferred ( pGroup, pSuggestedPreferredNode ) ) ||
         ( pGroup->lpszAntiAffinityClassName != NULL ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Node %2!u! for group %1!ws! is user preferred/antiaffinity property set...\n",
                      OmObjectId(pGroup),
                      NmGetNodeId(pSuggestedPreferredNode));
        goto FnExit;
    }

    cbGroupNodeList = sizeof ( FM_GROUP_NODE_LIST ) - 
                                sizeof ( FM_GROUP_NODE_LIST_ENTRY );
        
    //
    //  Walk the supplied list looking for the group entry.
    //
    while ( cbGroupNodeList < pGroupNodeList->cbGroupNodeList )
    {
        pGroupNodeListEntry = ( PFM_GROUP_NODE_LIST_ENTRY ) ( ( LPBYTE ) pGroupNodeList +
                                                                    cbGroupNodeList );
        
        if ( lstrcmp( pGroupNodeListEntry->szGroupId, OmObjectId( pGroup ) ) == 0 )  
        {
            fFoundGroup = TRUE;
            break;
        }
        cbGroupNodeList += ( sizeof ( FM_GROUP_NODE_LIST_ENTRY ) + 
                                    lstrlenW ( pGroupNodeListEntry->szGroupId ) * sizeof ( WCHAR ) +
                                            sizeof ( DWORD ) - 1 ) & ~( sizeof ( DWORD ) - 1 );
    } // while

    //
    //  Fallback to the suggested option if:
    //      (1) You did not find the group in the list
    //      (2) The preferred node for the group is invalid in the list
    //      (3) The preferred node for the group is down
    //
    if ( fFoundGroup == FALSE )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Did not find group %1!ws! in supplied list...\n",
                      OmObjectId(pGroup));
        goto FnExit;
    }

    if ( ( pGroupNodeListEntry->dwPreferredNodeId == 0 ) ||
         ( pGroupNodeListEntry->dwPreferredNodeId > NmMaxNodeId ) )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Invalid node %1!u! for group %1!ws! in supplied list...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup));
        goto FnExit;
    }

    pNode = NmReferenceNodeById( pGroupNodeListEntry->dwPreferredNodeId );

    if ( pNode == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpParseGroupNodeListForPreferredOwner: Unable to reference node %1!u! for group %1!ws!, Status %3!u!...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup),
                      dwStatus);
        goto FnExit;
    }

    if ( NmGetNodeState( pNode ) != ClusterNodeUp ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpParseGroupNodeListForPreferredOwner: Preferred node %1!u! for group %1!ws! is not UP...\n",
                      pGroupNodeListEntry->dwPreferredNodeId,
                      OmObjectId(pGroup));
        goto FnExit;
    }

    pSelectedNode = pNode;

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpParseGroupNodeListForPreferredOwner: Selected node %1!u! for group %2!ws! from supplied randomized list...\n",
                  pGroupNodeListEntry->dwPreferredNodeId,
                  OmObjectId(pGroup));

FnExit:
    //
    //  Dereference the node object since we depend on the original reference added to the
    //  group's preferred owner when it was added to the group structure.
    //
    if ( pNode != NULL ) OmDereferenceObject( pNode );

    return ( pSelectedNode );
}// FmpParseGroupNodeListForPreferredOwner

VOID
FmpNotifyGroupStateChangeReason(
    IN PFM_GROUP pGroup,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    )

/*++

Routine Description:

    Notify a resource DLL about the reason for a state change.

Arguments:

    pGroup - The group whose resources must be notified of the state change reason.

    eReason - The reason for the state change.

Returns:

    None.

Comments:

    This function MUST be called with local group lock held.

--*/
{
    PLIST_ENTRY         pListEntry;
    PFM_RESOURCE        pResource;

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpNotifyGroupStateChangeReason: Notifying group %1!ws! [%2!ws!] of state change reason %3!u!...\n",
                  OmObjectName(pGroup),
                  OmObjectId(pGroup),
                  eReason);
    //
    //  Walk the group contains list and attempt to notify each resource of the state change reason.
    //
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &(pGroup->Contains );
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry,
                                       FM_RESOURCE,
                                       ContainsLinkage );
        FmpNotifyResourceStateChangeReason( pResource, eReason );
    } // for
}// FmpNotifyGroupStateChangeReason
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmvote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fmvote.c

Abstract:

    Cluster FM Global Update processing routines.

Author:

    Sunita shrivastava (sunitas) 24-Apr-1996


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#define LOG_MODULE FMVOTE


/****
@func       DWORD | FmpGumVoteHandler| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwContext| The gum update type for which the vote is
            being collected.
            
@parm       IN DWORD | dwInputBufLength| The length of the input buffer.

@parm       IN PVOID | pInputBuf| A pointer to the input buffer based on 
            which a vote must be cast.

@parm       IN DWORD | dwVoteLength | The length of the buffer pointed to
            by pVoteBuf.

@parm       OUT POVID | pVoteBuf | A pointer to a buffer of size dwVoteLength
            where the vote must be cast.

            
@comm       The votes are collected by gum and returned to the node that is taking
            the poll.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/

DWORD
WINAPI
FmpGumVoteHandler(
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
)
{

    DWORD  dwStatus = ERROR_SUCCESS;
    
    if ( !FmpFMGroupsInited  ||
         FmpShutdown ) 
    {
        return(ERROR_NOT_READY);
    }

    switch ( dwContext ) 
    {
        case FmUpdatePossibleNodeForResType:
            dwStatus = FmpVotePossibleNodeForResType(dwInputBufLength, 
                (LPCWSTR)pInputBuf, dwVoteLength, pVoteBuf);
            break;
            
        default:
            dwStatus = ERROR_REQUEST_ABORTED;
            

    }

    return(dwStatus);

} // FmpGumVoteHandler


/****
@func       DWORD | FmpGumVoteHandler| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwContext| The gum update type for which the vote is
            being collected.
            
@parm       IN DWORD | dwInputBufLength| The length of the input buffer.

@parm       IN PVOID | pInputBuf| A pointer to the input buffer based on 
            which a vote must be cast.

@parm       IN DWORD | dwVoteLength | The length of the buffer pointed to
            by pVoteBuf.

@parm       OUT POVID | pVoteBuf | A pointer to a buffer of size dwVoteLength
            where the vote must be cast.

            
@comm       The votes are collected by gum and returned to the node that is taking
            the poll.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/

DWORD FmpVotePossibleNodeForResType(
    IN  DWORD dwInputBufLength,
    IN  LPCWSTR lpszResType,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwVoteStatus;
    PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE pVoteResType;
    PFM_RESTYPE pResType=NULL;

    
    if (dwVoteLength != sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE))
        return (ERROR_INVALID_PARAMETER);

    pVoteResType = (PFMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE)pVoteBuf;

    pResType = OmReferenceObjectById(ObjectTypeResType, lpszResType);

    if (!pResType)
        return (ERROR_INVALID_PARAMETER);
        
    dwVoteStatus = FmpRmLoadResTypeDll(pResType);

    pVoteResType->dwNodeId = NmLocalNodeId;
    pVoteResType->dwSize = sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE);
    if (dwVoteStatus == ERROR_SUCCESS)
        pVoteResType->bPossibleNode = TRUE;
    else
        pVoteResType->bPossibleNode = FALSE;


    if (pResType) OmDereferenceObject(pResType);
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\fmval.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    fmval.c
    
Abstract:

    Cluster manager api validation/support routines.

Author:

    Sunita Shrivastava (sunitas) 29-April-1999.

Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE FMVAL

////////////////////////////////////////////////////////
//
// Validation routines for Group operations.
//
////////////////////////////////////////////////////////

DWORD
FmpValOnlineGroup(
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Validation routine before group is brought online.

Arguments:

    Group - Supplies a pointer to the group structure to bring online.

Comments:

    Is called with the localgroup lock held

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY     listEntry;


    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Make sure the owning node can run the group.
    //
    if ( !FmpInPreferredList( Group, Group->OwnerNode ) ) 
    {
        dwStatus = ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST;
        goto FnExit;
    }

    //
    // Make sure the owning node is not paused.
    //
    if (NmGetNodeState(Group->OwnerNode) == ClusterNodePaused) 
    {
        dwStatus = ERROR_SHARING_PAUSED;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValOnlineGroup


DWORD
FmpValMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Validation routine for group move.

Arguments:

    Group - Supplies a pointer to the group structure to move.

    DestinationNode - Supplies the node object to move the group to. If not
        present, then move it to THE OTHER node.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    
    //if the group has been marked for delete, then fail this call
    if (!IS_VALID_FM_GROUP(Group))
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( FmpIsGroupPending(Group) ) 
    {
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( Group->OwnerNode == NULL ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_AVAILABLE;
        goto FnExit;
    }            

FnExit:
    return(dwStatus);

} // FmpValMoveGroup

////////////////////////////////////////////////////////
//
// Validation routines for resource operations
//
////////////////////////////////////////////////////////

DWORD
FmpValCreateResource(
    IN PFM_GROUP        Group,
    IN LPWSTR           ResourceId,
    IN LPCWSTR          ResourceName,
    OUT PGUM_CREATE_RESOURCE  *ppGumResource,
    OUT PDWORD          pdwBufSize
    )

/*++

Routine Description:

    Validation routine for resource creation.

Arguments:

    Group - Supplies the group in which this resource belongs.

    ResourceId - Supplies the Id of the resource to create.

    ResourceName - Supplies the 'user-friendly' name of the resource.

    ppGumResource - Message buffer to hold resource info.

    pdwBufSize - Message buffer size.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.


--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    PFM_RESOURCE    Resource;
    LPCWSTR         GroupId;
    PGUM_CREATE_RESOURCE GumResource;
    DWORD           GroupIdLen;
    DWORD           ResourceIdLen;
    DWORD           ResourceNameLen;
    DWORD           BufSize;
    HDMKEY          ResourceKey;
    HDMKEY          ParamsKey;
    DWORD           Disposition;

    *ppGumResource = NULL;
    *pdwBufSize = 0;
    
    //
    // First create the parameters field.
    //
    ResourceKey = DmOpenKey( DmResourcesKey,
                             ResourceId,
                             MAXIMUM_ALLOWED );
    if ( ResourceKey == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] CreateResource: Failed to open registry key for %1!ws!, status = %2!u!.\n",
                   ResourceId,
                   GetLastError() );
        dwStatus = GetLastError();
        goto FnExit;
    } 
    
    ParamsKey = DmCreateKey( ResourceKey,
                             CLUSREG_KEYNAME_PARAMETERS,
                             0,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &Disposition );
    if ( ParamsKey != NULL ) 
    {
        DmCloseKey( ParamsKey );
    }
    DmCloseKey( ResourceKey );

    //
    // Allocate a message buffer.
    //
    GroupId = OmObjectId(Group);
    GroupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
    ResourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
    ResourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
    BufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
              GroupIdLen + ResourceIdLen + ResourceNameLen;
    GumResource = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumResource == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Fill in message buffer.
    //
    GumResource->Resource = NULL;
    GumResource->GroupIdLen = GroupIdLen;
    GumResource->ResourceIdLen = ResourceIdLen;
    CopyMemory(GumResource->GroupId, GroupId, GroupIdLen);
    CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen,
               ResourceId,
               ResourceIdLen);
    CopyMemory((PCHAR)GumResource->GroupId + GroupIdLen + ResourceIdLen,
               ResourceName,
               ResourceNameLen);



    *ppGumResource = GumResource;
    *pdwBufSize = BufSize;

FnExit:    
    return(dwStatus);

} // FmpValCreateResource



DWORD
FmpValDeleteResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Validation routine for delete resource.

Arguments:

    Resource - Supplies the resource to delete.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;


    //
    // Check if this is the quorum resource.
    //
    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_QUORUM_RESOURCE;
        goto FnExit;
    }

    //other core resources cannot be deleted either
    if (pResource->ExFlags & CLUS_FLAG_CORE)
    {
        dwStatus = ERROR_CORE_RESOURCE;
        goto FnExit;
    }

    //
    // Check the state of the resource, before attempting to delete it.
    // It must be offline or failed in order to perform the delete.
    //
    if ((pResource->State != ClusterResourceOffline) &&
        (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Check whether this resource provides for any other resources.
    // If so, it cannot be deleted.
    //
    if (!IsListEmpty(&pResource->ProvidesFor)) 
    {
        dwStatus = ERROR_DEPENDENT_RESOURCE_EXISTS;
        goto FnExit;
    }

    if (pResource->Group->MovingList)
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }
        
FnExit:
    return(dwStatus);

} // FmpValDeleteResource


DWORD
FmpValOnlineResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    This routine validates if a resource can be brought online.

Arguments:

    Resource - A pointer to the resource to bring online.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{

    DWORD   dwStatus = ERROR_SUCCESS;
    
    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if the resource has been initialized. If not, attempt
    // to initialize the resource now.
    //
    if ( pResource->Monitor == NULL )
    {
        dwStatus = FmpInitializeResource( pResource, TRUE );
    }

FnExit:
    return(dwStatus);
} // FmpValOnlineResource


DWORD
FmpValOfflineResource(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    This routine validates if a given resource can be taken offline.

Arguments:

    Resource - A pointer to the resource to take offline.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;


    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if this is the quorum resource.
    //
    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_QUORUM_RESOURCE;
        goto FnExit;
    }

    //
    // Check if the resource has been initialized. If not, return
    // success because the resource is not online.
    //
    if ( pResource->Monitor == NULL ) 
    {
        dwStatus = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 4/8/99
    //  
    //  Don't attempt to do anything if the resource has failed. You could
    //  get into some funny cases in which the resource switches between
    //  offline pending and failed states for ever.
    //
    if ( pResource->State == ClusterResourceFailed ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }
    
FnExit:
    return(dwStatus);

} // FmpValOfflineResource



DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Validation routine for dependency addition.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //if the resource has been marked for delete, then dont let
    //it be brought online
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if (pResource->QuorumResource)
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((pResource->Group != pDependentResource->Group) ||
        (pResource == pDependentResource)) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // The resource to which the dependency is being added must be offline
    // Otherwise, it looks like the dependency is in effect when the depending
    // resource was not really brought online at the time the dependency existed
    // must also be offline or failed.
    // SS:  For instance if a network name is dependent on two ip addresesses and
    // is online and a third ip address resource dependency is added, the
    // network name must be brought offline and online for the dependency
    // to be truly in effect
    //
    if ((pResource->State != ClusterResourceOffline) &&
         (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Make sure that we don't have any circular dependencies!
    //
    if ( FmDependentResource( pDependentResource, pResource, FALSE ) ) 
    {
        dwStatus = ERROR_CIRCULAR_DEPENDENCY;
        goto FnExit;
    }

    //
    // Make sure that this dependency does not already exist!
    //
    if ( FmDependentResource(pResource, pDependentResource, TRUE)) 
    {
        dwStatus = ERROR_DEPENDENCY_ALREADY_EXISTS;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValAddResourceDependency


DWORD
FmpValChangeResourceNode(
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszNodeId,
    IN BOOL         bAdd,
    OUT PGUM_CHANGE_POSSIBLE_NODE *ppGumChange,
    OUT PDWORD      pdwBufSize
    )

/*++

Routine Description:

    Validation routine for changing the possible owner node of a resource.

Arguments:

    pResource - A pointer to the resource structure.

    pszNodeId - A pointer to the node id

    bAdd - Indicates add or remove

    ppGumChange - Message buffer to hold the resource info

    pdwBufSize - Size of the message buffer
    
Comments: 

    Lock must be held when this routine is called

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL    bNodeSupportsResType = FALSE;
    LPCWSTR pszResourceId;
    DWORD   dwResourceLen;
    DWORD   dwNodeLen;
    DWORD   dwBufSize;
    PGUM_CHANGE_POSSIBLE_NODE   pGumChange;

    *ppGumChange = NULL;
    *pdwBufSize = 0;


    //if the resource has been marked for delete, then perform
    //any operations on it
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( pResource->QuorumResource ) 
    {
        dwStatus = ERROR_INVALID_OPERATION_ON_QUORUM;
        goto FnExit;
    }

    //
    // We can't allow the owner node to be removed if the state
    // of the resource or the group is not offline or failed.
    //
    if ( !bAdd &&
         (lstrcmpi(NodeId, OmObjectId(NmLocalNode)) == 0) &&
         (((pResource->State != ClusterResourceOffline) &&
            (pResource->State != ClusterResourceFailed)) ||
         (FmpGetGroupState( pResource->Group, TRUE ) != ClusterGroupOffline)) ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }

    //make sure the node is on the list of possible nodes for this
    // resource type
    if (bAdd)
    {
        pListEntry = &(pResource->Type->PossibleNodeList);
        for (pListEntry = pListEntry->Flink; 
            pListEntry != &(pResource->Type->PossibleNodeList);
            pListEntry = pListEntry->Flink)
        {    

            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

            if (!lstrcmpW(OmObjectId(pResTypePosEntry->PossibleNode), pszNodeId))
            {
                bNodeSupportsResType = TRUE;
                break;
            }            
                    
        }    
    
        if (!bNodeSupportsResType)
        {
            dwStatus = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
    }
    
    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    dwNodeLen = (lstrlenW(pszNodeId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_POSSIBLE_NODE) - sizeof(WCHAR) + 
                    dwResourceLen + dwNodeLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszNodeId,
               dwNodeLen);


    *ppGumChange = pGumChange;
    *pdwBufSize = dwBufSize;

FnExit:    
    return(dwStatus);
} // FmpValChangeResourceNode


DWORD
FmpValChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup,
    OUT PGUM_CHANGE_GROUP  *ppGumChange,
    OUT LPDWORD     pdwBufSize)
/*++

Routine Description:

    Validation routine for changing a resource's group.

Arguments:

    pResource - Pointer to the resource structure

    pNewGroup - Pointer to the group to which the resource is moved to

    ppGumChange - Message buffer to hold the resource info

    pdwBufSize - Size of the message buffer

Comments: 

    Lock must be held when this routine is called

Returns:

    ERROR_SUCCESS if validation is successful.

    A Win32 error code otherwise.

--*/
{
    DWORD               dwBufSize;
    LPCWSTR             pszResourceId;
    DWORD               dwResourceLen;
    LPCWSTR             pszGroupId;
    DWORD               dwGroupLen;
    DWORD               dwStatus = ERROR_SUCCESS;
    PGUM_CHANGE_GROUP   pGumChange;
    
    *pdwBufSize = 0;
    *ppGumChange = NULL;

    // we need to validate here as well
    // this is called by the server side
    // this will help avoid a gum call if things have changed
    // since the request started from the originator
    // and got to the server
    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(pResource))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) 
    {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) 
    {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnExit;
    }


    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    pszGroupId = OmObjectId(pNewGroup);
    dwGroupLen = (lstrlenW(pszGroupId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_GROUP) - sizeof(WCHAR) + dwResourceLen + dwGroupLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszGroupId,
               dwGroupLen);

    *ppGumChange = pGumChange;
    *pdwBufSize = dwBufSize;
    
FnExit:
    return(dwStatus);
} // FmpValChangeResourceGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\ioctl.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Resource and Resource Type control functions.

Author:

    John Vert (jvert) 10/16/1996

Revision History:

--*/
#include "fmp.h"

#define LOG_MODULE IOCTL


DWORD
WINAPI
FmResourceControl(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    Resource - Supplies the resource to be controlled.

    Node - Supplies the node on which the resource control should
           be delivered. If this is NULL, then if the owner is up, it
           is used.  Else one of the other possible nodes is used.
           Else, one of the nodes that can support a resource of this type is used.
           

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD           status;
    PNM_NODE        node;

    //SS: dont require FM to be online, since these calls
    //can be made by the Open() call in resource dlls which
    //is called before the resource is online.
    //FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_RESOURCE ) {
        return(ERROR_INVALID_FUNCTION);
    }


    //
    // If a Node was specified, then ship the request off to that node.
    //
    if ( Node != NULL ) {
        if ( Node == NmLocalNode ) {
            status = FmpRmResourceControl( Resource,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        } else {
            status = FmcResourceControl( Node,
                                         Resource,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        }
    } else {

        PLIST_ENTRY             pListEntry;
        PPOSSIBLE_ENTRY         pPossibleEntry;

        pListEntry = &Resource->PossibleOwners;
        node = Node;

        //
        // If there is no supplied node, then use a possible node that is up.
        //

        for (pListEntry = pListEntry->Flink; pListEntry != &Resource->PossibleOwners;
            pListEntry = pListEntry->Flink)
        {
            pPossibleEntry = CONTAINING_RECORD(pListEntry, POSSIBLE_ENTRY, 
                    PossibleLinkage);

            // if Node is not given, then attempt to use a node that is
            // UP - giving preference to the group owner node node.
            node = pPossibleEntry->PossibleNode;
            if ( node == Resource->Group->OwnerNode ) {
                break;
            } 
            if ( NmGetNodeState(node) != ClusterNodeUp ) {
                node = NULL;
                // try again
            }
        }

        //if no such node was found, find a node that can host this resource type
        if (!node)
        {
            PFM_RESTYPE             pResType;
            PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
            PNM_NODE                prev_node = NULL;

            pResType = Resource->Type;
            // protect with the ResType lock

            ACQUIRE_SHARED_LOCK(gResTypeLock);
            
            pListEntry = &pResType->PossibleNodeList;

            //
            // If there is no supplied node, then use a possible node that is up.
            //

            for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
                pListEntry = pListEntry->Flink)
            {
                pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                        PossibleLinkage);

                // if Node is not given, then attempt to use a node that is
                // UP - giving preference to the local node.
                node = pResTypePosEntry->PossibleNode;
                if ( node == NmLocalNode ) {
                    break;
                } 
                if ( NmGetNodeState(node) != ClusterNodeUp ) {
                    node = NULL;
                    // try again
                }
                else
                    if (prev_node == NULL)
                        prev_node = node;
            }

            RELEASE_LOCK(gResTypeLock);

            if(!node && prev_node)
                node=prev_node;        

        }

        //if we still dont have a node, we have to throw up a failure
        if ( !node ) {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            return(status);
        }

        //
        // If we are the owner, then do the work, otherwise...
        // Ship the request off to the owner node.
        //
        if ( node == NmLocalNode ) {
            status = FmpRmResourceControl( Resource,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        } else {
            status = FmcResourceControl( node,
                                         Resource,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        }
    }

    return(status);

} // FmResourceControl


DWORD
WINAPI
FmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type to be
        controlled.

    Node - Supplies the node on which the resource control should be
        delivered. If this is NULL, the local node is used.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   retry = TRUE;
    PNM_NODE node = NULL;
    PNM_NODE prev_node=NULL;
    PFM_RESTYPE pResType = NULL;

    FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_RESOURCE_TYPE ) {
        status = ERROR_INVALID_FUNCTION;
        goto FnExit;
    }



    //find a node that can handle this resource type control
    pResType = OmReferenceObjectById(ObjectTypeResType,
                ResourceTypeName);
    if (!pResType)
    {
        status = ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
        goto FnExit;
    }

retry_search:
    prev_node = NULL;
    //if node wasnt specified choose a node
    if ( !Node ) 
    {
        PLIST_ENTRY             pListEntry;
        PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;
        
        // protect with the ResType lock

        ACQUIRE_SHARED_LOCK(gResTypeLock);
        
        pListEntry = &pResType->PossibleNodeList;

        //
        // If there is no supplied node, then use a possible node that is up.
        //

        for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
            pListEntry = pListEntry->Flink)
        {
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                    PossibleLinkage);

            // if Node is not given, then attempt to use a node that is
            // UP - giving preference to the local node.
            node = pResTypePosEntry->PossibleNode;
            if ( node == NmLocalNode ) {
                break;
            } 
            if ( NmGetNodeState(node) != ClusterNodeUp ) {
                node = NULL;
                // try again
            }
            else
                if (prev_node == NULL)
                    prev_node = node;
        }

        RELEASE_LOCK(gResTypeLock);

        
        if(!node && prev_node)
            node=prev_node;        

        // node should now contain a valid node to use or NULL!
        // if NULL, then let's see if the required ResDLL has been updated
        // on some other nodes.        
        if ( !node &&
             retry ) {
            retry = FALSE;
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmResourceTypeControl: No possible nodes for restype %1!ws!, "
                          "calling FmpSetPossibleNodeForRestype\r\n",
                          ResourceTypeName);
            FmpSetPossibleNodeForResType( ResourceTypeName, TRUE );
            // ignore status
            goto retry_search;
        }

        // node should now contain a valid node to use or NULL!
        // if NULL, then it is hopeless!
        if ( !node ) {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }

    }
    else
    {
        // If the supplied node is on the list of possible nodes, then use it.
        // else return error
        if (!FmpInPossibleListForResType(pResType, Node))
        {
            // either the restype is not supported - or the supporting node is
            // not up!
            status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
        node = Node;
    }

    
    CL_ASSERT(node != NULL);

    if ( (node != NmLocalNode) &&
         (NmGetNodeState(node) != ClusterNodeUp) ) {
        status = ERROR_HOST_NODE_NOT_AVAILABLE;
        goto FnExit;
    }

    //
    // If the node is remote, then ship the request off to that node, else
    // do the work locally.
    //
    if ( node == NmLocalNode ) 
    {
        status = FmpRmResourceTypeControl( ResourceTypeName,
                                           ControlCode,
                                           InBuffer,
                                           InBufferSize,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required
                                           );
        //if no node was specified and the local node doesnt support the resource
        //dll, remove it from the list and then retry
        if ((Node == NULL) && 
                ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND)))
        {
            ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmResourceTypeControl: Removing Local Node from Possible Owners List for %1!ws! restype because of error %2!u! \r\n",
                        ResourceTypeName,status);                                       
            FmpRemovePossibleNodeForResType(ResourceTypeName, NmLocalNode);
            node = NULL;
            retry = FALSE;
            goto retry_search;

        }
    } 
    else 
    {
        status = FmcResourceTypeControl( node,
                                         ResourceTypeName,
                                         ControlCode,
                                         InBuffer,
                                         InBufferSize,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required
                                         );
        if ((Node == NULL) && 
                ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND)))
        {
            node = NULL;
            retry = FALSE;
            goto retry_search;
        }

    }


FnExit:
    if (pResType)
        OmDereferenceObject(pResType);
    return(status);

} // FmResourceTypeControl


DWORD
WINAPI
FmGroupControl(
    IN PFM_GROUP Group,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    Group - Supplies the group to be controlled.

    Node - Supplies the node on which the resource control should
           be delivered. If this is NULL, the node where the group
           is owned is used.

    ControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    FmpMustBeOnline( );

    //
    // TODO - we should verify the access mode - in the future!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_GROUP ) {
        return(ERROR_INVALID_FUNCTION);
    }


    //
    // If a Node was specified, then ship the request off to that node, else
    //
    // If we are the owner, then do the work, otherwise...
    // Ship the request off to the owner node.
    //
    if ( (Node != NULL) && (Node != NmLocalNode) ) 
    {
        status = FmcGroupControl( Node,
                                  Group,
                                  ControlCode,
                                  InBuffer,
                                  InBufferSize,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required
                                  );
    } 
    else 
    {

        CL_ASSERT( Group != NULL );
        if ( (Node == NULL) &&
             (Group->OwnerNode != NmLocalNode) ) 
        {
            status = FmcGroupControl( Group->OwnerNode,
                                      Group,
                                      ControlCode,
                                      InBuffer,
                                      InBufferSize,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      Required
                                      );
        } 
        else 
        {
            status = FmpGroupControl( Group, ControlCode, InBuffer,
                         InBufferSize, OutBuffer, OutBufferSize, BytesReturned, Required);
        }
    }

    return(status);

} // FmGroupControl

DWORD
FmpGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
{
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;
    DWORD   status;

    //
    // Handle any requests that must be done without locks helds.
    //

    switch ( ControlCode ) {

        case CLUSCTL_GROUP_GET_COMMON_PROPERTY_FMTS:
            status = ClRtlGetPropertyFormats( FmpGroupCommonProperties,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
            break;


        case CLUSCTL_GROUP_GET_NAME:
            if ( OmObjectName( Group ) == NULL ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Group ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Group ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_GROUP_GET_ID:
            if ( OmObjectId( Group ) == NULL ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Group ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Group ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        default:
            break;

    }

    FmpAcquireLocalGroupLock( Group );
    
    status = FmpHandleGroupControl( Group,
                                    ControlCode,
                                    InBuffer,
                                    InBufferSize,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required
                                    );
    FmpReleaseLocalGroupLock( Group );
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {

        ClusterWideEvent(
            CLUSTER_EVENT_GROUP_PROPERTY_CHANGE,
            Group
            );
    }

    return(status);

}



DWORD
WINAPI
FmpHandleGroupControl(
    IN PFM_GROUP Group,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    Group - Supplies the group to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    switch ( ControlCode ) {

    case CLUSCTL_GROUP_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_GROUP_GET_FLAGS:
        status = FmpGroupGetFlags( Group,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );
        break;

    case CLUSCTL_GROUP_ENUM_COMMON_PROPERTIES:
        status = FmpGroupEnumCommonProperties( OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES:
        status = FmpGroupGetCommonProperties( Group,
                                              TRUE,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
        status = FmpGroupGetCommonProperties( Group,
                                              FALSE,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES:
        status = FmpGroupValidateCommonProperties( Group,
                                                   InBuffer,
                                                   InBufferSize );
        break;

    case CLUSCTL_GROUP_SET_COMMON_PROPERTIES:
        status = FmpGroupSetCommonProperties( Group,
                                              InBuffer,
                                              InBufferSize );
        break;

    case CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_GROUP_ENUM_PRIVATE_PROPERTIES:
        status = FmpGroupEnumPrivateProperties( Group,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
        break;

    case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
        status = FmpGroupGetPrivateProperties( Group,
                                               OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES:
        status = FmpGroupValidatePrivateProperties( Group,
                                                    InBuffer,
                                                    InBufferSize );
        break;

    case CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES:
        status = FmpGroupSetPrivateProperties( Group,
                                               InBuffer,
                                               InBufferSize );
        break;

    case CLUSCTL_GROUP_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    return(status);

} // FmpHandleGroupControl


/****
@func       DWORD | FmNetNameParseProperties| Updates the cluster name in
            the cluster database.

@parm       PUCHAR | InBuffer | A pointer to special property list.

@parm       DWORD | InBufferSize | The size of the InBuffer in bytes.

@parm       LPCWSTR | * ppszClusterName | A cluster name string is returned via this.

@comm       The string must be freed by the caller using LocalFree().

@rdesc      returns ERROR_SUCCESS if successful in getting the cluster name
            from the private properties.

@xref
****/
DWORD
FmNetNameParseProperties(
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT LPWSTR *ppszClusterName)
{
    //
    // Find the Cluster Name property
    //
    *ppszClusterName = NULL;

    return (ClRtlpFindSzProperty(
            InBuffer,
            InBufferSize,
            CLUSREG_NAME_NET_NAME,
            ppszClusterName,
            TRUE
            ));

} // FmNetNameParseProperties


/****
@func       DWORD | FmGetDiskInfoParseProperties| Updates the cluster name in
            the cluster database.

@parm       PUCHAR | InBuffer | A pointer to special property list.

@parm       DWORD | InBufferSize | The size of the InBuffer in bytes.

@parm       LPWSTR | pszPath | If this a null string, the first drive letter
            on the disk resource is returned, else you can validate
            a path of form "g:" on this storage class resource.

@comm       The string must be freed by the caller using LocalFree().

@rdesc      returns ERROR_SUCCESS if successful in getting the cluster name
            from the private properties.

@xref
****/
DWORD FmpGetDiskInfoParseProperties(
    IN PUCHAR   InBuffer,
    IN DWORD    InBufferSize,
    IN OUT LPWSTR  pszPath)
{
    DWORD                       status = ERROR_INVALID_PARAMETER;
    DWORD                       dwValueSize;
    CLUSPROP_BUFFER_HELPER      props;
    PCLUSPROP_PARTITION_INFO    pPartitionInfo;
    WCHAR                       szRootPath[MAX_PATH];

    props.pb = InBuffer;

    szRootPath[0] = L'\0';

    //
    // Set defaults in the parameter block.
    //

    // Loop through each property.
    while ( (InBufferSize > sizeof(CLUSPROP_SYNTAX)) &&
            (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) )
    {
        // Get the size of this value and verify there is enough buffer left.
        dwValueSize = sizeof(*props.pValue) + ALIGN_CLUSPROP( props.pValue->cbLength );
        if ( dwValueSize > InBufferSize )
        {
            break;
        }

        if ( props.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            // Validate the data.  There must be a device name.
            pPartitionInfo = props.pPartitionInfoValue;
            if ( (dwValueSize != sizeof(*pPartitionInfo)) ||
                 (pPartitionInfo->szDeviceName[0] == L'\0'))
            {
                break;
            }

            if (!(pPartitionInfo->dwFlags & CLUSPROP_PIFLAG_USABLE))
            {
                //check that it is formatted with NTFS.
                //if it is not usable,skip to the next one
                goto SkipToNext;
            }
            
            if (pszPath[0] == L'\0')
            {
                //
                //  Chittur Subbaraman (chitturs) - 12/12/2000
                //
                //  Save the first available NTFS partition if the user does not explicitly
                //  indicate any partition in the SetClusterQuorumResource API. This path will be 
                //  returned in two cases. 
                //
                //  (1) This cluster is a Whistler-Win2K cluster and the quorum disk
                //  is currently owned by the Win2K node. The Win2K disk resource does not
                //  set the CLUSPROP_PIFLAG_DEFAULT_QUORUM flags and so we have to revert the
                //  behavior of the SetClusterQuorumResource API to the old behavior. 
                //
                //  (2) A pre-Whistler third party implemented quorum resource is used in a 
                //  Whistler cluster. In this case, this resource may not support the
                //  CLUSPROP_PIFLAG_DEFAULT_QUORUM flags and so we have to revert the
                //  behavior of the SetClusterQuorumResource API to the old behavior.
                //  
                if ( szRootPath[0] == L'\0' )
                {
                    lstrcpyW( szRootPath, pPartitionInfo->szDeviceName );
                }

                //
                //  See whether you can find a default quorum partition (one that is
                //  larger than 50 MB and still the minimum among the usable partitions.)
                //
                if ( !( pPartitionInfo->dwFlags & CLUSPROP_PIFLAG_DEFAULT_QUORUM ) )
                {
                    goto SkipToNext;
                }

                // Construct a path from the device name.
                lstrcpyW( pszPath, pPartitionInfo->szDeviceName );
                status = ERROR_SUCCESS;
                break;
            }
            else
            {
                // Construct a path from the device name.
                if (!lstrcmpiW( pszPath, pPartitionInfo->szDeviceName ))
                {
                    status = ERROR_SUCCESS;
                    break;
                }
            }
        }

SkipToNext:
        InBufferSize -= dwValueSize;
        props.pb += dwValueSize;
    }

    //
    //  No path was found. However, a usable path got saved. So, use this saved path.
    //
    if ( ( status != ERROR_SUCCESS ) && ( szRootPath[0] != L'\0' ) )
    {
        lstrcpyW( pszPath, szRootPath );
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpGetDiskInfoParseProperties: Using saved path %1!ws!...\n",
                      pszPath);
        status = ERROR_SUCCESS;    
    }
    
    return(status);

} // FmpGetDiskInfoParseProperties


DWORD
FmpBroadcastDeleteControl(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Broadcasts a resource control to each node that notifies it that
    the resource is being deleted.

Arguments:

    Resource - Supplies the resource that is being deleted.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    DWORD   characteristics;
    DWORD   i;
    PNM_NODE Node;

    //
    // Only perform the broadcast if delete notification is required.
    // Otherwise, just perform the notification on the local node.
    //
    status = FmpRmResourceControl( Resource,
                                   CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                   NULL,
                                   0,
                                   (PUCHAR)&characteristics,
                                   sizeof(DWORD),
                                   NULL,
                                   NULL );
    if ( (status != ERROR_SUCCESS) ||
         !(characteristics & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES) ) {
        //
        // Note: the following 'local node only' notification is fairly useless.
        //
        FmpRmResourceControl( Resource,
                              CLUSCTL_RESOURCE_DELETE,
                              NULL,
                              0,
                              NULL,
                              0,
                              NULL,
                              NULL );
        return(ERROR_SUCCESS);
    }

    //
    // All nodes must be up in the cluster in order to perform this operation.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        Node = NmReferenceNodeById(i);
        if ( Node != NULL ) {
            if ( NmGetNodeState(Node) != ClusterNodeUp ) {
                return(ERROR_ALL_NODES_NOT_AVAILABLE);
            }
        }
    }

    //
    // Passed all checks, now broadcast to all nodes in the cluster.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        //
        // If this is the local node, do the ioctl directly
        //
        if (i == NmLocalNodeId) {
            FmpRmResourceControl( Resource,
                                  CLUSCTL_RESOURCE_DELETE,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL );

        } else {
            Node = NmReferenceNodeById(i);
            if ((Node != NULL) &&
                (NmGetNodeState(Node) == ClusterNodeUp)) {
                CL_ASSERT(Session[i] != NULL);

                FmcResourceControl( Node,
                                    Resource,
                                    CLUSCTL_RESOURCE_DELETE,
                                    NULL,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
                OmDereferenceObject(Node);
            }
        }
    }

    return(ERROR_SUCCESS);

} // FmpBroadcastDeleteControl

DWORD
FmpBroadcastDependencyChange(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR DependsOnId,
    IN BOOL Remove
    )
/*++

Routine Description:

    Broadcasts a resource control to each node that notifies it that
    the resource has had a dependency added or removed.

Arguments:

    Resource - Supplies the resource that has had the dependency added
               or removed

    DependsOnId - Supplies the id of the provider resource

    Remove - TRUE indicates that the dependency is being removed
             FALSE indicates that the dependency is being added.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   i;
    PNM_NODE Node;
    DWORD Control;
    DWORD Length;
    PFM_RESOURCE providerResource;

    if (Remove) {
        Control = CLUSCTL_RESOURCE_REMOVE_DEPENDENCY;
    } else {
        Control = CLUSCTL_RESOURCE_ADD_DEPENDENCY;
    }

    //
    // Get the provider resource.
    //
    providerResource = OmReferenceObjectById( ObjectTypeResource,
                                              DependsOnId );
    if ( providerResource == NULL )  {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    Length = (lstrlenW(OmObjectName(providerResource)) + 1) * sizeof(WCHAR);

    //
    // Broadcast to all nodes in the cluster.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) {
        //
        // If this is the local node, do the ioctl directly
        //
        if (i == NmLocalNodeId) {
            FmpRmResourceControl( Resource,
                                  Control,
                                  (PUCHAR)OmObjectName(providerResource),
                                  Length,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL );

        } else {
            Node = NmReferenceNodeById(i);
            if ((Node != NULL) &&
                (NmGetNodeState(Node) == ClusterNodeUp)) {
                CL_ASSERT(Session[i] != NULL);

                FmcResourceControl( Node,
                                    Resource,
                                    Control,
                                    (PUCHAR)OmObjectName(providerResource),
                                    Length,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );
                OmDereferenceObject(Node);
            }
        }
    }

    OmDereferenceObject( providerResource );

    return(ERROR_SUCCESS);

} // FmpBroadcastDeleteControl


/****
@func       DWORD | FmpGetResourceCharacteristics| Gets the characteristics
            for a given resource.

@parm       IN PFM_RESOURCE | pResource | Points to a FM_RESOURCE.
            
@parm       OUT LPDWORD | pdwCharacteristics | The ID of the dead node.

@comm       This is used to get the quorum characteristics during join since
            local quorums cant support multi-node clusters.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD FmpGetResourceCharacteristics(
    IN PFM_RESOURCE pResource,
    OUT LPDWORD pdwCharacteristics)
{

    DWORD   dwStatus;

    dwStatus = FmpRmResourceControl( pResource,
                                   CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                   NULL,
                                   0,
                                   (PUCHAR)pdwCharacteristics,
                                   sizeof(DWORD),
                                   NULL,
                                   NULL );

    SetLastError(dwStatus);
    return (dwStatus);
}

VOID
FmpClusterWideInitializeResource(
    IN PFM_RESOURCE pResource
    )
/*++

Routine Description:

    Initialize the supplied resource cluster wide.

Arguments:

    pResource - Supplies the resource that is being deleted.

Return Value:

    None.

Notes:

    This call MUST be made with local group lock held.
    
--*/

{
    DWORD           i, dwStatus = ERROR_SUCCESS;
    DWORD           dwClusterHighestVersion;
    PNM_NODE        pNode;   

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    //
    //  No actions on mixed mode clusters
    //
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < NT51_MAJOR_VERSION ) return;

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpClusterWideInitializeResource: Entry for resource %1!ws! [%2!ws!]...\n",
                  OmObjectName(pResource),
                  OmObjectId(pResource));              

    //
    //  Walk the complete node list and drop controls to nodes that are UP.
    //
    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; i++ ) 
    {
        //
        // If this is the local node, do the ioctl directly
        //
        if ( i == NmLocalNodeId ) 
        {
            dwStatus = FmpRmResourceControl( pResource,
                                             CLUSCTL_RESOURCE_INITIALIZE,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );

            if ( dwStatus != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpClusterWideInitializeResource: Control to local node returns status %1!u!...\n",
                              dwStatus);                 
            }
        } else 
        {
            pNode = NmReferenceNodeById( i );

            //
            // Since we are looping through the complete node set, this error is understandable.
            //
            if ( pNode == NULL ) continue;

            //
            // If this node is not UP, you continue on with the next node. Log stuff so you know
            // we didn't drop the control to that node.
            //
            if ( NmGetExtendedNodeState( pNode ) != ClusterNodeUp ) 
            {
                OmDereferenceObject( pNode );
                ClRtlLogPrint(LOG_NOISE, "[FM] FmpClusterWideInitializeResource: Node %1!ws! (ID=%2!u!) is not UP, no control sent...\n",
                              OmObjectName( pNode ),
                              i);              
                continue;               
            }

            //
            //  Send the control to the remote node.
            //
            dwStatus = FmcResourceControl( pNode,
                                           pResource,
                                           CLUSCTL_RESOURCE_INITIALIZE,
                                           NULL,
                                           0,
                                           NULL,
                                           0,
                                           NULL,
                                           NULL );

            if ( dwStatus != ERROR_SUCCESS )
            {
                ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpClusterWideInitializeResource: Control to node %1!ws! (ID=%2!u!) returns status %3!u!...\n",
                              OmObjectName(pNode),
                              OmObjectId(pNode),
                              dwStatus);                 
            }
            
            OmDereferenceObject( pNode );
        }
    }// for

    ClRtlLogPrint(LOG_NOISE, "[FM] FmpClusterWideInitializeResource: Exit with status %1!u!...\n",
                  dwStatus);                 
}// FmpClusterWideInitializeResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\grouparb.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    grouparb.c

Abstract:

    Cluster group arbitration and sorting routines.

Author:

    Rod Gamache (rodga) 8-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE GROUPARB

//
// Global data
//

//
// Local function prototypes
//

typedef struct FM_GROUP_ENUM_DATA {
    DWORD Allocated;
    LPCWSTR pszOwnerNodeId;
    BOOL  QuorumGroup;
} FM_GROUP_ENUM_DATA, *PFM_GROUP_ENUM_DATA;


BOOL
FmpEnumGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN PFM_GROUP_ENUM_DATA EnumData,
    IN PFM_GROUP        Group,
    IN LPCWSTR          Name
    );

BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    );

int
_cdecl
SortCompare(
    IN const void * Elem1,
    IN const void * Elem2
    );


DWORD
FmpEnumSortGroups(
    OUT PGROUP_ENUM *ReturnEnum,
    IN OPTIONAL LPCWSTR pszOwnerNodeId,
    OUT PBOOL  QuorumGroup
    )

/*++

Routine Description:

    Enumerates and sorts the list of Groups.

Arguments:

    ReturnEnum - Returns the requested objects.

    pszOwnerNodeId - If present, supplies the owner node to filter
                     the list of groups. (i.e. if you supply this, you
                     get a list of groups owned by that node)

                     If not present, all groups are returned.

    QuorumGroup - Returns TRUE if the quorum resource in one of the groups
                returned in the ENUM.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

--*/

{
    DWORD status;
    PGROUP_ENUM groupEnum = NULL;
    FM_GROUP_ENUM_DATA EnumData;

    EnumData.Allocated = ENUM_GROW_SIZE;
    EnumData.pszOwnerNodeId = pszOwnerNodeId;
    EnumData.QuorumGroup = FALSE;

    groupEnum = LocalAlloc(LMEM_FIXED, GROUP_SIZE(ENUM_GROW_SIZE));
    if ( groupEnum == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    groupEnum->EntryCount = 0;

    //
    // Enumerate all groups, sort with Quorum Group first in the list.
    //

    OmEnumObjects(ObjectTypeGroup,
                FmpEnumGroups,
                &groupEnum,
                &EnumData);


    *ReturnEnum = groupEnum;
    *QuorumGroup = EnumData.QuorumGroup;
    return(ERROR_SUCCESS);

error_exit:

    if ( groupEnum != NULL ) {
        LocalFree( groupEnum );
    }

    *ReturnEnum = NULL;
    *QuorumGroup = FALSE;
    return(status);

} // FmpEnumSortGroups



DWORD
FmpGetGroupListState(
    PGROUP_ENUM GroupEnum
    )

/*++

Routine Description:

    This routine gets the Group state for each of the Groups in the list.

Arguments:

    GroupEnum - The list of Groups we now own.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD i;

    for ( i = 0; i < GroupEnum->EntryCount; i++ ) {
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       GroupEnum->Entry[i].Id );
        if ( group == NULL ) {
            return(ERROR_GROUP_NOT_FOUND);
        }

        ClRtlLogPrint( LOG_NOISE,
            "[FM] GetGroupListState, Group <%1!ws!> state = %2!d!\n",
            OmObjectName(group), group->State );
        if ( (group->State == ClusterGroupFailed) ||
             (group->State == ClusterGroupPartialOnline) ) {
            GroupEnum->Entry[i].State = ClusterGroupOnline;
        } else {
            GroupEnum->Entry[i].State = group->State;
        }

        OmDereferenceObject( group );
    }

    return(ERROR_SUCCESS);

} // FmpGetGroupListState



DWORD
FmpOnlineGroupList(
    IN PGROUP_ENUM GroupEnum,
    IN BOOL bPrepareQuoForOnline
    )

/*++

Routine Description:

    Brings online all Groups in the Enum list. If the quorum group
    is present in the list, then it must be first.

Arguments:

    GroupEnum - The list of Groups to bring online.

    bPrepareQuoForOnline - Indicates whether the quorum resource should be 
    forced prepared for onlining
Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD   status = ERROR_SUCCESS;
    int     i;
    int     iQuoGroup=-1;

    //
    // see if the quorum group is present in the list.
    //
    if ( NmGetNodeId(NmLocalNode) == NmGetNodeId( gpQuoResource->Group->OwnerNode ) ) 
    {
        for ( i = 0; (DWORD)i < GroupEnum->EntryCount; i++ ) 
        {
            if (!lstrcmpW(OmObjectId(gpQuoResource->Group), GroupEnum->Entry[i].Id))
            {
                iQuoGroup = i;
                break;
            }
        }
    }
    
    //if quorum group was found, bring it online first. It would normally
    //be first in the list.
    //the quorum group online must return success, or invalid state
    //because of the online pending quorum resource.
    //if the quorum resource needs to be brought online, it must
    //be brought into online or online pending state.  This is
    // not required in fix quorum mode.

    if (iQuoGroup != -1)
    {
        ClRtlLogPrint(LOG_NOISE,
             "[FM] FmpOnlineGroupList: bring quorum group online\n");
        status = FmpOnlineGroupFromList(GroupEnum, iQuoGroup, bPrepareQuoForOnline);
        if ( status != ERROR_SUCCESS && status != ERROR_IO_PENDING) 
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineGroupFromList: quorum online returned %1!u!.\n",
                       status );
            CL_LOGFAILURE(status);
        }

    }

    // bring the non-quorum groups online
    for ( i = 0; (DWORD)i < GroupEnum->EntryCount; i++ ) 
    {
        //quorum resource should be online now
        if (i != iQuoGroup)
            FmpOnlineGroupFromList(GroupEnum, i, bPrepareQuoForOnline);
    }


    return(status);

} // FmpOnlineGroupList
    

DWORD FmpOnlineGroupFromList(
    IN PGROUP_ENUM GroupEnum,
    IN DWORD       Index,
    IN BOOL        bPrepareQuoForOnline
)
{

    PFM_GROUP group;
    DWORD     status=ERROR_SUCCESS; //assume success
    PLIST_ENTRY listEntry;
    PFM_RESOURCE resource;
    
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupEnum->Entry[Index].Id );

    //
    // If we fail to find a group, then just continue.
    //
    if ( group == NULL ) {
        status = ERROR_GROUP_NOT_FOUND;
        return(status);
    }

    FmpAcquireLocalGroupLock( group );
    
    if (group->OwnerNode != NmLocalNode) {
        FmpReleaseLocalGroupLock( group );
        OmDereferenceObject(group);
        return (ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }
  
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineGroupFromList: Previous group state for %1!ws! is %2!u!\r\n",
               OmObjectId(group), GroupEnum->Entry[Index].State);

    //
    // First make sure the group has completed initialization.
    //
    FmpCompleteInitGroup( group );

    //
    // First check if the Group failed to initialize. If so,
    // then attempt a failover immediately.
    //
    if ( GroupEnum->Entry[Index].State == ClusterGroupPartialOnline ) {
        GroupEnum->Entry[Index].State = ClusterGroupOnline;
    }

    if (!bPrepareQuoForOnline)
    {
        //
        // Normalize the state of each resource within the group.
        // except the quorum resource - this is because at initialization
        // we dont want to touch the quorum resource
        //
        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry, FM_RESOURCE, ContainsLinkage);

            if ( !resource->QuorumResource ) {
                // don't touch the quorum resource

                switch ( resource->State ) {
                // all active resources should be brought online.
                case ClusterResourceOnlinePending:
                case ClusterResourceOfflinePending:
                case ClusterResourceOnline:
                    resource->State = ClusterResourceOffline;
                    break;

                default:
                    // otherwise do nothing
                    break;
                }
            }
        }
    }
    FmpSignalGroupWaiters( group );

    if ( group->InitFailed ) {
        //
        // Bring the Group online... and then fail it!
        //
        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpOnlineGroupFromList: group->InitFailed is true for %1!ws!\n",
                OmObjectId(group));

        status = FmpOnlineGroup( group, FALSE );
        ClusterEvent( CLUSTER_EVENT_GROUP_FAILED, group );
        OmReferenceObject( group );
        FmpPostWorkItem( FM_EVENT_GROUP_FAILED, group, 0 );
    } else if ((group->PersistentState == ClusterGroupOnline) ||
         (GroupEnum->Entry[Index].State == ClusterGroupOnline) ||
         FmpIsAnyResourcePersistentStateOnline( group ) ) {
        //
        // Chittur Subbaraman (chitturs) - 01/07/2001
        //
        // Now bring the Group online if that is it's current state or if any one of the 
        // resources in the group has an online persistent state.  The third check is
        // required since it is possible for a group to have a persistent state of ClusterGroupOffline,
        // a state of ClusterGroupOffline and yet one or more resources in the group has a persistent 
        // state of ClusterResourceOnline. This happens for a group in which the client never ever 
        // calls OnlineGroup but calls OnlineResource for one or more resources in the group and you
        // reached this call either at the cluster service startup time or as a part of node down
        // processing when the source node died just after the group became ClusterGroupOffline
        // and before the destination node brought the appropriate resources within the group online.
        // In such a case, we still want to bring each resource that has a persistent state of 
        // ClusterResourceOnline to online state. Note that it is tricky to muck with the group 
        // persistent state in an OnlineResource call due to atomicity issues (we really need a 
        // transaction to update both group and resource persistent states in one shot) and also 
        // due to the fuzzy definition of group persistent state when the group has some resources 
        // online and some offline.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpOnlineGroupFromList: trying to bring group %1!ws! online\n",
                      OmObjectId(group));

        status = FmpOnlineGroup( group, FALSE );
        if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
        {
            PRESOURCE_ENUM pResourceEnum;
            // This fn is either called at startup or during
            // a node down event on claiming a group  - so we must 
            // try our darn best to bring resources
            // online after a quorum resource failure
            // With quorum resource failure the failure policy is
            // not invoked for resources so something must try to bring
            // these resources online.  This is why we are adding this
            // here 
            //
            // Get the list of resources in the group and their states.
            //
            status = FmpGetResourceList( &pResourceEnum, group );
            if ( status == ERROR_SUCCESS ) 
            {

                //submit a timer callback to try and bring these resources
                //online
                //the worker thread will clean up the resource list
                FmpSubmitRetryOnline(pResourceEnum, group);
            }                
        }                         
    }

    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );

    return(status);

} // FmpOnlineGroupFromList

DWORD
FmpOnlineResourceFromList(
    IN PRESOURCE_ENUM   ResourceEnum,
    IN PFM_GROUP        pGroup
    )

/*++

Routine Description:

    Brings online all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to bring online.

Comments : This function is called from the worker thread.  We
    dont assume that the resource hasnt changed groups since the
    work item was posted.  The local resource lock is acquired and
    released for each resource.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;

    if ( !FmpFMOnline ||
         FmpShutdown ) {
        return(ERROR_INVALID_STATE);
    }

    //log an event saying we are trying on online a group
    if (pGroup)
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_START_ONLINE, OmObjectName(pGroup));


    // if the quorum resource is contained in here, bring it online first
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);
        
        resource = OmReferenceObjectById( ObjectTypeResource,
                        ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );


        // the resource should not vanish, we are holding the group lock after all
        CL_ASSERT(resource != NULL);

        //
        // If we fail to find a resource, then just continue
        //
        if ( resource != NULL ) {

            //acquire the local resource lock
            FmpAcquireLocalResourceLock(resource);

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceFromList: Previous quorum resource state for %1!ws! is %2!u!\r\n",
                       OmObjectId(resource), ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State);

            if ( (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceOnline) ||
                 (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceFailed) ) {
                //
                // Now bring the resource online if that is it's current state.
                //
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOnlineResourceFromList: trying to bring quorum resource %1!ws! online, state %2!u!\n",
                           OmObjectId(resource),
                           resource->State);

                status = FmpOnlineResource( resource, FALSE );
                if ( status != ERROR_SUCCESS ) {
                    returnStatus = status;
                }
            }
            OmDereferenceObject( resource );
            
            FmpReleaseLocalResourceLock(resource);
            
        }

    }

    // SS::: TODO what happens to the persistent state of the
    // other resources - is it handled correctly - note that this is 
    // called on moving a group
    // Will the restart policy do the right thing in terms of bringing
    // them online
    // if the quorum resource has failed, dont bother trying
    // to bring the rest of the resourcess online
    if ((returnStatus != ERROR_SUCCESS) && (returnStatus != ERROR_IO_PENDING))
    {
        FmpSubmitRetryOnline(ResourceEnum, pGroup);
        goto FnExit;
    }

    // bring online all of the other resources
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );


        //
        // If we fail to find a resource, then just continue.
        //
        if ( resource == NULL ) {
            status = ERROR_RESOURCE_NOT_FOUND;
            continue;
        }

        FmpAcquireLocalResourceLock(resource);
        
        //if the resource has been marked for delete, then dont let
        //it be brought online
        if (!IS_VALID_FM_RESOURCE(resource))
        {
            FmpReleaseLocalResourceLock( resource );
            OmDereferenceObject(resource);
            continue;
        }


        //quorum resource has already been handled 
        if (resource->QuorumResource)
        {
            FmpReleaseLocalResourceLock( resource );
            OmDereferenceObject(resource);
            continue;
        }           
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineResourceFromList: Previous resource state for %1!ws! is %2!u!\r\n",
                   OmObjectId(resource), ResourceEnum->Entry[i].State);

        if ( (ResourceEnum->Entry[i].State == ClusterResourceOnline) ||
             (ResourceEnum->Entry[i].State == ClusterResourceFailed) ) 
        {
            //
            // Now bring the resource online if that is it's current state.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceFromList: trying to bring resource %1!ws! online\n",
                       OmObjectId(resource));

            status = FmpOnlineResource( resource, FALSE );
            if ( returnStatus == ERROR_SUCCESS ) 
            {
                returnStatus = status;
            }
            //if this resource didnt come online because the quorum resource                
            //didnt come online, dont bother bringing the other resources online
            //just a waste of time
            if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
            {
                //submit a timer callback to try and bring these resources
                //online
                FmpReleaseLocalResourceLock( resource );
                OmDereferenceObject( resource );
                FmpSubmitRetryOnline(ResourceEnum, pGroup);
                break;
            }                
        }
        FmpReleaseLocalResourceLock( resource );
        OmDereferenceObject( resource );
    }

FnExit:
    if (returnStatus == ERROR_IO_PENDING)
    {
        if (pGroup)
            pGroup->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT; 
        //the failed or success event will get logged later on
    }
    else if (returnStatus == ERROR_SUCCESS)
    {
        if (pGroup)
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_ONLINE, OmObjectName(pGroup));
    }
    else
    {
        //SS: log an event to say that the online process failed
        if (pGroup)
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(pGroup));
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineResourceFromList: Exit, status=%1!u!\r\n",
               returnStatus);
    return(returnStatus);

} // FmpOnlineResourceFromList



BOOL
FmpEqualGroupLists(
    IN PGROUP_ENUM Group1,
    IN PGROUP_ENUM Group2
    )

/*++

Routine Description:

    This routine verifies that two group lists are equal.

Arguments:

    Group1 - The first group to compare.
    Group2 - The second group to compare.

Returns:

    TRUE - if the two lists are equal.
    FALSE - otherwise.

--*/

{
    DWORD i;

    if ( (Group1 == NULL) ||
         (Group2 == NULL) ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] One of the Group lists is NULL for equality check\n");
        return(FALSE);
    }

    if ( Group1->EntryCount != Group2->EntryCount ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] Group entry counts not equal! Left: %1!u!, Right: %2!u!.\n",
                              Group1->EntryCount, Group2->EntryCount);
        return(FALSE);
    }

    for ( i = 0; i < Group1->EntryCount; i++ ) {
        if ( lstrcmpiW(Group1->Entry[i].Id, Group2->Entry[i].Id) != 0 ) {
            ClRtlLogPrint(LOG_NOISE,"[FM] Group Lists do not have same names!\n");
            return(FALSE);
        }
    }

    return(TRUE);

} // FmpEqualGroupLists



BOOL
FmpEnumGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN PFM_GROUP_ENUM_DATA EnumData,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Groups.
    This routine adds the specified Group to the list that is being
    generated.

Arguments:

    Enum - The Group Enumeration list. Can be an output if a new list is
            allocated.

    EnumData - Supplies the current enumeration data structure.

    Group - The Group object being enumerated.

    Id - The Id of the Group object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

Side Effects:

    Makes the quorum group first in the list.

--*/

{
    PGROUP_ENUM groupEnum;
    PGROUP_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;
    LPWSTR tmpId;
    DWORD  status;
    PFM_RESOURCE quorumResource;

    //HACKHACK::
    //SS: Since this is invoked from within a gum call and
    // the owner node is changed only within a gum call 
    // we wont acquire locks. 
    // there is a window if the dead node is the source of a
    // move and if it does a move after it is declared dead by
    // other nodes, the target of move and the fmpassignownerstogroup
    // might both land up bringing the group online on two nodes
    // However, if we could be guaranteed virtual synchrony, then
    // the target of move wouldnt accept calls from a dead node and
    // we wont land up in this soup.  Now, it is upto the xport layer
    // to provide this guarantee.  
    // For now we acquire no locks 
    
    //FmpAcquireLocalGroupLock( Group );
    
    if ((EnumData->pszOwnerNodeId != NULL) &&
        (lstrcmp(EnumData->pszOwnerNodeId, OmObjectId(Group->OwnerNode))) &&
        ((Group->pIntendedOwner == NULL) || 
          (lstrcmp(EnumData->pszOwnerNodeId, OmObjectId(Group->pIntendedOwner))))) {
        //
        // This group does not match the owner criteria
        //
        //FmpReleaseLocalGroupLock( Group );
        return(TRUE);
    }

    //FmpReleaseLocalGroupLock( Group );

    groupEnum = *Enum;

    if ( groupEnum->EntryCount >= EnumData->Allocated ) {
        //
        // Time to grow the GROUP_ENUM
        //

        newAllocated = EnumData->Allocated + ENUM_GROW_SIZE;
        newEnum = LocalAlloc(LMEM_FIXED, GROUP_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, groupEnum, GROUP_SIZE(EnumData->Allocated));
        EnumData->Allocated = newAllocated;
        *Enum = newEnum;
        LocalFree(groupEnum);
        groupEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = LocalAlloc(LMEM_FIXED, (lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(newId, Id);

    //
    // Find the quorum resource, and see if it is this group.
    //
    status = FmFindQuorumResource( &quorumResource );
    if ( status != ERROR_SUCCESS ) {
        CsInconsistencyHalt(status);
    }
    
    groupEnum->Entry[groupEnum->EntryCount].Id = newId;
    if ( quorumResource->Group == Group ) {
        // found the quorum resource group, put it first in the list.
        tmpId = groupEnum->Entry[0].Id;
        groupEnum->Entry[0].Id = newId;
        groupEnum->Entry[groupEnum->EntryCount].Id = tmpId;
        EnumData->QuorumGroup = TRUE;
    }
    ++groupEnum->EntryCount;

    OmDereferenceObject( quorumResource );

    return(TRUE);

} // FmpEnumGroups

DWORD
FmpClaimAllGroups(
    PGROUP_ENUM MyGroups
    )
/*++

Routine Description:

    Takes ownership of all the groups defined in the cluster. This
    is used when a new cluster is being formed.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise

--*/

{
    //
    // Bring online any Group that needs to be online.
    //
    FmpOnlineGroupList( MyGroups, FALSE );

    return(ERROR_SUCCESS);
}



VOID
FmpDeleteEnum(
    IN PGROUP_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an GROUP_ENUM and associated name strings.

Arguments:

    Enum - The GROUP_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    PGROUP_ENUM_ENTRY enumEntry;
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        enumEntry = &Enum->Entry[i];
        LocalFree(enumEntry->Id);
    }

    LocalFree(Enum);
    return;

} // FmpDeleteEnum


/****
@func       VOID | FmpPrepareGroupForOnline| This routine sets the Group
            up for onlining it on this node post a failure of a node
            or at initialization.

@parm       IN PFM_GROUP | pGroup| A pointer to the group.

@comm       The group lock must be held.  Except when called at bootstrapping
            by FmBringQuorumOnline.
            MUST BE CALLED ONLY BY THE OWNER NODE OF THE GROUP.

@rdesc      returns ERROR_SUCCESS if succesful else w32 error code. 
            MUST BE CALLED ONLY BY THE OWNER NODE OF THE GROUP.
****/
VOID FmpPrepareGroupForOnline(
    IN PFM_GROUP   pGroup
)
{
    PLIST_ENTRY     pListEntry;
    PFM_RESOURCE    pResource;

    pGroup->State = ClusterGroupOffline;
    ++pGroup->StateSequence;
    //
    // Mark offline all of the resources contained within this group.
    //
    for (pListEntry = pGroup->Contains.Flink;
         pListEntry != &pGroup->Contains;
         pListEntry = pListEntry->Flink)
    {
        pResource = CONTAINING_RECORD(pListEntry, FM_RESOURCE, ContainsLinkage);
        pResource->State = ClusterResourceOffline;
        ++pResource->StateSequence;
    }
}

/****
@func       DWORD | FmpSetGroupEnumOwner| This routine sets the Group
            owner for all Groups in the list.

@parm       IN PGROUP_ENUM | pGroupEnum| The list of Groups.
@parm       IN PNM_NODE | pDefaultOwnerNode | A pointer to the default owner
            node.
@parm       IN LPCWSTR | pszDeadNodeId | The ID of the node that died.  If
            this routine is being called other wise, this is set to NULL.
@parm       IN BOOL | bQuorumGroup | set to TRUE if the quorum group is
            on the list of groups.

@parm       IN PFM_GROUP_NODE_LIST | pGroupNodeList | The randomized suggested preferred 
            owner for all groups.

@comm       If the group was in the process of moving and had an intended
            owner and the intended owner is not dead, the intended owner is
            allowed to take care of the group. Else, the first node on the
            preferred list that is up is chosen as the owner.  If no such
            node exits, then the ownership is assigned to the default owner
            provided. This routine is called by the forming node at
            initialization to claimownership of all groups and by the gum
            update procedure FmpUpdateAssignOwnerToGroups.

@rdesc      returns ERROR_SUCCESS if succesful else w32 error code.
****/
DWORD
FmpSetGroupEnumOwner(
    IN PGROUP_ENUM  pGroupEnum,
    IN PNM_NODE     pDefaultOwnerNode,
    IN LPCWSTR      pszDeadNodeId,
    IN BOOL         bQuorumGroup,
    IN PFM_GROUP_NODE_LIST pGroupNodeList
    )
{
    PFM_GROUP   pGroup;
    DWORD       i;
    DWORD       dwStatus = ERROR_SUCCESS;
    PNM_NODE    pOwnerNode;

    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {       
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );
        if ( pGroup == NULL )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetGroupEnumOwner: Group %1!ws! not found\n",
                pGroupEnum->Entry[i].Id);
            dwStatus = ERROR_GROUP_NOT_FOUND;
            goto FnExit;
        }
        //
        // SS: HACKHACK : cant get the group lock within a gum update
	    // FmpAcquireLocalGroupLock( pGroup );
	    //
        // SS: In case of a node death, see if there was an intended owner
        // if the intended owner is set and if the intended owner is
        // not the one that died then we use the normal procedure
        // else we let the intended owner take care of the group.

        //
        // Chittur Subbaraman (chitturs) - 7/26/99
        //
        // Condition 2: Means the group was being moved and FmpTakeGroupRequest
        // has not taken 100% responsibility for the group.
        //
        // Condition 3: Means the source node crashed and NOT the destination node.
        //
        // Added condition 4 to cover the case in which the source node of
        // the move crashed AFTER setting the intended owner as the
        // destination node and BEFORE the FmpTakeGroupRequest has set
        // the group ownership to the destination node.
        //
        // If the group's owner node and the group's intended owner node are
        // not the same, then let this GUM handler take care of assigning
        // the group ownership. This means that the FmpTakeGroupRequest
        // has not yet set the ownership for the group to the destination
        // node of the move. Now, once this GUM handler sets the 
        // ownership for the group and then resets the intended owner to
        // NULL, FmpTakeGroupRequest which could follow behind this GUM handler
        // will not succeed in setting the ownership to the local node and that 
        // will just return doing nothing.  This is TRUE only for an NT5 cluster. 
        // For a mixed-mode cluster, all bets are off.
        //
        if ( (pszDeadNodeId) && 
             (pGroup->pIntendedOwner != NULL) &&
             (lstrcmp ( OmObjectId ( pGroup->pIntendedOwner ), pszDeadNodeId ) ) &&
             (pGroup->OwnerNode == pGroup->pIntendedOwner) )
        {
            //
            //  Chittur Subbaraman (chitturs) - 7/27/99
            //
            //  Looks like this code inside "if" will never ever be
            //  executed. Keeping it so as to make the changes minimal.
            //
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpSetGroupEnumOwner: Group %1!ws! will be handled by node %2!ws!\n",
               OmObjectId(pGroup), OmObjectId(pGroup->pIntendedOwner));
            continue;
        }


        //
        // Find first preferred node that is UP, if we can't find any use
        // default OwnerNode
        //
        //
        // If this is the quorum group, then use the node that was selected
        // by the MM layer. The quorum group is the first entry in the list
        // and the Boolean QuorumGroup must be TRUE!
        //
        if ( (i == 0) && bQuorumGroup )
        {
            DWORD dwOwnerNodeId;

            //for the quorum group find the node that had last
            //arbitrated for it.
            //We do this by asking MM about it.
            //If there was no arbitration during the last regroup
            //but there was one in the one before that one, the
            //node that arbitrated is returned.
            //This node should be able to online the group.
            //We use MMApproxArbitrationWinner instead if 
            // MMGetArbitrationWinner() since multiple-regroups 
            // might occur before the FM handles the node down
            // event for this node.
            MMApproxArbitrationWinner( &dwOwnerNodeId );
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetGroupEnumOwner:: MM suggests node %1!u! for quorum owner\r\n",
                dwOwnerNodeId);
            
            if ( dwOwnerNodeId != MM_INVALID_NODE )
            {
                pOwnerNode = NmReferenceNodeById( dwOwnerNodeId );
                //
                //  We can't proceed in this strange situation.
                //
                if ( pOwnerNode == NULL ) 
                {
                    CsInconsistencyHalt ( ERROR_CLUSTER_INVALID_NODE );
                } else
                {
                    //
                    //  Dereference the node object rightaway so that you don't increment the ref count
                    //  twice, one here and one again down below.
                    //
                    OmDereferenceObject ( pOwnerNode );
                }
            }
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpSetGroupEnumOwner:: MM returned MM_INVALID_NODE, chose the default target\r\n");
                //else just use the default target
                pOwnerNode = pDefaultOwnerNode;
            }
        }
        else
        {
            pOwnerNode = FmpGetPreferredNode(pGroup);
            if ( pOwnerNode == NULL )
            {
	            pOwnerNode = pDefaultOwnerNode;
            }

            //
            //  If the caller (GUM) has supplied a randomized preferred owner of the group, then
            //  see if it can be used.
            //
            if ( pGroupNodeList != NULL )
            {
                pOwnerNode = FmpParseGroupNodeListForPreferredOwner( pGroup, 
                                                                     pGroupNodeList, 
                                                                     pOwnerNode );
            }
        }

        if ( pGroup->OwnerNode != NULL )
        {
            OmDereferenceObject( pGroup->OwnerNode );
        }

        OmReferenceObject( pOwnerNode );
        
        pGroup->OwnerNode = pOwnerNode;

        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpSetGroupEnumOwner: Group's %1!ws! new owner is node %2!ws!\n",
               OmObjectId(pGroup), OmObjectId(pOwnerNode));

	    //FmpReleaseLocalGroupLock( pGroup );
        OmDereferenceObject(pGroup);
    }

FnExit:
    return(dwStatus);

} // FmpSetGroupEnumOwner


DWORD
FmpAssignOwnersToGroups(
    IN LPCWSTR   pszNodeId,
    IN PFM_GROUP pGroup,
    IN PFM_GROUP_NODE_LIST  pGroupNodeList
    )
/*++

Routine Description:

    Takes ownership of all the groups defined in the cluster that
    are owned by another node. This is used when a node fails.

    The current algorithm is very dumb and simple. Node with the
    lowest ID gets all the groups.

Arguments:

    pszNodeId - Supplies the node ID that all the groups should be taken
           from.

    pGroup - Supplies the group which alone is to be claimed.

    pGroupNodeList - The randomized suggested preferred owner for all groups.
    
Return Value:

    ERROR_SUCCESS if successful

    Win32 errorcode otherwise

--*/

{
    DWORD               i;
    DWORD               dwStatus;
    PGROUP_ENUM         pNodeGroups = NULL;
    PNM_NODE            pDefaultTarget = NULL;
    PNM_NODE            pPausedTarget = NULL;
    BOOL                bQuorumGroup;

    //
    // Acquire the global group lock
    //
    FmpAcquireGroupLock();

    //
    // Check if groups are initialized
    //
    if ( !FmpFMGroupsInited )
    {
        dwStatus = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    // Find and sort all known groups
    //
    if ( pGroup == NULL )
    {
        dwStatus = FmpEnumSortGroups(&pNodeGroups, pszNodeId, &bQuorumGroup);
    } else
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/7/99
        //
        //  This means you got here due to an RPC exception raised in
        //  FmpTakeGroupRequest. So, see where this sole group goes.
        //
        dwStatus = FmpGetGroupInNodeGroupList(&pNodeGroups, pGroup, pszNodeId, &bQuorumGroup);
    }
    
    if (dwStatus != ERROR_SUCCESS)
    {
        CL_ASSERT(pNodeGroups == NULL);
        goto FnExit;
    }

    CL_ASSERT(pNodeGroups != NULL);

    //if no nodes were owned by this node, just return
    if (pNodeGroups->EntryCount == 0)
    {
        FmpDeleteEnum(pNodeGroups);
        goto FnExit;
    }

    //
    // Find the state of the Groups.
    //
    FmpGetGroupListState( pNodeGroups );

    //
    // Find the active node with the lowest ID to be the default
    // owner of these groups.
    //
    // If we can't find an active node then select the lowest node id for
    // a node that is paused.
    //
    CL_ASSERT(NmMaxNodeId != ClusterInvalidNodeId);
    CL_ASSERT(Session != NULL);

    for (i=ClusterMinNodeId; i<=NmMaxNodeId; i++)
    {
        pDefaultTarget = NmReferenceNodeById(i);

        if ( pDefaultTarget != NULL )
        {
            //if this node is up, there is no need to use a paused target
            if ( NmGetNodeState(pDefaultTarget) == ClusterNodeUp )
            {
                if ( pPausedTarget )
                {
                    OmDereferenceObject(pPausedTarget);
                    pPausedTarget = NULL;
                }
                //found a node, leave this loop
                break;
            }
            //node is not up, check if it paused
            //if is is paused and no other paused node has been found
            //set this one to be the lowest paused node
            if ( !pPausedTarget && 
                (NmGetNodeState(pDefaultTarget) == ClusterNodePaused) )
            {
                pPausedTarget = pDefaultTarget;
            }
            else
            {
                OmDereferenceObject(pDefaultTarget);
            }
            pDefaultTarget = NULL;
        }
    }

    if ( (pDefaultTarget == NULL) && (pPausedTarget == NULL) ) {
        //
        // There are no online/paused nodes, this node must be paused,
        // so don't do anything.
        //
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpAssignOwnersToGroups - no online/paused nodes remaining\n");
        //SS: then what are we doing here
        FmpDeleteEnum(pNodeGroups);
        goto FnExit;
    }

    //if no node is up, use the lowest paused node as the default owner for
    //the groups
    if ( pDefaultTarget == NULL )
    {
        pDefaultTarget = pPausedTarget;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpAssignOwnersToGroups - DefaultTarget is %1!ws!\n",
        OmObjectId(pDefaultTarget));

    //
    //  Chittur Subbaraman (chitturs) - 7/20/99
    //
    //  Prepare the entire group list for subsequent online. You have
    //  to do this here to have a consistent resource state view
    //  among different nodes in the cluster since this is the GUM
    //  handler. Also, the DM node down handler which follows this
    //  GUM handler may think that the quorum resource is owned by 
    //  this node and its state is online while it has not been 
    //  brought online on this node. Note also the order of this
    //  call and the call to set the group ownership. THIS ORDER
    //  MUST BE FOLLOWED since we don't hold any groups lock here
    //  (since we are paranoid about deadlocks) and we don't want 
    //  the FmCheckQuorumState function called as a part of the 
    //  DM node down handler to think that the group is owned by 
    //  this node and is also online on this node.
    //
    FmpPrepareGroupEnumForOnline( pNodeGroups );

    //
    // Set the Group owner.
    //
    FmpSetGroupEnumOwner( pNodeGroups, 
                          pDefaultTarget, 
                          pszNodeId,
                          bQuorumGroup,
                          pGroupNodeList );

    //
    //  Chittur Subbaraman (chitturs) - 5/26/99
    //
    //  Clear the intended owner fields of all the groups. This is done
    //  since there is no guarantee that FmpTakeGroupRequest will do this.
    //
    FmpResetGroupIntendedOwner( pNodeGroups );
  
    //
    //  Chittur Subbaraman (chitturs) - 7/14/99
    //
    //  Handle the online of group list containing the quorum resource with  
    //  a separate thread and let the worker thread handle group lists
    //  not containing the quorum resource. This is necessary since it is
    //  possible that this node can take ownership at roughly the same
    //  time of a quorum group and a non-quorum group each resident 
    //  in a different node due to back-to-back node crashes. In such a
    //  case, we can't order these groups for online globally with the
    //  quorum group first in the list. So, we don't want the worker thread 
    //  to be "stuck" in FmpRmOnlineResource for the non-quorum group's 
    //  resource waiting for the quorum group to be brought online since 
    //  the quorum group online work item is queued behind the non-quorum 
    //  group online work item.
    //
    if ( bQuorumGroup )
    {
        HANDLE  hThread = NULL;
        DWORD   dwThreadId;

        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpAssignOwnersToGroups - Create thread to handle group list containing quorum group....\n"
                  );
    
        hThread = CreateThread( NULL, 
                                0, 
                                FmpBringQuorumGroupListOnline,
                                pNodeGroups, 
                                0, 
                                &dwThreadId );

        if ( hThread == NULL )
        {
            CL_UNEXPECTED_ERROR( GetLastError() );
            OmDereferenceObject( pDefaultTarget );
            goto FnExit;
        }
        
        CloseHandle( hThread );
    } else
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpAssignOwnersToGroups - Post work item to worker thread to handle group list containing non-quorum groups....\n"
                  );
        FmpPostWorkItem(FM_EVENT_INTERNAL_ONLINE_GROUPLIST, pNodeGroups, 0);
    }

    OmDereferenceObject(pDefaultTarget);

FnExit:
    //
    // Release the global group lock
    //
    FmpReleaseGroupLock();


    return(ERROR_SUCCESS);
}

/****
@func       DWORD | FmpResetGroupIntendedOwner| This routine resets the 
            intended owner for all groups in the list.

@parm       IN PGROUP_ENUM | pGroupEnum| The list of Groups.

@rdesc      Returns ERROR_SUCCESS.
****/
VOID
FmpResetGroupIntendedOwner(
    IN PGROUP_ENUM  pGroupEnum
    )
{
    DWORD i;
    PFM_GROUP pGroup;

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpResetGroupIntendedOwner: Entry.\n");
    
    for ( i = 0; i < pGroupEnum->EntryCount; i++ )
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );
        if ( pGroup == NULL )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpResetGroupIntendedOwner: Group %1!ws! not found\n");
            continue;
        }
        
        pGroup->pIntendedOwner = NULL;

        OmDereferenceObject( pGroup );
    }

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpResetGroupIntendedOwner: Exit.\n");

}

/****
@func       DWORD | FmpGetGroupInNodeGroupList | This routine checks whether
            the supplied group is to be included in the list to be brought
            online.

@parm       OUT PGROUP_ENUM | pReturnEnum | The group list possibly 
            containing the supplied group.

@parm       IN PFM_GROUP | pGroup | The group which is to be brought online
            possibly.

@parm       IN LPCWSTR | pszDeadNodeId | The node ID of the dead node.

@parm       OUT PBOOL | pbQuorumGroup | Does the group list contain the quorum group ?

@rdesc      Returns ERROR_SUCCESS on success OR a Win32 error code on a 
            failure.
****/
DWORD
FmpGetGroupInNodeGroupList(
    OUT PGROUP_ENUM *pReturnEnum,
    IN PFM_GROUP pGroup,
    IN LPCWSTR pszDeadNodeId,
    OUT PBOOL pbQuorumGroup
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PGROUP_ENUM pGroupEnum = NULL;
    PFM_RESOURCE pQuoResource = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 6/7/99
    //
    //  This function is only called if an RPC exception is raised in
    //  FmpTakeGroupRequest. This function will check to see whether this
    //  group is to be brought online in this node.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Entry for group <%1!ws!>\n",
                OmObjectId(pGroup));

    *pbQuorumGroup = FALSE;
   
    pGroupEnum = LocalAlloc( LPTR, 
                             sizeof( GROUP_ENUM_ENTRY ) + sizeof( GROUP_ENUM ) );
    
    if ( pGroupEnum == NULL ) 
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGroupEnum->Entry[0].Id = pGroupEnum->Entry[1].Id = NULL;

    pGroupEnum->EntryCount = 0;

    //
    //  Check whether this group was in the dead node or was in the
    //  process of moving to the dead node.
    //
    if( ( pszDeadNodeId != NULL ) &&
        ( lstrcmp ( pszDeadNodeId, OmObjectId ( pGroup->OwnerNode ) ) ) &&
        ( ( pGroup->pIntendedOwner == NULL ) ||
          ( ( lstrcmp ( pszDeadNodeId, OmObjectId ( pGroup->pIntendedOwner ) ) ) ) ) )
    {
        //
        // This group does not match the owner criteria
        //
        dwStatus = ERROR_GROUP_NOT_AVAILABLE;
        goto FnExit;
    }

    dwStatus = FmFindQuorumResource( &pQuoResource );
    
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpGetGroupInNodeGroupList: Cannot find quorum resource, Status = %1!u!\n",
                dwStatus);
        CsInconsistencyHalt( dwStatus );
    }

    //
    //  Handle the quorum group first, if necessary. This is needed since
    //  otherwise you may not be able to bring the other group online.
    //
    if( ( pGroup != pQuoResource->Group ) && 
        ( ( pszDeadNodeId == NULL ) ||
          ( !lstrcmp ( pszDeadNodeId, OmObjectId  ( pQuoResource->Group->OwnerNode ) ) ) ||
          ( ( pQuoResource->Group->pIntendedOwner != NULL ) &&
            ( !lstrcmp ( pszDeadNodeId, OmObjectId  ( pQuoResource->Group->pIntendedOwner ) ) ) ) ) )
    {
        //
        // The quorum group matches the owner criteria. Include it first
        // in the list.
        //
        pGroupEnum->Entry[pGroupEnum->EntryCount].Id = 
            LocalAlloc( LMEM_FIXED, ( lstrlenW(OmObjectId(pQuoResource->Group)) + 1 ) * sizeof( WCHAR ) );

        if ( pGroupEnum->Entry[pGroupEnum->EntryCount].Id == NULL )
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto FnExit;
        }

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Dead node contains quorum group also, including it...\n");
        lstrcpyW( pGroupEnum->Entry[pGroupEnum->EntryCount].Id, OmObjectId( pQuoResource->Group ) );
        pGroupEnum->EntryCount++;
        *pbQuorumGroup = TRUE;
    } else if ( pGroup == pQuoResource->Group )
    {
        *pbQuorumGroup = TRUE;
    }

    pGroupEnum->Entry[pGroupEnum->EntryCount].Id = 
        LocalAlloc( LMEM_FIXED, ( lstrlenW(OmObjectId(pGroup)) + 1 ) * sizeof( WCHAR ) );

    if ( pGroupEnum->Entry[pGroupEnum->EntryCount].Id == NULL )
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    lstrcpyW( pGroupEnum->Entry[pGroupEnum->EntryCount].Id, OmObjectId( pGroup ) );

    pGroupEnum->EntryCount++;

    *pReturnEnum = pGroupEnum;
    
    OmDereferenceObject( pQuoResource );
    
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Exit with SUCCESS.\n");

    return( ERROR_SUCCESS );

FnExit:
    if ( pGroupEnum != NULL ) 
    {
        FmpDeleteEnum( pGroupEnum );
    }

    if ( pQuoResource != NULL )
    {   
        OmDereferenceObject( pQuoResource );
    }

    *pReturnEnum = NULL;

    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpGetGroupInNodeGroupList: Exit, Status = %1!u!\n",
                dwStatus);
 
    return( dwStatus );
}

/****
@func       VOID | FmpPrepareGroupEnumForOnline | Prepare a list of
            groups for online.

@parm       IN PGROUP_ENUM | pGroupEnum | The group list.

@rdesc      None.
****/
VOID
FmpPrepareGroupEnumForOnline(
    IN PGROUP_ENUM pGroupEnum
    )
{
    PFM_GROUP pGroup = NULL;
    DWORD     i;

    //
    //  Chittur Subbaraman (chitturs) - 6/21/99
    //
    //  Prepare an entire group list for online.
    //
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPrepareGroupEnumForOnline - Entry...\n");
   
    for ( i=0; i<pGroupEnum->EntryCount; i++ ) 
    {
        pGroup = OmReferenceObjectById( ObjectTypeGroup,
                                        pGroupEnum->Entry[i].Id );

        //
        // If we fail to find a group, then just continue.
        //
        if ( pGroup == NULL ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpPrepareGroupEnumForOnline - Group %1!ws! cannot be found !\n",
                pGroupEnum->Entry[i].Id);
            continue;
        }

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPrepareGroupEnumForOnline - Preparing group <%1!ws!> for online...\n",
                pGroupEnum->Entry[i].Id);

        FmpPrepareGroupForOnline( pGroup );
        OmDereferenceObject ( pGroup );
    }

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmpPrepareGroupEnumForOnline - Exit...\n");

}

/****
@func       DWORD | FmpBringQuorumGroupListOnline | Bring a list of groups
            containing the quorum group online.

@parm       IN LPVOID | pContext | A pointer to the group list to be brought
            online.

@rdesc      Returns ERROR_SUCCESS.
****/
DWORD
FmpBringQuorumGroupListOnline(
    IN LPVOID pContext
    )
{
    PGROUP_ENUM pGroupList = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 7/14/99
    //
    //  This function tries to bring a list of groups containing the quorum
    //  group online. Note that if the group's owner turns out to be some
    //  other node, this function will not online the group.
    //
    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpBringQuorumGroupListOnline - Entry: Trying to online group list containing quorum group....\n"
                  );

    pGroupList = pContext;

    CL_ASSERT( pGroupList != NULL );
    
    FmpOnlineGroupList( pGroupList, TRUE );
    
    FmpDeleteEnum( pGroupList );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmpBringQuorumGroupListOnline - Exit ....\n"
                  );

    return( ERROR_SUCCESS );
}

/****
@func       BOOL | FmpIsAnyResourcePersistentStateOnline | Is the persistent state of any
            resource in the group online ?

@parm       IN PFM_GROUP | pGroup | The group which is to be checked.

@rdesc      TRUE if at least one resource's persistent state is ClusterResourceOnline, FALSE otherwise.
****/
BOOL
FmpIsAnyResourcePersistentStateOnline(
    IN PFM_GROUP pGroup
    )
{
    PFM_RESOURCE    pResource;
    PLIST_ENTRY     pListEntry;

    if ( CsNoQuorum ) return FALSE;
    
    for ( pListEntry = pGroup->Contains.Flink;
          pListEntry != &( pGroup->Contains );
          pListEntry = pListEntry->Flink ) 
    {
        pResource = CONTAINING_RECORD( pListEntry, 
                                       FM_RESOURCE, 
                                       ContainsLinkage );

        if ( pResource->PersistentState == ClusterResourceOnline ) 
        {
            ClRtlLogPrint(LOG_NOISE,
                          "[FM] FmpIsAnyResourcePersistentStateOnline: Persistent state of resource %1!ws! in group %2!ws! is online...\r\n",
                          OmObjectId(pResource), 
                          OmObjectId(pGroup));
            return ( TRUE );
        }
    } // for

    ClRtlLogPrint(LOG_NOISE,
                 "[FM] FmpIsAnyResourcePersistentStateOnline: No resource in group %1!ws! has persistent state online...\r\n",
                 OmObjectId(pGroup));
    
    return( FALSE );
} // FmpIsAnyResourcePersistentStateOnline
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\recv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    Cluster FM remote receive request routines.

Author:

    Rod Gamache (rodga) 21-Mar-1996


Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE RECV

//
// Global data
//

extern BOOL FmpOkayToProceed;

//
// Local function prototypes
//
BOOL
FmpEnumMyGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    );

BOOL
FmpEnumResources(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Id
    );


error_status_t
s_FmsOnlineGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId
    )

/*++

Routine Description:

    Receives a Group Online Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOnlineGroupRequest: To bring group '%1!ws!' online\n",
               GroupId);

    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsOnlineGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Only one of these requests per group at a time.
    //
    FmpAcquireLocalGroupLock( group );


    //
    // Now bring it online.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Set the Group's Current State.
        //
        FmpSetGroupPersistentState( group, ClusterGroupOnline );

        status = FmpOnlineGroup( group, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );

    return(status);

} // FmsOnlineGroupRequest



error_status_t
s_FmsOfflineGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId
    )

/*++

Routine Description:

    Receives a Group Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to bring offline.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOfflineGroupRequest: To take group '%1!ws!' offline\n",
               GroupId);

    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsOfflineGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Now take it offline if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Set the Group's Current State.
        //
        FmpSetGroupPersistentState( group, ClusterGroupOffline );

        status = FmpOfflineGroup( group, FALSE, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    OmDereferenceObject( group );

    return(status);

} // FmsOfflineGroupRequest



error_status_t
s_FmsMoveGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPCWSTR DestinationNode OPTIONAL
    )

/*++

Routine Description:

    Receives a Group Move Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to move.
    DestinationNode - The Id of the node to move the Group to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    PNM_NODE node = NULL;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsMoveGroupRequest: To move group '%1!ws!'\n",
               GroupId);

    //
    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsMoveGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    // Find the specified destination node.
    //

    if ( ARGUMENT_PRESENT( DestinationNode ) ) {
        node = OmReferenceObjectById( ObjectTypeNode, DestinationNode );

        if ( node == NULL ) {
            OmDereferenceObject( group );
            ClRtlLogPrint(LOG_NOISE,"[FM] FmsMoveGroupRequest: Could not find Node %1!ws!\n", DestinationNode);
            return(ERROR_HOST_NODE_NOT_AVAILABLE);
        }
    }

    //
    // Make sure we are the owner of the Group.
    //
    FmpAcquireLocalGroupLock( group );
    if ( group->OwnerNode == NmLocalNode ) {
        status = FmpDoMoveGroup( group, node, TRUE );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }
    FmpReleaseLocalGroupLock( group );

    OmDereferenceObject( group );
    if ( node != NULL ) {
        OmDereferenceObject( node );
    }

    return(status);

} // FmsMoveGroupRequest



error_status_t
s_FmsTakeGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN PRESOURCE_ENUM ResourceList
    )

/*++

Routine Description:

    Receives a Take Group Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to take locally.
    ResourceList - The list of resources and their states.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP group;
    DWORD status = ERROR_SUCCESS;

    //SS: removing this check from here 
    //FmpTakeGroupRequest does this check since if this call returns a failure,
    //the intended owner needs to be reset to invalidnode to avoid inconsistencies
    //FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsTakeGroupRequest: To take group '%1!ws!'.\n",
               GroupId );

    //
    //
    // Find the specified group.
    //

    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmsTakeGroupRequest: Could not find Group %1!ws!\n",
                   GroupId);
        if ( !FmpFMOnline ) {
            return(ERROR_CLUSTER_NODE_NOT_READY);
        }
        return(ERROR_GROUP_NOT_FOUND);
    }

    status = FmpTakeGroupRequest(group, ResourceList);
    OmDereferenceObject(group);

    return(status);

} // FmsTakeGroupRequest



error_status_t
s_FmsOnlineResourceRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Online Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsOnlineResourceRequest: To bring resource '%1!ws!' online\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsOnlineResourceRequest: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    if (!(resource->QuorumResource) && 
        !FmpInPreferredList( resource->Group, resource->Group->OwnerNode, TRUE, resource ) ) {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    }

    //
    // Now bring it online.
    //
    CL_ASSERT( resource->Group != NULL );
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        //
        // This can only be invoked through the API, so force all
        // resources online.
        //
        status = FmOnlineResource( resource );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

FnExit:
    FmpReleaseLocalResourceLock( resource );

    OmDereferenceObject( resource );

    return(status);

} // FmsOnlineResourceRequest



error_status_t
s_FmsOfflineResourceRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring offline.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] FmsOfflineResourceRequest: To take resource '%1!ws!' offline\n",
              ResourceId);

    //
    // Find the specified resource.
    //

    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsOfflineResourceRequest: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock(resource);
    //
    // Now take it offline if we are the owner.
    //
    CL_ASSERT( resource->Group != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) 
    {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnExit;
    } 
    //else handle it locally
    status = FmOfflineResource( resource );

FnExit:
    FmpReleaseLocalResourceLock(resource);
    OmDereferenceObject( resource );

    return(status);

} // FmsOfflineResourceRequest



error_status_t
s_FmsChangeResourceNode(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    IN BOOL Add
    )

/*++

Routine Description:

    Receives a Resource change node request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to change a node.
    NodeId - The node id of the node to add or remove.
    Add - Indicates whether to add or remove the node.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD        status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsChangeResourceNode: To %1!ws! node %2!ws! to/from resource '%3!ws!'.\n",
               Add ? L"Add" : L"Remove",
               NodeId,
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsChangeResourceNode: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    status = FmpChangeResourceNode(resource, NodeId, Add);
    FmpReleaseLocalResourceLock( resource );
    OmDereferenceObject( resource );

    return(status);

} // FmsChangeResourceNode



error_status_t
s_FmsArbitrateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Arbitrates a Resource for a remote system.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to bring online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsArbitrateResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    status = FmpRmArbitrateResource( resource );

    OmDereferenceObject( resource );

    return(status);

} // FmsArbitrateResource



error_status_t
s_FmsQueryOwnedGroups(
    IN handle_t IDL_handle,
    OUT PGROUP_ENUM *OwnedGroups,
    OUT PRESOURCE_ENUM *OwnedResources
    )
/*++

Routine Description:

    Server side used to propagate FM state to a joining node.

Arguments:

    IDL_handle - Supplies RPC binding handle, not used.

    OwnedGroups - Returns the list of groups owned by this node and
        their state.

    OwnedResources - Returns the list of resources contained by groups
        owned by this node and their state.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    DWORD           allocated;
    PGROUP_ENUM     groupEnum = NULL;
    PFM_GROUP       group;
    PRESOURCE_ENUM  resourceEnum = NULL;
    PFM_RESOURCE    resource;
    DWORD i;

    allocated = ENUM_GROW_SIZE;

    groupEnum = MIDL_user_allocate(GROUP_SIZE(allocated));
    if ( groupEnum == NULL ) {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    groupEnum->EntryCount = 0;
    //
    // Enumerate all groups
    //
    OmEnumObjects( ObjectTypeGroup,
                   FmpEnumMyGroups,
                   &groupEnum,
                   &allocated );

    //
    // Enumerate all the resources in each group.
    //
    allocated = ENUM_GROW_SIZE;
    resourceEnum = MIDL_user_allocate(RESOURCE_SIZE(allocated));
    if (resourceEnum == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(status);
        goto error_exit;
    }
    resourceEnum->EntryCount = 0;

    for (i=0; i < groupEnum->EntryCount; i++) {
        //
        // Get the group given its name.
        //
        group = OmReferenceObjectById( ObjectTypeGroup,
                                       groupEnum->Entry[i].Id );
        if (group == NULL) {
            continue;
        }

        //
        // Enumerate all the resources in this group.
        //
        status = FmpEnumerateGroupResources(group,
                                  FmpEnumResources,
                                  &resourceEnum,
                                  &allocated);
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmsQueryOwnedGroups: Failed group '%1!ws!', status %2!u!.\n",
                       OmObjectId(group),
                       status);
        }
        OmDereferenceObject(group);
    }

    *OwnedGroups = groupEnum;
    *OwnedResources = resourceEnum;

    return(ERROR_SUCCESS);

error_exit:
    if (groupEnum != NULL) {
        //
        // Free up group enum
        //
        for (i=0; i < groupEnum->EntryCount; i++) {
            MIDL_user_free(groupEnum->Entry[i].Id);
        }
        MIDL_user_free(groupEnum);
    }
    return(status);
}


error_status_t
s_FmsFailResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Resource Fail Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to fail.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsFailResource: To fail resource '%1!ws!'.\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsFailResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    //
    // Now fail it.
    //
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        status = FmpRmFailResource( resource );
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalResourceLock( resource );

    return(status);

} // FmsFailResource


error_status_t
s_FmsCreateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName
    )

/*++

Routine Description:

    Receives a Create Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to create the resource inside.
    ResourceId - The Id of the Resource to create.
    ResourceName - The name of the Resource to create.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_GROUP group;
    DWORD status;
    PGUM_CREATE_RESOURCE gumResource;
    DWORD groupIdLen;
    DWORD resourceIdLen;
    DWORD resourceNameLen;
    DWORD bufSize;
    HDMKEY resourceKey;
    HDMKEY paramsKey;
    DWORD  disposition;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCreateResource: To create resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified group.
    //
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCreateResource: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    FmpAcquireLocalGroupLock( group );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        groupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        resourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        resourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        bufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  groupIdLen + resourceIdLen + resourceNameLen;
        gumResource = LocalAlloc(LMEM_FIXED, bufSize);
        if (gumResource == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmsCreateResource: Unable to allocate memory for resource %1!ws!\n",
                         ResourceName);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Fill in message buffer.
        //
        gumResource->Resource = NULL;
        gumResource->GroupIdLen = groupIdLen;
        gumResource->ResourceIdLen = resourceIdLen;
        CopyMemory(gumResource->GroupId, GroupId, groupIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen,
                   ResourceId,
                   resourceIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen,
                   ResourceName,
                   resourceNameLen);

        //
        // Send message.
        //
        status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               bufSize,
                               gumResource);
        if ( ( status == ERROR_SUCCESS ) && 
             ( gumResource->Resource != NULL ) )
            FmpCleanupPossibleNodeList(gumResource->Resource);                               
        LocalFree(gumResource);
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    return(status);

} // FmsCreateResource


error_status_t
s_FmsDeleteResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId
    )

/*++

Routine Description:

    Receives a Delete Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the Resource to delete.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD resourceLen;

    FmpMustBeOnline();

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsDeleteResource: To delete resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource,
                                      ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsDeleteResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    FmpAcquireLocalResourceLock( resource );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( resource->Group->OwnerNode == NmLocalNode ) {
        //
        // Check if this is the quorum resource.
        //
        if ( resource->QuorumResource ) {
            status =  ERROR_QUORUM_RESOURCE;
            goto FnExit;
        }

        //other core resources cannot be deleted either
        if (resource->ExFlags & CLUS_FLAG_CORE)
        {
            status = ERROR_CORE_RESOURCE;
            goto FnExit;
        }


        //
        // Check the state of the resource, before attempting to delete it.
        // It must be offline or failed in order to perform the delete.
        //
        if ((resource->State != ClusterResourceOffline) &&
            (resource->State != ClusterResourceFailed)) {
            status = ERROR_RESOURCE_ONLINE;
            goto FnExit;
        }

        //
        // Check whether this resource provides for any other resources.
        // If so, it cannot be deleted.
        //
        if (!IsListEmpty(&resource->ProvidesFor)) {
            status = ERROR_DEPENDENT_RESOURCE_EXISTS;
            goto FnExit;
        }

        if (resource->Group->MovingList)
        {
            status = ERROR_INVALID_STATE;
            goto FnExit;
        }
        
        resourceLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);

        FmpBroadcastDeleteControl(resource);
        //
        // Send message.
        //
        status = GumSendUpdateEx(GumUpdateFailoverManager,
                                 FmUpdateDeleteResource,
                                 1,
                                 resourceLen,
                                 ResourceId);
    } else {
    
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        
    }


FnExit:
    FmpReleaseLocalResourceLock( resource );
    return(status);

} // FmsDeleteResource


BOOL
FmpEnumMyGroups(
    IN OUT PGROUP_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_GROUP Group,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Groups.
    This routine adds the specified Group to the list that is being
    generated if it is owned by the local system.

Arguments:

    Enum - The Group Enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The current number of allocated entries in Enum.
    Group - The Group object being enumerated.
    Id - The Id of the Group object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.

--*/

{
    PGROUP_ENUM groupEnum;
    PGROUP_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;
    CLUSTER_GROUP_STATE state;

    //
    // If we don't own the Group, return now.
    //
    if (Group->OwnerNode != NmLocalNode) {
        return(TRUE);
    }

    groupEnum = *Enum;

    if ( groupEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the GROUP_ENUM
        //

        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = MIDL_user_allocate(GROUP_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, groupEnum, GROUP_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        MIDL_user_free(groupEnum);
        groupEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = MIDL_user_allocate((lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(FALSE);
    }

    lstrcpyW(newId, Id);
    groupEnum->Entry[groupEnum->EntryCount].Id = newId;
    groupEnum->Entry[groupEnum->EntryCount].State = Group->State;
    groupEnum->Entry[groupEnum->EntryCount].StateSequence = Group->StateSequence;
    ++groupEnum->EntryCount;

    return(TRUE);

} // FmpEnumMyGroups


BOOL
FmpEnumResources(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Id
    )

/*++

Routine Description:

    Worker callback routine for the enumeration of Group resources.
    This routine adds the specified resource to the list that is being
    generated.

Arguments:

    Enum - The resource enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The current number of allocated entries in Enum.
    Resource - The Resource object being enumerated.
    Id - The Id of the resource object being enumerated.

Returns:

    TRUE - to indicate that the enumeration should continue.
    FALSE - to indicate that the enumeration should not continue.

--*/

{
    PRESOURCE_ENUM resourceEnum;
    PRESOURCE_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;

    resourceEnum = *Enum;

    if ( resourceEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the RESOURCE_ENUM
        //
        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = MIDL_user_allocate(RESOURCE_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(FALSE);
        }

        CopyMemory(newEnum, resourceEnum, RESOURCE_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        MIDL_user_free(resourceEnum);
        resourceEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = MIDL_user_allocate((lstrlenW(Id)+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(FALSE);
    }

    lstrcpyW(newId, Id);
    resourceEnum->Entry[resourceEnum->EntryCount].Id = newId;
    resourceEnum->Entry[resourceEnum->EntryCount].State = Resource->State;
    resourceEnum->Entry[resourceEnum->EntryCount].StateSequence = Resource->StateSequence;
    ++resourceEnum->EntryCount;

    return(TRUE);

} // FmpEnumResources



error_status_t
s_FmsResourceControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    ResourceId - the Id of the Resource to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD bufSize;
    DWORD dataLength;
    CLUSPROP_BUFFER_HELPER props;

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsResourceControl: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( InBuffer == NULL )
    {
        InBufferSize = 0;
    }
    else if ( InBufferSize == 0 )
    {
        InBuffer = NULL;
    }

    CL_ASSERT( resource->Group != NULL );

    status = FmpRmResourceControl( resource,
                                   ControlCode,
                                   InBuffer,
                                   InBufferSize,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required
                                   );
    OmDereferenceObject(resource);

    return(status);
} // FmsResourceControl



error_status_t
s_FmsResourceTypeControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine passes a resource control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    ResourceTypeName - the name of the Resource Type to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( InBuffer == NULL )
    {
        InBufferSize = 0;
    }
    else if ( InBufferSize == 0 )
    {
        InBuffer = NULL;
    }

    status = FmpRmResourceTypeControl( ResourceTypeName,
                                       ControlCode,
                                       InBuffer,
                                       InBufferSize,
                                       OutBuffer,
                                       OutBufferSize,
                                       BytesReturned,
                                       Required
                                       );

    if ((status == ERROR_MOD_NOT_FOUND) || (status == ERROR_PROC_NOT_FOUND))
    {
        FmpRemovePossibleNodeForResType(ResourceTypeName, NmLocalNode);
    }
#if 0
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {
        ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE, XXX );
    }
#endif

    return(status);

} // FmsResourceTypeControl


error_status_t
s_FmsGroupControl(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    This routine processes a group control request from a remote system.

Arguments:

    IDL_handle - the binding context - not used

    GroupId - the Id of the Group to control

    ControlCode - the control code for this request

    InBuffer - the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - the output buffer

    OutBufferSize - the size of the output buffer

    ByteReturned - the number of bytes returned in the output buffer

    Required - the number of bytes required if OutBuffer is not big enough.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_GROUP group;
    DWORD status;

    //
    // Find the specified group
    //
    group = OmReferenceObjectById( ObjectTypeGroup, GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsGroupControl: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( InBuffer == NULL )
    {
        InBufferSize = 0;
    }
    else if ( InBufferSize == 0 )
    {
        InBuffer = NULL;
    }

    status = FmpGroupControl(group, ControlCode, InBuffer, InBufferSize,
        OutBuffer, OutBufferSize, BytesReturned, Required);
        
    OmDereferenceObject(group);
    return(status);

} // FmsGroupControl


error_status_t
s_FmsPrepareQuorumResChange(
    IN handle_t IDL_handle,
    IN LPCWSTR  ResourceId,
    IN LPCWSTR  lpszQuoLogPath,
    IN DWORD    dwMaxQuoLogSize
    )

/*++

Routine Description:

    Receives a request to prepare a resource to become the quorum resource.
    A resource must be able to support a quorum log file and registry replication
    files.

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the resource to be made the quorum resource.
    lpszQuoLogPath - The path where the logs must be created.
    dwMaxQuoLogSize - The maximum size of the quorum log file.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource=NULL;
    DWORD           Status;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsPrepareQuorumResChange: Entry\r\n");

    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsPrepareQuorumResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    CL_ASSERT( pResource->Group != NULL );
    if ( pResource->Group->OwnerNode == NmLocalNode )
        Status = FmpPrepareQuorumResChange(pResource, lpszQuoLogPath, dwMaxQuoLogSize);
    else
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;

FnExit:
    if (pResource) OmDereferenceObject( pResource );
    return(Status);

} // FmsPrepareQuorumResChange



error_status_t
s_FmsCompleteQuorumResChange(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszOldQuoResId,
    IN LPCWSTR  lpszOldQuoLogPath
    )

/*++

Routine Description:

    Receives a request to clean up quorum logging and cluster registry files
    on the old quorum resource.

Arguments:

    IDL_handle - The binding context - not used.
    lpszOldQuoResId - The Id of the resource to be made the quorum resource.
    lpszQuoLogPath - The path where the logs must be created.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource=NULL;
    DWORD           Status;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCompleteQuorumResChange: Entry\r\n");

    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, lpszOldQuoResId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCompleteQuorumResource: Could not find Resource %1!ws!\n",
                  lpszOldQuoResId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    CL_ASSERT( pResource->Group != NULL );
    if ( pResource->Group->OwnerNode == NmLocalNode )
        Status = FmpCompleteQuorumResChange(lpszOldQuoResId, lpszOldQuoLogPath);
    else
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;

FnExit:
    if (pResource) OmDereferenceObject( pResource );
    return(Status);

} // FmsCompleteQuorumResChange



error_status_t
s_FmsQuoNodeOnlineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    OUT LPDWORD State
    )

/*++

Routine Description:

    Receives a RmResourceOnline request from (THE) remote system and returns
    status for that request.

    This system must own the quorum resource.

    This is the first half of the sling shot. We acquire locks
    and then RPC back to the originating node with a request to perform
    the online.

    This request is only valid for non-quorum resources.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring online.

    NodeId - The Id of the Node that originated the request.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/
{
    //not used
    return(ERROR_INVALID_FUNCTION);        
}
 // FmsQuoNodeOnlineResource



error_status_t
s_FmsQuoNodeOfflineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    IN LPCWSTR NodeId,
    OUT LPDWORD State
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring offline.

    NodeId - The Id of the Node that originated the request.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/
{
    //not used
    return(ERROR_INVALID_FUNCTION);
}// FmsQuoNodeOfflineResource



error_status_t
s_FmsRmOnlineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Receives a RmResourceOnline request from quorum node and returns
    status for that request.

    This system was the originator of the original online request.

    This is the second half of the sling shot. It just does the online
    request.

    This request is only valid for non-quorum resources.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring online.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    We can't acquire any locks... but the originating thread has the
    lock held for us.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] s_FmsRmOnlineResource: To bring resource '%1!ws!' online\n",
               ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRmOnlineResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // This must not be done on the quorum resource, and the local system
    // must not own the quorum resource. We'll assume that the quorum
    // resource migrated while we were performng this request.
    //
    CL_ASSERT( gpQuoResource != NULL );
    CL_ASSERT( gpQuoResource->Group != NULL );
    CL_ASSERT( gpQuoResource->Group->OwnerNode != NULL );

    if ( resource->QuorumResource ||
         (gpQuoResource->Group->OwnerNode == NmLocalNode) ) {
        OmDereferenceObject( resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // The local node must own the resource.
    //
    CL_ASSERT( resource->Group != NULL );
    CL_ASSERT( resource->Group->OwnerNode != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) {
        OmDereferenceObject( resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Just call the function that does the work.
    //
    OmNotifyCb( resource, NOTIFY_RESOURCE_PREONLINE );

    status = RmOnlineResource( resource->Id, pdwState );
    //call the synchronous notifications on the resource
    FmpCallResourceNotifyCb(resource, *pdwState);

    OmDereferenceObject( resource );

    return(status);

} // FmsRmOnlineResource



error_status_t
s_FmsRmOfflineResource(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Receives a Resource Offline Request from (THE) remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.

    ResourceId - The Id of the Resource to bring offline.

    State - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    We can't acquire any locks... but the originating thread has the
    lock held for us.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
              "[FM] s_FmsRmOfflineResource: To take resource '%1!ws!' offline\n",
              ResourceId);

    //
    // Find the specified resource.
    //
    resource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( resource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRmOfflineResource: Could not find Resource %1!ws!\n",
                  ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // This must not be done on the quorum resource, and the local system
    // must not own the quorum resource. We'll assume that the quorum
    // resource migrated while we were performng this request.
    //
    CL_ASSERT( gpQuoResource != NULL );
    CL_ASSERT( gpQuoResource->Group != NULL );
    CL_ASSERT( gpQuoResource->Group->OwnerNode != NULL );

    if ( resource->QuorumResource ||
         (gpQuoResource->Group->OwnerNode == NmLocalNode) ) {
        OmDereferenceObject( resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    //
    // The local node must own the resource.
    //
    CL_ASSERT( resource->Group != NULL );
    CL_ASSERT( resource->Group->OwnerNode != NULL );
    if ( resource->Group->OwnerNode != NmLocalNode ) {
        OmDereferenceObject( resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Just call the function that does the work.
    //
    OmNotifyCb( resource, NOTIFY_RESOURCE_PREOFFLINE );

    status = RmOfflineResource( resource->Id, pdwState );

    //call the post offline obj synchronous notifications
    FmpCallResourceNotifyCb(resource, *pdwState);

    OmDereferenceObject( resource );

    return(status);

} // FmsRmOfflineResource

error_status_t
s_FmsBackupClusterDatabase(
    IN handle_t IDL_handle,
    IN LPCWSTR  ResourceId,
    IN LPCWSTR  lpszPathName
    )

/*++

Routine Description:

    Receives a request to backup the quorum log file and the checkpoint
    file

Arguments:

    IDL_handle - The binding context - not used.
    ResourceId - The Id of the quorum resource
    lpszPathName - The directory path name where the files have to be 
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    DWORD           Status;

    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] s_FmsBackupClusterDatabase: Entry...\r\n");

    //
    //  Chittur Subbaraman (chitturs) - 10/12/1998
    //
    //  Find the specified quorum resource
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, ResourceId );

    if ( pResource == NULL )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsBackupClusterDatabase: Could not find Resource %1!ws!\n",
                  ResourceId);
        Status = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    FmpAcquireLocalResourceLock( pResource );

    CL_ASSERT( pResource->Group != NULL );

    //
    //  Make sure the local node owns the quorum resource
    //
    if ( pResource->Group->OwnerNode == NmLocalNode )
    {
        Status = FmpBackupClusterDatabase( pResource, lpszPathName );
    }
    else
    {
        Status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsBackupClusterDatabase: This node is not the quorum resource owner...\n"
                  );
    }
    
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    if ( pResource ) OmDereferenceObject( pResource );
    return( Status );
} // FmsBackupClusterDatabase

error_status_t
s_FmsChangeResourceGroup(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszGroupId
    )

/*++

Routine Description:

    Receives a Resource change group request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    pszResourceId - The Id of the Resource to change a resource
    pszGroupId - The Id of the Group to change to.
    
Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_GROUP       pNewGroup = NULL;
    DWORD           dwStatus;
    PFM_GROUP       pOldGroup;

    FmpMustBeOnline( );

    //
    // Find the specified resource.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsChangeResourceNode: Could not find Resource %1!ws!\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    //
    // Find the specified group.
    //
    pNewGroup = OmReferenceObjectById( ObjectTypeGroup, pszGroupId );

    if ( pNewGroup == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsChangeResourceGroupe: Could not find NewGroup %1!ws!\n",
                  pszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
       "[FM] s_FmChangeResourceGroup : Resource <%1!ws!> NewGroup %2!ws!\n",
       OmObjectId( pResource ),
       OmObjectId( pNewGroup ));

    //
    // Synchronize both the old and the new groups.
    // Lock the lowest by lowest Group Id first - to prevent deadlocks!
    // Note - the order of release is unimportant.
    //
    // strictly, the comparison below cannot be equal!
    //
    if ( lstrcmpiW( OmObjectId( pResource->Group ), OmObjectId( pNewGroup ) ) <= 0 ) {
        FmpAcquireLocalGroupLock( pResource->Group );
        FmpAcquireLocalGroupLock( pNewGroup );
    } else {
        FmpAcquireLocalGroupLock( pNewGroup );
        FmpAcquireLocalGroupLock( pResource->Group );
    }

    //remember the old group for freeing locks
    pOldGroup = pResource->Group;

    //boy if we are not the owner any more
    //shunt the request to the new owner
    if ( pResource->Group->OwnerNode != NmLocalNode ) 
    {
        // Note: FmcChangeResourceNode must release the resource lock.
        dwStatus = FmcChangeResourceGroup( pResource, pNewGroup );
        goto FnExit;
    } 
    else 
    {
        dwStatus = FmpChangeResourceGroup( pResource, pNewGroup );
    }

    FmpReleaseLocalGroupLock( pNewGroup );
    FmpReleaseLocalGroupLock( pOldGroup );
    
FnExit:
    if ( pResource ) OmDereferenceObject( pResource );
    if ( pNewGroup ) OmDereferenceObject( pNewGroup );
    ClRtlLogPrint(LOG_NOISE,
       "[FM] s_FmsChangeResourceGroup : returned <%1!u!>\r\n",
       dwStatus);
    return( dwStatus );
} //s_FmsChangeResourceGroup



error_status_t
s_FmsDeleteGroupRequest(
    IN handle_t IDL_handle,
    IN LPCWSTR pszGroupId
    )

/*++

Routine Description:

    Receives a delete group request from a remote system and returns
    the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    pszGroupId - The Id of the group to be deleted.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_GROUP    pGroup = NULL;
    DWORD        dwStatus = ERROR_SUCCESS;

    FmpMustBeOnline( );

    //
    // Find the specified group.
    //
    pGroup = OmReferenceObjectById( ObjectTypeGroup, pszGroupId );

    if ( pGroup == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsDeleteGroupRequest: Could not find group %1!ws!\n",
                  pszGroupId);
        dwStatus = ERROR_GROUP_NOT_FOUND;
        goto FnExit;
    }

    FmpAcquireLocalGroupLock( pGroup );

    if ( pGroup->OwnerNode == NmLocalNode )
    {
        dwStatus = FmpDeleteGroup( pGroup );
    }
    else
    {
        //
        // FmcDeleteGroup releases the group lock
        //
        dwStatus = FmcDeleteGroupRequest( pGroup );
        goto FnExit;
    }

    FmpReleaseLocalGroupLock( pGroup );
    
FnExit:
    if ( pGroup ) OmDereferenceObject( pGroup );
    return( dwStatus );
} //s_FmsChangeResourceGroup


error_status_t
s_FmsAddResourceDependency(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszDependsOnId
    )

/*++

Routine Description:

    Receives an add resource dependency request from a remote system 
    and returns the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    
    pszResourceId - The Id of the resource to add a dependent resource.

    pszDependentResourceId - The Id of the dependent resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_RESOURCE    pDependentResource = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwResourceLen;
    DWORD           dwDependsOnLen;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Handle add resource dependency RPC calls from non-owner nodes
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Resource <%1!ws!>, Dependent Resource <%2!ws!>\n",
                  pszResourceId,
                  pszDependsOnId);

    //
    // Find the specified resources.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Could not find resource <%1!ws!>\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    pDependentResource = OmReferenceObjectById( ObjectTypeResource, 
                                                pszDependsOnId );

    if ( pDependentResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsAddResourceDependency: Could not find dependent resource <%1!ws!>\n",
                  pszDependsOnId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }
    //    
    // Acquire the resource lock 
    //
    FmpAcquireLocalResourceLock( pResource );

    if ( pResource->Group->OwnerNode != NmLocalNode )
    {
        dwStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnUnlock;
    }

    dwStatus = FmpValAddResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnUnlock;
    }

    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );

    
    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateAddDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      FALSE );
    }

FnUnlock:
    FmpReleaseLocalResourceLock( pResource );


FnExit:
    if ( pResource ) OmDereferenceObject( pResource );

    if ( pDependentResource ) OmDereferenceObject( pDependentResource );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsAddResourceDependency Exit: Status = %1!u!\n",
                  dwStatus);

    return( dwStatus );
} // s_FmsAddResourceDependency

error_status_t
s_FmsRemoveResourceDependency(
    IN handle_t IDL_handle,
    IN LPCWSTR pszResourceId,
    IN LPCWSTR pszDependsOnId
    )

/*++

Routine Description:

    Receives a remove resource dependency request from a remote system 
    and returns the status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    
    pszResourceId - The Id of the resource to remove a dependent resource from.

    pszDependentResourceId - The Id of the dependent resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

--*/

{
    PFM_RESOURCE    pResource = NULL;
    PFM_RESOURCE    pDependentResource = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwResourceLen;
    DWORD           dwDependsOnLen;

    //
    //  Chittur Subbaraman (chitturs) - 5/16/99
    //
    //  Handle remove resource dependency RPC calls from non-owner nodes
    //
    FmpMustBeOnline( );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Resource <%1!ws!>, Dependent Resource <%2!ws!>\n",
                  pszResourceId,
                  pszDependsOnId);

    //
    // Find the specified resources.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, pszResourceId );

    if ( pResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Could not find resource <%1!ws!>\n",
                  pszResourceId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }

    pDependentResource = OmReferenceObjectById( ObjectTypeResource, 
                                                pszDependsOnId );

    if ( pDependentResource == NULL ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: Could not find dependent resource <%1!ws!>\n",
                  pszDependsOnId);
        dwStatus = ERROR_RESOURCE_NOT_FOUND;
        goto FnExit;
    }
    //    
    // Acquire the resource lock 
    //
    FmpAcquireLocalResourceLock( pResource );

    dwStatus = FmpValRemoveResourceDependency( pResource, pDependentResource );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] s_FmsRemoveResourceDependency: FmpValRemoveResourceDependency returns %1!u!\n",
                  dwStatus);
        goto FnUnlock;
    }

    if ( pResource->Group->OwnerNode != NmLocalNode )
    {
        dwStatus = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
        goto FnUnlock;
    }

    pszResourceId = OmObjectId( pResource );
    dwResourceLen = ( lstrlenW( pszResourceId ) + 1 ) * sizeof( WCHAR );

    pszDependsOnId = OmObjectId( pDependentResource );
    dwDependsOnLen = ( lstrlenW( pszDependsOnId ) + 1 ) * sizeof( WCHAR );


    dwStatus = GumSendUpdateEx( GumUpdateFailoverManager,
                                FmUpdateRemoveDependency,
                                2,
                                dwResourceLen,
                                pszResourceId,
                                dwDependsOnLen,
                                pszDependsOnId );

    if ( dwStatus == ERROR_SUCCESS ) 
    {
        FmpBroadcastDependencyChange( pResource,
                                      pszDependsOnId,
                                      TRUE );
    }
    
FnUnlock:
    FmpReleaseLocalResourceLock( pResource );

FnExit:
    if ( pResource ) OmDereferenceObject( pResource );

    if ( pDependentResource ) OmDereferenceObject( pDependentResource );

    ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsRemoveResourceDependency Exit: Status = %1!u!\n",
                  dwStatus);

    return( dwStatus );
} // s_FmsRemoveResourceDependency

error_status_t
s_FmsCreateResource2(
    IN handle_t IDL_handle,
    IN LPCWSTR GroupId,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Receives a Create Resource Request from a remote system and returns
    status for that request.

Arguments:

    IDL_handle - The binding context - not used.
    GroupId - The Id of the Group to create the resource inside.
    ResourceId - The Id of the Resource to create.
    ResourceName - The name of the Resource to create.
    ResourceType - The name of the Resource Type.
    dwFlags - Flags for the resource.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on error.

Notes:

    The Resource lock is acquired to synchronize access to the resource. This
    satisfies locking the resource on all nodes in the cluster... so long
    as the local node is the owner of the resource.

--*/

{
    PFM_GROUP group;
    DWORD status;
    PGUM_CREATE_RESOURCE gumResource;
    DWORD groupIdLen;
    DWORD resourceIdLen;
    DWORD resourceNameLen;
    DWORD resourceTypeLen;
    DWORD bufSize;
    HDMKEY resourceKey;
    HDMKEY paramsKey;
    DWORD  disposition;

    FmpMustBeOnline();

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmsCreateResource2: To create resource '%1!ws!'\n",
               ResourceId);

    //
    // Find the specified group.
    //
    group = OmReferenceObjectById( ObjectTypeGroup,
                                   GroupId );

    if ( group == NULL ) {
        ClRtlLogPrint(LOG_NOISE,
                  "[FM] FmsCreateResource2: Could not find Group %1!ws!\n",
                  GroupId);
        return(ERROR_GROUP_NOT_FOUND);
    }

    FmpAcquireLocalGroupLock( group );

    //
    // Now delete it on all nodes in the cluster if we are the owner.
    //
    if ( group->OwnerNode == NmLocalNode ) {
        //
        // Allocate a message buffer.
        //
        groupIdLen = (lstrlenW(GroupId)+1) * sizeof(WCHAR);
        resourceIdLen = (lstrlenW(ResourceId)+1) * sizeof(WCHAR);
        resourceNameLen = (lstrlenW(ResourceName)+1) * sizeof(WCHAR);
        resourceTypeLen = (lstrlenW(ResourceType)+1) * sizeof(WCHAR);
        bufSize = sizeof(GUM_CREATE_RESOURCE) - sizeof(WCHAR) +
                  groupIdLen + resourceIdLen + resourceNameLen + resourceTypeLen + 2 * sizeof( DWORD );
        gumResource = LocalAlloc(LMEM_FIXED, bufSize);
        if (gumResource == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, "[FM] FmsCreateResource2: Unable to allocate memory for resource %1!ws!\n",
                         ResourceName);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Fill in message buffer.
        //
        gumResource->Resource = NULL;
        gumResource->GroupIdLen = groupIdLen;
        gumResource->ResourceIdLen = resourceIdLen;
        CopyMemory(gumResource->GroupId, GroupId, groupIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen,
                   ResourceId,
                   resourceIdLen);
        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen,
                   ResourceName,
                   resourceNameLen);

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen,
                   &resourceTypeLen,
                   sizeof( DWORD ) );

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen + sizeof( DWORD ),
                   ResourceType,
                   resourceTypeLen );

        CopyMemory((PCHAR)gumResource->GroupId + groupIdLen + resourceIdLen + resourceNameLen + sizeof( DWORD ) + resourceTypeLen,
                   &dwFlags,
                   sizeof( DWORD ) );
        //
        // Send message.
        //
        status = GumSendUpdate(GumUpdateFailoverManager,
                               FmUpdateCreateResource,
                               bufSize,
                               gumResource);
        if ( ( status == ERROR_SUCCESS ) && 
             ( gumResource->Resource != NULL ) )
        {
            //
            //  If the GUM call was successful, ensure that the resource DLL initialization stuff is
            //  also done so that APIs following the CreateClusterResource API can make assumptions
            //  that the resource is fully created. Note that the GUM call above will post a work item
            //  for the FM worker thread to initialize a resource but there is no guarantee when the
            //  FM worker thread will act on the work item. The following call will make sure we 
            //  won't return from this API until the initialization is fully done thus not giving any
            //  chance for APIs such as ChangeClusterResourceGroup that follow this API to screw things
            //  up. For backward compatibility reasons (consider a create call originating from a
            //  W2K node), we still keep the work item posting in GUM and it won't do any harm since
            //  the FmpInitializeResource call is idempotent.
            //
            FmpClusterWideInitializeResource ( gumResource->Resource );
            FmpCleanupPossibleNodeList(gumResource->Resource); 
        }

        if( ( gumResource->Resource == NULL ) && FmpShutdown ) {
            status = ERROR_CLUSTER_NODE_SHUTTING_DOWN;
        }
        LocalFree(gumResource);
    } else {
        status = ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
    }

    FmpReleaseLocalGroupLock( group );

    return(status);

} // FmsCreateResource2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\reslist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reslist.c

Abstract:

    Cluster resource list processing routines.

Author:

    Rod Gamache (rodga) 21-Apr-1997


Revision History:


--*/

#include "fmp.h"


//
// Global data
//

//
// Local function prototypes
//
BOOL FmpCheckResourcesToOnline(
    IN PRESOURCE_ENUM  pResEnum
    );

DWORD
FmpAddResourceEntry(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource
    );



DWORD
FmpGetResourceList(
    OUT PRESOURCE_ENUM *ReturnEnum,
    IN PFM_GROUP Group
    )

/*++

Routine Description:

    Enumerates all the list of all resources in the Group and returns their
    state.

Arguments:

    ReturnEnum - Returns the requested objects.

    Resource - Supplies the resource to filter. (i.e. if you supply this, you
                get a list of resources within that Resource)

                If not present, all resources are returned.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code on error.

Notes:

    This routine should be called with the LocalGroupLock held.

--*/

{
    DWORD status;
    PRESOURCE_ENUM resourceEnum = NULL;
    DWORD          allocated;
    PFM_RESOURCE   resource;
    PLIST_ENTRY    listEntry;

    allocated = ENUM_GROW_SIZE;

    resourceEnum = LocalAlloc(LMEM_FIXED, RESOURCE_SIZE(ENUM_GROW_SIZE));
    if ( resourceEnum == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEnum, RESOURCE_SIZE(ENUM_GROW_SIZE) );
    //set the contains quorum to -1, if the quorum  is present
    // in this group then the containsquorum is set to the index
    // of the quorum resource
    // The quorum resource should be brought offline last and be
    // brought online first so that the registry replication data
    // can be flushed
    resourceEnum->ContainsQuorum = -1;
    //resourceEnum->EntryCount = 0;

    //
    // Enumerate all resources in the group.
    //
    for ( listEntry = Group->Contains.Flink;
          listEntry != &(Group->Contains);
          listEntry = listEntry->Flink ) {
        resource = CONTAINING_RECORD( listEntry,
                                      FM_RESOURCE,
                                      ContainsLinkage );
        status = FmpAddResourceEntry( &resourceEnum,
                                      &allocated,
                                      resource );
        if ( status != ERROR_SUCCESS ) {
            FmpDeleteResourceEnum( resourceEnum );
            goto error_exit;
        }
        //check if the resource is a quorum resource
        if (resource->QuorumResource)
            resourceEnum->ContainsQuorum = resourceEnum->EntryCount - 1;            
        resourceEnum->Entry[resourceEnum->EntryCount-1].State = resource->PersistentState;
    }

    *ReturnEnum = resourceEnum;
    return(ERROR_SUCCESS);

error_exit:

    *ReturnEnum = NULL;
    return(status);

} // FmpGetResourceList



DWORD
FmpOnlineResourceList(
    IN PRESOURCE_ENUM  ResourceEnum,
    IN PFM_GROUP       pGroup
    )

/*++

Routine Description:

    Brings online all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to bring online.

    pGroup - the group with which the resources are associated.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;
    BOOL  bResourcesToOnline;

    //
    // If the cluster service is shutting and this is not the quorum group,
    // then fail immediately. Otherwise, try to bring the quorum online first.
    //
    if ( FmpShutdown &&
         ResourceEnum->ContainsQuorum == -1 ) {
        return(ERROR_INVALID_STATE);
    }

    //find out if atleast one resource in the list necessitates coming being brought online
    bResourcesToOnline = FmpCheckResourcesToOnline(ResourceEnum);
    if (bResourcesToOnline)
    {     
        //log an event saying we are trying on online a group
        FmpLogGroupInfoEvent1( FM_EVENT_GROUP_START_ONLINE, OmObjectName(pGroup));
    }
    
    // if the quorum resource is contained in here, bring it online first
    if (ResourceEnum->ContainsQuorum >= 0)
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);
        
        resource = OmReferenceObjectById( ObjectTypeResource,
                        ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );


        // the resource should not vanish, we are holding the group lock after all
        CL_ASSERT(resource != NULL);
        //
        // If we fail to find a resource, then just continue
        //
        if ( resource != NULL ) {

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceList: Previous quorum resource state for %1!ws! is %2!u!\r\n",
                       OmObjectId(resource), ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State);

            if ( (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceOnline) ||
                 (ResourceEnum->Entry[ResourceEnum->ContainsQuorum].State == ClusterResourceFailed) ) {
                //
                // Now bring the resource online if that is it's current state.
                //
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOnlineResourceList: trying to bring quorum resource %1!ws! online, state %2!u!\n",
                           OmObjectId(resource),
                           resource->State);

                status = FmpOnlineResource( resource, FALSE );
                if ( status != ERROR_SUCCESS ) {
                    returnStatus = status;
                }
            }
            OmDereferenceObject( resource );
        }            
    }

    // SS::: TODO what happens to the persistent state of the
    // other resources - is it handled correctly - note that this is 
    // called on moving a group
    // Will the restart policy do the right thing in terms of bringing
    // them online
    // if the quorum resource has failed, dont bother trying
    // to bring the rest of the resourcess online
    if ((returnStatus != ERROR_SUCCESS) && (returnStatus != ERROR_IO_PENDING))
    {
        //retry after a while
        FmpSubmitRetryOnline(ResourceEnum, pGroup);
        goto FnExit;
    }

    // bring online all of the other resources
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );


        //
        // If we fail to find a resource, then just continue.
        //
        if ( resource == NULL ) {
            status = ERROR_RESOURCE_NOT_FOUND;
            continue;
        }

        //quorum resource has already been handled 
        if (resource->QuorumResource)
        {
            OmDereferenceObject(resource);
            continue;
        }           
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineResourceList: Previous resource state for %1!ws! is %2!u!\r\n",
                   OmObjectId(resource), ResourceEnum->Entry[i].State);

        if ( (ResourceEnum->Entry[i].State == ClusterResourceOnline) ||
             (ResourceEnum->Entry[i].State == ClusterResourceFailed) ) {
            //
            // Now bring the resource online if that is it's current state.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineResourceList: trying to bring resource %1!ws! online\n",
                       OmObjectId(resource));

            status = FmpOnlineResource( resource, FALSE );
            //overwrite the return status only if it is success
            //else the first error is returned
            if ( returnStatus == ERROR_SUCCESS ) {
                returnStatus = status;
            }
            //if this resource didnt come online because the quorum resource                
            //didnt come online, dont bother bringing the other resources online
            //just a waste of time
            if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
            {
                //submit a timer callback to try and bring these resources
                //online
                FmpSubmitRetryOnline(ResourceEnum, pGroup);
                OmDereferenceObject( resource );
                break;
            }                

        }
        OmDereferenceObject( resource );
    }

FnExit:
    if (returnStatus == ERROR_IO_PENDING)
    {
        CL_ASSERT(bResourcesToOnline);
        pGroup->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT; 
        //the failed or success event will get logged later on
    }
    else if (returnStatus == ERROR_SUCCESS)
    {
        if (bResourcesToOnline)
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_COMPLETE_ONLINE, OmObjectName(pGroup));
    }
    else
    {
        //SS: log an event to say that the online process failed
        if (bResourcesToOnline)
            FmpLogGroupInfoEvent1( FM_EVENT_GROUP_FAILED_ONLINE_OFFLINE, OmObjectName(pGroup));
    }
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineResourceList: Exit, status=%1!u!\r\n",
               returnStatus);
    return(returnStatus);

} // FmpOnlineResourceList




DWORD
FmpOfflineResourceList(
    IN PRESOURCE_ENUM ResourceEnum,
    IN BOOL Restore
    )

/*++

Routine Description:

    Takes offline all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to take offline.

    Restore - TRUE if we should set the resource back to it's previous state

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD status=ERROR_SUCCESS;
    DWORD returnStatus = ERROR_SUCCESS;
    DWORD i;
    CLUSTER_RESOURCE_STATE prevState;

    // offline all resources except the quorum resource
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        //quorum resource is brought offline last
        if (resource->QuorumResource)
        {
            OmDereferenceObject(resource);
            continue;
        }
        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            prevState = resource->State;
            status = FmpOfflineResource( resource, FALSE );
            if ( Restore ) {
                //FmpPropagateResourceState( resource, prevState );
                //resource->State = prevState;
            }
        }

        OmDereferenceObject( resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            return(status);
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }

    }

    // bring the quorum resource offline now
    // This allows other resources to come offline and save their checkpoints
    // The quorum resource offline should block till the resources have
    // finished saving the checkpoint
    if ((ResourceEnum->ContainsQuorum >= 0) && (returnStatus == ERROR_SUCCESS))
    {
        CL_ASSERT((DWORD)ResourceEnum->ContainsQuorum < ResourceEnum->EntryCount);

        resource = OmReferenceObjectById( ObjectTypeResource,
                ResourceEnum->Entry[ResourceEnum->ContainsQuorum].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            status = FmpOfflineResource( resource, FALSE );
        }

        OmDereferenceObject( resource );

        if ( (status != ERROR_SUCCESS) &&
             (status != ERROR_IO_PENDING) ) {
            return(status);
        }
        if ( status == ERROR_IO_PENDING ) {
            returnStatus = ERROR_IO_PENDING;
        }
    }
    
    return(returnStatus);

} // FmpOfflineResourceList



DWORD
FmpTerminateResourceList(
    PRESOURCE_ENUM ResourceEnum
    )

/*++

Routine Description:

    Terminates all resources in the Enum list.

Arguments:

    ResourceEnum - The list of resources to take offline.

Returns:

    ERROR_SUCCESS if successful.

    Win32 error code on failure.

--*/

{
    PFM_RESOURCE resource;
    DWORD i;

    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );

        if ( resource == NULL ) {
            return(ERROR_RESOURCE_NOT_FOUND);
        }

        //
        // Now take the Resource offline, if we own it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            FmpTerminateResource( resource );
        }

        OmDereferenceObject( resource );
    }
    //for now we dont care about the return
    return(ERROR_SUCCESS);
    
} // FmpTerminateResourceList



DWORD
FmpAddResourceEntry(
    IN OUT PRESOURCE_ENUM *Enum,
    IN LPDWORD Allocated,
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Worker routine for the enumeration of Resources.
    This routine adds the specified Resource to the list that is being
    generated.

Arguments:

    Enum - The Resource Enumeration list. Can be an output if a new list is
            allocated.
    Allocated - The number of entries allocated.
    Resource - The Resource object being enumerated.

Returns:

    ERROR_SUCCESS - if successful.
    A Win32 error code on failure.

--*/

{
    PRESOURCE_ENUM resourceEnum;
    PRESOURCE_ENUM newEnum;
    DWORD newAllocated;
    DWORD index;
    LPWSTR newId;

    resourceEnum = *Enum;

    if ( resourceEnum->EntryCount >= *Allocated ) {
        //
        // Time to grow the RESOURCE_ENUM
        //

        newAllocated = *Allocated + ENUM_GROW_SIZE;
        newEnum = LocalAlloc(LMEM_FIXED, RESOURCE_SIZE(newAllocated));
        if ( newEnum == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        CopyMemory(newEnum, resourceEnum, RESOURCE_SIZE(*Allocated));
        *Allocated = newAllocated;
        *Enum = newEnum;
        LocalFree(resourceEnum);
        resourceEnum = newEnum;
    }

    //
    // Initialize new entry
    //
    newId = LocalAlloc(LMEM_FIXED, (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR));
    if ( newId == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    lstrcpyW(newId, OmObjectId(Resource));
    resourceEnum->Entry[resourceEnum->EntryCount].Id = newId;
    ++resourceEnum->EntryCount;

    return(ERROR_SUCCESS);

} // FmpAddResourceEntry



VOID
FmpDeleteResourceEnum(
    IN PRESOURCE_ENUM Enum
    )

/*++

Routine Description:

    This routine deletes an RESOURCE_ENUM and associated name strings.

Arguments:

    Enum - The RESOURCE_ENUM to delete. This pointer can be NULL.

Returns:

    None.

Notes:

    This routine will take a NULL input pointer and just return.

--*/

{
    PRESOURCE_ENUM_ENTRY enumEntry;
    DWORD i;

    if ( Enum == NULL ) {
        return;
    }

    for ( i = 0; i < Enum->EntryCount; i++ ) {
        enumEntry = &Enum->Entry[i];
        LocalFree(enumEntry->Id);
    }

    LocalFree(Enum);
    return;

} // FmpDeleteResourceEnum


DWORD FmpSubmitRetryOnline(
    IN PRESOURCE_ENUM   pResourceEnum,
    IN PFM_GROUP        pGroup)
{

    PFM_RESLIST_ONLINE_RETRY_INFO   pFmOnlineRetryInfo;
    PRESOURCE_ENUM_ENTRY            enumEntry;
    DWORD                           dwSizeofResourceEnum;
    DWORD                           dwStatus = ERROR_SUCCESS;
    DWORD                           i;
    DWORD                           dwSize;
    
    //there is nothing to do
    if (pResourceEnum->EntryCount < 1)
        goto FnExit;
        
    dwSizeofResourceEnum = sizeof(RESOURCE_ENUM) - sizeof(RESOURCE_ENUM_ENTRY) + 
        (sizeof(RESOURCE_ENUM_ENTRY) * pResourceEnum->EntryCount);
    pFmOnlineRetryInfo = LocalAlloc(LMEM_FIXED, 
        (sizeof(FM_RESLIST_ONLINE_RETRY_INFO) - sizeof(RESOURCE_ENUM) + 
            dwSizeofResourceEnum));

    if (!pFmOnlineRetryInfo)
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }

    //SS: use the group field for logging
    //reference the group object
    if (pGroup)
        OmReferenceObject(pGroup);
    pFmOnlineRetryInfo->pGroup = pGroup;
    
    memcpy(&(pFmOnlineRetryInfo->ResourceEnum), pResourceEnum, dwSizeofResourceEnum);

    // allocate memory for Resource ID's and copy them from pResourceEnum
    for ( i = 0; i < pResourceEnum->EntryCount; i++ ) {
        enumEntry = &pResourceEnum->Entry[i];
        pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id = NULL;
        dwSize = (lstrlenW(enumEntry->Id) +1)*sizeof(WCHAR);
        pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id = (LPWSTR)(LocalAlloc(LMEM_FIXED,dwSize));
        if (!pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id )
        {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            CL_UNEXPECTED_ERROR(dwStatus);
            goto FnExit;
        }
        CopyMemory(pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id, enumEntry->Id, dwSize);        
    }


    dwStatus = FmpQueueTimerActivity(FM_TIMER_RESLIST_ONLINE_RETRY, 
        FmpReslistOnlineRetryCb, pFmOnlineRetryInfo );
        
FnExit: 
    return(dwStatus);
}

/****
@func       DWORD | FmpCheckResourcesToOnline| This routine walks a 
            resource list and returns TRUE, if atleast one of the resources
            in the group must be brought online.

@parm       IN PRESOURCE_ENUM | pResEnum | A pointer to a list of resources
            in the group.
            
@comm       This is called from FmpOnlineResourceList() to determine if the
            group info events should be logged.  For groups that have no 
            resources to be onlined, we should not log the starting online event.
            This routine must be called with the group lock held.  It is called
            by FmpOnlineResourceList().

@rdesc      Returns TRUE if atleast one of the resources in the list must be onlined.
****/
BOOL FmpCheckResourcesToOnline(
    IN PRESOURCE_ENUM  pResEnum
    )
{
    PFM_RESOURCE    pResource;
    DWORD           i;
    BOOL            bRet = FALSE;
    
    for ( i = 0; i < pResEnum->EntryCount; i++ ) 
    {
        pResource = OmReferenceObjectById( ObjectTypeResource,
                                          pResEnum->Entry[i].Id );

        //
        // If we fail to find a resource, then just continue.
        //
        if ( pResource == NULL ) {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpCheckResourcesToOnline: Resource for ResId %1!ws! not found.\n",
                   pResEnum->Entry[i].Id);
            continue;
        }

        //check if this is the quorum resource 
        if (pResource->QuorumResource)
        {
            //if the quorum resource is in the group, it must be brought online
            //irrespective of its state
            bRet = TRUE;
            OmDereferenceObject(pResource);
            break;
        }           

        if ( (pResEnum->Entry[i].State == ClusterResourceOnline) ||
             (pResEnum->Entry[i].State == ClusterResourceFailed) ) 
        {
            bRet = TRUE;
            OmDereferenceObject(pResource);
            break;        
        }
        OmDereferenceObject(pResource);
    }
    
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\resource.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Cluster resource management routines.

Author:

    Mike Massa (mikemas) 1-Jan-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

//globals

#define LOG_MODULE RESOURCE


//
// Global Data
//
CRITICAL_SECTION  FmpResourceLock;

//
// Local Data
//

typedef struct PENDING_CONTEXT {
    PFM_RESOURCE Resource;
    BOOL         ForceOnline;
} PENDING_CONTEXT, *PPENDING_CONTEXT;


//
// Local function prototypes
//



/////////////////////////////////////////////////////////////////////////////
//
// Resource List Maintenance Routines
//
/////////////////////////////////////////////////////////////////////////////

BOOL
FmpFindResourceByNotifyKeyWorker(
    IN RM_NOTIFY_KEY NotifyKey,
    IN PFM_RESOURCE *FoundResource,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Enumeration callback routine for finding a resource by notify key

Arguments:

    FoundResource - Returns the found resource.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching resource is returned in
        *FoundResource

--*/

{
    if ((RM_NOTIFY_KEY)Resource == NotifyKey) {
        *FoundResource = Resource;
        return(FALSE);
    }
    return(TRUE);

} // FmpFindResourceByNotifyKeyWorker



PFM_RESOURCE
FmpFindResourceByNotifyKey(
    RM_NOTIFY_KEY   NotifyKey
    )

/*++

Routine Description:

Arguments:

Returns:

--*/

{
    PFM_RESOURCE  resource = NULL;

    OmEnumObjects(ObjectTypeResource,
                  (OM_ENUM_OBJECT_ROUTINE)FmpFindResourceByNotifyKeyWorker,
                  (PVOID)NotifyKey,
                  &resource);
    return(resource);

} // FmpFindResourceByNotifyKey


//////////////////////////////////////////////////////////////
//
// Interfaces for managing resources.
//
/////////////////////////////////////////////////////////////


PFM_RESOURCE
FmpCreateResource(
    IN  PFM_GROUP   Group,
    IN  LPCWSTR     ResourceId,
    IN  LPCWSTR     ResourceName,
    IN  BOOL        Initialize
    )

/*++

Routine Description:

    Create a resource in our list of resources.

Arguments:

    Group - The Group in which this resource belongs.

    ResourceId - The id of the resource being created.

    ResourceName - The name of the resource being created.

    Initialize - TRUE if the resource should be initialized from the registry.
                 FALSE if the resource should be left un-initialized.

Returns:

    A pointer to the resource that was created or NULL.

Notes:

    1) The resource lock must be held when this routine is called.

    2) If the resource was created, then the reference count on the resource
    is 2 when this routine returns. If the resource was not created, then
    the reference count on the resource is not incremented. That way, if
    the caller needs extra references on the resource, then it must place
    them itself. This can be done later, since the resource lock is held.

--*/

{
    DWORD           mszStringIndex;
    PFM_RESOURCE    resource = NULL;
    DWORD           status;
    PDEPENDENCY     dependency = NULL;
    DWORD           resourceNameSize=
                          (wcslen(ResourceId) * sizeof(WCHAR)) +
                          sizeof(UNICODE_NULL);
    BOOL            created;
    LPWSTR          quorumId = NULL;
    DWORD           quorumIdSize = 0;
    DWORD           quorumIdMaxSize = 0;

    //
    // Open an existing resource or create a new one.
    //
    resource = OmCreateObject( ObjectTypeResource,
                               ResourceId,
                               ResourceName,
                               &created);
    if ( resource == NULL ) {
        return(NULL);
    }

    //
    // If we did not create a new resource, then make sure the Groups match.
    //
    if ( !created )
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] CreateResource, Opened existing resource %1!ws!\n",
                   ResourceId);
        OmDereferenceObject( resource );
        //the quorum group may be created again recursively before phase 1
        //in this case we dont want to do the special processing for putting
        //it on the quorum group contains list
        if ( resource->Group == Group )
        {
            return(resource);
        }
        //the quorum group is destroyed at initialization but not the quorum resource
        if (!FmpFMOnline)
        {
            //the quorum group is being recreated for the second time
            //the quorum group state needs to be refigured
            // this is done after all groups are created in FmFormNewClusterPhase2()

            if (resource->QuorumResource)
            {
                ClRtlLogPrint(LOG_NOISE,"[FM] ReCreating quorum resource %1!ws!\n", ResourceId);
                Group->OwnerNode = NmLocalNode;
                InsertTailList( &Group->Contains,
                    &resource->ContainsLinkage );
                //add a referenece to the resource object for being on the contains list
                OmReferenceObject( resource );
                resource->Group = Group;
                OmReferenceObject(Group);
                //SS: for now we dont use resource locks, so dont create it and leak it !
                //InitializeCriticalSection( &resource->Lock );
                FmpSetPreferredEntry( Group, NmLocalNode );
                return(resource);
            }
        }
        else
        {
            SetLastError(ERROR_RESOURCE_NOT_AVAILABLE);
            return(NULL);
        }

    }

    ClRtlLogPrint(LOG_NOISE,"[FM] Creating resource %1!ws!\n", ResourceId);

    resource->dwStructState = FM_RESOURCE_STRUCT_CREATED;

    //
    // Initialize the resource.
    //
    resource->Group = Group;
    resource->State = ClusterResourceOffline;  // Initial value for state.
    // resource->Flags = 0;             // Structure zeroed at creation
    // resource->Id = 0;
    // resource->FailureTime = 0;
    // resource->QuorumResource = FALSE;
    // resource->PossibleList = FALSE;
    //SS: for now we dont use resource locks, so dont create it and leak it !
    //InitializeCriticalSection( &resource->Lock );
    resource->hTimer=NULL;
    InitializeListHead( &(resource->ProvidesFor) );
    InitializeListHead( &(resource->DependsOn) );
    InitializeListHead( &(resource->PossibleOwners) );
    InitializeListHead( &(resource->DmRundownList) );

    //
    // Insert the new resource onto the Group's contains list.
    //
    InsertTailList( &Group->Contains,
                    &resource->ContainsLinkage );
    //SS: there is already a reference to the object for being on the resource
    //list
    //add a referenece to the resource object for being on the contains list
    OmReferenceObject( resource );

    //add a reference to the group because the resource has a pointer to it
    OmReferenceObject(Group);

    //
    // Complete initialization if we were told to do so.
    //
    status = FmpInitializeResource( resource, Initialize );

    //
    // Check for distinguished error code to delete this resource.
    //
    if ( status == ERROR_INVALID_NAME ) {
        goto error_exit;
    }
    //
    // On other failures, we must be sure to come back through init later...
    //
    if ( Initialize &&
         (status != ERROR_SUCCESS) ) {
        CL_ASSERT( resource->Monitor == NULL );
    }

    //
    // Now insert this object into the tree... before the dependency
    // list is processed. That way, if there are circular dependencies
    // this will not loop forever.  If we can be assured that there are
    // no circular dependencies, then we can do the insert after creating
    // the dependency tree.
    //
    // if this is being called during initialization, and the resource is
    // is already created it belonged to the group to which the quorum
    // resource belongs to and doesnt need to be inserted into the resource list
    if (FmpFMOnline  || (created))
    {
        status = OmInsertObject( resource );

        if ( status != ERROR_SUCCESS )
            goto error_exit;
    }

    //
    // Check if this is the Quorum Resource.
    //
    status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        &quorumId,
                        &quorumIdMaxSize,
                        &quorumIdSize );

    if ( status != ERROR_SUCCESS) {
         ClRtlLogPrint(LOG_ERROR,
                    "[FM] Failed to read quorum resource, error %1!u!.\n",
                    status);
    }

    //
    // If we're creating the quorum resource, then indicate it.
    //
    if ( (quorumId != NULL) &&
         (lstrcmpiW( quorumId, ResourceId ) == 0) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Found the quorum resource %1!ws!.\n",
                   ResourceId);
        resource->QuorumResource = TRUE;
    }

    LocalFree(quorumId);
    //
    // Create Any Dependencies
    //
    for (mszStringIndex = 0; ; mszStringIndex++) {
        LPCWSTR       nameString;
        PFM_RESOURCE  childResource;


        nameString = ClRtlMultiSzEnum(
                             resource->Dependencies,
                             resource->DependenciesSize/sizeof(WCHAR),
                             mszStringIndex
                             );

        if (nameString == NULL) {
            break;
        }

        //
        // Create the dependency.
        //
        dependency = LocalAlloc(LMEM_FIXED, sizeof(DEPENDENCY));
        if (dependency == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        //
        // Create the child resource recursively. We must also add an
        // additional reference required for the dependency relationship.
        //
        ClRtlLogPrint(LOG_NOISE,"[FM] Resource %1!ws! depends on %2!ws!. Creating...\n",
                  ResourceId,
                  nameString);

        childResource = FmpCreateResource( resource->Group,
                                           nameString,
                                           NULL,
                                           Initialize );
        if (childResource == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,"[FM] Failed to create dep %1!ws! for resource %2!ws!\n",
                      nameString,
                      ResourceId);

            goto error_exit;
        } else {
            //
            // Add a reference to each resource to reflect the
            // dependency.
            //
            OmReferenceObject( childResource );
            OmReferenceObject( resource );
            dependency->DependentResource = resource;
            dependency->ProviderResource = childResource;
            InsertTailList(&childResource->ProvidesFor,
                           &dependency->ProviderLinkage);
            InsertTailList(&resource->DependsOn,
                           &dependency->DependentLinkage);
        }

    }

    resource->dwStructState |= FM_RESOURCE_STRUCT_INITIALIZED;

    ClRtlLogPrint(LOG_NOISE,"[FM] All dependencies for resource %1!ws! created.\n",
                          ResourceId);

    return(resource);

error_exit:

    FmpAcquireLocalResourceLock( resource );

    RemoveEntryList( &resource->ContainsLinkage );
    //dereference the resource object for being removed from the contains linkage
    OmDereferenceObject( resource );

    FmpDestroyResource( resource, FALSE );

    //dereference the resource object, for being removed from the resource list.
    //OmDereferenceObject( resource );
    //delete the extra reference that was added to the group
    //OmDereferenceObject(Group);

    SetLastError(status);
    return(NULL);

} // FmpCreateResource


DWORD
FmpInitializeResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL          Initialize
    )

/*++

Routine Description:

    Initializes a resource from the registry and tells the Resource
    Monitor about the new resource (if the local system can host the
    resource).

Arguments:

    Resource - Supplies the resource to be initialized.

    Initialize - TRUE if the resource should be fully initialized.
                 FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    It is assumed that the resource lock is held.

--*/

{
    DWORD   status;

    if ( Resource->Monitor != NULL ) {
        return(ERROR_ALREADY_INITIALIZED);
    }

    status = FmpQueryResourceInfo( Resource, Initialize );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // If we didn't fully initialize the resource, then leave now.
    //
    if ( !Initialize ) {
        return(ERROR_SUCCESS);
    }

    //
    // This is a newly initialized resource. Tell the Resource Monitor to
    // create it.
    //
    // TODO - we don't want to instantiate resources in the resource
    // monitor that we cannot execute. We must check possible owners list
    // before making this call. We must also make sure the registry
    // parameters are read. We use the Monitor field as a surrogate for
    // determining whether the registry parameters have been read.
    //
    return(FmpRmCreateResource(Resource));

} // FmpInitializeResource



DWORD
FmpOnlineResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    Brings a resource and all its dependencies online. If ERROR_IO_PENDING is
    returned, then no thread is started to complete the online request.

Arguments:

    Resource - Supplies the resource to be brought online

    ForceOnline - TRUE if the resource should be forced online.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_IO_PENDING if the request is pending.
    Win32 error code otherwise.

--*/
{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;
    BOOL          waitingResource = FALSE;
    DWORD         separateMonitor;
    DWORD         onlinestatus;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is not owned by this system, then return error.
    //
    CL_ASSERT( Resource->Group != NULL );
    if (Resource->Group->OwnerNode != NmLocalNode)
    {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }
    //if it is the quorum resource dont check for the node
    //being in the preferred list, we should be able to
    //bring the quorum resource online on any node
    if (!(Resource->QuorumResource) && 
        !FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode, TRUE, Resource ))
    {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_NODE_CANT_HOST_RESOURCE);
    }

    //
    // If the resource is already online, then return immediately.
    //
    if (Resource->State == ClusterResourceOnline) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in online pending state, then return immediately.
    //
    if ( Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // If the resource is in offline pending state, then return immediately.
    //
    if ( Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is not initialized, then initialize it now.
    //
    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    } else {
        //
        // If the separate monitor flag has changed, then close down old
        // resource in resmon, and re-create it.
        //
        separateMonitor = (Resource->Flags & RESOURCE_SEPARATE_MONITOR) ? 1 : 0;
        status = DmQueryDword( Resource->RegistryKey,
                                        CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                        &separateMonitor,
                                        &separateMonitor );

        if ( (!separateMonitor &&
             (Resource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
             (separateMonitor &&
             ((Resource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) {

            status = FmpChangeResourceMonitor( Resource, separateMonitor );
            if ( status != ERROR_SUCCESS ) {
                FmpReleaseLocalResourceLock( Resource );
                return(status);
            }
        }
    }

    //
    // If this resource is supposed to be left offline, then make it so.
    //
    if ( !ForceOnline && (Resource->PersistentState == ClusterResourceOffline) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_ONLINE);
    }

    //
    // Next, make sure there are no resources down the tree that are waiting.
    // This prevents a deadlock where the top of the tree is trying to go
    // offline, while the bottom of the tree is trying to go online.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        if ( (dependency->ProviderResource->State == ClusterResourceOfflinePending) &&
             (dependency->ProviderResource->Flags & RESOURCE_WAITING) ) {
            waitingResource= TRUE;
            break;
        }
    }
    if ( waitingResource ) {
        Resource->Flags |= RESOURCE_WAITING;
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // If the PersistentState is Offline, then reset the current state.
    //
    if ( Resource->PersistentState == ClusterResourceOffline ) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOnline );
    }

    //
    // Make sure the Waiting flag is clear.
    //
    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependencies, bring them online first.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        //
        // Recursively bring the provider resource online.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OnlineResource: %1!ws! depends on %2!ws!. Bring online first.\n",
                   OmObjectId(Resource),
                   OmObjectId(dependency->ProviderResource));
        onlinestatus = FmpDoOnlineResource( dependency->ProviderResource,
                                      ForceOnline );

        if ( onlinestatus != ERROR_SUCCESS ) {
            if ( onlinestatus != ERROR_IO_PENDING ) {
                ClRtlLogPrint(LOG_NOISE,
                      "[FM] OnlineResource: dependency %1!ws! failed %2!d!\n",
                      OmObjectId(dependency->ProviderResource),
                      status);
                FmpReleaseLocalResourceLock( Resource );
                status = onlinestatus;
                return(status);
            } else {
                FmpCallResourceNotifyCb(Resource, ClusterResourceOnlinePending);
                FmpPropagateResourceState( Resource,
                                           ClusterResourceOnlinePending );
                Resource->Flags |= RESOURCE_WAITING;
                if (status == ERROR_SUCCESS)
                    status = onlinestatus;
            }
        }
    }


    //
    // Tell the resource monitor to bring this resource online.
    //
    if ( !(Resource->Flags & RESOURCE_WAITING) ) {
        status = FmpRmOnlineResource( Resource );
    }
#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailOnlineResource) {
        FmpRmFailResource( Resource );
    }
#endif

    FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmpOnlineResource

DWORD
FmpArbitrateResource(
    IN PFM_RESOURCE  pResource
    )

/*++

Routine Description:

    This is called by FM internally.  It makes sure the quorum resource 
    is initialized on a node before sending it the arbitration request. 
    This allows for third party quorum dlls to be installed on a node by
    node basis and  moves to work.  If a DLL is installed on a node and
    if a move operation is performed with a target of that node, the automagic
    calculation of possible node list kicks in. However, since the 
    process of resource initialization is asynchronous, if the FmpTakeGroupRequest()
    is invoked before the worker thread gets to run, the resource may not
    be initialized and hence may not be able to perform the request to arbitrate.
    

Arguments:

    Resource - Supplies the resource to be arbitrated.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code otherwise.

--*/
{
    DWORD   dwStatus;
    DWORD   dwSeparateMonitor;
 
    CL_ASSERT( pResource->Group != NULL );
    
    FmpAcquireLocalResourceLock(pResource);

    //
    // If the resource is not initialized, then initialize it now.
    //
    if ( pResource->Monitor == NULL ) 
    {
        dwStatus = FmpInitializeResource( pResource, TRUE );
        if ( dwStatus != ERROR_SUCCESS ) 
        {
            goto FnExit;
        }
    } 
    else 
    {
        //
        // If the separate monitor flag has changed, then close down old
        // resource in resmon, and re-create it.
        //
        dwSeparateMonitor = (pResource->Flags & RESOURCE_SEPARATE_MONITOR) ? 1 : 0;
        dwStatus = DmQueryDword( pResource->RegistryKey,
                                        CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                        &dwSeparateMonitor,
                                        &dwSeparateMonitor );

        if ( (!dwSeparateMonitor &&
             (pResource->Flags & RESOURCE_SEPARATE_MONITOR)) ||
             (dwSeparateMonitor &&
             ((pResource->Flags & RESOURCE_SEPARATE_MONITOR) == 0)) ) 
        {

            dwStatus = FmpChangeResourceMonitor(pResource, dwSeparateMonitor );
            if ( dwStatus != ERROR_SUCCESS )
            {
                goto FnExit;
            }
        }
    }

    dwStatus = FmpRmArbitrateResource(pResource);

FnExit:
    FmpReleaseLocalResourceLock(pResource);
    return(dwStatus);

} // FmpArbitrateResource


DWORD
FmpTerminateResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine takes a resource (and all of the resources that it provides
    for) offline - the hard way.

Arguments:

    Resource - A pointer to the resource to take offline the hard way.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    PLIST_ENTRY  entry;
    PDEPENDENCY  dependency;
    DWORD        status;


    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't been initialized we will return because the
    // pre-initialized state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependents, terminate them first.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively terminate the dependent resource
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] TerminateResource: %1!ws! depends on %2!ws!. Terminating first\n",
                   OmObjectId(dependency->DependentResource),
                   OmObjectId(Resource));

        //
        // First stop any pending threads.
        //

        if ( dependency->DependentResource->PendingEvent ) {
            SetEvent( dependency->DependentResource->PendingEvent );
        }

        status = FmpTerminateResource(dependency->DependentResource);

        CL_ASSERT( status != ERROR_IO_PENDING );
        if (status != ERROR_SUCCESS) {
            FmpReleaseLocalResourceLock( Resource );
            return(status);
        }
    }

    //
    // Tell the resource monitor to terminate this resource.
    //
    FmpRmTerminateResource(Resource);

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

} // FmpTerminateResource



DWORD
FmpOfflineResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL bForceOffline

    )

/*++

Routine Description:

    This routine takes a resource (and all of the resources that it provides
    for) offline. If ERROR_IO_PENDING is returned, then no thread is started
    to complete the offline request.

Arguments:

    Resource - A pointer to the resource to take offline.

    bForceOffline - Indicates whether the persistent state is to be set.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD         status = ERROR_SUCCESS;
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    BOOL          waitingResource = FALSE;
    DWORD         offlinestatus;
    
    FmpAcquireLocalResourceLock( Resource );

    //
    // If we own the Group and we are not a possible owner, then the resource
    // better be offline!
    //
    if ( (Resource->Group->OwnerNode != NmLocalNode) ||
         (!FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode , FALSE, NULL) &&
	 (Resource->Group != gpQuoResource->Group) &&
         (Resource->State != ClusterResourceOffline)) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is already offline, then return immediately.
    //
    // We should not have to check if a resource has been initialized,
    // since if it hasn't, then we will return because the pre-initialized
    // state of a resource is Offline.
    //
    if ( Resource->State == ClusterResourceOffline ) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        if ( Resource->QuorumResource ) {
            FmpRmTerminateResource( Resource );
        }
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    } else if ( Resource->State == ClusterResourceFailed ) {
        //
        //  Chittur Subbaraman (chitturs) - 4/8/99
        //
        //  If the resource has already failed, then don't do anything.
        //  You could run into some funny cases of a resource switching
        //  between offline pending and failed states for ever if you 
        //  attempt to offline a failed resource.
        //
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If this system is not the owner, then return an error. Forwarding
    // should have been done at a higher layer.
    //
    CL_ASSERT( Resource->Group != NULL );
    if ( (Resource->Group->OwnerNode != NmLocalNode) ||
	 ((Resource->Group != gpQuoResource->Group) &&
         !FmpInPreferredList( Resource->Group, Resource->Group->OwnerNode, FALSE, NULL)) ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
    }

    if (Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: Offline resource <%1!ws!> is in online pending state\n",
                   OmObjectName(Resource) );
        if (FmpShutdown)
        {
            FmpRmTerminateResource( Resource );
            return(ERROR_SUCCESS);
        }            
        else            
            return(ERROR_INVALID_STATE);
    }

    //
    // If the resource is in a pending state, then return immediately.
    //
    if (Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: Offline resource <%1!ws!> returned pending\n",
                   OmObjectName(Resource) );
        return(ERROR_IO_PENDING);
    }

    //
    // Next, make sure there are no resources up the tree that are waiting.
    // This prevents a deadlock where the top of the tree is trying to go
    // offline, while the bottom of the tree is trying to go online.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        if ( (dependency->DependentResource->State == ClusterResourceOnlinePending) &&
             (dependency->DependentResource->Flags & RESOURCE_WAITING) ) {
            waitingResource = TRUE;
            break;
        }
    }
    if ( waitingResource ) {
        Resource->Flags |= RESOURCE_WAITING;
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }

    //
    // Make sure the Waiting flag is clear.
    //
    Resource->Flags &= ~RESOURCE_WAITING;

    //
    // If this resource has any dependents, shut them down first.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively shutdown the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOfflineResource: %1!ws! depends on %2!ws!. Shut down first.\n",
                   OmObjectName(dependency->DependentResource),
                   OmObjectName(Resource));

        offlinestatus = FmpDoOfflineResource(dependency->DependentResource,
                            bForceOffline);

        if ( offlinestatus != ERROR_SUCCESS ) {
            if ( offlinestatus != ERROR_IO_PENDING ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOfflineResource for %1!ws!, bad status returned %2!u!.\n",
                           OmObjectName(dependency->DependentResource),
                           offlinestatus);
                FmpTerminateResource( dependency->DependentResource );
                FmpReleaseLocalResourceLock( Resource );
                return(offlinestatus);
            } else {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] FmpOfflineResource for %1!ws! marked as waiting.\n",
                           OmObjectName(Resource));
                FmpCallResourceNotifyCb(Resource, ClusterResourceOfflinePending);
                FmpPropagateResourceState( Resource,
                                           ClusterResourceOfflinePending );
                Resource->Flags |= RESOURCE_WAITING;
                if (status == ERROR_SUCCESS)
                    status = offlinestatus;
            }
        }
    }


    //
    // Tell the resource monitor to shut this resource down.
    // The state gets updated by the return status in FmpRmOfflineResource.
    //
    if ( !(Resource->Flags & RESOURCE_WAITING) ) {
        status = FmpRmOfflineResource( Resource );
        //
        //  Chittur Subbaraman (chitturs) - 3/2/2000
        //
        //  If the resource could not be made offline since the quorum 
        //  resource online operation failed or for other reasons, then 
        //  make sure the resource is terminated after you declare the 
        //  state of the resource as failed. This is necessary since 
        //  otherwise the FM will consider the resource as having failed 
        //  while the resource itself is actually online. This will 
        //  lead to disastrous cases whereby the FM will allow the online 
        //  entry point of a resource to be called while the resource is 
        //  actually online !
        //
        if( ( status != ERROR_SUCCESS ) &&
            ( status != ERROR_IO_PENDING ) && 
            ( status != ERROR_RETRY ) ) {
            FmpRmTerminateResource( Resource );
        }
    }
    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpOfflineResource



DWORD
FmpDoOnlineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL ForceOnline
    )

/*++

Routine Description:

    This routine brings a resource online. If ERROR_IO_PENDING is returned,
    then a thread is started to complete the Online request.


Arguments:

    Resource - A pointer to the resource to bring online.

    ForceOnline - TRUE if the resource should be forced online.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already online, then return immediately.
    //
    if ( Resource->State == ClusterResourceOnline ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in a pending state, then return immediately.
    // FmpOnlineResource checks for offlinepending state and returns
    // ERROR_INVALID_STATE if so.
    //
    if ( Resource->State == ClusterResourceOnlinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // If this node is paused, return failure.
    //
    if (NmGetNodeState(NmLocalNode) == ClusterNodePaused) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SHARING_PAUSED);
    }

    //
    // Try to bring the resource online.
    //
    status = FmpOnlineResource( Resource, ForceOnline );

    //
    // Write the persistent state if it is forced online.
    //
    if ( ForceOnline &&
         ((status == ERROR_SUCCESS)||
         (status == ERROR_IO_PENDING))) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOnline );
    }

    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpDoOnlineResource



DWORD
FmpDoOfflineResource(
    IN PFM_RESOURCE Resource,
    IN BOOL bForceOffline
    )

/*++

Routine Description:

    This routine takes a resource offline. If ERROR_IO_PENDING is returned,
    then a thread is started to complete the Offline request.


Arguments:

    Resource - A pointer to the resource to take offline.

    bForceOffline - Indicates whether the persistent state must be changed.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    A Win32 error code if the request fails.

--*/

{
    DWORD   status;

    FmpAcquireLocalResourceLock( Resource );

    //
    // If the resource is already offline, then return immediately.
    //
    if (Resource->State == ClusterResourceOffline) {
        //
        // If this is the quorum resource, make sure any reservation
        // threads are stopped!
        //
        if ( Resource->QuorumResource ) {
            FmpRmTerminateResource( Resource );
        }
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }

    //
    // If the resource is in a pending state, then return immediately.
    // FmpOffline resource checks to see if it is in OnlinePending state
    // and returns invalid state
    //
    if (Resource->State == ClusterResourceOfflinePending ) {
        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_IO_PENDING);
    }

    //
    // Try to take the resource offline.
    //
    status = FmpOfflineResource( Resource, bForceOffline );

    //
    // Write the persistent state if it is forced offline
    //
    if ( bForceOffline &&
         ((status == ERROR_SUCCESS)||
         (status == ERROR_IO_PENDING))) {
        FmpSetResourcePersistentState( Resource, ClusterResourceOffline );
    }

    FmpReleaseLocalResourceLock( Resource );

    return(status);

} // FmpDoOfflineResource



VOID
FmpSetResourcePersistentState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )

/*++

Routine Description:

    Set the persistent state of a Resource in the registry and set the
    PersistentState for the volatile (in-memory) resource. It is assumed
    that the dynamic state gets changed elsewhere depending on whether
    the resource online request succeeds or fails.

Arguments:

    Resource - The resource to set the state.
    State    - The new state for the Resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.


Notes:

    The LocalResourceLock must be held.

--*/

{
    CLUSTER_RESOURCE_STATE   persistentState;
    LPWSTR  persistentStateName = CLUSREG_NAME_RES_PERSISTENT_STATE;

    if (!gbIsQuoResEnoughSpace)
        return;

    //
    // If the current state has changed, then do the work. Otherwise,
    // skip the effort.
    //
    if ( Resource->PersistentState != State ) {
        Resource->PersistentState = State;
        CL_ASSERT( Resource->RegistryKey != NULL );

        ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetResourcePersistentState: Setting persistent state for resource %1!ws!...\r\n",
                OmObjectId(Resource));

        //
        // Set the new value, but only if it is online or offline.
        //
        if ( State == ClusterResourceOffline ) {
            persistentState = 0;
            DmSetValue( Resource->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        } else if ( State == ClusterResourceOnline ) {
            persistentState = 1;
            DmSetValue( Resource->RegistryKey,
                        persistentStateName,
                        REG_DWORD,
                        (LPBYTE)&persistentState,
                        sizeof(DWORD) );
        }
    }

} // FmpSetResourcePersistentState

void FmpCallResourceNotifyCb( 
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )
{

    switch ( State ) {
    case ClusterResourceOnline:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_POSTONLINE);
        break;
    case ClusterResourceOffline:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_POSTOFFLINE);
        break;
    case ClusterResourceFailed:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_FAILED);
        break;
    case ClusterResourceOnlinePending:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_ONLINEPENDING);
        break;
    case ClusterResourceOfflinePending:
        OmNotifyCb(Resource, NOTIFY_RESOURCE_OFFLINEPENDING);
        break;
    default:
        break;
    }
    return;

}


DWORD
FmpPropagateResourceState(
    IN PFM_RESOURCE Resource,
    IN CLUSTER_RESOURCE_STATE State
    )

/*++

Routine Description:

    Propagates the state of the resource to other systems in the cluster.
    Ideally the gQuoCritSec lock should be held when this routine is called.
    This is because this routine checks the quorumresource field of the 
    resource

Arguments:

    Resource - The resource to propagate state.

    State - The new state for the resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    GUM_RESOURCE_STATE resourceState;
    LPCWSTR  resourceId;
    DWORD    resourceStateSize;
    DWORD    status= ERROR_SUCCESS;
    BOOL     bAcquiredQuoLock = FALSE;
    
    //for quorum resource use the quorum lock for state changes
    // for others use the group locks
    if (Resource->QuorumResource)
    {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
        bAcquiredQuoLock = TRUE;
    }        
    else
        FmpAcquireLocalResourceLock( Resource );
        
    ++Resource->StateSequence;

    if (! FmpFMFormPhaseProcessing )
    {
        //
        // If this is the same state, or we don't own the group
        // then don't bother propagating.
        //

        if ( (State == Resource->State) ||
             (Resource->Group->OwnerNode != NmLocalNode) ) {
            goto ReleaseResourceLock;
        }

        //if the previous state is the online pending and this
        // is called for the quorum resource, wake up all resources
        // make sure that if this is called while the form phase
        //processing is going on(when the quorum group is destroyed 
        //and recreated), that the group is not referenced
        if ((Resource->QuorumResource) && 
            (Resource->State==ClusterResourceOnlinePending) &&
            (Resource->Group->OwnerNode == NmLocalNode) ) 
        {
            //set the state and signal
            Resource->State = State;
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpPropagateResourceState: signalling the ghQuoOnlineEvent\r\n");
            SetEvent(ghQuoOnlineEvent);    
        }


    }

    Resource->State = State;

    //
    // Prepare to notify other systems.
    //
    resourceId = OmObjectId( Resource );
    resourceState.State = State;
    resourceState.PersistentState = Resource->PersistentState;
    resourceState.StateSequence = Resource->StateSequence;

    status = GumSendUpdateEx(GumUpdateFailoverManager,
                             FmUpdateResourceState,
                             2,
                             (lstrlenW(resourceId)+1)*sizeof(WCHAR),
                             resourceId,
                             sizeof(resourceState),
                             &resourceState);


    //
    // Signal change notify event.
    //
    switch ( State ) {
    case ClusterResourceOnline:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! online event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_ONLINE, Resource);
        break;
    case ClusterResourceOffline:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! offline event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_OFFLINE, Resource);
        break;
    case ClusterResourceFailed:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! failed event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_FAILED, Resource);
        break;
    case ClusterResourceOnlinePending:
    case ClusterResourceOfflinePending:
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpPropagateResourceState: resource %1!ws! pending event.\n",
                   OmObjectId(Resource) );
        ClusterEvent(CLUSTER_EVENT_RESOURCE_CHANGE, Resource);
        break;
    default:
        break;
    }

ReleaseResourceLock:
    if (bAcquiredQuoLock)
        RELEASE_LOCK(gQuoLock);
    else
        FmpReleaseLocalResourceLock( Resource );


    if ( status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Propagation of resource %1!ws! state %2!u! failed. Error %3!u!\n",
                   OmObjectId(Resource),
                   State,
                   status);
        goto FnExit;                   
    }
    //if fm is not completely online we dont want to propagate group state
    // This is because the quorum group is destroyed in FmFormNewClusterPhase1
    // and then recreated again in FmFormNewClusterPhase2.
    if (FmpFMOnline)
    {
        OmReferenceObject(Resource->Group);
        //FmpPropagateGroupState( Resource->Group );
        FmpPostWorkItem(FM_EVENT_INTERNAL_PROP_GROUP_STATE, Resource->Group, 0);
    }
FnExit:
    return(status);

} // FmpPropagateResourceState



VOID
FmpDestroyResource(
    IN PFM_RESOURCE  Resource,
    IN BOOL          bDeleteObjOnly
    )

/*++

Routine Description:

    Destroys a resource. This basically snips a resource out of the
    dependency tree.

    First, any resources that depend on the specified
    resource are recursively destroyed. This removes any dependencies
    that other resources may have on the specified resource (i.e. all
    resources "higher" in the dependency tree are destroyed).

    Second, all the dependencies that the specified resource has are
    removed. This entails dereferencing the provider resource (to remove
    the reference that was added when the dependency was created) removing
    the DEPENDENCY structure from its provider and dependent lists, and
    finally freeing the DEPENDENCY storage.

    If the resource is online, it is terminated. The resource monitor is
    signalled to clean up and close the specified resource id.

Arguments:

    FoundResource - Returns the found resource.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    None.

Notes:

    The LocalResourceLock MUST be held! The lock is released before exit!

--*/
{
    DWORD         status;
    DWORD         i;
    PLIST_ENTRY ListEntry;
    PDEPENDENCY Dependency;
    PPOSSIBLE_ENTRY possibleEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] DestroyResource: destroying %1!ws!\n",
               OmObjectId(Resource));

    //
    // First, unlink this resource from the resource list.
    //
    //
    // if the resource belongs to the quorum group, it is destroyed
    // after the quorum logs are created so that it can be recreated
    // dont remove it from the list then
    if ((!bDeleteObjOnly))
        status = OmRemoveObject( Resource );

    //
    // If anyone depends on this resource, destroy them first.
    //
    while (!IsListEmpty(&Resource->ProvidesFor)) {

        ListEntry = Resource->ProvidesFor.Flink;
        Dependency = CONTAINING_RECORD(ListEntry, DEPENDENCY, ProviderLinkage);
        CL_ASSERT(Dependency->ProviderResource == Resource);

#if 0
        FmpRemoveResourceDependency( Dependency->DependentResource,
                                     Resource );
#endif
        RemoveEntryList(&Dependency->ProviderLinkage);
        RemoveEntryList(&Dependency->DependentLinkage);

        //
        // Dereference provider/dependent resource and free dependency storage
        //
        OmDereferenceObject(Dependency->ProviderResource);
        OmDereferenceObject(Dependency->DependentResource);
        LocalFree(Dependency);
    }

    //
    // Remove our resource dependencies.
    //
    while (!IsListEmpty(&Resource->DependsOn)) {

        ListEntry = RemoveHeadList(&Resource->DependsOn);
        Dependency = CONTAINING_RECORD(ListEntry, DEPENDENCY, DependentLinkage);
        CL_ASSERT(Dependency->DependentResource == Resource);

#if 0
        FmpRemoveResourceDependency( Resource,
                                     Dependency->ProviderResource );
#endif
        RemoveEntryList(&Dependency->ProviderLinkage);
        RemoveEntryList(&Dependency->DependentLinkage);

        //
        // Dereference provider/dependent resource and free dependency storage
        //
        OmDereferenceObject(Dependency->DependentResource);
        OmDereferenceObject(Dependency->ProviderResource);
        LocalFree(Dependency);
    }

    //
    // Remove all entries from the possible owners list.
    //
    while ( !IsListEmpty(&Resource->PossibleOwners) ) {
        ListEntry = RemoveHeadList(&Resource->PossibleOwners);
        possibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        OmDereferenceObject( possibleEntry->PossibleNode );
        LocalFree(possibleEntry);
    }

    if (!bDeleteObjOnly)
    {
        //
        // Close the resource's registry key.
        //

        DmRundownList( &Resource->DmRundownList );

        if (Resource->RegistryKey != NULL) {
            DmCloseKey( Resource->RegistryKey );
            Resource->RegistryKey = NULL;
        }

        //
        // Decrement resource type reference.
        //
        if ( Resource->Type != NULL ) {
            OmDereferenceObject( Resource->Type );
            Resource->Type = NULL;
        }

        // Let the worker thread peform the 'last' dereference
        FmpPostWorkItem(FM_EVENT_RESOURCE_DELETED, Resource, 0);
        FmpReleaseLocalResourceLock( Resource );

    }
    else
    {
        //the resource being destroyed is from the quorum group
        //This is done at initialization
        FmpReleaseLocalResourceLock( Resource );


        // make sure that all resources except the quorum resource
        // are created completely in the second phase of initialization
        //decrement its ref count here, this is the last ref 
        //SS:: we dont use FM_EVENT_RESOURCE_DELETED here
        //since we want this done synchronously before phase 2 is
        //complete
        OmDereferenceObject(Resource);
        
    }

    //ss: for now we dont use it, so dont delete it
    //DeleteCriticalSection(&Resource->Lock);

    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpDestroyResource Exit.\n");

    return;

} // FmpDestroyResource



///////////////////////////////////////////////////////////////////////////
//
// Initialization Routines
//
///////////////////////////////////////////////////////////////////////////


BOOL
FmDependentResource(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource,
    IN BOOL ImmediateOnly
    )

/*++

Routine Description:

    Returns indication of whether a resource is a dependent of another
    resource.

Arguments:

    Resource - The resource to scan if it depends on the dependent resource.

    DependentResource - The dependent resource to check on.

    ImmediateOnly - Specifies whether only immediate dependencies should be
        checked. If this is FALSE, this routine recursively checks all
        dependents.

Returns:

    TRUE - The the resource does depend on the dependent resource.

    FALSE - The resource does not depend on the dependent resource.

--*/

{
    PLIST_ENTRY listEntry;
    PDEPENDENCY dependency;
    BOOL    result = FALSE;

    FmpAcquireLocalResourceLock( Resource );

    listEntry = Resource->DependsOn.Flink;
    while ( listEntry != &Resource->DependsOn ) {
        dependency = CONTAINING_RECORD( listEntry,
                                        DEPENDENCY,
                                        DependentLinkage );
        if ( dependency->ProviderResource == DependentResource ) {
            result = TRUE;
            break;
        } else {
            if (!ImmediateOnly) {
                if (FmDependentResource(dependency->ProviderResource,
                                        DependentResource,
                                        FALSE)) {
                    result = TRUE;
                    break;
                }
            }
        }

        listEntry = listEntry->Flink;

    }  // while

    FmpReleaseLocalResourceLock( Resource );

    return(result);

} // FmpDependentResource


DWORD
FmpAddPossibleEntry(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Creates a new possible node entry and adds it to a resource's list.

    If the node is already in the resource's list, it will not be added
    again.

Arguments:

    Resource - Supplies the resource whose node list is to be updated.

    Node - Supplies the node to be added to the resource's list.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    PLIST_ENTRY ListEntry;
    PPOSSIBLE_ENTRY PossibleEntry;

    //
    // First check to see if the node is already in the possible owners list.
    //
    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        if (PossibleEntry->PossibleNode == Node) {
            //
            // Found a match, it's already here, so return
            // success.
            //
            return(ERROR_SUCCESS);
        }
        ListEntry = ListEntry->Flink;
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpAddPossibleEntry: adding node %1!ws! as possible host for resource %2!ws!.\n",
               OmObjectId(Node),
               OmObjectId(Resource));

    PossibleEntry = LocalAlloc(LMEM_FIXED, sizeof(POSSIBLE_ENTRY));
    if (PossibleEntry == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpAddPossibleEntry failed to allocated PossibleEntry\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    OmReferenceObject(Node);
    PossibleEntry->PossibleNode = Node;
    InsertTailList( &Resource->PossibleOwners,
                    &PossibleEntry->PossibleLinkage );

    return(ERROR_SUCCESS);

}


DWORD
FmpAddPossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node
    )
/*++

Routine Description:

    Adds a node to the resource's list of possible nodes.

    The resource lock must be held.

Arguments:

    Resource - Supplies the resource whose list of nodes is to be updated

    Node - Supplies the node to add to the specified resource's list.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    HDMKEY hGroup;
    DWORD Status;

    
    //
    // Allocate the new possible node entry and add it to the list.
    //
    Status = FmpAddPossibleEntry(Resource, Node);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Need to check the group list to see if the specified node
    // can be added to the preferred list now. The easiest way
    // to do that is to simply recreate the entire preferred list,
    // then reprune.
    //
    hGroup = DmOpenKey( DmGroupsKey,
                        OmObjectId(Resource->Group),
                        KEY_READ );
    if (hGroup == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] FmpAddPossibleNode failed to open group %1!ws! status %2!d!\n",
                    OmObjectId(Resource->Group),
                    Status);

        return(Status);
    }
    Status = FmpQueryGroupNodes(Resource->Group,
                                hGroup);
    CL_ASSERT(Status == ERROR_SUCCESS);
    if (Status == ERROR_SUCCESS) {
        FmpPruneGroupOwners(Resource->Group);
    }
    DmCloseKey(hGroup);


    return(Status);

} // FmpAddPossibleNode


DWORD
FmpRemovePossibleNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL RemoveQuorum
    )
/*++

Routine Description:

    Removes a node from the resource's list of possible nodes.

    The resource lock must be held.

Arguments:

    Resource - Supplies the resource whose list of nodes is to be updated

    Node - Supplies the node to be removed from the specified resource's list.

    RemoveQuorum - TRUE if we can remove node from quorum device.
                   FALSE otherwise.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PPOSSIBLE_ENTRY PossibleEntry;
    DWORD Status = ERROR_CLUSTER_NODE_NOT_FOUND;

    //
    // If the resource is currently online on the node to be removed,
    // fail the call.
    //
    if ((Resource->Group->OwnerNode == Node) &&
        (Resource->State == ClusterResourceOnline)) {
        return(ERROR_INVALID_STATE);
    }

    //
    // If it is NOT okay to remove this node from the quorum device,
    // and this is the quorum device, then fail the request.
    //
    if ( !RemoveQuorum &&
         Resource->QuorumResource) {
        return(ERROR_INVALID_OPERATION_ON_QUORUM);
    }

    //
    // Find the possible entry on the resource's list.
    //

    ListEntry = Resource->PossibleOwners.Flink;
    while (ListEntry != &Resource->PossibleOwners) {
        PossibleEntry = CONTAINING_RECORD( ListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        ListEntry = ListEntry->Flink;
        if (PossibleEntry->PossibleNode == Node) {
            //
            // Found a match, remove it from the list.
            //
            RemoveEntryList(&PossibleEntry->PossibleLinkage);
            OmDereferenceObject(PossibleEntry->PossibleNode);
            LocalFree(PossibleEntry);

            //
            // Now prune the containing group. This is a little bit
            // of overkill, if we were smarter, we could just
            // remove the node from the preferred list directly.
            //
            FmpPrunePreferredList(Resource);
            Status = ERROR_SUCCESS;
            break;
        }
    }

    return(Status);

} // FmpRemovePossibleNode



DWORD
FmpRemoveResourceDependency(
    HLOCALXSACTION  hXsaction,
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependsOn
    )
/*++

Routine Description:

    Removes a dependency relationship to a given resource. Both
    resources must be in the same group.

Arguments:

    Resource - Supplies the resource which is dependent.

    DependsOn - Supplies the resource that hResource depends on.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD           status;
    HDMKEY          resKey = NULL;
    
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((Resource->Group != DependsOn->Group) ||
        (Resource == DependsOn)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Remove the dependency from the registry database.
    //
    resKey = DmOpenKey(DmResourcesKey,
                       OmObjectId(Resource),
                       KEY_READ | KEY_SET_VALUE);
    if (resKey == NULL)
    {
        status = GetLastError();
        CL_LOGFAILURE(status);
        goto FnExit;
    }
    else
    {
        status = DmLocalRemoveFromMultiSz(hXsaction,
                                          resKey,
                                          CLUSREG_NAME_RES_DEPENDS_ON,
                                          OmObjectId(DependsOn));
    }

FnExit:
    if ( resKey ) {
        DmCloseKey(resKey);
    }
    return(status);

} // FmpRemoveResourceDependency


DWORD
FmpChangeResourceGroup(
    IN PFM_RESOURCE pResource,
    IN PFM_GROUP    pNewGroup
    )
/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    pResource - Supplies the resource to move.

    pNewGroup - Supplies the new group that the resource should be in.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD               dwBufSize;
    LPCWSTR             pszResourceId;
    DWORD               dwResourceLen;
    LPCWSTR             pszGroupId;
    DWORD               dwGroupLen;
    DWORD               dwStatus;
    PGUM_CHANGE_GROUP   pGumChange;

    // we need to validate here as well
    // this is called by the server side
    // this will help avoid a gum call if things have changed
    // since the request started from the originator
    // and got to the server

    //
    // Check if we're moving to same group.
    //
    if (pResource->Group == pNewGroup) {
        dwStatus = ERROR_ALREADY_EXISTS;
        goto FnExit;
    }

    //
    // For now... both Groups must be owned by the same node.
    //
    if ( pResource->Group->OwnerNode != pNewGroup->OwnerNode ) {
        dwStatus = ERROR_HOST_NODE_NOT_GROUP_OWNER;
        goto FnExit;
    }


    pszResourceId = OmObjectId(pResource);
    dwResourceLen = (lstrlenW(pszResourceId)+1)*sizeof(WCHAR);

    pszGroupId = OmObjectId(pNewGroup);
    dwGroupLen = (lstrlenW(pszGroupId)+1)*sizeof(WCHAR);

    dwBufSize = sizeof(GUM_CHANGE_GROUP) - sizeof(WCHAR) + dwResourceLen + dwGroupLen;
    pGumChange = LocalAlloc(LMEM_FIXED, dwBufSize);
    if (pGumChange == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    pGumChange->ResourceIdLen = dwResourceLen;
    CopyMemory(pGumChange->ResourceId, pszResourceId, dwResourceLen);
    CopyMemory((PCHAR)pGumChange->ResourceId + dwResourceLen,
               pszGroupId,
               dwGroupLen);
    dwStatus = GumSendUpdate(GumUpdateFailoverManager,
                           FmUpdateChangeGroup,
                           dwBufSize,
                           pGumChange);
    LocalFree(pGumChange);

FnExit:
    return(dwStatus);
}// FmpChangeResourceGroup

#if 0

DWORD
FmpClusterEventPropHandler(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Post a worker item to process a cluster name change.

Arguments:

    pResource - pointer to the resouce which is affected by the cluster
                property change.

Return Value:


    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    PFM_RESTYPE pResType;
    DWORD       dwError=ERROR_SUCCESS;

    pResType = pResource->Type;

    if ((pResource->ExFlags & CLUS_FLAG_CORE) &&
       ( !lstrcmpiW(OmObjectId(pResType), CLUS_RESTYPE_NAME_NETNAME)))
    {
        FmResourceControl(pResource, NmLocalNode,
           CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED, NULL, 0, NULL, 0, NULL, NULL);

    }
    return (dwError);

} // FmpClusterEventPropHandler

#endif


BOOL
FmpEnumResourceNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the resource object

    Name - Supplies the resource's object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_RESOURCE Resource = (PFM_RESOURCE)Object;
    PNM_NODE Node = (PNM_NODE)Context1;
    PLIST_ENTRY      listEntry;
    PPOSSIBLE_ENTRY possibleEntry;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] EnumResourceNodeEvict: Removing references to node %1!ws! from resource %2!ws!\n",
               OmObjectId(Node),
               OmObjectId(Resource));
               
    FmpAcquireLocalResourceLock(Resource);
    FmpRemovePossibleNode(Resource, Node, TRUE);
    FmpReleaseLocalResourceLock(Resource);
    //
    // Notify the resource of the removal of the node.
    //
    FmpRmResourceControl( Resource,
                          CLUSCTL_RESOURCE_EVICT_NODE,
                          (PUCHAR)OmObjectId(Node),
                          ((lstrlenW(OmObjectId(Node)) + 1) * sizeof(WCHAR)),
                          NULL,
                          0,
                          NULL,
                          NULL );
    // Ignore status return

    ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE, Resource );

    return(TRUE);

} // FmpEnumResourceNodeEvict



DWORD
FmpPrepareQuorumResChange(
    IN PFM_RESOURCE pNewQuoRes,
    IN LPCWSTR      lpszQuoLogPath,
    IN DWORD        dwMaxQuoLogSize
    )

/*++

Routine Description:

    This routine prepares for a quorum resource change operation.

Arguments:

    pNewQuoRes - pointer to the new quorum resource.

    lpszQuoLogPath - pointer to the quorum log path string name.

    dwMaxQuoLogSize - the maximum size of the quorum log path string.

--*/

{

    CL_ASSERT(pNewQuoRes->Group->OwnerNode == NmLocalNode);

    return(DmPrepareQuorumResChange(pNewQuoRes, lpszQuoLogPath, dwMaxQuoLogSize));

} // FmpPrepareQuorumResChange


DWORD
FmpCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszQuoLogPath
    )

/*++

Routine Description:

    This routine is called if the new quorum log path is not the same as the old
    quorum log path.  This completes the change of quorum resource by deleting the old
    quorum log files and creating a tompstone for them.  A node that tries to do a form
    with this as the quorum resource is prevented and has to do a join to get the location
    of the new quorum resource and quorum log file.

Arguments:

    pOldQuoRes - pointer to the new quorum resource.

    lpszOldQuoLogPath - pointer to the quorum log path string name.

    dwMaxQuoLogSize - the maximum size of the quorum log path string.

--*/

{

    return(DmCompleteQuorumResChange(lpszOldQuoResId, lpszQuoLogPath));

} // FmpCompleteQuorumResChange



VOID
FmpResourceLastReference(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Last dereference to resource object processing routine.
    All cleanup for a resource should really be done here!

Arguments:

    Resource - pointer the resource being removed.

Return Value:

    None.

--*/

{
    if ( Resource->DebugPrefix != NULL )
        LocalFree(Resource->DebugPrefix);
    if (Resource->Dependencies)
        LocalFree(Resource->Dependencies);
    if ( Resource->Group ) {
        OmDereferenceObject(Resource->Group);
    }
    if (Resource->Type)
        OmDereferenceObject(Resource->Type);
    return;

} // FmpResourceLastReference



BOOL
FmpCheckNetworkDependencyWorker(
    IN LPCWSTR DependentNetwork,
    OUT PBOOL FoundDependency,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Enumeration callback routine for finding an IP Address resource
    and checking its dependency on given network guid.

Arguments:

    DependentNetwork - The GUID of the network to check for a dependency.

    FoundDependency - Returns TRUE if a dependency is found.

    Resource - Supplies the current resource.

    Name - Supplies the current resource's name.

Return Value:

    TRUE - to continue searching

    FALSE - to stop the search. The matching resource is returned in
        *FoundResource

Notes:

    The IP Address resource's parameters are searched directly by this
    routine. Fetching them from the resource itself causes a deadlock.
    This routine is called by the NM from within a global udpate
    handler. The resource would have to call back into the cluster registry
    routines, which would deadlock over the GUM lock.

--*/

{
    BOOL    returnValue = TRUE;


    if ( lstrcmpiW(
             OmObjectId(Resource->Type),
             CLUS_RESTYPE_NAME_IPADDR
             ) == 0
       )
    {
        LPCWSTR resourceId = OmObjectId(Resource);
        DWORD   status;
        HDMKEY  resourceKey = DmOpenKey(DmResourcesKey, resourceId, KEY_READ);

        if (resourceKey != NULL) {
            HDMKEY  paramsKey = DmOpenKey(
                                    resourceKey,
                                    L"Parameters",
                                    KEY_READ
                                    );

            if (paramsKey != NULL) {
                LPWSTR  networkId = NULL;
                DWORD   valueLength = 0, valueSize = 0;

                status = DmQueryString(
                             paramsKey,
                             L"Network",
                             REG_SZ,
                             &networkId,
                             &valueLength,
                             &valueSize
                             );

                if (status == ERROR_SUCCESS) {

                    if ( lstrcmpiW( networkId, DependentNetwork ) == 0 ) {
                        *FoundDependency = TRUE;
                        returnValue = FALSE;
                    }

                    LocalFree(networkId);
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Query of Network value failed for ip addr resource %1!ws!, status %2!u!.\n",
                        resourceId,
                        status
                        );
                }

                DmCloseKey(paramsKey);
            }
            else {
                status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[FM] Failed to open params key for resource %1!ws!, status %2!u!\n",
                    resourceId,
                    status
                    );
            }

            DmCloseKey(resourceKey);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[FM] Failed to open key for resource %1!ws!, status %2!u!\n",
                resourceId,
                status
                );
        }
    }

    return(returnValue);

} // FmpCheckNetworkDependencyWorker

//lock must be held when this routine is called
DWORD FmpChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR NodeId,
    IN BOOL Add

    )
{
    PGUM_CHANGE_POSSIBLE_NODE GumChange;
    LPCWSTR ResourceId;
    DWORD   ResourceLen;
    DWORD   NodeLen;
    DWORD   BufSize;
    DWORD   Status;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL    bNodeSupportsResType = FALSE;
    BOOL    bRecalc = TRUE;
    PPOSSIBLE_ENTRY PossibleEntry;
    PNM_NODE    pNode = NULL;

    //cant remove possible node list from the quorum
    //we should allow adding possible node lists to quorum to 
    //allow 3rd party quorum resource vendors to install their
    //quorum resource incrementally on the nodes
    if ( Resource->QuorumResource && !Add ) {
        Status = ERROR_INVALID_OPERATION_ON_QUORUM;
        goto FnExit;
    }

    //
    // We can't allow the owner node to be removed if the state
    // of the resource or the group is not offline or failed.
    //
    if ( !Add &&
         (lstrcmpi(NodeId, OmObjectId(NmLocalNode)) == 0) &&
         (((Resource->State != ClusterResourceOffline) &&
            (Resource->State != ClusterResourceFailed)) ||
         (FmpGetGroupState( Resource->Group, TRUE ) != ClusterGroupOffline)) ) {
        Status = ERROR_INVALID_STATE;
        goto FnExit;
    }

    //make sure the node is on the list of possible nodes for this
    // resource type
    if (Add)
    {
        //if it is already on the list, return an error and dont
        //send a gum update call
        
        pNode = OmReferenceObjectById(ObjectTypeNode, NodeId);
        pListEntry = Resource->PossibleOwners.Flink;
        while (pListEntry != &Resource->PossibleOwners) {
            PossibleEntry = CONTAINING_RECORD( pListEntry,
                                               POSSIBLE_ENTRY,
                                               PossibleLinkage );
            if (PossibleEntry->PossibleNode == pNode) {
                //
                // Found a match, fail the duplicate add. Note that
                // we must fail here, not succeed, so that the API
                // layer knows not to add a duplicate to the registry.
                //
                Status = ERROR_OBJECT_ALREADY_EXISTS;
                goto FnExit;
            }
            pListEntry = pListEntry->Flink;
        }
        
ChkResTypeList:
        pListEntry = &(Resource->Type->PossibleNodeList);
        for (pListEntry = pListEntry->Flink; 
            pListEntry != &(Resource->Type->PossibleNodeList);
            pListEntry = pListEntry->Flink)
        {    

            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

            if (!lstrcmpW(OmObjectId(pResTypePosEntry->PossibleNode), NodeId))
            {
                bNodeSupportsResType = TRUE;
                break;
            }            
                    
        }    

        if (!bNodeSupportsResType  && bRecalc)
        {
            //if th node is not found, recalc again and retry..since then the
            //dll might have been copied to this node
            FmpSetPossibleNodeForResType(OmObjectId(Resource->Type), TRUE);
            bRecalc = FALSE;
            goto ChkResTypeList;
        }
        if (!bNodeSupportsResType)
        {
            Status = ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
            goto FnExit;
        }
    }
    
    ResourceId = OmObjectId(Resource);
    ResourceLen = (lstrlenW(ResourceId)+1)*sizeof(WCHAR);

    NodeLen = (lstrlenW(NodeId)+1)*sizeof(WCHAR);

    BufSize = sizeof(GUM_CHANGE_POSSIBLE_NODE) - sizeof(WCHAR) + ResourceLen + NodeLen;
    GumChange = LocalAlloc(LMEM_FIXED, BufSize);
    if (GumChange == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    GumChange->ResourceIdLen = ResourceLen;
    CopyMemory(GumChange->ResourceId, ResourceId, ResourceLen);
    CopyMemory((PCHAR)GumChange->ResourceId + ResourceLen,
               NodeId,
               NodeLen);

    Status = GumSendUpdate(GumUpdateFailoverManager,
                       Add ? FmUpdateAddPossibleNode : FmUpdateRemovePossibleNode,
                       BufSize,
                       GumChange);
    LocalFree(GumChange);

FnExit:
    if (pNode) 
        OmDereferenceObject(pNode);
    return(Status);

}



BOOL
FmpCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    )

/*++

Routine Description:

    Checks for an IP Address resource that may be dependent on the given
    Network.

Arguments:

    DependentNetwork - the dependent network to check for.

Returns:

    TRUE - if an IP Address depends on the given network.
    FALSE otherwise.

--*/

{
    BOOL    dependent = FALSE;

    OmEnumObjects(ObjectTypeResource,
                  (OM_ENUM_OBJECT_ROUTINE)FmpCheckNetworkDependencyWorker,
                  (PVOID)DependentNetwork,
                  &dependent);

    return(dependent);

} // FmpCheckNetworkDependency

/****
@func       DWORD | FmpFixupPossibleNodesForResources| This fixes the possible
            node information for a resource based on whether this node
            supports the given resource type.

@parm       IN BOOL| bJoin | If this node is joining, bJoin is set to TRUE.

@comm       This routine iterates thru all the resources in a system and fixes
            their possible node information.  If this node is not on the possible
            node list for the resource type corresponding to the resource, it
            is also removed from the possible node list for the resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpEnumFixupPossibleNodeForResource>
****/
DWORD
FmpFixupPossibleNodesForResources(
    BOOL    bJoin
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupPossibleNodesForResources Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    OmEnumObjects( ObjectTypeResource,
                   FmpEnumFixupPossibleNodesForResource,
                   NULL,
                   NULL);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupPossibleNodesForResources Exit\r\n");

    return(dwStatus);

} // FmpFixupPossibleNodesForResources

/****
@func       DWORD | FmpEnumFixupPossibleNodesForResource | This is the enumeration
            callback for every resource type to fix the possible node
            information related with it.

@parm       IN PVOID | pContext1 | Not used.
@parm       IN PVOID | pContext2 | Not Used.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine iterates thru all the resources in a system and fixes
            their possible node information.  If this node is not on the possible
            node list for the resource type corresponding to the resource, it
            is also removed from the possible node list for the resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpFixupPossibleNodesForResources>
****/
BOOL
FmpEnumFixupPossibleNodesForResource(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESOURCE pResource,
    IN LPCWSTR      pszResName
    )
{


    //if we are on the possible node list for the
    //resource but not for the resource type, remove it
    //from the possible node for the resource as well.
    //We do this because the join logic adds all nodes
    //as possible owners for a resource and we have
    //the rolling upgrade requirements - hence the fixups
    //have to be made later on
    if ((FmpInPossibleListForResource(pResource, NmLocalNode)) &&
        !(FmpInPossibleListForResType(pResource->Type, NmLocalNode)))
    {
        //if we dont support this resource type, make sure it is not on the possible node
        //list for a resource of this type
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpEnumFixupPossibleNode:remove local node for  resource %1!ws!\r\n",
                   OmObjectId(pResource));
        //we send a gum update to remove it from all nodes
        FmChangeResourceNode(pResource, NmLocalNode, FALSE);
    }

    //we add ourselves on the list only on a fresh install
    //not on an upgrade
    //csfirst run is also true on an upgrade, hence we need to
    //check that csupgrade is false
    if ((!FmpInPossibleListForResource(pResource, NmLocalNode)) &&
        (FmpInPossibleListForResType(pResource->Type, NmLocalNode))
        && CsFirstRun && !CsUpgrade)
    {
        //if we support a resource of this type, but we are not on the possible 
        //list for this resource, then add the local node to the possible list
        //this may happen because on a setup join the other nodes may not 
        //add us because the possible node list exists.  The possible node list
        //may exist either because the user set it or we internally set it due
        //to non availability of this resource type dll on one of the nodes
        //Note that irrespective of whether the user had set the possible list
        //or we set it internally, we always add a new node that joins 
        //to the possible node list of resources that are supported.
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpEnumFixupPossibleNode:add local node for  resource %1!ws!\r\n",
                   OmObjectId(pResource));
        //we send a gum update to add it from all nodes
        FmChangeResourceNode(pResource, NmLocalNode, TRUE);
    }
    //continue enumeration
    return (TRUE);
}


DWORD FmpCleanupPossibleNodeList(
    IN PFM_RESOURCE pResource)
{

    PLIST_ENTRY     pListEntry;
    PPOSSIBLE_ENTRY pPossibleEntry;
    DWORD           dwStatus = ERROR_SUCCESS;

    //for all possible nodes for this resource, check if the resource type
    //supports it.  If it doesnt, then remove that node from the in memory list
    pListEntry = pResource->PossibleOwners.Flink;
    while (pListEntry != &pResource->PossibleOwners) 
    {
        //get the possible entry at this link
        pPossibleEntry = CONTAINING_RECORD( pListEntry,
                                           POSSIBLE_ENTRY,
                                           PossibleLinkage );
        //save the pointer to the next link                                           
        pListEntry = pListEntry->Flink;
                                           
        if (!FmpInPossibleListForResType(pResource->Type, 
                        pPossibleEntry->PossibleNode))
        {
            ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpCleanupPossibleNodeList:remove local node %1!u! for  resource %2!ws!\r\n",
                   NmGetNodeId(pPossibleEntry->PossibleNode), OmObjectId(pResource));
            FmChangeResourceNode(pResource, pPossibleEntry->PossibleNode,
                    FALSE);
        }
    }

    return (dwStatus);
}


/****
@func       DWORD | FmpInPossibleListForResource| This checks if a given node 
            is in the possible list of nodes for a resource.

@parm       IN PFM_RESOURCE | pResource | A pointer to the the resource.
@parm       IN PNM_NODE | pNode | A pointer to the node object.

@comm       This routine check if a node is in the list of possible nodes
            for this resource.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpInPossibleListForResType>
****/
BOOL
FmpInPossibleListForResource(
    IN PFM_RESOURCE pResource,
    IN PNM_NODE     pNode
    )
{
    PLIST_ENTRY         plistEntry;
    PPOSSIBLE_ENTRY     pPossibleEntry;

    //see if this node is on the possible node list for the resource
    for ( plistEntry = pResource->PossibleOwners.Flink;
          plistEntry != &(pResource->PossibleOwners);
          plistEntry = plistEntry->Flink ) {

        pPossibleEntry = CONTAINING_RECORD( plistEntry,
                                            POSSIBLE_ENTRY,
                                            PossibleLinkage );
        if ( pPossibleEntry->PossibleNode == pNode ) {
            return(TRUE);
        }
    }

    return(FALSE);

} // FmpInPossibleListForResource


/****
@func       DWORD | FmpInPossibleListForResType| This checks if a given node 
            is in the possible list of nodes for a resource type.

@parm       IN PFM_RESTYPE| pResType | A pointer to the the resource type.
@parm       IN PNM_NODE | pNode | A pointer to the node object.

@comm       This routine check if a node is in the list of possible nodes
            for this resource type.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpInPossibleListForResource>
****/
BOOL
FmpInPossibleListForResType(
    IN PFM_RESTYPE pResType,
    IN PNM_NODE     pNode
    )
{
    PLIST_ENTRY         pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry;

    ACQUIRE_SHARED_LOCK(gResTypeLock);
    
    //see if this node is on the possible node list for the resource
    for ( pListEntry = pResType->PossibleNodeList.Flink;
          pListEntry != &(pResType->PossibleNodeList);
          pListEntry = pListEntry->Flink ) 
    {

        pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

        if ( pResTypePosEntry->PossibleNode == pNode ) 
        {
            RELEASE_LOCK(gResTypeLock);
            return(TRUE);
        }
    }
    RELEASE_LOCK(gResTypeLock);
    return(FALSE);

} // FmpInPossibleListForResType

DWORD
FmpValAddResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Add a dependency from one resource to another.

Arguments:

    Resource - The resource to add the dependent resource.

    DependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    //
    // If the resource or dependent resource have been marked for 
    // delete, then dont let a dependency be added.
    //
    if ((!IS_VALID_FM_RESOURCE(pResource)) ||
        (!IS_VALID_FM_RESOURCE(pDependentResource)))
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if (pResource->QuorumResource)
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    // If the resources are not in the same group, fail the
    // call. Also fail if some one tries to make a resource
    // dependent upon itself.
    //
    if ((pResource->Group != pDependentResource->Group) ||
        (pResource == pDependentResource)) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // The resource to which the dependency is being added must be offline
    // Otherwise, it looks like the dependency is in effect when the depending
    // resource was not really brought online at the time the dependency 
    // existed
    // must also be offline or failed.
    // SS:  For instance if a network name is dependent on two ip addresesses 
    // and
    // is online and a third ip address resource dependency is added, the
    // network name must be brought offline and online for the dependency
    // to be truly in effect
    //
    if ((pResource->State != ClusterResourceOffline) &&
         (pResource->State != ClusterResourceFailed)) 
    {
        dwStatus = ERROR_RESOURCE_ONLINE;
        goto FnExit;
    }

    //
    // Make sure that we don't have any circular dependencies!
    //
    if ( FmDependentResource( pDependentResource, pResource, FALSE ) ) 
    {
        dwStatus = ERROR_CIRCULAR_DEPENDENCY;
        goto FnExit;
    }

    //
    // Make sure that this dependency does not already exist!
    //
    if ( FmDependentResource(pResource, pDependentResource, TRUE)) 
    {
        dwStatus = ERROR_DEPENDENCY_ALREADY_EXISTS;
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpValAddResourceDependency


DWORD
FmpValRemoveResourceDependency(
    IN PFM_RESOURCE pResource,
    IN PFM_RESOURCE pDependentResource
    )

/*++

Routine Description:

    Validation routine for dependency removal.

Arguments:

    pResource - The resource to remove the dependent resource.

    pDependentResource - The dependent resource.

Returns:

    ERROR_SUCCESS if the validation is successful.

    A Win32 error code if the validation fails.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 8/3/99
    //   
    //  This function checks whether it is legal to remove the dependency
    //  relationship between 2 resources. Note that this function only
    //  does a partial validation, the rest is done in the GUM handler.
    //
    
    //
    //  If the resource has been marked for delete, then dont 
    //  let any dependency changes be made.
    //
    if ( !IS_VALID_FM_RESOURCE( pResource ) )
    {
        dwStatus = ERROR_RESOURCE_NOT_AVAILABLE;
        goto FnExit;
    }

    if ( pResource->QuorumResource )
    {
        dwStatus = ERROR_DEPENDENCY_NOT_ALLOWED;
        goto FnExit;
    }
    //
    //  If the resources are not in the same group, fail the
    //  call. Also fail if some one tries to make a resource
    //  dependent upon itself.
    //
    if ( ( pResource->Group != pDependentResource->Group ) ||
         ( pResource == pDependentResource ) ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    //  Ensure that both the resource and the dependent resource are in
    //  a stable state. This is necessary to prevent cases in which the
    //  user gets rid of a dependency link when one of the resources is in
    //  a pending state and later when the notification from resmon comes
    //  in and you try to stablize the rest of the waiting tree, the 
    //  dependency link is already cut and so the rest of the tree is
    //  stuck in pending state for ever !
    //
    if ( ( pResource->State > ClusterResourcePending ) ||
         ( pDependentResource->State > ClusterResourcePending ) ) 
    {
        dwStatus = ERROR_INVALID_STATE;
        goto FnExit;
    }

FnExit:
    return( dwStatus );

} // FmpValRemoveResourceDependency

VOID
FmpNotifyResourceStateChangeReason(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    )

/*++

Routine Description:

    Notify a resource DLL about the reason for a state change.

Arguments:

    pResource - The resource to be notified.

    eReason - The reason for the state change.

Returns:

    None.

Comments:

    This function will drop the notification only to those resources that support the
    CLUS_CHAR_REQUIRES_STATE_CHANGE_REASON characteristics. This function MUST be called
    with local group lock held.

--*/

{
    DWORD                                           dwStatus = ERROR_SUCCESS;
    DWORD                                           dwCharacteristics = 0;
    CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT     ClusterResourceStateChangeReason;
       
    //
    //  Make sure the state change reason is a valid one. 
    //
    if ( eReason == eResourceStateChangeReasonUnknown ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
                      "[FM] FmpNotifyResourceStateChangeReason: Invalid state change reason specified for resource %1!ws!...\n",
                      OmObjectId(pResource)); 
        CL_ASSERT( FALSE );
        goto FnExit;
    }
   
    //
    //  First of, check if the resource needs this state change notification.
    // 
    dwStatus = FmpRmResourceControl( pResource,
                                     CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                     NULL,
                                     0,
                                     ( PUCHAR ) &dwCharacteristics,
                                     sizeof( DWORD ),
                                     NULL,
                                     NULL );

    if ( ( dwStatus != ERROR_SUCCESS ) ||
         !( dwCharacteristics & CLUS_CHAR_REQUIRES_STATE_CHANGE_REASON ) ) 
    {
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE, 
                  "[FM] FmpNotifyResourceStateChangeReason: Resource %1!ws! [%2!ws!], Reason specified=%3!u!...\n",
                  OmObjectName(pResource),
                  OmObjectId(pResource),
                  eReason); 

    //
    //  This resource needs the state change reason. Drop it down to this resource.
    //
    ClusterResourceStateChangeReason.dwSize = sizeof ( CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT );
    ClusterResourceStateChangeReason.dwVersion = CLUSCTL_RESOURCE_STATE_CHANGE_REASON_VERSION_1;
    ClusterResourceStateChangeReason.eReason = eReason;

    dwStatus = FmpRmResourceControl( pResource,
                                     CLUSCTL_RESOURCE_STATE_CHANGE_REASON,
                                     ( PUCHAR ) &ClusterResourceStateChangeReason,
                                     ClusterResourceStateChangeReason.dwSize,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL );

    ClRtlLogPrint(LOG_NOISE, 
                  "[FM] FmpNotifyResourceStateChangeReason: Notified state change reason with status %1!u!...\n",
                  dwStatus);

FnExit:
    return;
} // FmpNotifyResourceStateChangeReason
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\monitor.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Monitor.c

Abstract:

    Routines for interfacing with the Resource Monitor process

Author:

    John Vert (jvert) 3-Jan-1996

Revision History:

--*/
#include "fmp.h"

#define LOG_MODULE MONITOR

//
// Global data
//
CRITICAL_SECTION    FmpMonitorLock;
LIST_ENTRY          g_leFmpMonitorListHead;
BOOL                g_fFmEnableResourceDllDeadlockDetection = FALSE;
DWORD               g_dwFmResourceDllDeadlockTimeout = 0;
DWORD               g_cResourceDllDeadlocks = 0;
DWORD               g_dwLastResourceDllDeadlockTick = 0;
DWORD               g_dwFmResourceDllDeadlockPeriod = 0;
DWORD               g_dwFmResourceDllDeadlockThreshold = 0;

//
// Local function prototypes
//
DWORD
FmpRmNotifyThread(
    IN LPVOID lpThreadParameter
    );

DWORD
FmpGetResmonDynamicEndpoint(
    OUT LPWSTR *ppResmonDynamicEndpoint
    );

PRESMON
FmpCreateMonitor(
    LPWSTR DebugPrefix,
    BOOL   SeparateMonitor
    )

/*++

Routine Description:

    Creates a new monitor process and initiates the RPC communication
    with it.

Arguments:

    None.

Return Value:

    Pointer to the resource monitor structure if successful.

    NULL otherwise.

--*/

{
#define FM_INITIAL_RESMON_COMMAND_LINE_SIZE    256
#define DOUBLE_QUOTE   TEXT( "\"" )
#define DEBUGGER_OPTION TEXT( " -d" )
#define SPACE TEXT ( " " )

    SECURITY_ATTRIBUTES Security;
    HANDLE WaitArray[2];
    HANDLE ThreadHandle;
    HANDLE Event = NULL;
    HANDLE FileMapping = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    PROCESS_INFORMATION DebugInfo;
    BOOL Success;
    TCHAR *Binding;
    RPC_BINDING_HANDLE RpcBinding;
    DWORD Status;
    PRESMON Monitor;
    DWORD ThreadId;
    DWORD Retry = 1;
    DWORD creationFlags;
    LPWSTR lpszResmonAppName = NULL;
    LPWSTR lpszResmonCmdLine = NULL;   
    DWORD cchCmdLineBufSize = FM_INITIAL_RESMON_COMMAND_LINE_SIZE;
    LPWSTR pResmonDynamicEndpoint = NULL;

    //
    //  Recover any DLL files left impartially upgraded.
    //
    FmpRecoverResourceDLLFiles ();

    Monitor = LocalAlloc(LMEM_ZEROINIT, sizeof(RESMON));
    if (Monitor == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to allocate a Monitor structure.\n");
        return(NULL);
    }

    Monitor->Shutdown = FALSE;
    Monitor->Signature = FMP_RESMON_SIGNATURE;

    //
    // Create an event and a file mapping object to be passed to
    // the Resource Monitor process. The event is for the Resource
    // Monitor to signal its initialization is complete. The file
    // mapping is for creating the shared memory region between
    // the Resource Monitor and the cluster manager.
    //
    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL;
    Security.bInheritHandle = TRUE;
    Event = CreateEvent(&Security,
                        TRUE,
                        FALSE,
                        NULL);
    if (Event == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to create a ResMon event, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL;
    Security.bInheritHandle = TRUE;
    FileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
                                    &Security,
                                    PAGE_READWRITE,
                                    0,
                                    sizeof(MONITOR_STATE),
                                    NULL);
    if (FileMapping == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] File Mapping for ResMon failed, error = %1!u!.\n",
                   Status);
        goto create_failed;
    }

    //
    // Create our own (read-only) view of the shared memory section
    //
    Monitor->SharedState = MapViewOfFile(FileMapping,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0);
    if (Monitor->SharedState == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Mapping shared state for ResMon failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    ZeroMemory( Monitor->SharedState, sizeof(MONITOR_STATE) );
    if ( !CsDebugResmon && DebugPrefix != NULL && *DebugPrefix != UNICODE_NULL ) {
        Monitor->SharedState->ResmonStop = TRUE;
    }

    //
    //  Get the resource monitor expanded app name. This should be passed to CreateProcess to
    //  avoid Trojan exe based security attacks (see Writing Secure Code p.419)
    //
    lpszResmonAppName = ClRtlExpandEnvironmentStrings( TEXT("%windir%\\cluster\\resrcmon.exe") );

    if ( lpszResmonAppName == NULL )
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                     "[FM] Unable to expand env strings in resmon app name, error %1!u!.\n",
                     Status);
        goto create_failed;        
    }

    //
    //  There are a few command line options that can be given to the resource monitor from the
    //  cluster service. These are
    //
    //  (1) Options given by the cluster service with no input from the user
    //      This looks like "resrcmon.exe -e Event -m Filemapping -p ClussvcPID"
    //
    //  (2) Options given by the cluster service with input from the user. There are 2 different
    //      cases:
    //      (2.1)  "resrcmon.exe -e Event -m Filemapping -p ClussvcPID -d"
    //              This option tells the resmon to wait for a debugger to be attached. Once the
    //              user attaches a debugger, the resmon will continue with its init.
    //
    //      (2.2)  "resrcmon.exe -e Event -m Filemapping -p ClussvcPID -d "debugger command""
    //             This option tells the resmon to create the process with the specified "debugger command"
    //             An example of a debugger command would be "ntsd -g -G".
    //
    //  (3) The admin sets the DebugPrefix property for the resource type.
    //      In this case, the cluster service will first create the resource monitor process and then
    //      create the debugger process specified by the DebugPrefix property passing it the PID
    //      of the resmon as an argument. The debugger can then attach to that PID.
    //
    while ( TRUE )
    {
        lpszResmonCmdLine = LocalAlloc ( LMEM_FIXED, cchCmdLineBufSize * sizeof ( WCHAR ) );

        if ( lpszResmonCmdLine == NULL )
        {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] Unable to alloc memory for cmd line, error %1!u!.\n",
                         Status);
            goto create_failed;               
        }
        
        //
        //  NULL terminate the buffer giving room for the possibility that a " -d" may have
        //  to fit in down below if the admin chooses the "-debugresmon" option. This "optimization"
        //  is done so that we don't have to reallocate in case the user just gives a "debugresmon"
        //  with no debugger command.
        //
        lpszResmonCmdLine [ cchCmdLineBufSize - ( wcslen( DEBUGGER_OPTION ) + 1 ) ] = UNICODE_NULL;

        //
        //  This is case 1 in the list outlined above.
        //  (1) Options given by the cluster service with no input from the user
        //      This looks like "resrcmon.exe -e Event -m Filemapping -p ClussvcPID"
        //
        if ( _snwprintf( lpszResmonCmdLine,
                    cchCmdLineBufSize - ( wcslen( DEBUGGER_OPTION ) + 1 ),  // Account space for NULL, and a possible -d option
                    TEXT("\"%ws\" -e %d -m %d -p %d"),
                    lpszResmonAppName,
                    Event,
                    FileMapping,
                    GetCurrentProcessId() ) > 0 ) 
        {
            break;
        }
        
        LocalFree ( lpszResmonCmdLine );
        lpszResmonCmdLine = NULL;

        if ( Retry == 9 )
        {
            Status = ERROR_INVALID_PARAMETER;
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] Command line is too big, error %1!u!.\n",
                         Status);
            goto create_failed;                      
        }

        cchCmdLineBufSize *= 2;
        Retry ++;
    }// while

    Retry = 0;
   
    if ( CsDebugResmon ) {
        //
        //  This is case 2.1 in the list outlined above.
        //
        //  (2) Options given by the cluster service with input from the user. There are 2 different
        //      cases:
        //      (2.1)  "resrcmon.exe -e Event -m Filemapping -p ClussvcPID -d"
        //              This option tells the resmon to wait for a debugger to be attached. Once the
        //              user attaches a debugger, the resmon will continue with its init.
        //
        //
        //  Wcsncat will ALWAYS NULL terminate the destination buffer.
        //
        wcsncat( lpszResmonCmdLine, 
                 DEBUGGER_OPTION, 
                 cchCmdLineBufSize - 
                     ( wcslen ( lpszResmonCmdLine ) + 1 ) );

        if ( CsResmonDebugCmd ) {
            //
            //  This is case 2.2 in the list outlined above.
            //
            //  (2) Options given by the cluster service with input from the user. There are 2 different
            //      cases:
            //
            //      (2.2)  "resrcmon.exe -e Event -m Filemapping -p ClussvcPID -d "debugger command""
            //             This option tells the resmon to create the process with the specified "debugger command"
            //             An example of a debugger command would be "ntsd -g -G".
            //
            DWORD cchCmdLineSize = wcslen( lpszResmonCmdLine );
            DWORD cchDebugCmdSize = wcslen( CsResmonDebugCmd );

            //
            // make sure our buffer is large enough; include 2 double quotes
            // the space and a NULL terminator
            //
            DWORD cchAdditionalChars = 2 * wcslen( DOUBLE_QUOTE ) + wcslen( SPACE ) + 1; 

            if ( cchCmdLineBufSize < ( cchCmdLineSize + cchDebugCmdSize + cchAdditionalChars ) ) {
                LPWSTR lpszResmonDebugCmd;

                //
                //  The previously allocated buffer is small. So, reallocate.
                //
                lpszResmonDebugCmd = ( LPWSTR ) LocalAlloc( LMEM_FIXED,
                                                   ( cchCmdLineSize + 
                                                     cchDebugCmdSize + 
                                                     cchAdditionalChars ) * sizeof( WCHAR ) );

                if ( lpszResmonDebugCmd != NULL ) {
                    //
                    //  Update the new command buffer size
                    //
                    cchCmdLineBufSize = cchCmdLineSize + cchDebugCmdSize + cchAdditionalChars;

                    //
                    //  lstrcpyn will NULL terminate the buffer in all cases, so we don't
                    //  have to explicitly NULL terminate the buffer
                    //
                    lstrcpyn( lpszResmonDebugCmd, lpszResmonCmdLine, cchCmdLineBufSize );

                    LocalFree ( lpszResmonCmdLine );

                    lpszResmonCmdLine = lpszResmonDebugCmd;
                    //
                    //  Wcsncat will ALWAYS NULL terminate the destination buffer.
                    //
                    wcsncat( lpszResmonCmdLine, 
                             SPACE, 
                             cchCmdLineBufSize - 
                                 ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                    wcsncat( lpszResmonCmdLine, 
                             DOUBLE_QUOTE, 
                             cchCmdLineBufSize - 
                                 ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                    wcsncat( lpszResmonCmdLine, 
                             CsResmonDebugCmd, 
                             cchCmdLineBufSize - 
                                 ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                    wcsncat( lpszResmonCmdLine, 
                             DOUBLE_QUOTE, 
                             cchCmdLineBufSize - 
                                 ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] Unable to allocate space for debug command line\n");
                }
            } else {
                //
                //  Wcsncat will ALWAYS NULL terminate the destination buffer.
                //
                wcsncat( lpszResmonCmdLine, 
                         SPACE, 
                         cchCmdLineBufSize - 
                             ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                wcsncat( lpszResmonCmdLine, 
                         DOUBLE_QUOTE, 
                         cchCmdLineBufSize - 
                             ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                wcsncat( lpszResmonCmdLine, 
                         CsResmonDebugCmd, 
                         cchCmdLineBufSize - 
                             ( wcslen ( lpszResmonCmdLine ) + 1 ) );
                wcsncat( lpszResmonCmdLine, 
                         DOUBLE_QUOTE, 
                         cchCmdLineBufSize - 
                             ( wcslen ( lpszResmonCmdLine ) + 1 ) );
            }
        }
    }

    //
    //  Acquire the monitor lock so as to ensure consistency of the resmon RPC EP that is set
    //  in the registry.
    //
    FmpAcquireMonitorLock();

    //
    // Attempt to start ResMon process.
    //
retry_resmon_start:

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    creationFlags = DETACHED_PROCESS;           // so ctrl-c won't kill it

    Success = CreateProcess(lpszResmonAppName,              // Must be supplied for security
                            lpszResmonCmdLine,              // Command line
                            NULL,
                            NULL,
                            FALSE,                          // Inherit handles
                            creationFlags,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInfo);

    if (!Success) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Failed to create resmon process, error %1!u!.\n",
                   Status);
        FmpReleaseMonitorLock();
        CL_LOGFAILURE(Status);
        goto create_failed;
    } else if ( CsDebugResmon && !CsResmonDebugCmd ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] Waiting for debugger to connect to resmon process %1!u!\n",
                   ProcessInfo.dwProcessId);
    }

    CloseHandle(ProcessInfo.hThread);           // don't need this

    //
    // Wait for the ResMon process to terminate, or for it to signal
    // its startup event.
    //
    WaitArray[0] = Event;
    WaitArray[1] = ProcessInfo.hProcess;
    Status = WaitForMultipleObjects(2,
                                    WaitArray,
                                    FALSE,
                                    INFINITE);
    if (Status == WAIT_FAILED) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Wait for ResMon to start failed, error %1!u!.\n",
                   Status);
        FmpReleaseMonitorLock();
        goto create_failed;
    }

    if (Status == ( WAIT_OBJECT_0 + 1 )) {
        if ( ++Retry > 1 ) {
           //
           // The resource monitor terminated prematurely.
           //
           GetExitCodeProcess(ProcessInfo.hProcess, &Status);
           ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] ResMon terminated prematurely, error %1!u!.\n",
                      Status);
            FmpReleaseMonitorLock();
            goto create_failed;
        } else {
            goto retry_resmon_start;
        }
    } else {
        //
        //  Get the resmon dynamic EP from the registry.
        //
        Status = FmpGetResmonDynamicEndpoint ( &pResmonDynamicEndpoint );

        //
        //  Release the monitor lock now that you have read the resmon EP.
        //
        FmpReleaseMonitorLock();

        if ( Status != ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                         "[FM] Unable get resmon dynamic EP, error %1!u!.\n",
                         Status);
            goto create_failed;               
        }
        
        //
        // The resource monitor has successfully initialized
        //
        CL_ASSERT(Status == 0);
        Monitor->Process = ProcessInfo.hProcess;

        //
        // invoke the DebugPrefix process only if we're not already debugging
        // the resmon process
        //
        if ( CsDebugResmon && DebugPrefix && *DebugPrefix != UNICODE_NULL ) {

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[FM] -debugresmon overrides DebugPrefix property\n");
        }

        if ( !CsDebugResmon && ( DebugPrefix != NULL ) && ( *DebugPrefix != UNICODE_NULL )) {
            WCHAR DebugLine[512];

            //
            //  This is case 3 in the list outlined above.
            //
            //  (3) The admin sets the DebugPrefix property for the resource type.
            //      In this case, the cluster service will first create the resource monitor process and then
            //      create the debugger process specified by the DebugPrefix property passing it the PID
            //      of the resmon as an argument. The debugger can then attach to that PID.
            //
            DebugLine[ RTL_NUMBER_OF( DebugLine ) - 1 ] = UNICODE_NULL;

            _snwprintf( DebugLine, 
                        RTL_NUMBER_OF( DebugLine ) - 1, 
                        TEXT("\"%ws\" -p %d"), 
                        DebugPrefix, 
                        ProcessInfo.dwProcessId );
            
            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.lpDesktop = TEXT("WinSta0\\Default");

            Success = CreateProcess( DebugPrefix,           // Must supply app name
                                     DebugLine,             // Cmd line arguments
                                     NULL,
                                     NULL,
                                     FALSE,                 // Inherit handles
                                     CREATE_NEW_CONSOLE,                                  
                                     NULL,
                                     NULL,
                                     &StartupInfo,
                                     &DebugInfo );

            Monitor->SharedState->ResmonStop = FALSE;

            if ( !Success ) {
                Status = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] ResMon debug start failed, error %1!u!.\n",
                            Status);
            } else {
                CloseHandle(DebugInfo.hThread);           // don't need this
                CloseHandle(DebugInfo.hProcess);          // don't need this
            }
        }
    }

    CloseHandle(Event);
    CloseHandle(FileMapping);
    Event = NULL;
    FileMapping = NULL;

    //
    // Initiate RPC with resource monitor process. 
    //
    Status = RpcStringBindingCompose(TEXT("e76ea56d-453f-11cf-bfec-08002be23f2f"),
                                     TEXT("ncalrpc"),
                                     NULL,
                                     pResmonDynamicEndpoint,    // Dynamic EP string
                                     NULL,
                                     &Binding);
   
    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] ResMon RPC binding compose failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }
    Status = RpcBindingFromStringBinding(Binding, &Monitor->Binding);

    RpcStringFree(&Binding);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] ResMon RPC binding creation failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    //
    // Set the binding level on the binding handle.
    //
    Status = RpcBindingSetAuthInfoW(Monitor->Binding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);
    
    if (  Status != RPC_S_OK ) {
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] Failed to set RPC auth level, error %1!d!\n", Status );
        goto create_failed;
    }
    
    //
    // Start notification thread.
    //
    Monitor->NotifyThread = CreateThread(NULL,
                                         0,
                                         FmpRmNotifyThread,
                                         Monitor,
                                         0,
                                         &ThreadId);

    if (Monitor->NotifyThread == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] Creation of notify thread for ResMon failed, error %1!u!.\n",
                   Status);
        goto create_failed;
    }

    Monitor->RefCount = 2;

    LocalFree ( lpszResmonAppName );
    LocalFree ( lpszResmonCmdLine );
    LocalFree ( pResmonDynamicEndpoint );

    //
    //  Insert the new entry into the monitor list
    //
    InitializeListHead ( &Monitor->leMonitor );

    FmpAcquireMonitorLock ();
    InsertTailList ( &g_leFmpMonitorListHead, &Monitor->leMonitor );
    FmpReleaseMonitorLock ();

    //
    //  Check if deadlock detection on resource dlls is enabled and if so update the
    //  monitor. We should only log failures in this function and not affect the 
    //  monitor creation itself.
    //
    FmpCheckAndUpdateMonitorForDeadlockDetection ( Monitor );
    
    return(Monitor);

create_failed:

    //
    //  Whack the process and close the handle if it was spawned already
    //
    if ( Monitor->Process != NULL ) {
        TerminateProcess( Monitor->Process, 1 );
        CloseHandle( Monitor->Process );
    }

    //
    // Wait for the notify thread to exit, but just a little bit.
    //
    if ( Monitor->NotifyThread != NULL ) {
        WaitForSingleObject( Monitor->NotifyThread,
                             FM_RPC_TIMEOUT*2 ); // Increased timeout to try to ensure RPC completes
        CloseHandle( Monitor->NotifyThread );
        Monitor->NotifyThread = NULL;
    }

    //
    //  Unmap view of shared file.
    //
    if ( Monitor->SharedState ) UnmapViewOfFile( Monitor->SharedState );

    //
    //  Free the RPC binding handle
    //
    if ( Monitor->Binding != NULL ) {
        RpcBindingFree( &Monitor->Binding );
    }

    LocalFree( Monitor );

    if ( FileMapping != NULL ) {
        CloseHandle( FileMapping );
    }

    if ( Event != NULL ) {
        CloseHandle( Event );
    }

    LocalFree ( lpszResmonAppName );
    LocalFree ( lpszResmonCmdLine );
    LocalFree ( pResmonDynamicEndpoint );

    SetLastError(Status);

    return(NULL);

} // FmpCreateMonitor



VOID
FmpShutdownMonitor(
    IN PRESMON Monitor
    )

/*++

Routine Description:

    Performs a clean shutdown of the Resource Monitor process.
    Note that this does not make any changes to the state of
    any resources being monitored by the Resource Monitor, it
    only asks the Resource Monitor to clean up and terminate.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD Status;

    CL_ASSERT(Monitor != NULL);

    FmpAcquireMonitorLock();

    if ( Monitor->Shutdown ) {
        FmpReleaseMonitorLock();
        return;
    }

    Monitor->Shutdown = TRUE;

    FmpReleaseMonitorLock();

    //
    // RPC to the server process to tell it to shutdown.
    //
    RmShutdownProcess(Monitor->Binding);

    //
    // Wait for the process to exit so that the monitor fully cleans up the resources if necessary.
    //
    if ( Monitor->Process ) {
        Status = WaitForSingleObject(Monitor->Process, FM_MONITOR_SHUTDOWN_TIMEOUT);
        if ( Status != WAIT_OBJECT_0 ) {
            ClRtlLogPrint(LOG_ERROR,"[FM] Failed to shutdown resource monitor.\n");
            TerminateProcess( Monitor->Process, 1 );
        }
        CloseHandle(Monitor->Process);
        Monitor->Process = NULL;
    }

    RpcBindingFree(&Monitor->Binding);

    //
    // Wait for the notify thread to exit, but just a little bit.
    //
    if ( Monitor->NotifyThread ) {
        Status = WaitForSingleObject(Monitor->NotifyThread, 
                                     FM_RPC_TIMEOUT*2); // Increased timeout to try to ensure RPC completes
        if ( Status != WAIT_OBJECT_0 ) {
            ;                   // call removed: Terminate Thread( Monitor->NotifyThread, 1 );
                                // Bad call to make since terminating threads on NT can cause real problems.
        }
        CloseHandle(Monitor->NotifyThread);
        Monitor->NotifyThread = NULL;
    }
    //
    // Clean up shared memory mapping
    //
    UnmapViewOfFile(Monitor->SharedState);

    //
    //  Remove this entry from the monitor list
    //
    FmpAcquireMonitorLock ();
    RemoveEntryList ( &Monitor->leMonitor );
    FmpReleaseMonitorLock ();

    if ( InterlockedDecrement(&Monitor->RefCount) == 0 ) {
        PVOID caller, callersCaller;
        RtlGetCallersAddress(
                &caller,
                &callersCaller );
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (1) %1!lx!, caller %2!lx!, callerscaller %3!lx!\n",
                   Monitor, caller, callersCaller );
        LocalFree(Monitor);
    }

    return;

} // FmpShutdownMonitor



DWORD
FmpRmNotifyThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This is the thread that receives resource monitor notifications.

Arguments:

    lpThreadParameter - Pointer to resource monitor structure.

Return Value:

    None.

--*/

{
    PRESMON Monitor;
    PRESMON NewMonitor;
    RM_NOTIFY_KEY  NotifyKey;
    DWORD   NotifyEvent;
    DWORD   Status;
    CLUSTER_RESOURCE_STATE CurrentState;
    BOOL Success;

    Monitor = lpThreadParameter;

    //
    // Loop forever picking up resource monitor notifications.
    // When the resource monitor returns FALSE, it indicates
    // that shutdown is occurring.
    //
    do {
        try {
            Success = RmNotifyChanges(Monitor->Binding,
                                      &NotifyKey,
                                      &NotifyEvent,
                                      (LPDWORD)&CurrentState);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // RPC communications failure, treat it as a shutdown.
            //
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] NotifyChanges got an RPC failure, %1!u!.\n",
                       Status);
            Success = FALSE;
        }

        if (Success) {
            Success = FmpPostNotification(NotifyKey, NotifyEvent, CurrentState);
        } else {           
            //
            // If we are shutting down... then this is okay.
            //
            if ( FmpShutdown ||
                 Monitor->Shutdown ) {
                break;
            }

            //
            // We will try to start a new resource monitor. If this fails,
            // then shutdown the cluster service.
            //
            ClRtlLogPrint(LOG_ERROR,
                       "[FM] Resource monitor terminated!\n");

            ClRtlLogPrint(LOG_ERROR,
                       "[FM] Last resource monitor state: %1!u!, resource %2!u!.\n",
                       Monitor->SharedState->State,
                       Monitor->SharedState->ActiveResource);
                       
            CsLogEvent(LOG_UNUSUAL, FM_EVENT_RESMON_DIED);

            //
            //  If this resource monitor has deadlocked, try to handle that deadlock. Note that
            //  the fact that resmon gave this specific state value means that deadlock detection
            //  was enabled in that monitor.
            //
            if ( Monitor->SharedState->State == RmonDeadlocked )
            {
                FmpHandleMonitorDeadlock ( Monitor );
            }

            //
            // Use a worker thread to start new resource monitor(s).
            //
            if (FmpCreateMonitorRestartThread(Monitor))
                CsInconsistencyHalt(ERROR_INVALID_STATE);
        }

    } while ( Success );

    ClRtlLogPrint(LOG_NOISE,"[FM] RmNotifyChanges returned\n");

    if ( InterlockedDecrement( &Monitor->RefCount ) == 0 ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (2) %1!lx!\n",
                   Monitor );
        LocalFree( Monitor );
    }

    return(0);

} // FmpRmNotifyThread



BOOL
FmpFindMonitorResource(
    IN PRESMON OldMonitor,
    IN PMONITOR_RESOURCE_ENUM *PtrEnumResource,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )

/*++

Routine Description:

    Finds all resources that were managed by the old resource monitor and
    starts them under the new resource monitor. Or adds them to the list
    of resources to be restarted.

Arguments:

    OldMonitor - pointer to the old resource monitor structure.

    PtrEnumResource - pointer to a pointer to a resource enum structure.

    Resource - the current resource being enumerated.

    Name - name of the current resource.

Return Value:

    TRUE - if we should continue enumeration.
    FALSE - otherwise.

Notes:

    Nothing in the old resource monitor structure should be used.

--*/

{
    DWORD   status;
    BOOL    returnNow = FALSE;
    PMONITOR_RESOURCE_ENUM enumResource = *PtrEnumResource;
    PMONITOR_RESOURCE_ENUM newEnumResource;
    DWORD   dwOldBlockingFlag;

    if ( Resource->Monitor == OldMonitor ) {
        if ( enumResource->fCreateMonitors == FALSE ) goto skip_monitor_creation;
        
        //
        // If this is not the quorum resource and it is blocking the
        // quorum resource, then fix it up now.
        //

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] RestartMonitor: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                    OmObjectId(Resource));
            InterlockedDecrement(&gdwQuoBlockingResources);
        }

        //
        // If the resource had been previously create in Resmon, then recreate
        // it with a new resource monitor.
        //
        if ( Resource->Flags & RESOURCE_CREATED ) {
            // Note - this will create a new resource monitor as needed.
            status = FmpRmCreateResource(Resource);
            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_ERROR,"[FM] Failed to restart resource %1!ws!. Error %2!u!.\n",
                Name, status );
                return(TRUE);
            }
        } else {
            return(TRUE);
        }
    } else {
        return(TRUE);
    }
    
skip_monitor_creation:
    //
    // If we successfully recreated a resource monitor, then add it to the
    // list of resources to indicate failure.
    //
    if ( enumResource->CurrentIndex >= enumResource->EntryCount ) {
        newEnumResource = LocalReAlloc( enumResource,
                            MONITOR_RESOURCE_SIZE( enumResource->EntryCount +
                                                   ENUM_GROW_SIZE ),
                            LMEM_MOVEABLE );
        if ( newEnumResource == NULL ) {
            ClRtlLogPrint(LOG_ERROR,
                "[FM] Failed re-allocating resource enum to restart resource monitor!\n");
            return(FALSE);
        }
        enumResource = newEnumResource;
        enumResource->EntryCount += ENUM_GROW_SIZE;
        *PtrEnumResource = newEnumResource;
    }

    enumResource->Entry[enumResource->CurrentIndex] = Resource;
    ++enumResource->CurrentIndex;

    return(TRUE);

} // FmpFindMonitorResource


BOOL
FmpRestartMonitor(
    IN PRESMON OldMonitor,
    IN BOOL fCreateResourcesOnly,
    OUT OPTIONAL PMONITOR_RESOURCE_ENUM *ppMonitorResourceEnum
    )

/*++

Routine Description:

    Creates a new monitor process and initiates the RPC communication
    with it. Restarts all resources that were attached to the old monitor
    process if requested to do so (see second parameter).

Arguments:

    OldMonitor - pointer to the old resource monitor structure.

    fCreateResourcesOnly - Create but do not start any resources

    ppMonitorResourceEnum - Resources hosted in the old monitor.

Return Value:

    TRUE if successful.

    FALSE otherwise.

Notes:

    The old monitor structure is deallocated when done.

--*/
{
    DWORD   enumSize;
    DWORD   i;
    DWORD   status;
    PMONITOR_RESOURCE_ENUM enumResource;
    PFM_RESOURCE resource;
    DWORD   dwOldBlockingFlag;

    FmpAcquireMonitorLock();

    if ( FmpShutdown ) {
        FmpReleaseMonitorLock();
        return(TRUE);
    }

    enumSize = MONITOR_RESOURCE_SIZE( ENUM_GROW_SIZE );
    enumResource = LocalAlloc( LMEM_ZEROINIT, enumSize );
    if ( enumResource == NULL ) {
        ClRtlLogPrint(LOG_ERROR,
            "[FM] Failed allocating resource enum to restart resource monitor!\n");
        FmpReleaseMonitorLock();
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    enumResource->EntryCount = ENUM_GROW_SIZE;

    //
    //  Issue preoffline notifications only if the resources should be created and brought online.
    //  Else, that will be done by FmpHandleResourceRestartOnMonitorCrash.
    //
    if ( fCreateResourcesOnly == FALSE )
    {
        enumResource->CurrentIndex = 0;
        enumResource->fCreateMonitors = FALSE;

        //
        // Enumerate all resources controlled by the old resource monitor so that we can invoke the
        // handlers registered for those resources. Both preoffline and postoffline handlers are
        // invoked prior to monitor shutdown so that the assumption made about underlying resource 
        // access (such as quorum disk access) remain valid in a graceful monitor shutdown case. 
        // We would issue a specific shutdown command in the case of a graceful shutdown occurring 
        // as a part of resource DLL upgrade.
        //
        OmEnumObjects( ObjectTypeResource,
                       (OM_ENUM_OBJECT_ROUTINE)FmpFindMonitorResource,
                       OldMonitor,
                       &enumResource );

        for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
            resource = enumResource->Entry[i];
            if ( ( resource->PersistentState == ClusterResourceOnline ) &&
                 ( resource->Group->OwnerNode == NmLocalNode ) ) {
                OmNotifyCb( resource, NOTIFY_RESOURCE_PREOFFLINE );
                OmNotifyCb( resource, NOTIFY_RESOURCE_POSTOFFLINE );
            }
        }
    }
	
    FmpShutdownMonitor( OldMonitor );

    if ( FmpDefaultMonitor == OldMonitor ) {
        FmpDefaultMonitor = FmpCreateMonitor(NULL, FALSE);
        if ( FmpDefaultMonitor == NULL ) {
            LocalFree( enumResource );
            FmpReleaseMonitorLock();
            CsInconsistencyHalt(GetLastError());
            return(FALSE);
        }
    }

    enumResource->CurrentIndex = 0;
    enumResource->fCreateMonitors = TRUE;

    //
    // Enumerate all resources controlled by the old resource monitor,
    // and connect them into the new resource monitor.
    //
    OmEnumObjects( ObjectTypeResource,
                   (OM_ENUM_OBJECT_ROUTINE)FmpFindMonitorResource,
                   OldMonitor,
                   &enumResource );

    //
    //  If you are not requested to restart any resources, bail
    //
    if ( fCreateResourcesOnly == TRUE )
    {
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpRestartMonitor: Skip restarting resources...\n");
        goto FnExit;
    }

    //
    // First set each resource in the list to the Offline state.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system, then do it.
        //
        if ( resource->Group->OwnerNode == NmLocalNode ) {
            resource->State = ClusterResourceOffline;

            //
            // If this is not the quorum resource and it is blocking the
            // quorum resource, then fix it up now.
            //


            dwOldBlockingFlag = InterlockedExchange( &resource->BlockingQuorum, 0 );
            if ( dwOldBlockingFlag ) {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] RestartMonitor: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                        OmObjectId(resource));
                InterlockedDecrement(&gdwQuoBlockingResources);
            }
        }
    }

    //
    // Find the quorum resource - if present bring online first.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system and is the
        // quorum resource, then do it.
        //
        if ( (resource->Group->OwnerNode == NmLocalNode) &&
             resource->QuorumResource ) {
            FmpRestartResourceTree( resource );
        }
    }

    //
    // Now restart the rest of the resources in the list.
    //
    for ( i = 0; i < enumResource->CurrentIndex; i++ ) {
        resource = enumResource->Entry[i];
        //
        // If the resource is owned by the local system, then do it.
        //
        if ( (resource->Group->OwnerNode == NmLocalNode) &&
             !resource->QuorumResource ) {
            FmpRestartResourceTree( resource );
        }
    }

FnExit:
    FmpReleaseMonitorLock();

    //
    //  If the caller has requested for the enumerated resource list, give it. It is the responsibility
    //  of the caller to free the list.
    //
    if ( ARGUMENT_PRESENT ( ppMonitorResourceEnum ) )
    {
        *ppMonitorResourceEnum = enumResource;
    } else
    {
        LocalFree( enumResource );
    }

    //
    // Don't delete the old monitor block until we've reset the resources
    // to point to the new resource monitor block.
    // Better to get an RPC failure, rather than some form of ACCVIO.
    //   
    if ( InterlockedDecrement( &OldMonitor->RefCount ) == 0 ) {
#if 0
        PVOID caller, callersCaller;
        RtlGetCallersAddress(
                &caller,
                &callersCaller );
        ClRtlLogPrint(LOG_NOISE,
                   "[FMY] Freeing monitor structure (3) %1!lx!, caller %2!lx!, callerscaller %3!lx!\n",
                   OldMonitor, caller, callersCaller );
#endif
        LocalFree( OldMonitor );
    }

    return(TRUE);

} // FmpRestartMonitor



/****
@func       DWORD | FmpCreateMonitorRestartThread| This creates a new
            thread to restart a monitor.  

@parm       IN PRESMON | pMonitor| Pointer to the resource monitor that n
            needs to be restarted.

@comm       A monitor needs to be started in a separate thread as it
            decrements the gquoblockingrescount for resources therein.  
            This cannot be done by fmpworkerthread because that causes 
            deadlocks if other items, like failure handling, being 
            processed by the fmpworkerthread are waiting for work that 
            will done by the items, like restart monitor, still in queue.
            
@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/
DWORD FmpCreateMonitorRestartThread(
    IN PRESMON pMonitor
)
{

    HANDLE                  hThread = NULL;
    DWORD                   dwThreadId;
    DWORD                   dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateMonitorRestartThread: Entry\r\n");

    //reference the resource
    //the thread will dereference it
    InterlockedIncrement( &pMonitor->RefCount );

    hThread = CreateThread( NULL, 0, FmpHandleMonitorCrash,
                pMonitor, 0, &dwThreadId );

    if ( hThread == NULL )
    {
        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }

FnExit:
    //do general cleanup
    if (hThread)
        CloseHandle(hThread);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateMonitorRestartThread: Exit, status %1!u!\r\n",
        dwStatus);
        
    return(dwStatus);
}

BOOL
FmpHandleMonitorCrash(
    IN PRESMON pCrashedMonitor
    )

/*++

Routine Description:

    Handle the crash of a resource monitor.

Arguments:

    pCrashedMonitor - Pointer to the crashed monitor.

Return Value:

	None.
	
--*/
{
    PMONITOR_RESOURCE_ENUM      pEnumResourcesHosted = NULL;
    DWORD                       i, cRetries = MmQuorumArbitrationTimeout * 4;  // Wait for quorum online for twice the arb timeout;
    PFM_RESOURCE                pResource, pExchangedResource;
    BOOL                        fStatus = TRUE;

    FmpRestartMonitor ( pCrashedMonitor,            // Crashed monitor
                        TRUE,                       // Just create resources
                        &pEnumResourcesHosted );    // Resources hosted in old monitor

    if ( pEnumResourcesHosted == NULL )
    {
        fStatus = FALSE;
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmpHandleMonitorCrash: No resources in crashed monitor\n");
        goto FnExit;
    }

    //
    //  Acquire the quorum change lock to make sure the quorum resource is not changed
    //  from under us.
    //
    ACQUIRE_SHARED_LOCK ( gQuoChangeLock );

    //
    //  Make sure the quorum resource is first in the enumerated list, so that it can be brought
    //  online first.  This is needed because no resource can go online until the quorum resource
    //  does.
    //
    for ( i = 0; i < pEnumResourcesHosted->CurrentIndex; i++ ) 
    {
        if ( pEnumResourcesHosted->Entry[i] == gpQuoResource ) 
        {           
            //
            //  If the quorum resource is already first in the list, bail.
            //
            if ( i == 0 ) break;

            //
            //  Swap the quorum resource with the first resource in the list.
            //
            pExchangedResource = pEnumResourcesHosted->Entry[0]; 
            pEnumResourcesHosted->Entry[0] = gpQuoResource;
            pEnumResourcesHosted->Entry[i] = pExchangedResource;
            ClRtlLogPrint(LOG_NOISE, "[FM] FmpHandleMonitorCrash: Move quorum resource %1!ws! into first position in list\n",
                         OmObjectName(gpQuoResource));
            break;
        }      
    } // for

    //
    //  Handle the restart of each resource
    //
    for ( i = 0; i < pEnumResourcesHosted->CurrentIndex; i++ ) 
    {
        pResource = pEnumResourcesHosted->Entry[i];

        //
        //  Order of locks gQuoChangeLock -> Group lock should be ok (see fm\fminit.c)
        //
        FmpAcquireLocalResourceLock ( pResource );

        //
        //  If this is the owner node, take some action.
        //
        if ( pResource->Group->OwnerNode == NmLocalNode )
        {
            FmpHandleResourceRestartOnMonitorCrash ( pResource ); 
        } // if

        FmpReleaseLocalResourceLock ( pResource );

    } // for

    RELEASE_LOCK ( gQuoChangeLock );
    
FnExit:
    LocalFree ( pEnumResourcesHosted );
    return ( fStatus );
}// FmpHandleMonitorCrash

DWORD
FmpGetResmonDynamicEndpoint(
    OUT LPWSTR *ppResmonDynamicEndpoint
    )

/*++

Routine Description:

    Read the resource monitor dynamic endpoint from the registry.

Arguments:

    ppResmonDynamicEndpoint - Pointer to the dynamic endpoint string

Return Value:

	None.
	
--*/
{
    HKEY    hParamsKey = NULL;
    DWORD   dwStatus, dwSize = 0, dwType;

    //
    //  NULL out return parameter
    //
    *ppResmonDynamicEndpoint = NULL;
    
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKey ( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] Error in opening cluster service params key, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Get the size of the EP name string
    //
    dwStatus = RegQueryValueEx ( hParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                                 0,
                                 &dwType,
                                 NULL,
                                 &dwSize );


    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] Error in querying %1!ws! value size, status %2!u!\n",
                      CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                      dwStatus);
        goto FnExit;
    }

    *ppResmonDynamicEndpoint = ( LPWSTR ) LocalAlloc( LMEM_FIXED, dwSize );

    if ( *ppResmonDynamicEndpoint == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[FM] Error in memory allocation for resmon EP string, status %1!u!\n",
                      dwStatus);
        goto FnExit;               
    }

    //
    //  Get the EP name string
    //
    dwStatus = RegQueryValueExW( hParamsKey,
                                 CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                                 0,
                                 &dwType,
                                 ( LPBYTE ) *ppResmonDynamicEndpoint,
                                 &dwSize );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL, "[FM] Error in querying %1!ws! value, status %2!u!\n",
                      CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                      dwStatus);
        goto FnExit;               
    }

    //
    //  Delete the value, but this operation is not fatal if it doesn't succeed
    //
    dwStatus = RegDeleteValue ( hParamsKey, CLUSREG_NAME_SVC_PARAM_RESMON_EP );
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] Error in deleting %1!ws! value, status %2!u!\n",
                      CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                      dwStatus);
        dwStatus = ERROR_SUCCESS;
        goto FnExit;               
    }

    ClRtlLogPrint(LOG_NOISE, "[FM] Resmon LRPC EP name is %1!ws!\n", *ppResmonDynamicEndpoint);
    
FnExit:
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        LocalFree ( *ppResmonDynamicEndpoint );
        *ppResmonDynamicEndpoint = NULL;
    }
    if ( hParamsKey ) RegCloseKey ( hParamsKey );
    return ( dwStatus );
}  // FmpGetResmonDynamicEndpoint        

VOID
FmpHandleResourceRestartOnMonitorCrash(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Take action to restart the specified resource on a monitor crash.

Arguments:

    pResource - Pointer to the resource to be restarted.

Return Value:

	None.

Comments:

    This function essentially does the same job as what FmpRmDoHandleCriticalResourceStateChange
    does with one VERY CRUCIAL difference. While that function relies on the resource structure
    to look at the current state and see if a failure needs to be processed, this function WILL
    FORCE a failure to be processed. This is needed in a case such as 
        1. The current state of the resource is failed.
        2. FM is trying to terminate the resource.
        3. The resource dll gets stuck in terminate.
        4. Resource monitor detects a deadlock and terminates itself.
        5. We will post a new failure notification generated by the monitor crash.
        6. Resource state in this case transitions from failed to failed and so if we were to
           rely on FmpRmDoHandleCriticalResourceStateChange, no action will be taken.
        7. On the other hand, this function will pretend the last state of the resource was
           ClusterResourceOnline and force a restart.
        8. Of course, only those resources whose persistent state is set to 1 will be restarted by
           FmpOnlineResource.
    
--*/
{
    //
    //  If this is the quorum resource, handle the failure in this thread itself and don't post it to
    //  the worker. This is because it is possible in a wierd case for some resources to be stuck 
    //  in the FM worker thread waiting for the quorum resource to go online and the quorum resource
    //  online work item is queued behind. Note also that this function is called from a non-worker
    //  thread. In addition, we handle the quorum online first and so other resources are free to 
    //  go online after the quorum comes online.
    //
    ClRtlLogPrint (LOG_NOISE, "[FM] FmpHandleResourceRestartOnMonitorCrash: Processing resource %1!ws!\n",
                   OmObjectName ( pResource ) );

    //
    //  If this resource is either online or in pending state, declare it as failed. We don't
    //  touch failed or offline resources. Note that we need to mark the state as failed so
    //  that management tools show the state of the resource correctly. In addition, we want
    //  the clussvc to die in case the quorum resource fails repeatedly and that triggers a 
    //  group failure.
    //
    if ( ( pResource->State == ClusterResourceOnline ) ||
         ( pResource->State > ClusterResourcePending ) )
    {
        FmpPropagateResourceState( pResource, ClusterResourceFailed );
    }
  
    //
    //  Comments from sunitas: Call the synchronous notifications. 
    //  This is done before the count is decremented as the synchronous 
    //  callbacks like the registry replication must get a chance to 
    //  finish before the quorum resource state is allowed to change.
    //
    //  Note, there is no synchronization here with the resmon's 
    //  online/offline code. They are using the local resource locks.
    //
    FmpCallResourceNotifyCb( pResource, ClusterResourceFailed );

    //
    //  This function is called with gQuoChangeLock held, so this check is safe.
    //
    if ( pResource == gpQuoResource )
    {
        InterlockedExchange( &pResource->BlockingQuorum, 0 );

        //
        //  If this group is moving, then return.
        //
        if ( ( pResource->Group->MovingList != NULL ) ||
             ( pResource->Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) )
        {
            ClRtlLogPrint (LOG_NOISE, "[FM] FmpHandleResourceRestartOnMonitorCrash: Take no action on resource %1!ws! since group is moving\n",
                           OmObjectName ( pResource ) );
            goto FnExit;
        }
    
        FmpProcessResourceEvents ( pResource,           
                                   ClusterResourceFailed,   // New state
                                   ClusterResourceOnline ); // Old state -- pretend it is online to force
                                                            // a restart.
        goto FnExit;
    }

    //
    //  Just to be safe, make sure the blocking quorum count is reduced by 1 if necessary.
    //
    if ( InterlockedExchange( &pResource->BlockingQuorum, 0 ) ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpHandleResourceRestartOnMonitorCrash: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                      OmObjectName(pResource));
        InterlockedDecrement( &gdwQuoBlockingResources );
    }

    //
    //  If this group is moving, then return.
    //
    if ( ( pResource->Group->MovingList != NULL ) ||
         ( pResource->Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) )
    {
        ClRtlLogPrint (LOG_NOISE, "[FM] FmpHandleResourceRestartOnMonitorCrash: Take no action on resource %1!ws! since group is moving\n",
                       OmObjectName ( pResource ) );
        goto FnExit;
    }

    //
    //  Now post a work item to the FM worker thread to process this non-quorum resource
    //  failure.
    //
    OmReferenceObject ( pResource );
    FmpPostWorkItem( FM_EVENT_RES_RESOURCE_FAILED,
                     pResource,
                     ClusterResourceOnline );  // Old state -- pretend it is online to force
                                               // a restart.     

FnExit:
    return;
}// FmpHandleResourceRestartOnMonitorCrash

VOID
FmCheckIsDeadlockDetectionEnabled(
    )

/*++

Routine Description:

    Query the cluster key and see if deadlock detection is enabled.

Arguments:

    None.
    
Return Value:

	None.
	
--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       dwValue = 0;
    BOOL        fDeadlockDetectionEnabled = FALSE;
    DWORD       dwDeadlockDetectionTimeout = CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_TIMEOUT_SECS; 
    DWORD       dwDeadlockDetectionPeriod = CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_PERIOD_SECS;
    DWORD       dwDeadlockDetectionThreshold = CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_THRESHOLD;

    if ( !FmpInitialized ) return;

    //
    //  First check if deadlock detection is enabled. If not, you are done.
    //
    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_CLUS_ENABLE_RESOURCE_DLL_DEADLOCK_DETECTION,
                             &dwValue, 
                             NULL );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmCheckIsDeadlockDetectionEnabled: Unable to query cluster property %1!ws!, status %2!u!\n",
                         CLUSREG_NAME_CLUS_ENABLE_RESOURCE_DLL_DEADLOCK_DETECTION,
                         dwStatus);
            goto FnExit;
        } else
        {
            //
            //  No value is present. Return with success.
            //
            dwStatus = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    if ( dwValue == 1 ) 
    {
        fDeadlockDetectionEnabled = TRUE;
    } else if ( dwValue != 0 )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmCheckIsDeadlockDetectionEnabled: Illegal value set %2!u! for property %1!ws!, ignoring\n",
                      CLUSREG_NAME_CLUS_ENABLE_RESOURCE_DLL_DEADLOCK_DETECTION,
                      dwValue);
        goto FnExit;
    } else
    {
        goto FnExit;
    }

    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_TIMEOUT,
                             &dwDeadlockDetectionTimeout, 
                             &dwDeadlockDetectionTimeout ); // Set initially to the default

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmCheckIsDeadlockDetectionEnabled: Unable to query cluster property %1!ws!, status %2!u!\n",
                         CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_TIMEOUT,
                         dwStatus);
            goto FnExit;
        } else
        {
            //
            //  No value is present. Continue with success status.
            //
            dwStatus = ERROR_SUCCESS;
        }
    }

    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_THRESHOLD,
                             &dwDeadlockDetectionThreshold, 
                             &dwDeadlockDetectionThreshold ); // Set initially to the default

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmCheckIsDeadlockDetectionEnabled: Unable to query cluster property %1!ws!, status %2!u!\n",
                         CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_THRESHOLD,
                         dwStatus);
            goto FnExit;
        } else
        {
            //
            //  No value is present. Continue with success status.
            //
            dwStatus = ERROR_SUCCESS;
        }
    }

    dwStatus = DmQueryDword( DmClusterParametersKey,
                             CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_PERIOD,
                             &dwDeadlockDetectionPeriod, 
                             &dwDeadlockDetectionPeriod ); // Set initially to the default

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[FM] FmCheckIsDeadlockDetectionEnabled: Unable to query cluster property %1!ws!, status %2!u!\n",
                         CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_PERIOD,
                         dwStatus);
            goto FnExit;
        } else
        {
            //
            //  No value is present. Continue with success status.
            //
            dwStatus = ERROR_SUCCESS;
        }
    }
     
FnExit:
    if ( dwStatus == ERROR_SUCCESS )
    {
        DWORD   dwCurrentDeadlockDetectionTimeout;
        BOOL    fIsDeadlockDetectionEnabledCurrently;
        DWORD   dwCurrentDeadlockDetectionPeriod;
        DWORD   dwCurrentDeadlockDetectionThreshold;
            
        //
        //  Make sure these values are updated together. We can only take the lock if FM
        //  is initialized. 
        //
        FmpAcquireMonitorLock ();

        dwCurrentDeadlockDetectionTimeout       = g_dwFmResourceDllDeadlockTimeout;
        fIsDeadlockDetectionEnabledCurrently    = g_fFmEnableResourceDllDeadlockDetection;
        dwCurrentDeadlockDetectionPeriod        = g_dwFmResourceDllDeadlockPeriod;
        dwCurrentDeadlockDetectionThreshold     = g_dwFmResourceDllDeadlockThreshold;
            
        g_fFmEnableResourceDllDeadlockDetection = fDeadlockDetectionEnabled;

        //
        //  Update the three values only if deadlock detection is enabled.
        //
        if ( g_fFmEnableResourceDllDeadlockDetection )
        {
            g_dwFmResourceDllDeadlockTimeout        = dwDeadlockDetectionTimeout;
            g_dwFmResourceDllDeadlockPeriod         = dwDeadlockDetectionPeriod;
            g_dwFmResourceDllDeadlockThreshold      = dwDeadlockDetectionThreshold;
        } else
        {
            //
            //  Change the timeout to 0 so that the next time deadlock detection is enabled,
            //  we will update all monitors with the new timeout.
            //
            g_dwFmResourceDllDeadlockTimeout        = 0;
        }

        if ( g_fFmEnableResourceDllDeadlockDetection != fIsDeadlockDetectionEnabledCurrently )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmCheckIsDeadlockDetectionEnabled: Deadlock detection %1!ws!\n",
                          (g_fFmEnableResourceDllDeadlockDetection ? L"enabled" : L"disabled"));
        }
        
        //
        //  Update the monitors with deadlock info if necessary. We will update the monitors
        //  only if the timeout has changed.
        //
        if ( ( dwCurrentDeadlockDetectionTimeout != g_dwFmResourceDllDeadlockTimeout ) &&
             ( g_fFmEnableResourceDllDeadlockDetection ) )
        {
            ClRtlLogPrint(LOG_NOISE, "[FM] FmCheckIsDeadlockDetectionEnabled: Deadlock timeout = %1!u! secs\n",
                          dwDeadlockDetectionTimeout);
            FmpCheckAndUpdateMonitorForDeadlockDetection( NULL );
        }

        //
        //  If deadlock detection is enabled, log if the deadlock threshold or deadlock period is
        //  changed.
        //
        if ( g_fFmEnableResourceDllDeadlockDetection )
        {
            if ( dwCurrentDeadlockDetectionPeriod != g_dwFmResourceDllDeadlockPeriod )
            {
                ClRtlLogPrint(LOG_NOISE, "[FM] FmCheckIsDeadlockDetectionEnabled: Deadlock period = %1!u! secs\n",
                              dwDeadlockDetectionPeriod);
            }
            if ( dwCurrentDeadlockDetectionThreshold != g_dwFmResourceDllDeadlockThreshold )
            {
                ClRtlLogPrint(LOG_NOISE, "[FM] FmCheckIsDeadlockDetectionEnabled: Deadlock threshold = %1!u!\n",
                              dwDeadlockDetectionThreshold);
            }
        }

        FmpReleaseMonitorLock ();
    }
    return;
}// FmCheckIsDeadlockDetectionEnabled

VOID
FmpCheckAndUpdateMonitorForDeadlockDetection(
    IN PRESMON  pMonitor    OPTIONAL
    )
/*++

Routine Description:

    Check if deadlock detection is enabled and if so update the monitor with the information.
    If no monitor information is supplied, then all monitors will be updated.

Arguments:

    pMonitor - The monitor to be updated.   OPTIONAL

Return Value:

	None.
	
--*/
{
    DWORD   dwStatus;

    if ( !FmpInitialized ) return;
    
    FmpAcquireMonitorLock ();

    //
    //  If deadlock detection is disabled, there is nothing else to do.
    //
    if ( g_fFmEnableResourceDllDeadlockDetection == FALSE )
    {
        goto FnExit;
    }

    //
    //  Update the monitors with the deadlock timeout. That API will also initialize the
    //  resmon deadlock monitoring subsystem if necessary.
    //
    if ( ARGUMENT_PRESENT ( pMonitor ) )
    {
        dwStatus = RmUpdateDeadlockDetectionParams ( pMonitor->Binding,
                                                     g_dwFmResourceDllDeadlockTimeout );
        
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpCheckAndUpdateMonitorForDeadlockDetection: Updated monitor with a deadlock timeout of %1!u! secs, status %2!u!\n",
                      g_dwFmResourceDllDeadlockTimeout, 
                      dwStatus);

        //
        //  If the monitor is successfully updated, save the value that we sent in. Note that
        //  this is done so that we know what value we used. The global can go out of sync
        //  with this saved value in many situations since our update policy is kind of
        //  lazy.
        //
        if ( dwStatus == ERROR_SUCCESS ) 
        {
            pMonitor->dwDeadlockTimeoutSecs = g_dwFmResourceDllDeadlockTimeout;
        }
    } else
    {
        PLIST_ENTRY pListEntry;
        
        pListEntry = g_leFmpMonitorListHead.Flink;

        while ( pListEntry != &g_leFmpMonitorListHead )
        {
            pMonitor = CONTAINING_RECORD ( pListEntry,
                                           RESMON,
                                           leMonitor );
            
            dwStatus = RmUpdateDeadlockDetectionParams ( pMonitor->Binding,
                                                         g_dwFmResourceDllDeadlockTimeout );

            //
            //  If the monitor is successfully updated, save the value that we sent in. Note that
            //  this is done so that we know what value we used. The global can go out of sync
            //  with this saved value in many situations since our update policy is kind of
            //  lazy.
            //
            if ( dwStatus == ERROR_SUCCESS ) 
            {
                pMonitor->dwDeadlockTimeoutSecs = g_dwFmResourceDllDeadlockTimeout;
            }

            ClRtlLogPrint(LOG_NOISE, "[FM] FmpCheckAndUpdateMonitorForDeadlockDetection: Updated monitor with a deadlock timeout of %1!u! secs, status %2!u!\n",
                          g_dwFmResourceDllDeadlockTimeout, 
                          dwStatus);
            pListEntry = pListEntry->Flink;        
        }// while
    }

FnExit:
    FmpReleaseMonitorLock ();

    return;
} // FmpCheckAndUpdateMonitorForDeadlockDetection

VOID
FmpHandleMonitorDeadlock(
    IN PRESMON  pMonitor
    )
/*++

Routine Description:

    Handle the deadlock of a monitor.

Arguments:

    pMonitor - The monitor that deadlocked.

Return Value:

	None.

Comments:

    This function is called only when FM positively knows the resmon deadlocked.
	
--*/
{
    DWORD   dwCurrentTickCount;
    
    FmpAcquireMonitorLock ();

    g_cResourceDllDeadlocks ++;

    ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpHandleMonitorDeadlock: Deadlock detected, count = %1!u!, last deadlock tick = %2!u!, deadlock timeout = %3!u! secs\n",
                  g_cResourceDllDeadlocks,
                  g_dwLastResourceDllDeadlockTick,
                  pMonitor->dwDeadlockTimeoutSecs);

    ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpHandleMonitorDeadlock: Deadlock threshold = %1!u!, deadlock period = %2!u! secs\n",
                  g_dwFmResourceDllDeadlockThreshold,
                  g_dwFmResourceDllDeadlockPeriod);

    //
    //  Reset the deadlock count if it has been very long since the last deadlock. Currently, we 
    //  see if the resource monitor has deadlocked g_dwLastResourceMonitorDeadlockThreshold + 1
    //  times within a time period of twice the time it would take to detect a deadlock during that
    //  period.
    //
    dwCurrentTickCount = GetTickCount ();

    if ( ( dwCurrentTickCount - g_dwLastResourceDllDeadlockTick ) >
          g_dwFmResourceDllDeadlockPeriod * 1000 )
    {
        g_cResourceDllDeadlocks = 1;
        g_dwLastResourceDllDeadlockTick = dwCurrentTickCount;
        ClRtlLogPrint(LOG_NOISE, "[FM] FmpHandleMonitorDeadlock: Resetting monitor deadlock count, deadlock tick = %1!u!\n",
                      dwCurrentTickCount);
    } 

    //
    //  We crossed the tolerable threshold. Give up.
    //
    if ( g_cResourceDllDeadlocks > g_dwFmResourceDllDeadlockThreshold )
    {
        MMStopClussvcClusnetHb ();
        ClRtlLogPrint(LOG_CRITICAL, "[FM] FmpHandleMonitorDeadlock: Inform MM to stop clusnet heartbeats\n");
    }
    
    FmpReleaseMonitorLock ();
    return;
}// FmpHandleMonitorDeadlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\resmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resmon.c

Abstract:

    Cluster resource manager interface routines for the resource monitor.

Author:

    Rod Gamache (rodga) 17-Apr-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"

#define LOG_MODULE RESMONF

//
// Global Data
//

//
// Local function prototypes
//



/////////////////////////////////////////////////////////////////////////////
//
// Resource Control Routines (via Resource Monitor)
//
/////////////////////////////////////////////////////////////////////////////

DWORD
FmpRmExceptionFilter(
    DWORD ExceptionCode
    )

/*++

Routine Description:

    Exception filter for calls to the Resource Monitor. These calls will
    often raise an exception if the RPC path to the Resource Monitor fails.

Arguments:

    ExceptionCode - the exception to process.

Returns:

    EXCEPTION_EXECUTE_HANDLE if the exception handler should handle this failure
    EXCEPTION_CONTINUE_SEARCH if the exception is a fatal exception and the handler 
    should not handle it.

--*/

{
    ClRtlLogPrint(LOG_UNUSUAL,
                 "[FM] FmpRmExceptionFilter: Unusual exception %1!u! occurred.\n",
                 ExceptionCode);
    return(I_RpcExceptionFilter(ExceptionCode));
} // FmpRmExceptionFilter



DWORD
FmpRmCreateResource(
    PFM_RESOURCE     Resource
    )

/*++

Routine Description:

    Add a resource to the list of resources managed by the resource monitor.

Arguments:

    Resource - The resource to add.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD       status;
    PRESMON     monitor;
    LPWSTR      debugPrefix;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmCreateResource: creating resource %1!ws! in %2!ws! resource monitor\n",
               OmObjectId(Resource),
               Resource->Flags & RESOURCE_SEPARATE_MONITOR ?
                L"separate" : L"shared");

    if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        if ( Resource->DebugPrefix != NULL ) {
            debugPrefix = Resource->DebugPrefix;
        } else {
            debugPrefix = Resource->Type->DebugPrefix;
        }
        Resource->Monitor = FmpCreateMonitor(debugPrefix, TRUE);
        if (Resource->Monitor == NULL) {
            return(GetLastError());
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        Resource->Monitor = FmpDefaultMonitor;
    }

    try {
        Resource->Id = RmCreateResource(Resource->Monitor->Binding,
                                        Resource->Type->DllName,
                                        OmObjectId(Resource->Type),
                                        OmObjectId(Resource),
                                        Resource->LooksAlivePollInterval,
                                        Resource->IsAlivePollInterval,
                                        (RM_NOTIFY_KEY)Resource,
                                        Resource->PendingTimeout,
                                        &status);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD code = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmCreateResource issued exception %1!u!\n", code);

        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
            monitor = Resource->Monitor;
#if 0
            CL_ASSERT( monitor->NotifyThread != NULL );
            CL_ASSERT( monitor->Process != NULL );

            // Terminate Thread call removed: ( monitor->NotifyThread, 1 );
            CloseHandle( monitor->NotifyThread );

            TerminateProcess( monitor->Process, 1 );
            LocalFree( monitor );
#endif
            FmpShutdownMonitor( monitor );
        }

        Resource->Monitor = NULL;
        return(code);
    }

    if (Resource->Id != 0) {
        Resource->Flags |= RESOURCE_CREATED;
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmCreateResource: created resource %1!ws!, resid %2!u!\n",
                   OmObjectId(Resource),
                   Resource->Id);

        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmCreateResource: unable to create resource %1!ws!\n",
               OmObjectId(Resource));
    //
    // Stop this resource monitor if it is a separate resource monitor.
    //
    if (Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        monitor = Resource->Monitor;
#if 0
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        // Terminate Thread call removed: ( monitor->NotifyThread, 1 );
        CloseHandle( monitor->NotifyThread );

        TerminateProcess( monitor->Process, 1 );
        LocalFree( monitor );
#endif
        FmpShutdownMonitor( monitor );
    }

    Resource->Monitor = NULL;
    return(status);

} // FmpRmCreateResource



DWORD
FmpRmOnlineResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine requests the Resource Monitor to bring a resource online.

Arguments:

    Resource - A pointer to the resource to bring online.

Comments :
    If this is the quorum resource, the exclusive quorum lock should be 
    held when this routine is called.  Else the quorum lock should be held
    in shared mode.  This routine release the lock.
    
Returns:

    ERROR_SUCCESS - if the request was successful.
    ERROR_IO_PENDING - if the request is pending.
    A Win32 error if the request failed.

--*/

{
    CLUSTER_RESOURCE_STATE  state;
    DWORD                   Status=ERROR_SUCCESS;
    DWORD                   retry = MmQuorumArbitrationTimeout * 4;  // Wait for quorum online for twice the arb timeout


#if 0
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] RmOnlineResource for <%1!ws!> called from %2!lx! and %3!lx!\n",
               OmObjectId( Resource ),
               callersAddress, callersCaller );
#endif
    if ( Resource->State > ClusterResourcePending ) {
        Status = ERROR_IO_PENDING;
        return(Status);
    }

    if ( Resource->State == ClusterResourceOnline ) {
        Status = ERROR_SUCCESS;
        return(Status);
    }


    CL_ASSERT((Resource->State == ClusterResourceOffline) ||
              (Resource->State == ClusterResourceFailed));

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmOnlineResource: bringing resource %1!ws! (resid %2!u!) online.\n",
               OmObjectId(Resource),
               Resource->Id);

    //if this is the quorum resource acquire the quolock
    // For registry replication to work, the resource should
    // not be brought online while the quorum resource is offline
    // what do we do for fixquorum mode

    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREONLINE);

    //SS:initialize state so that in case of a failure, a failed state is
    // propagated.
    state = ClusterResourceFailed;

CheckQuorumState:    

    //CL_ASSERT( (LONG)gdwQuoBlockingResources >= 0 );


    if (Resource->QuorumResource) {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);

    } else {
        DWORD     dwOldBlockingFlag;

        ACQUIRE_SHARED_LOCK(gQuoLock);

        // if it is not the quorum resource,
        // check the state of the quorum resource
        
        // check if the quorum resource is failed
        // we must exit from here and let the recovery for the
        // quorum resource to kick in
        if (gpQuoResource->State == ClusterResourceFailed)
        {
            Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //we dont halt, we will try online again at a later time
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            goto FnExit;

        }

        // check if the quorum resource is online,
        // if the quorum resource is marked as waiting and offlinepending,
        // it is actually online
        // if the quorum resource still needs to come online
        // release the lock and wait
        if (((gpQuoResource->State != ClusterResourceOnline) &&
              ((gpQuoResource->State != ClusterResourceOfflinePending) ||
               (!(gpQuoResource->Flags & RESOURCE_WAITING))))
            && !CsNoQuorum) 
        {
            // we release the lock here since the quorum resource
            // state transition from pending needs to acquire the lock
            // In general it is a bad idea to do a wait holding locks
            RELEASE_LOCK(gQuoLock);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOnlineResource: release quolock/group lock and wait on ghQuoOnlineEvent\r\n");
            Status = WaitForSingleObject(ghQuoOnlineEvent, 500);
            if ( Status == WAIT_OBJECT_0 ) {
                // If we're going to retry - make sure we wait a little.
                Sleep( 500 );
            }
            if ( retry-- ) {
                goto CheckQuorumState;
            }
#if DBG
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //we dont halt, we will try online again at a later time
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //CsInconsistencyHalt(ERROR_INVALID_STATE);
        }

        //
        // assume that we'll be pending... mark the resource as having
        // bumped the QuoBlockResource count.
        //
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOnlineResource: called InterlockedIncrement on gdwQuoBlockingResources for resource %1!ws!\n",
                OmObjectId(Resource));

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 1 );
        CL_ASSERT( dwOldBlockingFlag == 0 );
                    
        InterlockedIncrement(&gdwQuoBlockingResources);

        //
        // everything is now fine on the local node... if any other
        // component (CP) needs to synchronize with the quorum resource, then
        // should acquire the shared lock on the quorum node as part of
        // their operation. If that fails, then they should assume the quorum
        // resource moved, and they should retry.
        //
    }

    // By now we have either the shared or the exclusive lock on the
    // quorum resource.
    // If we have the shared lock then the quorum resource is online(somewhere).
    // Unlesss there is a failure, it should not go offline.



    Status = ERROR_SUCCESS;
    if (Resource->QuorumResource) {
        Status = FmpRmArbitrateResource( Resource );
    }
    if (Status == ERROR_SUCCESS) {
        Status = RmOnlineResource( Resource->Id, 
                                   (LPDWORD)&state  // cast to quiet win64 warning
                                 );
        if (Resource->QuorumResource && Status != ERROR_SUCCESS) {
            MMSetQuorumOwner( MM_INVALID_NODE , /* Block = */ FALSE, NULL );
        }
    }
        
    FmpCallResourceNotifyCb(Resource, state);

    //SS: the synchronous state propagation must happen when it goes offline
    FmpPropagateResourceState( Resource, state );

    //
    // Cleanup for the non-quorum resource case.
    //
    if ( !Resource->QuorumResource &&
         Resource->State < ClusterResourcePending ) {
        DWORD     dwOldBlockingFlag;

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            //
            // If the Transition Thread processed the request, then we can't
            // perform the decrement.
            //
            ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpRmOnlineResource: InterlockedDecrement on gdwQuoBlockingResources for resource %1!ws!\n",
                    OmObjectId(Resource));
                    
            InterlockedDecrement(&gdwQuoBlockingResources);
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOnlineResource: RmOnlineResource Failed. Resource %1!ws!, status %2!u!\n",
            OmObjectId(Resource),
            Status);
    }

    //if RmOnlineResource is successful, do the post processing
    if ( Resource->State == ClusterResourceOnline ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: %1!ws! is now online\n",
                   OmObjectId(Resource));
        //if this is the quorum resource and it goes into online state
        //immediately, wake other threads
        if (Resource->QuorumResource)
            SetEvent(ghQuoOnlineEvent);

    } else if ( Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: Resource %1!ws! pending\n",
                   OmObjectId(Resource));
                //SS: what should we tell the callbacks
                //FmpNotifyResourceCb(Resource,??);
                //will they eventually get called if so how ?
        if (Resource->QuorumResource)
        {
            //the quorum resource is coming online, unsignal the event so that 
            //all threads that need quorum resource to be online will block
            ResetEvent(ghQuoOnlineEvent);
        }
        Status  = ERROR_IO_PENDING;
    } else {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOnlineResource: Failed. Resource %1!ws!, state %2!u!\n",
                   OmObjectId(Resource),
                   Resource->State);

        //
        //  If the server died, then don't post any failure notifications since the resource monitor
        //  crash detection thread will handle the failure.
        //
        if ( Status != RPC_S_SERVER_UNAVAILABLE )
        {
            //
            // rjain: for a synchronous resource we must post RESOURCE_FAILED event 
            // so thatfailback policies are correctly followed
            // Also pretend that the old state to be online to actually force the 
            // restart behaviour. See: FmpProcessResourceEvents.
            //
            OmReferenceObject(Resource);
            FmpPostWorkItem(FM_EVENT_RES_RESOURCE_FAILED,
                            Resource,
                            ClusterResourceOnline);    
            Status = ERROR_RESMON_ONLINE_FAILED;  
        }
    }

FnExit:
    RELEASE_LOCK(gQuoLock);
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmOnlineResource: Returning. Resource %1!ws!, state %2!u!, status %3!u!.\n",
               OmObjectId(Resource),
               Resource->State,
               Status);
    return (Status);

} // FmpRmOnlineResource



VOID
FmpRmTerminateResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Terminates (immediately) a resource.

Arguments:

    Resource - A pointer to the resource to terminate.

Returns:

    None.

--*/

{
    DWORD   dwOldBlockingFlag;


    //notify callbacks that need preprocessing before a resource is
    //brought offline-call this here since all resources may not go
    //thru the offline pending transition
    //SS - what if the resource never even goes to offline
    //pending state - then should we renotify the callbacks that it
    //is still online?
    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);

    //
    // Try to terminate the resource.
    //
    try {
        if (Resource->QuorumResource) {
            MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ FALSE, NULL ); 
        }
        RmTerminateResource(Resource->Id);

        // if FmpRmterminate was called for a failed resource, mark  
        // the resource as Failed and not Offline.
        if (Resource->State == ClusterResourceFailed)
        {
            FmpCallResourceNotifyCb(Resource, ClusterResourceFailed);
            FmpPropagateResourceState( Resource, ClusterResourceFailed );
        }

        else
        {
            FmpCallResourceNotifyCb(Resource, ClusterResourceOffline);
            FmpPropagateResourceState( Resource, ClusterResourceOffline );
        }
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        DWORD code = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmTerminateResource issued exception %1!u!\n", code);

        return;
    }

    //if terminate was called during a pending state, this resource may be
    //blocking the quorum resource, decrement the blocking count
    dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );

    if ( dwOldBlockingFlag ) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmTerminateResource: InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
                OmObjectId(Resource));
        InterlockedDecrement(&gdwQuoBlockingResources);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[FM] RmTerminateResource: %1!ws! is now offline\n",
               OmObjectId(Resource));

    return;

} // FmpRmTerminateResource



DWORD
FmpRmOfflineResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Calls the Resource Monitor to take a resource offline.

Arguments:

    Resource - A pointer to the resource to terminate.

Returns:

    ERROR_SUCCESS if the request is successful.
    ERROR_IO_PENDING if the request is pending.
    Win32 error code on failure.

--*/

{
    CLUSTER_RESOURCE_STATE  state;
    DWORD                   status;
    DWORD                   retry = MmQuorumArbitrationTimeout * 4;  // Wait for quorum online for twice the arb timeout;

#if DBG
    PLIST_ENTRY listEntry;
#endif

    if ( Resource->State > ClusterResourcePending ) {
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpRmOfflineResource: pending condition\n");
        return(ERROR_IO_PENDING);
    }

    CL_ASSERT(Resource->State != ClusterResourceOffline);

#if DBG
    // everything else in the same group must be offline if this is the
    // quorum resource
    if ( Resource->QuorumResource ) {
        PFM_GROUP group = Resource->Group;
        PFM_RESOURCE resource;

        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage );
            if ( (Resource != resource) &&
                 (resource->State != ClusterResourceOffline) &&
                 (resource->State != ClusterResourceFailed) &&
                 (resource->State != ClusterResourceOfflinePending) ) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] RmOfflineResource: resource <%1!ws!> not offline when the quorum resource was shutting down.\n",
                           OmObjectId(resource));
                CsInconsistencyHalt(ERROR_INVALID_STATE);
            }
        }
    } else {
        // this is not the quorum resource... but if the quorum resource is in
        // this group, it must not be offline!
        PFM_GROUP group = Resource->Group;
        PFM_RESOURCE resource;

        for ( listEntry = group->Contains.Flink;
              listEntry != &(group->Contains);
              listEntry = listEntry->Flink ) {

            resource = CONTAINING_RECORD(listEntry,
                                         FM_RESOURCE,
                                         ContainsLinkage );
            if ( (resource->QuorumResource) &&
                 ((resource->State == ClusterResourceOffline) ||
                 (resource->State == ClusterResourceFailed) ||
                 ((resource->State == ClusterResourceOfflinePending) &&
                  (!(resource->Flags & RESOURCE_WAITING))))) {
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] RmOfflineResource: quorum resource <%1!ws!> offline when resource <%2!ws!> was shutting down.\n",
                           OmObjectId(resource),
                           OmObjectId(Resource));
                CsInconsistencyHalt(ERROR_INVALID_STATE);
            }
        }
    }
#endif

    state = ClusterResourceFailed;

CheckQuorumState:

    //if this is the quorum resource acquire the quolock
    // For registry replication to work, the resource should
    // not be brought online while the quorum resource is offline
    // what do we do for fixquorum mode
    if (Resource->QuorumResource) {
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
    } else {
        ACQUIRE_SHARED_LOCK(gQuoLock);
    }

    //if it is not the quorum resource, check the state of the quorum resource
    if (!Resource->QuorumResource)
    {
        DWORD     dwOldBlockingFlag;

        // check if the quorum resource is failed
        // we must exit from here and allow the recovery for the
        // quorum resource to kick in, which can only happen when
        // the group lock is released
        if (gpQuoResource->State == ClusterResourceFailed)
        {
            status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            RELEASE_LOCK(gQuoLock);
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(status);

        }

        // check if the quorum resource is online,
        // if the quorum resource is marked as waiting and offlinepending,
        // it is actually online.
        // if the quorum resource still needs to come online,
        // release the lock and wait
        if (((gpQuoResource->State != ClusterResourceOnline) &&
              ((gpQuoResource->State != ClusterResourceOfflinePending) ||
                (!(gpQuoResource->Flags & RESOURCE_WAITING))))
            && !CsNoQuorum) 
        {
            RELEASE_LOCK(gQuoLock);
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOfflineResource: release quolock/group lock and wait on ghQuoOnlineEvent\r\n");
            WaitForSingleObject(ghQuoOnlineEvent, 500);
            if ( retry-- ) {
                Sleep(500);
                goto CheckQuorumState;
            }
#if DBG
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            CL_LOGFAILURE(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            // Should we halt? What about the pre-online notification above?
            FmpCallResourceNotifyCb(Resource, state);
            FmpPropagateResourceState( Resource, state );
            return(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            //CsInconsistencyHalt(ERROR_INVALID_STATE);
            
        }

        //
        // assume that we'll be pending... mark the resource as having
        // bumped the QuoBlockResource count.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmOfflineResource: InterlockedIncrement on gdwQuoBlockingResources for resource %1!ws!\n",
            OmObjectId(Resource));

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 1 );
        CL_ASSERT( dwOldBlockingFlag == 0 );
                    
        InterlockedIncrement(&gdwQuoBlockingResources);

    }
    else
    {
        DWORD       dwNumBlockingResources;

        //allow resources about 30 seconds to finish a pending 
        //operation
        retry = 60;
        
        // This is for a quorum resource.

CheckPendingResources:        

        // this is the quorum resource, wait for other resources
        // to get out of their pending states
        // new resources are not allowed to queue since the quorum 
        // lock is held exclusively

        dwNumBlockingResources =
            InterlockedCompareExchange( &gdwQuoBlockingResources, 0, 0 );
                    
        if (dwNumBlockingResources)            
        {
            ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpRmOfflineResource: Quorum resource waiting to be brought offline-sleep.BlckingRes=%1!u!\r\n",
                       dwNumBlockingResources);
            //sleep for 500 msec
            Sleep(500);
            if ( retry-- ) {
                goto CheckPendingResources;
            }
            //if some resources are still pending, go ahead and offline
            //the quorum, the checkpointing code will simply retry when 
            //it finds that the quorum resource is not available
#if 0            
            if ( IsDebuggerPresent() ) {
                DbgBreakPoint();
            }
#endif
            ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpRmOfflineResource: Quorum resource is being brought offline despite %1!u! pending resources...\r\n",
                      dwNumBlockingResources);

        }
    }

    //notify callbacks that need preprocessing before a resource is
    //brought offline-call this here since all resources may not go
    //thru the offline pending transition
    //SS - what if the resource never even goes to offline
    //pending state - then should we renotify the callbacks that it
    //is still online?
    state = ClusterResourceOffline;

    OmNotifyCb(Resource, NOTIFY_RESOURCE_PREOFFLINE);
    if (Resource->QuorumResource) {
        MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ TRUE, NULL );
    }
    status = RmOfflineResource( Resource->Id, 
                                (LPDWORD)&state // cast to quiet win64 warning
                              );

    //
    // Cleanup for the non-quorum resource case
    // if the resource has gone offline, decrement the count
    //
    if ( !Resource->QuorumResource &&
         state < ClusterResourcePending ) {
        DWORD     dwOldBlockingFlag;

        dwOldBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );
        if ( dwOldBlockingFlag ) {
            //
            // If the Transition Thread processed the request, then we can't
            // perform the decrement.
            //
            ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpRmOfflineResource: InterlockedDecrement on gdwQuoBlockingResources for resource %1!ws!\n",
                    OmObjectId(Resource));
                    
            InterlockedDecrement(&gdwQuoBlockingResources);
        }
    }

    if (status == ERROR_SUCCESS)
    {
        //
        // If the new state is pending, then we must wait.
        //
        if ( state == ClusterResourceOffline ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpRmOfflineResource: %1!ws! is now offline\n",
                       OmObjectId(Resource));
        } else if ( state == ClusterResourceOfflinePending ) {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpRmOfflineResource: %1!ws! offline pending\n",
                       OmObjectId(Resource));
            status = ERROR_IO_PENDING;
        }
    }
    else
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmOfflineResource: RmOffline() for %1!ws! returned error %2!u!\r\n",
                   OmObjectId(Resource), status);
    }

    FmpCallResourceNotifyCb(Resource, state);
    FmpPropagateResourceState( Resource, state );
    RELEASE_LOCK(gQuoLock);

    return(status);

} // FmpRmOfflineResource



DWORD
FmpRmCloseResource(
    PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Removes a resource from those being managed by the resource monitor.

Arguments:

    Resource - The resource to remove.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status;
    PRESMON monitor;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_SUCCESS);
    }

    monitor = Resource->Monitor;
    Resource->Monitor = NULL;

    if ( Resource->QuorumResource ) {
        RmReleaseResource( Resource->Id );
    }

    try {
        RmCloseResource(&Resource->Id);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,"[FM] RmDestroyResource issued exception %1!u!\n", status);

    }

    if ( monitor &&
         Resource->Flags & RESOURCE_SEPARATE_MONITOR) {
        //
        // Shutdown the resource monitor as well.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Shutting down separate resource monitor!\n");
        FmpShutdownMonitor(monitor);
    }

    Resource->Id = 0;

    return(ERROR_SUCCESS);

} // FmpRmCloseResource



DWORD
FmpRmArbitrateResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Arbitrate for the given resource.

Arguments:

    Resource - The resource to arbitrate.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }
    try {
        if (Resource->QuorumResource) {
            status = MMSetQuorumOwner( NmGetNodeId(NmLocalNode), /* Block = */ TRUE, NULL ); 
        }
        if (status == ERROR_SUCCESS) {
            status = RmArbitrateResource(Resource->Id);
            if (status != ERROR_SUCCESS) {
                if (Resource->QuorumResource) {
                    MMSetQuorumOwner( MM_INVALID_NODE , /* Block = */ FALSE, NULL );
                }
            }
        }
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmArbitrateResource issued exception %1!u!\n",
                   status);

    }

    return(status);

} // FmpRmArbitrateResource



DWORD
FmpRmReleaseResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Release arbitration on a given resource.

Arguments:

    Resource - The resource to release.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS;

    if (Resource->Id == 0) {
        //
        // This resource was never fully created.
        //
        return(ERROR_RESOURCE_NOT_AVAILABLE);
    }
    try {
        status = RmReleaseResource(Resource->Id);
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {

        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmReleaseResource issued exception %1!u!\n",
                   status);

    }

    return(status);

} // FmpRmReleaseResource



DWORD
FmpRmFailResource(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    Fail a given resource.

Arguments:

    Resource - The resource to fail.

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{

    if (Resource->QuorumResource) {
        MMSetQuorumOwner( MM_INVALID_NODE, /* Block = */ FALSE, NULL ); 
    }
    return(RmFailResource(Resource->Id));

} // FmpRmFailResource

DWORD FmpRmLoadResTypeDll(
    IN PFM_RESTYPE  pResType
)
{
    PRESMON     monitor;
    DWORD       dwStatus;
    LPWSTR      pszDebugPrefix;

    
    // Read the DebugControlFunction registry value.
    //

    if ( pResType->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        if ( pResType->DebugPrefix != NULL ) {
            pszDebugPrefix = pResType->DebugPrefix;
        } else {
            pszDebugPrefix = pResType->DebugPrefix;
        }
        monitor = FmpCreateMonitor(pszDebugPrefix, TRUE);
        if (monitor == NULL) {
            dwStatus = GetLastError();
            goto FnExit;
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        monitor = FmpDefaultMonitor;
    }


    dwStatus = RmLoadResourceTypeDll(monitor->Binding, OmObjectId(pResType), 
                    pResType->DllName);


    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmLoadResourceTypeDll call failed %1!u!\n",
                   dwStatus);
    }

    if ( pResType->Flags & RESTYPE_DEBUG_CONTROL_FUNC )
    {
        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        FmpShutdownMonitor( monitor );

    }


FnExit:                    
    return(dwStatus);
                    
}



DWORD
FmpRmChangeResourceParams(
    IN PFM_RESOURCE Resource
    )

/*++

Routine Description:

    Tell the resource monitor to change parameters for the given resource.

Arguments:

    Resource - The resource to change parameters.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpRmChangeResourceParams for resource <%1!ws!> called...\n",
               OmObjectId(Resource));

    return(RmChangeResourceParams(
                    Resource->Id,
                    Resource->LooksAlivePollInterval,
                    Resource->IsAlivePollInterval,
                    Resource->PendingTimeout ) );

} // FmpRmChangeResourceParams



DWORD
FmpRmResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    Resource - Supplies the resource to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    CL_ASSERT( Resource->Group != NULL );
    //
    // Handle any requests that must be done without locks helds.
    //
    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_GET_NAME:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectName( Resource ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Resource ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Resource ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_GET_ID:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectId( Resource ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Resource ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Resource ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_GET_RESOURCE_TYPE:
            if ( (Resource->Monitor == NULL) ||
                 (OmObjectId( Resource->Type ) == NULL) ) {
                return(ERROR_NOT_READY);
            }
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Resource->Type ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Resource->Type ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
            return(status);

        case CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT:
        case CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT:
            {
                LPWSTR RegistryKey;
                DWORD LastChar;

                //
                // Validate the input buffer
                //
                RegistryKey = (LPWSTR)InBuffer;
                LastChar = (InBufferSize/sizeof(WCHAR)) - 1;
                //
                // If the length of the input buffer is zero, or not a integral
                // number of WCHARs, or the last character is not NULL, the
                // request is invalid.
                //
                if ((InBufferSize < sizeof(WCHAR)) ||
                    ((InBufferSize % sizeof(WCHAR)) != 0) ||
		    (RegistryKey == NULL) ||
                    (RegistryKey[LastChar] != L'\0')) {
                    return(ERROR_INVALID_PARAMETER);
                }

                //
                // If we are not the owner of this resource, don't let the set
                // happen.
                //
                if (Resource->Group->OwnerNode != NmLocalNode) {
                    return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
                }

                //
                // Call the checkpoint manager to perform the change.
                //
                if (ControlCode == CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT) {
                    status = CpAddRegistryCheckpoint(Resource, RegistryKey);
                } else {
                    status = CpDeleteRegistryCheckpoint(Resource, RegistryKey);
                }
            }
            *BytesReturned = 0;
            return(status);

        case CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT:
        case CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT:
            {
                //
                // If we are not the owner of this resource, don't let the set
                // happen.
                //
                if (Resource->Group->OwnerNode != NmLocalNode) {
                    return(ERROR_HOST_NODE_NOT_RESOURCE_OWNER);
                }

                //
                // Call the checkpoint manager to perform the change.
                //
                if (ControlCode == CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT) {
                    status = CpckAddCryptoCheckpoint(Resource, InBuffer, InBufferSize);
                } else {
                    status = CpckDeleteCryptoCheckpoint(Resource, InBuffer, InBufferSize);
                }
            }
            *BytesReturned = 0;
            return(status);

        case CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS:
            //
            // Call the checkpoint manager to retrieve the list of checkpoints
            //
            status = CpGetRegistryCheckpoints(Resource,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required);
            return(status);

        case CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS:
            //
            // Call the checkpoint manager to retrieve the list of checkpoints
            //
            status = CpckGetCryptoCheckpoints(Resource,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required);
            return(status);

        case CLUSCTL_RESOURCE_UPGRADE_DLL:
            status = FmpUpgradeResourceDLL(Resource,
                                           ( LPWSTR ) InBuffer);
            return(status);

        case CLUSCTL_RESOURCE_INITIALIZE:   
            //
            //  Attempt to initialize the resource if it is not already initialized and return 
            //  the initialization status to caller.
            //
            FmpAcquireLocalResourceLock( Resource );

            if ( Resource->Monitor == NULL )
            {
                status = FmpInitializeResource( Resource, TRUE );
            } else 
            {
                status = ERROR_SUCCESS;
            }

            FmpReleaseLocalResourceLock( Resource );

            return ( status );

        default:
            break;

    }


    OmReferenceObject( Resource );

    FmpAcquireLocalResourceLock( Resource );

    //if the resource has been marked for delete, then fail this call
    if (!IS_VALID_FM_RESOURCE(Resource))
    {
        status = ERROR_RESOURCE_NOT_AVAILABLE;
        FmpReleaseLocalResourceLock( Resource );
        goto FnExit;
    }

    if ( Resource->Monitor == NULL ) {
        status = FmpInitializeResource( Resource, TRUE );
        if ( status != ERROR_SUCCESS ) {
            FmpReleaseLocalResourceLock( Resource );
            goto FnExit;
        }
    }
    FmpReleaseLocalResourceLock( Resource );

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }        
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;
      
    try {
        status = RmResourceControl(Resource->Id,
                                   ControlCode,
                                   InBuffer,
                                   InBufferSize,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required
                                   );
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {
        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmResourceControl issued exception %1!u!\n",
                   status);
    }

    if ( ( status != ERROR_SUCCESS ) && 
         ( status != ERROR_MORE_DATA ) &&
         ( status != ERROR_INVALID_FUNCTION ) )
    {
    	ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpRmResourceControl: RmResourceControl returned %1!u! for resource %2!ws!, resid=%3!u!...\n",
                   status,
                   OmObjectId(Resource),
                   Resource->Id);
    }
	
    //for core resource we may need special handling
    if ((status == ERROR_SUCCESS) || (status == ERROR_RESOURCE_PROPERTIES_STORED))
    {
        DWORD   dwPostProcessStatus;
        
        dwPostProcessStatus = FmpPostProcessResourceControl( Resource,
                                                             ControlCode,
                                                             InBuffer, 
                                                             InBufferSize,
                                                             OutBuffer,
                                                             OutBufferSize,
                                                             BytesReturned,
                                                             Required );
        if ( dwPostProcessStatus != ERROR_SUCCESS ) status = dwPostProcessStatus;
    }
    
    if ( ((status == ERROR_SUCCESS) ||
          (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {

        //
        // We cannot just broadcast a cluster wide event... which is what
        // we want to do. Unfortunately, this code path can be activated
        // from within a GUM call, and we cannot call GUM back until we
        // have dispatched the current event.
        //

        //
        // Reference the resource object to keep it around while we
        // perform the post notification. The dereference must occur
        // in the post routine after the event posting.
        //
        OmReferenceObject( Resource );

        FmpPostWorkItem( FM_EVENT_RESOURCE_PROPERTY_CHANGE,
                         Resource,
                         0 );
    }

FnExit:
    OmDereferenceObject( Resource );
    //FmpReleaseLocalResourceLock( Resource );
    return(status);

} // FmpRmResourceControl


DWORD
FmpRmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type to be
        controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD       status;
    PRESMON     monitor;
    PFM_RESTYPE type = NULL;
    LPWSTR      debugPrefix;
    DWORD   Dummy;
    DWORD   dwTmpBytesReturned;
    DWORD   dwTmpBytesRequired;

    
    //
    // Find the resource type structure associated with this resource type name
    //
    OmEnumObjects( ObjectTypeResType,
                   FmpReturnResourceType,
                   &type,
                   (PVOID)ResourceTypeName );
    if ( type == NULL ) {
        return(ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND);
    }

    //
    // Read the DebugControlFunction registry value.
    //

    if ( type->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        if ( type->DebugPrefix != NULL ) {
            debugPrefix = type->DebugPrefix;
        } else {
            debugPrefix = type->DebugPrefix;
        }
        monitor = FmpCreateMonitor(debugPrefix, TRUE);
        if (monitor == NULL) {
            status = GetLastError();
            goto FnExit;
        }
    } else {
        CL_ASSERT(FmpDefaultMonitor != NULL);
        monitor = FmpDefaultMonitor;
    }

    //to take care of the output reference pointer which cannot be NULL.
    if (!OutBuffer)
    {
       OutBuffer = (PUCHAR)&Dummy;
       OutBufferSize = 0;
    }        
    if (!BytesReturned)
        BytesReturned = &dwTmpBytesReturned;
    if (!Required)
        Required = &dwTmpBytesRequired;



    try {
        status = RmResourceTypeControl(monitor->Binding,
                                       ResourceTypeName,
                                       type->DllName,
                                       ControlCode,
                                       InBuffer,
                                       InBufferSize,
                                       OutBuffer,
                                       OutBufferSize,
                                       BytesReturned,
                                       Required
                                       );
    }
    except( FmpRmExceptionFilter(GetExceptionCode()) ) {
        status = GetExceptionCode();

        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RmResourceTypeControl issued exception %1!u!\n",
                   status);
    }

    if ( type->Flags & RESTYPE_DEBUG_CONTROL_FUNC ) {
        //
        // Stop this resource monitor if it is a separate resource monitor.
        //
        CL_ASSERT( monitor->NotifyThread != NULL );
        CL_ASSERT( monitor->Process != NULL );

        FmpShutdownMonitor( monitor );

    }

    //
    // If we successfully processed this request then re-fetch any changed
    // data items.
    //
    if ( (status == ERROR_SUCCESS ||
         (status == ERROR_RESOURCE_PROPERTIES_STORED)) &&
         (ControlCode & CLCTL_MODIFY_MASK) ) {
        FmpHandleResourceTypeControl( type,
                                      ControlCode,
                                      InBuffer, 
                                      InBufferSize,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      Required );
        // ignore status
    }

FnExit:
    OmDereferenceObject(type);

    return(status);

} // FmpRmResourceTypeControl




/****
@func       BOOL | FmpPostProcessResourceControl| For core resource, if the control
            code is handled successfully by the resource dll, the fm handles
            any special handling in this function.

@parm       PFM_RESOURCE | Resource | Supplies the resource to be controlled.

@parm       DWORD| ControlCode | Supplies the control code that defines the
            structure and action of the resource control.
            Values of ControlCode between 0 and 0x10000000 are reserved
            for future definition and use by Microsoft. All other values
            are available for use by ISVs

@parm       PUCHAR | InBuffer | Supplies a pointer to the input buffer to be passed
            to the resource.

@parm       DWORD | InBufferSize | Supplies the size, in bytes, of the data pointed
            to by lpInBuffer..

@parm       PUCHAR | OutBuffer | Supplies a pointer to the output buffer to be
            filled in by the resource..

@parm       DWORD | OutBufferSize | Supplies the size, in bytes, of the available
            space pointed to by lpOutBuffer.

@parm       LPDWORD | BytesReturned | Returns the number of bytes of lpOutBuffer
            actually filled in by the resource..

@parm       LPDWORD | Required | The number of bytes required if OutBuffer is not big enough.


@comm       Called only for core resources.

@xref
****/

DWORD
FmpPostProcessResourceControl(
    IN PFM_RESOURCE Resource,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
{
    DWORD dwStatus=ERROR_SUCCESS;
    
    //handle cluster name change
    switch(ControlCode)
    {
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        {
            LPWSTR      pszClusterName=NULL;
            PFM_RESTYPE pResType;    

            //need to check this only for core resources
            if (Resource->ExFlags & CLUS_FLAG_CORE)
            {
                pResType = Resource->Type;
                //SS: chk follow the name
                if (!lstrcmpiW(OmObjectId(pResType), CLUS_RESTYPE_NAME_NETNAME))
                {
                    dwStatus = FmNetNameParseProperties(InBuffer, InBufferSize,
                        &pszClusterName);
                    if (dwStatus == ERROR_SUCCESS && pszClusterName)
                    {
                        dwStatus = FmpRegUpdateClusterName(pszClusterName);
                        LocalFree(pszClusterName);
                    } else if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                        dwStatus = ERROR_SUCCESS;
                    }
                }
            }
            break;
        }            

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        {
            LPDWORD pdwCharacteristics = ( LPDWORD ) OutBuffer;
            //
            // If the resource has dependencies, remove the quorum capable flag
            //
            if ( ( pdwCharacteristics != NULL ) && 
                 ( ( *BytesReturned ) == sizeof ( DWORD ) ) &&
                 ( ( *pdwCharacteristics ) & ( CLUS_CHAR_QUORUM ) ) )
            {
                FmpAcquireLocalResourceLock( Resource );
                //
                // The resource says it is quorum capable, however it has a dependency so it 
                // cant be a quorum.
                //
                if ( !IsListEmpty( &Resource->DependsOn ) ) 
                {
                    //
                    // We will mask the quorum capable bit
                    //
                    *pdwCharacteristics = ( *pdwCharacteristics ) & ( ~CLUS_CHAR_QUORUM );
                }
                FmpReleaseLocalResourceLock( Resource );
            }
            break;
        }
        
        default:
            break;
    }        
    
    return(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\restype.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    restype.c

Abstract:

    Public interfaces for managing the resource types in a cluster

Author:

    John Vert (jvert) 11-Jan-1996

Revision History:

--*/
#include "fmp.h"


//
// Data local to this module
//




DWORD
FmpInitResourceTypes(
    VOID
    )

/*++

 Routine Description:

    Initializes the resource type database. Process the ResourceType
    key in the registry. Each ResourceType found is added to the
    resource type database.

 Arguments:

    None.

 Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD       status;
    DWORD       keyIndex;
    LPWSTR      resTypeName = NULL;
    DWORD       resTypeNameMaxSize = 0;

    ClRtlLogPrint(LOG_NOISE,"[FM] processing resource types.\n");


    //
    // Enumerate all Resource Types.
    //

    for ( keyIndex = 0; ; keyIndex++ ) {
        status = FmpRegEnumerateKey( DmResourceTypesKey,
                                     keyIndex,
                                     &resTypeName,
                                     &resTypeNameMaxSize
                                    );

        if ( status == ERROR_SUCCESS ) {
            FmpCreateResType( resTypeName);
            continue;
        }

        if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
        } else {
            ClRtlLogPrint(LOG_NOISE,"[FM] FmpInitResourceTypes: FmpRegEnumerateKey error %1!u!\n", status);
        }

        break;
    }
    if (resTypeName) LocalFree(resTypeName);
    return(status);

} // FmpInitResourceTypes



/****
@func       DWORD | FmpFixupResourceTypesPhase1| This fixes up the possible nodes supporting
            a all the resource types.  It is called on join or form.

@parm       IN BOOL | bJoin | Set to TRUE on a join.

@parm       IN BOOL | bLocalNodeVersionChanged | Set to TRUE if the local node
            just upgraded.

@parm       IN PCLUSTERVERSIONINFO | pClusterVersionInfo | A pointer to the 
            cluster version info.

@comm       This routine checks all the resource types in a system and fixes
            their possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.
            If this is on an upgrade, the version change control code is sent
            to the dll as well.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD
FmpFixupResourceTypesPhase1(
    IN BOOL    bJoin,
    IN BOOL    bNmLocalNodeVersionChanged,
    IN PCLUSTERVERSIONINFO  pClusterVersionInfo
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;
    BOOL        pbBoolInfo[2];
    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase1 Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    pbBoolInfo[0]=bNmLocalNodeVersionChanged;
    if(bJoin)
       pbBoolInfo[1]=FALSE;
    else
        pbBoolInfo[1]=TRUE;
    
    
    OmEnumObjects( ObjectTypeResType,
                   FmpFixupPossibleNodesForResTypeCb,
                   pbBoolInfo,
                   pClusterVersionInfo);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase1 Exit\r\n");

    return(dwStatus);

} // FmpFixupResourceTypes


/****
@func       DWORD | FmpFixupResourceTypesPhase2| This fixes up the possible nodes supporting
            a all the resource types.  It is called on join or form.

@parm       IN BOOL | bJoin | Set to TRUE on a join.

@parm       IN BOOL | bLocalNodeVersionChanged | Set to TRUE if the local node
            just upgraded.

@parm       IN PCLUSTERVERSIONINFO | pClusterVersionInfo | A pointer to the 
            cluster version info.

@comm       If this is on an upgrade, the version change control code is sent
            to the dll as well.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f DmSwitchToNewQuorumLog>
****/
DWORD
FmpFixupResourceTypesPhase2(
    IN BOOL    bJoin,
    IN BOOL    bLocalNodeVersionChanged,
    IN PCLUSTERVERSIONINFO  pClusterVersionInfo
    )
{
    DWORD       dwStatus=ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase2 Entry.\n");

    //
    // Fix up all resources's possible node list information
    //
    OmEnumObjects( ObjectTypeResType,
                   FmpFixupResTypePhase2Cb,
                   &bJoin,
                   &bLocalNodeVersionChanged);


    ClRtlLogPrint(LOG_NOISE,"[FM] FmpFixupResourceTypesPhase Exit\r\n");

    return(dwStatus);

} // FmpFixupResourceTypes

/****
@func       BOOL | FmpFixupPossibleNodesForResTypeCb| This is the enumeration
            callback for every resource type to fix the possible node
            information related with it.

@parm       IN PVOID | pContext1 | Whether the local node has just upgraded.
@parm       IN PVOID | pContext2 | A pointer to the cluster version info.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine checks a given resource types in a system and fixes
            its possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.

@rdesc      Returns TRUE to continue enumeration, else returns FALSE.

@xref       <f FmpFixupResourceTypes>
****/
BOOL
FmpFixupPossibleNodesForResTypeCb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
    )
{

    PLIST_ENTRY     pListEntry;
    BOOL            bLocalNodeFound = FALSE;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    BOOL            bLocalNodeVersionChanged = FALSE;
    BOOL            bForm;
    PCLUSTERVERSIONINFO pClusterVersionInfo;
    DWORD           dwStatus;
    PCLUS_STARTING_PARAMS pClusStartingParams = NULL;
    eClusterInstallState eState;
    PBOOL            pbBoolInfo;
    
    //get the context parameters
    pbBoolInfo=(PBOOL)pContext1;

    bLocalNodeVersionChanged = pbBoolInfo[0];
    bForm = pbBoolInfo[1];
    
    pClusterVersionInfo = (PCLUSTERVERSIONINFO)pContext2;
    
    // safeguard against the list being modified while we are
    // traversing it
    
    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = &pResType->PossibleNodeList;

    for (pListEntry = pListEntry->Flink; pListEntry != &pResType->PossibleNodeList;
        pListEntry = pListEntry->Flink)
    {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);

        if (pResTypePosEntry->PossibleNode == NmLocalNode)
        {            
            bLocalNodeFound = TRUE;       
        }

    }

    RELEASE_LOCK(gResTypeLock);

    if (!bLocalNodeFound)
    {

        //check to see if we support this node, if we do make an update
        //to add our node name to the list
        dwStatus = FmpRmLoadResTypeDll(pResType);
        ClRtlLogPrint(LOG_NOISE,
                      "[FM] FmpFixupPossibleNodesForResTypeCb: FmpRmLoadDll returned %1!d! for restype %2!ws! \r\n",
                      dwStatus,
                      OmObjectId(pResType));  
        if (dwStatus == ERROR_SUCCESS)
        {

            HDMKEY  hResTypeKey;
            LPWSTR  pmszPossibleNodes = NULL;
            DWORD   dwlpmszLen;
            DWORD   dwSize;

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpFixupPossibleNodesForRestype: fix up resource type %1!ws!\r\n",
                       OmObjectId(pResType));

            bLocalNodeFound = TRUE;


            // The earlier method of updating possible nodes by first querying 
            // the registry and then appending this node to the list and then 
            // updating the registry by GUM update was not an atomic action
            // and was subject to race condition. Instead we now use 
            // FmpSetPossibleNodeForRestype to achieve this atomically.

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpFixupPossibleNodesForRestype: Calling FmpSetPossibleNodeForRestype resource type %1!ws!\r\n",
                       OmObjectId(pResType));
            
            dwStatus = FmpSetPossibleNodeForResType(OmObjectId(pResType),TRUE);
            if ( dwStatus != ERROR_SUCCESS) 
            {
                ClRtlLogPrint(LOG_CRITICAL,
                            "[FM] FmpFixupPossibleNodesForRestype:FmpSetPossibleNodeForResType  returned error %1!u!\r\n",
                            dwStatus);
                return(TRUE);
            }
        }

    }

    //if the version has changed and the localnode hosts this resource type
    //dll, drop
    if (bLocalNodeFound && bLocalNodeVersionChanged && pClusterVersionInfo)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpFixupPossibleNodeForResType: dropping "
                    "CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED control code "
                    "to restype '%1!ws!'\n",
                    pszResTypeName);

        FmpRmResourceTypeControl(pszResTypeName,
                    CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED, 
                    (LPBYTE)pClusterVersionInfo,
                    pClusterVersionInfo->dwVersionInfoSize,
                    NULL,
                    0,
                    NULL,
                    NULL
                    );

    }   

    pClusStartingParams = (PCLUS_STARTING_PARAMS)LocalAlloc(LMEM_FIXED,sizeof(CLUS_STARTING_PARAMS));
    if (pClusStartingParams == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpFixupPossibleNodesForResType: Failed to allocate memory\n");
        CL_UNEXPECTED_ERROR(dwStatus);
        return(TRUE);

    }    
    pClusStartingParams->dwSize = sizeof(CLUS_STARTING_PARAMS);

    // Drop down CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1

    pClusStartingParams->bFirst = CsFirstRun;

    pClusStartingParams->bForm = bForm;    
        
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpFixupPossibleNodesForResType: dropping "
                "CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1 control code to restype '%1!ws!'\n",
                pszResTypeName);

    FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1, 
                (LPBYTE)pClusStartingParams,
                pClusStartingParams->dwSize,
                NULL,
                0,
                NULL,
                NULL
                );

    if(pClusStartingParams)
        LocalFree(pClusStartingParams);
    
    return (TRUE);
}

/****
@func       BOOL | FmpFixupResTypePhase2| This is the enumeration
            callback for every resource type to do post FM online
            fixups.

@parm       IN PVOID | pContext1 | Whether the local node has just upgraded.
@parm       IN PVOID | pContext2 | A pointer to the cluster version info.
@parm       IN PFM_RESTYPE | pResType | Pointer to the resource type object.
@parm       IN LPCWSTR | pszResTypeName | The name of the resource type.

@comm       This routine checks a given resource types in a system and fixes
            its possible node information.  If this node is not on the possible
            node list, but this resource type is supported on the system, the
            node is added to the possible node list for that resource type.

@rdesc      Returns TRUE to continue enumeration, else returns FALSE.

@xref       <f FmpFixupResourceTypes>
****/
BOOL
FmpFixupResTypePhase2Cb(
    IN PVOID        pContext1,
    IN PVOID        pContext2,
    IN PFM_RESTYPE  pResType,
    IN LPCWSTR      pszResTypeName
    )
{
    BOOL    bJoin;
    BOOL    bLocalNodeVersionChanged;
    DWORD   dwStatus;
    CLUS_RESOURCE_CLASS_INFO rcClassInfo;
    PCLUS_STARTING_PARAMS pClusStartingParams = NULL;
    eClusterInstallState eState;

    
    bJoin = *((PBOOL)pContext1);
    bLocalNodeVersionChanged = *((PBOOL)pContext2);
    //if the version has changed let the resource type dll
    // do any fixups.
    if (bLocalNodeVersionChanged)
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpFixupResTypePhase2Cb: dropping CLUSCTL_RESOURCE_TYPE_FIXUP_ON_UPGRADE "
                    "control code to restype '%1!ws!'\n",
                    pszResTypeName);

        FmpRmResourceTypeControl(pszResTypeName,
                    CLUSCTL_RESOURCE_TYPE_FIXUP_ON_UPGRADE, 
                    (LPBYTE)&bJoin,
                    sizeof(BOOL),
                    NULL,
                    0,
                    NULL,
                    NULL
                    );

    }      

    // Drop down CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2

    pClusStartingParams = (PCLUS_STARTING_PARAMS)LocalAlloc(LMEM_FIXED,sizeof(CLUS_STARTING_PARAMS));
    if (pClusStartingParams == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[FM] FmpFixupResTypePhase2Cb: Failed to allocate memory\n");
        CL_UNEXPECTED_ERROR(dwStatus);
        return(TRUE);

    }    
    pClusStartingParams->dwSize = sizeof(CLUS_STARTING_PARAMS);
    pClusStartingParams->bFirst = CsFirstRun;            

    if(bJoin)
        pClusStartingParams->bForm =  FALSE;
    else
        pClusStartingParams->bForm =  TRUE;
           
        
    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpFixupResTypePhase2Cb: dropping CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2 "
                 "control code to restype '%1!ws!', bFirst= %2!u!\n",
                 pszResTypeName,
                 pClusStartingParams->bFirst);

    FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2, 
                (LPBYTE)pClusStartingParams,
                pClusStartingParams->dwSize,
                NULL,
                0,
                NULL,
                NULL
                );

    //
    // Now query for the class information
    //
    rcClassInfo.dw = CLUS_RESCLASS_UNKNOWN;
    dwStatus = FmpRmResourceTypeControl(pszResTypeName,
                CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                NULL,
                0,
                (PUCHAR)&rcClassInfo,
                sizeof(CLUS_RESOURCE_CLASS_INFO),
                NULL,
                NULL );
    if ( dwStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpFixupRestypePhase2Cb: Restype %1!ws!, class = %2!u!, status = %3!u!\n",
               pszResTypeName,
               rcClassInfo.dw,
               dwStatus );
    }

    pResType->Class = rcClassInfo.dw;

    if(pClusStartingParams)
        LocalFree(pClusStartingParams);
    return(TRUE);

}

PFM_RESTYPE
FmpCreateResType(
    IN LPWSTR ResTypeName
    )

/*++

 Routine Description:

    Create a new resource type.

 Arguments:

    ResTypeName - Supplies the resource type name.

 Return Value:

    Do a get last error to get the error. 

 Comments :  If the object already exists, it returns an error.
    If the resource type is created, its reference count is 1.


--*/
{
    DWORD               status = ERROR_SUCCESS;
    PFM_RESTYPE         resType = NULL;
    BOOL                created;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    PLIST_ENTRY         pListEntry;

    resType = OmCreateObject( ObjectTypeResType,
                              ResTypeName,   // This is really the Id
                              NULL,
                              &created);

    if ( resType == NULL ) {
        status = GetLastError();
        goto FnExit;
    }
    // A resource type may be recreated twice, once before the
    //quorum resource is online and once after the database has
    //been uptodated, hence we need to handle the two cases
    if ( created ) {
        resType->State = 0;
        InitializeListHead(&(resType->PossibleNodeList));
    }
    else
    {
        //free the old list, we will recreate it again
        while (!IsListEmpty(&resType->PossibleNodeList))
        {
            pListEntry = RemoveHeadList(&resType->PossibleNodeList);
            pResTypePosEntry = CONTAINING_RECORD(pListEntry, RESTYPE_POSSIBLE_ENTRY, 
                PossibleLinkage);
            OmDereferenceObject(pResTypePosEntry->PossibleNode);
            LocalFree(pResTypePosEntry);
        }
        OmDereferenceObject(resType);

    }
    status = FmpQueryResTypeInfo( resType );

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //if the object was just created, insert it in the list
    if (created)
    {
        status = OmInsertObject( resType );
    }



FnExit:
    if (status != ERROR_SUCCESS)
    {
        SetLastError(status);
        if (resType) 
        {
            OmDereferenceObject( resType );
            resType = NULL;
        }            
    }        
    return(resType);

} // FmpCreateResType



DWORD
FmpDeleteResType(
    IN PFM_RESTYPE pResType
    )

/*++

Routine Description:

    This routine destroys a Resource Type.

Arguments:

    ResType - The Resource Type to destroy.

Returns:

    None.

--*/

{
    DWORD   status;

    status = OmRemoveObject( pResType );


    CL_ASSERT( status == ERROR_SUCCESS );
    //decrement the ref count to get rid of it
    OmDereferenceObject(pResType);
    return(status);
} // FmpDestroyResType


BOOL
FmpFindResourceType(
    IN PFM_RESTYPE Type,
    IN PBOOL ResourceExists,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Callback routine for enumerating resources to see if a given
    resource type exists or not.

Arguments:

    Type - Supplies the resource type to look for.

    ResourceExists - Returns whether or not a resource of the given
        type was found.

    Resource - Supplies the resource.

    Name - Supplies the resource name.

Return Value:

    TRUE - to indicate that the enumeration should continue.

    FALSE - to indicate that the enumeration should not continue.

--*/

{
    if (Resource->Type == Type) {
        *ResourceExists = TRUE;
        return(FALSE);
    }
    return(TRUE);
} // FmpFindResourceType



DWORD
FmpHandleResourceTypeControl(
    IN PFM_RESTYPE Type,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Handle resource type control requests for the FM.

Arguments:

    Type - Supplies the resource type to look for.

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - The number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    DWORD   dataValue;
    LPWSTR  debugPrefix = NULL;

    //
    //  Acquire the restype lock for synchronizing access to the restype
    //  object
    //
    ACQUIRE_EXCLUSIVE_LOCK ( gResTypeLock );
    
    switch ( ControlCode ) {

    case CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES:
        //
        // Re-fetch the IsAlive value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_IS_ALIVE,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            Type->IsAlivePollInterval = dataValue;
        }

        //
        // Re-fetch the LooksAlive value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            Type->LooksAlivePollInterval = dataValue;
        }

        //
        // Re-fetch the DebugPrefix value.
        //
        status = ClRtlFindSzProperty( InBuffer,
                                      InBufferSize,
                                      CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,
                                      &debugPrefix );
        if ( status == ERROR_SUCCESS ) {
            LocalFree( Type->DebugPrefix );
            Type->DebugPrefix = debugPrefix;
        }

        //
        // Re-fetch the DebugControlFunctions value.
        //
        status = ClRtlFindDwordProperty( InBuffer,
                                         InBufferSize,
                                         CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC,
                                         &dataValue );
        if ( status == ERROR_SUCCESS ) {
            if ( dataValue ) {
                Type->Flags |= RESTYPE_DEBUG_CONTROL_FUNC;
            } else {
                Type->Flags &= ~RESTYPE_DEBUG_CONTROL_FUNC;
            }
        }

        break;

    default:
        break;

    }

    RELEASE_LOCK ( gResTypeLock );

    return(ERROR_SUCCESS);

} // FmpHandleResourceTypeControl



VOID
FmpResTypeLastRef(
    IN PFM_RESTYPE pResType
    )

/*++

Routine Description:

    Last dereference to resource object processing routine.
    All cleanup for a resource should really be done here!

Arguments:

    Resource - pointer the resource being removed.

Return Value:

    None.

--*/

{

    if (pResType->DllName)
    {
        LocalFree(pResType->DllName);
    }
    if (pResType->DebugPrefix)
    {
        LocalFree(pResType->DebugPrefix);
    }

    return;

} // FmpResourceLastReference



DWORD
FmpAddPossibleNodeToList(
    IN LPCWSTR      pmszPossibleNodes,
    IN DWORD        dwStringSize,         
    IN PLIST_ENTRY  pPosNodeList
)    
{    

    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;
    DWORD                   i;
    DWORD                   dwStatus = ERROR_SUCCESS;
    LPCWSTR                 pszNode;

    dwStringSize = dwStringSize/sizeof(WCHAR);

    for (i=0; ; i++)
    {
        PNM_NODE    pNmNode;

        pszNode = ClRtlMultiSzEnum(pmszPossibleNodes, dwStringSize, i);
        
        //last string, break out of the loop
        if ((!pszNode) || (*pszNode == UNICODE_NULL))
            break;

        pNmNode = OmReferenceObjectById(ObjectTypeNode,
            pszNode);
        if (!pNmNode)
        {
            //this can be called when all node structures havent been
            //created
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpAddPossibleNodeToList: Warning, node %1!ws! not found\n",
                       pszNode);
            continue;
        }

        pResTypePosEntry = (PRESTYPE_POSSIBLE_ENTRY)LocalAlloc(LMEM_FIXED, sizeof(RESTYPE_POSSIBLE_ENTRY));

        if (!pResTypePosEntry)
        {
            OmDereferenceObject(pNmNode);
            dwStatus = GetLastError();
            goto FnExit;
        }

        //this can be called when all node structures havent been
        //created
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpAddPossibleNodeToList: adding node %1!ws! to resource "
                    "type's possible node list\n",
                    pszNode);
        pResTypePosEntry->PossibleNode = pNmNode;
        InsertTailList(pPosNodeList, &pResTypePosEntry->PossibleLinkage);

    }

FnExit:
    return(dwStatus);
} // FmpAddPossibleNodeToList



DWORD
FmpSetPossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN BOOL    bAssumeSupported
    )
/*++

Routine Description:

    Issues a GUM update to update the possible node list for a resource
    type on every node. The necessary registry information must already
    be in the cluster registry.

Arguments:

    TypeName - Supplies the name of the cluster resource type to update.

    bAssumeSupported - If the node doesnt answer, we assume that the node
        supports this resource type if it already on the possible node
        list for the resource type, i.e in the past it had supported this
        resource type.
    

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    PFM_RESTYPE pResType = NULL;


    ClRtlLogPrint(LOG_NOISE,
                "[FM] FmpSetPossibleNodeForResType: for type %1!ws!, bAssumeSupported= %2!u!.\n",
                TypeName,
                bAssumeSupported );



    dwStatus = GumSendUpdateOnVote( GumUpdateFailoverManager,
                    FmUpdatePossibleNodeForResType,
                    (lstrlenW(TypeName) + 1) * sizeof(WCHAR),
                    (PVOID) TypeName,
                    sizeof(FMP_VOTE_POSSIBLE_NODE_FOR_RESTYPE),
                    FmpDecidePossibleNodeForResType,
                    (PVOID)&bAssumeSupported);

    if (dwStatus != ERROR_SUCCESS) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpSetPossibleNodeForResType: Gum update failed for %1!ws!, status = %2!u!.\n",
                   TypeName,
                   dwStatus );
    }

    return(dwStatus);
    
} // FmpSetPossibleNodeForResType


DWORD
FmpRemovePossibleNodeForResType(
    IN LPCWSTR TypeName,
    IN PNM_NODE pNode
    )
/*++

Routine Description:

    Reads the current list of possible nodes for a restype, removes the specified node
    and then issues a GUM update to update the possible node list for a resource
    type on all nodes.

Arguments:

    TypeName - Supplies the name of the cluster resource type to update.

    pNode - The node that is to be removed from the list of possible nodes.
    

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise.

--*/

{
    DWORD       dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpRemovePossibleNodeForResType: remove node %1!u! from resource "
            "type's %2!ws! possible node list\n",
            NmGetNodeId(pNode),
            TypeName);

    
    dwStatus = FmpSetPossibleNodeForResType(TypeName,TRUE);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpRemovePossibleNodeForRestype: Exit with Status %1!u!\r\n",
        dwStatus);
    return(dwStatus);
    
} // FmpRemovePossibleNodeForResType

BOOL
FmpEnumResTypeNodeEvict(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Resource type enumeration callback for removing node references when
    a node is evicted.

Arguments:

    Context1 - Supplies the node that is being evicted.

    Context2 - not used

    Object - Supplies a pointer to the resource object

    Name - Supplies the resource's object name.

Return Value:

    TRUE to continue enumeration

--*/

{
    PFM_RESTYPE pResType = (PFM_RESTYPE)Object;
    PNM_NODE pNode = (PNM_NODE)Context1;
    PLIST_ENTRY pListEntry;
    PRESTYPE_POSSIBLE_ENTRY pResTypePosEntry = NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpEnumResTypeNodeEvict: Removing references to node %1!ws! from restype %2!ws!\n",
               OmObjectId(pNode),
               OmObjectId(pResType));
               
    ACQUIRE_SHARED_LOCK(gResTypeLock);

    pListEntry = pResType->PossibleNodeList.Flink;
    while (pListEntry != &pResType->PossibleNodeList) {
        pResTypePosEntry = CONTAINING_RECORD(pListEntry,
                                          RESTYPE_POSSIBLE_ENTRY,
                                          PossibleLinkage);
        pListEntry = pListEntry->Flink;
        if (pResTypePosEntry->PossibleNode == pNode)
        {
            RemoveEntryList(&pResTypePosEntry->PossibleLinkage);
            OmDereferenceObject( pResTypePosEntry->PossibleNode );
            LocalFree ( pResTypePosEntry );
            break;
        }
    }

    ClusterEvent( CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE, pResType);
    RELEASE_LOCK(gResTypeLock);
  
    return(TRUE);

} // FmpEnumResTypeNodeEvict

// The DLL Name field is are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.

DWORD FmpBuildWINSParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN OUT LPWSTR * ppAdminExt,
   IN LPWSTR       lpKeyName, 
   IN HDMKEY       hdmKey,
   IN BOOL         CopyOldData
   )
/**
    Helper routine for FmBuildWINS. It packs parameters for WINS 
    Key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize,dwTemp1,dwTemp2;
    LPWSTR          lpOldName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;    
    DWORD           dwAdminExtSize;

    dwTotalSize=3* sizeof(DWORD) + 3*(sizeof (LPWSTR)) ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    if(CopyOldData)
    {
        dwStatus = DmQueryDword( hdmKey,
                       CLUSREG_NAME_RESTYPE_IS_ALIVE,
                       &dwTemp1,
                       NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp1 = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The IsAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_WINS,
                              dwStatus);
                goto FnExit;
            }
        }

        dwStatus = DmQueryDword( hdmKey,
               CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
               &dwTemp2,
               NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp2 = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The LooksAlive poll interval for the %1!ws! resource type could "
                              "not be read from the registry. Resources of this type will not be "
                              "monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_WINS,
                              dwStatus);
                goto FnExit;
            }
        }

    }    
    else
    {
        dwTemp1=CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        dwTemp2=CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    }

    ((PDWORD)*ppInParams)[0]= dwTemp1;
    ((PDWORD)*ppInParams)[1]= dwTemp2; 

    dwNameSize=(lstrlen(L"ClNetRes.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    CopyMemory(*ppDllName,L"ClNetRes.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    //check if the resource type name needs to copied
    if(CopyOldData)
    {
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_NAME,
                        &lpOldName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpBuidlWINSParams: Failed to read from registry, status = %1!u!\n",
                       dwStatus);
            goto FnExit;
        }           
    }
    else
    {
        dwSize=(lstrlen(lpKeyName)+1)*sizeof(WCHAR);
        lpOldName=(LPWSTR ) LocalAlloc(LMEM_FIXED,dwSize);
        if (lpOldName == NULL)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        CopyMemory(lpOldName,lpKeyName,dwSize);
    }
    
    dwNameSize=(lstrlen(lpOldName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppResTypeName,lpOldName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    //copy adminextensions value
    dwAdminExtSize = (lstrlen(L"{AB4B1105-DCD6-11D2-84B7-009027239464}")+1)*sizeof(WCHAR);
    dwNameSize = dwAdminExtSize + sizeof(WCHAR); // size of the second terminating NULL for the MUITI_SZ
    *ppAdminExt= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppAdminExt == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppAdminExt,L"{AB4B1105-DCD6-11D2-84B7-009027239464}",dwAdminExtSize);
    (*ppAdminExt)[dwAdminExtSize/sizeof(WCHAR)] = L'\0'; // second NULL for the MULTI_SZ
    CopyMemory(*ppInParams+2*sizeof(DWORD)+2*sizeof(LPWSTR),ppAdminExt,sizeof(LPWSTR)); 
    CopyMemory(*ppInParams+2*sizeof(DWORD)+3*sizeof(LPWSTR),&dwNameSize,sizeof(DWORD)); 
FnExit:
    if(lpOldName)
        LocalFree(lpOldName);
    return dwStatus;
}//FmBuildWINSParams

/****
@func       DWORD | FmBuildWINS| Builds the property list for 
            WINS Servcie Regisrty entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for WINS Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpBuildWINSParams> 
****/

DWORD FmBuildWINS(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR    *  pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    LPWSTR          pAdminExt=NULL;
    HDMKEY          hdmKey = NULL;
    BOOL            CopyOldData= TRUE; //whenever we do the fixups, copy old data 
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;
    DWORD           dwDisposition;
    
    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    // open the key, if it doesnt exist create it.
    hdmKey = DmCreateKey(DmResourceTypesKey, CLUS_RESTYPE_NAME_WINS, 0,
            KEY_READ | KEY_WRITE, NULL, &dwDisposition );
    if (hdmKey == NULL)
    {
        //should we create the key if the key is missing
        //if there is some other error we should exit
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[FM] FmBuildWINS: Failed to create or open the wins resource type key, Status=%1!u!\r\n",
             dwStatus);
        goto FnExit;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
        CopyOldData = FALSE;
    
    //check to see if the resource dll name is valid
    dwStatus = DmQuerySz( hdmKey,
                    CLUSREG_NAME_RESTYPE_DLL_NAME,
                    &pOldDllName,
                    &dwSize,
                    &dwStringSize );
    if ( dwStatus == ERROR_SUCCESS ) 
    {
        //SS: Always apply the fixup.  There was a bug in the win2K fixup
        //where the administrator extensions was not being treated like a 
        //multi-sz.  To fix the broken administrator extension we must 
        //always appy this fixup.
        //
#if 0
        if (!lstrcmpW(pOldDllName,L"ClNetRes.dll"))
        {                    
            // No need to apply the fixup.
            goto FnExit;    
        }
#endif
    }
    else
    {
        //fixup is needed
        //we assume that CopyOldData is always true
        //dwStatus will be overwritten by the return from next func call
    }


    //specify the key name for this fixup
    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    // Build the parameter list
    dwStatus=FmpBuildWINSParams(&pInParams,&pDllName,&pResTypeName,&pAdminExt,CLUS_RESTYPE_NAME_WINS,hdmKey,CopyOldData);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupWINSProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
   //     ClRtlLogPrint(LOG_CRITICAL," AllocMem : ERROR_MORE_DATA\n");
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildWINS - error constructing property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
// Cleanup
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    if (pAdminExt)
        LocalFree(pAdminExt);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
    return dwStatus;
} //FmBuildWINS


// The DLL Name and AdminExtensions field are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.

DWORD
FmpBuildDHCPParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN OUT LPWSTR * ppAdminExt,
   IN LPWSTR       lpKeyName, 
   IN HDMKEY       hdmKey,
   IN BOOL         CopyOldData 
)
/**
    Helper routine for FmBuildDHCP. It packs parameters for DHCP key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize,dwTemp1,dwTemp2;
    LPWSTR          lpOldName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize; 
    DWORD           dwAdminExtSize;

    
    dwTotalSize=3* sizeof(DWORD) + 3*(sizeof (LPWSTR))  ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }
    
    if(CopyOldData)    
    {
        dwStatus = DmQueryDword( hdmKey,
                       CLUSREG_NAME_RESTYPE_IS_ALIVE,
                       &dwTemp1,
                       NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp1 = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The IsAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_DHCP,
                              dwStatus);
                goto FnExit;
            }
        }

        dwStatus = DmQueryDword( hdmKey,
               CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,
               &dwTemp2,
               NULL );

        if ( dwStatus != NO_ERROR ) {
            if ( dwStatus == ERROR_FILE_NOT_FOUND ) {
                dwTemp2 = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[FM] The LooksAlive poll interval for the %1!ws! resource type "
                              "could not be read from the registry. Resources of this type "
                              "will not be monitored. The error was %2!d!.\n",
                              CLUS_RESTYPE_NAME_DHCP,
                              dwStatus);
                goto FnExit;
            }
        }

    }
    else
    {
        dwTemp1=CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
        dwTemp2=CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    }

    ((PDWORD)*ppInParams)[0]= dwTemp1;
    ((PDWORD)*ppInParams)[1]= dwTemp2; 
    

    dwNameSize=(lstrlen(L"ClNetRes.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }
    CopyMemory(*ppDllName,L"ClNetRes.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    //check if the resource type name needs to copied
    if(CopyOldData)
    {
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_NAME,
                        &lpOldName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmpBuidlDHCPParams: Failed to read from registry, status = %1!u!\n",
                       dwStatus);
            goto FnExit;
        }           
    }
    else
    {
        dwSize=(lstrlen(lpKeyName)+1)*sizeof(WCHAR);
        lpOldName=(LPWSTR ) LocalAlloc(LMEM_FIXED,dwSize);
        if (lpOldName == NULL)
        {
            dwStatus = GetLastError();
            goto FnExit;
        }
        CopyMemory(lpOldName,lpKeyName,dwSize);
    }

    dwNameSize=(lstrlen(lpOldName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    CopyMemory(*ppResTypeName,lpOldName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    //copy adminextensions value
    dwAdminExtSize=(lstrlen(L"{AB4B1105-DCD6-11D2-84B7-009027239464}")+1)*sizeof(WCHAR);
    dwNameSize = dwAdminExtSize + sizeof(WCHAR); // size of the second terminating NULL for the MUITI_SZ
    *ppAdminExt= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppAdminExt == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(*ppAdminExt,L"{AB4B1105-DCD6-11D2-84B7-009027239464}",dwAdminExtSize);
    (*ppAdminExt)[dwAdminExtSize/sizeof(WCHAR)] = L'\0'; // second NULL for the MULTI_SZ
    CopyMemory(*ppInParams+2*sizeof(DWORD)+2*sizeof(LPWSTR),ppAdminExt,sizeof(LPWSTR)); 
    CopyMemory(*ppInParams+2*sizeof(DWORD)+3*sizeof(LPWSTR),&dwNameSize,sizeof(DWORD)); 
FnExit:
    if(lpOldName)
        LocalFree(lpOldName);
    return dwStatus;
} //FmpBuildDHCPParams

/****
@func       DWORD | FmBuildDHCP| Builds the property list for 
            DHCP Servcie Regisrty entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for DHCP Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmBuildDHCPParams> 
****/

DWORD FmBuildDHCP(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    LPWSTR          pAdminExt=NULL;
    HDMKEY          hdmKey = NULL;
    BOOL            CopyOldData= TRUE; //whenever fixup is applied, copy the old data
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;
    DWORD           dwDisposition;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;


    // open the key, if it isnt present create it.
    hdmKey = DmCreateKey(DmResourceTypesKey, CLUS_RESTYPE_NAME_DHCP, 0,
            KEY_READ | KEY_WRITE, NULL, &dwDisposition );
    if (hdmKey == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[FM] FmBuildDHCP: Failed to create or open the dhcp resource type key, Status=%1!u!\r\n",
                      dwStatus);
        goto FnExit;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
        CopyOldData = FALSE;

    //check to see if the resource dll name is valid
    dwStatus = DmQuerySz( hdmKey,
                    CLUSREG_NAME_RESTYPE_DLL_NAME,
                    &pOldDllName,
                    &dwSize,
                    &dwStringSize );
    if ( dwStatus == ERROR_SUCCESS ) 
    {
        //SS: for now we will always apply the fixup.  There is a bug in the 
        //win2k fixup which needs to be fixed up..and one way of doing it to
        //always apply the new fixup
#if 0
        if (!lstrcmpW(pOldDllName,L"ClNetRes.dll"))
        {                    
            // No need to apply the fixup.
            goto FnExit;    
        }
#endif        
    }
    else
    {
        //fixup is needed
        //we assume that CopyOldData is always true
        //dwStatus will be overwritten by the return from next func call
    }


    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    dwStatus=FmpBuildDHCPParams(&pInParams,&pDllName,&pResTypeName,&pAdminExt,CLUS_RESTYPE_NAME_DHCP,hdmKey,CopyOldData);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupDHCPProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
   //     ClRtlLogPrint(LOG_CRITICAL," AllocMem : ERROR_MORE_DATA\n");
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildDHCP: error construct property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    if (pAdminExt)
        LocalFree(pAdminExt);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
        
    return dwStatus;
} //FmBuildDHCP

// The DLL Name and AdminExtensions field are hardcoded in here. More 
// appropriately, thse should be read from cluster.inf using setup API's.


// The DLL Name field is hardcoded in here. More 
// appropriately, it should be read from cluster.inf using setup API's.

DWORD
FmpBuildNewMSMQParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName,
   IN OUT LPWSTR * ppResTypeName,
   IN LPWSTR       lpResTypeDisplayName 
   )
/**
    Helper routine for FmBuildNewMSMQ. It packs parameters for MSMQ key into a parameter list.

**/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize;

    dwTotalSize=2* sizeof(DWORD) + 2*(sizeof (LPWSTR))  ;
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    ((PDWORD)*ppInParams)[0]= CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;
    ((PDWORD)*ppInParams)[1]= CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE; 

    dwNameSize=(lstrlen(L"mqclus.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }

    
    CopyMemory(*ppDllName,L"mqclus.dll",dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD),ppDllName,sizeof(LPWSTR));

    dwNameSize=(lstrlen(lpResTypeDisplayName)+1)*sizeof(WCHAR);
    *ppResTypeName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppResTypeName == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    CopyMemory(*ppResTypeName,lpResTypeDisplayName,dwNameSize);
    CopyMemory(*ppInParams+2*sizeof(DWORD)+sizeof(LPWSTR),ppResTypeName,sizeof(LPWSTR));

    return dwStatus;
} //FmpBuildNewMSMQParams

/****
@func       DWORD | FmBuildNewMSMQ| Builds the property list for 
            MSMQ Servcie Registry entry.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the Property Table for MSMQ Registry

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmBuildNewMSMQParams> 
****/

DWORD FmBuildNewMSMQ(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    LPWSTR          pResTypeName=NULL; 
    HDMKEY          hdmKey;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    // if this key is already present in registry , skip
    hdmKey=DmOpenKey(DmResourceTypesKey,CLUS_RESTYPE_NAME_NEW_MSMQ,KEY_EXECUTE);
    if (hdmKey!= NULL)
    {
        DmCloseKey(hdmKey);
        goto FnExit;    
    } 

    *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
    if(*pszKeyName==NULL)
    {
        dwStatus =GetLastError();
        goto FnExit;
    }    
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);    


    dwStatus=FmpBuildNewMSMQParams(&pInParams,&pDllName,&pResTypeName,CLUS_RESTYPE_DISPLAY_NAME_NEW_MSMQ);
    if (dwStatus!= ERROR_SUCCESS)
        goto FnExit;
    Required=sizeof(DWORD);
 AllocMem:  

    *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList==NULL)
    {
        dwStatus=GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize=Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmJoinFixupNewMSMQProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize=Returned;
    if (dwStatus==ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildNewMSMQ: error construct property list. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            


FnExit:
    if(pInParams)
        LocalFree(pInParams); 
    if(pDllName)
        LocalFree(pDllName);
    if (pResTypeName)
        LocalFree(pResTypeName);
    return dwStatus;
} //FmBuildNewMSMQ


DWORD
FmpBuildMSDTCParams(
   IN OUT LPBYTE * ppInParams,
   IN OUT LPWSTR * ppDllName
   )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwTotalSize;
    DWORD           dwNameSize;
    DWORD           dwSize=0;
    DWORD           dwStringSize;

    dwTotalSize=sizeof (LPWSTR);
    *ppInParams=(LPBYTE)LocalAlloc(LMEM_FIXED,dwTotalSize);
    if(*ppInParams == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    dwNameSize=(lstrlen(L"mtxclu.dll")+1)*sizeof(WCHAR);
    *ppDllName= (LPWSTR ) LocalAlloc(LMEM_FIXED,dwNameSize);
    if(*ppDllName == NULL)
    {
         dwStatus = GetLastError();
        return dwStatus;
    }
    CopyMemory(*ppDllName,L"mtxclu.dll",dwNameSize);
    CopyMemory(*ppInParams,ppDllName,sizeof(LPWSTR));

    return dwStatus;
}//FmpBuildMSDTCParams


DWORD
FmBuildMSDTC(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus=ERROR_SUCCESS;
    LPBYTE          pInParams=NULL;
    DWORD           Required,Returned;
    LPWSTR          pDllName=NULL;
    HDMKEY          hdmKey = NULL;
    LPWSTR          pOldDllName=NULL;
    DWORD           dwSize=0;
    DWORD           dwStringSize;

    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;

    hdmKey=DmOpenKey(DmResourceTypesKey,CLUS_RESTYPE_NAME_MSDTC,KEY_EXECUTE);
    if (hdmKey!= NULL)
    {
        //check to see if the resource dll name is valid
        dwStatus = DmQuerySz( hdmKey,
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &pOldDllName,
                        &dwSize,
                        &dwStringSize );
        if ( dwStatus != NO_ERROR ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[FM] The DllName value for the %1!ws! resource type could not be read "
                          "from the registry. Resources of this type will not be monitored. "
                          "The error was %2!d!.\n",
                          CLUS_RESTYPE_NAME_MSDTC,
                          dwStatus);
            goto FnExit;
        }

        if (!lstrcmpW(pOldDllName,L"mtxclu.dll"))
        {
            // No need to apply the fixup.
            goto FnExit;
        }

        *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_RESOURCE_TYPES)+1)*sizeof(WCHAR));
        if(*pszKeyName==NULL)
        {
            dwStatus =GetLastError();
            goto FnExit;
        }
        lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_RESOURCE_TYPES);

        dwStatus=FmpBuildMSDTCParams(&pInParams,&pDllName);
        if (dwStatus!= ERROR_SUCCESS)
            goto FnExit;
        Required=sizeof(DWORD);
    AllocMem:

        *ppPropertyList=(LPBYTE)LocalAlloc(LMEM_FIXED, Required);
        if(*ppPropertyList==NULL)
        {
            dwStatus=GetLastError();
            goto FnExit;
        }
        *pdwPropertyListSize=Required;
        dwStatus = ClRtlPropertyListFromParameterBlock(
                                             NmJoinFixupMSDTCProperties,
                                             *ppPropertyList,
                                             pdwPropertyListSize,
                                             (LPBYTE)pInParams,
                                             &Returned,
                                             &Required
                                              );

        *pdwPropertyListSize=Returned;
        if (dwStatus==ERROR_MORE_DATA)
        {
            LocalFree(*ppPropertyList);
            *ppPropertyList=NULL;
            goto AllocMem;
        }
        else
            if (dwStatus != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[FM] FmBuildMSDTC: error constructing property list. status %1!u!\n",
                            dwStatus);
                goto FnExit;
            }
    }


FnExit:
    if(pInParams)
        LocalFree(pInParams);
    if(pDllName)
        LocalFree(pDllName);
    if(pOldDllName)
        LocalFree(pOldDllName);
    if (hdmKey)        
        DmCloseKey(hdmKey);
    return dwStatus;
} //FmBuildMSDTC


/****
@func       DWORD | FmBuildClusterProp| Builds the property list for 
            adding Admin Extension value to Cluster root key. The ClsID, if
            not already present,is appended to the existing value.

@parm       IN DWORD | dwFixupType| JoinFixup or FormFixup

@parm       OUT PVOID* | ppPropertyList| Pointer to the pointer to the property list
@parm       OUT LPDWORD | pdwProperyListSize | Pointer to the property list size

@comm       Builds up the propertylist from the NmFixupClusterProperties 

@rdesc      Returns a result code. ERROR_SUCCESS on success.

****/


DWORD
FmBuildClusterProp(
    IN  DWORD    dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD  pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LPBYTE          pInParams = NULL;
    DWORD           Required,Returned;
    LPWSTR          pwszValue = NULL;
    HDMKEY          hdmKey;
    DWORD           dwBufferSize = 0;
    DWORD           dwSize       = 0;
    DWORD           dwNewSize    = 0;   
    BOOL            bAlreadyRegistered = FALSE;
    const WCHAR     pwszClsId[] = L"{4EC90FB0-D0BB-11CF-B5EF-00A0C90AB505}"; 
    LPCWSTR	        pwszValueBuf = NULL;
    LPWSTR		    pwszNewValue = NULL;
    LPWSTR          pwszNewValueBuf = NULL;
    DWORD	        cch;


    *ppPropertyList = NULL;
    *pdwPropertyListSize = 0;
    dwStatus = DmQueryString( DmClusterParametersKey,   
                               CLUSREG_NAME_ADMIN_EXT,
                               REG_MULTI_SZ,
                               (LPWSTR *) &pwszValue,
                               &dwBufferSize,
                               &dwSize );
    if ((dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_FILE_NOT_FOUND))
	{	
        ClRtlLogPrint(LOG_CRITICAL,
           "[FM] FmBuildClusterProp: error in DmQueryValue. status %1!u!\n",
            dwStatus);
	    goto FnExit;  
    }
    
    // Check if Admin Extension value is already present  

	if(pwszValue != NULL)
	{
    	pwszValueBuf = pwszValue;

    	while (*pwszValueBuf != L'\0')
    	{
    		if (lstrcmpiW(pwszClsId, pwszValueBuf) == 0)
    			break;
    		pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
    	}  // while:  more strings in the extension list
    	bAlreadyRegistered = (*pwszValueBuf != L'\0');

        if(bAlreadyRegistered)
            goto FnExit;  // value already present, don't do anything
    }    
	
	// Allocate a new buffer.
	dwNewSize = dwSize + (lstrlenW(pwszClsId) + 1) * sizeof(WCHAR);
	if (dwSize == 0) // Add size of final NULL if first entry.
		dwNewSize += sizeof(WCHAR);
	pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, dwNewSize);
	if (pwszNewValue == NULL)
	{
		dwStatus = GetLastError();
		goto FnExit;
    }

	pwszValueBuf	= pwszValue;
    pwszNewValueBuf	= pwszNewValue;

    // Copy the existing extensions to the new buffer.
	if (pwszValue != NULL)
	{
		while (*pwszValueBuf != L'\0')
		{
			lstrcpyW(pwszNewValueBuf, pwszValueBuf);
			cch = lstrlenW(pwszValueBuf);
			pwszValueBuf += cch + 1;
			pwszNewValueBuf += cch + 1;
		}  // while:  more strings in the extension list
	}  // if:  previous value buffer existed

	// Add the new CLSID to the list.
	lstrcpyW(pwszNewValueBuf, pwszClsId);
	pwszNewValueBuf += lstrlenW(pwszClsId) + 1;
	*pwszNewValueBuf = L'\0';
	
    dwSize = sizeof(DWORD) + sizeof(LPWSTR);
    pInParams = (LPBYTE)LocalAlloc(LMEM_FIXED,dwSize);
    if (pInParams == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    CopyMemory(pInParams,&pwszNewValue,sizeof(LPWSTR)); 
    CopyMemory(pInParams+sizeof(LPWSTR),&dwNewSize,sizeof(DWORD)); 
    
    Required = sizeof(DWORD);
AllocMem:  

    *ppPropertyList = (LPBYTE)LocalAlloc(LMEM_FIXED, Required);
    if(*ppPropertyList == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    *pdwPropertyListSize = Required;
    dwStatus = ClRtlPropertyListFromParameterBlock(
                                         NmFixupClusterProperties,
                                         *ppPropertyList,
                                         pdwPropertyListSize,
                                         (LPBYTE)pInParams,
                                         &Returned,
                                         &Required
                                          );

    *pdwPropertyListSize = Returned;
    if (dwStatus == ERROR_MORE_DATA)
    {
        LocalFree(*ppPropertyList);
        *ppPropertyList=NULL;
        goto AllocMem;
    }
    else
        if (dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[FM] FmBuildClusterProp - error in ClRtlPropertyListFromParameterBlock. status %1!u!\n",
                        dwStatus);
            goto FnExit;
        }            

    //specify the key name for this fixup
    *pszKeyName = (LPWSTR)LocalAlloc(LMEM_FIXED,(lstrlenW(CLUSREG_KEYNAME_CLUSTER)+1)*sizeof(WCHAR));
    if(*pszKeyName == NULL)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }
    lstrcpyW(*pszKeyName,CLUSREG_KEYNAME_CLUSTER);
FnExit:
    // Cleanup
    if (pwszValue)
        LocalFree(pwszValue);
    if(pwszNewValue)
        LocalFree(pwszNewValue);
    if(pInParams)
        LocalFree(pInParams);
    return dwStatus;
}


//call back to update in-memory structures after registry fixup for WINS and DHCP
/**
   The call-back function will update the in-memory ResoucreType list,
   but it will not fix the PossibleOwners list in registry and in memory. 
   This is okay for the joining node as it will invoke FmpFixupResourceTypes
   later on in FmJoinPhase2. The other nodes of the cluster will not be
   able to add themselves to the possible nodes in registry or in in-memory struct.
   This is right for present(NT4-NT5) scenario,but might have to be changed later.

**/

DWORD FmFixupNotifyCb(VOID)
{
	return FmpInitResourceTypes();
}

//RJain - When an NT5 node joins an NT4SPx node, in order to enable 
//the cluadmin on NT5 side to view the security tab for NT4 node
//we need to add the NT5 ClsId to the AdminExtension value under 
//Cluster key on both NT4 and NT5 nodes. This can't done in 
//NmPerformFixups as the GumUpdate handler for this update is not
//present on SP4 and SP5. So we do it before NmPerformFixups is called by 
//by using DmAppendToMultiSz.

DWORD
FmFixupAdminExt(VOID)
{
    DWORD           dwClusterHighestVersion;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           Required,Returned;
    LPWSTR          pwszValue = NULL;
    DWORD           dwBufferSize = 0;
    DWORD           dwSize       = 0;
    DWORD           dwNewSize    = 0;   
    const WCHAR     pwszClsId[] = L"{4EC90FB0-D0BB-11CF-B5EF-00A0C90AB505}"; 
    

    NmGetClusterOperationalVersion( &dwClusterHighestVersion, 
                                    NULL, 
                                    NULL );

    // Apply this fixup only if there is an NT4 node in the cluster 
    if ( CLUSTER_GET_MAJOR_VERSION( dwClusterHighestVersion ) < 
                NT5_MAJOR_VERSION )
    {   
        dwStatus = DmQueryString( DmClusterParametersKey,   
                                   CLUSREG_NAME_ADMIN_EXT,
                                   REG_MULTI_SZ,
                                   (LPWSTR *) &pwszValue,
                                   &dwBufferSize,
                                   &dwSize );
        if ((dwStatus != ERROR_SUCCESS)
    		&& (dwStatus != ERROR_FILE_NOT_FOUND))
    	{	
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt: error in DmQueryString. status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
        }

        //check if ClsId is already present
        if (ClRtlMultiSzScan(pwszValue,pwszClsId) != NULL)
            goto FnExit;    

        //if not, append ClsId to the existing value
        dwNewSize = dwSize/sizeof(WCHAR);
        dwStatus = ClRtlMultiSzAppend((LPWSTR *)&pwszValue,
                                    &dwNewSize,
                                    pwszClsId
                                    );

        if(dwStatus != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt:ClRtlMultiSzAppend returned status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
    	}

        dwStatus = DmSetValue(DmClusterParametersKey,   
                        CLUSREG_NAME_ADMIN_EXT,
                        REG_MULTI_SZ,
                        (CONST BYTE *)pwszValue,
                        dwNewSize*sizeof(WCHAR)
                        );

        if (dwStatus != ERROR_SUCCESS)
    	{	
            ClRtlLogPrint(LOG_CRITICAL,
               "[FM] FmFixupAdminExt:Error in DmSetValue. status %1!u!\n",
                dwStatus);
    	    goto FnExit;  
        }
            	    	
    } //if(CLUSTER_GET_MAJOR_VERSION)
FnExit:
    // Cleanup
    if (pwszValue)
        LocalFree(pwszValue);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\rmnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rmnotify.c

Abstract:

    Interfaces with the resource monitor to detect notification
    of resource state changes.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE RMNOTIFY

//
// Local Data
//

CL_QUEUE NotifyQueue;

HANDLE RmNotifyThread;



//
// Local Functions
//
DWORD
FmpRmWorkerThread(
    IN LPVOID lpThreadParameter
    );

VOID
FmpRmWorkItemHandler(
    IN PCLRTL_WORK_ITEM  WorkItem,
    IN DWORD             Ignored1,
    IN DWORD             Ignored2,
    IN ULONG_PTR         Ignored3
    );

DWORD
FmpInitializeNotify(
    VOID
    )

/*++

Routine Description:

    Initialization routine for notification engine

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD ThreadId;
    DWORD Status;

    Status = ClRtlInitializeQueue(&NotifyQueue);
    if (Status != ERROR_SUCCESS) {
        CL_LOGFAILURE(Status);
        return(Status);
    }

    RmNotifyThread = CreateThread(NULL,
                                  0,
                                  FmpRmWorkerThread,
                                  NULL,
                                  0,
                                  &ThreadId);
    if (RmNotifyThread == NULL) {
        CsInconsistencyHalt(GetLastError());
    }

    return(ERROR_SUCCESS);
}


DWORD
FmpRmWorkerThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread processes deferred Resource Monitor events.

Arguments:

    lpThreadParameter - not used.

Return Value:

    None.

--*/

{
    DWORD        status = ERROR_SUCCESS;
    PRM_EVENT    event;
    PLIST_ENTRY  entry;

    while (TRUE) 
    {
        entry = ClRtlRemoveHeadQueue(&NotifyQueue);
        if ( entry == NULL ) {
            break;
        }

        event = CONTAINING_RECORD(entry,
                                  RM_EVENT,
                                  Linkage);

        if (event->EventType == RmWorkerTerminate) 
        {
            LocalFree(event);
            break;
        }

        status = FmpRmDoHandleCriticalResourceStateChange( event, 
                                                           NULL,
                                                           event->Parameters.ResourceTransition.NewState);

        LocalFree(event);
        if (status != ERROR_SUCCESS)
        {
            break;
        }
    }
    return(status);
}

BOOL
FmpPostNotification(
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD NotifyEvent,
    IN CLUSTER_RESOURCE_STATE CurrentState
    )

/*++

Routine Description:

    Callback routine used by resource monitor for resource state
    change notification. This routine queues the notification to
    a worker thread for deferred processing.

Arguments:

    NotifyKey - Supplies the notification key for the resource
                that changed

    NotifyEvent - The event type.

    CurrentState - Supplies the (new) current state of the resource

Return Value:

    TRUE - continue receiving notifications

    FALSE - abort notifications

--*/

{
    PRM_EVENT  event;


    event = LocalAlloc(LMEM_FIXED, sizeof(RM_EVENT));

    if (event != NULL) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] NotifyCallBackRoutine: enqueuing event\n");

        event->EventType = NotifyEvent;
        event->Parameters.ResourceTransition.NotifyKey = NotifyKey;
        event->Parameters.ResourceTransition.NewState = CurrentState;

        //
        // Enqueue the event for the worker thread.
        //
        ClRtlInsertTailQueue(&NotifyQueue, &event->Linkage);
    } else {
        ClRtlLogPrint(LOG_UNUSUAL, "[FM] NotifyCallBackRoutine: Unable to post item, memory alloc failure %1!u!\n",
                      GetLastError());
    }

    return(TRUE);
}

DWORD
FmpRmDoHandleCriticalResourceStateChange(
    IN PRM_EVENT pEvent,
    IN OPTIONAL PFM_RESOURCE pTransitionedResource,
    IN CLUSTER_RESOURCE_STATE NewState
    )

/*++

Routine Description:

    Does an interlocked decrement of the gdwQuoBlockingResources variable.
    Handle the transition of the quorum resource state via a separate 
    thread.

Arguments:

    pEvent - The Resource Monitor Event

    pTransitionedResource - The resource whose state has changed.

    NewState - New state of the resource.

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

Comments:

    DO NOT hold any locks (such as group lock, gQuoChangeLock, etc.) 
    in this function. You could deadlock the system quite easily.

--*/

{
    RM_NOTIFY_KEY       NotifyKey;
    DWORD               dwOldBlockingFlag;
    PFM_RESOURCE        pResource = pTransitionedResource;
    DWORD               status = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/99
    //
    //  This function decrements the blocking resources count when the
    //  resource state has stabilized. It is important to do this
    //  decrement in a non-blocking mode so that the quorum resource
    //  does not get caught forever waiting for this count to go down to 
    //  zero in the offline call, FmpRmOfflineResource. This code was 
    //  originally located in FmpHandleResourceTransition and was moved
    //  here since you could run out of FmpRmWorkItemHandler threads 
    //  (which service the CsDelayedWorkQueue) since all of them could
    //  get blocked on the local resource lock in 
    //  FmpHandleResourceTransition and consequently any new notifications
    //  from resmon which could potentially decrement this count will
    //  not get serviced.
    //
    if ( !ARGUMENT_PRESENT ( pTransitionedResource ) )
    {
        //SS: have no idea what this was for, but only do this check if pEvent is passed in
        if (pEvent)
        {
            NotifyKey = pEvent->Parameters.ResourceResuscitate.NotifyKey;

            pResource = FmpFindResourceByNotifyKey(
                   NotifyKey
                    );

            if ( pResource == NULL ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpRmDoHandleCriticalResourceStateChange, bad resource NotifyKey %1!u!\n",
                NotifyKey);
                goto FnExit;
            } 

            if ( pEvent->EventType != ResourceTransition )
            {
                goto FnExit;
            }
        }
    }
    
    if ( pResource->QuorumResource ) 
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/25/99
        //
        //  If this resource is the quorum resource, then let 
        //  FmpHandleResourceTransition take care of the sync notifications.
        //  Note that this function only does the notifications for the
        //  non-quorum resources as well as does the decrement on the
        //  blocking resources count. The decrement MUST be done
        //  without holding any locks to avoid potential deadlocks with
        //  the quorum resource offline getting stuck in FmpRmOfflineResource
        //  waiting for the blocking resources count to go to 0. 
        //  As far as the quorum resource goes, the sync notifications
        //  must be done with gQuoChangeLock held since we want to 
        //  synchronize with other threads such as the FmCheckQuorumState 
        //  called by the DM node down handler. FmpHandleResourceTransition 
        //  does hold the gQuoChangeLock.
        //
        //  Note also that for the quorum resource a separate thread
        //  handles the resource transition since if we depend on the
        //  worker threads servicing the CsDelayedWorkQueue to do this,
        //  this notification could be starved from being processed since
        //  some thread could hold the group lock and be stuck in the
        //  resource onlining waiting for the quorum resource to go
        //  online and all the worker threads servicing the CsDelayedWorkQueue 
        //  could be blocked on the group lock preventing the propagation
        //  of the quorum resource state.
        //
        FmpCreateResStateChangeHandler( pResource, NewState, pResource->State ); 

        
        goto FnExit;
    }


    //
    //  Comments from sunitas: Call the synchronous notifications. 
    //  This is done before the count is decremented as the synchronous 
    //  callbacks like the registry replication must get a chance to 
    //  finish before the quorum resource state is allowed to change.
    //
    //  Note, there is no synchronization here with the resmon's 
    //  online/offline code. They are using the LocalResourceLocks.
    //
    FmpCallResourceNotifyCb( pResource, NewState );

    dwOldBlockingFlag = InterlockedExchange( &pResource->BlockingQuorum, 0 );

    if ( dwOldBlockingFlag ) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpRmDoHandleCriticalResourceStateChange: call InterlockedDecrement on gdwQuoBlockingResources, Resource %1!ws!\n",
            OmObjectId(pResource));
        InterlockedDecrement( &gdwQuoBlockingResources );
    }

    //post a work item to the fm worker thread to handle the rest
    OmReferenceObject(pResource);
    FmpPostWorkItem(FM_EVENT_RES_RESOURCE_TRANSITION,
                    pResource,
                    NewState);


FnExit:
    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\resfail.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    resfail.c

Abstract:

    Cluster resource state management routines.

Author:

    Mike Massa (mikemas) 14-Jan-1996


Revision History:

--*/

#include "fmp.h"

#define LOG_MODULE RESFAIL

// globals

//
// Local Functions
//

DWORD
FmpHandleResStateChangeProc(
    IN LPVOID pContext
    );
    

VOID
FmpHandleResourceFailure(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Handles resource failure notifications from the resource monitor.

Arguments:

    Resource   - The resource which has failed.

Return Value:

    None.

Note:

    This routine is only called if the resource was online at the time of
    the failure.

--*/
{
    DWORD                                   dwStatus;
    BOOL                                    bRestartGroup = TRUE;
    DWORD                                   tickCount;
    DWORD                                   withinFailurePeriod;
    
    CsLogEvent2(LOG_CRITICAL,
        FM_RESOURCE_FAILURE,
        OmObjectName(pResource),
        OmObjectName(pResource->Group));

    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpHandleResourceFailure: taking resource %1!ws! and dependents offline\n",
               OmObjectId(pResource));



    if ( pResource->State == ClusterResourceOnline ) 
    {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] Resource %1!ws! failed, but still online!\n",
                   OmObjectId(pResource));
    }
   
    // SS: We handle the failure of the quorum resource specially
    // since other resources rely on it and may be blocked waiting
    // for the quorum resource to come online.

    ++ pResource->NumberOfFailures;
    switch ( pResource->RestartAction ) 
    {

    case RestartNot:
        FmpTerminateResource( pResource );
        //  
        // No action if FM is shutting down
        //
        if ( FmpShutdown ) return;

        // Don't do anything.
        // However, if this is a quorum resource cause it to halt
        if (pResource->QuorumResource)
        {
            //cleanup quorum resource and cause the node to halt
            if (pResource->RestartAction == RestartNot)
            {
                FmpCleanupQuorumResource(pResource);
                CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            }            
        }
        
        break;


    case RestartLocal:
        // fall through is correct for this case
        bRestartGroup = FALSE;
    case RestartGroup:
        //
        // If the number of failures is too high, then don't restart locally.
        // If this was a local restart then don't notify FM so that Group
        // doesn't move because of this guy; otherwise notify the FM that the
        // group has failed.
        //
        //
        // Get our current time, in milliseconds.
        //
        tickCount = GetTickCount();

        //
        // Compute a boolean that tells if we are withing the allotted
        // failure period.
        //
        withinFailurePeriod = ( ((tickCount - pResource->FailureTime) <=
                                pResource->RestartPeriod) ? TRUE : FALSE);

        //
        // If it's been a long time since our last failure, then
        // get the current time of this failure, and reset the count
        // of failures.
        //
        if ( !withinFailurePeriod ) {
            pResource->FailureTime = tickCount;
            pResource->NumberOfFailures = 1;
        }
        if ( pResource->NumberOfFailures <= pResource->RestartThreshold ) 
        {
            FmpTerminateResource( pResource );
            //  
            // No restart if FM is shutting down or if the group is marked for a failover.
            //
            if ( ( FmpShutdown ) || 
                 ( pResource->Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) ) 
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[FM] FmpHandleResourceFailure: No restart tree on resource %1!ws!...\n",
                              OmObjectId(pResource));
                return;
            }

            FmpRestartResourceTree( pResource );
            pResource->Group->dwStructState |= FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT; 
            FmpCheckForGroupCompletionEvent(pResource->Group);
        } 

        else if ( bRestartGroup ) 
        {
            //  
            // No restart if FM is shutting down or if the group is marked for a failover.
            //
            if ( ( FmpShutdown ) || 
                 ( pResource->Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) ) 
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[FM] FmpHandleResourceFailure: No group failure handling for resource %1!ws!...\n",
                              OmObjectId(pResource));
                FmpTerminateResource( pResource );
                return;
            }

            //
            //  Handle the group failure and notify the resources if we decide to failover the
            //  group.
            //
            FmpHandleGroupFailure( pResource->Group, pResource );
            ClusterEvent( CLUSTER_EVENT_GROUP_FAILED, pResource->Group );
        } 
        else 
        {
            FmpTerminateResource( pResource );
            //  
            // No restart if FM is shutting down or if the group is marked for a failover.
            //
            if ( ( FmpShutdown ) || 
                 ( pResource->Group->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL ) ) 
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[FM] FmpHandleResourceFailure: No delayed restart on resource %1!ws!...\n",
                              OmObjectId(pResource));
                return;
            }

            ClRtlLogPrint(LOG_NOISE,
                       "[FM] RestartLocal: resource %1!ws! has exceeded its restart limit!\n",
                       OmObjectId(pResource));
            if (pResource->QuorumResource)
            {
                FmpCleanupQuorumResource(pResource);
                CsInconsistencyHalt(ERROR_QUORUM_RESOURCE_ONLINE_FAILED);
            }
            // Start a timer for which will attempt to restart the resource later
            FmpDelayedStartRes(pResource);
        }
        
        break;

    default:
        ClRtlLogPrint(LOG_NOISE,"[FM] FmpHandleResourceFailure: unknown restart action! Value = %1!u!\n",
            pResource->RestartAction);

    }

    return;

} // FmpHandleResourceFailure



VOID
FmpHandleResourceTransition(
    IN PFM_RESOURCE   Resource,
    IN CLUSTER_RESOURCE_STATE NewState
    )
/*++

Routine Description:

    Takes appropriate action based on resource state transitions indicated
    by the Resource Monitor.

Arguments:

    Resource   - The resource which has transitioned.

    NewState   - The new state of Resource.

Return Value:

    None.

--*/

{
    DWORD       status;
    DWORD       dwOldBlockingFlag;

ChkFMState:    
    ACQUIRE_SHARED_LOCK(gQuoChangeLock);
    if (!FmpFMGroupsInited)
    {
        DWORD   dwRetryCount = 50;
        

        //FmFormNewClusterPhaseProcessing is in progress
        if (FmpFMFormPhaseProcessing)
        {
     