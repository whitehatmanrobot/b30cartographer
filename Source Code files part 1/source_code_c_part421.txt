e, lstrlen(lpGPOName) + 1, lpGPOName);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpDate)
    {
        if (lpGPOName)
        {
            lpItem->lpDate = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
        }
        else
        {
            if (lpArgs)
            {
                lpItem->lpDate = lpItem->lpArgs + lstrlen (lpItem->lpArgs) + 1;
            }
            else
            {
                if (lpCommandLine)
                {
                    lpItem->lpDate = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
                }
                else
                {
                    lpItem->lpDate = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
                }
            }
        }

        hr = StringCchCopy (lpItem->lpDate, lstrlen(lpDate) + 1, lpDate);
        ASSERT(SUCCEEDED(hr));
    }

    //
    // Add item to the appropriate link list
    //

    switch (uiScriptType)
    {
        case 1:
            if (m_pRSOPLogon)
            {
                lpTemp = m_pRSOPLogon;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPLogon = lpItem;
            }
            break;

        case 2:
            if (m_pRSOPLogoff)
            {
                lpTemp = m_pRSOPLogoff;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPLogoff = lpItem;
            }
            break;

        case 3:
            if (m_pRSOPStartup)
            {
                lpTemp = m_pRSOPStartup;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPStartup = lpItem;
            }
            break;

        case 4:
            if (m_pRSOPShutdown)
            {
                lpTemp = m_pRSOPShutdown;

                while (lpTemp->pNext)
                {
                    lpTemp = lpTemp->pNext;
                }

                lpTemp->pNext = lpItem;
            }
            else
            {
                m_pRSOPShutdown = lpItem;
            }
            break;
    }

    return TRUE;
}


VOID CScriptsComponentData::FreeRSOPScriptData(VOID)
{
    LPRSOPSCRIPTITEM lpTemp;


    if (m_pRSOPLogon)
    {
        do {
            lpTemp = m_pRSOPLogon->pNext;
            LocalFree (m_pRSOPLogon);
            m_pRSOPLogon = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPLogoff)
    {
        do {
            lpTemp = m_pRSOPLogoff->pNext;
            LocalFree (m_pRSOPLogoff);
            m_pRSOPLogoff = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPStartup)
    {
        do {
            lpTemp = m_pRSOPStartup->pNext;
            LocalFree (m_pRSOPStartup);
            m_pRSOPStartup = lpTemp;

        } while (lpTemp);
    }

    if (m_pRSOPShutdown)
    {
        do {
            lpTemp = m_pRSOPShutdown->pNext;
            LocalFree (m_pRSOPShutdown);
            m_pRSOPShutdown = lpTemp;

        } while (lpTemp);
    }
}

HRESULT CScriptsComponentData::InitializeRSOPScriptsData(VOID)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pScriptList = NULL, pScript = NULL, pArgs = NULL, pExecutionTime = NULL;
    BSTR pGPOid = NULL, pNamespace = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2], *pObject;
    HRESULT hr;
    ULONG ulRet;
    VARIANT varScriptList, varScript, varArgs, varExecutionTime;
    VARIANT varGPOid;
    SAFEARRAY * pSafeArray;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    LPTSTR lpGPOName;
    TCHAR szQuery[200];
    UINT uiOrder, uiScriptType, uiIndex;
    LONG lIndex;
    IUnknown *pItem;



    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::InitializeRSOPScriptsData:  Entering")));

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pScriptList = SysAllocString (TEXT("scriptList"));

    if (!pScriptList)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for scriptList")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pGPOid = SysAllocString (TEXT("GPOID"));

    if (!pGPOid)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for GPO id")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pScript = SysAllocString (TEXT("script"));

    if (!pScript)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for script")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pArgs = SysAllocString (TEXT("arguments"));

    if (!pArgs)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for arguments")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pExecutionTime = SysAllocString (TEXT("executionTime"));

    if (!pExecutionTime)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for execution time")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pIWbemServices,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Exit;
    }

    //
    // We need to read two sets of data.  Either logon & logoff scripts
    // or startup & shutdown scripts.
    //

    for (uiIndex = 0; uiIndex < 2; uiIndex++)
    {

        //
        // Set the uiScriptType to the correct value.  These values are defined
        // in rsop.mof
        //

        if (m_bUserScope)
        {
            if (uiIndex == 0)
            {
                uiScriptType = 1;  //Logon
            }
            else
            {
                uiScriptType = 2;  //Logoff
            }
        }
        else
        {
            if (uiIndex == 0)
            {
                uiScriptType = 3;  //Startup
            }
            else
            {
                uiScriptType = 4;  //Shutdown
            }
        }


        //
        // Loop through the items bumping the order number by 1 each time
        //

        uiOrder = 1;


        while (TRUE)
        {

            //
            // Build the query
            //

            hr = StringCchPrintf (szQuery, ARRAYSIZE(szQuery), TEXT("SELECT * FROM RSOP_ScriptPolicySetting WHERE scriptType=\"%d\" AND scriptOrder=\"%d\""),
                      uiScriptType, uiOrder);
            
            ASSERT(SUCCEEDED(hr));

            pQuery = SysAllocString (szQuery);

            if (!pQuery)
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to allocate memory for query")));
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                goto Exit;
            }


            //
            // Execute the query
            //

            hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnum);


            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::InitializeRSOPScriptsData: Failed to query for %s with 0x%x"),
                          pQuery, hr));
                goto Exit;
            }


            //
            // Get the first (and only) item
            //

            hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);


            //
            // Check for the "data not available case"
            //

            if ((hr != S_OK) || (ulRet == 0))
            {
                pEnum->Release();
                pEnum = NULL;
                goto LoopAgain;
            }


            //
            // Get the scriptList
            //

            hr = pObjects[0]->Get (pScriptList, 0, &varScriptList, NULL, NULL);

            if (SUCCEEDED(hr))
            {

                //
                // Get the GPO ID
                //

                hr = pObjects[0]->Get (pGPOid, 0, &varGPOid, NULL, NULL);

                if (SUCCEEDED(hr))
                {

                    //
                    // Get the GPO friendly name from the GPOID
                    //

                    hr = GetGPOFriendlyName (pIWbemServices, varGPOid.bstrVal,
                                             pLanguage, &lpGPOName);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Loop through the script entries
                        //

                        pSafeArray = varScriptList.parray;

                        for (lIndex=0; lIndex < (LONG)pSafeArray->rgsabound[0].cElements; lIndex++)
                        {
                            SafeArrayGetElement (pSafeArray, &lIndex, &pItem);

                            hr = pItem->QueryInterface (IID_IWbemClassObject, (LPVOID *)&pObject);

                            if (SUCCEEDED(hr))
                            {

                                //
                                // Get the script command line
                                //

                                hr = pObject->Get (pScript, 0, &varScript, NULL, NULL);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Get the arguments
                                    //

                                    hr = pObject->Get (pArgs, 0, &varArgs, NULL, NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        TCHAR szDate[20];
                                        TCHAR szTime[20];
                                        TCHAR szBuffer[45] = {0};
                                        XBStr xbstrWbemTime;
                                        SYSTEMTIME SysTime;
                                        FILETIME FileTime, LocalFileTime;


                                        //
                                        // Get the execution time
                                        //

                                        hr = pObject->Get (pExecutionTime, 0, &varExecutionTime, NULL, NULL);

                                        if (SUCCEEDED(hr))
                                        {
                                            xbstrWbemTime = varExecutionTime.bstrVal;

                                            hr = WbemTimeToSystemTime(xbstrWbemTime, SysTime);

                                            if (SUCCEEDED(hr))
                                            {
                                                if (SysTime.wMonth != 0)
                                                {
                                                    SystemTimeToFileTime (&SysTime, &FileTime);
                                                    FileTimeToLocalFileTime (&FileTime, &LocalFileTime);
                                                    FileTimeToSystemTime (&LocalFileTime, &SysTime);

                                                    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                                                                   &SysTime, NULL, szDate, 20);

                                                    GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                                                   &SysTime, NULL, szTime, 20);

                                                    hr = StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%s %s"), szDate, szTime);
                                                }
                                                else
                                                {
                                                    hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), TEXT(" "));
                                                }
                                                ASSERT(SUCCEEDED(hr));
                                            }

                                            VariantClear (&varExecutionTime);
                                        }


                                        AddRSOPScriptDataNode(varScript.bstrVal,
                                                              (varArgs.vt == VT_NULL) ? NULL : varArgs.bstrVal,
                                                              lpGPOName, szBuffer, uiScriptType);

                                        VariantClear (&varArgs);
                                    }

                                    VariantClear (&varScript);
                                }

                                pObject->Release();
                            }
                        }

                        LocalFree (lpGPOName);
                    }

                    VariantClear (&varGPOid);
                }

                VariantClear (&varScriptList);
            }

            pEnum->Release();
            pEnum = NULL;
            pObjects[0]->Release();
            SysFreeString (pQuery);
            pQuery = NULL;
            uiOrder++;
        }

LoopAgain:
        hr = S_OK;
    }

    hr = S_OK;


Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pScriptList)
    {
        SysFreeString (pScriptList);
    }

    if (pScript)
    {
        SysFreeString (pScript);
    }

    if (pArgs)
    {
        SysFreeString (pArgs);
    }

    if (pExecutionTime)
    {
        SysFreeString (pExecutionTime);
    }

    if (pGPOid)
    {
        SysFreeString (pGPOid);
    }

    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::InitializeRSOPScriptsData:  Leaving")));

    return hr;
}

HRESULT CScriptsComponentData::GetGPOFriendlyName(IWbemServices *pIWbemServices,
                                                LPTSTR lpGPOID, BSTR pLanguage,
                                                LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;


    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //
    
    DWORD dwQryLen = (lstrlen(lpGPOID) + 50);
    lpQuery = (LPTSTR) LocalAlloc (LPTR, (dwQryLen * sizeof(TCHAR)));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hr = StringCchPrintf (lpQuery, dwQryLen, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);
    ASSERT(SUCCEEDED(hr));

    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    pObjects[0]->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    DWORD dwGPONameLen = lstrlen(varGPOName.bstrVal) + 1;
    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (dwGPONameLen) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hr = StringCchCopy (*pGPOName, dwGPONameLen, varGPOName.bstrVal);
    ASSERT(SUCCEEDED(hr));

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

VOID CScriptsComponentData::DumpRSOPScriptsData(LPRSOPSCRIPTITEM lpList)
{
    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::DumpRSOPScriptsData: *** Entering ***")));

    while (lpList)
    {
        if (lpList->lpCommandLine)
        {
            OutputDebugString (TEXT("Script:    "));
            OutputDebugString (lpList->lpCommandLine);

            if (lpList->lpArgs)
            {
                OutputDebugString (TEXT(" "));
                OutputDebugString (lpList->lpArgs);
            }

            OutputDebugString (TEXT("\n"));
        }
        else
           OutputDebugString (TEXT("NULL command line\n"));


        OutputDebugString (TEXT("GPO Name:  "));
        if (lpList->lpGPOName)
            OutputDebugString (lpList->lpGPOName);
        else
            OutputDebugString (TEXT("NULL GPO Name"));

        OutputDebugString (TEXT("\n"));

        OutputDebugString (TEXT("Execution Date:  "));
        if (lpList->lpDate)
            OutputDebugString (lpList->lpDate);
        else
            OutputDebugString (TEXT("NULL Execution Date"));

        OutputDebugString (TEXT("\n\n"));

        lpList = lpList->pNext;
    }

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsComponentDataCF::CScriptsComponentDataCF(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
}

CScriptsComponentDataCF::~CScriptsComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CScriptsComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CScriptsComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CScriptsComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CScriptsComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CScriptsComponentData *pComponentData = new CScriptsComponentData(m_bUserScope, m_bRSOP); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref
    return hr;
}


STDMETHODIMP
CScriptsComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateScriptsComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (IsEqualCLSID (rclsid, CLSID_ScriptSnapInMachine)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(FALSE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_ScriptSnapInUser)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(TRUE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPScriptSnapInMachine)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(FALSE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref
        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPScriptSnapInUser)) {

        CScriptsComponentDataCF *pComponentDataCF = new CScriptsComponentDataCF(TRUE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    return CLASS_E_CLASSNOTAVAILABLE;
}



unsigned int CScriptsSnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsSnapIn::CScriptsSnapIn(CScriptsComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumn1Size = 180;
    m_nColumn2Size = 180;
    m_nColumn3Size = 160;
    m_nColumn4Size = 200;
    m_lViewMode = LVS_REPORT;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
    LoadString(g_hInstance, IDS_PARAMETERS, m_column2, ARRAYSIZE(m_column2));
    LoadString(g_hInstance, IDS_LASTEXECUTED, m_column3, ARRAYSIZE(m_column3));
    LoadString(g_hInstance, IDS_GPONAME, m_column4, ARRAYSIZE(m_column4));

}

CScriptsSnapIn::~CScriptsSnapIn()
{
    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::Destroy(MMC_COOKIE cookie)
{
    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPSCRIPTDATAOBJECT pScriptDataObject;
            MMC_COOKIE cookie;
            INT i, iDescStringID;
            ULONG ulCount = 0;
            LPRSOPSCRIPTITEM lpTemp;
            LPSCRIPTRESULTITEM lpScriptItem;
            TCHAR szDesc[100], szFullDesc[120];

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pScriptDataObject->GetCookie(&cookie);

            pScriptDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumn1Size);

            if (cookie > 2)
            {
                m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, m_nColumn2Size);
                m_pHeader->InsertColumn(2, m_column3, LVCFMT_LEFT, m_nColumn3Size);
                m_pHeader->InsertColumn(3, m_column4, LVCFMT_LEFT, m_nColumn4Size);
            }

            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < m_pcd->m_pNameSpaceItems[cookie].cResultItems; i++)
            {
                lpScriptItem = (LPSCRIPTRESULTITEM) LocalAlloc (LPTR, sizeof(SCRIPTRESULTITEM));

                if (lpScriptItem)
                {
                    lpScriptItem->lpResultItem = &m_pcd->m_pNameSpaceItems[cookie].pResultItems[i];
                    lpScriptItem->iDescStringID = m_pcd->m_pNameSpaceItems[cookie].pResultItems[i].iDescStringID;
                    lpScriptItem->pNodeID = m_pcd->m_pNameSpaceItems[cookie].pNodeID;

                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = m_pcd->m_pNameSpaceItems[cookie].pResultItems[i].iImage;
                    resultItem.lParam = (LPARAM) lpScriptItem;
                    m_pResult->InsertItem(&resultItem);
                }
            }


            if (cookie > 2)
            {
                if (cookie == 3)
                {
                    lpTemp = m_pcd->m_pRSOPLogon;
                    iDescStringID = IDS_LOGON_DESC;
                }
                else if (cookie == 4)
                {
                    lpTemp = m_pcd->m_pRSOPLogoff;
                    iDescStringID = IDS_LOGOFF_DESC;
                }
                else if (cookie == 5)
                {
                    lpTemp = m_pcd->m_pRSOPStartup;
                    iDescStringID = IDS_STARTUP_DESC;
                }
                else
                {
                    lpTemp = m_pcd->m_pRSOPShutdown;
                    iDescStringID = IDS_SHUTDOWN_DESC;
                }


                while (lpTemp)
                {
                    lpScriptItem = (LPSCRIPTRESULTITEM) LocalAlloc (LPTR, sizeof(SCRIPTRESULTITEM));

                    if (lpScriptItem)
                    {
                        lpScriptItem->lpRSOPScriptItem = lpTemp;
                        lpScriptItem->iDescStringID = iDescStringID;
                        lpScriptItem->pNodeID = m_pcd->m_pNameSpaceItems[cookie].pNodeID;

                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;
                        resultItem.nImage = 3;
                        resultItem.lParam = (LPARAM) lpScriptItem;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            if (lpTemp->lpArgs)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 1;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }

                            if (lpTemp->lpDate)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 2;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }

                            if (lpTemp->lpGPOName)
                            {
                                resultItem.mask = RDI_STR | RDI_PARAM;
                                resultItem.str = MMC_CALLBACK;
                                resultItem.bScopeItem = FALSE;
                                resultItem.nCol = 3;
                                resultItem.lParam = (LPARAM) lpScriptItem;

                                m_pResult->SetItem(&resultItem);
                            }
                        }
                    }

                    lpTemp = lpTemp->pNext;
                    ulCount++;
                }


                LoadString(g_hInstance, IDS_DESCTEXT, szDesc, ARRAYSIZE(szDesc));
                (void) StringCchPrintf (szFullDesc, ARRAYSIZE(szFullDesc), szDesc, ulCount);
                m_pResult->SetDescBarText(szFullDesc);
            }

        }
        else
        {
            INT i = 0;
            RESULTDATAITEM resultItem;

            while (TRUE)
            {
                ZeroMemory (&resultItem, sizeof(resultItem));
                resultItem.mask = RDI_PARAM;
                resultItem.nIndex = i;
                hr = m_pResult->GetItem(&resultItem);
                if (hr != S_OK)
                {
                    break;
                }

                if (!resultItem.bScopeItem)
                {
                        LocalFree((LPSCRIPTRESULTITEM)(resultItem.lParam));
                        resultItem.lParam = NULL;
                }
                i++;
            }

            m_pResult->DeleteAllRsltItems();

            m_pHeader->GetColumnWidth(0, &m_nColumn1Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn2Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn3Size);
            m_pHeader->GetColumnWidth(0, &m_nColumn4Size);
            m_pResult->GetViewMode(&m_lViewMode);

            m_pResult->SetDescBarText(L"");
        }
        break;


    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPSCRIPTDATAOBJECT pScriptDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                break;

            pScriptDataObject->GetType(&type);
            pScriptDataObject->GetCookie(&cookie);

            pScriptDataObject->Release();


            //
            // If this is a GPE result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (type == CCT_SCOPE)
            {
                if (cookie == 0)
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                }
            }
            else
            {
                if (!m_pcd->m_bRSOP)
                {
                    if (HIWORD(arg))
                    {
                        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                    }
                }
            }

        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPSCRIPTDATAOBJECT pScriptDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;
            LPOLESTR pszHelpTopic;


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

            if (FAILED(hr))
                break;

            pScriptDataObject->Release();


            //
            // Display the scripts help page
            //
            
            DWORD dwHelpTopicLen = 50;
            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (dwHelpTopicLen * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                hr = StringCchCopy (pszHelpTopic, dwHelpTopicLen, TEXT("gpedit.chm::/Scripts.htm"));
                ASSERT(SUCCEEDED(hr));
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }


    return hr;
}

STDMETHODIMP CScriptsSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                    pResult->str = m_pcd->m_pNameSpaceItems[pResult->lParam].szDisplayName;
                else
                    pResult->str = L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = (pResult->lParam > 2) ? 0 : 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    if (m_pcd->m_bRSOP)
                    {
                        LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                        pResult->str = lpItem->lpRSOPScriptItem->lpCommandLine;
                    }
                    else
                    {
                        LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                        if (lpItem->lpResultItem->szDisplayName[0] == TEXT('\0'))
                        {
                            LoadString (g_hInstance, lpItem->lpResultItem->iStringID,
                                        lpItem->lpResultItem->szDisplayName,
                                        MAX_DISPLAYNAME_SIZE);
                        }

                        pResult->str = lpItem->lpResultItem->szDisplayName;
                    }
                }

                if (pResult->nCol == 1)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpArgs;
                }

                if (pResult->nCol == 2)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpDate;
                }

                if (pResult->nCol == 3)
                {
                    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) pResult->lParam;

                    pResult->str = lpItem->lpRSOPScriptItem->lpGPOName;
                }


                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CScriptsSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CScriptsSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CScriptsSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPSCRIPTDATAOBJECT pScriptDataObjectA, pScriptDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectB)))
    {
        pScriptDataObjectA->Release();
        return S_FALSE;
    }

    hr = CompareDataObjects(pScriptDataObjectA,pScriptDataObjectB);

    pScriptDataObjectA->Release();
    pScriptDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (IExtendPropertySheet)                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsSnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[2];
    LPSCRIPTDATAOBJECT pScriptDataObject;
    LPSCRIPTINFO lpScriptInfo;
    LPSCRIPTRESULTITEM pItem;
    MMC_COOKIE cookie;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pScriptDataObject->GetCookie(&cookie);
    pScriptDataObject->Release();


    pItem = (LPSCRIPTRESULTITEM)cookie;


    //
    // Allocate a script info struct to pass to the dialog
    //

    lpScriptInfo = (LPSCRIPTINFO) LocalAlloc (LPTR, sizeof(SCRIPTINFO));

    if (!lpScriptInfo)
    {
        return S_OK;
    }


    lpScriptInfo->pCS = this;


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) lpScriptInfo;


    //
    // Do the page specific stuff
    //

    switch (pItem->lpResultItem->dwID)
    {
        case 2:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Logon;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 3:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Logoff;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 4:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Startup;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

        case 5:
            psp.pszTemplate = MAKEINTRESOURCE(IDD_SCRIPT);
            psp.pfnDlgProc = ScriptDlgProc;
            lpScriptInfo->ScriptType = ScriptType_Shutdown;


            hPage[0] = CreatePropertySheetPage(&psp);

            if (hPage[0])
            {
                hr = lpProvider->AddPage(hPage[0]);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
            break;

    }


    return (hr);
}

STDMETHODIMP CScriptsSnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPSCRIPTDATAOBJECT pScriptDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IScriptDataObject,
                                               (LPVOID *)&pScriptDataObject)))
    {
        pScriptDataObject->GetType(&type);
        pScriptDataObject->Release();

        if ((type == CCT_RESULT) && (!m_pcd->m_bRSOP))
            return S_OK;
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsSnapIn object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CScriptsSnapIn::ScriptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSCRIPTINFO lpScriptInfo;
    HRESULT hr;


    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szType[30];
            TCHAR szSection[30];
            TCHAR szKeyName[30];
            TCHAR szGPOName[256];
            TCHAR szBuffer1[MAX_PATH + 50];
            TCHAR szBuffer2[2 * MAX_PATH];
            TCHAR szBuffer3[MAX_PATH];
            LPTSTR lpEnd;
            LVCOLUMN lvc;
            LV_ITEM item;
            HWND hLV;
            RECT rc;
            INT iIndex;


            //
            // Save the scriptinfo pointer for future use
            //

            lpScriptInfo = (LPSCRIPTINFO) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpScriptInfo);


            //
            // Query for the GPO display name
            //

            hr = lpScriptInfo->pCS->m_pcd->m_pGPTInformation->GetDisplayName(szGPOName, ARRAYSIZE(szGPOName));

            if (FAILED(hr))
                break;


            //
            // Load the type description
            //

            switch (lpScriptInfo->ScriptType)
            {
                case ScriptType_Logon:
                    LoadString (g_hInstance, IDS_LOGON, szType, ARRAYSIZE(szType));
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logon"));
                    break;

                case ScriptType_Logoff:
                    LoadString (g_hInstance, IDS_LOGOFF, szType, ARRAYSIZE(szType));
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logoff"));
                    break;

                case ScriptType_Startup:
                    LoadString (g_hInstance, IDS_STARTUP, szType, ARRAYSIZE(szType));
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Startup"));
                    break;

                case ScriptType_Shutdown:
                    LoadString (g_hInstance, IDS_SHUTDOWN, szType, ARRAYSIZE(szType));
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Shutdown"));
                    break;

                default:
                    DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::ScriptDlgProc: Unknown script type.")));
                    hr = E_FAIL;
                    break;
            }

            if (FAILED(hr))
                break;

            //
            // Initialize the title and header
            //

            GetDlgItemText (hDlg, IDC_SCRIPT_TITLE, szBuffer1, ARRAYSIZE(szBuffer1));
            hr = StringCchPrintf (szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1, szType, szGPOName);
            ASSERT(SUCCEEDED(hr));
            SetDlgItemText (hDlg, IDC_SCRIPT_TITLE, szBuffer2);

            GetDlgItemText (hDlg, IDC_SCRIPT_HEADING, szBuffer1, ARRAYSIZE(szBuffer1));
            hr = StringCchPrintf (szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1, szType, szGPOName);
            ASSERT(SUCCEEDED(hr));
            SetDlgItemText (hDlg, IDC_SCRIPT_HEADING, szBuffer2);


            //
            // Set initial state of buttons
            //

            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP),     FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN),   FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT),   FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), FALSE);


            //
            // Set extended LV styles
            //

            hLV = GetDlgItem (hDlg, IDC_SCRIPT_LIST);
            SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


            //
            // Insert the columns into the listview
            //

            GetClientRect (hLV, &rc);
            LoadString (g_hInstance, IDS_NAME, szBuffer1, ARRAYSIZE(szBuffer1));

            lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = (int)(rc.right * .50);
            lvc.pszText = szBuffer1;
            lvc.cchTextMax = ARRAYSIZE(szBuffer1);
            lvc.iSubItem = 0;

            SendMessage (hLV, LVM_INSERTCOLUMN,  0, (LPARAM) &lvc);


            LoadString (g_hInstance, IDS_PARAMETERS, szBuffer1, ARRAYSIZE(szBuffer1));

            lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = rc.right - lvc.cx;
            lvc.pszText = szBuffer1;
            lvc.cchTextMax = ARRAYSIZE(szBuffer1);
            lvc.iSubItem = 0;

            SendMessage (hLV, LVM_INSERTCOLUMN,  1, (LPARAM) &lvc);


            //
            // Insert existing scripts
            //

            hr = StringCchCopy (szBuffer1, ARRAYSIZE(szBuffer1), lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
            ASSERT(SUCCEEDED(hr));
          
            hr = StringCchCat (szBuffer1, ARRAYSIZE(szBuffer1), TEXT("\\"));
            ASSERT(SUCCEEDED(hr));
            
            hr = StringCchCat (szBuffer1, ARRAYSIZE(szBuffer1), SCRIPTS_FILE_NAME);
            ASSERT(SUCCEEDED(hr));

            iIndex = 0;

            while (TRUE)
            {

                //
                // Get the command line
                //

                szBuffer3[0] = TEXT('\0');

                _itot (iIndex, szKeyName, 10);
                lpEnd = szKeyName + lstrlen (szKeyName);
                hr = StringCchCopy (lpEnd, ARRAYSIZE(szKeyName) - (lpEnd - szKeyName), TEXT("CmdLine"));
                ASSERT(SUCCEEDED(hr));

                GetPrivateProfileString (szSection, szKeyName, TEXT(""),
                                         szBuffer3, ARRAYSIZE(szBuffer3),
                                         szBuffer1);

                if (szBuffer3[0] == TEXT('\0'))
                    break;


                //
                // Get the parameters
                //

                szBuffer2[0] = TEXT('\0');
                hr = StringCchCopy (lpEnd, ARRAYSIZE(szKeyName) - (lpEnd - szKeyName), TEXT("Parameters"));
                ASSERT(SUCCEEDED(hr));

                GetPrivateProfileString (szSection, szKeyName, TEXT(""),
                                         szBuffer2, ARRAYSIZE(szBuffer2),
                                         szBuffer1);

                //
                // Add script to the list
                //

                lpScriptInfo->pCS->AddScriptToList (hLV, szBuffer3, szBuffer2);


                //
                // Loop again
                //

                iIndex++;
            }

            //
            // Select the first item
            //

            item.mask = LVIF_STATE;
            item.iItem = 0;
            item.iSubItem = 0;
            item.state = LVIS_SELECTED | LVIS_FOCUSED;
            item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

            SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);


            break;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_SCRIPT_UP)
            {
                INT iSrc, iDest;
                LPSCRIPTITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LVITEM item;

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc - 1;

                    //
                    // Get the current lpScriptItem pointers
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPSCRIPTITEM) item.lParam;

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPSCRIPTITEM) item.lParam;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);


                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iDest, iSrc);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);

                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_DOWN)
            {
                INT iSrc, iDest;
                LPSCRIPTITEM lpSrc, lpDest;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LVITEM item;

                iSrc = ListView_GetNextItem (hLV, -1,
                                             LVNI_ALL | LVNI_SELECTED);

                if (iSrc != -1)
                {
                    iDest = iSrc + 1;

                    //
                    // Get the current lpScriptItem pointers
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpSrc = (LPSCRIPTITEM) item.lParam;

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpDest = (LPSCRIPTITEM) item.lParam;


                    //
                    // Swap them
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpDest;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }

                    item.mask = LVIF_PARAM;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.lParam = (LPARAM)lpSrc;

                    if (!ListView_SetItem (hLV, &item))
                    {
                        break;
                    }


                    //
                    // Select the item
                    //

                    item.mask = LVIF_STATE;
                    item.iItem = iSrc;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iSrc, (LPARAM) &item);


                    item.mask = LVIF_STATE;
                    item.iItem = iDest;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iDest, (LPARAM) &item);


                    //
                    // Update the listview
                    //

                    ListView_RedrawItems (hLV, iSrc, iDest);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);


                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_ADD)
            {
                SCRIPTEDITINFO info;
                TCHAR szName[MAX_PATH];
                TCHAR szArgs[2 * MAX_PATH];

                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }

                szName[0] = TEXT('\0');
                szArgs[0] = TEXT('\0');

                info.lpScriptInfo = lpScriptInfo;
                info.bEdit = FALSE;
                info.lpName = szName;
                info.lpArgs = szArgs;

                if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_SCRIPT_EDIT),
                                    hDlg, ScriptEditDlgProc, (LPARAM) &info))
                {
                    if (lpScriptInfo->pCS->AddScriptToList (GetDlgItem(hDlg, IDC_SCRIPT_LIST),
                                                           szName, szArgs))
                    {
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (GetDlgItem(hDlg, IDC_SCRIPT_LIST));
                    }
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_EDIT)
            {
                SCRIPTEDITINFO info;
                TCHAR szName[MAX_PATH];
                TCHAR szArgs[2 * MAX_PATH];
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                INT iIndex;
                LPSCRIPTITEM lpItem;
                LVITEM item;
                DWORD dwSize;


                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }


                //
                // Get the selected item
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {

                    //
                    // Get the script item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSCRIPTITEM) item.lParam;


                    //
                    // Put up the edit script dialog
                    //

                    hr = StringCchCopy (szName, ARRAYSIZE(szName), lpItem->lpName);
                    ASSERT(SUCCEEDED(hr));
                    
                    hr = StringCchCopy (szArgs, ARRAYSIZE(szArgs), lpItem->lpArgs);
                    ASSERT(SUCCEEDED(hr));

                    info.lpScriptInfo = lpScriptInfo;
                    info.bEdit = TRUE;
                    info.lpName = szName;
                    info.lpArgs = szArgs;

                    if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_SCRIPT_EDIT),
                                        hDlg, ScriptEditDlgProc, (LPARAM) &info))
                    {

                        //
                        // Free old pointer
                        //

                        LocalFree(lpItem);
                        lpItem = NULL;

                        //
                        // Setup new pointer
                        //

                        dwSize = sizeof(SCRIPTITEM);
                        dwSize += ((lstrlen(szName) + 1) * sizeof(TCHAR));
                        dwSize += ((lstrlen(szArgs) + 1) * sizeof(TCHAR));

                        lpItem = (LPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

                        if (!lpItem)
                            break;


                        lpItem->lpName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(SCRIPTITEM));
                        hr = StringCchCopy (lpItem->lpName, (lstrlen(szName) + 1), szName);
                        ASSERT(SUCCEEDED(hr));

                        lpItem->lpArgs = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
                        hr = StringCchCopy (lpItem->lpArgs, (lstrlen(szArgs) + 1), szArgs);
                        ASSERT(SUCCEEDED(hr));


                        //
                        // Set the new script item pointer
                        //

                        item.mask = LVIF_PARAM;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.lParam = (LPARAM) lpItem;

                        if (!ListView_SetItem (hLV, &item))
                        {
                            break;
                        }


                        //
                        // Update the display
                        //

                        ListView_Update (hLV, iIndex);
                        SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                        SetFocus (GetDlgItem(hDlg, IDC_SCRIPT_LIST));
                    }
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_REMOVE)
            {
                INT iIndex, iNext;
                HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);
                LPSCRIPTITEM lpItem;
                LVITEM item;


                //
                // Get the selected item
                //

                iIndex = ListView_GetNextItem (hLV, -1, LVNI_ALL | LVNI_SELECTED);

                if (iIndex != -1)
                {

                    //
                    // Get the script item pointer
                    //

                    item.mask = LVIF_PARAM;
                    item.iItem = iIndex;
                    item.iSubItem = 0;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSCRIPTITEM) item.lParam;


                    //
                    // Select the next item
                    //

                    iNext = ListView_GetNextItem (hLV, iIndex, LVNI_ALL);

                    item.mask = LVIF_STATE;
                    item.iItem = iNext;
                    item.iSubItem = 0;
                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                    SendMessage (hLV, LVM_SETITEMSTATE, iNext, (LPARAM) &item);

                    ListView_DeleteItem (hLV, iIndex);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    SetFocus (hLV);
                }
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_SHOW)
            {
                TCHAR szPath[MAX_PATH];
                LPTSTR lpEnd;

                lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpScriptInfo) {
                    break;
                }

                hr = StringCchCopy (szPath, ARRAYSIZE(szPath), lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
                if (FAILED(hr))
                    break;

                lpEnd = CheckSlash (szPath);

                switch (lpScriptInfo->ScriptType)
                {
                    case ScriptType_Logon:
                        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Logon"));
                        break;

                    case ScriptType_Logoff:
                        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Logoff"));
                        break;

                    case ScriptType_Startup:
                        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Startup"));
                        break;

                    case ScriptType_Shutdown:
                        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Shutdown"));
                        break;
                }

                if (FAILED(hr))
                    break;

                SetCursor (LoadCursor(NULL, IDC_WAIT));
                ShellExecute (hDlg, TEXT("open"), szPath,
                              NULL, NULL, SW_SHOWNORMAL);
                SetCursor (LoadCursor(NULL, IDC_ARROW));
            }
            break;

        case WM_NOTIFY:

            lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpScriptInfo) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case LVN_GETDISPINFO:
                    {
                        NMLVDISPINFO * lpDispInfo = (NMLVDISPINFO *) lParam;
                        LPSCRIPTITEM lpItem = (LPSCRIPTITEM)lpDispInfo->item.lParam;

                        if (lpDispInfo->item.iSubItem == 0)
                        {
                            lpDispInfo->item.pszText = lpItem->lpName;
                        }
                        else
                        {
                            lpDispInfo->item.pszText = lpItem->lpArgs;
                        }
                    }
                    break;

                case LVN_DELETEITEM:
                    {
                    NMLISTVIEW * pLVInfo = (NMLISTVIEW *) lParam;

                    if (pLVInfo->lParam)
                    {
                        LocalFree ((LPTSTR)pLVInfo->lParam);
                        pLVInfo->lParam = NULL;
                    }

                    }
                    break;

                case LVN_ITEMCHANGED:
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    break;

                case PSN_APPLY:
                    lpScriptInfo->pCS->OnApplyNotify (hDlg);

                    // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_REFRESHDISPLAY:
            {
            INT iIndex, iCount;
            HWND hLV = GetDlgItem(hDlg, IDC_SCRIPT_LIST);


            lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpScriptInfo) {
                break;
            }

            iIndex = ListView_GetNextItem (hLV, -1,
                                           LVNI_ALL | LVNI_SELECTED);

            if (iIndex != -1)
            {
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT), TRUE);

                iCount = ListView_GetItemCount(hLV);

                if (iIndex > 0)
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), TRUE);
                else
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), FALSE);

                if (iIndex < (iCount - 1))
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), TRUE);
                else
                    EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), FALSE);
            }
            else
            {
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_REMOVE), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_EDIT), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_UP), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_SCRIPT_DOWN), FALSE);
            }

            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aScriptsHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aScriptsHelpIds);
            return (TRUE);
    }

    return FALSE;
}

BOOL CScriptsSnapIn::AddScriptToList (HWND hLV, LPTSTR lpName, LPTSTR lpArgs)
{
    LPSCRIPTITEM lpItem;
    LV_ITEM item;
    INT iItem;
    DWORD dwSize;
    HRESULT hr = S_OK;

    dwSize = sizeof(SCRIPTITEM);
    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpArgs) + 1) * sizeof(TCHAR));

    lpItem = (LPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
        return FALSE;


    lpItem->lpName = (LPTSTR) (((LPBYTE)lpItem) + sizeof(SCRIPTITEM));
    hr = StringCchCopy (lpItem->lpName, (lstrlen(lpName) + 1), lpName);
    ASSERT(SUCCEEDED(hr));

    lpItem->lpArgs = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
    hr = StringCchCopy (lpItem->lpArgs, (lstrlen(lpArgs) + 1), lpArgs);
    ASSERT(SUCCEEDED(hr));

    //
    // Add the item
    //

    iItem = ListView_GetItemCount(hLV);
    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    item.iItem = iItem;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam = (LPARAM) lpItem;

    ListView_InsertItem (hLV, &item);

    return TRUE;
}

LPTSTR CScriptsSnapIn::GetSectionNames (LPTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpNames;


    //
    // Read in the section names
    //

    dwSize = 256;
    lpNames = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!lpNames)
    {
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSectionNames (lpNames, dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        LocalFree (lpNames);
        lpNames = NULL;

        dwSize *= 2;
        lpNames = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

        if (!lpNames)
        {
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        LocalFree (lpNames);
        lpNames = NULL;
    }

    return lpNames;
}

BOOL CScriptsSnapIn::OnApplyNotify (HWND hDlg)
{
    HWND hLV = GetDlgItem (hDlg, IDC_SCRIPT_LIST);
    WIN32_FILE_ATTRIBUTE_DATA fad;
    LVITEM item;
    LPSCRIPTITEM lpItem;
    LPSCRIPTINFO lpScriptInfo;
    INT iIndex = -1;
    TCHAR szSection[30];
    TCHAR szKeyName[30];
    TCHAR szBuffer1[MAX_PATH];
    LPTSTR lpEnd, lpNames;
    BOOL bAdd = TRUE;
    INT i = 0;
    HANDLE hFile;
    DWORD dwWritten;
    GUID guidScriptsExt = { 0x42B5FAAE, 0x6536, 0x11d2, {0xAE, 0x5A, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xE3}};
    GUID guidSnapinMach = CLSID_ScriptSnapInMachine;
    GUID guidSnapinUser = CLSID_ScriptSnapInUser;
    HRESULT hr = S_OK;
    XLastError xe;

    lpScriptInfo = (LPSCRIPTINFO) GetWindowLongPtr (hDlg, DWLP_USER);

    if (!lpScriptInfo) {
        return FALSE;
    }


    //
    // Get the section name
    //

    switch (lpScriptInfo->ScriptType)
    {
        case ScriptType_Logon:
            hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logon"));
            ASSERT(SUCCEEDED(hr));
            break;

        case ScriptType_Logoff:
            hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logoff"));
            ASSERT(SUCCEEDED(hr));
            break;

        case ScriptType_Startup:
            hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Startup"));
            ASSERT(SUCCEEDED(hr));
            break;

        case ScriptType_Shutdown:
            hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Shutdown"));
            ASSERT(SUCCEEDED(hr));
            break;

        default:
            return FALSE;
    }


    //
    // Build pathname to scripts ini file
    //

    hr = StringCchCopy (szBuffer1, ARRAYSIZE(szBuffer1), lpScriptInfo->pCS->m_pcd->m_pScriptsDir);
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    hr = StringCchCat (szBuffer1, ARRAYSIZE(szBuffer1), TEXT("\\"));
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }
    
    hr = StringCchCat (szBuffer1, ARRAYSIZE(szBuffer1), SCRIPTS_FILE_NAME);
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    //
    // If the scripts.ini file does not exist, then precreate the file
    // using Unicode text so that the WritePrivateProfile* functions
    // preserve the Unicodeness of the file
    //

    if (!GetFileAttributesEx (szBuffer1, GetFileExInfoStandard, &fad))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            hFile = CreateFile(szBuffer1, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
                CloseHandle(hFile);
            }
        }
    }


    //
    // Delete the old information in the section
    //

    if (!WritePrivateProfileSection(szSection, NULL, szBuffer1))
    {
        TCHAR szTitle[50];
        TCHAR szTmpBuffer1[200],szTmpBuffer2[220];

        DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to delete previous %s section in ini file with %d"),
                 szSection, GetLastError()));

        LoadString (g_hInstance, IDS_SCRIPTS_NAME, szTitle, ARRAYSIZE(szTitle));
        LoadString (g_hInstance, IDS_SAVEFAILED, szTmpBuffer1, ARRAYSIZE(szTmpBuffer1));
        hr = StringCchPrintf (szTmpBuffer2, ARRAYSIZE(szTmpBuffer2), szTmpBuffer1, GetLastError());
        ASSERT(SUCCEEDED(hr));

        MessageBox (hDlg, szTmpBuffer2, szTitle, MB_OK | MB_ICONERROR);

        return FALSE;
    }


    //
    // Enumerate through the items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex, LVNI_ALL)) != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpItem = (LPSCRIPTITEM) item.lParam;

        _itot (i, szKeyName, 10);
        lpEnd = szKeyName + lstrlen (szKeyName);
        hr = StringCchCopy (lpEnd, ARRAYSIZE(szKeyName) - (lpEnd - szKeyName), TEXT("CmdLine"));
        ASSERT(SUCCEEDED(hr));

        if (!WritePrivateProfileString (szSection, szKeyName, lpItem->lpName, szBuffer1))
        {
            DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to save command line in ini file with %d"),
                     GetLastError()));
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szKeyName) - (lpEnd - szKeyName), TEXT("Parameters"));
        ASSERT(SUCCEEDED(hr));

        if (!WritePrivateProfileString (szSection, szKeyName, lpItem->lpArgs, szBuffer1))
        {
            if (lpItem->lpArgs && (*lpItem->lpArgs))
            {
                DebugMsg((DM_WARNING, TEXT("CScriptsSnapIn::OnApplyNotify: Failed to save parameters in ini file with %d"),
                         GetLastError()));
            }
        }

        i++;
    }


    //
    // If we didn't write any command lines to scripts.ini,
    // then check if our counterpart is also empty.  If so,
    // we can remove the scripts extension from the GPO
    //

    if (i == 0)
    {
        BOOL bFound =  FALSE;

        lpNames = GetSectionNames (szBuffer1);

        if (lpNames)
        {

            //
            // Reverse the section name we are looking for
            //

            switch (lpScriptInfo->ScriptType)
            {
                case ScriptType_Logon:
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logoff"));
                    ASSERT(SUCCEEDED(hr));
                    break;

                case ScriptType_Logoff:
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Logon"));
                    ASSERT(SUCCEEDED(hr));
                    break;

                case ScriptType_Startup:
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Shutdown"));
                    ASSERT(SUCCEEDED(hr));
                    break;

                case ScriptType_Shutdown:
                    hr = StringCchCopy (szSection, ARRAYSIZE(szSection), TEXT("Startup"));
                    ASSERT(SUCCEEDED(hr));
                    break;

                default:
                    return FALSE;
            }


            //
            // See if the opposite name is in the list of names returned
            //

            lpEnd = lpNames;

            while (*lpEnd)
            {
                if (!lstrcmpi (lpEnd, szSection))
                {
                    bFound = TRUE;
                    break;
                }

                lpEnd = lpEnd + lstrlen (lpEnd);
            }

            if (!bFound)
            {
                bAdd = FALSE;
            }

            LocalFree (lpNames);
            lpNames = NULL;
        }
        else
        {
            bAdd = FALSE;
        }
    }

    SetFileAttributes (szBuffer1, FILE_ATTRIBUTE_HIDDEN);

    m_pcd->m_pGPTInformation->PolicyChanged( !m_pcd->m_bUserScope,
                                             bAdd,
                                             &guidScriptsExt,
                                             m_pcd->m_bUserScope ? &guidSnapinUser
                                                                 : &guidSnapinMach);

    return TRUE;
}


INT_PTR CALLBACK CScriptsSnapIn::ScriptEditDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSCRIPTEDITINFO lpInfo;
    HRESULT hr;
    XLastError xe;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            //
            // Save the ScriptEditInfo pointer for future use
            //

            lpInfo = (LPSCRIPTEDITINFO) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpInfo);
            EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);

            if (lpInfo->bEdit)
            {
                TCHAR szTitle[100];

                LoadString (g_hInstance, IDS_SCRIPT_EDIT, szTitle, ARRAYSIZE(szTitle));
                SetWindowText (hDlg, szTitle);

                SetDlgItemText (hDlg, IDC_SCRIPT_NAME, lpInfo->lpName);
                SetDlgItemText (hDlg, IDC_SCRIPT_ARGS, lpInfo->lpArgs);
            }

            break;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                lpInfo = (LPSCRIPTEDITINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpInfo) {
                    break;
                }

                lpInfo->lpName[0] = TEXT('\0');
                GetDlgItemText (hDlg, IDC_SCRIPT_NAME, lpInfo->lpName, MAX_PATH);

                lpInfo->lpArgs[0] = TEXT('\0');
                GetDlgItemText (hDlg, IDC_SCRIPT_ARGS, lpInfo->lpArgs, 2 * MAX_PATH);

                EndDialog (hDlg, TRUE);
                return TRUE;
            }

            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog (hDlg, FALSE);
                return TRUE;
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_BROWSE)
            {
                OPENFILENAME ofn;
                TCHAR szFilter[100];
                TCHAR szTitle[100];
                TCHAR szFile[MAX_PATH];
                TCHAR szPath[MAX_PATH];
                LPTSTR lpTemp, lpEnd;
                DWORD dwStrLen;

                lpInfo = (LPSCRIPTEDITINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpInfo) {
                    break;
                }

                hr = StringCchCopy (szPath, ARRAYSIZE(szPath), lpInfo->lpScriptInfo->pCS->m_pcd->m_pScriptsDir);

                if (FAILED(hr))
                {
                    xe = HRESULT_CODE(hr);
                    return FALSE;
                }

                lpEnd = CheckSlash (szPath);

                switch (lpInfo->lpScriptInfo->ScriptType)
                {
                    case ScriptType_Logon:
                        hr =  StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Logon"));
                        if (FAILED(hr))
                        {
                            xe = HRESULT_CODE(hr);
                            return FALSE;
                        }

                        break;

                    case ScriptType_Logoff:
                        hr =  StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Logoff"));
                        if (FAILED(hr))
                        {
                            xe = HRESULT_CODE(hr);
                            return FALSE;
                        }
                        
                        break;

                    case ScriptType_Startup:
                        hr =  StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Startup"));
                        if (FAILED(hr))
                        {
                            xe = HRESULT_CODE(hr);
                            return FALSE;
                        }
                        
                        break;

                    case ScriptType_Shutdown:
                        hr =  StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("Shutdown"));
                        if (FAILED(hr))
                        {
                            xe = HRESULT_CODE(hr);
                            return FALSE;
                        }
                        
                        break;
                }


                //
                // Prompt for the script file
                //

                LoadString (g_hInstance, IDS_SCRIPT_FILTER, szFilter, ARRAYSIZE(szFilter));
                LoadString (g_hInstance, IDS_BROWSE, szTitle, ARRAYSIZE(szTitle));


                lpTemp = szFilter;

                while (*lpTemp)
                {
                    if (*lpTemp == TEXT('#'))
                        *lpTemp = TEXT('\0');

                    lpTemp++;
                }

                ZeroMemory (&ofn, sizeof(ofn));
                szFile[0] = TEXT('\0');
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = hDlg;
                ofn.hInstance = g_hInstance;
                ofn.lpstrFilter = szFilter;
                ofn.nFilterIndex = 2;
                ofn.lpstrFile = szFile;
                ofn.nMaxFile = ARRAYSIZE(szFile);
                ofn.lpstrInitialDir = szPath;
                ofn.lpstrTitle = szTitle;
                ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;

                if (!GetOpenFileName (&ofn))
                {
                    return FALSE;
                }

                dwStrLen = lstrlen (szPath);

                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                   szPath, dwStrLen, szFile, dwStrLen) == 2)
                    SetDlgItemText (hDlg, IDC_SCRIPT_NAME, (szFile + dwStrLen + 1));
                else
                    SetDlgItemText (hDlg, IDC_SCRIPT_NAME, szFile);
            }

            else if (LOWORD(wParam) == IDC_SCRIPT_NAME)
            {
                if (HIWORD(wParam) == EN_UPDATE)
                {
                    if (GetWindowTextLength (GetDlgItem(hDlg, IDC_SCRIPT_NAME)))
                        EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
                    else
                        EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                }
            }

            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aScriptsEditHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aScriptsEditHelpIds);
            return (TRUE);
    }

    return FALSE;
}


unsigned int CScriptsDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CScriptsDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CScriptsDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CScriptsDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CScriptsDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CScriptsDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CScriptsDataObject::CScriptsDataObject(CScriptsComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
    m_cookiePrevRes = NULL;
}

CScriptsDataObject::~CScriptsDataObject()
{
    FreeResultItem((LPSCRIPTRESULTITEM) m_cookiePrevRes);
    m_cookiePrevRes = NULL;
    m_pcd->Release();
        
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IScriptDataObject))
    {
        *ppv = (LPSCRIPTDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (IDataObject)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[200];

            if (m_type == CCT_SCOPE)
            {
                LoadString (g_hInstance, m_pcd->m_pNameSpaceItems[m_cookie].iDescStringID, szDesc, ARRAYSIZE(szDesc));
            }
            else
            {
                LPSCRIPTRESULTITEM lpScriptItem = (LPSCRIPTRESULTITEM) m_cookie;

                LoadString (g_hInstance, lpScriptItem->iDescStringID, szDesc, ARRAYSIZE(szDesc));
            }

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if ((m_type == CCT_RESULT) && !m_pcd->m_bRSOP)
        {
            if (lpMedium->tymed == TYMED_ISTREAM)
            {
                ULONG ulWritten;

                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }
    return hr;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsDataObject object implementation (Internal functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CScriptsDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CScriptsDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
    {
        pGUID = lpItem->pNodeID;
    }
    else
        pGUID = m_pcd->m_pNameSpaceItems[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CScriptsDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPSCRIPTRESULTITEM lpItem = (LPSCRIPTRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = lpItem->pNodeID;
    else
        pGUID = m_pcd->m_pNameSpaceItems[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CScriptsDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[100] = {0};

    if (m_pcd->m_bUserScope)
        LoadStringW (g_hInstance, IDS_SCRIPTS_NAME_USER, szDisplayName, 100);
    else
        LoadStringW (g_hInstance, IDS_SCRIPTS_NAME_MACHINE, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CScriptsDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&CLSID_ScriptSnapInUser, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_ScriptSnapInMachine, sizeof(CLSID), lpMedium);
}



BOOL InitScriptsNameSpace()
{
    DWORD dwIndex;

    for (dwIndex = 1; dwIndex < ARRAYSIZE(g_GPEScriptsNameSpace); dwIndex++)
    {
        LoadString (g_hInstance, g_GPEScriptsNameSpace[dwIndex].iStringID,
                    g_GPEScriptsNameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }

    for (dwIndex = 1; dwIndex < ARRAYSIZE(g_RSOPScriptsNameSpace); dwIndex++)
    {
        LoadString (g_hInstance, g_RSOPScriptsNameSpace[dwIndex].iStringID,
                    g_RSOPScriptsNameSpace[dwIndex].szDisplayName,
                    MAX_DISPLAYNAME_SIZE);
    }


    return TRUE;
}

const TCHAR szThreadingModel[] = TEXT("Apartment");

HRESULT RegisterScriptExtension (REFGUID clsid, UINT uiStringId, REFGUID rootID, LPTSTR lpSnapInNameIndirect)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwValue;
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;

    //
    // First register the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);

    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, uiStringId, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)g_szSnapInLocation,
                   (lstrlen(g_szSnapInLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)lpSnapInNameIndirect,
                   (lstrlen(lpSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (rootID, szGUID, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    ASSERT(SUCCEEDED(hr));
    
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);


    return S_OK;
}

const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");

HRESULT RegisterNodeID (REFGUID clsid, REFGUID nodeid)
{
    TCHAR szSnapInKey[50];
    TCHAR szGUID[50];
    TCHAR szSubKey[200];
    DWORD dwDisp;
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;

    StringFromGUID2 (clsid, szSnapInKey, 50);
    StringFromGUID2 (nodeid, szGUID, 50);

    //
    // Register the node id
    //

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
              szSnapInKey, szGUID);
    ASSERT(SUCCEEDED(hr));
    
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register in the NodeTypes key
    //

    StringFromGUID2 (nodeid, szGUID, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);

    //
    // Register for the view extension
    //

    hr = StringCchCat (szSubKey, ARRAYSIZE(szSubKey), TEXT("\\Extensions\\View"));
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                   (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    return S_OK;
}

HRESULT RegisterScripts(void)
{
    DWORD dwDisp, dwValue;
    LONG lResult;
    HKEY hKey;
    HRESULT hr;
    TCHAR szSnapInName[100];


    //
    // Register the GPE machine extension and it's root node
    //

    hr = RegisterScriptExtension (CLSID_ScriptSnapInMachine, IDS_SCRIPTS_NAME_MACHINE,
                                  NODEID_Machine, TEXT("@gptext.dll,-2"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_ScriptSnapInMachine, NODEID_ScriptRootMachine);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the GPE user extension and it's root node
    //

    hr = RegisterScriptExtension (CLSID_ScriptSnapInUser, IDS_SCRIPTS_NAME_USER,
                                  NODEID_User, TEXT("@gptext.dll,-3"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_ScriptSnapInUser, NODEID_ScriptRootUser);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the RSOP machine extension and it's nodes
    //

    hr = RegisterScriptExtension (CLSID_RSOPScriptSnapInMachine, IDS_SCRIPTS_NAME_MACHINE,
                                  NODEID_RSOPMachine, TEXT("@gptext.dll,-2"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPScriptRootMachine);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPStartup);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPShutdown);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the RSOP user extension and it's nodes
    //

    hr = RegisterScriptExtension (CLSID_RSOPScriptSnapInUser, IDS_SCRIPTS_NAME_USER,
                                  NODEID_RSOPUser, TEXT("@gptext.dll,-3"));

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPScriptRootUser);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPLogon);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = RegisterNodeID (CLSID_RSOPScriptSnapInUser, NODEID_RSOPLogoff);

    if (hr != S_OK)
    {
        return hr;
    }


    //
    // Register the client side extension
    //

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }


    LoadString (g_hInstance, IDS_SCRIPTS_NAME, szSnapInName, 100);
    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegSetValueEx (hKey, TEXT("ProcessGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("ProcessScriptsGroupPolicy"),
                   (lstrlen(TEXT("ProcessScriptsGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessScriptsGroupPolicyEx"),
                   (lstrlen(TEXT("ProcessScriptsGroupPolicyEx")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateScriptsGroupPolicy"),
                   (lstrlen(TEXT("GenerateScriptsGroupPolicy")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("gptext.dll"),
                   (lstrlen(TEXT("gptext.dll")) + 1) * sizeof(TCHAR));

    dwValue = 1;
    RegSetValueEx (hKey, TEXT("NoSlowLink"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegSetValueEx (hKey, TEXT("NotifyLinkTransition"), 0, REG_DWORD, (LPBYTE)&dwValue,
                   sizeof(dwValue));

    RegCloseKey (hKey);


    return S_OK;
}

HRESULT UnregisterScriptExtension (REFGUID clsid, REFGUID RootNodeID)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;
    HRESULT hr = S_OK;

    StringFromGUID2 (clsid, szSnapInKey, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (RootNodeID, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    ASSERT(SUCCEEDED(hr));


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}

HRESULT UnregisterScripts(void)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;
    HRESULT hr = S_OK;

    //
    // Unregister the GPE machine extension
    //

    UnregisterScriptExtension (CLSID_ScriptSnapInMachine, NODEID_Machine);

    StringFromGUID2 (NODEID_ScriptRootMachine, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the GPE user extension
    //

    UnregisterScriptExtension (CLSID_ScriptSnapInUser, NODEID_User);

    StringFromGUID2 (NODEID_ScriptRootUser, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the RSOP machine extension
    //

    UnregisterScriptExtension (CLSID_RSOPScriptSnapInMachine, NODEID_RSOPMachine);

    StringFromGUID2 (NODEID_RSOPScriptRootMachine, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPStartup, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPShutdown, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the RSOP user extension
    //

    UnregisterScriptExtension (CLSID_RSOPScriptSnapInUser, NODEID_RSOPUser);

    StringFromGUID2 (NODEID_RSOPScriptRootUser, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPLogon, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (NODEID_RSOPLogoff, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);


    //
    // Unregister the client side extension
    //

    RegDeleteKey (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"));


    return S_OK;
}

//=============================================================================
//
//  This is the client side extension for scripts which gathers the
//  working directories and stores them in the registry.
//

DWORD AddPathToList(LPTSTR *lpDirs, LPTSTR lpPath)
{
    LPTSTR lpTemp, lpTemp2;
    DWORD dwSize, dwResult = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    DebugMsg((DM_VERBOSE, TEXT("AddPathToList: Adding <%s> to list."), lpPath));

    lpTemp = *lpDirs;

    if (lpTemp)
    {
        dwSize = lstrlen (lpTemp);      // size of original paths
        dwSize++;                       // space for a semicolon
        dwSize += lstrlen (lpPath);     // size of new path
        dwSize++;                       // space for a null terminator


        lpTemp2 = (LPTSTR) LocalReAlloc (lpTemp, (dwSize * sizeof(TCHAR)), LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (lpTemp2)
        {
            hr = StringCchCat (lpTemp2, dwSize, TEXT(";"));
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat (lpTemp2, dwSize, lpPath);
            ASSERT(SUCCEEDED(hr));

            *lpDirs = lpTemp2;
        }
        else
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AddPathToList: Failed to allocate memory with %d."), dwResult));
        }
    }
    else
    {
        dwSize = lstrlen(lpPath) + 1;
        lpTemp = (LPTSTR)LocalAlloc (LPTR, (dwSize) * sizeof(TCHAR));

        if (lpTemp)
        {
            hr = StringCchCopy (lpTemp, dwSize, lpPath);
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AddPathToList: Failed to allocate memory with %d."), dwResult));
        }

        *lpDirs = lpTemp;
    }

    return dwResult;
}

DWORD
ProcessScripts( DWORD dwFlags,
                HANDLE hToken,
                HKEY hKeyRoot,
                PGROUP_POLICY_OBJECT pDeletedGPOList,
                PGROUP_POLICY_OBJECT pChangedGPOList,
                BOOL *pbAbort,
                BOOL bRSoPPlanningMode,
                IWbemServices* pWbemServices,
                HRESULT*       phrRsopStatus );

DWORD ProcessScriptsGroupPolicy (DWORD dwFlags, HANDLE hToken, HKEY hKeyRoot,
                                PGROUP_POLICY_OBJECT pDeletedGPOList,
                                PGROUP_POLICY_OBJECT pChangedGPOList,
                                ASYNCCOMPLETIONHANDLE pHandle, BOOL *pbAbort,
                                PFNSTATUSMESSAGECALLBACK pStatusCallback)
{
    HRESULT hrRSoPStatus = 0;
    return ProcessScripts(  dwFlags,
                            hToken,
                            hKeyRoot,
                            pDeletedGPOList,
                            pChangedGPOList,
                            pbAbort,
                            FALSE,
                            0,
                            &hrRSoPStatus );
}

DWORD ProcessScriptsGroupPolicyEx(  DWORD                       dwFlags,
                                    HANDLE                      hToken,
                                    HKEY                        hKeyRoot,
                                    PGROUP_POLICY_OBJECT        pDeletedGPOList,
                                    PGROUP_POLICY_OBJECT        pChangedGPOList,
                                    ASYNCCOMPLETIONHANDLE       pHandle,
                                    BOOL*                       pbAbort,
                                    PFNSTATUSMESSAGECALLBACK    pStatusCallback,
                                    IWbemServices*              pWbemServices,
                                    HRESULT*                    phrRsopStatus )
{
    *phrRsopStatus = S_OK;

    return ProcessScripts(  dwFlags,
                            hToken,
                            hKeyRoot,
                            pDeletedGPOList,
                            pChangedGPOList,
                            pbAbort,
                            FALSE,
                            pWbemServices,
                            phrRsopStatus );
}

DWORD GenerateScriptsGroupPolicy(   DWORD dwFlags,
                                    BOOL *pbAbort,
                                    WCHAR *pwszSite,
                                    PRSOP_TARGET pMachTarget,
                                    PRSOP_TARGET pUserTarget )
{
    DWORD dwResult = ERROR_SUCCESS;
    HRESULT hrRSoPStatus = 0;

    if ( pMachTarget )
    {
        //
        // log machine scripts
        //

        dwResult = ProcessScripts(  dwFlags | GPO_INFO_FLAG_MACHINE,
                                    (HANDLE)pMachTarget->pRsopToken,
                                    0,
                                    0,
                                    pMachTarget->pGPOList,
                                    pbAbort,
                                    TRUE,
                                    pMachTarget->pWbemServices,
                                    &hrRSoPStatus );
        if ( dwResult != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, L"GenerateScriptPolicy: could not log machine scripts, error %d", dwResult));
        }
    }

    if ( pUserTarget )
    {
        //
        // log user scripts
        //

        dwResult = ProcessScripts(  dwFlags & ~GPO_INFO_FLAG_MACHINE,
                                    (HANDLE)pUserTarget->pRsopToken,
                                    0,
                                    0,
                                    pUserTarget->pGPOList,
                                    pbAbort,
                                    TRUE,
                                    pUserTarget->pWbemServices,
                                    &hrRSoPStatus );
        if ( dwResult != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, L"GenerateScriptPolicy: could not log user scripts, error %d", dwResult ));
        }
    }
    
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\util.cpp ===
#include "gptext.h"
#include <strsafe.h>
#define  PCOMMON_IMPL
#include "pcommon.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;

    //
    // Make a copy of the subkey so we can write to it.
    //

    hr = StringCchCopy (szDelKey, ARRAYSIZE(szDelKey), lpSubKey);
    
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}

//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary.
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr = S_OK;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    hr = StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), lpDirectory);
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        return 0; 
    }

    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

/*******************************************************************

        NAME:           StringToNum

        SYNOPSIS:       Converts string value to numeric value

        NOTES:          Calls atoi() to do conversion, but first checks
                                for non-numeric characters

        EXIT:           Returns TRUE if successful, FALSE if invalid
                                (non-numeric) characters

********************************************************************/
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal)
{
        TCHAR *pTst = pszStr;

        if (!pszStr) return FALSE;

        // verify that all characters are numbers
        while (*pTst) {
                if (!(*pTst >= TEXT('0') && *pTst <= TEXT('9'))) {
//                   if (*pTst != TEXT('-'))
                       return FALSE;
                }
                pTst = CharNext(pTst);
        }

        *pnVal = _ttoi(pszStr);

        return TRUE;
}

//*************************************************************
//
//  ImpersonateUser()
//
//  Purpose:    Impersonates the specified user
//
//  Parameters: hToken - user to impersonate
//
//  Return:     hToken  if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser)
{

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, hOldUser)) {
        *hOldUser = NULL;
    }

    if (!ImpersonateLoggedOnUser(hNewUser))
    {
        if ( *hOldUser )
        {
            CloseHandle( *hOldUser );
            *hOldUser = NULL;
        }
        DebugMsg((DM_WARNING, TEXT("ImpersonateUser: Failed to impersonate user with %d."), GetLastError()));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  RevertToUser()
//
//  Purpose:    Revert back to original user
//
//  Parameters: hUser  -  original user token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RevertToUser (HANDLE *hUser)
{

    BOOL bRet = SetThreadToken(NULL, *hUser);

    if (*hUser) {
        CloseHandle (*hUser);
        *hUser = NULL;
    }

    return bRet;
}

//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid, CompareGuid()
//
//  Purpose:    Guid utility functions
//
//*************************************************************

//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//

#define GUID_LENGTH 38


void GuidToString( GUID *pGuid, TCHAR * szValue )
{
    (void) StringCchPrintf( szValue,
                            GUID_LENGTH + 1,
                            TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
                            pGuid->Data1,
                            pGuid->Data2,
                            pGuid->Data3,
                            pGuid->Data4[0], pGuid->Data4[1],
                            pGuid->Data4[2], pGuid->Data4[3],
                            pGuid->Data4[4], pGuid->Data4[5],
                            pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}



INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}


////////////////////////////////////////////////////////////////////////////
//                                                                        //
//  HRESULT IsFilePresent ()                                              //
//                                                                        //
//  Purpose: Checks if a file of a pirticular format                      //
//          is present in a given directory                               //
//                                                                        //
//  Returns: S_OK if such file is present                                 //
//           S_FALSE  otherwise                                           //  
//                                                                        //
////////////////////////////////////////////////////////////////////////////


HRESULT IsFilePresent (WCHAR *szDirName, WCHAR *szFormat)
{
    WCHAR      szPath[MAX_PATH];
    HANDLE     hFile;
    DWORD      dwError;
    HRESULT    hr;
    WIN32_FIND_DATA fd;

    hr = StringCchCopy (szPath, ARRAYSIZE(szPath), szDirName);
    if (FAILED(hr)) 
    {
        return hr;
    }

    (void) CheckSlash(szPath);

    hr = StringCchCat (szPath, ARRAYSIZE(szPath), szFormat);
    if (FAILED(hr)) 
    {
        return hr;
    }

    hFile = FindFirstFile (szPath, &fd);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        return S_OK;
    }

    dwError = GetLastError();
    if (ERROR_FILE_NOT_FOUND == dwError) 
    {
        return S_FALSE;
    }

    return HRESULT_FROM_WIN32(GetLastError());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\wirelessext.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <iadsp.h>
extern "C"{
#include "wlrsop.h"
}
#include "wirelessext.h"
#include "SmartPtr.h"
#include "wbemtime.h"
#include <adsopenflags.h>
#include <strsafe.h>

#define GPEXT_PATH  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{0ACDD40C-75AC-47ab-BAA0-BF6DE7E7FE63}")
#define POLICY_PATH   TEXT("Software\\Policies\\Microsoft\\Windows\\Wireless\\GPTWirelessPolicy")

LPWSTR GetWirelessAttributes[] = {L"msieee80211-ID", L"cn", L"description"}; 


HRESULT
RegisterWireless(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString (g_hInstance, IDS_WIRELESS_NAME, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicyEx"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessWIRELESSPolicyEx"),
                (lstrlen(TEXT("ProcessWIRELESSPolicyEx")) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("GenerateGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("GenerateWIRELESSPolicy"),
                (lstrlen(TEXT("GenerateWIRELESSPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    (void) StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);
    return S_OK;
}


HRESULT
UnregisterWireless(void)
{
    DWORD dwError = 0;

    dwError = RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return HRESULT_FROM_WIN32(dwError);
}

DWORD
ProcessWIRELESSPolicyEx(
    DWORD dwFlags,                           // GPO_INFO_FLAGS
    HANDLE hToken,                           // User or machine token
    HKEY hKeyRoot,                           // Root of registry
    PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    BOOL *pbAbort,                           // If true, then abort GPO processing
    PFNSTATUSMESSAGECALLBACK pStatusCallback,// Callback function for displaying status messages
    IWbemServices *pWbemServices,            // Pointer to namespace to log diagnostic mode data
                                             // Note, this will be NULL when Rsop logging is disabled
    HRESULT      *pRsopStatus                // RSOP Logging succeeded or not.
    )

{
    
    // Call ProcessWIRELESSPolicy & get path -> polstore funcs
    LPWSTR pszWIRELESSPolicyPath = NULL;
    WCHAR szWIRELESSPolicyName[MAX_PATH];    //policy name
    WCHAR szWIRELESSPolicyDescription[512];  //policy descr
    WCHAR szWIRELESSPolicyID[512];  //policy descr
    HRESULT hr = S_OK;
    PGROUP_POLICY_OBJECT pGPO = NULL;
    GPO_INFO GPOInfo;

    //validate the args.

    if (!pRsopStatus) {
        return(E_INVALIDARG);
        }

    //
    // Call CoInitialize for all the COM work we're doing
    //
    hr = CoInitializeEx(NULL,0);
    if (FAILED(hr)) {
        goto error;
    }

    memset(szWIRELESSPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szWIRELESSPolicyDescription, 0, sizeof(WCHAR)*512);
    memset(szWIRELESSPolicyID, 0, sizeof(WCHAR)*512);

    // First process the Deleted GPO List. If there is a single
    // entry on the GPO list, just delete the entire list.
    // Example Rex->Cassius->Brutus. If the delete List has
    // Cassius to be deleted, then really, we shouldn't be deleting
    // our registry entry because we're interested in Brutus which
    // has not be deleted. But in our case, the pChangedGPOList will
    // have all the information, so Brutus gets written back in the
    // next stage.
    //
    if (pDeletedGPOList) {
        DeleteWirelessPolicyFromRegistry();
        //
        //  Also Clear WMI store if no GPO's applied and logging enabled
        //
        
        if (!pChangedGPOList && pWbemServices) {
            hr = WirelessClearWMIStore(
                    pWbemServices
                    );
            if (FAILED(hr)) {
                    goto error;
            }
            DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx: WIRELESS WMI store cleared") );
        }

    }
    
    if(pChangedGPOList) {

        DWORD dwNumGPO = 0;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            dwNumGPO++;

            //
            // Write only the last, highest precedence policy to registry
            //
            if(pGPO->pNext == NULL) {
                hr = RetrieveWirelessPolicyFromDS(
                    pGPO,
                    &pszWIRELESSPolicyPath,
                    szWIRELESSPolicyName,
                    ARRAYSIZE(szWIRELESSPolicyName),
                    szWIRELESSPolicyDescription,
                    ARRAYSIZE(szWIRELESSPolicyDescription),
                    szWIRELESSPolicyID,
                    ARRAYSIZE(szWIRELESSPolicyID)
                    );
                if (FAILED(hr)) {
                    goto success; // WMI store still consistent
                }

                hr = WriteWirelessPolicyToRegistry(
                    pszWIRELESSPolicyPath,
                    szWIRELESSPolicyName,
                    szWIRELESSPolicyDescription,
                    szWIRELESSPolicyID
                    );

                if (pszWIRELESSPolicyPath) {
                    LocalFree(pszWIRELESSPolicyPath);
                    pszWIRELESSPolicyPath = NULL;
                    }
                if (FAILED(hr)) {
                    goto success; // WMI store still consistent
                }
            }
        }
        DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx: dwNumGPO: %d", dwNumGPO) );

        // Write WMI log if logging enabled
        if (pWbemServices) {
            DWORD dwPrecedence = dwNumGPO;
            for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
                hr = RetrieveWirelessPolicyFromDS(
                    pGPO,
                    &pszWIRELESSPolicyPath,
                    szWIRELESSPolicyName,
                    ARRAYSIZE(szWIRELESSPolicyName),
                    szWIRELESSPolicyDescription,
                    ARRAYSIZE(szWIRELESSPolicyDescription),
                    szWIRELESSPolicyID,
                    ARRAYSIZE(szWIRELESSPolicyID)
                    );
                if (FAILED(hr)) {
                    goto error;
                }

                LPWSTR pszWIRELESSPolicy = pszWIRELESSPolicyPath + wcslen(L"LDAP://");
                DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx: pszWIRELESSPolicy: %s", pszWIRELESSPolicy) );

                (VOID) CreateWlstoreGPOInfo(
                           pGPO,
                           dwPrecedence--,
                           dwNumGPO,
                           &GPOInfo
                           );

                hr = WirelessWriteDirectoryPolicyToWMI(
                    0, //pszMachineName
                    pszWIRELESSPolicy,
                    &GPOInfo,
                    pWbemServices
                    );
                (VOID) FreeWlstoreGPOInfo(&GPOInfo);

                if (pszWIRELESSPolicyPath) {
                    LocalFree(pszWIRELESSPolicyPath);
                    pszWIRELESSPolicyPath = NULL;
                    }
                
                if (FAILED(hr)) {
                    DebugMsg( (DM_WARNING, L"WIRELESSext::ProcessWIRELESSPolicyEx: WirelessWriteDirectoryPolicyToWMI failed: 0x%x", hr) );
                    goto error;
                }
            }
        }
    }
    
    DebugMsg( (DM_WARNING, L"wirelessext::ProcessWIRELESSPolicyEx completed") );
    
    PingWirelessPolicyAgent();
    CoUninitialize();

success:    
    *pRsopStatus = S_OK;
    return(ERROR_SUCCESS);
    
error:

    /* Cannot Result in a double delete becuase, 
      whenever we free, we set the pszWirelessPolicyPath to NULL
      so that freeing happens only once 
      */
      
    if (pszWIRELESSPolicyPath) {
                    LocalFree(pszWIRELESSPolicyPath);
                    pszWIRELESSPolicyPath = NULL;
                    }
    
    *pRsopStatus = hr;
    return(ERROR_POLICY_OBJECT_NOT_FOUND);

}

DWORD 
GenerateWIRELESSPolicy(   
    DWORD dwFlags,
    BOOL *pbAbort,
    WCHAR *pwszSite,
    PRSOP_TARGET pMachTarget,
    PRSOP_TARGET pUserTarget 
    )
{

    // Call ProcessWIRELESSPolicy & get path -> polstore funcs
    LPWSTR pszWIRELESSPolicyPath = NULL;  // policy Path 
    WCHAR szWIRELESSPolicyName[MAX_PATH];    //policy name
    WCHAR szWIRELESSPolicyDescription[512];  //policy descr
    WCHAR szWIRELESSPolicyID[512];  //policy descr
    HRESULT hr = S_OK;
    PGROUP_POLICY_OBJECT pGPO = NULL;
    GPO_INFO GPOInfo;


    //
    // Call CoInitialize for all the COM work we're doing
    //
    hr = CoInitializeEx(NULL,0);
    if (FAILED(hr)) {
        goto error;
    }

    memset(szWIRELESSPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szWIRELESSPolicyDescription, 0, sizeof(WCHAR)*512);
    memset(szWIRELESSPolicyID, 0, sizeof(WCHAR)*512);
    
    ////start
    PGROUP_POLICY_OBJECT  pChangedGPOList = NULL;
    IWbemServices *pWbemServices;
    
    if(pMachTarget) {
        pChangedGPOList = pMachTarget->pGPOList;
        pWbemServices = pMachTarget->pWbemServices;
    }

    if(pUserTarget) {
        pChangedGPOList = pUserTarget->pGPOList;
        pWbemServices = pUserTarget->pWbemServices;
    }

    if(pChangedGPOList) {

        DWORD dwNumGPO = 0;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            dwNumGPO++;
        }
        DebugMsg( (DM_WARNING, L"wirelessext::GenerateWIRELESSPolicy: dwNumGPO: %d", dwNumGPO) );
        
        DWORD dwPrecedence = dwNumGPO;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            hr = RetrieveWirelessPolicyFromDS(
                pGPO,
                &pszWIRELESSPolicyPath,
                szWIRELESSPolicyName,
                ARRAYSIZE(szWIRELESSPolicyName),
                szWIRELESSPolicyDescription,
                ARRAYSIZE(szWIRELESSPolicyDescription),
                szWIRELESSPolicyID,
                ARRAYSIZE(szWIRELESSPolicyID)
                );
            if (FAILED(hr)) {
                goto error;
            }
            
            LPWSTR pszWIRELESSPolicy = pszWIRELESSPolicyPath + wcslen(L"LDAP://");
            DebugMsg( (DM_WARNING, L"wirelessext::GenerateWIRELESSPolicy: pszWIRELESSPolicy: %s", pszWIRELESSPolicy) );

            (VOID) CreateWlstoreGPOInfo(
                       pGPO,
                       dwPrecedence--,
                       dwNumGPO,
                       &GPOInfo
                       );

            hr = WirelessWriteDirectoryPolicyToWMI(
                0, //pszMachineName
                pszWIRELESSPolicy,
                &GPOInfo,
                pWbemServices
                );
            (VOID) FreeWlstoreGPOInfo(&GPOInfo);

            if (pszWIRELESSPolicyPath) {
                    LocalFree(pszWIRELESSPolicyPath);
                    pszWIRELESSPolicyPath = NULL;
                    }

            if (FAILED(hr)) {
                DebugMsg( (DM_WARNING, L"wirelessext::GenerateWIRELESSPolicy: WirelessWriteDirectoryPolicyToWMI failed: 0x%x", hr) );
                goto error;
            }

        }
    }
    
    DebugMsg( (DM_WARNING, L"wirelessext::GenerateWIRELESSPolicy completed") );
    
    CoUninitialize();
    
    return(ERROR_SUCCESS);
    
error:

    /* Cannot Result in a double delete becuase, 
      whenever we free, we set the pszWirelessPolicyPath to NULL
      so that freeing happens only once 
      */
      
    if (pszWIRELESSPolicyPath) {
                    LocalFree(pszWIRELESSPolicyPath);
                    pszWIRELESSPolicyPath = NULL;
                    }
    
    return(ERROR_POLICY_OBJECT_NOT_FOUND);

}

HRESULT
CreateWlstoreGPOInfo(
    PGROUP_POLICY_OBJECT pGPO,
    UINT32 uiPrecedence,
    UINT32 uiTotalGPOs,
    PGPO_INFO pGPOInfo
    )
{
  XBStr xbstrCurrentTime;
  HRESULT hr;
    
  memset(pGPOInfo, 0, sizeof(GPO_INFO));
  
  pGPOInfo->uiPrecedence = uiPrecedence;
  pGPOInfo->uiTotalGPOs = uiTotalGPOs;
  pGPOInfo->bsGPOID = SysAllocString(
                         StripPrefixWireless(pGPO->lpDSPath)
                         );
  pGPOInfo->bsSOMID = SysAllocString(
                         StripLinkPrefixWireless(pGPO->lpLink)
                         );
  // (Failing safe above by ignoring mem alloc errors)
  hr = GetCurrentWbemTime(xbstrCurrentTime);
  if ( FAILED (hr) ) {
      pGPOInfo->bsCreationtime = 0;
  }
  else {
      pGPOInfo->bsCreationtime = xbstrCurrentTime.Acquire();
  }

  return S_OK;
}


HRESULT
FreeWlstoreGPOInfo(
    PGPO_INFO pGPOInfo
    )
{
    if (pGPOInfo && pGPOInfo->bsCreationtime) {
        SysFreeString(pGPOInfo->bsCreationtime);
    }
    if (pGPOInfo && pGPOInfo->bsGPOID) {
        SysFreeString(pGPOInfo->bsGPOID);
    }
    if (pGPOInfo && pGPOInfo->bsSOMID) {
        SysFreeString(pGPOInfo->bsSOMID);
    }


    return S_OK;
}


HRESULT
CreateWirelessChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(pszParentPath, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->AddLeafElement(pszChildComponent);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);

error:
    if (pPathname) {
        pPathname->Release();
    }

    return(hr);
}



HRESULT
RetrieveWirelessPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR *ppszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    DWORD  dwWirelessPolicyNameLen,
    LPWSTR pszWirelessPolicyDescription,
    DWORD  dwWirelessPolicyDescLen,
    LPWSTR pszWirelessPolicyID,
    DWORD  dwWirelessPolicyIDLen
    )
{
    LPWSTR pszMachinePath = NULL;
    BSTR pszMicrosoftPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszWirelessPath = NULL;
    BSTR pszLocWirelessPolicy = NULL;
    IDirectoryObject * pDirectoryObject = NULL;
    IDirectoryObject * pWirelessObject = NULL;
    IDirectorySearch * pWirelessSearch = NULL;
    BOOL bFound = FALSE;
    ADS_SEARCH_HANDLE hSearch;
    ADS_SEARCH_COLUMN col;
    WCHAR pszLocName[MAX_PATH+10]; // We need to store only CN=, in additon to the name.
    LPWSTR pszWirelessPolicyPath = NULL;
    DWORD dwWirelessPolicyPathLen = 0;
    DWORD dwError = 0;

    LPWSTR pszOwnersReference = L"wifiOwnersReference";

    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttributeEntries = NULL;
    DWORD dwNumAttributesReturned = 0;

    DWORD i = 0;
    PADS_ATTR_INFO pAttributeEntry = NULL;



    pszMachinePath = pGPOInfo->lpDSPath;

    // Build the fully qualified ADsPath for my object

    hr = CreateWirelessChildPath(
                pszMachinePath,
                L"cn=Microsoft",
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateWirelessChildPath(
                pszMicrosoftPath,
                L"cn=Windows",
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateWirelessChildPath(
                pszWindowsPath,
                L"cn=Wireless",
                &pszWirelessPath
                );
    BAIL_ON_FAILURE(hr);

    hr = AdminToolsOpenObject(
        pszWirelessPath,
        NULL,
        NULL,
        ADS_SECURE_AUTHENTICATION,
        IID_IDirectorySearch,
       (void **)&pWirelessSearch
       );
    BAIL_ON_FAILURE(hr);

    hr = pWirelessSearch->ExecuteSearch(
        L"(&(objectClass=msieee80211-Policy))", GetWirelessAttributes, 3, &hSearch );
    if (!SUCCEEDED(hr)) {
        pWirelessSearch->CloseSearchHandle(hSearch);
    BAIL_ON_FAILURE(hr);
    }

    hr = pWirelessSearch->GetNextRow(hSearch);
    if (!SUCCEEDED(hr)) {
        pWirelessSearch->CloseSearchHandle(hSearch);
    BAIL_ON_FAILURE(hr);
    }

    hr = pWirelessSearch->GetColumn(hSearch, L"cn", &col);    
    if (!SUCCEEDED(hr)) {
    pWirelessSearch->CloseSearchHandle(hSearch);
    BAIL_ON_FAILURE(hr);
    }

    if (col.dwADsType != ADSTYPE_CASE_IGNORE_STRING) {
        DebugMsg((DM_ASSERT, L"wirelessext::RetrievePolicyFromDS: cn NOT adstype_case_ignore_string"));
        pWirelessSearch->FreeColumn(&col);
        pWirelessSearch->CloseSearchHandle(hSearch);
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    hr = StringCchCopy(pszWirelessPolicyName, dwWirelessPolicyNameLen, col.pADsValues->CaseIgnoreString);
    BAIL_ON_FAILURE(hr);

    pWirelessSearch->FreeColumn(&col);

    pWirelessSearch->CloseSearchHandle(hSearch);

    hr = StringCchCopy(pszLocName, ARRAYSIZE(pszLocName), L"\0");
    ASSERT(SUCCEEDED(hr));

    hr = StringCchCopy(pszLocName, ARRAYSIZE(pszLocName), L"CN=");
    ASSERT(SUCCEEDED(hr));
    
    hr = StringCchCat(pszLocName, ARRAYSIZE(pszLocName), pszWirelessPolicyName);
    BAIL_ON_FAILURE(hr);

    hr = CreateWirelessChildPath(
                pszWirelessPath,
                pszLocName,
                &pszLocWirelessPolicy
                );
    BAIL_ON_FAILURE(hr);

    hr = AdminToolsOpenObject(
        pszLocWirelessPolicy,
        NULL,
        NULL,
        ADS_SECURE_AUTHENTICATION,
        IID_IDirectoryObject,
       (void **)&pWirelessObject
       );
    BAIL_ON_FAILURE(hr);

    hr = pWirelessObject->GetObjectAttributes(
                        GetWirelessAttributes,
                        3,
                        &pAttributeEntries,
                        &dwNumAttributesReturned
                        );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributesReturned == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // Process the PathName
    //

    
    //
    // Process the ID
    //
    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"msieee80211-ID")) {
            hr = StringCchCopy(pszWirelessPolicyID, dwWirelessPolicyIDLen, pAttributeEntry->pADsValues->DNString);
            BAIL_ON_FAILURE(hr);
            bFound = TRUE;
            break;
        }
    }
    if (!bFound) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    
    //
    // Process the description
    //
    
    hr = StringCchCopy(pszWirelessPolicyDescription, dwWirelessPolicyDescLen, L"\0");
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"description")) {
            hr = StringCchCopy(pszWirelessPolicyDescription, dwWirelessPolicyDescLen, pAttributeEntry->pADsValues->DNString);
            BAIL_ON_FAILURE(hr);
            break;
        }
    }

    dwWirelessPolicyPathLen = wcslen(pszLocWirelessPolicy);
    pszWirelessPolicyPath = (LPWSTR) LocalAlloc(
        LPTR, 
        sizeof(WCHAR) * (dwWirelessPolicyPathLen+1)
        );

    if (!pszWirelessPolicyPath) {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        }
   BAIL_ON_FAILURE(hr);

    memset(pszWirelessPolicyPath, 0, sizeof(WCHAR) * (dwWirelessPolicyPathLen+1));
    hr = StringCchCopy(pszWirelessPolicyPath, dwWirelessPolicyPathLen+1, pszLocWirelessPolicy);
    BAIL_ON_FAILURE(hr);

    *ppszWirelessPolicyPath = pszWirelessPolicyPath;


error:

    if (pszLocWirelessPolicy) {
        SysFreeString(pszLocWirelessPolicy);
    }

    if (pszWirelessPath) {
        SysFreeString(pszWirelessPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    return(hr);

}


DWORD
DeleteWirelessPolicyFromRegistry(
    )
{

    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwDisp = 0;


    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Policies\\Microsoft\\Windows\\Wireless"),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    dwError = RegDeleteKey(
                    hKey,
                    L"GPTWirelessPolicy"
                    );

/*
    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSWIRELESSPolicyPath")
                    );

    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSWIRELESSPolicyName")
                    );*/
error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);
}

DWORD
WriteWirelessPolicyToRegistry(
    LPWSTR pszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    )
{
    DWORD dwError = 0;
    DWORD dwDisp = 0;
    HKEY hKey = NULL;
    DWORD dwFlags = 1;

    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    POLICY_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    if (pszWirelessPolicyPath && *pszWirelessPolicyPath) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyPath"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyPath,
                       (lstrlen(pszWirelessPolicyPath) + 1) * sizeof(TCHAR)
                       );

        dwFlags = 1;

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyFlags"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFlags,
                        sizeof(dwFlags)
                       );

    }


    if (pszWirelessPolicyName && *pszWirelessPolicyName) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyName"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyName,
                       (lstrlen(pszWirelessPolicyName) + 1) * sizeof(TCHAR)
                       );
    }

    if (pszWirelessPolicyID && *pszWirelessPolicyID) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("WirelessID"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyID,
                       (lstrlen(pszWirelessPolicyID) + 1) * sizeof(TCHAR)
                       );
    }





    if (pszWirelessPolicyDescription && *pszWirelessPolicyDescription) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSWirelessPolicyDescription"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszWirelessPolicyDescription,
                       (lstrlen(pszWirelessPolicyDescription) + 1) * sizeof(TCHAR)
                       );
    }

error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);

}


VOID
PingWirelessPolicyAgent(
    )
{
    HANDLE hPolicyChangeEvent = NULL;

    hPolicyChangeEvent = OpenEvent(
                             EVENT_ALL_ACCESS,
                             FALSE,
                             L"WIRELESS_POLICY_CHANGE_EVENT"
                             );

    if (hPolicyChangeEvent) {
        SetEvent(hPolicyChangeEvent);
        CloseHandle(hPolicyChangeEvent);
    }
}

//
// Prefix stripping functions copied from 
// gina\userenv\rsop\logger.cpp written by SitaramR
//

//*************************************************************
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: lpGPOInfo     - Gpo Info
//              pWbemServices - Wbem services
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripPrefixWireless( WCHAR *pwszPath )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Gpo
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iUserPrefixLen;
    } else if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iMachPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}


//*************************************************************
//
//  StripLinkPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to DS
//              object
//
//  Parameters: pwszPath - path to strip
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripLinkPrefixWireless( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\wirelessext.h ===
HRESULT
CreateWirelessChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    );

HRESULT
RetrieveWirelessPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR *ppszWirelessPolicy,
    LPWSTR pszWirelessPolicyName,
    DWORD  dwWirelessPolicyNameLen,
    LPWSTR pszWirelessPolicyDescription,
    DWORD  dwWirelessPolicyDescLen,
    LPWSTR pszWirelessPolicyID,
    DWORD  dwWirelessPolicyIDLen
    );


DWORD
DeleteWirelessPolicyFromRegistry(
    );

DWORD
WriteWirelessPolicyToRegistry(
    LPWSTR pszWirelessPolicyPath,
    LPWSTR pszWirelessPolicyName,
    LPWSTR pszWirelessPolicyDescription,
    LPWSTR pszWirelessPolicyID
    );


HRESULT
RegisterWireless(void);

HRESULT
UnregisterWireless(void);

VOID
PingWirelessPolicyAgent(
    );

WCHAR *
StripPrefixWireless(
    WCHAR *pwszPath
    );

WCHAR *
StripLinkPrefixWireless(
    WCHAR *pwszPath
    );
    
HRESULT
CreateWlstoreGPOInfo(
    PGROUP_POLICY_OBJECT pGPO,
    UINT32 uiPrecedence,
    UINT32 uiTotalGPOs,
    PGPO_INFO pGPOInfo
    );

HRESULT
FreeWlstoreGPOInfo(
    PGPO_INFO pGPOInfo
    );


#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) { \
        goto error;  \
    }

#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\inc\gpedit.h ===
//-----------------------------------------------------------------------------
//
// GPEDIT.H - Definitions and prototypes for Group Policy
//
// Copyright 1997-2000, Microsoft Corporation
//
//-----------------------------------------------------------------------------

//
// Terminology
//
// Group Policy Editor  -  The tool to view a Group Policy Object.
//
// Group Policy Object  -  A collection of administrator defined policies.
//                         Each Group Policy Object (GPO) has both file system
//                         and Active Directory storage available to it.
//
// IGPEInformation      -  The interface MMC Snapin Extensions use to
//                         talk to the Group Policy Editor.
//
// IGroupPolicyObject   -  The interface used to create/edit a GPO directly
//                         without going through the Group Policy Editor
//


//
// Group Policy Editor MMC SnapIn GUID
//
// {8FC0B734-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GPESnapIn, 0x8fc0b734, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Editor node ids
//

//
// Computer Configuration\Windows Settings
// {8FC0B737-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_Machine, 0x8fc0b737, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Computer Configuration\Software Settings
// {8FC0B73A-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_MachineSWSettings, 0x8fc0b73a, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Windows Settings
// {8FC0B738-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_User, 0x8fc0b738, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// User Configuration\Software Settings
// {8FC0B73C-A0E1-11d1-A7D3-0000F87571E3}
//

DEFINE_GUID(NODEID_UserSWSettings, 0x8fc0b73c, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// IGPEInformation interface id
//
// {8FC0B735-A0E1-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGPEInformation, 0x8fc0b735, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object class id
//
// {EA502722-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(CLSID_GroupPolicyObject, 0xea502722, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// Group Policy Object interface id
//
// {EA502723-A23D-11d1-A7D3-0000F87571E3}

DEFINE_GUID(IID_IGroupPolicyObject, 0xea502723, 0xa23d, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }



//========================================================================================
//
// Resultant Set of Policy node ids
//
//========================================================================================

//
// Resultant Set of Policy MMC SnapIn GUID
//
// {6DC3804B-7212-458D-ADB0-9A07E2AE1FA2}

DEFINE_GUID(CLSID_RSOPSnapIn, 0x6dc3804b, 0x7212, 0x458d, 0xad, 0xb0, 0x9a, 0x07, 0xe2, 0xae, 0x1f, 0xa2);


//
// Computer Configuration\Windows Settings
// {BD4C1A2E-0B7A-4A62-A6B0-C0577539C97E}
//

DEFINE_GUID(NODEID_RSOPMachine, 0xbd4c1a2e, 0x0b7a, 0x4a62, 0xa6, 0xb0, 0xc0, 0x57, 0x75, 0x39, 0xc9, 0x7e);


//
// Computer Configuration\Software Settings
// {6A76273E-EB8E-45DB-94C5-25663A5f2C1A}
//

DEFINE_GUID(NODEID_RSOPMachineSWSettings, 0x6a76273e, 0xeb8e, 0x45db, 0x94, 0xc5, 0x25, 0x66, 0x3a, 0x5f, 0x2c, 0x1a);


//
// User Configuration\Windows Settings
// {AB87364F-0CEC-4CD8-9BF8-898F34628FB8}
//

DEFINE_GUID(NODEID_RSOPUser, 0xab87364f, 0x0cec, 0x4cd8, 0x9b, 0xf8, 0x89, 0x8f, 0x34, 0x62, 0x8f, 0xb8);


//
// User Configuration\Software Settings
// {E52C5CE3-FD27-4402-84DE-D9A5F2858910}
//

DEFINE_GUID(NODEID_RSOPUserSWSettings, 0xe52c5ce3, 0xfd27, 0x4402, 0x84, 0xde, 0xd9, 0xa5, 0xf2, 0x85, 0x89, 0x10);


//
// IRSOPInformation interface id
//
// {9A5A81B5-D9C7-49EF-9D11-DDF50968C48D}

DEFINE_GUID(IID_IRSOPInformation, 0x9a5a81b5, 0xd9c7, 0x49ef, 0x9d, 0x11, 0xdd, 0xf5, 0x09, 0x68, 0xc4, 0x8d);


#ifndef _GPEDIT_H_
#define _GPEDIT_H_


//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_GPEDIT_)
#define GPEDITAPI DECLSPEC_IMPORT
#else
#define GPEDITAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif


#include <objbase.h>


//
// Group Policy Object Section flags
//

#define GPO_SECTION_ROOT                 0  // Root
#define GPO_SECTION_USER                 1  // User
#define GPO_SECTION_MACHINE              2  // Machine


//
// Group Policy Object types
//

typedef enum _GROUP_POLICY_OBJECT_TYPE {
    GPOTypeLocal = 0,                       // GPO on the local machine
    GPOTypeRemote,                          // GPO on a remote machine
    GPOTypeDS                               // GPO in the Active Directory
} GROUP_POLICY_OBJECT_TYPE, *PGROUP_POLICY_OBJECT_TYPE;


//
// Group Policy Hint types
//

typedef enum _GROUP_POLICY_HINT_TYPE {
    GPHintUnknown = 0,                      // No link information available
    GPHintMachine,                          // GPO linked to a machine (local or remote)
    GPHintSite,                             // GPO linked to a site
    GPHintDomain,                           // GPO linked to a domain
    GPHintOrganizationalUnit,               // GPO linked to a organizational unit
} GROUP_POLICY_HINT_TYPE, *PGROUP_POLICY_HINT_TYPE;


#undef INTERFACE
#define INTERFACE   IGPEInformation
DECLARE_INTERFACE_(IGPEInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGPEInformation methods ***

    //
    // Returns the unique Group Policy Object name (a GUID)
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in ADSI name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the user preferences (options)
    //
    // Currently, there are no options defined.  This is reserved for future use.
    //
    // dwOptions receives a bitmask value
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags listed above.
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the type of Active Directory object (or machine) that could be linked to
    // this GPO
    //
    // This is a hint api only.  The GPE does not know which Active Directory objects are
    // linked to a particular GPO, but it can offer a hint based upon how the
    // user started the GPE.
    //
    // Use this method with great caution.  Some extensions might want to
    // customize their user interface based upon the scoping for this GPO,
    // but it is easy to offer the wrong namespace.  Best advice is to
    // always offer your full user interface, but if you choose to use this
    // method, always offer your full user interface if you recieve the
    // unknown hint back.
    //
    // gpHint receives one of the hint flags listed above.
    //

    STDMETHOD(GetHint) (THIS_ GROUP_POLICY_HINT_TYPE *gpHint) PURE;


    //
    // Informs the Group Policy Editor that policy settings have changed.
    // Extensions MUST call this methold every time a change is made
    // to a Group Policy Object.
    //
    // bMachine specifies if machine or user policy has changed.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuidSnapin is the guid or unique name of snapin that is making
    //    this call
    //

    STDMETHOD(PolicyChanged) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin ) PURE;
};
typedef IGPEInformation *LPGPEINFORMATION;


//
// Group Policy Object open / creation flags
//

#define GPO_OPEN_LOAD_REGISTRY      0x00000001  // Load the registry files
#define GPO_OPEN_READ_ONLY          0x00000002  // Open the GPO as read only



//
// Group Policy Object option flags
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled


#undef INTERFACE
#define INTERFACE   IGroupPolicyObject
DECLARE_INTERFACE_(IGroupPolicyObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IGroupPolicyObject methods ***

    //
    // Creates a new GPO in the Active Directory with the given friendly name
    // and opens it via OpenDSGPO().  If pszDomainName contains a domain
    // controller name, the GPO will be created on that DC.  If it does not
    // specify a domain controller name, the method will select a DC on
    // the callers behalf.
    //
    // pszDomainName contains the ADSI path of the domain root
    // pszDisplayName contains the friendly display name
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(New) (THIS_ LPOLESTR pszDomainName, LPOLESTR pszDisplayName,
                    DWORD dwFlags) PURE;


    //
    // Opens the specified Group Policy Object in the Active Directory
    // based upon the passed in flags.  If pszPath contains a domain
    // controller name, the GPO will be opened on that DC.  If it does
    // not contain a domain controller name, the method will select a
    // DC on the callers behalf.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszPath contains the ADSI path to the GPO to open
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenDSGPO) (THIS_ LPOLESTR pszPath, DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on this machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenLocalMachineGPO) (THIS_ DWORD dwFlags) PURE;


    //
    // Opens the default Group Policy Object on a remote machine with the
    // dwFlags options listed above.  If the registry is not loaded,
    // GetRegistryKey() will return E_FAIL.
    //
    // pszComputerName contains the machine name in \\machine format
    // dwFlags is a bitmask of GPO open / creation flags listed above
    //

    STDMETHOD(OpenRemoteMachineGPO) (THIS_ LPOLESTR pszComputerName, DWORD dwFlags) PURE;


    //
    // Flushes the registry settings to disk and updates the revision
    // number of the GPO.
    //
    // bMachine specifies if machine or user should be saved.
    // bAdd specifies whether this is an add or delete.
    // pGuidExtension is the guid or unique name of extension that
    //    will process this GPO.
    // pGuid is a guid
    //

    STDMETHOD(Save) (THIS_ BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuid ) PURE;


    //
    // Deletes this Group Policy Object.
    //
    // After calling this method, no other methods are valid to call
    // since the data will have been deleted.
    //

    STDMETHOD(Delete) (THIS) PURE;


    //
    // Returns the unique Group Policy Object name
    //
    // For Active Directory policy objects, this is a GUID
    // For the local policy object, it is the string "Local"
    // For remote policy objects, it is the computername
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns the friendly display name for this Group Policy Object
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetDisplayName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Sets the friendly display name for this Group Policy Object
    //
    // pszName is the new display name
    //

    STDMETHOD(SetDisplayName) (THIS_ LPOLESTR pszName) PURE;


    //
    // Returns the path to the Group Policy Object
    //
    //
    // If the GPO is an Active Directory object, the path is in ADSI name format.
    // If the GPO is a machine object, it is a file system path
    //
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetPath) (THIS_ LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the Active Directory path to the root of the request section.
    // The path is in DN name format.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the max number of characters that can be stored in pszPath
    //

    STDMETHOD(GetDSPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns the UNC path to the root of the requested section.
    //
    // dwSection is one of the GPO_SECTION_* flags
    // pszPath contains the path on return
    // cchMaxPath is the number of characters that can be stored in pszPath.
    //

    STDMETHOD(GetFileSysPath) (THIS_ DWORD dwSection, LPOLESTR pszPath, int cchMaxPath) PURE;


    //
    // Returns a registry key handle for the requested section.  The returned
    // key is the root of the registry, not the Policies subkey.  To set / read
    // a value in the Policies subkey, you will need to call RegOpenKeyEx to
    // open Software\Policies subkey first.
    //
    // The handle has been opened with ALL ACCESS rights.  Call RegCloseKey
    // on the handle when finished.
    //
    // If the GPO was loaded / created without the registry being loaded
    // this method will return E_FAIL.
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // hKey contains the registry key on return
    //

    STDMETHOD(GetRegistryKey) (THIS_ DWORD dwSection, HKEY *hKey) PURE;


    //
    // Returns any options for this Group Policy Object
    //
    // dwOptions receives the GPO_OPTION_* flags
    //

    STDMETHOD(GetOptions) (THIS_ DWORD *dwOptions) PURE;


    //
    // Sets any options for this Group Policy Object
    //
    // This method sets any options for this GPO.  To change
    // an option, that flag must be set in the mask field.
    // If the flag is in the mask field, then the dwOptions
    // field is read for the current state.
    //
    // For example:  to disable the GPO, make this call
    //
    //    SetOptions (GPO_OPTION_DISABLED, GPO_OPTION_DISABLED);
    //
    // dwOptions specifies one or more GPO_OPTION_* flags
    // dwMask specificies which of the dwOptions to change
    //

    STDMETHOD(SetOptions) (THIS_ DWORD dwOptions, DWORD dwMask) PURE;


    //
    // Returns the type of GPO being edited.
    //
    // The three types are:  a GPO in the Active Directory, the GPO on the local machine,
    // and the GPO on a remote machine.
    //
    // Machine GPOs only have file system storage (no Active Directory storage available).
    // If GetDSPath is called for a machine GPO, the function will succeed
    // and the returned buffer will be the empty string ""
    //
    // Active Directory GPOs have both file system and Active Directory storage available to them.
    //
    // gpoType receives one of the type flags
    //

    STDMETHOD(GetType) (THIS_ GROUP_POLICY_OBJECT_TYPE *gpoType) PURE;


    //
    // Returns the machine name of the remote GPO
    //
    // This method returns the name passed to OpenRemoteMachineGPO.
    //
    // pszName contains the name on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetMachineName) (THIS_ LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns an array of property sheet pages and the number of pages
    // in the array
    //
    // Note, this method will allocate memory for the array with
    // LocalAlloc.  When finished, the caller should free the array
    // with LocalFree
    //
    // hPages address of the pointer for the array of property sheet pages
    // uPageCount receives the number of pages in the array
    //

    STDMETHOD(GetPropertySheetPages) (THIS_ HPROPSHEETPAGE **hPages, UINT *uPageCount) PURE;
};
typedef IGroupPolicyObject *LPGROUPPOLICYOBJECT;


//
// RSOP flags
//

#define RSOP_INFO_FLAG_DIAGNOSTIC_MODE  0x00000001      // Running in diagnostic mode vs planning mode

#undef INTERFACE
#define INTERFACE   IRSOPInformation
DECLARE_INTERFACE_(IRSOPInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPInformation methods ***

    //
    // Returns the namespace for the RSOP data
    //
    // dwSection is either GPO_SECTION_USER or GPO_SECTION_MACHINE
    // pszName contains the namespace on return
    // cchMaxLength is the max number of characters that can be stored in pszName
    //

    STDMETHOD(GetNamespace) (THIS_ DWORD dwSection, LPOLESTR pszName, int cchMaxLength) PURE;


    //
    // Returns information about the RSOP session
    //
    // pdwFlags points to a DWORD which contains the flags on return
    //

    STDMETHOD(GetFlags) (THIS_ DWORD * pdwFlags) PURE;


    //
    // Returns the event log text for a specific entry
    //
    // lpEventSource - event log source name
    // lpEventLogName - event log name
    // lpEventTime - event log time in WMI datetime format
    // dwEventID - event ID
    // lpText - Receives a pointer to a buffer containing the text.
    //          The caller should free this buffer with CoTaskMemFree.
    //

    STDMETHOD(GetEventLogEntryText) (THIS_ LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                           LPOLESTR pszEventTime, DWORD dwEventID,  LPOLESTR *ppszText) PURE;

};
typedef IRSOPInformation *LPRSOPINFORMATION;


//=============================================================================
//
// CreateGPOLink
//
// Creates a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
// fHighPriority - Create the link as the highest or lowest priority
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
CreateGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer,
    BOOL fHighPriority);


//=============================================================================
//
// DeleteGPOLink
//
// Deletes a link to a GPO for the specified Site, Domain, or Organizational Unit
//
// lpGPO         - ADSI path to the GPO
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteGPOLink(
    LPOLESTR lpGPO,
    LPOLESTR lpContainer);


//=============================================================================
//
// DeleteAllGPOLinks
//
// Deletes all GPO links for the specified Site, Domain, or Organizational Unit
//
// lpContainer   - ADSI path to the Site, Domain, or Organizational Unit
//
// Returns:  S_OK if successful
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
DeleteAllGPOLinks(
    LPOLESTR lpContainer);


//=============================================================================
//
// BrowseForGPO
//
// Displays the GPO browser dialog
//
// lpBrowseInfo   - Address of a GPOBROWSEINFO structure
//
// Returns:  S_OK if successful
//
//=============================================================================

//
// Flags passed in the dwFlags field of the GPOBROWSEINFO structure
//

#define GPO_BROWSE_DISABLENEW           0x00000001   // Disables the New GPO functionality on all pages except "All"
#define GPO_BROWSE_NOCOMPUTERS          0x00000002   // Removes the Computers tab
#define GPO_BROWSE_NODSGPOS             0x00000004   // Removes the Domain/OU and Sites tabs
#define GPO_BROWSE_OPENBUTTON           0x00000008   // Change the Ok button to say Open
#define GPO_BROWSE_INITTOALL            0x00000010   // Initialize the dialog focused on the All pane

typedef struct tag_GPOBROWSEINFO
{
    DWORD       dwSize;                   // [in] Initialized to the size of this structure
    DWORD       dwFlags;                  // [in] Flags defined above
    HWND        hwndOwner;                // [in] Parent window handle (can be NULL)
    LPOLESTR    lpTitle;                  // [in] Title bar text.  If NULL, "Browse for a Group Policy Object" will be the default text
    LPOLESTR    lpInitialOU;              // [in] Initial Domain/Organizational Unit to open focus on
    LPOLESTR    lpDSPath;                 // [in/out] Pointer to the buffer that receives the Active Directory GPO path
    DWORD       dwDSPathSize;             // [in] Size in characters of buffer given in lpDSPath
    LPOLESTR    lpName;                   // [in/out] Pointer to a buffer that receives either the computer name or
                                          //      the friendly name of the GPO (can be NULL)
    DWORD       dwNameSize;               // [in] Size in characters of buffer given in lpName
    GROUP_POLICY_OBJECT_TYPE    gpoType;  // [out] Specifies the type of GPO
    GROUP_POLICY_HINT_TYPE      gpoHint;  // [out] Specifies a hint of the GPO association
} GPOBROWSEINFO, *LPGPOBROWSEINFO;


GPEDITAPI
HRESULT
WINAPI
BrowseForGPO(
    LPGPOBROWSEINFO lpBrowseInfo);


//=============================================================================
//
// ImportRSoPData
//
// Imports a data file generated by ExportRSoPData
//
// lpNameSpace   - Namespace to place the data in
// lpFileName    - Filename containing the data
//
// Returns:  S_OK if successful
//
// Notes:    The namespace specified in lpNameSpace must exist prior to calling
//           this function.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ImportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);


//=============================================================================
//
// ExportRSoPData
//
// Exports a WBEM namespace containing RSoP information to a data file.
// This data file can be imported to a WBEM namespace using ImportRSoPData.
//
// lpNameSpace   - Namespace to read the data from
// lpFileName    - Filename to receive the data
//
// Returns:  S_OK if successful
//
// Notes:    This function should be called twice.  Once for the user data
//           and once for the computer data.
//
//=============================================================================

GPEDITAPI
HRESULT
WINAPI
ExportRSoPData(
    LPOLESTR lpNameSpace,
    LPOLESTR lpFileName);

#ifdef __cplusplus
}
#endif


#endif  /* _GPEDIT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\fsm.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wlx.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-15-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"


typedef _FSM_Determinant {
    DWORD           Response;
    WinstaState     NextState;
} FSM_Determinant;

typedef struct _FSM_Node {
    WinstaState     State;
    DWORD           Function;
    DWORD           cStates;
    FSM_Determinant Choices[];
} FSM_Node;

#define ANY_RETURN  0xFFFFFFFF

FSM_Node    TestGinaFSM[] = {
                    { Winsta_PreLoad, WLX_NEGOTIATE_API, 1, {{ANY_RETURN, Winsta_Initialize}}},
                    { Winsta_Initialize, WLX_INITIALIZE_API, 1, {{ANY_RETURN, Winsta_NoOne}}},
                    { Winsta_NoOne, WLX_DISPLAYSASNOTICE_API, 1, {{ANY_RETURN, Winsta_NoOne_SAS}}},
                    { Winsta_NoOne_Display, -1, 1, {{ANY_RETURN, Winsta_NoOne_SAS}}},
                    { Winsta_NoOne_SAS, WLX_LOGGEDOUTSAS_API, 5,
                        {WLX_SAS_ACTION_NONE, Winsta_NoOne},
                        {WLX_SAS_ACTION_SHUTDOWN, Winsta_Shutdown},
                        {WLX_SAS_ACTION_SHUTDOWN_REBOOT, Winsta_Shutdown},
                        {WLX_SAS_ACTION_SHUTDOWN_POWER_OFF, Winsta_Shutdown},
                        {WLX_SAS_ACTION_USER_LOGON, Winsta_LoggedOnUser_StartShell}
                        }},
                    { Winsta_LoggedOnUser_StartShell, WLX_ACTIVATEUSERSHELL_API, 1, {{ANY_RETURN, Winsta_LoggedOnUser}}},
                    { Winsta_LoggedOnUser_SAS, WLX_LOGGEDONSAS_API,
                    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\dialogs.h ===
#define IDD_VIEW_MPR                100
#define IDD_VIEW_MPR_USERNAME       105
#define IDD_VIEW_MPR_DOMAIN         106
#define IDD_VIEW_MPR_PASSWORD       107
#define IDD_VIEW_MPR_OLD_PASSWORD   108
#define IDD_USERDEF_SAS             200
#define IDD_SAS_USERNAME            201
#define IDD_SAS_VALUE               204
#define IDD_SAS_KEEPAROUND          205
#define IDD_SAS_REMOVE              206
#define IDD_START_APP               300
#define IDD_STARTAPP_CB             302
#define IDD_VIEW_MPR_PROVIDER       110
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\sunlogon\sunlogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sunlogon.c
//
//  Contents:   Intermediate startup app for sundown to keep going
//
//  Classes:
//
//  Functions:
//
//  History:    3-03-98   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include <winuserp.h>
#include <userenv.h>
#include <userenvp.h>

HANDLE WindowStation ;
HANDLE DefaultDesktop ;
HANDLE WinlogonDesktop ;


BOOL
CreatePrimaryTerminal(
    VOID)
{

    //
    // Create the window station
    //

    WindowStation = CreateWindowStationW(
                            TEXT("WinSta0"),
                            0,
                            MAXIMUM_ALLOWED,
                            NULL);

    if ( !WindowStation ) {
        DbgPrint( "Failed to create WindowStation in win32k/user\n" );
        goto failCreateTerminal;
    }

    SetProcessWindowStation( WindowStation );

    //
    // Create the application desktop
    //

    DefaultDesktop = CreateDesktopW(
                                TEXT("Default"),
                                NULL,
                                NULL,
                                0,
                                MAXIMUM_ALLOWED,
                                NULL );

    if ( !DefaultDesktop ) {
        DbgPrint( "Could not create Default desktop\n" );
        goto failCreateTerminal;
    }


    return TRUE ;

failCreateTerminal:

    //
    // Cleanup
    //

    return FALSE;
}

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    STARTUPINFO si ;
    PROCESS_INFORMATION pi ;
    BOOL Result ;
    WCHAR InitialCommand[ MAX_PATH ];
    WCHAR szComputerName[ 18 ];
    DWORD dwComputerNameSize = 18 ;
    DWORD dwSize ;
    LUID luidNone = { 0, 0 };
    NTSTATUS Status ;
    HANDLE Token ;

    //
    // Get a copy of the computer name in *my* environment, so that we
    // can look at it later.
    //

    if (GetComputerName (szComputerName, &dwComputerNameSize)) {

        SetEnvironmentVariable(
            TEXT("COMPUTERNAME"),
            (LPTSTR) szComputerName);
    }


    //
    // Set the default USERPROFILE location
    //


    dwSize = MAX_PATH ;
    if ( GetDefaultUserProfileDirectory( InitialCommand, &dwSize ) )
    {
        SetEnvironmentVariable( TEXT("USERPROFILE" ), InitialCommand );
    }



    if (!RegisterLogonProcess(
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
            TRUE)) {

        DbgPrint( "Failed to register with win32/user as the logon process\n" );
        return 0;
    }

    if ( !CreatePrimaryTerminal() )
    {
        DbgPrint( "Failed to create terminal\n" );
        return 0 ;
    }

    SwitchDesktop( DefaultDesktop );

    SetThreadDesktop( DefaultDesktop );


    //
    // Whack system as current user:
    //

    SetWindowStationUser( WindowStation, &luidNone, NULL, 0 );

    Status = NtOpenProcessToken(
                    NtCurrentProcess(),
                    MAXIMUM_ALLOWED,
                    &Token );

    if ( NT_SUCCESS( Status ) )
    {
        UpdatePerUserSystemParameters( Token, UPUSP_USERLOGGEDON );
    }
    //
    // At this stage, we're mostly set.
    //

    wcscpy( InitialCommand, TEXT("cmd.exe") );

    do
    {

        ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);
        si.lpTitle = InitialCommand ;
        si.dwFlags = 0 ;
        si.wShowWindow = SW_SHOW;   // at least let the guy see it
        si.lpDesktop = TEXT("Winsta0\\Default");

        Result = CreateProcessW(
                        NULL,
                        InitialCommand,
                        NULL,
                        NULL,
                        FALSE,
                        0,
                        NULL,
                        NULL,
                        &si,
                        &pi );

        if ( !Result )
        {
            DbgPrint(" Failed to start initial command\n" );
            return 0;
        }

        CloseHandle( pi.hThread );
        WaitForSingleObjectEx( pi.hProcess, INFINITE, FALSE );


    } while ( 1 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\desktops.c ===
//+---------------------------------------------------------------------------
//
//  File:       desktops.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-02-96   RichardW   Created
//
//----------------------------------------------------------------------------


#include "testgina.h"

BOOL
AddDesktop(
    DWORD   Index,
    PWSTR   Name)
{
    PWLX_DESKTOP    pDesk;

    pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( WLX_DESKTOP ) +
                        ( wcslen(Name) + 1 ) * sizeof(WCHAR) );

    if ( pDesk )
    {
        pDesk->Size = sizeof( WLX_DESKTOP );
        pDesk->Flags = WLX_DESKTOP_NAME;
        pDesk->pszDesktopName = (PWSTR) ( pDesk + 1 );
        wcscpy( pDesk->pszDesktopName, Name );

        Desktops[ Index ] = pDesk;

        return( TRUE );
    }

    return( FALSE );
}

PWLX_DESKTOP
CopyDesktop(
    PWLX_DESKTOP    pOrig)
{
    PWLX_DESKTOP    pDesk;

    if ( pOrig->pszDesktopName )
    {
        pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof( WLX_DESKTOP ) +
                            ( wcslen( pOrig->pszDesktopName ) + 1 ) * 2 );
    }
    else
    {
        pDesk = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof( WLX_DESKTOP ) );

    }

    if ( pDesk )
    {
        *pDesk = *pOrig;
        if ( pOrig->pszDesktopName )
        {
            pDesk->pszDesktopName = (PWSTR) (pDesk + 1);
            wcscpy( pDesk->pszDesktopName, pOrig->pszDesktopName );
        }
    }

    return( pDesk );
}

BOOL
InitializeDesktops( VOID )
{
    ZeroMemory( Desktops, sizeof( PWLX_DESKTOP ) * MAX_DESKTOPS );

    AddDesktop( WINLOGON_DESKTOP, TEXT("Winlogon") );
    AddDesktop( DEFAULT_DESKTOP, TEXT("Default") );
    AddDesktop( SCREENSAVER_DESKTOP, TEXT("Screen-Saver") );

    CurrentDesktop = WINLOGON_DESKTOP;
    OtherDesktop = WINLOGON_DESKTOP;
    DesktopCount = 3;

    return( TRUE );
}


int
WINAPI
WlxGetSourceDesktop(
    HANDLE                  hWlx,
    PWLX_DESKTOP *          ppDesktop)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxGetSourceDesktop"));
    }

    *ppDesktop = CopyDesktop( Desktops[ OtherDesktop ] );

    return( 0 );
}

int
WINAPI
WlxSetReturnDesktop(
    HANDLE                  hWlx,
    PWLX_DESKTOP            pDesktop)
{
    DWORD   i;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetReturnDesktop"));
    }

    for ( i = 0 ; i < DesktopCount ; i++ )
    {
        if ( _wcsicmp( pDesktop->pszDesktopName, Desktops[ i ]->pszDesktopName ) == 0 )
        {
            break;
        }
    }

    if ( i == WINLOGON_DESKTOP )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetReturnDesktop"));
    }

    if ( i == DesktopCount )
    {
        AddDesktop( DesktopCount, pDesktop->pszDesktopName );
        DesktopCount ++ ;
    }

    OtherDesktop = i;

    return( 0 );
}

int
WINAPI
WlxCreateUserDesktop(
    HANDLE                  hWlx,
    HANDLE                  hToken,
    DWORD                   Flags,
    PWSTR                   pszDesktopName,
    PWLX_DESKTOP *          ppDesktop )
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxCreateUserDesktop"));
    }

    AddDesktop( DesktopCount, pszDesktopName );

    *ppDesktop = CopyDesktop( Desktops[ DesktopCount ] );

    DesktopCount++;

    return( 0 );

}

BOOL
WINAPI
WlxCloseUserDesktop(
    HANDLE hWlx,
    PWLX_DESKTOP Desktop,
    HANDLE Token
    )
{
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\menu.h ===
#define TESTGINAMENU        1000
#define IDM_DLL_OPEN        1010
#define IDM_DLL_RESET       1011
#define IDM_DLL_RUN         1012
#define IDM_DLL_EXIT        1013
#define IDM_DLL_LOAD_LAST   1014

#define IDM_WHACK_NEGOTIATE     1020
#define IDM_WHACK_INITIALIZE    1021
#define IDM_WHACK_DISPLAY       1022
#define IDM_WHACK_LOGGEDOUT     1023
#define IDM_WHACK_LOGGEDON      1024
#define IDM_WHACK_DISPLAYLOCKED 1025
#define IDM_WHACK_LOCKED        1026
#define IDM_WHACK_STARTSHELL    1027
#define IDM_WHACK_LOGOFF        1028
#define IDM_WHACK_SHUTDOWN      1029
#define IDM_WHACK_LOGOFFOK      1050
#define IDM_WHACK_LOCKOK        1051
#define IDM_WHACK_SCREENSAVE    1052
#define IDM_WHACK_RESTARTSHELL  1053

#define IDM_OPTIONS_SAS         1030
#define IDM_OPTIONS_TIMEOUT     1031
#define IDM_OPTIONS_LOGOFF      1032
#define IDM_OPTIONS_VIEW_MPR    1033
#define IDM_OPTIONS_SSNOTIFY    1034
#define IDM_OPTIONS_STARTAPP    1035

#define IDM_HELP_HELP   1040
#define IDM_HELP_ABOUT  1041

#define DEBUGGINAMENU           1100
#define IDM_DEBUG_BREAK_NOW     1101
#define IDM_DEBUG_NEGOTIATE     1102
#define IDM_DEBUG_INITIALIZE    1103
#define IDM_DEBUG_DISPLAYSAS    1104
#define IDM_DEBUG_LOGGEDOUT     1105
#define IDM_DEBUG_ACTIVATE      1106
#define IDM_DEBUG_LOGGEDON      1107
#define IDM_DEBUG_DISPLAYLOCKED 1108
#define IDM_DEBUG_LOCKED        1109
#define IDM_DEBUG_LOGOFF        1110
#define IDM_DEBUG_SHUTDOWN      1111
#define IDM_DEBUG_LOGOFFOK      1112
#define IDM_DEBUG_LOCKOK        1113
#define IDM_DEBUG_SCREENSAVE    1114
#define IDM_DEBUG_RESTARTSHELL  1115

#define IDM_SAS_CAD     1051
#define IDM_SAS_TIMEOUT 1052
#define IDM_SAS_SCRNSVR 1053
#define IDM_SAS_USERDEF 1054
#define IDM_SAS_USERDEF1    1055
#define IDM_SAS_USERDEF2    1056
#define IDM_SAS_USERDEF3    1057
#define IDM_SAS_USERDEF4    1058
#define IDM_SAS_SC_INSERT 1060
#define IDM_SAS_SC_REMOVE 1061
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created.
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPMgr]
//      DebugFlags=<Flag>[<,Flag>]*
//      Package=<int>
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      Package is the name of the dll implementing the package, e.g.
//          NTLM=3
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//


#include "testgina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.


//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];
    long    OriginalMask = Mask;


    if (1)
    {

        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), "TestGINA");


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;
            FILETIME    ftTime;
            FILETIME    localtime;

            NtQuerySystemTime((PLARGE_INTEGER) &ftTime);
            FileTimeToLocalFileTime(&ftTime, &localtime);
            FileTimeToSystemTime(&localtime, &stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    LogEvent(0, "Log File Begins\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\testgina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
#include <stdio.h>
#include <wchar.h>

HINSTANCE                   hDllInstance;   // Dll instance,
DWORD                       DllVersion;     // Dll Version
HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
HWND                        hMainWindow;    // Main window
WNDCLASS                    WndClass;       // Window class
HICON                       hIcon;
WNDCLASS                    StatusClass;    // Status Window class
HWND                        hStatusWindow;  // Status Window
HMENU                       hDebugMenu;     // Debug Menu

USER_SAS                    UserDefSas[MAX_USER_SASES];
DWORD                       UserSases;

DWORD                       CurrentDesktop;
PWLX_DESKTOP                Desktops[ MAX_DESKTOPS ];
DWORD                       DesktopCount;
DWORD                       OtherDesktop;

LRESULT StatusProc(HWND, UINT, WPARAM, LPARAM);

WLX_DISPATCH_VERSION_1_3    WlxDispatchTable = {
                                WlxUseCtrlAltDel,
                                WlxSetContextPointer,
                                WlxSasNotify,
                                WlxSetTimeout,
                                WlxAssignShellProtection,
                                WlxMessageBox,
                                WlxDialogBox,
                                WlxDialogBoxParam,
                                WlxDialogBoxIndirect,
                                WlxDialogBoxIndirectParam,
                                WlxSwitchDesktopToUser,
                                WlxSwitchDesktopToWinlogon,
                                WlxChangePasswordNotify,
                                WlxGetSourceDesktop,
                                WlxSetReturnDesktop,
                                WlxCreateUserDesktop,
                                WlxChangePasswordNotifyEx,
                                WlxCloseUserDesktop,
                                WlxSetOption,
                                WlxGetOption,
                                WlxWin31Migrate,
                                WlxQueryClientCredentials,
                                WlxQueryICCredentials,
                                WlxDisconnect };

PWLX_NEGOTIATE              pWlxNegotiate;
PWLX_INITIALIZE             pWlxInitialize;
PWLX_DISPLAYSASNOTICE       pWlxDisplaySASNotice;
PWLX_LOGGEDOUTSAS           pWlxLoggedOutSAS;
PWLX_ACTIVATEUSERSHELL      pWlxActivateUserShell;
PWLX_LOGGEDONSAS            pWlxLoggedOnSAS;
PWLX_DISPLAYLOCKEDNOTICE    pWlxDisplayLockedNotice;
PWLX_WKSTALOCKEDSAS         pWlxWkstaLockedSAS;
PWLX_LOGOFF                 pWlxLogoff;
PWLX_SHUTDOWN               pWlxShutdown;

WinstaState                 GinaState;              // State of the GinaTest
DWORD                       fTestGina;              // Flags
DWORD                       GinaBreakFlags;         // Break points for Gina debugging
WCHAR                       szGinaDll[MAX_PATH];    // Path and name of the DLL
DWORD                       SizeX, SizeY;
DWORD                       PosX, PosY;
DWORD                       StatusHeight = 24;
DWORD                       StatusDeltaX;
DWORD                       StatusDeltaY;
DWORD                       LastRetCode;
BOOL                        LastBoolRet;


PWSTR   szErrorMessages[] = {   TEXT("Internal TestGina Error!"),
                                TEXT("Invalid hWlx Handle Passed"),
                                TEXT("Improper SAS supplied"),
                                TEXT("Invalid Protocol Level"),
                                TEXT("Load of DLL Failed"),
                                TEXT("Missing Function"),
                                TEXT("Unknown HWND"),
                                TEXT("No Window for SAS message"),
                                TEXT("Invalid SAS code in message"),
                                TEXT("Invalid return code from function")
                            };

PWSTR   szStates[]  = { TEXT("Pre Load"),
                        TEXT("Initialize"),
                        TEXT("No One Logged On"),
                        TEXT("No One Logged On -- Display Notice"),
                        TEXT("No One Logged On -- SAS Received"),
                        TEXT("User Logged On -- Start Shell"),
                        TEXT("User Logged On"),
                        TEXT("User Logged On -- SAS Received"),
                        TEXT("Wksta Locked"),
                        TEXT("Wksta Locked -- SAS Received"),
                        TEXT("Waiting to Shutdown"),
                        TEXT("Shutdown")
                      };

PWSTR   szRetcodes[] = {    TEXT("N/A"),
                            TEXT("WLX_SAS_ACTION_USER_LOGON"),
                            TEXT("WLX_SAS_ACTION_NONE"),
                            TEXT("WLX_SAS_ACTION_LOCK_WKSTA"),
                            TEXT("WLX_SAS_ACTION_LOGOFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN"),
                            TEXT("WLX_SAS_ACTION_PWD_CHANGED"),
                            TEXT("WLX_SAS_ACTION_TASKLIST"),
                            TEXT("WLX_SAS_ACTION_UNLOCK_WKSTA"),
                            TEXT("WLX_SAS_ACTION_FORCE_LOGOFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN_POWER_OFF"),
                            TEXT("WLX_SAS_ACTION_SHUTDOWN_REBOOT")
                       };

BOOLEAN
AmIBeingDebugged(void)
{
    HANDLE      DebugPort;
    NTSTATUS    Status;

    DebugPort = (HANDLE) NULL;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDebugPort,
                (PVOID) &DebugPort,
                sizeof(DebugPort),
                NULL );

    if (NT_SUCCESS(Status) && DebugPort)
    {
        return(TRUE);
    }

    return(FALSE);
}

void
TestGinaError(  DWORD   dwError,
                PWSTR   pszFunction)
{
    int mbret;
    BOOLEAN fDbg;
    WCHAR   szBuffer[MAX_PATH];
    WCHAR   szCaption[MAX_PATH];

    if (dwError > (sizeof(szErrorMessages) / sizeof(PWSTR)))
    {
        dwError = 0;
    }

    fDbg = AmIBeingDebugged();

    wsprintf(szCaption, TEXT("%ws:  Error %d"), pszFunction, dwError);
    if (fDbg)
    {
        wsprintf(szBuffer, TEXT("The following error occurred:\n%ws\nPress OK to exit, Cancel to debug"),
                    szErrorMessages[dwError]);
    }
    else
        wsprintf(szBuffer, TEXT("The following error occurred:\n%ws\nPress OK to exit."),
                    szErrorMessages[dwError]);

    mbret = MessageBox( hMainWindow,
                        szBuffer,
                        szCaption,
                        MB_ICONSTOP | (fDbg ? MB_OKCANCEL : MB_OK) );

    if (fDbg && (mbret == IDCANCEL))
    {
        DbgBreakPoint();
        mbret = MessageBox(hMainWindow, TEXT("Continue after error?"),
                            TEXT("TestGina"), MB_OKCANCEL);
        if (mbret == IDOK)
        {
            return;
        }
    }

    ExitProcess(dwError);
}


void
DoClass(void)
{
    WndClass.style = 0;
    WndClass.lpfnWndProc = WndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = hAppInstance;
    WndClass.hIcon = LoadIcon(hAppInstance, MAKEINTRESOURCE(TESTGINAICON));
    hIcon = WndClass.hIcon;
    WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    WndClass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    WndClass.lpszMenuName = MAKEINTRESOURCE(TESTGINAMENU);
    WndClass.lpszClassName = TEXT("TestGina");

    RegisterClass(&WndClass);
}


int
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrev,
    LPSTR       pszCommandLine,
    int         nCmdShow)
{
    MSG msg;
    HMENU   hMenu;

    hAppInstance = hInstance;

    InitCommonControls();

    DoClass();

    SizeX = (DWORD) CW_USEDEFAULT;
    SizeY = (DWORD) CW_USEDEFAULT;
    PosX = (DWORD) CW_USEDEFAULT;
    PosY = (DWORD) CW_USEDEFAULT;

    LoadParameters();

    InitializeDesktops();

    hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(TESTGINAMENU));
    if (szGinaDll[0] == TEXT('\0'))
    {
        DeleteMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND);
    }
    else
    {
        WCHAR   tmp[32];
        PWSTR   pszName;

        if (wcslen(szGinaDll) > 32)
        {
            pszName = wcsrchr(szGinaDll, TEXT('\\'));
            if (!pszName)
            {
                wcsncpy(tmp, szGinaDll, 31);
            }
            else
            {
                wcsncpy(tmp, szGinaDll, 3);
                wcscpy(tmp + 3, TEXT("..."));
                wcsncpy(tmp+6, pszName, 25);
            }
            ModifyMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND | MF_STRING,
                        IDM_DLL_LOAD_LAST, (LPCTSTR) tmp);
        }
        else
        {
            ModifyMenu(hMenu, IDM_DLL_LOAD_LAST, MF_BYCOMMAND | MF_STRING,
                        IDM_DLL_LOAD_LAST, szGinaDll);
        }
    }
    if (AmIBeingDebugged())
    {
        hDebugMenu = LoadMenu(hInstance, MAKEINTRESOURCE(DEBUGGINAMENU));

        InsertMenu(hMenu, 3, MF_BYPOSITION | MF_POPUP, (UINT) hDebugMenu, TEXT("&Debug"));
    }

    hMainWindow = CreateWindow(
                    TEXT("TestGina"),
                    TEXT("TestGina"),
                    WS_OVERLAPPEDWINDOW,
                    PosX,
                    PosY,
                    SizeX,
                    SizeY,
                    NULL,
                    hMenu,
                    hInstance,
                    NULL);

    if (!hMainWindow)
    {
        return(0);
    }

    RegisterHotKey(hMainWindow, 0, MOD_CONTROL, VK_DELETE);
    RegisterHotKey(hMainWindow, 1, MOD_CONTROL, VK_ADD);

    ShowWindow(hMainWindow, nCmdShow);

    StatusDeltaX = GetSystemMetrics(SM_CXFRAME);
    StatusDeltaY = GetSystemMetrics(SM_CYFRAME);

    ShowWindow(hMainWindow, nCmdShow);

    SetFocus(hMainWindow);

    UpdateMenuBar();

    EnableOptions(FALSE);



    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0 ;
}



void
UpdateGinaState(DWORD   Update)
{
    LogEvent( 0, "UpdateGinaState(%d):  CurrentDesktop = %d, OtherDesktop = %d\n",
                    Update, CurrentDesktop, OtherDesktop );

    switch (Update)
    {
        case UPDATE_INITIALIZE:
            GinaState = Winsta_NoOne;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_DISPLAY_NOTICE:
            if (GinaState != Winsta_NoOne)
            {
                TestGinaError(0, TEXT("UpdateGinaState_1"));
            }
            GinaState = Winsta_NoOne_Display;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_SAS_BYPASS:
            //
            // The kind of weird state of skipping DISPLAY and invoking the
            //
            if ((GinaState == Winsta_NoOne) || (GinaState == Winsta_NoOne_Display))
            {
                GinaState = Winsta_NoOne_SAS;
            }
            else if ((GinaState == Winsta_LoggedOnUser))
            {
                GinaState = Winsta_LoggedOn_SAS;
            }
            else if (GinaState == Winsta_Locked)
            {
                GinaState = Winsta_Locked_SAS;
            }

            LastRetCode = 0;
            CurrentDesktop = WINLOGON_DESKTOP;
            OtherDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_SAS_RECEIVED:
            if ((GinaState == Winsta_NoOne) || (GinaState == Winsta_NoOne_Display))
            {
                GinaState = Winsta_NoOne_SAS;
            }
            else if (GinaState == Winsta_LoggedOnUser)
            {
                GinaState = Winsta_LoggedOn_SAS;
            }
            else if (GinaState == Winsta_Locked)
            {
                GinaState = Winsta_Locked_SAS;
            }

            OtherDesktop = CurrentDesktop;
            CurrentDesktop = WINLOGON_DESKTOP;

            LastRetCode = 0;
            break;

        case UPDATE_USER_LOGON:
            if (GinaState != Winsta_NoOne_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_2"));
            }
            GinaState = Winsta_LoggedOnUser;

            OtherDesktop = WINLOGON_DESKTOP;
            CurrentDesktop = DEFAULT_DESKTOP;

            break;

        case UPDATE_LOCK_WKSTA:
            if (GinaState != Winsta_LoggedOn_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_3"));
            }
            GinaState = Winsta_Locked;
            CurrentDesktop = WINLOGON_DESKTOP;
            break;

        case UPDATE_UNLOCK_WKSTA:
            if (GinaState != Winsta_Locked_SAS)
            {
                TestGinaError(0, TEXT("UpdateGinaState_4"));
            }
            GinaState = Winsta_LoggedOnUser;
            CurrentDesktop = OtherDesktop;
            OtherDesktop = WINLOGON_DESKTOP;

            break;

        case UPDATE_SAS_COMPLETE:
            if (GinaState == Winsta_LoggedOn_SAS)
            {
                GinaState = Winsta_LoggedOnUser;
                CurrentDesktop = OtherDesktop;
                OtherDesktop = WINLOGON_DESKTOP;
            }
            if (GinaState == Winsta_NoOne_SAS)
            {
                GinaState = Winsta_NoOne;
            }
            if (GinaState == Winsta_Locked_SAS)
            {
                GinaState = Winsta_Locked;
            }
            break;

        case UPDATE_LOGOFF:
            LastRetCode = 0;
            GinaState = Winsta_NoOne;
            break;

    }

    LogEvent( 0, "UpdateGinaState:  CurrentDesktop = %d, OtherDesktop = %d\n",
                    CurrentDesktop, OtherDesktop );

    UpdateStatusBar( );
}

void
LoadGinaSpecificParameters(
    VOID )
{
    PWSTR   pszGina;
    HKEY    hKey;
    HKEY    hRealKey;
    int     err;
    DWORD   cbBuffer;
    DWORD   dwType;
    WCHAR   szTemp[512];
    DWORD   i;
    PWSTR   pszWalk;
    DWORD   RealBuf;
    DWORD   disp;

    pszGina = wcsrchr( szGinaDll, TEXT('\\') );
    if (!pszGina)
    {
        pszGina = szGinaDll;
    }
    else
    {
        pszGina++;
    }

    err = RegCreateKey( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey );
    if (err)
    {
        return;
    }

    err = RegCreateKeyEx(   hKey,
                            pszGina,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hRealKey,
                            &disp );

    RegCloseKey( hKey );

    if (err)
    {
        return;
    }

    cbBuffer = 512 * sizeof(WCHAR);

    err = RegQueryValueEx(  hRealKey,
                            TEXT("Order"),
                            NULL,
                            &dwType,
                            (LPBYTE) szTemp,
                            &cbBuffer );

    if (err || (dwType != REG_MULTI_SZ))
    {
        RegCloseKey( hRealKey );
        return;
    }

    pszWalk = szTemp;

    for (i = 0; i < 4 ; i++ )
    {

        RealBuf = sizeof(DWORD);

        err = RegQueryValueEx(  hRealKey,
                                pszWalk,
                                NULL,
                                &dwType,
                                (LPBYTE) &UserDefSas[i].Value,
                                &RealBuf );

        if (err || ( dwType != REG_DWORD))
        {
            RegCloseKey( hRealKey );
            return;
        }

        wcsncpy( UserDefSas[i].Name, pszWalk, 128 );

        pszWalk += wcslen(pszWalk) + 1;

        if (*pszWalk == TEXT('\0'))
        {
            break;
        }

    }

    RegCloseKey( hRealKey );

    UserSases = i + 1;

}

void
SaveGinaSpecificParameters(void)
{
    PWSTR   pszGina;
    HKEY    hKey;
    HKEY    hRealKey;
    int     err;
    DWORD   cbBuffer;
    WCHAR   szTemp[512];
    DWORD   i;
    DWORD   disp;

    pszGina = wcsrchr( szGinaDll, TEXT('\\') );
    if (!pszGina)
    {
        pszGina = szGinaDll;
    }
    else
    {
        pszGina++;
    }

    err = RegCreateKey( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey );
    if (err)
    {
        return;
    }

    err = RegCreateKeyEx(   hKey,
                            pszGina,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hRealKey,
                            &disp );

    RegCloseKey( hKey );

    if (err)
    {
        return;
    }

    cbBuffer = 0;

    for (i = 0; i < UserSases ; i++ )
    {
        wcscpy( &szTemp[cbBuffer],
                UserDefSas[i].Name );

        cbBuffer += wcslen(UserDefSas[i].Name) + 1;

    }

    szTemp[cbBuffer++] = TEXT('\0');

    RegSetValueEx(  hRealKey,
                    TEXT("Order"),
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE) szTemp,
                    cbBuffer * 2);

    for (i = 0; i < UserSases ; i++ )
    {
        RegSetValueEx(  hRealKey,
                        UserDefSas[i].Name,
                        0,
                        REG_DWORD,
                        (LPBYTE) &UserDefSas[i].Value,
                        sizeof(DWORD) );
    }

    RegCloseKey( hRealKey );

}

void
LoadParameters(void)
{
    HKEY    hKey;
    int     err;
    DWORD   dwX;
    DWORD   cbBuffer;
    DWORD   dwType;

    err = RegCreateKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey);
    if (err)
    {
        return;
    }

    cbBuffer = sizeof(dwX);

    err = RegQueryValueEx(hKey, TEXT("Size"), NULL, &dwType, (LPBYTE)&dwX, &cbBuffer);
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    SizeX = LOWORD(dwX);
    SizeY = HIWORD(dwX);

    err = RegQueryValueEx(hKey, TEXT("Pos"), NULL, &dwType, (LPBYTE)&dwX, &cbBuffer);
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    PosX = LOWORD(dwX);
    PosY = HIWORD(dwX);

    cbBuffer = sizeof(szGinaDll);
    err = RegQueryValueEx(hKey, TEXT("Dll"), NULL, &dwType, (LPBYTE)szGinaDll, &cbBuffer);

    RegCloseKey(hKey);

}

void
SaveParameters(void)
{
    HKEY    hKey;
    int     err;
    DWORD   dwX;

    err = RegCreateKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\TestGina"), &hKey);
    if (err)
    {
        return;
    }

    dwX = (SizeY << 16) + (SizeX & 0x0000FFFF);

    err = RegSetValueEx(hKey, TEXT("Size"), 0, REG_DWORD, (LPBYTE)&dwX, sizeof(DWORD));
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    dwX = (PosY << 16) + (PosX & 0x0000FFFF);

    err = RegSetValueEx(hKey, TEXT("Pos"), 0, REG_DWORD, (LPBYTE)&dwX, sizeof(DWORD));
    if (err)
    {
        RegCloseKey(hKey);
        return;
    }

    err = RegSetValueEx(hKey, TEXT("Dll"), 0, REG_SZ, (LPBYTE) szGinaDll, (wcslen(szGinaDll) + 1) * sizeof(WCHAR));

    RegCloseKey(hKey);
}


PrintStatus(HWND hWnd)
{
    WCHAR szText[128];
    PWSTR pszRet;

    wsprintf( szText, TEXT("GINA State:  %s"), szStates[ GinaState ] );
    SendMessage( hStatusWindow, SB_SETTEXT, 0, (LPARAM) szText );

    if ( LastRetCode == WLX_SAS_ACTION_BOOL_RET )
    {
        if ( LastBoolRet )
        {
            pszRet = TEXT("TRUE");
        }
        else
        {
            pszRet = TEXT("FALSE");
        }
    }
    else
    {
        pszRet = szRetcodes[ LastRetCode ];
    }

    wsprintf( szText, TEXT("Last Return:  %s"), pszRet );
    SendMessage( hStatusWindow, SB_SETTEXT, 1, (LPARAM) szText );

    wsprintf( szText, TEXT("Desktop:  %s"), Desktops[ CurrentDesktop ]->pszDesktopName );
    SendMessage( hStatusWindow, SB_SETTEXT, 2, (LPARAM) szText );

    return(0);
}

void
UpdateStatusBar(VOID)
{
    RECT    rect;
    int     Widths[4];

    GetClientRect( hStatusWindow, &rect );

    rect.right -= 15;   // Reduce by size grip

    Widths[0] = rect.right / 3;
    Widths[1] = rect.right / 3 + Widths[0] ;
    Widths[2] = rect.right / 3 + Widths[1] ;

    SendMessage( hStatusWindow, SB_SETPARTS, (WPARAM) 3, (LPARAM) Widths );

    PrintStatus( hStatusWindow );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\testgina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       testgina.h
//
//  Contents:   Main header file for testgina.exe
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#define UNICODE

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>
#endif


#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>
#include <stdio.h>

#ifndef RC_INVOKED

#include <winwlx.h>

typedef
BOOL (WINAPI * PWLX_NEGOTIATE)(
    DWORD, DWORD *);

typedef
BOOL (WINAPI * PWLX_INITIALIZE)(
    LPWSTR, HANDLE, PVOID, PVOID, PVOID *);

typedef
VOID (WINAPI * PWLX_DISPLAYSASNOTICE)(
    PVOID );

typedef
int (WINAPI * PWLX_LOGGEDOUTSAS)(
    PVOID, DWORD, PLUID, PSID, PDWORD, PHANDLE, PWLX_MPR_NOTIFY_INFO, PVOID);

typedef
VOID (WINAPI * PWLX_ACTIVATEUSERSHELL)(
    PVOID, PWSTR, PWSTR, PVOID);

typedef
int (WINAPI * PWLX_LOGGEDONSAS)(
    PVOID, DWORD, PWLX_MPR_NOTIFY_INFO);

typedef
VOID (WINAPI * PWLX_DISPLAYLOCKEDNOTICE)(
    PVOID );

typedef
int (WINAPI * PWLX_WKSTALOCKEDSAS)(
    PVOID, DWORD );

typedef
VOID (WINAPI * PWLX_LOGOFF)(
    PVOID );

typedef
VOID (WINAPI * PWLX_SHUTDOWN)(
    PVOID );

#define WLX_NEGOTIATE_NAME          "WlxNegotiate"
#define WLX_INITIALIZE_NAME         "WlxInitialize"
#define WLX_DISPLAYSASNOTICE_NAME   "WlxDisplaySASNotice"
#define WLX_LOGGEDOUTSAS_NAME       "WlxLoggedOutSAS"
#define WLX_ACTIVATEUSERSHELL_NAME  "WlxActivateUserShell"
#define WLX_LOGGEDONSAS_NAME        "WlxLoggedOnSAS"
#define WLX_DISPLAYLOCKED_NAME      "WlxDisplayLockedNotice"
#define WLX_WKSTALOCKEDSAS_NAME     "WlxWkstaLockedSAS"
#define WLX_LOGOFF_NAME             "WlxLogoff"
#define WLX_SHUTDOWN_NAME           "WlxShutdown"

#define WLX_NEGOTIATE_API           0
#define WLX_INITIALIZE_API          1
#define WLX_DISPLAYSASNOTICE_API    2
#define WLX_LOGGEDOUTSAS_API        3
#define WLX_ACTIVATEUSERSHELL_API   4
#define WLX_LOGGEDONSAS_API         5
#define WLX_DISPLAYLOCKED_API       6
#define WLX_WKSTALOCKEDSAS_API      7
#define WLX_LOGOFF_API              8
#define WLX_SHUTDOWN_API            9


typedef enum _WinstaState {
    Winsta_PreLoad,
    Winsta_Initialize,
    Winsta_NoOne,
    Winsta_NoOne_Display,
    Winsta_NoOne_SAS,
    Winsta_LoggedOnUser_StartShell,
    Winsta_LoggedOnUser,
    Winsta_LoggedOn_SAS,
    Winsta_Locked,
    Winsta_Locked_SAS,
    Winsta_WaitForShutdown,
    Winsta_Shutdown
} WinstaState;

typedef struct _USER_SAS {
    DWORD       Value;
    WCHAR       Name[128];
} USER_SAS, * PUSER_SAS;
#define MAX_USER_SASES          4


#define UPDATE_INITIALIZE       0
#define UPDATE_DISPLAY_NOTICE   1
#define UPDATE_SAS_RECEIVED     2
#define UPDATE_USER_LOGON       3
#define UPDATE_LOCK_WKSTA       4
#define UPDATE_UNLOCK_WKSTA     5
#define UPDATE_LOGOFF           6
#define UPDATE_SAS_BYPASS       7
#define UPDATE_SAS_COMPLETE     8
#define UDPATE_FORCE_LOGOFF     9
#define UPDATE_SHUTDOWN         10

void
UpdateGinaState(DWORD   Update);


void TestGinaError(DWORD, PWSTR);

#define GINAERR_INVALID_HANDLE      1
#define GINAERR_IMPROPER_CAD        2
#define GINAERR_INVALID_LEVEL       3
#define GINAERR_LOAD_FAILED         4
#define GINAERR_MISSING_FUNCTION    5
#define GINAERR_UNKNOWN_HWND        6
#define GINAERR_NO_WINDOW_FOR_SAS   7
#define GINAERR_INVALID_SAS_CODE    8
#define GINAERR_INVALID_RETURN      9
#define GINAERR_DIALOG_ERROR        10


#define MAX_DESKTOPS                16
#define WINLOGON_DESKTOP            0
#define DEFAULT_DESKTOP             1
#define SCREENSAVER_DESKTOP         2


void LoadParameters(void);
void SaveParameters(void);
void
SaveGinaSpecificParameters(void);
void
LoadGinaSpecificParameters(
    VOID );
VOID
UpdateSasMenu(VOID);
VOID
EnableOptions(BOOL Enable);

VOID WINAPI WlxUseCtrlAltDel(HANDLE);
VOID WINAPI WlxSasNotify(HANDLE, DWORD);
VOID WINAPI WlxSetContextPointer(HANDLE, PVOID);
BOOL WINAPI WlxSetTimeout(HANDLE, DWORD);
int WINAPI  WlxAssignShellProtection(HANDLE, HANDLE, HANDLE, HANDLE);
int WINAPI  WlxMessageBox(HANDLE, HWND, LPWSTR, LPWSTR, UINT);
int WINAPI  WlxDialogBox(HANDLE, HANDLE, LPWSTR, HWND, DLGPROC);
int WINAPI  WlxDialogBoxIndirect(HANDLE, HANDLE, LPCDLGTEMPLATE, HWND, DLGPROC);
int WINAPI  WlxDialogBoxParam(HANDLE, HANDLE, LPWSTR, HWND, DLGPROC, LPARAM);
int WINAPI  WlxDialogBoxIndirectParam(HANDLE, HANDLE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
int WINAPI  WlxSwitchDesktopToUser(HANDLE);
int WINAPI  WlxSwitchDesktopToWinlogon(HANDLE);
int WINAPI  WlxChangePasswordNotify(HANDLE, PWLX_MPR_NOTIFY_INFO, DWORD);
BOOL WINAPI WlxGetSourceDesktop(HANDLE, PWLX_DESKTOP *);
BOOL WINAPI WlxSetReturnDesktop(HANDLE, PWLX_DESKTOP);
BOOL WINAPI WlxCreateUserDesktop(HANDLE, HANDLE, DWORD, PWSTR, PWLX_DESKTOP *);
int WINAPI WlxChangePasswordNotifyEx( HANDLE, PWLX_MPR_NOTIFY_INFO, DWORD, PWSTR, PVOID);
BOOL WINAPI WlxCloseUserDesktop( HANDLE, PWLX_DESKTOP, HANDLE );
BOOL WINAPI WlxSetOption( HANDLE, DWORD, ULONG_PTR, ULONG_PTR * );
BOOL WINAPI WlxGetOption( HANDLE, DWORD, ULONG_PTR * );
VOID WINAPI WlxWin31Migrate( HANDLE );
BOOL WINAPI WlxQueryClientCredentials( PWLX_CLIENT_CREDENTIALS_INFO_V1_0 );
BOOL WINAPI WlxQueryICCredentials( PWLX_CLIENT_CREDENTIALS_INFO_V1_0 );
BOOL WINAPI WlxDisconnect( VOID );
int UpdateMenuBar(void);
void UpdateStatusBar(void);
PingSAS(DWORD   SasType);

BOOLEAN LoadGinaDll(void);
BOOLEAN TestNegotiate(void);
BOOLEAN TestInitialize(void);
BOOLEAN TestDisplaySASNotice(void);
int     TestLoggedOutSAS(int    SasType);
int     TestLoggedOnSAS(int SasType);
int     TestActivateUserShell(void);
int     TestWkstaLockedSAS(int SasType);
int     TestDisplayLockedNotice(void);
int     TestLogoff(void);
BOOL
InitializeDesktops( VOID );

BOOLEAN AmIBeingDebugged(void);

void    LogEvent(long Mask, const char * Format, ...);

LRESULT
CALLBACK
WndProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam);

BOOL    AssociateHandle(HANDLE);
BOOL    VerifyHandle(HANDLE);
BOOL    StashContext(PVOID);
PVOID   GetContext(VOID);
BOOL
ValidResponse(
    DWORD       ApiNum,
    DWORD       Response);




//
// Global Variables

extern  HINSTANCE   hDllInstance;
extern  HINSTANCE   hAppInstance;
extern  DWORD       DllVersion;
extern  HICON       hIcon;
extern  HWND        hMainWindow;
extern  HWND        hStatusWindow;
extern  DWORD       StatusHeight;
extern  DWORD       fTestGina;
extern  DWORD       GinaBreakFlags;
extern  WinstaState GinaState;
extern  DWORD       LastRetCode;
extern  BOOL        LastBoolRet;
extern  WCHAR       szGinaDll[];
extern  WLX_DISPATCH_VERSION_1_3    WlxDispatchTable;
extern  HANDLE      hThread;
extern  DWORD       SizeX, SizeY;
extern  DWORD       PosX, PosY;
extern  DWORD       StatusDeltaX, StatusDeltaY;
extern  DWORD       StatusHeight;
extern  WLX_MPR_NOTIFY_INFO GlobalMprInfo;
extern  HMENU       hDebugMenu;
extern  USER_SAS    UserDefSas[4];
extern  DWORD       UserSases;
extern  PVOID       pWlxContext;
extern  WCHAR       GlobalProviderName[];

extern  DWORD           CurrentDesktop;
extern  PWLX_DESKTOP    Desktops[];
extern  DWORD           OtherDesktop;
extern  DWORD           DesktopCount;


#define WLX_SAS_ACTION_BOOL_RET 12


//
// Function Pointers in DLL:
//

extern  PWLX_NEGOTIATE              pWlxNegotiate;
extern  PWLX_INITIALIZE             pWlxInitialize;
extern  PWLX_DISPLAYSASNOTICE       pWlxDisplaySASNotice;
extern  PWLX_LOGGEDOUTSAS           pWlxLoggedOutSAS;
extern  PWLX_ACTIVATEUSERSHELL      pWlxActivateUserShell;
extern  PWLX_LOGGEDONSAS            pWlxLoggedOnSAS;
extern  PWLX_DISPLAYLOCKEDNOTICE    pWlxDisplayLockedNotice;
extern  PWLX_WKSTALOCKEDSAS         pWlxWkstaLockedSAS;
extern  PWLX_LOGOFF                 pWlxLogoff;
extern  PWLX_SHUTDOWN               pWlxShutdown;

#define GINA_USE_CAD        0x00000001      // DLL requested Use CAD
#define GINA_DLL_KNOWN      0x00000002      // DLL name has been determined
#define GINA_USE_SC         0x00000004

#define GINA_NEGOTIATE_OK   0x80000000      // Ok to call Negotiate
#define GINA_INITIALIZE_OK  0x40000000      // Ok to call Initialize
#define GINA_LOGGEDOUT_OK   0x20000000      // Ok to call LoggedOutSAS
#define GINA_ACTIVATE_OK    0x10000000      // Ok to call Activate
#define GINA_LOGGEDON_OK    0x08000000      // Ok to call LoggedOnSAS
#define GINA_DISPLAYLOCK_OK 0x04000000      // Ok to call DisplayLockedNotice
#define GINA_WKSTALOCK_OK   0x02000000      // Ok to call WkstaLockedSAS
#define GINA_LOGOFF_OK      0x01000000      // Ok to call Logoff
#define GINA_SHUTDOWN_OK    0x00800000      // Ok to call Shutdown
#define GINA_DISPLAY_OK     0x00400000      // Ok to call Display
#define GINA_ISLOCKOK_OK    0x00200000      // Ok to call IsLockOk
#define GINA_ISLOGOFFOK_OK  0x00100000      // Ok to call IsLogoffOk
#define GINA_RESTART_OK     0x00080000      // Ok to call RestartShell
#define GINA_SCREENSAVE_OK  0x00040000      // Ok to call ScreenSaverNotify
#define GINA_DISPLAYLOG_OK  0x00020000

#define BREAK_NEGOTIATE     0x00000001
#define BREAK_INITIALIZE    0x00000002
#define BREAK_DISPLAY       0x00000004
#define BREAK_LOGGEDOUT     0x00000008
#define BREAK_ACTIVATE      0x00000010
#define BREAK_LOGGEDON      0x00000020
#define BREAK_DISPLAYLOCKED 0x00000040
#define BREAK_WKSTALOCKED   0x00000080
#define BREAK_LOGOFF        0x00000100
#define BREAK_SHUTDOWN      0x00000200

#define FLAG_ON(dw, f)      dw |= (f)
#define FLAG_OFF(dw, f)     dw &= (~(f))
#define TEST_FLAG(dw, f)    ((BOOL)(dw & (f)))


#endif // RC_INVOKED

#include "menu.h"
#include "dialogs.h"

#define TESTGINAICON    10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\validate.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       validate.c
//
//  Contents:   Validation stuff
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------


#include "testgina.h"

HANDLE  hWlxHandle;
PVOID   pWlxContext;

#define ACTION_LOGON        ((1) << (WLX_SAS_ACTION_LOGON))
#define ACTION_NONE         ((1) << (WLX_SAS_ACTION_NONE))
#define ACTION_LOCK_WKSTA   ((1) << (WLX_SAS_ACTION_LOCK_WKSTA))
#define ACTION_LOGOFF       ((1) << (WLX_SAS_ACTION_LOGOFF))
#define ACTION_SHUTDOWN     ((1) << (WLX_SAS_ACTION_SHUTDOWN))
#define ACTION_PWD_CHANGED  ((1) << (WLX_SAS_ACTION_PWD_CHANGED))
#define ACTION_TASKLIST     ((1) << (WLX_SAS_ACTION_TASKLIST))
#define ACTION_UNLOCK_WKSTA ((1) << (WLX_SAS_ACTION_UNLOCK_WKSTA))
#define ACTION_FORCE_LOGOFF ((1) << (WLX_SAS_ACTION_FORCE_LOGOFF))
#define ACTION_SHUTDOWN_POW ((1) << (WLX_SAS_ACTION_SHUTDOWN_POWER_OFF))
#define ACTION_SHUTDOWN_REB ((1) << (WLX_SAS_ACTION_SHUTDOWN_REBOOT))


DWORD   ValidReturnCodes[] = {
        0,                                              // Negotiate
        0,                                              // Initialize
        0,                                              // DisplaySAS
        ACTION_LOGON | ACTION_NONE | ACTION_SHUTDOWN |
        ACTION_SHUTDOWN_POW | ACTION_SHUTDOWN_REB,      // LoggedOutSAS
        0,                                              // ActivateUserShell
        ACTION_LOCK_WKSTA | ACTION_LOGOFF | ACTION_FORCE_LOGOFF |
        ACTION_SHUTDOWN | ACTION_PWD_CHANGED |
        ACTION_TASKLIST | ACTION_SHUTDOWN_POW |
        ACTION_SHUTDOWN_REB | ACTION_NONE,              // LoggedOnSAS
        0,                                              // DisplayLockedNotice
        ACTION_NONE | ACTION_UNLOCK_WKSTA |
        ACTION_FORCE_LOGOFF,                            // WkstaLockedSAS
        0,                                              // Logoff
        0 };                                            // Shutdown


BOOL
AssociateHandle(HANDLE   hWlx)
{
    hWlxHandle = hWlx;
    return(TRUE);
}

BOOL
VerifyHandle(HANDLE hWlx)
{
    return(hWlx == hWlxHandle);
}

BOOL
StashContext(PVOID  pvContext)
{
    pWlxContext = pvContext;
    return(TRUE);
}

PVOID
GetContext(VOID)
{
    return(pWlxContext);
}

BOOL
ValidResponse(
    DWORD       ApiNum,
    DWORD       Response)
{
    DWORD   Test = (1) << Response;

    if (Response > 11)
    {
        LastRetCode = 0;
    }
    else
    {
        LastRetCode = Response;
    }

    UpdateStatusBar( );

    if (ValidReturnCodes[ApiNum] & Test)
    {
        return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\wlx.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       wlx.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-15-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
HANDLE  hThread;
SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY gLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
WLX_MPR_NOTIFY_INFO GlobalMprInfo;
WCHAR GlobalProviderName[128];

HANDLE  hToken;


void
LockTestGina(void)
{
    FLAG_OFF(fTestGina, GINA_LOGGEDON_OK);
    FLAG_ON(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_ON(fTestGina, GINA_WKSTALOCK_OK);
    UpdateGinaState(UPDATE_LOCK_WKSTA);
    UpdateMenuBar();

}

void
UnlockTestGina(void)
{
    FLAG_OFF(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_OFF(fTestGina, GINA_WKSTALOCK_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDON_OK);
    UpdateGinaState(UPDATE_UNLOCK_WKSTA);
    UpdateMenuBar();
}

LogoffUser(void)
{
    CloseHandle(hToken);
    FLAG_OFF(fTestGina, GINA_LOGGEDON_OK);
    FLAG_OFF(fTestGina, GINA_DISPLAYLOCK_OK);
    FLAG_OFF(fTestGina, GINA_WKSTALOCK_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDOUT_OK);
    FLAG_ON(fTestGina, GINA_DISPLAY_OK);
    UpdateGinaState(UPDATE_LOGOFF);
    UpdateMenuBar();
    return(0);
}



BOOLEAN
LoadGinaDll(void)
{
    hDllInstance = LoadLibrary(szGinaDll);

    if (!hDllInstance)
    {
        TestGinaError(GINAERR_LOAD_FAILED, TEXT("LoadGinaDll"));
    }
    pWlxNegotiate = (PWLX_NEGOTIATE) GetProcAddress(hDllInstance, WLX_NEGOTIATE_NAME);
    if (!pWlxNegotiate)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_NEGOTIATE_NAME));
    }

    pWlxInitialize = (PWLX_INITIALIZE) GetProcAddress(hDllInstance, WLX_INITIALIZE_NAME);
    if (!pWlxInitialize)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_INITIALIZE_NAME));
    }

    pWlxDisplaySASNotice = (PWLX_DISPLAYSASNOTICE) GetProcAddress(hDllInstance, WLX_DISPLAYSASNOTICE_NAME);
    if (!pWlxDisplaySASNotice)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_DISPLAYSASNOTICE_NAME));
    }

    pWlxLoggedOutSAS = (PWLX_LOGGEDOUTSAS) GetProcAddress(hDllInstance, WLX_LOGGEDOUTSAS_NAME);
    if (!pWlxLoggedOutSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGGEDOUTSAS_NAME));
    }

    pWlxActivateUserShell = (PWLX_ACTIVATEUSERSHELL) GetProcAddress(hDllInstance, WLX_ACTIVATEUSERSHELL_NAME);
    if (!pWlxActivateUserShell)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_ACTIVATEUSERSHELL_NAME));
    }

    pWlxLoggedOnSAS = (PWLX_LOGGEDONSAS) GetProcAddress(hDllInstance, WLX_LOGGEDONSAS_NAME);
    if (!pWlxLoggedOnSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGGEDONSAS_NAME));
    }

    pWlxDisplayLockedNotice = (PWLX_DISPLAYLOCKEDNOTICE) GetProcAddress(hDllInstance, WLX_DISPLAYLOCKED_NAME);
    if (!pWlxDisplayLockedNotice)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_DISPLAYLOCKED_NAME));
    }

    pWlxWkstaLockedSAS = (PWLX_WKSTALOCKEDSAS) GetProcAddress(hDllInstance, WLX_WKSTALOCKEDSAS_NAME);
    if (!pWlxWkstaLockedSAS)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_WKSTALOCKEDSAS_NAME));
    }

    pWlxLogoff = (PWLX_LOGOFF) GetProcAddress(hDllInstance, WLX_LOGOFF_NAME);
    if (!pWlxLogoff)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_LOGOFF_NAME));
    }

    pWlxShutdown = (PWLX_SHUTDOWN) GetProcAddress(hDllInstance, WLX_SHUTDOWN_NAME);
    if (!pWlxShutdown)
    {
        TestGinaError(GINAERR_MISSING_FUNCTION, TEXT(WLX_SHUTDOWN_NAME));
    }

    FLAG_ON(fTestGina, GINA_NEGOTIATE_OK);

    UpdateMenuBar();

    return(TRUE);
}


BOOLEAN
TestNegotiate(void)
{
    BOOL ret;

    if (!TEST_FLAG(fTestGina, GINA_NEGOTIATE_OK) ||
        !TEST_FLAG(fTestGina, GINA_DLL_KNOWN))
    {
        TestGinaError(0, TEXT("TestNegotiate"));
    }

    if (TEST_FLAG(GinaBreakFlags, BREAK_NEGOTIATE))
    {
        LogEvent(0, "About to call WlxNegotiate(%d, @%#x):\n",
            WLX_CURRENT_VERSION, & DllVersion);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    ret = pWlxNegotiate(WLX_CURRENT_VERSION, & DllVersion );

    if (TEST_FLAG(GinaBreakFlags, BREAK_NEGOTIATE))
    {
        LogEvent(0, "Back from WlxNegotiate() @%#x = %d \n",
            & DllVersion, DllVersion);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    if (DllVersion > WLX_CURRENT_VERSION)
    {
        TestGinaError(GINAERR_INVALID_LEVEL, TEXT("TestNegotiate"));
    }

    FLAG_OFF(fTestGina, GINA_NEGOTIATE_OK);
    FLAG_ON(fTestGina, GINA_INITIALIZE_OK);

    UpdateMenuBar();

    GinaState = Winsta_Initialize;
    LastRetCode = WLX_SAS_ACTION_BOOL_RET;
    LastBoolRet = ret;

    UpdateStatusBar();

    return(TRUE);

}


BOOLEAN
TestInitialize(void)
{
    PVOID   pContext = NULL;
    BOOL ret;

    if (!TEST_FLAG(fTestGina, GINA_INITIALIZE_OK))
    {
        TestGinaError(0, TEXT("TestInitialize"));
    }

    AssociateHandle((HANDLE) 1);

    UpdateGinaState(UPDATE_INITIALIZE);

    FLAG_OFF(fTestGina, GINA_INITIALIZE_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDOUT_OK);
    FLAG_ON(fTestGina, GINA_SHUTDOWN_OK);
    FLAG_ON(fTestGina, GINA_DISPLAY_OK);

    UpdateMenuBar();

    if (TEST_FLAG(GinaBreakFlags, BREAK_INITIALIZE))
    {
        LogEvent(0, "About to call WlxInitialize(%ws, 1, @%#x, @%#x)\n",
                    TEXT("winsta0"), &WlxDispatchTable, &pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    ret = pWlxInitialize( TEXT("winsta0"),
                    (HANDLE) 1,
                    NULL,
                    &WlxDispatchTable,
                    &pContext );

    StashContext(pContext);

    GinaState = Winsta_NoOne;
    LastRetCode = WLX_SAS_ACTION_BOOL_RET;
    LastBoolRet = ret;

    UpdateStatusBar();
    EnableOptions( TRUE );

    return(TRUE);
}

DWORD
TestDisplaySASNoticeWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   err;

    if (!TEST_FLAG(fTestGina, GINA_DISPLAY_OK))
    {
        TestGinaError(0, TEXT("TestDisplaySASNotice"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_DISPLAY))
    {
        LogEvent(0, "About to call WlxDisplaySASNotice(%#x) \n", pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    pWlxDisplaySASNotice(pContext);

    err = GetLastError();


    return(err == 0 ? TRUE : FALSE);

}

BOOLEAN
TestDisplaySASNotice(void)
{
    DWORD   tid;

    UpdateGinaState(UPDATE_DISPLAY_NOTICE);

    hThread = CreateThread( NULL, 0, TestDisplaySASNoticeWorker,
                            NULL, 0, &tid);

    CloseHandle(hThread);

    return(TRUE);
}


/***************************************************************************\
* CreateLogonSid
*
* Creates a logon sid for a new logon.
*
* If LogonId is non NULL, on return the LUID that is part of the logon
* sid is returned here.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSID
CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        TestGinaError(0, TEXT("CreateLogonSid"));
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Length);
    ASSERTMSG("Winlogon failed to allocate memory for logonsid", Sid != NULL);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &gSystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}

DWORD
TestLoggedOutSASWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   res;
    LUID    LogonId;
    PSID    pSid;
    WLX_MPR_NOTIFY_INFO MprInfo;
    PWLX_PROFILE_V2_0   pProfile;
    DWORD   Options;

    if (!TEST_FLAG(fTestGina, GINA_LOGGEDOUT_OK))
    {
        TestGinaError(0, TEXT("TestLoggedOutSASWorker"));
    }

    pContext = GetContext();

    pSid = CreateLogonSid(NULL);

    if (TEST_FLAG(GinaBreakFlags, BREAK_LOGGEDOUT))
    {
        LogEvent(0, "About to call WlxLoggedOutSAS()\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }

    res = pWlxLoggedOutSAS( pContext,
                            (DWORD) pvIgnored,
                            &LogonId,
                            pSid,
                            &Options,
                            &hToken,
                            &MprInfo,
                            &pProfile );

    if (!ValidResponse(WLX_LOGGEDOUTSAS_API, res))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxLoggedOutSAS"));
    }

    if (res == WLX_SAS_ACTION_LOGON)
    {
        UpdateGinaState(UPDATE_USER_LOGON);
        FLAG_OFF(fTestGina, GINA_LOGGEDOUT_OK);
        FLAG_OFF(fTestGina, GINA_DISPLAY_OK);
        FLAG_ON(fTestGina, GINA_ACTIVATE_OK);
        UpdateMenuBar();
        if (MprInfo.pszUserName || MprInfo.pszDomain || MprInfo.pszPassword ||
            MprInfo.pszOldPassword)
        {
//          FLAG_ON(fTestGina, GINA_MPRINFO_RECV);
            GlobalMprInfo = MprInfo;
            wcscpy( GlobalProviderName, TEXT("All") );
        }
    }
    if (res == WLX_SAS_ACTION_NONE)
    {
        UpdateGinaState(UPDATE_SAS_COMPLETE);
    }


    return(res);

}

int
TestLoggedOutSAS(int    SasType)
{
    DWORD   tid;

    hThread = CreateThread( NULL, 0, TestLoggedOutSASWorker,
                            (PVOID) SasType, 0, &tid);

    CloseHandle(hThread);

    return(TRUE);

}

int
TestActivateUserShell(void)
{
    PVOID   pContext = NULL;
    PVOID   pEnvironment = NULL;

    if (!TEST_FLAG(fTestGina, GINA_ACTIVATE_OK) )
    {
        TestGinaError(0, TEXT("TestActivateUserShell"));
    }

    pContext = GetContext();

    pEnvironment = GetEnvironmentStrings();

    pWlxActivateUserShell(  pContext,
                            TEXT("Winsta0\\Default"),
                            NULL,
                            pEnvironment );

    FLAG_OFF(fTestGina, GINA_ACTIVATE_OK);
    FLAG_ON(fTestGina, GINA_LOGGEDON_OK);
    UpdateMenuBar();

    return(0);
}

int
TestLoggedOnSAS(int SasType)
{
    PVOID                   pContext = NULL;
    WLX_MPR_NOTIFY_INFO     MprInfo;
    DWORD                   Result;

    if (!TEST_FLAG(fTestGina, GINA_LOGGEDON_OK))
    {
        TestGinaError(0, TEXT("TestLoggedOnSAS"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_LOGGEDON))
    {
        LogEvent(0, "About to call WlxLoggedOnSAS\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    Result = pWlxLoggedOnSAS(   pContext,
                                SasType,
                                &MprInfo );

    if (!ValidResponse(WLX_LOGGEDONSAS_API, Result))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxLoggedOnSAS"));
    }

    switch (Result)
    {
        case WLX_SAS_ACTION_NONE:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            break;

        case WLX_SAS_ACTION_TASKLIST:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            break;

        case WLX_SAS_ACTION_LOCK_WKSTA:
            LockTestGina();
            break;

        case WLX_SAS_ACTION_LOGOFF:
            LogoffUser();
            break;

        case WLX_SAS_ACTION_SHUTDOWN:
        case WLX_SAS_ACTION_SHUTDOWN_REBOOT:
        case WLX_SAS_ACTION_SHUTDOWN_POWER_OFF:
            LogoffUser();
            UpdateGinaState(UPDATE_SHUTDOWN);
            break;

        default:
            TestGinaError(0, TEXT("TestLoggedOnSAS_2"));

    }

    return(0);
}

DWORD
TestDisplayLockedWorker(PVOID    pvIgnored)
{
    PVOID   pContext = NULL;
    DWORD   err;

    if (!TEST_FLAG(fTestGina, GINA_DISPLAYLOCK_OK))
    {
        TestGinaError(0, TEXT("TestDisplayLocked"));
    }

    pContext = GetContext();

    if (TEST_FLAG(GinaBreakFlags, BREAK_DISPLAYLOCKED))
    {
        LogEvent(0, "About to call WlxDisplayLockedNotice(%#x) \n", pContext);
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    pWlxDisplayLockedNotice(pContext);

    err = GetLastError();


    return(err == 0 ? TRUE : FALSE);

}
int
TestDisplayLockedNotice(void)
{
    DWORD   tid;

    hThread = CreateThread( NULL, 0, TestDisplayLockedWorker,
                            NULL, 0, &tid);

    CloseHandle(hThread);

    return(0);
}


int
TestWkstaLockedSAS(int  SasType)
{
    PVOID   pContext;
    DWORD   Result;

    pContext = GetContext();

    if (!TEST_FLAG(fTestGina, GINA_WKSTALOCK_OK))
    {
        TestGinaError(0, TEXT("TestWkstaLockedSAS"));
    }

    if (TEST_FLAG(GinaBreakFlags, BREAK_WKSTALOCKED))
    {
        LogEvent(0, "About to call WlxWkstaLockedSAS\n");
        if (AmIBeingDebugged())
        {
            DebugBreak();
        }
    }
    Result = pWlxWkstaLockedSAS(pContext,
                                SasType);

    if (!ValidResponse(WLX_WKSTALOCKEDSAS_API, Result))
    {
        TestGinaError(GINAERR_INVALID_RETURN, TEXT("WlxWkstaLockedSAS"));
    }

    switch (Result)
    {
        case WLX_SAS_ACTION_NONE:
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            return(0);

        case WLX_SAS_ACTION_UNLOCK_WKSTA:
            UnlockTestGina();
            return(0);

        case WLX_SAS_ACTION_FORCE_LOGOFF:
            LogoffUser();
            UpdateGinaState(UPDATE_SAS_COMPLETE);
            return(0);

        default:
            TestGinaError(0, TEXT("TestWkstaLockedSAS_2"));
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testnp\testnp.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <npapi.h>
#include <ntsecapi.h>
#include <stdio.h>
#include <stdlib.h>

BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );

        case DLL_PROCESS_DETACH:
        default:
            return(TRUE);
    }
}

VOID
DebugOut(
    PSTR Format,
    ...
    )
{
    va_list ArgList;
    CHAR Buffer[ 256 ];

    va_start( ArgList, Format );
    _vsnprintf( Buffer, 256, Format, ArgList );
    OutputDebugString( Buffer );
}

DWORD
WINAPI
NPGetCaps(
         DWORD nIndex
         )
{
   DWORD dwRes;

   switch (nIndex)
   {

   case WNNC_NET_TYPE:
      dwRes = 0xffff0000; // credential manager
      break;

   case WNNC_SPEC_VERSION:
      dwRes = WNNC_SPEC_VERSION51;  // We are using version 5.1 of the spec.
      break;

   case WNNC_DRIVER_VERSION:
      dwRes = 1;  // This driver is version 1.
      break;

   case WNNC_START:
      dwRes = 1;  // We are already "started"
      break;

   default:
      dwRes = 0;  // We don't support anything else
      break;
   }

   return dwRes;

}


/****************************************************************************
   FUNCTION: NPLogonNotify

   PURPOSE:  This entry point is called when a user logs on.  If the user
             authentication fails here, the user will still be logged on
             to the local machine.

*******************************************************************************/
DWORD
WINAPI
NPLogonNotify (
              PLUID               lpLogonId,
              LPCWSTR             lpAuthentInfoType,
              LPVOID              lpAuthentInfo,
              LPCWSTR             lpPreviousAuthentInfoType,
              LPVOID              lpPreviousAuthentInfo,
              LPWSTR              lpStationName,
              LPVOID              StationHandle,
              LPWSTR              *lpLogonScript
              )
{
    PMSV1_0_INTERACTIVE_LOGON pAuthInfo;


    //
    // Write out some information about the logon attempt
    //

    DebugOut( "NPLogonNotify\n" );

    DebugOut( "lpAuthentInfoType=%ws lpStationName=%ws\r\n",
            lpAuthentInfoType, lpStationName);



    // Do something with the authentication information
    //
    pAuthInfo = (PMSV1_0_INTERACTIVE_LOGON) lpAuthentInfo;

    DebugOut( "LogonDomain=%ws User=%ws\r\n",
            pAuthInfo->LogonDomainName.Buffer,
             pAuthInfo->UserName.Buffer);
      

    return NO_ERROR;
}


/****************************************************************************
   FUNCTION: NPPasswordChangeNotify

   PURPOSE:  This function is used to notify a credential manager provider
             of a password change (or, more accurately, an authentication
             information change) for an account.

*******************************************************************************/
DWORD
WINAPI
NPPasswordChangeNotify (
                       LPCWSTR             lpAuthentInfoType,
                       LPVOID              lpAuthentInfo,
                       LPCWSTR             lpPreviousAuthentInfoType,
                       LPVOID              lpPreviousAuthentInfo,
                       LPWSTR              lpStationName,
                       LPVOID              StationHandle,
                       DWORD               dwChangeInfo
                       )
{
    DebugOut( "NPPasswordChangeNotify\n" );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\windproc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       windproc.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"
#include <commdlg.h>

WCHAR szFilter[] = TEXT("DLLs (*.dll)\0*.dll\0\0");

DoLoadDll(void)
{
    if (LoadGinaDll())
    {
        WCHAR   szCaption[MAX_PATH];

        fTestGina |= GINA_DLL_KNOWN;
        SaveParameters();
        wcscpy(szCaption, TEXT("TestGina - "));
        wcscat(szCaption, szGinaDll);
        SetWindowText(hMainWindow, szCaption);
        GinaState = Winsta_PreLoad;
        UpdateStatusBar();
        LoadGinaSpecificParameters();
        UpdateSasMenu();
    }

    UpdateMenuBar();
    return(0);
}


int
GetFile()
{
    OPENFILENAME    ofn;

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hMainWindow;
    ofn.hInstance = hAppInstance;
    ofn.lpstrFilter =  szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szGinaDll;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = TEXT("Load A DLL");
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_NOTESTFILECREATE |
                OFN_PATHMUSTEXIST ;
    ofn.lpstrDefExt = TEXT("DLL");

    if (GetOpenFileName(&ofn))
    {
        DoLoadDll();
    }

    return(0);
}

LRESULT
MprDialogProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    if (Message == WM_INITDIALOG)
    {
        SetDlgItemText(hDlg, IDD_VIEW_MPR_USERNAME,
                    (GlobalMprInfo.pszUserName ? GlobalMprInfo.pszUserName : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_DOMAIN,
                    (GlobalMprInfo.pszDomain ? GlobalMprInfo.pszDomain : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_PASSWORD,
                    (GlobalMprInfo.pszPassword ? GlobalMprInfo.pszPassword : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_OLD_PASSWORD,
                    (GlobalMprInfo.pszOldPassword ? GlobalMprInfo.pszOldPassword : TEXT("<Null>")));
        SetDlgItemText(hDlg, IDD_VIEW_MPR_PROVIDER,
                    GlobalProviderName);

        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_USERNAME ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_DOMAIN ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_OLD_PASSWORD ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDD_VIEW_MPR_PROVIDER ), FALSE );

        return(TRUE);
    }
    if (Message == WM_COMMAND)
    {
        if (LOWORD(wParam) == IDOK)
        {
            EndDialog(hDlg, IDOK);
            return(TRUE);
        }
    }
    return(FALSE);
}

void
DoViewMPR(void)
{
    DialogBox(  hAppInstance,
                MAKEINTRESOURCE(IDD_VIEW_MPR),
                hMainWindow,
                MprDialogProc );
}

SasBoxProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    USER_SAS    Sas;

    switch (Message)
    {
        case WM_INITDIALOG:
            SetDlgItemText( hDlg, IDD_SAS_USERNAME, TEXT("User Defined") );
            SetDlgItemText( hDlg, IDD_SAS_VALUE, TEXT("128") );
            if (UserSases == MAX_USER_SASES)
            {
                EnableWindow( GetDlgItem(hDlg, IDD_SAS_KEEPAROUND), FALSE );
            }
            EnableWindow( GetDlgItem( hDlg, IDD_SAS_REMOVE ), FALSE );
            return( TRUE );

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog( hDlg, IDCANCEL );
            }
            if ((LOWORD(wParam) == IDOK) ||
                (LOWORD(wParam) == IDD_SAS_REMOVE) )
            {
                GetDlgItemText(hDlg, IDD_SAS_USERNAME, Sas.Name, 128);
                Sas.Value = GetDlgItemInt(hDlg, IDD_SAS_VALUE, NULL, FALSE );

                if (Sas.Value <= WLX_SAS_TYPE_MAX_MSFT_VALUE)
                {
                    MessageBox( hDlg, TEXT("Invalid SAS Value!"), TEXT("Error"),
                                MB_OK | MB_ICONERROR);

                }
                else
                {

                    if (IsDlgButtonChecked(hDlg, IDD_SAS_KEEPAROUND) == BST_CHECKED)
                    {
                        //
                        // Ok, big update time:
                        //

                        UserDefSas[UserSases ++ ] = Sas;
                        SaveGinaSpecificParameters();
                        UpdateSasMenu();
                    }

                    EndDialog( hDlg, Sas.Value );
                }

            }
            return( TRUE );


    }
    return( FALSE );
}

ToggleDebugItem(DWORD   MenuId,
                DWORD   FlagId)
{
    DWORD   fuFlags;

    if (TEST_FLAG(GinaBreakFlags, FlagId))
    {
        FLAG_OFF(GinaBreakFlags, FlagId);
        fuFlags = MF_UNCHECKED;
    }
    else
    {
        FLAG_ON(GinaBreakFlags, FlagId);
        fuFlags = MF_CHECKED;
    }

    fuFlags |= MF_BYCOMMAND;
    CheckMenuItem(hDebugMenu, MenuId, fuFlags);
    DrawMenuBar(hMainWindow);
    return(0);
}


void
ShowDialogUnits(HWND    hWnd)
{
    CHAR    Buff[256];
    LONG    l;
    LONG    DlgX;
    LONG    DlgY;

    l = GetDialogBaseUnits();
    DlgX = LOWORD(l);
    DlgY = HIWORD(l);

    sprintf(Buff, "BaseUnits are\nX = %d\nY = %d", DlgX, DlgY);
    MessageBoxA( hWnd, Buff, "Hello!", MB_OK);


}

VOID
DoSendSS( VOID )
{

}

VOID
DoSendLogoff( VOID )
{

}


LRESULT
DoCommand(  HWND    hWnd,
            UINT    Message,
            WPARAM  wParam,
            LPARAM  lParam)
{
    DWORD   res;

    switch (wParam)
    {
        case IDM_DLL_EXIT:
            PostQuitMessage(0);
            return(0);

        case IDM_DLL_OPEN:
            GetFile();
            return(0);


        case IDM_DLL_LOAD_LAST:
            DoLoadDll();
            return(0);

        case IDM_WHACK_NEGOTIATE:
            TestNegotiate();
            return(0);

        case IDM_WHACK_INITIALIZE:
            TestInitialize();
            return(0);

        case IDM_WHACK_DISPLAY:
            TestDisplaySASNotice();
            return(0);

        case IDM_WHACK_LOGGEDOUT:
            UpdateGinaState(UPDATE_SAS_BYPASS);
            TestLoggedOutSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_WHACK_STARTSHELL:
            TestActivateUserShell();
            return(0);

        case IDM_WHACK_LOGGEDON:
            UpdateGinaState(UPDATE_SAS_RECEIVED);
            TestLoggedOnSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_WHACK_DISPLAYLOCKED:
            TestDisplayLockedNotice();
            return(0);

        case IDM_WHACK_LOCKED:
            UpdateGinaState(UPDATE_SAS_RECEIVED);
            TestWkstaLockedSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_SAS_CAD:
            PingSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
            return(0);

        case IDM_SAS_TIMEOUT:
            PingSAS(WLX_SAS_TYPE_TIMEOUT);
            return(0);

        case IDM_SAS_SCRNSVR:
            PingSAS(WLX_SAS_TYPE_SCRNSVR_TIMEOUT);
            return(0);

        case IDM_SAS_SC_INSERT:
            PingSAS(WLX_SAS_TYPE_SC_INSERT );
            return(0);

        case IDM_SAS_SC_REMOVE:
            PingSAS( WLX_SAS_TYPE_SC_REMOVE );
            return(0);

        case IDM_SAS_USERDEF1:
            PingSAS(UserDefSas[0].Value);
            return(0);

        case IDM_SAS_USERDEF2:
            PingSAS(UserDefSas[1].Value);
            return(0);

        case IDM_SAS_USERDEF3:
            PingSAS(UserDefSas[2].Value);
            return(0);

        case IDM_SAS_USERDEF4:
            PingSAS(UserDefSas[3].Value);
            return(0);

        case IDM_SAS_USERDEF:
            res = DialogBox(  hAppInstance,
                        MAKEINTRESOURCE(IDD_USERDEF_SAS),
                        hMainWindow,
                        SasBoxProc );
            if (res != IDCANCEL)
            {
                PingSAS( res );
            }
            return( 0 );

        case IDM_OPTIONS_SSNOTIFY:
            DoSendSS();
            return( 0 );

        case IDM_OPTIONS_LOGOFF:
            DoSendLogoff();
            return( 0 );

        case IDM_OPTIONS_VIEW_MPR:
            DoViewMPR();
            return(0);

        case IDM_HELP_ABOUT:
            ShellAbout(hWnd, TEXT("TestGina"), TEXT("Graphical Logon Tester"), hIcon);
            return(0);

        case IDM_DEBUG_BREAK_NOW:
            if (AmIBeingDebugged())
            {
                DebugBreak();
            }
            return(0);

        case IDM_DEBUG_NEGOTIATE:
            ToggleDebugItem(IDM_DEBUG_NEGOTIATE, BREAK_NEGOTIATE);
            return(0);

        case IDM_DEBUG_INITIALIZE:
            ToggleDebugItem(IDM_DEBUG_INITIALIZE, BREAK_INITIALIZE);
            return(0);

        case IDM_DEBUG_DISPLAYSAS:
            ToggleDebugItem(IDM_DEBUG_DISPLAYSAS, BREAK_DISPLAY);
            return(0);

        case IDM_DEBUG_LOGGEDOUT:
            ToggleDebugItem(IDM_DEBUG_LOGGEDOUT, BREAK_LOGGEDOUT);
            return(0);

        case IDM_DEBUG_ACTIVATE:
            ToggleDebugItem(IDM_DEBUG_ACTIVATE, BREAK_ACTIVATE);
            return(0);

        case IDM_DEBUG_LOGGEDON:
            ToggleDebugItem(IDM_DEBUG_LOGGEDON, BREAK_LOGGEDON);
            return(0);

        case IDM_DEBUG_DISPLAYLOCKED:
            ToggleDebugItem(IDM_DEBUG_DISPLAYLOCKED, BREAK_DISPLAYLOCKED);
            return(0);

        case IDM_DEBUG_LOCKED:
            ToggleDebugItem(IDM_DEBUG_LOCKED, BREAK_WKSTALOCKED);
            return(0);

        case IDM_DEBUG_LOGOFF:
            ToggleDebugItem(IDM_DEBUG_LOGOFF, BREAK_LOGOFF);
            return(0);

        case IDM_DEBUG_SHUTDOWN:
            ToggleDebugItem(IDM_DEBUG_SHUTDOWN, BREAK_SHUTDOWN);
            return(0);
    }
    return 0;
}

LRESULT
CreateMainWindow(
    HWND    hWnd,
    WPARAM  wParam,
    LPARAM  lParam )
{


    hStatusWindow = CreateStatusWindow(
                        WS_CHILD | WS_BORDER | WS_VISIBLE | SBARS_SIZEGRIP,
                        TEXT("Initializing"),
                        hWnd,
                        10 );

    if (hStatusWindow == NULL)
    {
        return( FALSE );
    }

    UpdateStatusBar();

    return( TRUE );

}


LRESULT
CALLBACK
WndProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    RECT    rect;

    switch (Message)
    {
        case WM_CREATE:
            return( CreateMainWindow( hWnd, wParam, lParam ) );
        case WM_CLOSE:
            PostQuitMessage(0);
            return(0);

        case WM_SIZE:
        case WM_MOVE:
            if ((Message == WM_SIZE) && (wParam != SIZE_RESTORED))
            {
                break;
            }

            GetWindowRect(hWnd, &rect);
            PosX = rect.left;
            PosY = rect.top;
            SizeX = rect.right - rect.left;
            SizeY = rect.bottom - rect.top;
            SaveParameters();
            SendMessage( hStatusWindow, Message, wParam, lParam );
            UpdateStatusBar();
            return(0);

        case WM_HOTKEY:
            if (wParam == 0)
            {
                if (TEST_FLAG(fTestGina, GINA_USE_CAD))
                {
                    PingSAS(WLX_SAS_TYPE_CTRL_ALT_DEL);
                }
            }
            OutputDebugStringA("Got a hotkey!\n");
            return(0);

        case WM_COMMAND:
            return DoCommand(hWnd, Message, wParam, lParam);
    }
    return(DefWindowProc(hWnd, Message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testshim\testshim.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    ginastub.c

Abstract:


--*/

#include <windows.h>
#include <stdio.h>
#include <winwlx.h>

#include "testshim.h"

//
// Location of the real msgina.
//

#define REALGINA_PATH   TEXT("MSGINA.DLL")


//
// winlogon function dispatch table
//

WLX_DISPATCH_VERSION_1_3 WinlogonTable;
PWLX_DISPATCH_VERSION_1_3 pTable ;

//
// Functions pointers to the real msgina which we will call.
//

PGWLXNEGOTIATE GWlxNegotiate;
PGWLXINITIALIZE GWlxInitialize;
PGWLXDISPLAYSASNOTICE GWlxDisplaySASNotice;
PGWLXLOGGEDOUTSAS GWlxLoggedOutSAS;
PGWLXACTIVATEUSERSHELL GWlxActivateUserShell;
PGWLXLOGGEDONSAS GWlxLoggedOnSAS;
PGWLXDISPLAYLOCKEDNOTICE GWlxDisplayLockedNotice;
PGWLXWKSTALOCKEDSAS GWlxWkstaLockedSAS;
PGWLXISLOCKOK GWlxIsLockOk;
PGWLXISLOGOFFOK GWlxIsLogoffOk;
PGWLXLOGOFF GWlxLogoff;
PGWLXSHUTDOWN GWlxShutdown;

//
// NEW for version 1.1
//

PGWLXSTARTAPPLICATION GWlxStartApplication;
PGWLXSCREENSAVERNOTIFY GWlxScreenSaverNotify;

//
// Scum Level
//

ULONG ScumLevel = 0 ;

#define SCUM_CLEAN  2 
#define SCUM_DIRTY  1 
#define SCUM_RANCID 0 

//
// hook into the real GINA.
//

BOOL
MyInitialize( void )
{
    HINSTANCE hDll;

    //
    // Load MSGINA.DLL.
    //
    if( !(hDll = LoadLibrary( REALGINA_PATH )) ) {
        return FALSE;
    }

    ScumLevel = GetProfileInt( TEXT("Winlogon"), 
                               TEXT("ShimScum"),
                               0 );

    //
    // Get pointers to all of the WLX functions in the real MSGINA.
    //
    GWlxNegotiate = (PGWLXNEGOTIATE)GetProcAddress( hDll, "WlxNegotiate" );
    if( !GWlxNegotiate ) {
        return FALSE;
    }

    GWlxInitialize = (PGWLXINITIALIZE)GetProcAddress( hDll, "WlxInitialize" );
    if( !GWlxInitialize ) {
        return FALSE;
    }

    GWlxDisplaySASNotice =
        (PGWLXDISPLAYSASNOTICE)GetProcAddress( hDll, "WlxDisplaySASNotice" );
    if( !GWlxDisplaySASNotice ) {
        return FALSE;
    }

    GWlxLoggedOutSAS =
        (PGWLXLOGGEDOUTSAS)GetProcAddress( hDll, "WlxLoggedOutSAS" );
    if( !GWlxLoggedOutSAS ) {
        return FALSE;
    }

    GWlxActivateUserShell =
        (PGWLXACTIVATEUSERSHELL)GetProcAddress( hDll, "WlxActivateUserShell" );
    if( !GWlxActivateUserShell ) {
        return FALSE;
    }

    GWlxLoggedOnSAS =
        (PGWLXLOGGEDONSAS)GetProcAddress( hDll, "WlxLoggedOnSAS" );
    if( !GWlxLoggedOnSAS ) {
        return FALSE;
    }

    GWlxDisplayLockedNotice =
        (PGWLXDISPLAYLOCKEDNOTICE)GetProcAddress(
                                        hDll,
                                        "WlxDisplayLockedNotice" );
    if( !GWlxDisplayLockedNotice ) {
        return FALSE;
    }

    GWlxIsLockOk = (PGWLXISLOCKOK)GetProcAddress( hDll, "WlxIsLockOk" );
    if( !GWlxIsLockOk ) {     
        return FALSE;
    }

    GWlxWkstaLockedSAS =
        (PGWLXWKSTALOCKEDSAS)GetProcAddress( hDll, "WlxWkstaLockedSAS" );
    if( !GWlxWkstaLockedSAS ) {
        return FALSE;
    }

    GWlxIsLogoffOk = (PGWLXISLOGOFFOK)GetProcAddress( hDll, "WlxIsLogoffOk" );
    if( !GWlxIsLogoffOk ) {
        return FALSE;
    }

    GWlxLogoff = (PGWLXLOGOFF)GetProcAddress( hDll, "WlxLogoff" );
    if( !GWlxLogoff ) {
        return FALSE;
    }

    GWlxShutdown = (PGWLXSHUTDOWN)GetProcAddress( hDll, "WlxShutdown" );
    if( !GWlxShutdown ) {
        return FALSE;
    }

    //
    // we don't check for failure here because these don't exist for
    // gina's implemented prior to Windows NT 4.0
    //

    GWlxStartApplication = (PGWLXSTARTAPPLICATION) GetProcAddress( hDll, "WlxStartApplication" );
    GWlxScreenSaverNotify = (PGWLXSCREENSAVERNOTIFY) GetProcAddress( hDll, "WlxScreenSaverNotify" );

    //
    // Everything loaded ok.  Return success.
    //
    return TRUE;
}


BOOL
WINAPI
WlxNegotiate(
    DWORD       dwWinlogonVersion,
    DWORD       *pdwDllVersion)
{
    BOOL NegRet ;

    if( !MyInitialize() )
        return FALSE;

    NegRet = GWlxNegotiate(
                ( (ScumLevel == SCUM_RANCID) ? dwWinlogonVersion :
                  (ScumLevel == SCUM_DIRTY) ? WLX_VERSION_1_2 :
                    dwWinlogonVersion ),
                pdwDllVersion );

    return NegRet ;


}


BOOL
WINAPI
WlxInitialize(
    LPWSTR      lpWinsta,
    HANDLE      hWlx,
    PVOID       pvReserved,
    PVOID       pWinlogonFunctions,
    PVOID       *pWlxContext)
{
    switch ( ScumLevel )
    {
        case SCUM_RANCID:
        case SCUM_DIRTY:
            CopyMemory( &WinlogonTable,
                        pWinlogonFunctions,
                        sizeof( WLX_DISPATCH_VERSION_1_2 ) );
            pTable = &WinlogonTable ;
            break;

        case SCUM_CLEAN:
            pTable = pWinlogonFunctions ;
            break;
            
    }
    return GWlxInitialize(
                lpWinsta,
                hWlx,
                pvReserved,
                pTable,
                pWlxContext
                );
}


VOID
WINAPI
WlxDisplaySASNotice(
    PVOID   pWlxContext)
{
    GWlxDisplaySASNotice( pWlxContext );
}


int
WINAPI
WlxLoggedOutSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType,
    PLUID           pAuthenticationId,
    PSID            pLogonSid,
    PDWORD          pdwOptions,
    PHANDLE         phToken,
    PWLX_MPR_NOTIFY_INFO    pMprNotifyInfo,
    PVOID           *pProfile)
{
    int iRet;

    iRet = GWlxLoggedOutSAS(
                pWlxContext,
                dwSasType,
                pAuthenticationId,
                pLogonSid,
                pdwOptions,
                phToken,
                pMprNotifyInfo,
                pProfile
                );

    if(iRet == WLX_SAS_ACTION_LOGON) {
        //
        // copy pMprNotifyInfo and pLogonSid for later use
        //

        // pMprNotifyInfo->pszUserName
        // pMprNotifyInfo->pszDomain
        // pMprNotifyInfo->pszPassword
        // pMprNotifyInfo->pszOldPassword

    }

    return iRet;
}


BOOL
WINAPI
WlxActivateUserShell(
    PVOID           pWlxContext,
    PWSTR           pszDesktopName,
    PWSTR           pszMprLogonScript,
    PVOID           pEnvironment)
{
    return GWlxActivateUserShell(
                pWlxContext,
                pszDesktopName,
                pszMprLogonScript,
                pEnvironment
                );
}


int
WINAPI
WlxLoggedOnSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType,
    PVOID           pReserved)
{
    return GWlxLoggedOnSAS( pWlxContext, dwSasType, pReserved );
}

VOID
WINAPI
WlxDisplayLockedNotice(
    PVOID           pWlxContext )
{
    GWlxDisplayLockedNotice( pWlxContext );
}


BOOL
WINAPI
WlxIsLockOk(
    PVOID           pWlxContext)
{
    return GWlxIsLockOk( pWlxContext );
}


int
WINAPI
WlxWkstaLockedSAS(
    PVOID           pWlxContext,
    DWORD           dwSasType )
{
    return GWlxWkstaLockedSAS( pWlxContext, dwSasType );
}

BOOL
WINAPI
WlxIsLogoffOk(
    PVOID pWlxContext
    )
{
    BOOL bSuccess;

    bSuccess = GWlxIsLogoffOk( pWlxContext );

    if(bSuccess) {

        //
        // if it's ok to logoff, finish with the stored credentials
        // and scrub the buffers
        //

    }

    return bSuccess;
}


VOID
WINAPI
WlxLogoff(
    PVOID pWlxContext
    )
{
    GWlxLogoff( pWlxContext );
}


VOID
WINAPI
WlxShutdown(
    PVOID pWlxContext,
    DWORD ShutdownType
    )
{
    GWlxShutdown( pWlxContext, ShutdownType );
}


//
// NEW for version 1.1
//

BOOL
WINAPI
WlxScreenSaverNotify(
    PVOID                   pWlxContext,
    BOOL *                  pSecure
    )
{
    if(GWlxScreenSaverNotify != NULL)
        return GWlxScreenSaverNotify( pWlxContext, pSecure );

    //
    // if not exported, return something intelligent
    //

    *pSecure = TRUE;

    return TRUE;
}

BOOL
WINAPI
WlxStartApplication(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktopName,
    PVOID                   pEnvironment,
    PWSTR                   pszCmdLine
    )
{
    if(GWlxStartApplication != NULL)
        return GWlxStartApplication(
            pWlxContext,
            pszDesktopName,
            pEnvironment,
            pszCmdLine
            );

    //
    // if not exported, return something intelligent
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testgina\winutil.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       winutil.c
//
//  Contents:   General Utilities to test ginas
//
//  Classes:
//
//  Functions:
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "testgina.h"

DWORD DummySCData = sizeof( DWORD ) ;

typedef struct _WindowMapper {
    DWORD                   fMapper;
    HWND                    hWnd;
    DLGPROC                 DlgProc;
    struct _WindowMapper *  pPrev;
    LPARAM                  InitialParameter;
} WindowMapper, * PWindowMapper;
#define MAPPERFLAG_ACTIVE   1
#define MAPPERFLAG_DIALOG   2
#define MAPPERFLAG_SAS      4

#define MAX_WINDOW_MAPPERS  32

WindowMapper    Mappers[MAX_WINDOW_MAPPERS];
DWORD           cActiveWindow;

void
InitWindowMappers()
{
    ZeroMemory(Mappers, sizeof(WindowMapper) * MAX_WINDOW_MAPPERS);
    cActiveWindow = 0;
}

PWindowMapper
LocateTopMappedWindow(void)
{
    int i;
    for (i = 0; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if (Mappers[i].fMapper & MAPPERFLAG_SAS)
        {
            return(&Mappers[i]);
        }
    }

    return(NULL);

}

PWindowMapper
AllocWindowMapper(void)
{
    int i;
    PWindowMapper   pMap;

    for (i = 0 ; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if ((Mappers[i].fMapper & MAPPERFLAG_ACTIVE) == 0)
        {
            cActiveWindow ++;
            pMap = LocateTopMappedWindow();
            if (pMap)
            {
                FLAG_OFF(pMap->fMapper, MAPPERFLAG_SAS);
            }

            FLAG_ON(Mappers[i].fMapper, MAPPERFLAG_ACTIVE | MAPPERFLAG_SAS);
            Mappers[i].pPrev = pMap;

            return(&Mappers[i]);
        }
    }
    return(NULL);
}

PWindowMapper
LocateWindowMapper(HWND hWnd)
{
    int i;

    for (i = 0; i < MAX_WINDOW_MAPPERS ; i++ )
    {
        if (Mappers[i].hWnd == hWnd)
        {
            return(&Mappers[i]);
        }
    }

    return(NULL);
}

void
FreeWindowMapper(PWindowMapper  pMap)
{
    pMap->hWnd = NULL;
    pMap->DlgProc = NULL;
    if (pMap->fMapper & MAPPERFLAG_SAS)
    {
        if (pMap->pPrev)
        {
            FLAG_ON(pMap->pPrev->fMapper, MAPPERFLAG_SAS);
        }
    }
    pMap->fMapper = 0;
    pMap->pPrev = NULL;
    cActiveWindow--;
}


#define CALAIS_PATH         TEXT("Software\\Microsoft\\Cryptography\\Calais")
BOOL
IsSmartCardReaderPresent(
    VOID
    )
{
    HKEY hKey ;
    int err ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        CALAIS_PATH,
                        0,
                        KEY_READ,
                        &hKey );

    if ( err == 0 )
    {
        RegCloseKey( hKey );

        return TRUE ;
    }
    else
    {
        return FALSE ;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   RootWndProc
//
//  Synopsis:   This is the base window proc for all testgina windows.
//
//  Arguments:  [hWnd]    --
//              [Message] --
//              [wParam]  --
//              [lParam]  --
//
//  History:    7-18-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CALLBACK
RootDlgProc(
    HWND    hWnd,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    PWindowMapper   pMap;
    int res;
    BOOL bRet;

    //
    // If this is a WM_INITDIALOG message, then the parameter is the mapping,
    // which needs to have a hwnd associated with it.  Otherwise, do the normal
    // preprocessing.
    //
    if (Message == WM_INITDIALOG)
    {
        pMap = (PWindowMapper) lParam;
        pMap->hWnd = hWnd;
        lParam = pMap->InitialParameter;
    }
    else
    {
        pMap = LocateWindowMapper(hWnd);
        if (!pMap)
        {
            return(FALSE);
        }
    }

    bRet = pMap->DlgProc(hWnd, Message, wParam, lParam);
    if (!bRet)
    {
        if (Message == WM_INITDIALOG)
        {
            return(bRet);
        }
        if (Message == WLX_WM_SAS)
        {
            switch (wParam)
            {
                case WLX_SAS_TYPE_CTRL_ALT_DEL:
                default:
                    res = WLX_DLG_SAS;
                    break;

                case WLX_SAS_TYPE_TIMEOUT:
                    res = WLX_DLG_INPUT_TIMEOUT;
                    break;
                case WLX_SAS_TYPE_SCRNSVR_TIMEOUT:
                    res = WLX_DLG_SCREEN_SAVER_TIMEOUT;
                    break;
                case WLX_SAS_TYPE_USER_LOGOFF:
                    res = WLX_DLG_USER_LOGOFF;
                    break;
            }
            if (res)
            {
                EndDialog(hWnd, res);
                bRet = TRUE;
            }
            else
            {
                TestGinaError(GINAERR_INVALID_SAS_CODE, TEXT("RootDlgProc"));
            }
        }
    }

    return(bRet);

}

PingSAS(DWORD   SasType)
{
    PWindowMapper   pMap;

    if (cActiveWindow)
    {
        pMap = LocateTopMappedWindow();

        if (!pMap)
        {
            TestGinaError(GINAERR_NO_WINDOW_FOR_SAS, TEXT("PingSAS"));
        }

        PostMessage(pMap->hWnd, WLX_WM_SAS, (WPARAM) SasType, 0);
    }

    UpdateGinaState(UPDATE_SAS_RECEIVED);

    switch (GinaState)
    {
        case Winsta_NoOne_SAS:
            TestLoggedOutSAS(SasType);
            break;
        case Winsta_LoggedOn_SAS:
            TestLoggedOnSAS(SasType);
            break;
        case Winsta_Locked_SAS:
            TestWkstaLockedSAS(SasType);
            break;
        default:
            TestGinaError(0, TEXT("PingSAS"));

    }
    return(0);
}


VOID WINAPI
WlxUseCtrlAltDel(HANDLE hWlx)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxUserCtrlAltDel"));
    }

    fTestGina |= GINA_USE_CAD;

}

VOID
WINAPI
WlxSetContextPointer(
    HANDLE  hWlx,
    PVOID   pvContext)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSetContextPointer"));
    }

    StashContext(pvContext);
}


VOID WINAPI
WlxSasNotify(HANDLE     hWlx,
             DWORD      dwSasType)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSasNotify"));
    }

    if (fTestGina & GINA_USE_CAD)
    {
        if (dwSasType == WLX_SAS_TYPE_CTRL_ALT_DEL)
        {
            TestGinaError(GINAERR_IMPROPER_CAD, TEXT("WlxSasNotify"));
        }
    }

    PingSAS(dwSasType);
}


BOOL WINAPI
WlxSetTimeout(
    HANDLE      hWlx,
    DWORD       dwTimeout)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxSetTimeout"));
    }

    if (dwTimeout < 300)
    {
        return(TRUE);
    }
    return(FALSE);

}

int WINAPI
WlxAssignShellProtection(
    HANDLE      hWlx,
    HANDLE      hToken,
    HANDLE      hProcess,
    HANDLE      hThread)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxAssignShellProtection"));
    }

    return(0);
}


int WINAPI
WlxMessageBox(
    HANDLE      hWlx,
    HWND        hWnd,
    LPWSTR      lpsz1,
    LPWSTR      lpsz2,
    UINT        fmb)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxMessageBox"));
    }
    return MessageBoxW(hWnd, lpsz1, lpsz2, fmb);
}

int WINAPI
WlxDialogBox(
    HANDLE      hWlx,
    HANDLE      hInstance,
    LPWSTR      lpsz1,
    HWND        hWnd,
    DLGPROC     dlgproc)
{
    return(WlxDialogBoxParam(hWlx, hInstance, lpsz1, hWnd, dlgproc, 0));
}

int WINAPI
WlxDialogBoxIndirect(
    HANDLE          hWlx,
    HANDLE          hInstance,
    LPCDLGTEMPLATE  lpTemplate,
    HWND            hWnd,
    DLGPROC         dlgproc)
{
    return(WlxDialogBoxIndirectParam(hWlx, hInstance, lpTemplate, hWnd, dlgproc, 0));
}



int WINAPI
WlxDialogBoxParam(
    HANDLE          hWlx,
    HANDLE          hInstance,
    LPWSTR          lpsz1,
    HWND            hWnd,
    DLGPROC         dlgproc,
    LPARAM          lParam)
{
    PWindowMapper   pMap;
    int res;
    char    buf[256];

    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxDialogBoxParam"));
    }

    pMap = AllocWindowMapper();

    pMap->InitialParameter = lParam;
    pMap->DlgProc = dlgproc;
    pMap->fMapper |= MAPPERFLAG_DIALOG;

    res = DialogBoxParam(hInstance, lpsz1, hWnd, RootDlgProc, (LPARAM) pMap);
    if (res == -1)
    {
            if ((DWORD) lpsz1 > 0x00010000)
            {
                sprintf( buf, "DialogBoxParam(%#x, %ws, %#x, %#x, %#x) failed, error %d\n",
                            hInstance, lpsz1, hWnd, dlgproc,
                            lParam, GetLastError() );
            }
            else
            {
                sprintf( buf, "DialogBoxParam(%#x, %#x, %#x, %#x, %#x) failed, error %d\n",
                            hInstance, lpsz1, hWnd, dlgproc,
                            lParam, GetLastError() );

            }

            MessageBoxA( hMainWindow, buf, "Dialog Error", MB_ICONSTOP | MB_OK );
    }

    FreeWindowMapper(pMap);

    return(res);
}

int WINAPI
WlxDialogBoxIndirectParam(
    HANDLE          hWlx,
    HANDLE  hInstance,
    LPCDLGTEMPLATE  lpTemplate,
    HWND    hWnd,
    DLGPROC dlgproc,
    LPARAM  lParam)
{
    if (!VerifyHandle(hWlx))
    {
        TestGinaError(GINAERR_INVALID_HANDLE, TEXT("WlxUserCtrlAltDel"));
    }
    return(DialogBoxIndirectParam(hInstance, lpTemplate, hWnd, dlgproc, lParam));
}

int
WINAPI
WlxSwitchDesktopToUser(
    HANDLE      hWlx)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSwitchDesktopToUser"));
    }

    return( 0 );
}

int
WINAPI
WlxSwitchDesktopToWinlogon(
    HANDLE      hWlx)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSwitchDesktopToWinlogon"));
    }

    return( 0 );
}

int
WINAPI
WlxChangePasswordNotify(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxChangePasswordNotify"));
    }

    GlobalMprInfo = *pMprInfo;
    wcscpy( GlobalProviderName, TEXT("All") );

    return( 0 );

}

int
WINAPI
WlxChangePasswordNotifyEx(
    HANDLE                  hWlx,
    PWLX_MPR_NOTIFY_INFO    pMprInfo,
    DWORD                   dwChangeInfo,
    PWSTR                   ProviderName,
    PVOID                   Reserved)
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxChangePasswordNotifyEx"));
    }

    GlobalMprInfo = *pMprInfo;
    wcscpy( GlobalProviderName, ProviderName );

    return( 0 );

}


BOOL
WINAPI
WlxSetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR Value,
    ULONG_PTR * OldValue)
{
    ULONG_PTR * Item ;
    ULONG_PTR Dummy ;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }

    Item = &Dummy ;

    switch ( Option )
    {
        case WLX_OPTION_USE_CTRL_ALT_DEL:
            Dummy = (BOOL) ((fTestGina & GINA_USE_CAD) != 0);
            fTestGina |= GINA_USE_CAD;
            break;

        case WLX_OPTION_CONTEXT_POINTER:
            Item = (PDWORD) &pWlxContext ;
            break;

        case WLX_OPTION_USE_SMART_CARD:
            Dummy = (BOOL) ((fTestGina & GINA_USE_SC) != 0);
            fTestGina |= GINA_USE_SC ;
            break;

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
    }

    if ( Item )
    {
        if ( OldValue )
        {
            *OldValue = *Item ;
        }

        *Item = Value ;
    }

    return TRUE ;
}

BOOL
WINAPI
WlxGetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR * Value)
{
    ULONG_PTR * Item ;
    ULONG_PTR Dummy ;

    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }

    Item = &Dummy ;

    switch ( Option )
    {
        case WLX_OPTION_USE_CTRL_ALT_DEL:
            Dummy = (BOOL) ((fTestGina & GINA_USE_CAD) != 0);
            break;

        case WLX_OPTION_CONTEXT_POINTER:
            Item = (ULONG_PTR *) &pWlxContext ;
            break;

        case WLX_OPTION_USE_SMART_CARD:
            Dummy = (BOOL) ((fTestGina & GINA_USE_SC) != 0);
            break;

        case WLX_OPTION_SMART_CARD_PRESENT :
            Dummy = IsSmartCardReaderPresent() ;
            break;

        case WLX_OPTION_SMART_CARD_INFO :
            Dummy = (ULONG_PTR)& DummySCData ;
            Item = (ULONG_PTR *) &Dummy ;
            break;

        case WLX_OPTION_DISPATCH_TABLE_SIZE:
            Dummy = sizeof( WlxDispatchTable );
            Item = (ULONG_PTR *) &Dummy ;
            break;

        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE ;
    }

    if ( Item )
    {
        if ( Value )
        {
            *Value = *Item ;
            return TRUE ;
        }

    }

    return FALSE ;
}

VOID
WINAPI
WlxWin31Migrate(
    HANDLE hWlx
    )
{
    if ( !VerifyHandle( hWlx ) )
    {
        TestGinaError( GINAERR_INVALID_HANDLE, TEXT("WlxSetOption") );
    }
}

BOOL
WINAPI
WlxQueryClientCredentials(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    )
{
    return FALSE ;
}

BOOL
WINAPI
WlxQueryICCredentials(
    PWLX_CLIENT_CREDENTIALS_INFO_V1_0 pCred
    )
{
    return FALSE ;
}

BOOL
WINAPI
WlxDisconnect(
    VOID
    )
{
    return FALSE ;
}



struct _BitsToMenu {
    DWORD   Bits;
    DWORD   Menu;
} MenuBarControl[] = {
    {   GINA_DLL_KNOWN, IDM_DLL_RUN },
    {   GINA_NEGOTIATE_OK, IDM_WHACK_NEGOTIATE },
    {   GINA_INITIALIZE_OK, IDM_WHACK_INITIALIZE },
    {   GINA_DISPLAY_OK, IDM_WHACK_DISPLAY },
    {   GINA_LOGGEDOUT_OK, IDM_WHACK_LOGGEDOUT },
    {   GINA_ACTIVATE_OK, IDM_WHACK_STARTSHELL },
    {   GINA_LOGGEDON_OK, IDM_WHACK_LOGGEDON },
    {   GINA_DISPLAYLOCK_OK, IDM_WHACK_DISPLAYLOCKED},
    {   GINA_WKSTALOCK_OK, IDM_WHACK_LOCKED },
    {   GINA_LOGOFF_OK, IDM_WHACK_LOGOFF },
    {   GINA_SHUTDOWN_OK, IDM_WHACK_SHUTDOWN },
    {   GINA_ISLOCKOK_OK, IDM_WHACK_LOCKOK },
    {   GINA_ISLOGOFFOK_OK, IDM_WHACK_LOGOFFOK },
    {   GINA_RESTART_OK, IDM_WHACK_RESTARTSHELL },
    {   GINA_SCREENSAVE_OK, IDM_WHACK_SCREENSAVE },

    };


int
UpdateMenuBar(void)
{
    HMENU   hMenu;
    int i;

    hMenu = GetMenu(hMainWindow);

    for (i = 0; i < (sizeof(MenuBarControl) / sizeof(struct _BitsToMenu))  ; i++ )
    {
        if (TEST_FLAG(fTestGina, MenuBarControl[i].Bits))
        {
            EnableMenuItem(hMenu, MenuBarControl[i].Menu, MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu, MenuBarControl[i].Menu, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    return(0);
}

VOID
EnableOptions(BOOL  Enable)
{
    HMENU   hMenu;
    HMENU   hOptions;
    UINT    uenable;

    hMenu = GetMenu( hMainWindow );

    hOptions = GetSubMenu( hMenu, 2 );

    if (Enable)
    {
        uenable = MF_ENABLED | MF_BYCOMMAND;
    }
    else
    {
        uenable = MF_GRAYED | MF_BYCOMMAND;
    }

    EnableMenuItem( hMenu, (UINT) hOptions, uenable);

    DrawMenuBar( hMainWindow );
}

VOID
UpdateSasMenu(VOID)
{
    HMENU   hMenu;
    HMENU   hOptions;
    HMENU   hSas;
    DWORD   i;
    DWORD   MenuItem;

    hMenu = GetMenu( hMainWindow );

    hOptions = GetSubMenu( hMenu, 2 );

    hSas = GetSubMenu( hOptions, 0 );

    //
    // Clean out existing ones
    //

    DeleteMenu( hSas, IDM_SAS_USERDEF1, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF2, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF3, MF_BYCOMMAND );
    DeleteMenu( hSas, IDM_SAS_USERDEF4, MF_BYCOMMAND );

    //
    // Add in current ones:
    //

    for (i = 0, MenuItem = IDM_SAS_USERDEF1; i < UserSases ; i++, MenuItem++ )
    {
        AppendMenu( hSas, MF_STRING, MenuItem, UserDefSas[i].Name );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\uenv.h ===
//*************************************************************
//
//  Main header file for UserEnv project
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ole2.h>
#include <lm.h>
#include <lmdfs.h>
#include <ntregapi.h>
#define SECURITY_WIN32
#include <security.h>
#include <shlobj.h>

//
// Turn off shell debugging stuff so that it does not conflict
// with our debugging stuff.
//

#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "wbemcli.h"
#include <userenv.h>
#include <userenvp.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <accctrl.h>
#include <ntldap.h>
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <iphlpapi.h>
#include <icmpapi.h>
#include <dfsfsctl.h>
#include <sddl.h>
#include <winuserp.h>
#include "globals.h"

#if defined(__cplusplus)
extern "C"{
#endif
#include "debug.h"
#include "dllload.h"
#include "util.h"
#include "sid.h"
#include "pcommon.h"
#if defined(__cplusplus)
}
#endif

#include "profile.h"
#include "events.h"
#include "copydir.h"
#include "resource.h"
#include "userdiff.h"
#include "policy.h"
#include "gpt.h"
#if defined(__cplusplus)
extern "C"{
#endif

#include "gpnotif.h"

#if defined(__cplusplus)
}
#endif

#include "winbasep.h"

//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\uenvext\uenvext.cpp ===
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <dbghelp.h>
#include <ntsdexts.h>
#include <wdbgexts.h>
#include <ntverp.h>

#define private public
#define protected public

#include "uenv.h"
#include "reghash.h"

//
// forwards
//

BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
ReadMemoryKernelMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

BOOL
WriteMemoryKernelMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead );

//
// types
//

typedef BOOL (*UEnvReadMemory)( HANDLE, const void*, void*, DWORD, DWORD* );
typedef BOOL (*UEnvWriteMemory)( HANDLE, void*, void*, DWORD, DWORD* );

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion = 0;
USHORT                  SavedMinorVersion = 0;
BOOL                    fKernelDebug = FALSE;
UEnvReadMemory          ReadMemoryExt = ReadMemoryUserMode;
UEnvReadMemory          WriteMemoryExt = ReadMemoryUserMode;

//
// macros
//
#define ExtensionRoutinePrologue()  if (!fKernelDebug) \
                                    { \
                                        ExtensionApis = *lpExtensionApis; \
                                        ReadMemoryExt = ReadMemoryUserMode; \
                                        WriteMemoryExt = WriteMemoryUserMode; \
                                    } \
                                    ULONG_PTR dwAddr = GetExpression(lpArgumentString); \

#define PRINT_SIZE(_x_) {dprintf(#_x_" - 0x%X\n", sizeof(_x_));}

#define Boolean( x )    ( x ) ? "True" : "False"

//
// routines
//

BOOL
DllInit(HANDLE hModule,
        DWORD  dwReason,
        DWORD  dwReserved  )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    fKernelDebug = TRUE;
    ReadMemoryExt = ReadMemoryKernelMode;
    WriteMemoryExt = WriteMemoryKernelMode;
    
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// define our own operators new and delete, so that we do not have to include the crt
//
void* __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void* p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
ReadMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadProcessMemory( hProcess, pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
ReadMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return ReadMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryUserMode( HANDLE hProcess, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteProcessMemory( hProcess, (void*) pAddress, pBuffer, dwSize, pdwRead );
}

BOOL
WriteMemoryKernelMode( HANDLE, const void* pAddress, void* pBuffer, DWORD dwSize, DWORD* pdwRead )
{
    return WriteMemory( (ULONG) pAddress, pBuffer, dwSize, pdwRead );
}

void
PrintUuid( UUID x )
{
    dprintf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                x.Data1, x.Data2, x.Data3, x.Data4[0], x.Data4[1],
                x.Data4[2], x.Data4[3], x.Data4[4], x.Data4[5],
                x.Data4[6], x.Data4[7] );
}

void
version(HANDLE  hCurrentProcess,
        HANDLE  hCurrentThread,
        DWORD   dwCurrentPc,
        PWINDBG_EXTENSION_APIS lpExtensionApis,
        LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    if ( fKernelDebug )
    {
        dprintf( "%s UserEnv Extension dll for Build %d debugging %s kernel for Build %d\n",
                 DebuggerType,
                 VER_PRODUCTBUILD,
                 SavedMajorVersion == 0x0c ? "Checked" : "Free",
                 SavedMinorVersion
               );
    }
    else
    {
        dprintf(
                "%s UserEnv Extension dll for Build %d\n",
                DebuggerType,
                VER_PRODUCTBUILD
                );
    }
}

LPEXT_API_VERSION
ExtensionApiVersion( void )
{
    return &ApiVersion;
}

void help(  HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )

{
    ExtensionRoutinePrologue();
    dprintf("!version\n");
    dprintf("!gpo           <address>\n");
    dprintf("!gpext         <address>\n");
    dprintf("!container     <address>\n");
    dprintf("!som           <address>\n");
    dprintf("!profile       <address>\n");
    dprintf("!debuglevel    <address>\n");
    dprintf("!dmpregtable   <address>\n");
    
    // dprintf("!globals\n");
    dprintf("!sizes\n");
}

void gpo(   HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )

{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPOINFO)];
    LPGPOINFO       lpGPOInfo = (LPGPOINFO) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPOINFO), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPOINFO) )
    {
        dprintf("dwFlags                 - 0x%08X\n", lpGPOInfo->dwFlags );
        dprintf("iMachineRole            - %d\n",   lpGPOInfo->iMachineRole );
        dprintf("hToken                  - 0x%08X\n", lpGPOInfo->hToken );
        dprintf("pRsopToken              - 0x%08X\n", lpGPOInfo->pRsopToken );

        WCHAR sz[128];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPOInfo->lpDNName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;

        dprintf("lpDNName                - 0x%08X\t: \"%S\"\n", lpGPOInfo->lpDNName, bOk ? sz : L"" );
        dprintf("hEvent                  - 0x%08X\n", lpGPOInfo->hEvent );
        dprintf("hKeyRoot                - 0x%08X\n", lpGPOInfo->hKeyRoot );
        dprintf("bXferToExtList          - %s\n",   Boolean( lpGPOInfo->bXferToExtList ) );
        dprintf("lpExtFilterList         - 0x%08X\n", lpGPOInfo->lpExtFilterList );
        dprintf("lpGPOList               - 0x%08X\n", lpGPOInfo->lpGPOList );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPOInfo->lpwszSidUser, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;

        dprintf("lpwszSidUser            - 0x%08X\t: \"%S\"\n", lpGPOInfo->lpwszSidUser, bOk ? sz : L""  );
        dprintf("hTriggerEvent           - 0x%08X\n", lpGPOInfo->hTriggerEvent );
        dprintf("hNotifyEvent            - 0x%08X\n", lpGPOInfo->hNotifyEvent );
        dprintf("hCritSection            - 0x%08X\n", lpGPOInfo->hCritSection );
        dprintf("lpExtensions            - 0x%08X\n", lpGPOInfo->lpExtensions );
        dprintf("bMemChanged             - %s\n", Boolean( lpGPOInfo->bMemChanged ) );
        dprintf("bUserLocalMemChanged    - %s\n", Boolean( lpGPOInfo->bUserLocalMemChanged ) );
        dprintf("pStatusCallback         - 0x%08X\n", lpGPOInfo->pStatusCallback );
        dprintf("lpSOMList               - 0x%08X\n", lpGPOInfo->lpSOMList );
        dprintf("lpGpContainerList       - 0x%08X\n", lpGPOInfo->lpGpContainerList );
        dprintf("lpLoopbackSOMList       - 0x%08X\n", lpGPOInfo->lpLoopbackSOMList );
        dprintf("lpLoopbackGpContainer   - 0x%08X\n", lpGPOInfo->lpLoopbackGpContainerList );
    }
}

void gpext( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPEXT)];
    LPGPEXT         lpGPExt = (LPGPEXT) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPEXT), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPEXT) )
    {
        WCHAR sz[256];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpDisplayName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDisplayName           - 0x%08X\t: \"%S\"\n", lpGPExt->lpDisplayName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpKeyName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpKeyName               - 0x%08X\t: \"%S\"\n", lpGPExt->lpKeyName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpDllName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDllName               - 0x%08X\t: \"%S\"\n", lpGPExt->lpDllName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpFunctionName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpFunctionName          - 0x%08X\t: \"%S\"\n", lpGPExt->lpFunctionName, bOk ? sz : L""  );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPExt->lpRsopFunctionName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpRsopFunctionName      - 0x%08X\t: \"%S\"\n", lpGPExt->lpRsopFunctionName, bOk ? sz : L""  );
        
        dprintf("hInstance               - 0x%08X\n", lpGPExt->hInstance );

        DWORD dwDisplacement = 0;
        GetSymbol((void*)lpGPExt->pEntryPoint, (UCHAR *)sz, &dwDisplacement);
        sz[64] = 0;
        dprintf("pEntryPoint             - 0x%08X\t: %s\n", lpGPExt->pEntryPoint, sz );
        GetSymbol((void*)lpGPExt->pRsopEntryPoint, (UCHAR *)sz, &dwDisplacement);
        sz[64] = 0;
        dprintf("pRsopEntryPoint         - 0x%08X\t: %s\n", lpGPExt->pRsopEntryPoint, sz );
        
        dprintf("dwNoMachPolicy          - 0x%08X\n", lpGPExt->dwNoMachPolicy );
        dprintf("dwNoUserPolicy          - 0x%08X\n", lpGPExt->dwNoUserPolicy );
        dprintf("dwNoSlowLink            - 0x%08X\n", lpGPExt->dwNoSlowLink );
        dprintf("dwNoBackgroundPolicy    - 0x%08X\n", lpGPExt->dwNoBackgroundPolicy );
        dprintf("dwNoGPOChanges          - 0x%08X\n", lpGPExt->dwNoGPOChanges );
        dprintf("dwUserLocalSetting      - 0x%08X\n", lpGPExt->dwUserLocalSetting );
        dprintf("dwRequireRegistry       - 0x%08X\n", lpGPExt->dwRequireRegistry );
        dprintf("dwEnableAsynch          - 0x%08X\n", lpGPExt->dwEnableAsynch );
        dprintf("dwLinkTransition        - 0x%08X\n", lpGPExt->dwLinkTransition );
        dprintf("dwMaxChangesInterval    - 0x%08X\n", lpGPExt->dwMaxChangesInterval );
        
        dprintf("bRegistryExt            - %s\n", Boolean( lpGPExt->bRegistryExt ) );
        dprintf("bSkipped                - %s\n", Boolean( lpGPExt->bSkipped ) );
        dprintf("bHistoryProcessing      - %s\n", Boolean( lpGPExt->bHistoryProcessing ) );
        
//        dprintf("dwSlowLinkPrev          - 0x%08X\n", lpGPExt->dwSlowLinkPrev );

        dprintf("guid                    - " );
        PrintUuid( lpGPExt->guid );
        dprintf("\n" );

        dprintf("pNext                   - 0x%08X\n", lpGPExt->pNext );
    }
}

void container(HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(GPCONTAINER)];
    LPGPCONTAINER   lpGPCont = (LPGPCONTAINER) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(GPCONTAINER), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(GPCONTAINER) )
    {
        WCHAR sz[256];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszDSPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszDSPath              - 0x%08X\t: \"%S\"\n", lpGPCont->pwszDSPath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszGPOName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszGPONa               - 0x%08X\t: \"%S\"\n", lpGPCont->pwszGPOName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszDisplayName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszDisplayName         - 0x%08X\t: \"%S\"\n", lpGPCont->pwszDisplayName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpGPCont->pwszFileSysPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszFileSysPath         - 0x%08X\t: \"%S\"\n", lpGPCont->pwszFileSysPath, bOk ? sz : L"" );

        dprintf("bFound                  - %s\n", Boolean( lpGPCont->bFound ) );
        dprintf("bAccessDenied           - %s\n", Boolean( lpGPCont->bAccessDenied ) );
        dprintf("bUserDisabled           - %s\n", Boolean( lpGPCont->bUserDisabled ) );
        dprintf("bMachDisabled           - %s\n", Boolean( lpGPCont->bMachDisabled ) );

        dprintf("dwUserVersion           - 0x%08X\n", lpGPCont->dwUserVersion );
        dprintf("dwMachVersion           - 0x%08X\n", lpGPCont->dwMachVersion );
        dprintf("pSD                     - 0x%08X\n", lpGPCont->pSD );
        dprintf("cbSDLen                 - 0x%08X\n", lpGPCont->cbSDLen );
        dprintf("pNext                   - 0x%08X\n", lpGPCont->pNext );
    }
}

void som(   HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(SCOPEOFMGMT)];
    LPSCOPEOFMGMT   lpSOM = (LPSCOPEOFMGMT) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(SCOPEOFMGMT), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(SCOPEOFMGMT) )
    {
        WCHAR sz[128];
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpSOM->pwszSOMId, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("pwszSOMId               - 0x%08X\t: \"%S\"\n", lpSOM->pwszSOMId, bOk ? sz : L"" );
        dprintf("dwType                  - 0x%08X\n", lpSOM->dwType );
        dprintf("bBlocking               - %s\n", Boolean( lpSOM->bBlocking ) );
        dprintf("pGpLinkList             - 0x%08X\n", lpSOM->pGpLinkList );
    }
}

void profile(   HANDLE  hCurrentProcess,
                HANDLE  hCurrentThread,
                DWORD   dwCurrentPc,
                PWINDBG_EXTENSION_APIS lpExtensionApis,
                LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(USERPROFILE)];
    LPPROFILE       lpProf = (LPPROFILE) buffer;
    DWORD           dwBytesRead = 0;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(USERPROFILE), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(USERPROFILE) )
    {
        WCHAR sz[128];
        
        dprintf("dwFlags                 - 0x%08X\n", lpProf->dwFlags );
        dprintf("dwInternalFlags         - 0x%08X\n", lpProf->dwInternalFlags );
        dprintf("dwUserPreference        - 0x%08X\n", lpProf->dwUserPreference );
        dprintf("hToken                  - 0x%08X\n", lpProf->hToken );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpUserName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpUserName              - 0x%08X\t: \"%S\"\n", lpProf->lpUserName, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpProfilePath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpProfilePath           - 0x%08X\t: \"%S\"\n", lpProf->lpProfilePath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpRoamingProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpRoamingProfile        - 0x%08X\t: \"%S\"\n", lpProf->lpRoamingProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpDefaultProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpDefaultProfile        - 0x%08X\t: \"%S\"\n", lpProf->lpDefaultProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpLocalProfile, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpLocalProfile          - 0x%08X\t: \"%S\"\n", lpProf->lpLocalProfile, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpPolicyPath, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpPolicyPath            - 0x%08X\t: \"%S\"\n", lpProf->lpPolicyPath, bOk ? sz : L"" );
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpServerName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpServerName            - 0x%08X\t: \"%S\"\n", lpProf->lpServerName, bOk ? sz : L"" );

        dprintf("hKeyCurrentUser         - 0x%08X\n", lpProf->hKeyCurrentUser );
        
        dprintf("ftProfileLoad           - 0x%08X:0x%08X\n", lpProf->ftProfileLoad.dwLowDateTime, lpProf->ftProfileLoad.dwHighDateTime );
        dprintf("ftProfileUnload         - 0x%08X:0x%08X\n", lpProf->ftProfileUnload.dwLowDateTime, lpProf->ftProfileUnload.dwHighDateTime );
        
        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) lpProf->lpExclusionList, sz, sizeof(WCHAR) * 128, &dwBytesRead );
        sz[127] = 0;
        dprintf("lpExclusionList         - 0x%08X\t: \"%S\"\n", lpProf->lpExclusionList, bOk ? sz : L"" );
    }
}

void
debuglevel( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();

    DWORD   dwDebugLevelPtr = 0;

    dwDebugLevelPtr = GetExpression( "userenv!dwDebugLevel" );

    if ( dwDebugLevelPtr )
    {
        unsigned char   buffer[sizeof(DWORD)];
        LPDWORD         lpdw = (LPDWORD) buffer;
        DWORD           dwBytesRead = 0;
        
        BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwDebugLevelPtr, buffer, sizeof(DWORD), &dwBytesRead );

        if ( bOk && dwBytesRead == sizeof(DWORD) )
        {
            dprintf("0x%08X\n", *lpdw );
        }

        /*
        if ( lpArgumentString && isxdigit( *lpArgumentString ) )
        {
            DWORD dwValue = GetExpression(lpArgumentString);
            dprintf("%x, Writing 0x%X at 0x%X\n", ExtensionApis.lpWriteProcessMemoryRoutine, dwValue, dwDebugLevelPtr );
            WriteMemoryExt( hCurrentProcess, (void*) dwDebugLevelPtr, (void*) dwValue, sizeof( DWORD ), 0 );
        }
        */
    }
    else
    {
        dprintf("Could not resolve symbol dwDebugLevel in module userenv!\n" );
    }
}

void
globals(    HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
}

void sizes( HANDLE  hCurrentProcess,
            HANDLE  hCurrentThread,
            DWORD   dwCurrentPc,
            PWINDBG_EXTENSION_APIS lpExtensionApis,
            LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    PRINT_SIZE(GPEXT);
    PRINT_SIZE(GPLINK);
    PRINT_SIZE(SCOPEOFMGMT);
    PRINT_SIZE(GPCONTAINER);
    PRINT_SIZE(GPOINFO);
    PRINT_SIZE(USERPROFILE);
}


void dmpregtable(   HANDLE  hCurrentProcess,
                    HANDLE  hCurrentThread,
                    DWORD   dwCurrentPc,
                    PWINDBG_EXTENSION_APIS lpExtensionApis,
                    LPSTR   lpArgumentString )
{
    ExtensionRoutinePrologue();
    unsigned char   buffer[sizeof(REGHASHTABLE)];
    LPREGHASHTABLE  pHashTable = (LPREGHASHTABLE) buffer;
    DWORD           dwBytesRead = 0;
    int             i;
    BOOL            bError=FALSE;
    
    BOOL bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) dwAddr, buffer, sizeof(REGHASHTABLE), &dwBytesRead );

    if ( bOk && dwBytesRead == sizeof(REGHASHTABLE) )
    {
        WCHAR sz[128];

        dprintf("Dumping Registry HashTable at Location 0x%08X\n", dwAddr );
        for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
            
            REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
            REGKEYENTRY  KeyEntry;

            if (pKeyEntry) 
                dprintf("Hash Bucket 0x%X\n", i);
            
            while ( pKeyEntry ) {

                bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pKeyEntry, &KeyEntry, sizeof(REGKEYENTRY), &dwBytesRead );
                if (!bOk || dwBytesRead != sizeof(REGKEYENTRY) ) {
                    dprintf("    !!Couldn't read keyEntry at 0x%08X. quitting..\n", pKeyEntry);
                    bError = TRUE;
                    break;
                }
                dprintf("    KeyEntry at 0x%08X\n", pKeyEntry);
                
                pKeyEntry = &KeyEntry;
                bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pKeyEntry->pwszKeyName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                sz[127] = 0;
                dprintf("    pwszKeyName              - 0x%08X\t: \"%S\"\n", pKeyEntry->pwszKeyName, pKeyEntry->pwszKeyName?sz:L"<NULL>");


                REGVALUEENTRY *pValueList=pKeyEntry->pValueList;
                REGVALUEENTRY ValueList;
                
                while ( pValueList ) {
                    bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pValueList, &ValueList, sizeof(REGVALUEENTRY), &dwBytesRead );
                    if (!bOk || dwBytesRead != sizeof(REGVALUEENTRY) ) {
                        dprintf("        !!Couldn't read ValueEntry at 0x%08X. quitting..\n", pValueList);
                        bError = TRUE;
                        break;
                    }
                    dprintf("        ValueEntry at 0x%08X\n", pValueList);

                    pValueList = &ValueList;
                    bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pValueList->pwszValueName, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                    sz[127] = 0;
                    dprintf("        pwszValueName              - 0x%08X\t: \"%S\"\n", pValueList->pwszValueName, pValueList->pwszValueName?sz:L"<NULL>");


                    REGDATAENTRY *pDataList = pValueList->pDataList;
                    REGDATAENTRY DataList;

                    while ( pDataList ) {
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList, &DataList, sizeof(REGDATAENTRY), &dwBytesRead );
                        if (!bOk || dwBytesRead != sizeof(REGDATAENTRY) ) {
                            dprintf("            !!Couldn't read DataEntry at 0x%08X. quitting..\n", pDataList);
                            bError = TRUE;
                            break;
                        }
                        dprintf("            **DataEntry** at 0x%08X\n", pDataList);

                        pDataList = &DataList;

                        
                        dprintf("            bDeleted              - %s\n", pDataList->bDeleted?"TRUE":"FALSE");
                        dprintf("            bAdmPolicy            - %s\n", pDataList->bAdmPolicy?"TRUE":"FALSE");
                        dprintf("            dwValueType           - 0x%X\n", pDataList->dwValueType);
                        dprintf("            dwDataLen             - 0x%X\n", pDataList->dwDataLen);
                        dprintf("            pData                 - 0x%08X\n", pDataList->pData);

                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszGPO, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszGPO               - 0x%08X\t: \"%S\"\n", pDataList->pwszGPO, pDataList->pwszGPO?sz:L"<NULL>");
                        
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszSOM, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszSOM               - 0x%08X\t: \"%S\"\n", pDataList->pwszSOM, pDataList->pwszSOM?sz:L"<NULL>");

                        
                        bOk = ReadMemoryExt( hCurrentProcess, ( const void * ) pDataList->pwszCommand, sz, sizeof(WCHAR) * 128, &dwBytesRead );
                        sz[127] = 0;
                        dprintf("            pwszCommand           - 0x%08X\t: \"%S\"\n", pDataList->pwszCommand, pDataList->pwszCommand?sz:L"<NULL>");

                        if (bError)
                            break;
                            
                        pDataList = pDataList->pNext;
                        
                    } // While pDataList

                    if (bError)
                        break;
                        
                    pValueList = pValueList->pNext;
                } // While pValue
                
                if (bError)
                    break;
                    
                pKeyEntry = pKeyEntry->pNext;
                dprintf("\n");

            }   // while pKey
            
            if (bError)
                break;            
        }            

    }   // for

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\main\import.h ===
/********************************************************************/
/**               Copyright(c) 1991 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	import.h
//
// Description: This file allows us to include standard system header files 
//		in the .idl file.  The main .idl file imports a file called 
//		import.idl. This allows the .idl file to use the types defined 
//		in these header files. It also causes the following line to 
//		be added in the MIDL generated header file:
//
//    		#include "import.h"
//
//   		Thus these types are available to the RPC stub routines as well.
//
//


#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#define HANDLE      DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\main\resource.h ===
//*************************************************************
//
//  Resource.h      -   Header file for userenv.rc
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uevents.h"

// Error codes that were used by profile and
// policy event logging (rc strings) have been removed
//
// Don't reuse the codes 0 - 28 because it might confuse localisers
//

#define IDS_COMMON                    15
#define IDS_PROFILES_ROOT             25

#define IDS_SH_APPDATA                30
#define IDS_SH_DESKTOP                31
#define IDS_SH_FAVORITES              32
#define IDS_SH_NETHOOD                33
#define IDS_SH_PRINTHOOD              34
#define IDS_SH_RECENT                 35
#define IDS_SH_SENDTO                 36
#define IDS_SH_STARTMENU              37
#define IDS_SH_TEMPLATES              38
#define IDS_SH_PERSONAL               39
#define IDS_SH_PROGRAMS               40
#define IDS_SH_STARTUP                41
#define IDS_SH_TEMP                   42
#define IDS_SH_LOCALSETTINGS          43
#define IDS_SH_LOCALAPPDATA           44
#define IDS_SH_CACHE                  45
#define IDS_SH_COOKIES                46
#define IDS_SH_HISTORY                47
#define IDS_SH_MYPICTURES             48
#define IDS_SH_SHAREDDOCS             49

#define IDS_SH_PERSONAL2              70
#define IDS_SH_MYPICTURES2            71
#define IDS_SH_TEMPLATES2             72

#define IDS_PROFILE_FORMAT            75
#define IDS_PROFILEDOMAINNAME_FORMAT  76

#define IDS_NT_AUTHORITY              80
#define IDS_BUILTIN                   81

#define IDS_LOCALGPONAME             103
#define IDS_TEMPINTERNETFILES        104
#define IDS_HISTORY                  105
#define IDS_EXCLUSIONLIST            106
#define IDS_REGISTRYNAME             107
#define IDS_CALLEXTENSION            108
#define IDS_USER_SETTINGS            109
#define IDS_COMPUTER_SETTINGS        110
#define IDS_GPCORE_NAME              111

//
// Profile icon
//

#define IDI_PROFILE                  1


//
// Slow link test data
//

#define IDB_SLOWLINK                 1


//
// Slow link dialog
//

#define IDD_LOGIN_SLOW_LINK       1000
#define IDC_DOWNLOAD              1001
#define IDC_LOCAL                 1002
#define IDC_TIMEOUT               1004
#define IDC_TIMETITLE             1005
#define IDD_LOGOFF_SLOW_LINK      1006
#define IDC_UPLOAD                1007
#define IDC_NOUPLOAD              1008

//
// Error dialog
//

#define IDD_ERROR                 3000
#define IDC_ERRORTEXT             3001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\testshim\testshim.h ===
//
// function prototypes for the gina interface
//

typedef BOOL (WINAPI *PGWLXNEGOTIATE)( DWORD, DWORD* );
typedef BOOL (WINAPI *PGWLXINITIALIZE)( LPWSTR, HANDLE, PVOID, PVOID, PVOID* );
typedef VOID (WINAPI *PGWLXDISPLAYSASNOTICE)( PVOID );
typedef int  (WINAPI *PGWLXLOGGEDOUTSAS)( PVOID, DWORD, PLUID, PSID, PDWORD,
                                        PHANDLE, PWLX_MPR_NOTIFY_INFO, PVOID *);
typedef BOOL (WINAPI *PGWLXACTIVATEUSERSHELL)(  PVOID, PWSTR, PWSTR, PVOID );
typedef int  (WINAPI *PGWLXLOGGEDONSAS)( PVOID, DWORD, PVOID );
typedef VOID (WINAPI *PGWLXDISPLAYLOCKEDNOTICE)( PVOID );
typedef int  (WINAPI *PGWLXWKSTALOCKEDSAS)( PVOID, DWORD );
typedef BOOL (WINAPI *PGWLXISLOCKOK)( PVOID );
typedef BOOL (WINAPI *PGWLXISLOGOFFOK)( PVOID );
typedef VOID (WINAPI *PGWLXLOGOFF)( PVOID );
typedef VOID (WINAPI *PGWLXSHUTDOWN)( PVOID, DWORD );

//
// NEW for version 1.1
//
typedef BOOL (WINAPI *PGWLXSCREENSAVERNOTIFY)( PVOID, BOOL * );
typedef BOOL (WINAPI *PGWLXSTARTAPPLICATION)( PVOID, PWSTR, PVOID, PWSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\main\globals.h ===
//*************************************************************
//
//  Global Variable Extern's
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WINDOWS_POLICIES_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define ROOT_POLICIES_KEY            TEXT("Software\\Policies")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define DIAGNOSTICS_KEY              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics")
#define DIAGNOSTICS_GLOBAL_VALUE     TEXT("RunDiagnosticLoggingGlobal")
#define DIAGNOSTICS_POLICY_VALUE     TEXT("RunDiagnosticLoggingGroupPolicy")
#define LOCAL_GPO_DIRECTORY          TEXT("%SystemRoot%\\System32\\GroupPolicy")
#define LONG_UNC_PATH_PREFIX         TEXT("\\\\?\\UNC")

//ds
//
// When the time to change the profiles directory to the root,
// these things need to be done / checked:
//
// 1)  Search for //ds everywhere in this directory
// 2)  Change the default profiles directory in
//     windows\setup\inf\win4\inf\usa\hivesft.txt
//     note:  the new name is "Documents and Settings"
// 3)  In hivedef.inx, remove the TEMP and TMP environment variable entries
// 4)  Remove all of the special folder entries
// 5)  In usa\hivedef.txt, remove TEMP, TMP, and special folder entries
// 6)  Review MoveUserProfile() function to make sure it will handle
//     name collision (dual boot) case for All Users and Default User
//

#define NT4_PROFILES_DIRECTORY       TEXT("%SystemRoot%\\Profiles")
#define DEFAULT_USER                 TEXT("Default User")
#define DEFAULT_USER_NETWORK         TEXT("Default User (Network)")
#define ALL_USERS                    TEXT("All Users")

#define GUIMODE_SETUP_MUTEX          TEXT("Global\\userenv: GUI mode setup running")
#define USER_POLICY_MUTEX            TEXT("userenv: user policy mutex")
#define MACHINE_POLICY_MUTEX         TEXT("Global\\userenv: machine policy mutex")
#define USER_POLICY_REFRESH_EVENT    TEXT("userenv: user policy refresh event")
#define MACHINE_POLICY_REFRESH_EVENT TEXT("Global\\userenv: machine policy refresh event")
#define USER_POLICY_APPLIED_EVENT    TEXT("userenv: User Group Policy has been applied")
#define MACHINE_POLICY_APPLIED_EVENT TEXT("Global\\userenv: Machine Group Policy has been applied")
#define USER_POLICY_DONE_EVENT       TEXT("userenv: User Group Policy Processing is done")
#define MACHINE_POLICY_DONE_EVENT    TEXT("Global\\userenv: Machine Group Policy Processing is done")

#define MACH_POLICY_FOREGROUND_DONE_EVENT   TEXT("Global\\userenv: Machine Policy Foreground Done Event")
#define USER_POLICY_FOREGROUND_DONE_EVENT   TEXT("userenv: User Policy Foreground Done Event")

#define USER_REGISTRY_EXT_MUTEX      TEXT("userenv: User Registry policy mutex")
#define MACH_REGISTRY_EXT_MUTEX      TEXT("Global\\userenv: Machine Registry policy mutex")


//
// This event needs to be set for user or machine forced refresh
//

#define USER_POLICY_FORCE_REFRESH_EVENT  TEXT("userenv: user policy force refresh event")
#define MACHINE_POLICY_FORCE_REFRESH_EVENT  TEXT("Global\\userenv: machine policy force refresh event")


//
// This event is set by the core if a reboot is needed for the forced refresh to complete.
//

#define USER_POLICY_REFRESH_NEEDFG_EVENT    TEXT("userenv: User Group Policy ForcedRefresh Needs Foreground Processing")
#define MACHINE_POLICY_REFRESH_NEEDFG_EVENT TEXT("Global\\userenv: Machine Group Policy ForcedRefresh Needs Foreground Processing")


#define USER_SHELL_FOLDERS           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#if defined(_WIN64)
#define USER_SHELL_FOLDERS32         TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#endif
#define SHELL_FOLDERS                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define PROFILE_LIST_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileGuid")
#define PROFILES_DIRECTORY           TEXT("ProfilesDirectory")
#define ALL_USERS_PROFILE            TEXT("AllUsersProfile")
#define DEFAULT_USER_PROFILE         TEXT("DefaultUserProfile")
#define PROFILE_FLAGS                TEXT("Flags")
#define PROFILE_GUID                 TEXT("Guid")
#define PROFILE_STATE                TEXT("State")
#define PROFILE_IMAGE_VALUE_NAME     TEXT("ProfileImagePath")
#define PROFILE_CENTRAL_PROFILE      TEXT("CentralProfile")
#define PROFILE_REF_COUNT            TEXT("RefCount")
#define PREFERENCE_KEYNAME           TEXT("Preference")
#define USER_PREFERENCE              TEXT("UserPreference")
#define PROFILE_LOAD_TIME_LOW        TEXT("ProfileLoadTimeLow")
#define PROFILE_LOAD_TIME_HIGH       TEXT("ProfileLoadTimeHigh")
#define PROFILE_UNLOAD_TIME_LOW      TEXT("ProfileUnloadTimeLow")
#define PROFILE_UNLOAD_TIME_HIGH     TEXT("ProfileUnloadTimeHigh")
#define PROFILE_GENERAL_SECTION      TEXT("General")
#define PROFILE_EXCLUSION_LIST       TEXT("ExclusionList")
#define PROFILE_LOAD_TYPE            TEXT("ProfileLoadType")
#define PROFILE_LAST_UPLOAD_STATE    TEXT("LastUploadState")
#define COMPLETE_PROFILE             TEXT("Complete")
#define PARTIAL_PROFILE              TEXT("Partial")
#define PROFILE_BUILD_NUMBER         TEXT("BuildNumber")
#define PROFILE_SID_STRING           TEXT("SidString")
#define TEMP_PROFILE_NAME_BASE       TEXT("TEMP")
#define PROFILE_UNLOAD_TIMEOUT       TEXT("ProfileUnloadTimeout")
#define DISABLE_PROFILE_UNLOAD_MSG   TEXT("DisableProfileUnloadMsg")
#define DELETE_ROAMING_CACHE         TEXT("DeleteRoamingCache")
#define ADD_ADMIN_GROUP_TO_RUP       TEXT("AddAdminGroupToRUP")
#define READONLY_RUP                 TEXT("ReadOnlyProfile")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define USER_PROFILE_SETUP_EVENT     TEXT("Global\\userenv:  User Profile setup event")
#define USER_PROFILE_MUTEX           TEXT("Global\\userenv:  User Profile Mutex for ")

#define SYSTEM_PROFILE_LOCATION      TEXT("%systemroot%\\system32\\config\\systemprofile")


//
// Appmgmt stuff to nuke
//

#define APPMGMT_DIR_ROOT             TEXT("%systemroot%\\system32\\appmgmt")
#define APPMGMT_REG_MANAGED          TEXT("Software\\Microsoft\\Windows\\Currentversion\\Installer\\Managed")

//
// IE cache key
//

#define IE4_CACHE_KEY                TEXT("Software\\Microsoft\\Windows\\Currentversion\\Internet Settings\\Cache\\Extensible Cache")
#define IE5_CACHE_KEY                TEXT("Software\\Microsoft\\Windows\\Currentversion\\Internet Settings\\5.0\\Cache\\Extensible Cache")
#define IE_CACHEKEY_PREFIX           TEXT("MsHist")

#ifdef  __cplusplus
extern "C" {
#endif

extern HINSTANCE    g_hDllInstance;
extern TCHAR        c_szRegistryExtName[];
extern const TCHAR  c_szRegistryPol[];


//
// Group policy handles
//

extern HANDLE           g_hPolicyCritMutexMach;
extern HANDLE           g_hPolicyCritMutexUser;

extern HANDLE           g_hRegistryPolicyCritMutexMach;
extern HANDLE           g_hRegistryPolicyCritMutexUser;

extern HANDLE           g_hPolicyNotifyEventMach;
extern HANDLE           g_hPolicyNotifyEventUser;

extern HANDLE           g_hPolicyNeedFGEventMach;
extern HANDLE           g_hPolicyNeedFGEventUser;

extern HANDLE           g_hPolicyDoneEventMach;
extern HANDLE           g_hPolicyDoneEventUser;

extern DWORD            g_dwBuildNumber;
extern HANDLE           g_hProfileSetup;

extern HANDLE           g_hPolicyForegroundDoneEventMach;
extern HANDLE           g_hPolicyForegroundDoneEventUser;

extern const TCHAR c_szStarDotStar[];
extern const TCHAR c_szSlash[];
extern const TCHAR c_szDot[];
extern const TCHAR c_szDotDot[];
extern const TCHAR c_szMAN[];
extern const TCHAR c_szUSR[];
extern const TCHAR c_szLog[];
extern const TCHAR c_szPDS[];
extern const TCHAR c_szPDM[];
extern const TCHAR c_szLNK[];
extern const TCHAR c_szBAK[];
extern const TCHAR c_szNTUserTmp[];
extern const TCHAR c_szNTUserMan[];
extern const TCHAR c_szNTUserDat[];
extern const TCHAR c_szNTUserIni[];
extern const TCHAR c_szNTUserStar[];
extern const TCHAR c_szUserStar[];
extern const TCHAR c_szSpace[];
extern const TCHAR c_szDotPif[];
extern const TCHAR c_szNULL[];
extern const TCHAR c_szCommonGroupsLocation[];
#if defined(__cplusplus)
}
#endif

//
// Timeouts
//

#define SLOW_LINK_TIMEOUT        120  // ticks
#define SLOW_LINK_TRANSFER_RATE  500  // Kbps
#define PROFILE_DLG_TIMEOUT       30  // seconds

//
// Folder sizes
//

#define MAX_FOLDER_SIZE                80
#define MAX_COMMON_LEN                 30
#define MAX_DLL_NAME_LEN               13

//
// Personal / common profile folders
//

#if defined(__cplusplus)
extern "C" {
#endif
extern DWORD g_dwNumShellFolders;
extern DWORD g_dwNumCommonShellFolders;
#if defined(__cplusplus)
}
#endif


typedef struct _FOLDER_INFO {
    BOOL   bHidden;
    BOOL   bLocal;
    BOOL   bAddCSIDL;
    BOOL   bNewNT5;
    BOOL   bLocalSettings;
    INT    iFolderID;
    LPTSTR lpFolderName;
    TCHAR  szFolderLocation[MAX_FOLDER_SIZE]; // must be at end of structure
    LPTSTR lpFolderResourceDLL;
    INT    iFolderResourceID;
} FOLDER_INFO;

#if defined(__cplusplus)
extern "C" {
#endif
extern FOLDER_INFO c_ShellFolders[];
extern FOLDER_INFO c_CommonShellFolders[];
#if defined(__cplusplus)
}
#endif


//
// Product type
//

typedef enum {
   PT_WORKSTATION           = 0x0001,   // Workstation
   PT_SERVER                = 0x0002,   // Server
   PT_DC                    = 0x0004,   // Domain controller
   PT_WINDOWS               = 0x0008    // Windows
} NTPRODUCTTYPE;

#if defined(__cplusplus)
extern "C" {
#endif
extern NTPRODUCTTYPE g_ProductType;
#if defined(__cplusplus)
}
#endif


//
// Function proto-types
//

#if defined(__cplusplus)
extern "C" {
#endif
void InitializeGlobals (HINSTANCE hInstance);
void PatchLocalAppData(HANDLE hToken);
void InitializeSnapProv();
#if defined(__cplusplus)
}
#endif

//
// Type of message
//

#define DLGTYPE_ERROR        0
#define DLGTYPE_SLOWLINK     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\main\userenv.c ===
//*************************************************************
//
//  Main entry point
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

extern DWORD    g_dwLoadFlags;

//*************************************************************
//
//  DllMain()
//
//  Purpose:    Main entry point
//
//  Parameters:     hInstance   -   Module instance
//                  dwReason    -   Way this function is being called
//                  lpReseved   -   Reserved
//
//
//  Return:     (BOOL) TRUE if successfully initialized
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    DWORD dwStatus;
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            {

            DisableThreadLibraryCalls (hInstance);
            InitializeGlobals (hInstance);
            InitializeAPIs();
            dwStatus = InitializeNotifySupport();
            if ( dwStatus != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("LibMain:: InitializeNotifySupport failed with WIN32 error %d."), dwStatus) );
                return FALSE;
            }

            __try
            {
                InitializeGPOCriticalSection();
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                CloseGPOCriticalSection();
                ShutdownNotifySupport();
                return FALSE;
            }

            InitializeSnapProv();
            {
                TCHAR szProcessName[MAX_PATH] = {0};
                DWORD dwLoadFlags = FALSE;
                DWORD WINLOGON_LEN = 12;  // Length of string "winlogon.exe"
                DWORD SETUP_LEN = 9;      // Length of string "setup.exe"

                DWORD dwRet = GetModuleFileName (NULL, szProcessName, ARRAYSIZE(szProcessName));
				szProcessName[MAX_PATH-1] = 0;
                if ( dwRet > WINLOGON_LEN ) {

                    if ( CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                                         &szProcessName[dwRet-WINLOGON_LEN], -1, L"winlogon.exe", -1 ) == CSTR_EQUAL ) {
                        g_dwLoadFlags = dwLoadFlags = WINLOGON_LOAD;
                    }
                }
#if 0
                if ( dwRet > SETUP_LEN ) {

                    if ( CompareString ( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                         &szProcessName[dwRet-SETUP_LEN], -1, L"setup.exe", -1 ) == CSTR_EQUAL ) {
                        g_dwLoadFlags = dwLoadFlags = SETUP_LOAD;
                    }
                }
#endif

                InitDebugSupport( dwLoadFlags );

                if (dwLoadFlags == WINLOGON_LOAD) {
                    InitializePolicyProcessing(TRUE);
                    InitializePolicyProcessing(FALSE);
                }

                DebugMsg((DM_VERBOSE, TEXT("LibMain: Process Name:  %s"), szProcessName));
            }

            }
            break;


        case DLL_PROCESS_DETACH:

            if (g_hProfileSetup) {
                CloseHandle (g_hProfileSetup);
                g_hProfileSetup = NULL;
            }

            
            if (g_hPolicyCritMutexMach) {
                CloseHandle (g_hPolicyCritMutexMach);
                g_hPolicyCritMutexMach = NULL;
            }

            if (g_hPolicyCritMutexUser) {
                CloseHandle (g_hPolicyCritMutexUser);
                g_hPolicyCritMutexUser = NULL;
            }

            if (g_hRegistryPolicyCritMutexMach) {
                CloseHandle (g_hRegistryPolicyCritMutexMach);
                g_hRegistryPolicyCritMutexMach = NULL;
            }

            if (g_hRegistryPolicyCritMutexUser) {
                CloseHandle (g_hRegistryPolicyCritMutexUser);
                g_hRegistryPolicyCritMutexUser = NULL;
            }
            
            if (g_hPolicyNotifyEventMach) {
                CloseHandle (g_hPolicyNotifyEventMach);
                g_hPolicyNotifyEventMach = NULL;
            }

            if (g_hPolicyNotifyEventUser) {
                CloseHandle (g_hPolicyNotifyEventUser);
                g_hPolicyNotifyEventUser = NULL;
            }

            
            if (g_hPolicyNeedFGEventMach) {
                CloseHandle (g_hPolicyNeedFGEventMach);
                g_hPolicyNeedFGEventMach = NULL;
            }

            if (g_hPolicyNeedFGEventUser) {
                CloseHandle (g_hPolicyNeedFGEventUser);
                g_hPolicyNeedFGEventUser = NULL;
            }

            
            if (g_hPolicyDoneEventMach) {
                CloseHandle (g_hPolicyDoneEventMach);
                g_hPolicyDoneEventMach = NULL;
            }

            if (g_hPolicyDoneEventUser) {
                CloseHandle (g_hPolicyDoneEventUser);
                g_hPolicyDoneEventUser = NULL;
            }

            if ( g_hPolicyForegroundDoneEventUser )
            {
                CloseHandle( g_hPolicyForegroundDoneEventUser );
                g_hPolicyForegroundDoneEventUser = 0;
            }

            if ( g_hPolicyForegroundDoneEventMach )
            {
                CloseHandle( g_hPolicyForegroundDoneEventMach );
                g_hPolicyForegroundDoneEventMach = 0;
            }

            CloseApiDLLsCritSec();
            ShutdownEvents ();
            ShutdownNotifySupport();
            CloseGPOCriticalSection();
            ClosePingCritSec();
            break;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\main\globals.c ===
//*************************************************************
//
//  Global Variables
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <winfoldr.h>
#include "strsafe.h"

HINSTANCE        g_hDllInstance;
DWORD            g_dwBuildNumber;
NTPRODUCTTYPE    g_ProductType;
HANDLE           g_hProfileSetup = NULL;
DWORD            g_dwNumShellFolders;
DWORD            g_dwNumCommonShellFolders;


HANDLE           g_hPolicyCritMutexMach = NULL;
HANDLE           g_hPolicyCritMutexUser = NULL;

HANDLE           g_hRegistryPolicyCritMutexMach = NULL;
HANDLE           g_hRegistryPolicyCritMutexUser = NULL;

HANDLE           g_hPolicyNotifyEventMach = NULL;
HANDLE           g_hPolicyNotifyEventUser = NULL;

HANDLE           g_hPolicyNeedFGEventMach = NULL;
HANDLE           g_hPolicyNeedFGEventUser = NULL;

HANDLE           g_hPolicyDoneEventMach = NULL;
HANDLE           g_hPolicyDoneEventUser = NULL;

HANDLE           g_hPolicyForegroundDoneEventMach = 0;
HANDLE           g_hPolicyForegroundDoneEventUser = 0;

const TCHAR c_szStarDotStar[] = TEXT("*.*");
const TCHAR c_szSlash[] = TEXT("\\");
const TCHAR c_szDot[] = TEXT(".");
const TCHAR c_szDotDot[] = TEXT("..");
const TCHAR c_szMAN[] = TEXT(".man");
const TCHAR c_szUSR[] = TEXT(".usr");
const TCHAR c_szLog[] = TEXT(".log");
const TCHAR c_szPDS[] = TEXT(".pds");
const TCHAR c_szPDM[] = TEXT(".pdm");
const TCHAR c_szLNK[] = TEXT(".lnk");
const TCHAR c_szBAK[] = TEXT(".bak");
const TCHAR c_szNTUserTmp[] = TEXT("ntuser.tmp");
const TCHAR c_szNTUserMan[] = TEXT("ntuser.man");
const TCHAR c_szNTUserDat[] = TEXT("ntuser.dat");
const TCHAR c_szNTUserIni[] = TEXT("ntuser.ini");
const TCHAR c_szRegistryPol[] = TEXT("registry.pol");
const TCHAR c_szNTUserStar[] = TEXT("ntuser.*");
const TCHAR c_szUserStar[] = TEXT("user.*");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szDotPif[] = TEXT(".pif");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szCommonGroupsLocation[] = TEXT("Software\\Program Groups");
TCHAR c_szRegistryExtName[64];

//
// Registry Extension guid
//

GUID guidRegistryExt = REGISTRY_EXTENSION_GUID;

//
// Special folders
//

FOLDER_INFO c_ShellFolders[] =
{
//Hidden   Local    Add    New    Within    Folder                 Folder                    Folder    Folder                Folder
// Dir?     Dir    CSIDl?  NT5?   Local     Resource ID            Name                      Location  Resource              Resource
//                                Settings                                                             DLL                   ID

  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_APPDATA,       TEXT("AppData"),           {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_APP_DATA}, // AppData
  {TRUE,   FALSE,  TRUE,  TRUE,   FALSE,    IDS_SH_COOKIES,       TEXT("Cookies"),           {0},      TEXT("shell32.dll"),  0}, // Cookies
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_DESKTOP,       TEXT("Desktop"),           {0},      TEXT("shell32.dll"),  0}, // Desktop
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_FAVORITES,     TEXT("Favorites"),         {0},      TEXT("shell32.dll"),  0}, // Favorites
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_NETHOOD,       TEXT("NetHood"),           {0},      TEXT("shell32.dll"),  0}, // NetHood
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PERSONAL,      TEXT("Personal"),          {0},      TEXT("shell32.dll"),  0}, // My Documents
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PRINTHOOD,     TEXT("PrintHood"),         {0},      TEXT("shell32.dll"),  0}, // PrintHood
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_RECENT,        TEXT("Recent"),            {0},      TEXT("shell32.dll"),  0}, // Recent
  {TRUE,   FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_SENDTO,        TEXT("SendTo"),            {0},      TEXT("shell32.dll"),  0}, // SendTo
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_STARTMENU,     TEXT("Start Menu"),        {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_START_MENU}, // Start Menu
  {TRUE,   FALSE,  TRUE,  TRUE,   FALSE,    IDS_SH_TEMPLATES,     TEXT("Templates"),         {0},      TEXT("shell32.dll"),  0}, // Templates
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_PROGRAMS,      TEXT("Programs"),          {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_PROGRAMS}, // Programs
  {FALSE,  FALSE,  TRUE,  FALSE,  FALSE,    IDS_SH_STARTUP,       TEXT("Startup"),           {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_STARTUP}, // Startup

  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_LOCALSETTINGS, TEXT("Local Settings"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_LOCALSETTINGS}, // Local Settings
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_LOCALAPPDATA,  TEXT("Local AppData"),     {0},      TEXT("shell32.dll"),  0}, // Local AppData
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_CACHE,         TEXT("Cache"),             {0},      TEXT("shell32.dll"),  0}, // Temporary Internet Files
  {TRUE,   TRUE,   TRUE,  TRUE,   TRUE,     IDS_SH_HISTORY,       TEXT("History"),           {0},      TEXT("shell32.dll"),  0}, // History
  {FALSE,  TRUE,   FALSE, TRUE,   TRUE,     IDS_SH_TEMP,          TEXT("Temp"),              {0},      TEXT("shell32.dll"),  0}, // Temp
};


FOLDER_INFO c_CommonShellFolders[] =
{
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_DESKTOP,       TEXT("Common Desktop"),    {0},      TEXT("shell32.dll"),  0}, // Common Desktop
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_STARTMENU,     TEXT("Common Start Menu"), {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_START_MENU}, // Common Start Menu
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_PROGRAMS,      TEXT("Common Programs"),   {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_PROGRAMS}, // Common Programs
  {FALSE,  TRUE,   TRUE,  FALSE,  FALSE,    IDS_SH_STARTUP,       TEXT("Common Startup"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_STARTUP}, // Common Startup
  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_APPDATA,       TEXT("Common AppData"),    {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_APP_DATA}, // Common Application Data
  {TRUE,   TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_TEMPLATES,     TEXT("Common Templates"),  {0},      TEXT("shell32.dll"),  0}, // Common Templates
  {FALSE,  TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_FAVORITES,     TEXT("Common Favorites"),  {0},      TEXT("shell32.dll"),  0}, // Common Favorites
  {FALSE,  TRUE,   TRUE,  TRUE,   FALSE,    IDS_SH_SHAREDDOCS,    TEXT("Common Documents"),  {0},      TEXT("shell32.dll"),  IDS_LOCALGDN_FLD_SHARED_DOC}, // Common Documents
};


//
// Function proto-types
//

void InitializeProductType (void);
BOOL DetermineLocalSettingsLocation(LPTSTR szLocalSettings, DWORD cchLocalSettings);


//*************************************************************
//
//  PatchLocalSettings()
//
//  Purpose:    Initializes the LocalSettingsFolder correctly
//
//  Parameters: hInstance   -   DLL instance handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/13/95    ushaji     Created
//
//
// Comments:
//      Should remove this post NT5 and restructure to take care of the
// NT4 Localisation Problems
//
//*************************************************************

void PatchLocalAppData(HANDLE hToken)
{
    TCHAR szLocalSettingsPath[MAX_PATH];
    TCHAR szLocalAppData[MAX_PATH];
    LPTSTR lpEnd = NULL, lpLocalAppDataFolder;
    HANDLE hTokenOld=NULL;
    HKEY hKeyRoot, hKey;
    DWORD dwIndex;
    DWORD cchEnd;
    BOOL  bGotLocalPath = FALSE;


    if (!ImpersonateUser (hToken, &hTokenOld))
        return;


    if (RegOpenCurrentUser(KEY_READ, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            if (RegQueryValueEx (hKey, TEXT("Local AppData"), NULL, NULL,
                                 NULL, NULL) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                RegCloseKey(hKeyRoot);
                RevertToUser(&hTokenOld);
                return;
            }

            RegCloseKey(hKey);
        }

        RegCloseKey(hKeyRoot);
    }


    //
    // Impersonate and determine the user's localsettings
    //

    bGotLocalPath = DetermineLocalSettingsLocation(szLocalSettingsPath, ARRAYSIZE(szLocalSettingsPath));

    RevertToUser(&hTokenOld);

    if (!bGotLocalPath)
        return;

    StringCchCopy(szLocalAppData, ARRAYSIZE(szLocalAppData), TEXT("%userprofile%"));


    //
    // Set the Local AppData Folder after %userprofile% so that we
    // we can update the global variable below.
    //

    lpLocalAppDataFolder = CheckSlashEx(szLocalAppData, ARRAYSIZE(szLocalAppData), NULL);

    if (SUCCEEDED(StringCchCat(szLocalAppData, ARRAYSIZE(szLocalAppData), szLocalSettingsPath)))
    {
        lpEnd = CheckSlashEx(szLocalAppData, ARRAYSIZE(szLocalAppData), &cchEnd);

        if (lpEnd)
        {

            LoadString(g_hDllInstance, IDS_SH_LOCALAPPDATA, lpEnd, cchEnd);

            //
            // Construct the path and let it be set.
            //

            SetFolderPath(CSIDL_LOCAL_APPDATA | CSIDL_FLAG_DONT_UNEXPAND, hToken, szLocalAppData);

            //
            // the global variable should be reset by the time it gets used.
            // No Need to reset it here, but let us be safer.
            //

            for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++)
                if (c_ShellFolders[dwIndex].iFolderID == IDS_SH_LOCALAPPDATA)
                    StringCchCopy(c_ShellFolders[dwIndex].szFolderLocation, MAX_FOLDER_SIZE, lpLocalAppDataFolder);
        }
    }
}

//*************************************************************
//
//  LoadStringWithLangid()
//
//  Purpose:    MUI version requires load the folder name in the
//              default UI language. Standard LoadString() doesn't
//              support the language id. 
//
//  Parameters: hInstance   -   handle to resource module
//              uID         -   resource identifier
//              lpBuffer    -   result string resource buffer
//              nBufferMax  -   size of buffer
//              idLang      -   language id
//
//  Return:     number of chars copied to the buffer, 0 means failed.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/12/01    mingzhu    Created
//
//*************************************************************

int LoadStringWithLangid(HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer, int nBufferMax, LANGID idLang)
{
    int     cchstr = 0;
    UINT    block, num, i;
    HRSRC   hResInfo;
    HGLOBAL hRes;
    LPWSTR  lpwstrRes;
 
    if (!hInstance || !lpBuffer)
        goto Exit;
 
    block = (uID >>4)+1;
    num   = uID & 0xf;
 
    // Load the resource block which contains up to 16 length-counted strings.
    hResInfo = FindResourceEx (hInstance, RT_STRING, MAKEINTRESOURCE(block), idLang);
    if (!hResInfo)
        goto Exit;
 
    if ((hRes = LoadResource(hInstance, hResInfo)) == NULL)
        goto Exit;
 
    if ((lpwstrRes = (LPWSTR)LockResource(hRes)) == NULL)
        goto Exit;
 
    // Seek to the string using the length
    for(i = 0; i < num; i++)
        lpwstrRes += *lpwstrRes + 1;
 
    // Get the length
    cchstr = *lpwstrRes;

    #ifdef UNICODE
        if (cchstr > nBufferMax - 1)
            cchstr = nBufferMax - 1;
        CopyMemory(lpBuffer, lpwstrRes+1, cchstr * sizeof(WCHAR));
    #else
        cchstr = WideCharToMultiByte(CP_ACP, 0, lpwstrRes+1, cchstr, lpBuffer, nBufferMax-1, 0, 0);
    #endif
    
Exit:
    // Add the terminating null char
    lpBuffer[cchstr]= (TCHAR)0x0;
    return cchstr;
}


//*************************************************************
//
//  InitializeGlobals()
//
//  Purpose:    Initializes all the globals variables
//              at DLL load time.
//
//  Parameters: hInstance   -   DLL instance handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/13/95    ericflo    Created
//
//*************************************************************

void InitializeGlobals (HINSTANCE hInstance)
{
    OSVERSIONINFO ver;
    DWORD dwIndex, dwSize, dwType;
    HKEY hKey, hKeyRoot;
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_PATH];
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    LPTSTR lpEnd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  pSidAdmin = NULL, pSidSystem = NULL;
    DWORD cbAcl;
    BOOL  bDefaultSecurity = FALSE;
    LANGID  idDefLang;
    DWORD   cchEnd;

    //
    // Save the instance handle
    //

    g_hDllInstance = hInstance;


    //
    // Save the number of shell folders
    //

    g_dwNumShellFolders = ARRAYSIZE(c_ShellFolders);
    g_dwNumCommonShellFolders = ARRAYSIZE(c_CommonShellFolders);


    //
    // Query the build number
    //

    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    g_dwBuildNumber = (DWORD) LOWORD(ver.dwBuildNumber);


    //
    // Initialize the product type
    //

    InitializeProductType ();


    //
    // Open the user profile setup event.  This event is set to non-signalled
    // anytime the default user profile is being updated.  This blocks
    // LoadUserProfile until the update is finished.
    //

    if (!g_hProfileSetup) {

        //
        // Get the system sid
        //

        if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0, &pSidSystem)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize system sid.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        //
        // Get the Admin sid
        //

        if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                      0, 0, 0, 0, &pSidAdmin)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize admin sid.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        cbAcl = (GetLengthSid (pSidSystem)) +
                (GetLengthSid (pSidAdmin))  +
                sizeof(ACL) +
                (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
 
 
        pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
        if (!pAcl) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
 
        if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to initialize acl.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
 
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSidSystem)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to add system ace.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSidAdmin)) {
            DebugMsg((DM_WARNING, TEXT("InitializeGlobals: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
            bDefaultSecurity = TRUE;
            goto DefaultSecurity;
        }

        //
        // Put together the security descriptor
        //

        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        SetSecurityDescriptorDacl (
                        &sd,
                        TRUE,                           // Dacl present
                        pAcl,                           // Dacl
                        FALSE                           // Not defaulted
                        );

DefaultSecurity:

        sa.nLength = sizeof(sa);
        sa.bInheritHandle = FALSE;
        if (bDefaultSecurity) {
            sa.lpSecurityDescriptor = NULL;
        }
        else {
            sa.lpSecurityDescriptor = &sd;
        }

        g_hProfileSetup = CreateEvent (&sa, TRUE, TRUE, USER_PROFILE_SETUP_EVENT);

        if (!g_hProfileSetup) {
            DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: Failed to create profile setup event with %d"), GetLastError()));
        }

        if (pAcl) {
            GlobalFree (pAcl);
        }        

        if (pSidSystem) {
            FreeSid(pSidSystem);
        }

        if (pSidAdmin) {
            FreeSid(pSidAdmin);
        }    
    }


    //
    // Now load the directory names that match the special folders
    // MUI version requires the resources in the installed language (SystemDefaultUILanguage)
    //
    idDefLang = GetSystemDefaultUILanguage();
    for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++) {
        int cchFolder = LoadStringWithLangid(
                            hInstance,
                            c_ShellFolders[dwIndex].iFolderID,
                            c_ShellFolders[dwIndex].szFolderLocation,
                            MAX_FOLDER_SIZE,
                            idDefLang);
        // If we failed to load string using default language, use the resource in current binary
        if (cchFolder == 0) {
            cchFolder = LoadString(
                            hInstance,
                            c_ShellFolders[dwIndex].iFolderID,
                            c_ShellFolders[dwIndex].szFolderLocation,
                            MAX_FOLDER_SIZE);
        }
    }

    for (dwIndex = 0; dwIndex < g_dwNumCommonShellFolders; dwIndex++) {
        int cchFolder = LoadStringWithLangid(
                            hInstance,
                            c_CommonShellFolders[dwIndex].iFolderID,
                            c_CommonShellFolders[dwIndex].szFolderLocation,
                            MAX_FOLDER_SIZE,
                            idDefLang);
        // If we failed to load string using default language, use the resource in current binary
        if (cchFolder == 0) {
            cchFolder = LoadString(
                            hInstance,
                            c_CommonShellFolders[dwIndex].iFolderID,
                            c_CommonShellFolders[dwIndex].szFolderLocation,
                            MAX_FOLDER_SIZE);
        }
    }

    //
    // Special case for the Personal / My Documents folder.  NT4 used a folder
    // called "Personal" for document storage.  NT5 renamed this folder to
    // My Documents.  In the upgrade case from NT4 to NT5, if the user already
    // had information in "Personal", that name was preserved (for compatibility
    // reasons) and the My Pictures folder is created inside of Personal.
    // We need to make sure and fix up the My Documents and My Pictures entries
    // in the global array so they have the correct directory names.
    //


    if (RegOpenCurrentUser(KEY_READ, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(szTemp3);
            szTemp3[0] = TEXT('\0');
            if (RegQueryValueEx (hKey, TEXT("Personal"), NULL, &dwType,
                                 (LPBYTE) szTemp3, &dwSize) == ERROR_SUCCESS) {

                LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2));
                StringCchCopy (szTemp, ARRAYSIZE(szTemp), TEXT("%USERPROFILE%\\"));
                StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp2);

                if (lstrcmpi(szTemp, szTemp3) == 0) {
                    LoadString(hInstance, IDS_SH_PERSONAL2,
                               c_ShellFolders[5].szFolderLocation, MAX_FOLDER_SIZE);
                }
            }


            //
            // Special Case for Local Settings.
            // Due to localisations LocalSettings can be pointing to different places in nt4 and rc might
            // not be in sync with the current value. Read the LocalSettings value first and then
            // update everything else afterwards.
            //

            dwSize = sizeof(szTemp2);
            *szTemp = *szTemp2 = TEXT('\0');


            //
            // Read the value from the registry if it is available
            //

            if (RegQueryValueEx (hKey, TEXT("Local Settings"), NULL, &dwType,
                                 (LPBYTE) szTemp2, &dwSize) != ERROR_SUCCESS) {

                //
                // if the value is not present load it from the rc file
                //

                LoadString(hInstance, IDS_SH_LOCALSETTINGS, szTemp, MAX_FOLDER_SIZE);
                DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder from the rc is %s"), szTemp));
            }
            else {

                //
                // The registry value read from the registry is the full unexpanded path.
                //


                if (lstrlen(szTemp2) > lstrlen(TEXT("%userprofile%"))) {

                    StringCchCopy(szTemp, ARRAYSIZE(szTemp), szTemp2+(lstrlen(TEXT("%userprofile%"))+1));

                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder from the reigtry is %s"), szTemp));
                }
                else {
                    LoadString(hInstance, IDS_SH_LOCALSETTINGS, szTemp, MAX_FOLDER_SIZE);
                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: local settings folder(2) from the rc is %s"), szTemp));
                }
            }


            lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchEnd);

            for (dwIndex = 0; dwIndex < g_dwNumShellFolders; dwIndex++) {


                //
                // Fix up all LocalSettings related shfolders
                //


                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE,
                                  c_ShellFolders[dwIndex].lpFolderName, -1,
                                  TEXT("Local Settings"), -1) == CSTR_EQUAL)
                {
                
                    //
                    // Don't copy the final slash
                    //

                    *lpEnd = TEXT('\0');
                    c_ShellFolders[dwIndex].szFolderLocation[0] = TEXT('\0');
                    StringCchCatN(c_ShellFolders[dwIndex].szFolderLocation, MAX_FOLDER_SIZE, szTemp, lstrlen(szTemp) - 1);
                }


                if (c_ShellFolders[dwIndex].bLocalSettings) {
                    LoadString(hInstance, c_ShellFolders[dwIndex].iFolderID, szTemp3, ARRAYSIZE(szTemp3));

                    //
                    // Append localsetting value read above to the end of %userprofile%
                    // before putting on the shell folder itself
                    //

                    StringCchCopy(lpEnd, cchEnd, szTemp3);
                    StringCchCopy(c_ShellFolders[dwIndex].szFolderLocation, MAX_FOLDER_SIZE, szTemp);

                    DebugMsg((DM_VERBOSE, TEXT("InitializeGlobals: Shell folder %s is  %s"), c_ShellFolders[dwIndex].lpFolderName,
                                                                                             c_ShellFolders[dwIndex].szFolderLocation));

                }
            }


            RegCloseKey (hKey);
        }

        RegCloseKey (hKeyRoot);
    }


    //
    // Get string version of registry extension guid
    //

    GuidToString( &guidRegistryExt, c_szRegistryExtName);
}

//*************************************************************
//
//  InitializeProductType()
//
//  Purpose:    Determines the current product type and
//              sets the g_ProductType global variable.
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/08/96     ericflo    Created
//
//*************************************************************

void InitializeProductType (void)
{

#ifdef WINNT

    HKEY hkey;
    LONG lResult;
    TCHAR szProductType[50];
    DWORD dwType, dwSize;


    //
    // Default product type is workstation.
    //

    g_ProductType = PT_WORKSTATION;


    //
    // Query the registry for the product type.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Failed to open registry (%d)"), lResult));
        goto Exit;
    }


    dwSize = 50;
    szProductType[0] = TEXT('\0');

    lResult = RegQueryValueEx (hkey,
                               TEXT("ProductType"),
                               NULL,
                               &dwType,
                               (LPBYTE) szProductType,
                               &dwSize);

    RegCloseKey (hkey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Failed to query product type (%d)"), lResult));
        goto Exit;
    }


    //
    // Map the product type string to the enumeration value.
    //

    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szProductType, -1, TEXT("WinNT") , -1) == CSTR_EQUAL ) {
        g_ProductType = PT_WORKSTATION;

    } else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szProductType, -1, TEXT("ServerNT") , -1) == CSTR_EQUAL ) {
        g_ProductType = PT_SERVER;

    } else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szProductType, -1, TEXT("LanmanNT") , -1) == CSTR_EQUAL ) {
        g_ProductType = PT_DC;

    } else {
        DebugMsg((DM_WARNING, TEXT("InitializeProductType: Unknown product type! <%s>"), szProductType));
    }



Exit:
    DebugMsg((DM_VERBOSE, TEXT("InitializeProductType: Product Type: %d"), g_ProductType));


#else   // WINNT

    //
    // Windows only has 1 product type
    //

    g_ProductType = PT_WINDOWS;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gphdr.h ===
//*************************************************************
//
//  Policy specific headers
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "reghash.h"
#include "rsop.h"
#include "chkacc.h"
#include "collect.h"
#include "Indicate.h"
#include "rsopsec.h"
#include "gpfilter.h"
#include "locator.h"
#include "rsopinc.h"

#define GPO_LPARAM_FLAG_DELETE         0x00000001


//
// Structures
//

typedef struct _GPINFOHANDLE
{
    LPGPOINFO   pGPOInfo;
    BOOL        bNoBackgroupThread;
} GPINFOHANDLE, *LPGPINFOHANDLE;


typedef struct _DNENTRY {
    LPTSTR                pwszDN;            // Distinguished name
    union {
        PGROUP_POLICY_OBJECT  pDeferredGPO;  // GPO corresponding to this DN
        struct _DNENTRY *     pDeferredOU;   // OU correspdonding to this DN
    };
    PLDAPMessage          pOUMsg;            // Message for evaluating deferred OU
    GPO_LINK              gpoLink;           // Type of GPO
    struct _DNENTRY *     pNext;             // Singly linked list pointer
} DNENTRY;


typedef struct _LDAPQUERY {
    LPTSTR              pwszDomain;          // Domain of subtree search
    LPTSTR              pwszFilter;          // Ldap filter for search
    DWORD               cbAllocLen;          // Allocated size of pwszFilter in bytes
    DWORD               cbLen;               // Size of pwszFilter currently used in bytes
    PLDAP               pLdapHandle;         // Ldap bind handle
    BOOL                bOwnLdapHandle;      // Does this struct own pLdapHandle ?
    PLDAPMessage        pMessage;            // Ldap message handle
    DNENTRY *           pDnEntry;            // Distinguished name entry
    struct _LDAPQUERY * pNext;               // Singly linked list pointer
} LDAPQUERY;

typedef struct _POLICYCHANGEDINFO {
    HANDLE  hToken;
    BOOL    bMachine;
} POLICYCHANGEDINFO, *LPPOLICYCHANGEDINFO;



//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// Default refresh rate (minutes)
//
// Client machines will refresh every 90 minutes
// Domain controllers will refresh every 5 minutes
//

#define GP_DEFAULT_REFRESH_RATE      90
#define GP_DEFAULT_REFRESH_RATE_DC    5


//
// Default refresh rate max offset
//
// To prevent many clients from querying policy at the exact same
// time, a random amount is added to the refresh rate.  In the
// default case, a number between 0 and 30 will be added to
// 180 to determine when the next background refresh will occur
//

#define GP_DEFAULT_REFRESH_RATE_OFFSET    30
#define GP_DEFAULT_REFRESH_RATE_OFFSET_DC  0


//
// Max keyname size
//

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512


//
// Max time to wait for the network to start (in ms)
//

#define MAX_WAIT_TIME            120000


//
// Extension registry path
//

#define GP_EXTENSIONS   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")

//
// Path for extension preference policies
//

#define GP_EXTENSIONS_POLICIES   TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy\\%s")

//
// Group Policy Object option flags
//
// Note, this was taken from sdk\inc\gpedit.h
//

#define GPO_OPTION_DISABLE_USER     0x00000001  // The user portion of this GPO is disabled
#define GPO_OPTION_DISABLE_MACHINE  0x00000002  // The machine portion of this GPO is disabled

//
// DS Object class types
//

extern TCHAR szDSClassAny[];
extern TCHAR szDSClassGPO[];
extern TCHAR szDSClassSite[];
extern TCHAR szDSClassDomain[];
extern TCHAR szDSClassOU[];
extern TCHAR szObjectClass[];

//
// Extension name properties
//
#define GPO_MACHEXTENSION_NAMES   L"gPCMachineExtensionNames"
#define GPO_USEREXTENSION_NAMES   L"gPCUserExtensionNames"
#define GPO_FUNCTIONALITY_VERSION L"gPCFunctionalityVersion"
#define MACHPOLICY_DENY_USERS     L"DenyUsersFromMachGP"

extern TCHAR wszKerberos[];

#define POLICY_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PolicyGuid")

//
// Global flags for Gpo shutdown processing. These are accessed outside
// the lock because its value is either 0 or 1. Even if there is a race,
// all it means is that shutdown will start one iteration later.
//

extern BOOL g_bStopMachGPOProcessing;
extern BOOL g_bStopUserGPOProcessing;

//
// Critical section for handling concurrent, asynchronous completion
//

extern CRITICAL_SECTION g_GPOCS;

//
// Global pointers for maintaining asynchronous completion context
//

extern LPGPINFOHANDLE g_pMachGPInfo;
extern LPGPINFOHANDLE g_pUserGPInfo;


//
// Status UI critical section, callback, and proto-types
//

extern CRITICAL_SECTION g_StatusCallbackCS;
extern PFNSTATUSMESSAGECALLBACK g_pStatusMessageCallback;
DWORD UserPolicyCallback (BOOL bVerbose, LPWSTR lpMessage);
DWORD MachinePolicyCallback (BOOL bVerbose, LPWSTR lpMessage);


//
// Function proto-types
//

DWORD WINAPI GPOThread (LPGPOINFO lpGPOInfo);
extern "C" BOOL ProcessGPOs (LPGPOINFO lpGPOInfo);
DWORD WINAPI PolicyChangedThread (LPPOLICYCHANGEDINFO lpPolicyChangedInfo);
BOOL ResetPolicies (LPGPOINFO lpGPOInfo, LPTSTR lpArchive);
extern "C" BOOL SetupGPOFilter (LPGPOINFO lpGPOInfo );
extern "C" void FilterGPOs( LPGPEXT lpExt, LPGPOINFO lpGPOInfo );
void FreeLists( LPGPOINFO lpGPOInfo );
void FreeExtList(LPEXTLIST pExtList );
BOOL CheckGPOs (LPGPEXT lpExt, LPGPOINFO lpGPOInfo, DWORD dwTime, BOOL *pbProcessGPOs,
                BOOL *pbNoChanges, PGROUP_POLICY_OBJECT *ppDeletedGPOList);
BOOL CheckForChangedSid( LPGPOINFO lpGPOInfo, CLocator *plocator );
extern "C" BOOL CheckForSkippedExtensions( LPGPOINFO lpGPOInfo, BOOL bRsopPlanningMode );
extern "C" BOOL ReadGPExtensions( LPGPOINFO lpGPOInfo );
BOOL LoadGPExtension (LPGPEXT lpExt, BOOL bRsopPlanningMode );
extern "C" BOOL UnloadGPExtensions (LPGPOINFO lpGPOInfo);
BOOL WriteStatus( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus );
void ReadStatus ( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus );
DWORD ProcessGPOList (LPGPEXT lpExt, LPGPOINFO lpGPOInfo, PGROUP_POLICY_OBJECT pDeletedGPOList,
                     PGROUP_POLICY_OBJECT pChangedGPOList, BOOL bNoChanges,
                     ASYNCCOMPLETIONHANDLE pAsyncHandle, HRESULT *phrCSERsopStatus );
BOOL ProcessGPORegistryPolicy (LPGPOINFO lpGPOInfo, PGROUP_POLICY_OBJECT pChangedGPOList, HRESULT *phrRsopLogging);
BOOL SaveGPOList (TCHAR *pszExtName, LPGPOINFO lpGPOInfo,
                  HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow, PGROUP_POLICY_OBJECT lpGPOList);

extern "C" BOOL AddGPO (PGROUP_POLICY_OBJECT * lpGPOList,
             DWORD dwFlags, BOOL bFound, BOOL bAccessGranted, BOOL bDisabled, DWORD dwOptions,
             DWORD dwVersion, LPTSTR lpDSPath, LPTSTR lpFileSysPath,
             LPTSTR lpDisplayName, LPTSTR lpGPOName, LPTSTR lpExtensions,
             PSECURITY_DESCRIPTOR pSD, DWORD cbSDLen,
             GPO_LINK GPOLink, LPTSTR lpLink,
             LPARAM lParam, BOOL bFront, BOOL bBlock, BOOL bVerbose, BOOL bProcessGPO);
BOOL RefreshDisplay (LPGPOINFO lpGPOInfo);
extern "C" DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdapterIndex );
BOOL GetGPOInfo (DWORD dwFlags, LPTSTR lpHostName, LPTSTR lpDNName,
                 LPCTSTR lpComputerName, PGROUP_POLICY_OBJECT *lpGPOList,
                 LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                 PNETAPI32_API pNetAPI32, BOOL bMachineTokenOk, PRSOPTOKEN pRsopToken, WCHAR *pwszSiteName,
                 CGpoFilter *pGpoFilter, CLocator *pLocator );
void WINAPI ShutdownGPOProcessing( BOOL bMachine );
void DebugPrintGPOList( LPGPOINFO lpGPOInfo );

typedef BOOL (*PFNREGFILECALLBACK)(LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                                   LPTSTR lpValueName, DWORD dwType,
                                   DWORD dwDataLength, LPBYTE lpData,
                                   WCHAR *pwszGPO,
                                   WCHAR *pwszSOM, REGHASHTABLE *pHashTable);
BOOL ParseRegistryFile (LPGPOINFO lpGPOInfo, LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
                        HANDLE hArchive, WCHAR *pwszGPO,
                        WCHAR *pwszSOM, REGHASHTABLE *pHashTable,
                        BOOL bRsopPlanningMode);
BOOL ExtensionHasPerUserLocalSetting( LPTSTR pszExtension, HKEY hKeyRoot );
void CheckGroupMembership( LPGPOINFO lpGPOInfo, HANDLE hToken, BOOL *pbMemChanged, BOOL *pbUserLocalMemChanged, PTOKEN_GROUPS *pTokenGroups );
BOOL ReadMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups );
void SaveMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups );
BOOL GroupInList( LPTSTR lpSid, PTOKEN_GROUPS pGroups );
DWORD GetCurTime();
extern "C" DWORD GetDomainControllerInfo(  PNETAPI32_API pNetAPI32, LPTSTR szDomainName,
                                ULONG ulFlags, HKEY hKeyRoot, PDOMAIN_CONTROLLER_INFO* ppInfo,
                                BOOL* pfSlow,
                                DWORD* pdwAdapterIndex );
PLDAP GetMachineDomainDS( PNETAPI32_API pNetApi32, PLDAP_API pLdapApi );
extern "C" HANDLE GetMachineToken();
NTSTATUS CallDFS(LPWSTR lpDomainName, LPWSTR lpDCName);
BOOL AddLocalGPO( LPSCOPEOFMGMT *ppSOMList );
BOOL AddGPOToRsopList( LPGPCONTAINER *ppGpContainerList,
                       DWORD dwFlags,
                       BOOL bFound,
                       BOOL bAccessGranted,
                       BOOL bDisabled,
                       DWORD dwVersion,
                       LPTSTR lpDSPath,
                       LPTSTR lpFileSysPath,
                       LPTSTR lpDisplayName,
                       LPTSTR lpGPOName,
                       PSECURITY_DESCRIPTOR pSD, 
                       DWORD cbSDLen,
                       BOOL bFilterAllowed, 
                       WCHAR *pwszFilterId, 
                       LPWSTR szSOM,
                       DWORD dwGPOOptions );
SCOPEOFMGMT *AllocSOM( LPWSTR pwszSOMId );
void FreeSOM( SCOPEOFMGMT *pSOM );
GPLINK *AllocGpLink( LPWSTR pwszGPO, DWORD dwOptions );
void FreeGpLink( GPLINK *pGpLink );
extern "C" GPCONTAINER *AllocGpContainer(  DWORD dwFlags,
                                BOOL bFound,
                                BOOL bAccessGranted,
                                BOOL bDisabled,
                                DWORD dwVersion,
                                LPTSTR lpDSPath,
                                LPTSTR lpFileSysPath,
                                LPTSTR lpDisplayName,
                                LPTSTR lpGpoName,
                                PSECURITY_DESCRIPTOR pSD,
                                DWORD cbSDLen,
                                BOOL bFilterAllowed,
                                WCHAR *pwszFilterId,
                                LPWSTR szSOM,
                                DWORD dwOptions );
void FreeGpContainer( GPCONTAINER *pGpContainer );
void FreeSOMList( SCOPEOFMGMT *pSOMList );
void FreeGpContainerList( GPCONTAINER *pGpContainerList );
extern "C" LONG GPOExceptionFilter( PEXCEPTION_POINTERS pExceptionPtrs );
extern "C" BOOL FreeGpoInfo( LPGPOINFO pGpoInfo );

BOOL ReadExtStatus(LPGPOINFO lpGPOInfo);

BOOL ReadGPOList ( TCHAR * pszExtName, HKEY hKeyRoot,
                   HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                   PGROUP_POLICY_OBJECT * lpGPOList);

BOOL GetDeletedGPOList (PGROUP_POLICY_OBJECT lpGPOList,
                        PGROUP_POLICY_OBJECT *ppDeletedGPOList);

BOOL HistoryPresent( LPGPOINFO lpGPOInfo, LPGPEXT lpExt, BOOL *pbPresent);


extern "C" BOOL InitializePolicyProcessing(BOOL bMachine);

BOOL FilterCheck( PLDAP pld, PLDAP_API pLDAP, 
                  PLDAPMessage pMessage,
                  PRSOPTOKEN pRsopToken,
                  LPTSTR szWmiFilter,
                  CGpoFilter *pGpoFilter,
                  CLocator *pLocator,
                  BOOL *pbFilterAllowed,
                  WCHAR **ppwszFilterId );

BOOL CheckGPOAccess (PLDAP pld, PLDAP_API pLDAP, HANDLE hToken, PLDAPMessage pMessage,
                     LPTSTR lpSDProperty, DWORD dwFlags,
                     PSECURITY_DESCRIPTOR *ppSD, DWORD *pcbSDLen,
                     BOOL *pbAccessGranted,
                     PRSOPTOKEN pRsopToken );


BOOL AddOU( DNENTRY **ppOUList, LPTSTR pwszOU, GPO_LINK gpoLink );
BOOL EvaluateDeferredGPOs (PLDAP pldBound,
                           PLDAP_API pLDAP,
                           LPTSTR pwszDomainBound,
                           DWORD dwFlags,
                           HANDLE hToken,
                           BOOL bVerbose,
                           PGROUP_POLICY_OBJECT pDeferredForcedList,
                           PGROUP_POLICY_OBJECT pDeferredNonForcedList,
                           PGROUP_POLICY_OBJECT *ppForcedList,
                           PGROUP_POLICY_OBJECT *ppNonForcedList,
                           LPGPCONTAINER *ppGpContainerList,
                           PRSOPTOKEN pRsopToken,
                           CGpoFilter *pGpoFilter,
                           CLocator *pLocator );

BOOL SearchDSObject (LPTSTR lpDSObject, DWORD dwFlags, HANDLE hToken, PGROUP_POLICY_OBJECT *pGPOForcedList,
                     PGROUP_POLICY_OBJECT *pGPONonForcedList,
                     LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                     BOOL bVerbose,
                     GPO_LINK GPOLink, PLDAP  pld, PLDAP_API pLDAP, PLDAPMessage pLDAPMsg,BOOL *bBlock, PRSOPTOKEN pRsopToken );

BOOL EvaluateDeferredOUs(   DNENTRY *pOUList,
                            DWORD dwFlags,
                            HANDLE hToken,
                            PGROUP_POLICY_OBJECT *ppDeferredForcedList,
                            PGROUP_POLICY_OBJECT *ppDeferredNonForcedList,
                            LPSCOPEOFMGMT *ppSOMList,
                            LPGPCONTAINER *ppGpContainerList,
                            BOOL bVerbose,
                            PLDAP  pld,
                            PLDAP_API pLDAP,
                            BOOL *pbBlock,
                            PRSOPTOKEN pRsopToken);

void FreeDnEntry( DNENTRY *pDnEntry );

BOOL CheckOUAccess( PLDAP_API pLDAP,
                    PLDAP pld,
                    PLDAPMessage    pMessage,
                    PRSOPTOKEN pRsopToken,
                    BOOL *pbAccessGranted );

BOOL AddAdmFile( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite, LPTSTR szComputer, ADMFILEINFO **ppAdmFileCache );
void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache );

ADMFILEINFO * AllocAdmFileInfo( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite );
void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo );

DWORD
SavePolicyState( LPGPOINFO pInfo );

DWORD
SaveLinkState( LPGPOINFO pInfo );

DWORD
ComparePolicyState( LPGPOINFO pInfo, BOOL* pbLinkChanged, BOOL* pbStateChanged, BOOL *pbNoState );

DWORD
DeletePolicyState( LPCWSTR szSid );

LPTSTR GetSomPath( LPTSTR szContainer );
HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups);

#define DOMAIN_GPO_LOCATION_FMT     L"cn=policies,cn=system,%s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpfilter.cpp ===
//*************************************************************
//
//  Group Policy filtering Support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

extern "C" DWORD WINAPI PingComputerEx( ULONG ipaddr, ULONG *ulSpeed, DWORD* pdwAdapterIndex );

//*************************************************************
//
//  SetupGPOFilter()
//
//  Purpose:    Setup up GPO Filter info
//
//  Parameters: lpGPOInfo   - GPO info
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetupGPOFilter( LPGPOINFO lpGPOInfo )
{
    //
    // Format is [{ext guid1}{snapin guid1}..{snapin guidn}][{ext guid2}...]...\0
    // Both extension and snapin guids are in ascending order.
    //
    // Note: If the format is corrupt then take the conservative
    //       position and assume that it means that all
    //       extensions need to be applied to the GPO.
    //

    LPEXTFILTERLIST pExtFilterListTail = 0;
    PGROUP_POLICY_OBJECT lpGPO = 0;
    LPEXTFILTERLIST pExtFilterElem = NULL;
    ASSERT((lpGPOInfo!= NULL));

    lpGPOInfo->bXferToExtList = FALSE;

    lpGPO = lpGPOInfo->lpGPOList;
    while ( lpGPO ) {

        TCHAR *pchCur = lpGPO->lpExtensions;
        LPEXTLIST pExtListHead = 0;
        LPEXTLIST pExtListTail = 0;

        if ( pchCur ) {

            while ( *pchCur ) {

                GUID guidExt;
                LPEXTLIST pExtElem;

                if ( *pchCur == TEXT('[') )
                    pchCur++;
                else {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Corrupt extension name format.")));
                    FreeExtList( pExtListHead );
                    pExtListHead = 0;
                    break;

                }

                if ( ValidateGuidPrefix( pchCur ) ) // Fixing as part of bug 570352
                    StringToGuid( pchCur, &guidExt );
                else {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Corrupt extension name format.")));
                    FreeExtList( pExtListHead );
                    pExtListHead = 0;
                    break;

                }

                pExtElem = ( LPEXTLIST ) LocalAlloc( LPTR, sizeof(EXTLIST) );
                if ( pExtElem == 0 ) {

                    DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Unable to allocate memory.")));
                    FreeExtList( pExtListHead );
                    SetLastError(ERROR_OUTOFMEMORY);
                    return FALSE;

                }

                pExtElem->guid = guidExt;
                pExtElem->pNext = 0;

                if ( pExtListTail )
                    pExtListTail->pNext = pExtElem;
                else
                    pExtListHead = pExtElem;

                pExtListTail = pExtElem;

                while ( *pchCur && *pchCur != TEXT('[') )
                    pchCur++;

            } // while *pchcur

        } // if pchcur

        //
        // Append to lpExtFilterList
        //

        pExtFilterElem = (LPEXTFILTERLIST)LocalAlloc( LPTR, sizeof(EXTFILTERLIST) );
        if ( pExtFilterElem == NULL ) {

             DebugMsg((DM_WARNING, TEXT("SetupGPOFilter: Unable to allocate memory.")));
             FreeExtList( pExtListHead );
             SetLastError(ERROR_OUTOFMEMORY);
             return FALSE;
        }

        pExtFilterElem->lpExtList = pExtListHead;
        pExtFilterElem->lpGPO = lpGPO;
        pExtFilterElem->pNext = NULL;

        if ( pExtFilterListTail == 0 )
            lpGPOInfo->lpExtFilterList = pExtFilterElem;
        else
            pExtFilterListTail->pNext = pExtFilterElem;

        pExtFilterListTail = pExtFilterElem;

        //
        // Advance to next GPO
        //

        lpGPO = lpGPO->pNext;

    } // while lpgpo

    //
    // Transfer ownership from lpGPOList to lpExtFilterList
    //

    lpGPOInfo->bXferToExtList = TRUE;

    return TRUE;
}



//*************************************************************
//
//  FilterGPOs()
//
//  Purpose:    Filter GPOs not relevant to this extension
//
//  Parameters: lpExt        -  Extension
//              lpGPOInfo    -  GPO info
//
//*************************************************************

void FilterGPOs( LPGPEXT lpExt, LPGPOINFO lpGPOInfo )
{


    //
    // lpGPOInfo->lpGPOList will have the filtered list of GPOs
    //

    PGROUP_POLICY_OBJECT pGPOTail = 0;
    LPEXTFILTERLIST pExtFilterList = lpGPOInfo->lpExtFilterList;

    lpGPOInfo->lpGPOList = 0;

    while ( pExtFilterList ) {

        BOOL bFound = FALSE;
        LPEXTLIST pExtList = pExtFilterList->lpExtList;

        if ( pExtList == NULL ) {

            //
            // A null pExtlist means no extensions apply to this GPO
            //

            bFound = FALSE;

        } else {

            while (pExtList) {

                INT iComp = CompareGuid( &lpExt->guid, &pExtList->guid );

                if ( iComp == 0 ) {
                    bFound = TRUE;
                    break;
                } else if ( iComp < 0 ) {
                    //
                    // Guids in pExtList are in ascending order, so we are done
                    //
                    break;
                } else
                    pExtList = pExtList->pNext;

            } // while pextlist

        } // else

        if ( bFound ) {

            //
            // Append pExtFilterList->lpGPO to the filtered GPO list
            //

            pExtFilterList->lpGPO->pNext = 0;
            pExtFilterList->lpGPO->pPrev = pGPOTail;

            if ( pGPOTail == 0 )
                lpGPOInfo->lpGPOList = pExtFilterList->lpGPO;
            else
                pGPOTail->pNext = pExtFilterList->lpGPO;

            pGPOTail = pExtFilterList->lpGPO;

        }  // bFound

        pExtFilterList = pExtFilterList->pNext;

    }  // while pextfilterlist
}



//*************************************************************
//
//  CheckForGPOsToRemove()
//
//  Purpose:    Compares the GPOs in list1 with list 2 to determine
//              if any GPOs need to be removed.
//
//  Parameters: lpGPOList1  -   GPO link list 1
//              lpGPOList2  -   GPO link list 2
//
//  Return:     TRUE if one or more GPOs need to be removed
//              FALSE if not
//
//*************************************************************

BOOL CheckForGPOsToRemove (PGROUP_POLICY_OBJECT lpGPOList1, PGROUP_POLICY_OBJECT lpGPOList2)
{
    PGROUP_POLICY_OBJECT lpGPOSrc, lpGPODest;
    BOOL bFound;
    BOOL bResult = FALSE;


    //
    // First check to see if they are both NULL
    //

    if (!lpGPOList1 && !lpGPOList2) {
        return FALSE;
    }


    //
    // Go through every GPO in list 1, and see if it is still in list 2
    //

    lpGPOSrc = lpGPOList1;

    while (lpGPOSrc) {

        lpGPODest = lpGPOList2;
        bFound = FALSE;

        while (lpGPODest) {

            if (!lstrcmpi (lpGPOSrc->szGPOName, lpGPODest->szGPOName)) {
                bFound = TRUE;
                break;
            }

            lpGPODest = lpGPODest->pNext;
        }

        if (!bFound) {
            DebugMsg((DM_VERBOSE, TEXT("CheckForGPOsToRemove: GPO <%s> needs to be removed"), lpGPOSrc->lpDisplayName));
            lpGPOSrc->lParam |= GPO_LPARAM_FLAG_DELETE;
            bResult = TRUE;
        }

        lpGPOSrc = lpGPOSrc->pNext;
    }


    return bResult;
}

//*************************************************************
//
//  CompareGPOLists()
//
//  Purpose:    Compares one list of GPOs to another
//
//  Parameters: lpGPOList1  -   GPO link list 1
//              lpGPOList2  -   GPO link list 2
//
//  Return:     TRUE if the lists are the same
//              FALSE if not
//
//*************************************************************

BOOL CompareGPOLists (PGROUP_POLICY_OBJECT lpGPOList1, PGROUP_POLICY_OBJECT lpGPOList2)
{

    //
    // Check if one list is empty
    //

    if ((lpGPOList1 && !lpGPOList2) || (!lpGPOList1 && lpGPOList2)) {
        DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  One list is empty")));
        return FALSE;
    }


    //
    // Loop through the GPOs
    //

    while (lpGPOList1 && lpGPOList2) {

        //
        // Compare GPO names
        //

        if (lstrcmpi (lpGPOList1->szGPOName, lpGPOList2->szGPOName) != 0) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  Different entries found.")));
            return FALSE;
        }


        //
        // Compare the version numbers
        //

        if (lpGPOList1->dwVersion != lpGPOList2->dwVersion) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  Different version numbers found")));
            return FALSE;
        }


        //
        // Move to the next node
        //

        lpGPOList1 = lpGPOList1->pNext;
        lpGPOList2 = lpGPOList2->pNext;


        //
        // Check if one list has more entries than the other
        //

        if ((lpGPOList1 && !lpGPOList2) || (!lpGPOList1 && lpGPOList2)) {
            DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  One list has more entries than the other")));
            return FALSE;
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("CompareGPOLists:  The lists are the same.")));

    return TRUE;
}


//*************************************************************
//
//  CheckForSkippedExtensions()
//
//  Purpose:    Checks to the current list of extensions to see
//              if any of them have been skipped
//
//  Parameters: lpGPOInfo         -   GPOInfo
//              bRsopPlanningMode -   Is this being called during Rsop
//                                    planning mode ?
//
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL CheckForSkippedExtensions (LPGPOINFO lpGPOInfo, BOOL bRsopPlanningMode )
{
    BOOL bUsePerUserLocalSetting = FALSE;

    BOOL dwFlags = lpGPOInfo->dwFlags;

    LPGPEXT lpExt = lpGPOInfo->lpExtensions;

    while ( lpExt )
    {
        if ( bRsopPlanningMode )
        {
            //
            // In planning mode, check only for user, machine preferences and slow link
            //
            lpExt->bSkipped = lpExt->dwNoMachPolicy && dwFlags & GP_MACHINE        // mach policy
                                     || lpExt->dwNoUserPolicy && !(dwFlags & GP_MACHINE)
                                     || lpExt->dwNoSlowLink && (dwFlags & GP_SLOW_LINK);
            lpExt = lpExt->pNext;
            continue;
        }

        if ( // Check background preference. 
             lpExt->dwNoBackgroundPolicy && dwFlags & GP_BACKGROUND_THREAD ) {

            // in forced refresh don't skip the extension here but only after
            // we do a quick check to see whether extension is enabled and
            // after we set the appropriate registry key
            
            if (!(dwFlags & GP_FORCED_REFRESH)) 
                lpExt->bSkipped = TRUE;
            else {
                lpExt->bSkipped = FALSE;
                lpExt->bForcedRefreshNextFG = TRUE;
            } 
            
        } else
            lpExt->bSkipped = FALSE;


        if ( (!(lpExt->bSkipped)) && (lpExt->dwNoSlowLink && dwFlags & GP_SLOW_LINK)) {

            //
            // Slow link preference can be overridden by link transition preference
            //

            DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;

            if ( lpExt->dwLinkTransition && ( dwSlowLinkCur != lpExt->lpPrevStatus->dwSlowLink ) )
                lpExt->bSkipped = FALSE;
            else
                lpExt->bSkipped = TRUE;

        } else if (!(lpExt->bSkipped)) {

            //
            // If cached history is present but policy is turned off then still call
            // extension one more time so that cached policies can be passed to extension
            // to do delete processing. If there is no cached history then extension can be skipped.
            //

            BOOL bPolicySkippedPreference = lpExt->dwNoMachPolicy && dwFlags & GP_MACHINE        // mach policy
                                            || lpExt->dwNoUserPolicy && !(dwFlags & GP_MACHINE); // user policy

            if ( bPolicySkippedPreference ) {

                BOOL bHistoryPresent;
                if (HistoryPresent( lpGPOInfo, lpExt, &bHistoryPresent )) {
                    if ( bHistoryPresent )
                        lpExt->bHistoryProcessing = TRUE;
                    else
                        lpExt->bSkipped = TRUE;
                }
                else {
                    CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
                    ev.AddArgWin32Error(GetLastError()); ev.Report();
                    return FALSE;
                }
            }
        }

        lpExt = lpExt->pNext;

    }

    return TRUE;
}

//*************************************************************
//
//  CheckGPOs()
//
//  Purpose:    Checks to the current list of GPOs with
//              the list stored in the registry to see
//              if policy needs to be flushed.
//
//  Parameters: lpExt            - GP extension
//              lpGPOInfo        - GPOInfo
//              dwTime           - Current time in minutes
//              pbProcessGPOs    - On return set TRUE if GPOs have to be processed
//              pbNoChanges      - On return set to TRUE if no changes, but extension
//                                    has asked for GPOs to be still processed
//              ppDeletedGPOList - On return set to deleted GPO list, if any
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      For extensions that have PerUserLocalSetting specified, history data is
//              stored under both hkcu and hklm\{sid-user}. For such extensions there are two
//              deleted lists. First deleted list is obtained by comparing hklm\{sid-user} data
//              with current GPO data. Second deleted list is obtained by comparing
//              hkcu data with current GPO data. The final deleted list is obtained by appending
//              one deleted list to the other after removing duplicate GPOs.
//
//*************************************************************

BOOL CheckGPOs (LPGPEXT lpExt,
                LPGPOINFO lpGPOInfo,
                DWORD dwCurrentTime,
                BOOL *pbProcessGPOs,
                BOOL *pbNoChanges,
                PGROUP_POLICY_OBJECT *ppDeletedGPOList)
{
    PGROUP_POLICY_OBJECT lpOldGPOList = NULL, lpOldGPOList2 = NULL, lpGPO, lpGPOTemp;
    BOOL bTemp, bTemp2;

    BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

    *pbProcessGPOs = TRUE;
    *pbNoChanges = FALSE;
    *ppDeletedGPOList = NULL;

    DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

    //
    // Read in the old GPO list
    //

    bTemp = ReadGPOList (lpExt->lpKeyName, lpGPOInfo->hKeyRoot,
                         HKEY_LOCAL_MACHINE,
                         NULL,
                         FALSE, &lpOldGPOList);

    if (!bTemp) {
        DebugMsg((DM_WARNING, TEXT("CheckGPOs: ReadGPOList failed.")));
        CEvents ev(TRUE, EVENT_FAILED_READ_GPO_LIST); ev.Report();

        lpOldGPOList = NULL;
    }

    if ( bUsePerUserLocalSetting ) {
        bTemp2 = ReadGPOList (lpExt->lpKeyName, lpGPOInfo->hKeyRoot,
                              HKEY_LOCAL_MACHINE,
                              lpGPOInfo->lpwszSidUser,
                              FALSE, &lpOldGPOList2);
        if (!bTemp2) {
            DebugMsg((DM_WARNING, TEXT("CheckGPOs: ReadGPOList for user local settings failed.")));
            CEvents ev(TRUE, EVENT_FAILED_READ_GPO_LIST); ev.Report();

            lpOldGPOList2 = NULL;
        }
    }


    //
    // Compare with the new GPO list to determine if any GPOs have been
    // removed.
    //

    bTemp = CheckForGPOsToRemove (lpOldGPOList, lpGPOInfo->lpGPOList);

    if ( bUsePerUserLocalSetting ) {
        bTemp2 = CheckForGPOsToRemove (lpOldGPOList2, lpGPOInfo->lpGPOList);
    }


    if (bTemp || bUsePerUserLocalSetting && bTemp2 ) {

        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
            CEvents ev(FALSE, EVENT_GPO_LIST_CHANGED); ev.Report();
        }

        if ( !GetDeletedGPOList (lpOldGPOList, ppDeletedGPOList)) {

            DebugMsg((DM_WARNING, TEXT("CheckGPOs: GetDeletedList failed for %s."), lpExt->lpDisplayName));
            CEvents ev(TRUE, EVENT_FAILED_GETDELETED_LIST);
            ev.AddArg(lpExt->lpDisplayName); ev.Report();

        }

        if ( bUsePerUserLocalSetting ) {

            if ( !GetDeletedGPOList (lpOldGPOList2, ppDeletedGPOList)) {
                DebugMsg((DM_WARNING, TEXT("CheckGPOs: GetDeletedList failed for %s."), lpExt->lpDisplayName));
                CEvents ev(TRUE, EVENT_FAILED_GETDELETED_LIST);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();
            }

        }

        return TRUE;
    }

    //
    // Both the saved history GPO lists are the same and there are no deletions.
    // So, we need to compare the version numbers of the GPOs to see if any have been updated.
    //

    BOOL bMembershipChanged = bUsePerUserLocalSetting && lpGPOInfo->bUserLocalMemChanged
                              || !bUsePerUserLocalSetting && lpGPOInfo->bMemChanged;

    BOOL bPolicyUnchanged = CompareGPOLists (lpOldGPOList, lpGPOInfo->lpGPOList);
    BOOL bPerUserPolicyUnchanged = !bUsePerUserLocalSetting ? TRUE : CompareGPOLists (lpOldGPOList2, lpGPOInfo->lpGPOList);

    if ( bPolicyUnchanged && bPerUserPolicyUnchanged && !bMembershipChanged && (!(lpGPOInfo->bSidChanged)))
    {
        //
        // The list of GPOs hasn't changed or been updated, and the security group
        // membership has not changed. The default is to not call the extension if
        // it has NoGPOListChanges set. However this can be overridden based on other
        // extension preferences. These are hacks for performance.
        //
        // Exception: Even if nothing has changed but the user's sid changes we need to
        // call the extensions so that they can update their settings
        //

        BOOL bSkip = TRUE;      // Start with the default case
        BOOL bNoChanges = TRUE;
        DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
        DWORD dwRsopLoggingCur = lpGPOInfo->bRsopLogging;


        if ( !(lpExt->lpPrevStatus->bStatus) ) {

            //
            // Couldn't read the previous status or time, so the conservative solution is to call
            // extension.
            //

            bSkip = FALSE;
            DebugMsg((DM_VERBOSE,
                          TEXT("CheckGPOs: No GPO changes but couldn't read extension %s's status or policy time."),
                          lpExt->lpDisplayName));

        } else {
            if ( ( (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) || 
                  ((!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) && (lpExt->lpPrevStatus->bForceRefresh)))) {

                //
                // Forced refresh has been called or the extension doesn't support running in the background
                // and is running for the first time in the foreground since a force refresh has been called.
                //
                // Pass in changes too
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but called in force refresh flag or extension %s needs to run force refresh in foreground processing"),
                              lpExt->lpDisplayName));

            } else if ( lpExt->lpPrevStatus->dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED && 
                            !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {
                //
                // When the previous call completed the status code has explicitly asked the framework
                // to call the CSE in foreground.
                //
                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s had returned ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED for previous policy processing call."),
                              lpExt->lpDisplayName));

            } else if ( ((lpExt->lpPrevStatus->dwStatus) == ERROR_OVERRIDE_NOCHANGES) ) {

                //
                // When the previous call completed the status code has explicitly asked the framework
                // to disregard the NoGPOListChanges setting.
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s had returned ERROR_OVERRIDE_NOCHANGES for previous policy processing call."),
                              lpExt->lpDisplayName));

            } else if ( ((lpExt->lpPrevStatus->dwStatus) != ERROR_SUCCESS) ) {

                //
                // Extension returned error code, so call the extension again with changes.
                //

                bSkip = FALSE;
                bNoChanges = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's returned error status %d earlier."),
                              lpExt->lpDisplayName, (lpExt->lpPrevStatus->dwStatus) ));


            } else if ( lpExt->dwLinkTransition
                        && ( lpExt->lpPrevStatus->dwSlowLink != dwSlowLinkCur ) ) {

                //
                // If there has been a link speed transition then no changes is overridden.
                //

                bSkip = FALSE;
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a link speed transition from %d to %d."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwSlowLink, dwSlowLinkCur ));


            } else if ( lpExt->bNewInterface
                        && ( lpExt->lpPrevStatus->dwRsopLogging != dwRsopLoggingCur ) ) {

                //
                // If there has been a Rsop logging transition then no changes is overridden.
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a Rsop Logging transition from %d to %d."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwRsopLogging, dwRsopLoggingCur ));


            } else if ( lpExt->bNewInterface
                        && ( lpExt->lpPrevStatus->dwRsopLogging)
                        && ( FAILED(lpExt->lpPrevStatus->dwRsopStatus) ) ) {

                //
                // If rsop logging failed last time for this CSE
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but rsop is on and extension <%s> failed to log rsop wih error 0x%x."),
                              lpExt->lpDisplayName, lpExt->lpPrevStatus->dwRsopStatus ));


            } else if ( lpExt->bNewInterface && dwRsopLoggingCur
                        && (lpGPOInfo->bRsopCreated)) {

                //
                // If Rsop logging is turned on and the RSOP Name Space was created just now.
                //

                bSkip = FALSE;
                lpExt->bRsopTransition = TRUE;           
                DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's has a Rsop Logging transition because name space was created now."),
                              lpExt->lpDisplayName));
            } else if ( (lpExt->lpPrevStatus->dwStatus) == ERROR_SUCCESS
                        && lpExt->dwNoGPOChanges
                        && lpExt->dwMaxChangesInterval != 0 ) {

                if ( dwCurrentTime == 0
                     || (lpExt->lpPrevStatus->dwTime) == 0
                     || dwCurrentTime < (lpExt->lpPrevStatus->dwTime) ) {

                    //
                    // Handle clock overflow case by assuming that interval has been exceeded
                    //

                    bSkip = FALSE;
                    DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's MaxNoGPOListChangesInterval has been exceeded due to clock overflow."),
                              lpExt->lpDisplayName));

                } else if ( (dwCurrentTime - (lpExt->lpPrevStatus->dwTime)) > lpExt->dwMaxChangesInterval ) {

                    //
                    // Extension has specified a time interval for which NoGPOListChanges is valid and the time
                    // interval has been exceeded.
                    //

                    bSkip = FALSE;
                    DebugMsg((DM_VERBOSE,
                              TEXT("CheckGPOs: No GPO changes but extension %s's MaxNoGPOListChangesInterval has been exceeded."),
                              lpExt->lpDisplayName));
                }
            }
        }

        if ( bSkip && lpExt->dwNoGPOChanges ) {

            //
            // Case of skipping extension when there are *really* no changes and extension
            // set NoGPOListChanges to true.
            //

            DebugMsg((DM_VERBOSE,
                      TEXT("CheckGPOs: No GPO changes and no security group membership change and extension %s has NoGPOChanges set."),
                      lpExt->lpDisplayName));
            if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                CEvents ev(FALSE, EVENT_NO_CHANGES);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();
            }

            *pbProcessGPOs = FALSE;

        } else
            *pbNoChanges = bNoChanges;

    } // if CompareGpoLists

    FreeGPOList( lpOldGPOList );
    FreeGPOList( lpOldGPOList2 );

    return TRUE;
}



//*************************************************************
//
//  CheckGroupMembership()
//
//  Purpose:    Checks if the security groups has changed,
//              and if so saves the new security groups.
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              pbMemChanged          - Change status returned here
//              pbUserLocalMemChanged - PerUserLocal change status returned here
//
//*************************************************************

void CheckGroupMembership( LPGPOINFO lpGPOInfo, HANDLE hToken, BOOL *pbMemChanged, BOOL *pbUserLocalMemChanged, 
                           PTOKEN_GROUPS *ppRetGroups )
{
    PTOKEN_GROUPS pGroups = 0;
    DWORD dwTokenGrpSize = 0;

    *ppRetGroups = NULL;

    DWORD dwStatus = NtQueryInformationToken( hToken,
                                              TokenGroups,
                                              pGroups,
                                              dwTokenGrpSize,
                                              &dwTokenGrpSize );

    if ( dwStatus ==  STATUS_BUFFER_TOO_SMALL ) {

        pGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, dwTokenGrpSize );

        if ( pGroups == 0 ) {
            *pbMemChanged = TRUE;
            *pbUserLocalMemChanged = TRUE;

            goto Exit;
        }

        dwStatus = NtQueryInformationToken( hToken,
                                            TokenGroups,
                                            pGroups,
                                            dwTokenGrpSize,
                                            &dwTokenGrpSize );
    }

    if ( dwStatus != STATUS_SUCCESS ) {
        *pbMemChanged = TRUE;
        *pbUserLocalMemChanged = TRUE;

        goto Exit;
    }

    //
    // First do the machine and roaming user case
    //

    *pbMemChanged = ReadMembershipList( lpGPOInfo, NULL, pGroups );
    if ( *pbMemChanged )
        SaveMembershipList( lpGPOInfo, NULL, pGroups );

    //
    // Now the per user local settings case
    //

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

        *pbUserLocalMemChanged = *pbMemChanged;

    } else {

        DmAssert( lpGPOInfo->lpwszSidUser != 0 );

        *pbUserLocalMemChanged = ReadMembershipList( lpGPOInfo, lpGPOInfo->lpwszSidUser, pGroups );
        if ( *pbUserLocalMemChanged )
            SaveMembershipList( lpGPOInfo, lpGPOInfo->lpwszSidUser, pGroups );
    }


    //
    // filter out the logon sids in the returned token groups
    //

    *ppRetGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, sizeof(TOKEN_GROUPS) + 
                                                    (pGroups->GroupCount)*sizeof(SID_AND_ATTRIBUTES) +
                                                    (pGroups->GroupCount)*(SECURITY_MAX_SID_SIZE));

    if (*ppRetGroups) {
        DWORD i=0, dwCount=0, cbSid;
        PSID pSidPtr;

        pSidPtr = (PSID)( ((LPBYTE)(*ppRetGroups)) + 
                        sizeof(TOKEN_GROUPS) + (pGroups->GroupCount)*sizeof(SID_AND_ATTRIBUTES));

        for ( ; i < pGroups->GroupCount; i++ ) {

            if ( (SE_GROUP_LOGON_ID & pGroups->Groups[i].Attributes) == 0 ) {
                //
                // copy the sid first
                //

                cbSid =  RtlLengthSid(pGroups->Groups[i].Sid);
                dwStatus = RtlCopySid(cbSid, pSidPtr, pGroups->Groups[i].Sid);
                
                //
                // copy the attributes and make sid point correctly
                //
                (*ppRetGroups)->Groups[dwCount].Attributes = pGroups->Groups[i].Attributes;
                (*ppRetGroups)->Groups[dwCount].Sid = pSidPtr;

                pSidPtr = (PSID)( ((LPBYTE)pSidPtr) + cbSid);
                dwCount++;
            }
        }

        (*ppRetGroups)->GroupCount = dwCount;
    }

Exit:

    if ( pGroups != 0 )
        LocalFree( pGroups );

}



//*************************************************************
//
//  GroupInList()
//
//  Purpose:    Checks if sid in is list of security groups.
//
//  Parameters: lpSid   - Sid to check
//              pGroups - List of token groups
//
//  Return:     TRUE if sid is in list
//              FALSE otherwise
//
//*************************************************************

BOOL GroupInList( LPTSTR lpSid, PTOKEN_GROUPS pGroups )
{
    PSID    pSid = 0;
    DWORD   dwStatus, i;
    BOOL    bInList = FALSE;

    //
    // Optimize the basic case where the user is an earthling
    //

    
    if ( CompareString (LOCALE_INVARIANT, NORM_IGNORECASE, lpSid, -1, L"s-1-1-0", -1) == CSTR_EQUAL )
        return TRUE;

    dwStatus = AllocateAndInitSidFromString (lpSid, &pSid);

    if (ERROR_SUCCESS != dwStatus)
        return FALSE;

    //
    // Cannot match up cached groups with current groups one-by-one because
    // current pGroups can have groups with  SE_GROUP_LOGON_ID attribute
    // set which are different for each logon session.
    //

    for ( i=0; i < pGroups->GroupCount; i++ ) {

        bInList = RtlEqualSid (pSid, pGroups->Groups[i].Sid);
        if ( bInList )
            break;

    }

    LocalFree (pSid);

    return bInList;
}


//*************************************************************
//
//  IsSlowLink()
//
//  Purpose:    Determines if the connection to the specified
//              server is a slow link or not
//
//  Parameters: hKeyRoot     -  Registry hive root
//              lpDCAddress  -  Server address in string form
//              bSlow        -  Receives slow link status
//
//  Return:     TRUE if slow link
//              FALSE if not
//
//*************************************************************

DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdaptexIndex )
{
    DWORD dwSize, dwType, dwResult;
    HKEY hKey;
    LONG lResult;
    ULONG ulSpeed, ulTransferRate;
    IPAddr ipaddr;
    LPSTR lpDCAddressA, lpTemp;
    PWSOCK32_API pWSock32;
    DWORD   dwRet;


    //
    // Set default
    //

    *bSlow = TRUE;


    //
    // Get the slow link detection flag, and slow link timeout.
    //

    ulTransferRate = SLOW_LINK_TRANSFER_RATE;

    lResult = RegOpenKeyEx(hKeyRoot,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(hKeyRoot,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If the transfer rate is 0, then always download policy
    //

    if (!ulTransferRate) {
        DebugMsg((DM_VERBOSE, TEXT("IsSlowLink: Slow link transfer rate is 0.  Always download policy.")));
        *bSlow = FALSE;
        return ERROR_SUCCESS;
    }


    //
    // Convert the ipaddress from string form to ulong format
    //

    dwSize = lstrlen (lpDCAddress) + 1;

    lpDCAddressA = (LPSTR)LocalAlloc (LPTR, dwSize);

    if (!lpDCAddressA) {
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: Failed to allocate memory.")));
        return GetLastError();
    }

    if (!WideCharToMultiByte(CP_ACP, 0, lpDCAddress, -1, lpDCAddressA, dwSize, NULL, NULL)) {
        dwRet = GetLastError();
        LocalFree(lpDCAddressA);
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: WideCharToMultiByte failed with %d"), GetLastError()));
        //treat it as slow link
        return dwRet;
    }

    pWSock32 = LoadWSock32();

    if ( !pWSock32 ) {
        dwRet = GetLastError();
        LocalFree(lpDCAddressA);
        DebugMsg((DM_WARNING, TEXT("IsSlowLink: Failed to load wsock32.dll with %d"), GetLastError()));
        //treat it as slow link
        return dwRet;
    }


    if ((*lpDCAddressA == TEXT('\\')) && (*(lpDCAddressA+1) == TEXT('\\'))) {
        lpTemp = lpDCAddressA+2;
    } else {
        lpTemp = lpDCAddressA;
    }

    ipaddr = pWSock32->pfninet_addr (lpTemp);


    //
    // Ping the computer
    //

    dwResult = PingComputerEx( ipaddr, &ulSpeed, pdwAdaptexIndex );


    if (dwResult == ERROR_SUCCESS) {

        if (ulSpeed) {

            //
            // If the delta time is greater that the timeout time, then this
            // is a slow link.
            //

            if (ulSpeed < ulTransferRate) {
                *bSlow = TRUE;
            }
            else
                *bSlow = FALSE;
        }
        else
            *bSlow = FALSE;
    }

    LocalFree (lpDCAddressA);

    return dwResult;
}


//*************************************************************
//
//  CheckGPOAccess()
//
//  Purpose:    Determines if the user / machine has read access to
//              the GPO and if so, checks the Apply Group Policy
//              extended right to see if the GPO should be applied.
//              Also retrieves GPO attributes.
//
//  Parameters: pld             -  LDAP connection
//              pLDAP           -  LDAP function table pointer
//              pMessage        -  LDAP message
//              lpSDProperty    -  Security descriptor property name
//              dwFlags         -  GetGPOList flags
//              hToken          -  User / machine token
//              pSD             -  Security descriptor returned here
//              pcbSDLen        -  Length of security descriptor returned here
//              pbAccessGranted -  Receives the final yes / no status
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
//*************************************************************

BOOL CheckGPOAccess (PLDAP pld, PLDAP_API pLDAP, HANDLE hToken, PLDAPMessage pMessage,
                     LPTSTR lpSDProperty, DWORD dwFlags,
                     PSECURITY_DESCRIPTOR *ppSD, DWORD *pcbSDLen,
                     BOOL *pbAccessGranted,
                     PRSOPTOKEN pRsopToken )
{
    BOOL bResult = FALSE;
    PWSTR *ppwszValues = NULL;
    PLDAP_BERVAL *pSize = NULL;
    OBJECT_TYPE_LIST ObjType[2];
    PRIVILEGE_SET PrivSet;
    DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
    DWORD dwGrantedAccess;
    BOOL bAccessStatus = TRUE;
    GUID GroupPolicyContainer = {0x31B2F340, 0x016D, 0x11D2,
                                 0x94, 0x5F, 0x00, 0xC0, 0x4F, 0xB9, 0x84, 0xF9};
    // edacfd8f-ffb3-11d1-b41d-00a0c968f939
    GUID ApplyGroupPolicy = {0xedacfd8f, 0xffb3, 0x11d1,
                             0xb4, 0x1d, 0x00, 0xa0, 0xc9, 0x68, 0xf9, 0x39};
    GENERIC_MAPPING DS_GENERIC_MAPPING = { DS_GENERIC_READ, DS_GENERIC_WRITE,
                                           DS_GENERIC_EXECUTE, DS_GENERIC_ALL };

    XLastError xe;

    //
    // Set the default return value
    //

    *pbAccessGranted = FALSE;


    //
    // Get the security descriptor value
    //

    ppwszValues = pLDAP->pfnldap_get_values(pld, pMessage, lpSDProperty);


    if (!ppwszValues) {
        if (pld->ld_errno == LDAP_NO_SUCH_ATTRIBUTE) {
            DebugMsg((DM_VERBOSE, TEXT("CheckGPOAccess:  Object can not be accessed.")));
            bResult = TRUE;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  ldap_get_values failed with 0x%x"),
                 pld->ld_errno));
            xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        }

        goto Exit;
    }


    //
    // Get the length of the security descriptor
    //

    pSize = pLDAP->pfnldap_get_values_len(pld, pMessage, lpSDProperty);

    if (!pSize || !*pSize) {
        DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  ldap_get_values_len failed with 0x%x"),
                 pld->ld_errno));
        xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        goto Exit;
    }


    //
    // Allocate the memory for the security descriptor
    //

    *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);

    if ( *ppSD == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  Failed to allocate memory for SD with  %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Copy the security descriptor
    //

    CopyMemory( *ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
    *pcbSDLen = (*pSize)->bv_len;


    //
    // Now we use AccessCheckByType to determine if the user / machine
    // should have this GPO applied to them
    //
    //
    // Prepare the object type array
    //

    ObjType[0].Level = ACCESS_OBJECT_GUID;
    ObjType[0].Sbz = 0;
    ObjType[0].ObjectType = &GroupPolicyContainer;

    ObjType[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjType[1].Sbz = 0;
    ObjType[1].ObjectType = &ApplyGroupPolicy;


    //
    // Check access
    //

    if  ( pRsopToken )
    {
        HRESULT hr = RsopAccessCheckByType( *ppSD, NULL, pRsopToken, MAXIMUM_ALLOWED, ObjType, 2,
                            &DS_GENERIC_MAPPING, &PrivSet, &PrivSetLength,
                            &dwGrantedAccess, &bAccessStatus);
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  RsopAccessCheckByType failed with  0x%08X"), hr));
            goto Exit;
        }

        //
        // Check for the control bit
        //


        DWORD dwReqdRights = ACTRL_DS_CONTROL_ACCESS | 
                             STANDARD_RIGHTS_READ    | 
                             ACTRL_DS_LIST           | 
                             ACTRL_DS_READ_PROP;

                            // DS_GENERIC_READ without ACTRL_DS_LIST_OBJECT


        if (bAccessStatus && ( ( dwGrantedAccess & dwReqdRights  ) == dwReqdRights ) )
        {
            *pbAccessGranted = TRUE;
        }
        
        if (!(*pbAccessGranted)) {
            DebugMsg((DM_VERBOSE, TEXT("CheckGPOAccess:  AccessMask 0x%x, Looking for 0x%x"), 
                      dwGrantedAccess, dwReqdRights));
        }
    }
    else
    {
        if (!AccessCheckByType ( *ppSD, NULL, hToken, MAXIMUM_ALLOWED, ObjType, 2,
                            &DS_GENERIC_MAPPING, &PrivSet, &PrivSetLength,
                            &dwGrantedAccess, &bAccessStatus)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CheckGPOAccess:  AccessCheckByType failed with  %d"), GetLastError()));
            goto Exit;
        }
        //
        // Check for the control bit
        //

        if (bAccessStatus && ( dwGrantedAccess & ACTRL_DS_CONTROL_ACCESS ) )
        {
            *pbAccessGranted = TRUE;
        }
    }

    bResult = TRUE;

Exit:

    if (pSize) {
        pLDAP->pfnldap_value_free_len(pSize);
    }

    if (ppwszValues) {
        pLDAP->pfnldap_value_free(ppwszValues);
    }

    return bResult;
}


//*************************************************************
//
//  FilterCheck()
//
//  Purpose:    Determines if the GPO passes the WQL filter check
//
//  Parameters: pRsopToken      - Rsop security token
//              pGpoFilter      - Gpo filter class
//              pbFilterAllowed - True if GPO passes the filter check
//              pwszFilterId    - Filter id that can be used for
//                                Rsop logging. Needs to be freed by caller
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
// Notes:
//      Even though the code can handle multiple filters, we are not logging
// it or returning it till we make up our minds whether this is actually supported.
//
//*************************************************************

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *wszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2, DWORD dwParam3 );

BOOL FilterCheck( PLDAP pld, PLDAP_API pLDAP, 
                  PLDAPMessage pMessage,
                  PRSOPTOKEN pRsopToken,
                  LPTSTR szWmiFilter,
                  CGpoFilter *pGpoFilter,
                  CLocator *pLocator,
                  BOOL *pbFilterAllowed,
                  WCHAR **ppwszFilterId
                  )
{
    *pbFilterAllowed = FALSE;
    *ppwszFilterId = NULL;
    XPtrLF<WCHAR> xWmiFilter;
    HRESULT hr;
    LPTSTR *lpValues;
    XLastError xe;


    //
    // In the results, get the values that match the gPCFilterObject 
    //


    lpValues = pLDAP->pfnldap_get_values (pld, pMessage, szWmiFilter);

    if (lpValues) {
        DWORD dwFilterLength = lstrlen(*lpValues)+1;
        xWmiFilter = (LPWSTR) LocalAlloc( LPTR, (dwFilterLength) * sizeof(TCHAR) );
        if ( xWmiFilter == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("FilterCheck:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            return FALSE;
        }

        hr = StringCchCopy (xWmiFilter, dwFilterLength, *lpValues);
        ASSERT(SUCCEEDED(hr));

        DebugMsg((DM_VERBOSE, TEXT("FilterCheck:  Found WMI Filter id of:  <%s>"), (LPWSTR)xWmiFilter));
        pLDAP->pfnldap_value_free (lpValues);
    }

    

    if ( xWmiFilter == NULL ) {

        //
        // For backwards compatibility, assume that a null filter id implies that
        // GPO passes filter check.
        //

        *pbFilterAllowed = TRUE;
        return TRUE;
    }

    if (*xWmiFilter == TEXT(' ')) {

       if (*(xWmiFilter+1) == TEXT('\0')) {

          //
          // The UI will reset a GPO's filter to a single space character
          // when the admin sets the filter option to None.
          //

          *pbFilterAllowed = TRUE;
          return TRUE;
       }
    }

    //
    // The value we get back to split the
    // DS path and the id before calling evaluate..
    //
    // The query is assumed to be of the format..
    // [Dspath;id;flags] [Dspath;id;flags]
    //
    

    LPWSTR lpPtr = xWmiFilter;
    LPWSTR lpDsPath=NULL;
    LPWSTR lpId=NULL;
    LPWSTR dwFlags = 0;
    WCHAR wszNS[] = L"MSFT_SomFilter.ID=\"%ws\",Domain=\"%ws\"";

    XPtrLF<WCHAR> xwszNS;
    
    *pbFilterAllowed = TRUE;

    while (*lpPtr) {

        while ((*lpPtr) && (*lpPtr != L'[')) {
            lpPtr++;
        }

        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        lpPtr++;
        lpDsPath = lpPtr;

        while ((*lpPtr) && (*lpPtr != L';')) 
            lpPtr++;
        
        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        *lpPtr = L'\0';
        lpPtr++;
        lpId = lpPtr;

        while ((*lpPtr) && (*lpPtr != L';')) 
            lpPtr++;
        
        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        *lpPtr = L'\0';
        lpPtr++;

        while ((*lpPtr) && (*lpPtr != L']')) 
            lpPtr++;

        if (!(*lpPtr)) {
            xe = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
        
        lpPtr++;

        DWORD dwNSLength = lstrlen(wszNS)+lstrlen(lpId)+lstrlen(lpDsPath);
        xwszNS = (LPWSTR)LocalAlloc(LPTR, (dwNSLength)*sizeof(WCHAR));

        if (!xwszNS) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("FilterCheck: Couldn't allocate memory for filter. error - %d" ), GetLastError() ));
            return FALSE;
        }

        hr = StringCchPrintf(xwszNS, dwNSLength, wszNS, lpId, lpDsPath);
        ASSERT(SUCCEEDED(hr));

        if ( pRsopToken ) {

            //
            // Planning mode
            //

            *pbFilterAllowed = pGpoFilter->FilterCheck( xwszNS );

        } else {

            //
            // Normal mode
            //

            IWbemServices *pWbemServices = pLocator->GetPolicyConnection();
            if( pWbemServices == NULL ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("FilterCheck: ConnectServer failed. hr = 0x%x" ), xe));
                return FALSE;
            }


            XBStr xbstrMethod = L"Evaluate";
            XBStr xbstrObject = xwszNS;

            XInterface<IWbemClassObject> xpOutParam = NULL;

            hr = pWbemServices->ExecMethod( xbstrObject,
                                            xbstrMethod,
                                            0,
                                            NULL,
                                            NULL,
                                            &xpOutParam,
                                            NULL );
            if(FAILED(hr)) {
                if (hr != WBEM_E_NOT_FOUND) {
                    // only full WMI error makes sense.
                    xe = hr;
                    DebugMsg((DM_WARNING, TEXT("FilterCheck: ExecMethod failed. hr=0x%x" ), hr ));
                    return FALSE;
                }
                else {
                    // treat it as if the filter doesn't exist
                    // only full WMI error makes sense.
                    xe = hr;
                    DebugMsg((DM_VERBOSE, TEXT("FilterCheck: Filter doesn't exist. Evaluating to false" )));
                    *pbFilterAllowed = FALSE;
                    *ppwszFilterId = xwszNS.Acquire();
                    return FALSE;
                }
            }

            XBStr xbstrRetVal = L"ReturnValue";
            VARIANT var;

            hr = xpOutParam->Get( xbstrRetVal, 0, &var, 0, 0);
            if(FAILED(hr)) {
                xe = hr;
                DebugMsg((DM_WARNING, TEXT("FilterCheck: Get failed. hr=0x%x" ), hr ));
                return FALSE;
            }

            XVariant xVar( &var );
            if (FAILED(var.lVal)) {
                xe = hr;
                DebugMsg((DM_WARNING, TEXT("FilterCheck: Evaluate returned error. hr=0x%x" ), var.lVal ));
                *pbFilterAllowed = FALSE;
            }

            if (var.lVal == S_FALSE) {
                *pbFilterAllowed = FALSE;
            }
        }
    }

    //
    // Acquire it and return to the caller
    //


    *ppwszFilterId = xwszNS.Acquire();
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gplist.cpp ===
//*************************************************************
//
//  Group Policy Support - Getting the list of gpos
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

//*************************************************************
//
//  DsQuoteSearchFilter()
//
// 
//  Comment:  This function takes a DN and returns a version
//            of the DN escaped according to RFC's 2253 and 2254
//
//  Return:   A pointer to the quoted string, which must be
//            freed by the caller.  If the function fails, the
//            return value is 0.
//
//*************************************************************
LPWSTR
DsQuoteSearchFilter( LPCWSTR szUDN )
{
    DmAssert(NULL != szUDN );
    if (NULL == szUDN)
        return NULL;

    DWORD   cUDN = wcslen( szUDN );
    LPWSTR  szQDN = 0, szTemp = 0;;
    HRESULT hr = S_OK;

    //
    // Note that the maximum length of the quoted string would result
    // if every single character in the DN needed to be escaped.  Since
    // the escaped characters are of the form '\nn', the escaped string 
    // could be at most 3 times the size of the original string
    //
    if ( cUDN )
    {
        szTemp = szQDN = (LPWSTR) LocalAlloc( LPTR, ( cUDN * 3 + 1 ) * sizeof( WCHAR ) );
    }

    if ( !szQDN )
    {
        return 0;
    }
    
    while ( *szUDN )
    {
        WCHAR   szBuffer[16];
        
        if ( *szUDN == L'*' || *szUDN == L'(' || *szUDN == L')' || !*szUDN )
        {
            //
            // convert special characters to \NN
            //
            *szQDN++ = L'\\';
            DWORD dwQDNLength = cUDN * 3 + 1 - (DWORD) (szQDN - szTemp);
            hr = StringCchCat( szQDN, dwQDNLength, _itow( *szUDN++, szBuffer, 16 ) );
            ASSERT(SUCCEEDED(hr));
            szQDN += 2;
        }
        else
        {
            *szQDN++ = *szUDN++;
        }
    }
    *szQDN = 0;

    return szTemp;
}

//*************************************************************
//
//  GetGPOInfo()
//
//  Purpose:    Gets the GPO info for this threads token.
//
//  Parameters: dwFlags         -   GPO_LIST_FLAG_* from userenv.h
//              lpHostName      -   Domain DN name or DC server name
//              lpDNName        -   User or Machine DN name
//              lpComputerName  -   Computer name used for site look up
//              lpGPOList       -   Receives the list of GROUP_POLICY_OBJECTs
//              ppSOMList       -   List of LSDOUs returned here
//              ppGpContainerList - List of Gp containers returned here
//              pNetAPI32       -   Netapi32 function table
//              bMachineTokenOK -   Ok to query for the machine token
//              pRsopToken      -   Rsop security token
//              pGpoFilter      -   Gpo filter
//              pLocator        -   WMI interfaces
//
//  Comment:    This is a link list of GROUP_POLICY_OBJECTs.  Each can be
//              free'ed with LocalFree() or calling FreeGPOList()
//
//              The processing sequence is:
//
//              Local Forest Site Domain OrganizationalUnit
//
//              Note that we process this list backwards to get the
//              correct sequencing for the force flag.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetGPOInfo(DWORD dwFlags,
                LPTSTR lpHostName,
                LPTSTR lpDNName,
                LPCTSTR lpComputerName,
                PGROUP_POLICY_OBJECT *lpGPOList,
                LPSCOPEOFMGMT *ppSOMList,
                LPGPCONTAINER *ppGpContainerList,
                PNETAPI32_API pNetAPI32,
                BOOL bMachineTokenOk,
                PRSOPTOKEN pRsopToken,
                LPWSTR pwszSiteName,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator )
{
    PGROUP_POLICY_OBJECT pGPOForcedList = NULL, pGPONonForcedList = NULL;
    PLDAP  pld = NULL;
    ULONG ulResult;
    BOOL bResult = FALSE;
    BOOL bBlock = FALSE;
    LPTSTR lpDSObject, lpTemp;
    PLDAPMessage pLDAPMsg = NULL;
    TCHAR szGPOPath[MAX_PATH];
    TCHAR szGPOName[50];
    BOOL bVerbose;
    DWORD dwVersion, dwOptions;
    TCHAR szNamingContext[] = TEXT("configurationNamingContext");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor"); // this is unused currently
    LPTSTR lpAttr[] = { szNamingContext,
                        szSDProperty,
                        0 };

    PGROUP_POLICY_OBJECT lpGPO, lpGPOTemp;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    PLDAP_API pldap_api;
    HANDLE hToken = NULL, hTempToken;
    DWORD dwFunctionalityVersion;
    PGROUP_POLICY_OBJECT pDeferredForcedList = NULL, pDeferredNonForcedList = NULL;
    DNENTRY *pDeferredOUList = NULL;    // List of deferred OUs
    TCHAR*  szDN;
    PSECUR32_API pSecur32Api;
    BOOL    bAddedOU = FALSE;
    PLDAP   pldMachine = 0;
    VOID *pData;
    BOOL bOwnSiteName = FALSE;
    BOOL bRsopLogging = (ppSOMList != 0);
    BOOL bRsopPlanningMode = (pRsopToken != 0);
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  ********************************")));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Entering...")));


    //
    // Start with lpGPOList being a pointer to null
    //

    *lpGPOList = NULL;

    DmAssert( *ppSOMList == NULL );
    DmAssert( *ppGpContainerList == NULL );

    //
    // Check if we should be verbose to the event log
    //

    bVerbose = CheckForVerbosePolicy();


    //
    // Load the secur32 api
    //

    pSecur32Api = LoadSecur32();

    if (!pSecur32Api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to load secur32 api.")));
        goto Exit;
    }

    //
    // Load the ldap api
    //

    pldap_api = LoadLDAP();

    if (!pldap_api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to load ldap api.")));
        goto Exit;
    }

    //=========================================================================
    //
    // If we don't have a DS server or user / machine name, we can
    // skip the DS stuff and only check for a local GPO
    //
    //=========================================================================

    if (!lpHostName || !lpDNName) {
        DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  lpHostName or lpDNName is NULL.  Skipping DS stuff.")));
        goto CheckLocal;
    }


    //
    // Get the user or machine's token
    //

    if (bMachineTokenOk && (dwFlags & GPO_LIST_FLAG_MACHINE)) {

        hToken = GetMachineToken();

        if (!hToken) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get the machine token with  %d"),
                     GetLastError()));

            CEvents ev(TRUE, EVENT_FAILED_MACHINE_TOKEN);
            ev.AddArgWin32Error(xe); ev.Report();
            goto Exit;
        }

    } else {

        if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                              TRUE, &hTempToken)) {
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                                  &hTempToken)) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get a token with  %d"),
                         GetLastError()));
                goto Exit;
            }
        }


        //
        // Duplicate it so it can be used for impersonation
        //

        if (!DuplicateTokenEx(hTempToken, TOKEN_QUERY, // Fixing bug 568191. 
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &hToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to duplicate the token with  %d"),
                     GetLastError()));
            CloseHandle (hTempToken);
            goto Exit;
        }

        CloseHandle (hTempToken);
    }


    //
    // Get a connection to the DS
    //

    if ((lpHostName[0] == TEXT('\\')) && (lpHostName[1] == TEXT('\\')))  {
        lpHostName = lpHostName + 2;
    }

    pld = pldap_api->pfnldap_init( lpHostName, LDAP_PORT);

    if (!pld) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_open for <%s> failed with = 0x%x or %d"),
                 lpHostName, pldap_api->pfnLdapGetLastError(), GetLastError()));

        CEvents ev(TRUE, EVENT_FAILED_DS_CONNECT);
        ev.AddArg(lpHostName); ev.AddArgLdapError(pldap_api->pfnLdapGetLastError()); ev.Report();

        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Server connection established.")));

    //
    // Turn on Packet integrity flag
    //

    pData = (VOID *) LDAP_OPT_ON;
    ulResult = pldap_api->pfnldap_set_option(pld, LDAP_OPT_SIGN, &pData);

    if (ulResult != LDAP_SUCCESS) {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
        goto Exit;
    }

    ulResult = pldap_api->pfnldap_connect(pld, 0);

    if (ulResult != LDAP_SUCCESS) {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to connect %s with %d"), lpHostName, ulResult));
        pldap_api->pfnldap_unbind(pld);
        pld = 0;
        goto Exit;
    }

    //
    // Bind to the DS.
    //

    if ( !bRsopPlanningMode && (dwFlags & GPO_LIST_FLAG_MACHINE) ) {

        //
        // For machine policies specifically ask for Kerberos as the only authentication
        // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
        // and localsystem context has no real credentials, which means that we won't get
        // any GPOs back.
        //

        SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;

        secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        secIdentity.User = 0;
        secIdentity.UserLength = 0;
        secIdentity.Domain = 0;
        secIdentity.DomainLength = 0;
        secIdentity.Password = 0;
        secIdentity.PasswordLength = 0;
        secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        secIdentity.PackageList = wszKerberos;
        secIdentity.PackageListLength = lstrlen( wszKerberos );

        ulResult = pldap_api->pfnldap_bind_s (pld, NULL, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI);

    } else
        ulResult = pldap_api->pfnldap_bind_s (pld, NULL, NULL, LDAP_AUTH_SSPI);

    if (ulResult != LDAP_SUCCESS) {
       xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
       DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_bind_s failed with = <%d>"),
                ulResult));
       CEvents ev(TRUE, EVENT_FAILED_DS_BIND);
       ev.AddArg(lpHostName); ev.AddArgLdapError(ulResult); ev.Report();
       goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Bound successfully.")));


    //=========================================================================
    //
    // Check the organizational units and domain for policy
    //
    //=========================================================================


    if (!(dwFlags & GPO_LIST_FLAG_SITEONLY)) {

        //
        // Loop through the DN Name to find each OU or the domain
        //

        lpDSObject = lpDNName;

        while (*lpDSObject) {

            //
            // See if the DN name starts with OU=
            //

            if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                               lpDSObject, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
                if ( !AddOU( &pDeferredOUList, lpDSObject, GPLinkOrganizationalUnit ) ) {
                    xe = GetLastError();
                    goto Exit;
                }
            }

            //
            // See if the DN name starts with DC=
            //

            else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                    lpDSObject, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
                if ( !AddOU( &pDeferredOUList, lpDSObject, GPLinkDomain ) ) {
                    xe = GetLastError();
                    goto Exit;
                }


                //
                // Now that we've found a DN name that starts with DC=
                // we exit the loop now.
                //

                break;
            }


            //
            // Move to the next chunk of the DN name
            //

            while (*lpDSObject && (*lpDSObject != TEXT(','))) {
                lpDSObject++;
            }

            if (*lpDSObject == TEXT(',')) {
                lpDSObject++;
            }
        }

        //
        // Evaluate deferred OUs with single Ldap query
        //

        if ( !EvaluateDeferredOUs(  pDeferredOUList,
                                    dwFlags,
                                    hToken,
                                    &pDeferredForcedList,
                                    &pDeferredNonForcedList,
                                    ppSOMList,
                                    ppGpContainerList,
                                    bVerbose,
                                    pld,
                                    pldap_api,
                                    &bBlock,
                                    pRsopToken ) )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  EvaluateDeferredOUs failed. Exiting") ));
            goto Exit;
        }
    }


    //=========================================================================
    //
    // Check the site object for policy
    //
    //=========================================================================

    //
    // Now we need to query for the domain name.
    //

    //
    // Now we need to query for the domain name.  This is done by
    // reading the operational attribute configurationNamingContext
    //

    if (pwszSiteName) {
        pldMachine = GetMachineDomainDS( pNetAPI32, pldap_api );

        if ( pldMachine )
        {
            pLDAPMsg = 0;

            ulResult = pldap_api->pfnldap_search_s( pldMachine,
                                                    TEXT(""),
                                                    LDAP_SCOPE_BASE,
                                                    TEXT("(objectClass=*)"),
                                                    lpAttr,
                                                    FALSE,
                                                    &pLDAPMsg);


            if ( ulResult == LDAP_SUCCESS )
            {
                LPTSTR* pszValues = pldap_api->pfnldap_get_values( pldMachine, pLDAPMsg, szNamingContext );

                if ( pszValues )
                {
                    LPWSTR szSite;
                    WCHAR  szSiteFmt[] = TEXT("CN=%s,CN=Sites,%s");

                    //
                    // Combine the domain name + site name to get the full
                    // DS object path
                    //
                    
                    DWORD dwSiteLen = lstrlen(pwszSiteName) + lstrlen(*pszValues) + lstrlen(szSiteFmt) + 1;
                    szSite = (LPWSTR) LocalAlloc( LPTR, (dwSiteLen) * sizeof(WCHAR));

                    if (szSite)
                    {
                        (void) StringCchPrintf( szSite, dwSiteLen, szSiteFmt, pwszSiteName, *pszValues );

                        if (SearchDSObject (szSite, dwFlags, hToken, &pDeferredForcedList, &pDeferredNonForcedList,
                                            ppSOMList, ppGpContainerList,
                                            bVerbose, GPLinkSite, pldMachine,
                                            pldap_api, NULL, &bBlock, pRsopToken )) {
    
                            bAddedOU = TRUE;
    
                        } else {
                            xe = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  SearchDSObject failed.  Exiting.")));
                        }

                        LocalFree(szSite);
                    }
                    else
                    { 
                        xe = ERROR_OUTOFMEMORY;
                    }

                    pldap_api->pfnldap_value_free( pszValues );
                }
                else
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get values.")));
                }

                pldap_api->pfnldap_msgfree( pLDAPMsg );
            }
            else
            {
                xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_search_s failed with = <%d>"), ulResult) );
                CEvents ev(TRUE, EVENT_FAILED_ROOT_SEARCH);
                ev.AddArgLdapError(ulResult); ev.Report();
            }
        }
        
        if ( !bAddedOU )
        {
            goto Exit;
        }
    }

#ifdef FGPO_SUPPORTED


    //=========================================================================
    //
    // Now query for the forest GPO
    //
    //=========================================================================

    pLDAPMsg = 0;

    ulResult = pldap_api->pfnldap_search_s( pld,
                                            TEXT(""),
                                            LDAP_SCOPE_BASE,
                                            TEXT("(objectClass=*)"),
                                            lpAttr,
                                            FALSE,
                                            &pLDAPMsg);


    if ( ulResult == LDAP_SUCCESS )
    {
        LPTSTR* pszValues = pldap_api->pfnldap_get_values( pld, pLDAPMsg, szNamingContext );

        if (pszValues) {
            if (SearchDSObject (*pszValues, dwFlags, hToken, &pDeferredForcedList, &pDeferredNonForcedList,
                                ppSOMList, ppGpContainerList,
                                bVerbose, GPLinkForest, pld,
                                pldap_api, NULL, &bBlock, pRsopToken )) {

                bAddedOU = TRUE;
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  SearchDSObject failed for forest GPOs.  Exiting.")));
            }
            
            pldap_api->pfnldap_value_free( pszValues );
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to get values for user config container.")));
        }
        
        pldap_api->pfnldap_msgfree( pLDAPMsg );
    }
    else
    {
        xe = pldap_api->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  ldap_search_s failed with = <%d>"), ulResult) );
        CEvents ev(TRUE, EVENT_FAILED_ROOT_SEARCH);
        ev.AddArgLdapError(ulResult); ev.Report();
    }

    
    if ( !bAddedOU )
    {
        goto Exit;
    }

#endif

CheckLocal:

    //
    // Evaluate all GPOs deferred so far with single Ldap query
    //

    if ( !EvaluateDeferredGPOs( pld,
                                pldap_api,
                                lpHostName,
                                dwFlags,
                                hToken,
                                bVerbose,
                                pDeferredForcedList,
                                pDeferredNonForcedList,
                                &pGPOForcedList,
                                &pGPONonForcedList,
                                ppGpContainerList,
                                pRsopToken,
                                pGpoFilter, pLocator ) )
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  EvaluateDeferredGPOs failed. Exiting") ));
        goto Exit;
    }


    //=========================================================================
    //
    // Check if we have a local GPO. If so, add it to the list. In planning mode
    // local Gpo processing is omitted because planning mode is generated on a DC
    // and local Gpo should refer to Gpo on the target computer.
    //
    //=========================================================================

    if (!bRsopPlanningMode && !(dwFlags & GPO_LIST_FLAG_SITEONLY)) {

        BOOL bDisabled = FALSE;
        BOOL bOldGpoVersion = FALSE;
        BOOL bNoGpoData = FALSE;
        DWORD dwSize = MAX_PATH;
        DWORD dwCount = 0;
        BOOL bOk = FALSE;
        TCHAR *pszExtensions = 0;
        BOOL bGptIniExists = FALSE;
        DWORD   dwRet;

        //
        // If the gpt.ini doesn't exist because this is a clean installed machine,
        // we manufacture default state for it here -- these values must be
        // initialized since they normally require the gpt.ini
        //

        dwFunctionalityVersion = 2;
        dwOptions = 0;
        bDisabled = FALSE;
        dwVersion = 0;
        bNoGpoData = TRUE;

        //
        // Retrieve the gpo path
        //

        dwRet = ExpandEnvironmentStrings (LOCAL_GPO_DIRECTORY, szGPOPath, ARRAYSIZE(szGPOPath));

        if (dwRet == 0)
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to expand local gpo path with error %d. Exiting"), GetLastError() ));
            goto Exit;
        }

        if (dwRet > ARRAYSIZE(szGPOPath))
        {
            xe = ERROR_INSUFFICIENT_BUFFER;
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to expand local gpo path with error %d. Exiting"), (DWORD)xe ));
            goto Exit;
        }


        //
        // We check for the existence of gpt.ini -- note that if it does not exist,
        // we will use the default state initialized earlier to represent this gpo --
        // this mimics the behavior of the gp engine, which does not distinguish between
        // different types of failures to access gpt.ini -- if access fails for any reason,
        // it is treated as the local gpo in the default (clean installed) case
        //
        if (GetFileAttributesEx (szGPOPath, GetFileExInfoStandard, &fad) &&
            (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            bGptIniExists = TRUE;
        } else {

            DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Local GPO's gpt.ini is not accessible, assuming default state.") ));
        }

        //
        // Retrieve the gpo name
        //

        if (!LoadString (g_hDllInstance, IDS_LOCALGPONAME, szGPOName, ARRAYSIZE(szGPOName))) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to local gpo name with error %d. Exiting"), GetLastError() ));
            goto Exit;
        }

        DmAssert( lstrlen(szGPOPath) + lstrlen(TEXT("gpt.ini")) + 1 < MAX_PATH );

        lpTemp = CheckSlash (szGPOPath);
        
        hr = StringCchCopy (lpTemp, MAX_PATH - (lpTemp - szGPOPath), TEXT("gpt.ini"));
        
        if ( FAILED(hr) ) {
            xe = ERROR_INSUFFICIENT_BUFFER;
            goto Exit;
        }

        //
        // Read the gpt.ini file if it exists -- otherwise the default values will be used
        //

        if ( bGptIniExists ) {

            bNoGpoData = FALSE;

            //
            // Check the functionalty version number
            //

            dwFunctionalityVersion = GetPrivateProfileInt(TEXT("General"), GPO_FUNCTIONALITY_VERSION, 2, szGPOPath);
            if (dwFunctionalityVersion < 2) {

                bOldGpoVersion = TRUE;

                DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  GPO %s was created by an old version of the Group Policy Editor.  It will be skipped."), szGPOName));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_GPO_TOO_OLD);
                    ev.AddArg(szGPOName); ev.Report();
                }

            }

            //
            // Check if this GPO is enabled
            //

            dwOptions = GetPrivateProfileInt(TEXT("General"), TEXT("Options"), 0, szGPOPath);

            if (((dwFlags & GPO_LIST_FLAG_MACHINE) &&
                 (dwOptions & GPO_OPTION_DISABLE_MACHINE)) ||
                 (!(dwFlags & GPO_LIST_FLAG_MACHINE) &&
                 (dwOptions & GPO_OPTION_DISABLE_USER))) {
                 bDisabled = TRUE;
            }

            //
            // Check if the version number is 0, if so there isn't any data
            // in the GPO and we can skip it
            //

            dwVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szGPOPath);

            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                dwVersion = MAKELONG (LOWORD(dwVersion), LOWORD(dwVersion));
            } else {
                dwVersion = MAKELONG (HIWORD(dwVersion), HIWORD(dwVersion));
            }

            if (dwVersion == 0) {

                bNoGpoData = TRUE;
                DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  GPO %s doesn't contain any data since the version number is 0.  It will be skipped."), szGPOName));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_GPO_NO_DATA);
                    ev.AddArg(szGPOName); ev.Report();
                }

            }

            //
            // Read list of extension guids
            //

            pszExtensions = (LPWSTR) LocalAlloc( LPTR, dwSize * sizeof(TCHAR) );
            if ( pszExtensions == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to allocate memory.")));
                goto Exit;
            }

            dwCount = GetPrivateProfileString( TEXT("General"),
                                               dwFlags & GPO_LIST_FLAG_MACHINE ? GPO_MACHEXTENSION_NAMES
                                                                               : GPO_USEREXTENSION_NAMES,
                                               TEXT(""),
                                               pszExtensions,
                                               dwSize,
                                               szGPOPath );

            while ( dwCount == dwSize - 1 )
            {
                //
                // Value has been truncated, so retry with larger buffer
                //

                LocalFree( pszExtensions );

                dwSize *= 2;
                pszExtensions = (LPWSTR) LocalAlloc( LPTR, dwSize * sizeof(TCHAR) );
                if ( pszExtensions == 0 ) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to allocate memory.")));
                    goto Exit;
                }

                dwCount = GetPrivateProfileString( TEXT("General"),
                                                   dwFlags & GPO_LIST_FLAG_MACHINE ? GPO_MACHEXTENSION_NAMES
                                                                                   : GPO_USEREXTENSION_NAMES,
                                                   TEXT(""),
                                                   pszExtensions,
                                                   dwSize,
                                                   szGPOPath );
            }

            if ( lstrcmpi( pszExtensions, TEXT("")) == 0 || lstrcmpi( pszExtensions, TEXT(" ")) == 0 ) {
                //
                // Extensions property was not found
                //


                LocalFree( pszExtensions );
                pszExtensions = 0;
            }
        }

        //
        // Tack on the correct subdirectory name
        //

        DmAssert( lstrlen(szGPOPath) + lstrlen(TEXT("Machine")) + 1 < MAX_PATH );

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            hr = StringCchCopy (lpTemp, MAX_PATH - (lpTemp - szGPOPath), TEXT("Machine"));
        } else {
            hr = StringCchCopy (lpTemp, MAX_PATH - (lpTemp - szGPOPath), TEXT("User"));
        }
        
        if ( FAILED(hr) ) {
            xe = HRESULT_CODE(hr);
            goto Exit;
        }

        //
        // Add this to the list of paths
        //

        if ( bRsopLogging ) {

            bOk = AddLocalGPO( ppSOMList );
            if ( !bOk ) {
                xe = GetLastError();
                if ( pszExtensions )
                    LocalFree( pszExtensions );
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to log Rsop data.")));
                goto Exit;
            }

            bOk = AddGPOToRsopList( ppGpContainerList,
                                    dwFlags,
                                    TRUE,
                                    TRUE,
                                    bDisabled, 
                                    dwVersion,
                                    L"LocalGPO",
                                    szGPOPath,
                                    szGPOName,
                                    szGPOName, 
                                    0,
                                    0,
                                    TRUE,
                                    0,
                                    L"Local",
                                    0 );
            if ( !bOk ) {
                xe = GetLastError();
                if ( pszExtensions )
                    LocalFree( pszExtensions );
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to log Rsop data.")));
                goto Exit;
            }

        }

        if ( !bDisabled && !bOldGpoVersion && !bNoGpoData )
        {

            bOk = AddGPO (&pGPONonForcedList, dwFlags, TRUE, TRUE, bDisabled, 0, dwVersion,
                          L"LocalGPO", szGPOPath,
                          szGPOName, szGPOName, pszExtensions, 0, 0, GPLinkMachine, L"Local", 0, TRUE,
                          FALSE, bVerbose, TRUE);
        }

        if ( pszExtensions )
            LocalFree( pszExtensions );

        if ( bOk ) {
            if ( bVerbose ) {
                if ( bDisabled || bOldGpoVersion || bNoGpoData ) {
                    CEvents ev(FALSE, EVENT_NO_LOCAL_GPO);
                    ev.Report();
                }
                else {
                    CEvents ev(FALSE, EVENT_FOUND_LOCAL_GPO);
                    ev.Report();
                }
            }
        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOInfo:  Failed to add local group policy object to the list.")));
            goto Exit;
        }
    }

    //
    // Merge the forced and nonforced lists together
    //

    if (pGPOForcedList && !pGPONonForcedList) {

        *lpGPOList = pGPOForcedList;

    } else if (!pGPOForcedList && pGPONonForcedList) {

        *lpGPOList = pGPONonForcedList;

    } else if (pGPOForcedList && pGPONonForcedList) {

        lpGPO = pGPONonForcedList;

        while (lpGPO->pNext) {
            lpGPO = lpGPO->pNext;
        }

        lpGPO->pNext = pGPOForcedList;
        pGPOForcedList->pPrev = lpGPO;

        *lpGPOList = pGPONonForcedList;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    //
    // Free any GPOs we found
    //

    if (!bResult) {
        FreeGPOList( pGPOForcedList );
        FreeGPOList( pGPONonForcedList );
    }

    //
    // Free temporary OU list
    //

    while ( pDeferredOUList ) {
        DNENTRY *pTemp = pDeferredOUList->pNext;
        FreeDnEntry( pDeferredOUList );
        pDeferredOUList = pTemp;
    }

    //
    // Free temporary deferred GPO lists
    //

    FreeGPOList( pDeferredForcedList );
    FreeGPOList( pDeferredNonForcedList );

    if (pld) {
        pldap_api->pfnldap_unbind (pld);
    }

    if ( pldMachine )
    {
        pldap_api->pfnldap_unbind( pldMachine );
    }

    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  Leaving with %d"), bResult));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOInfo:  ********************************")));

    if ( hToken )
    {
        CloseHandle( hToken );
    }

    return bResult;
}

//*************************************************************
//
//  GetGPOList()
//
//  Purpose:    Retreives the list of GPOs for the specified
//              user or machine
//
//  Parameters:  hToken     - User or machine token, if NULL,
//                            lpName and lpDCName must be supplied
//               lpName     - User or machine name in DN format,
//                            if hToken is supplied, this must be NULL
//               lpHostName - Host name.  This should be a domain's
//                            dn name for best performance.  Otherwise
//                            it can also be a DC name.  If hToken is supplied,
//                            this must be NULL
//               lpComputerName - Computer named used to determine site
//                                information.  Can be NULL which means
//                                use the local machine
//               dwFlags  - Flags field
//               pGPOList - Address of a pointer which receives
//                          the link list of GPOs
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI GetGPOList (HANDLE hToken, LPCTSTR lpName, LPCTSTR lpHostName,
                        LPCTSTR lpComputerName, DWORD dwFlags,
                        PGROUP_POLICY_OBJECT *pGPOList)
{
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    BOOL bResult = FALSE;
    LPTSTR lpDomainDN, lpDNName, lpTemp, lpUserName = NULL;
    DWORD dwResult;
    HANDLE hOldToken = 0;
    PNETAPI32_API pNetAPI32;
    LPSCOPEOFMGMT lpSOMList = 0;         // LSDOU list
    LPGPCONTAINER lpGpContainerList = 0; // GP container list
    HRESULT hr;
    OLE32_API *pOle32Api = NULL;
    XLastError xe;
    LPWSTR szSiteName = NULL;
    BOOL bInitializedCOM = FALSE;


    //
    // mask off the flags that are used internally.
    //
    dwFlags &= FLAG_INTERNAL_MASK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("GetGPOList: Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  hToken = 0x%x"), (hToken ? hToken : 0)));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  lpName = <%s>"), (lpName ? lpName : TEXT("NULL"))));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  lpHostName = <%s>"), (lpHostName ? lpHostName : TEXT("NULL"))));
    DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  dwFlags = 0x%x"), dwFlags));


    //
    // Check parameters
    //

    if (hToken) {
        if (lpName || lpHostName) {
            xe = ERROR_INVALID_PARAMETER;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: lpName and lpHostName must be NULL")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        if (!lpName || !lpHostName) {
            xe = ERROR_INVALID_PARAMETER;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: lpName and lpHostName must be valid")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    // check if there is space in the lpHostName
    if (lpHostName)
    {
        // fixing bug 567835
        // check if there is space in the lpHostName
        LPCTSTR lpPtr = lpHostName;

        while (*lpPtr) {
            if (*lpPtr == L' ')
            {
                xe = ERROR_INVALID_PARAMETER;
                DebugMsg((DM_WARNING, TEXT("GetGPOInfo: lpHostName shld not contain space in it")));
                return FALSE;
            }
            lpPtr++;
        }
    }

    if (!pGPOList) {
        xe = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("GetGPOList: pGPOList is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOList:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    //
    // If an hToken was offered, then we need to get the name and
    // domain DN name
    //

    if (hToken) {

        //
        // Impersonate the user / machine
        //

        if (!ImpersonateUser(hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList: Failed to impersonate user")));
            return FALSE;
        }


        //
        // Get the username in DN format
        //

        lpUserName = MyGetUserName (NameFullyQualifiedDN);

        if (!lpUserName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  MyGetUserName failed for DN style name with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        lpDNName = lpUserName;
        DebugMsg((DM_VERBOSE, TEXT("GetGPOList:  Queried lpDNName = <%s>"), lpDNName));


        //
        // Get the dns domain name
        //

        lpDomainDN = MyGetDomainDNSName ();

        if (!lpDomainDN) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  MyGetUserName failed for dns domain name with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }


        //
        // Check this domain for a DC
        //

        dwResult = pNetAPI32->pfnDsGetDcName (NULL, lpDomainDN, NULL, NULL,
                                   DS_DIRECTORY_SERVICE_PREFERRED |
                                   DS_RETURN_DNS_NAME,
                                   &pDCI);

        if (dwResult != ERROR_SUCCESS) {
            xe = dwResult;
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  DSGetDCName failed with %d for <%s>"),
                     dwResult, lpDomainDN));
            goto Exit;
        }


        //
        // Found a DC, does it have a DS ?
        //

        if (!(pDCI->Flags & DS_DS_FLAG)) {
            xe = ERROR_DS_DS_REQUIRED;
            pNetAPI32->pfnNetApiBufferFree(pDCI);
            DebugMsg((DM_WARNING, TEXT("GetGPOList:  The domain <%s> does not have a DS"),
                     lpDomainDN));
            goto Exit;
        }

        pNetAPI32->pfnNetApiBufferFree(pDCI);

    } else {

        //
        // Use the server and DN name passed in
        //

        lpDomainDN = (LPTSTR)lpHostName;
        lpDNName = (LPTSTR)lpName;
    }

    pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetGPOList: Failed to load ole32.dll.") ));
        goto Exit;
    }

    hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    if ( SUCCEEDED(hr) )
    {
        bInitializedCOM = TRUE;
    }

    //
    // If this thread is already initialized, this is fine -- we will ignore
    // this since we are safely initialized, we just need to remember not
    // to try to uninitialize the thread later
    //
    if ( RPC_E_CHANGED_MODE == hr )
    {
        hr = S_OK;
    }

    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("GetGPOList: CoInitializeEx failed with 0x%x."), hr ));
        goto Exit;
    }


    hr = CoInitializeSecurity(NULL, -1, NULL, NULL, 
                     RPC_C_AUTHN_LEVEL_DEFAULT, /* this should be the current value */
                     RPC_C_IMP_LEVEL_IMPERSONATE,
                     NULL, EOAC_NONE, NULL);

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("GetGPOList: CoInitializeSecurity failed with 0x%x"), hr ));
    }

    //
    // Call to get the list of GPOs
    //
    dwResult = pNetAPI32->pfnDsGetSiteName(lpComputerName,  &szSiteName);

    if ( dwResult != ERROR_SUCCESS )
    {
        if ( dwResult != ERROR_NO_SITENAME )
        {
            xe = dwResult;
            DebugMsg((DM_WARNING, TEXT("GetGPOList: DSGetSiteName failed, exiting. 0x%x"), dwResult ));
            goto Exit;
        }
        szSiteName = 0;
    }

    {
        CLocator locator;
        // Clocator has a bunch of OLE interfaces.
        // It should be released before CoUninit gets called
        bResult = GetGPOInfo(   dwFlags,
                                lpDomainDN,
                                lpDNName,
                                lpComputerName,
                                pGPOList,
                                &lpSOMList,
                                &lpGpContainerList,
                                pNetAPI32,
                                FALSE,
                                0,
                                szSiteName,
                                0,
                                &locator );

        if (!bResult) {
            xe = GetLastError();
        }
    }

Exit:

    if ( bInitializedCOM )
    {
        pOle32Api->pfnCoUnInitialize();
    }

    //
    // Stop impersonating if a hToken was given
    //

    if ( hOldToken ) {
        RevertToUser(&hOldToken);
    }

    if (lpDomainDN) {
        LocalFree (lpDomainDN);
    }

    if (lpUserName) {
        LocalFree (lpUserName);
    }

    if ( szSiteName )
    {
        pNetAPI32->pfnNetApiBufferFree( szSiteName );
    }

    FreeSOMList( lpSOMList );
    FreeGpContainerList( lpGpContainerList );

    DebugMsg((DM_VERBOSE, TEXT("GetGPOList: Leaving with %d"), bResult));

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpnotif.h ===
//*************************************************************
//
//  Group Policy Notification
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  History:    28-Sep-98   SitaramR    Created
//
//*************************************************************


DWORD InitializeNotifySupport();
void ShutdownNotifySupport();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpnotif.cpp ===
//*************************************************************
//
//  Group Policy Notification
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  Notes:      There is a small window where notifications
//              can be lost. If while processing an eMonitor workitem
//              a policy event is Pulsed then that notification will
//              be lost. This window can be closed by using two threads.
//
//  History:    28-Sep-98   SitaramR    Created
//
//*************************************************************

#include "gphdr.h"

//
// Work items for notification thread
//
enum EWorkType { eMonitor,              // Monitor events
                 eTerminate };          // Stop monitoring

//
// Entry in list of registered events
//
typedef struct _GPNOTIFINFO
{
    HANDLE                 hEvent;      // Event to be signaled
    BOOL                   bMachine;    // Machine policy notifcation ?
    struct _GPNOTIFINFO *  pNext;       // Singly linked list ptr
} GPNOTIFINFO;


typedef struct _GPNOTIFICATION
{
    HMODULE           hModule;           // Module handle to userenv.dll
    HANDLE            hThread;           // Notification thread
    HANDLE            hThreadEvent;      // For signaling notification thread (Ordering of fields is important)
    HANDLE            hMachEvent;        // Event signaled by machine policy change
    HANDLE            hUserEvent;        // Event signaled by user policy change
    enum EWorkType    eWorkType;         // Work descrpition for notification thread
    GPNOTIFINFO *     pNotifList;        // List of registered events
} GPNOTIFICATION;

GPNOTIFICATION g_Notif = { NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           eMonitor,
                           NULL };

CRITICAL_SECTION g_NotifyCS;             // Lock


//
// Forward decls
//
DWORD WINAPI NotificationThread();
void NotifyEvents( BOOL bMachine );



//*************************************************************
//
//  InitNotifSupport, ShutdownNotifSupport
//
//  Purpose:    Initialization and cleanup routines
//
//*************************************************************

DWORD InitializeNotifySupport()
{
    __try
    {
        InitializeCriticalSection( &g_NotifyCS );
        return ERROR_SUCCESS;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return ERROR_OUTOFMEMORY;
    }
}

void ShutdownNotifySupport()
{
    BOOL fWait = FALSE;
    DWORD dwResult;

    {
        EnterCriticalSection( &g_NotifyCS );

        if ( g_Notif.hThread != NULL )
        {
            //
            // Set up terminate workitem and then signal thread
            //

            fWait = TRUE;
            g_Notif.eWorkType = eTerminate;

            if (!SetEvent( g_Notif.hThreadEvent )) {
                // dll is going away. this is the best that we can do.
                DebugMsg((DM_WARNING, TEXT("ShutdownNotifySupport: SetEvent failed with %d. abandoning thread"),
                         GetLastError()));
                fWait = FALSE;
            }
        }

        LeaveCriticalSection( &g_NotifyCS );
    }

    if ( fWait )
        WaitForSingleObject( g_Notif.hThread, INFINITE );

    {
        EnterCriticalSection( &g_NotifyCS );

        //
        // Close all opened handles
        //

        if ( g_Notif.hThread != NULL )
            CloseHandle( g_Notif.hThread );

        if ( g_Notif.hThreadEvent != NULL )
            CloseHandle( g_Notif.hThreadEvent );

        if ( g_Notif.hUserEvent != NULL )
            CloseHandle( g_Notif.hUserEvent );

        if ( g_Notif.hMachEvent != NULL )
            CloseHandle( g_Notif.hMachEvent );

        LeaveCriticalSection( &g_NotifyCS );
    }

    DeleteCriticalSection( &g_NotifyCS );
}


//*************************************************************
//
//  RegisterGPNotification
//
//  Purpose:    Registers for a group policy change notification
//
//  Parameters: hEvent   -   Event to be notified
//              bMachine -   If true, then register for
//                                 machine policy notification, else
//                                 user policy notification
//
//  Returns:    True if successful
//              False if error occurs
//
//*************************************************************

BOOL WINAPI RegisterGPNotification( IN HANDLE hEvent, IN BOOL bMachine )
{
    BOOL bResult = FALSE;
    BOOL bNotifyThread = FALSE;
    GPNOTIFINFO *pNotifInfo = NULL;

    //
    // Validate input as much as possible
    //

    if ( NULL == hEvent )
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_NotifyCS );

    //
    // Create events and thread as needed
    //

    if ( g_Notif.hThreadEvent == NULL )
    {
        g_Notif.hThreadEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( g_Notif.hThreadEvent == NULL )
            goto Exit;
    }

    if ( g_Notif.hMachEvent == NULL )
    {
        g_Notif.hMachEvent = OpenEvent (SYNCHRONIZE, FALSE, MACHINE_POLICY_APPLIED_EVENT);

        if ( g_Notif.hMachEvent == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateEvent failed with %d"),
                     GetLastError()));

            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( !bMachine && g_Notif.hUserEvent == NULL )
    {
        g_Notif.hUserEvent = OpenEvent (SYNCHRONIZE, FALSE, USER_POLICY_APPLIED_EVENT);

        if ( g_Notif.hUserEvent == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateEvent failed with %d"),
                     GetLastError()));

            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( g_Notif.hThread == NULL )
    {
        // RAID 717164: Previously, the created thread would call LoadLibrary( "userenv.dll" ) once it
        //  spins up, thereby permanently locking the dll from unloading because the thread would never
        //  go away (except when DllMain(DLL_PROCESS_DETACH) is called, which will not happen as the
        //  thread has a refcount to the library - catch 22).
        // With this bug, there is a possibility that DllMain(DLL_PROCESS_DETACH) can get called before
        //  the created thread reaches our routine. In this case, the created thread would wait on the
        //  loader lock critical section, but we know that NT locks the loader lock before calling
        //  DllMain. Therefor, in ShutdownNotifySupport called from DllMain(DLL_PROCESS_DETACH), this
        //  thread is waiting for the created thread to stop, but the created thread is locked waiting
        //  for the critical section held by the thread waiting for it - DEADLOCK!
        // So, the solution with the smallest impact to stability is simply to keep the status quo
        //  mentioned above (the catch 22), but ensure that it also happens in the deadlock case above,
        //  thereby avoiding the deadlock and fixing the bug.
        // How do we do that? By permanently pinning the Dll from ever dynamically unloading BEFORE we
        //  spin up this thread.
        GetModuleHandleEx( GET_MODULE_HANDLE_EX_FLAG_PIN, TEXT("userenv.dll"), &(g_Notif.hModule) );
        
        DWORD dwThreadId;
        g_Notif.hThread = CreateThread( NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) NotificationThread,
                                        0,
                                        0,
                                        &dwThreadId );
        if ( g_Notif.hThread == NULL ) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: CreateThread failed with %d"),
                     GetLastError()));
            goto Exit;
        }

        bNotifyThread = TRUE;
    }

    if ( bNotifyThread )
    {
        //
        // Notify thread that there is a new workitem, possibly
        // user event has been added.
        //

        g_Notif.eWorkType = eMonitor;
        if (!SetEvent( g_Notif.hThreadEvent )) {
            DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: SetEvent failed with %d"),
                     GetLastError()));
            goto Exit;
        }
    }

    //
    // Add event to beginning of list
    //

    pNotifInfo = (GPNOTIFINFO *) LocalAlloc( LPTR, sizeof(GPNOTIFINFO) );
    if ( pNotifInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("RegisterGPNotification: LocalAlloc failed with %d"),
                 GetLastError()));
        goto Exit;
    }

    pNotifInfo->hEvent = hEvent;
    pNotifInfo->bMachine = bMachine;
    pNotifInfo->pNext = g_Notif.pNotifList;
    g_Notif.pNotifList = pNotifInfo;

    bResult = TRUE;

Exit:

    LeaveCriticalSection( &g_NotifyCS );
    return bResult;
}


//*************************************************************
//
//  UnregisterGPNotification
//
//  Purpose:    Removes registration for a group policy change notification
//
//  Parameters: hEvent  -   Event to be removed
//
//  Return:     True if successful
//              False if error occurs
//
//*************************************************************

BOOL WINAPI UnregisterGPNotification( IN HANDLE hEvent )
{
    BOOL bFound = FALSE;
    GPNOTIFINFO *pTrailPtr = NULL;
    GPNOTIFINFO *pCurPtr = NULL;

    EnterCriticalSection( &g_NotifyCS );

    pCurPtr = g_Notif.pNotifList;

    while ( pCurPtr != NULL )
    {
        if ( pCurPtr->hEvent == hEvent )
        {
            //
            // Found match, so delete entry
            //
            if ( pTrailPtr == NULL )
            {
                //
                // First elem of list matched
                //
                g_Notif.pNotifList = pCurPtr->pNext;
            }
            else
                pTrailPtr->pNext = pCurPtr->pNext;

            LocalFree( pCurPtr );
            bFound = TRUE;
            break;
        }

        //
        // Advance down the list
        //

        pTrailPtr = pCurPtr;
        pCurPtr = pCurPtr->pNext;
    }

    LeaveCriticalSection( &g_NotifyCS );
    return bFound;
}


//*************************************************************
//
//  CGPNotification::NotificationThread
//
//  Purpose:    Separate thread for notifications
//
//  Returns:    0
//
//*************************************************************

DWORD WINAPI NotificationThread()
{
    DWORD cEvents = 2;
    BOOL fShutdown = FALSE;

    HINSTANCE hInst = LoadLibrary (TEXT("userenv.dll"));

    {
        EnterCriticalSection( &g_NotifyCS );

        //
        // The event fields in g_Notif are ordered as hThreadEvent,
        // hMachEvent and finally hUserEvent. The first two events have
        // to be successfully created in order for this thread to run
        // (see asserts). If the user event has been successfully created
        // then that too is monitored.
        //

        DmAssert( g_Notif.hThreadEvent != NULL && g_Notif.hMachEvent != NULL );

        if ( g_Notif.hUserEvent != NULL )
            cEvents = 3;

        LeaveCriticalSection( &g_NotifyCS );
    }

    while ( !fShutdown )
    {
        DWORD dwResult = WaitForMultipleObjects( cEvents,
                                                 &g_Notif.hThreadEvent,
                                                 FALSE,
                                                 INFINITE );

        EnterCriticalSection( &g_NotifyCS );

        if ( dwResult == WAIT_FAILED )
        {
            DebugMsg((DM_WARNING, TEXT("GPNotification: WaitforMultipleObjects failed")));
            fShutdown = TRUE;
        }
        else if ( dwResult == WAIT_OBJECT_0 )
        {
            if (!ResetEvent( g_Notif.hThreadEvent )) {
                DebugMsg((DM_WARNING, TEXT("GPNotification: ResetEvent failed with error %d"), GetLastError()));
                fShutdown = TRUE;
            }
            else
            {
                if ( g_Notif.eWorkType == eMonitor )
                {
                    //
                    // Start monitoring user events too
                    //
                    if ( g_Notif.hUserEvent != NULL )
                        cEvents = 3;
                }
                else {
                    fShutdown = TRUE;
                }
            }
        }
        else if ( dwResult == WAIT_OBJECT_0 + 1 || dwResult == WAIT_OBJECT_0 + 2 )
        {
            BOOL bMachine = (dwResult == WAIT_OBJECT_0 + 1);
            NotifyEvents( bMachine );

            if ( g_Notif.pNotifList == NULL )
                fShutdown = TRUE;
        }
        else
        {
            if ( dwResult == WAIT_ABANDONED_0 || dwResult == WAIT_ABANDONED_0 + 1 )
                fShutdown = TRUE;
            else
            {
                CloseHandle( g_Notif.hUserEvent );
                g_Notif.hUserEvent = NULL;

                cEvents = 2;
            }
        }

        if ( fShutdown )
        {
            //
            // Close all handles and thread
            //
            CloseHandle( g_Notif.hThreadEvent );
            g_Notif.hThreadEvent = NULL;

            if ( g_Notif.hMachEvent != NULL )
            {
                CloseHandle( g_Notif.hMachEvent );
                g_Notif.hMachEvent = NULL;
            }

            if ( g_Notif.hUserEvent != NULL )
            {
                CloseHandle( g_Notif.hUserEvent );
                g_Notif.hUserEvent = NULL;
            }

            CloseHandle( g_Notif.hThread );
            g_Notif.hThread = NULL;
        }

        LeaveCriticalSection( &g_NotifyCS );
    }

    if ( hInst != NULL )
        FreeLibraryAndExitThread (hInst, 0);

    return 0;
}


//*************************************************************
//
//  NotifyEvents
//
//  Purpose:    Notifies registered events
//
//  Parameters: bMachine  -   Is this a machine policy change ?
//
//*************************************************************

void NotifyEvents( BOOL bMachine )
{
    GPNOTIFINFO *pNotifInfo = NULL;

    pNotifInfo = g_Notif.pNotifList;
    while ( pNotifInfo != NULL )
    {
        if ( pNotifInfo->bMachine == bMachine )
        {
            (void)SetEvent( pNotifInfo->hEvent ); 
            // multiple events are registered. move to the next event in case of errors. 
        }

        pNotifInfo = pNotifInfo->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpqry.cpp ===
//*************************************************************
//
//  Group Policy Support - Queries about the Policies
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

//*************************************************************
//
//  AddGPO()
//
//  Purpose:    Adds a GPO to the list
//
//  Parameters: lpGPOList           - list of GPOs
//              dwFlags          - Flags
//              bFound           - Was Gpo found ?
//              bAccessGranted   - Was access granted ?
//              bDisabled        - Is this Gpo disabled ?
//              dwOptions        - Options
//              dwVersion        - Version number
//              lpDSPath         - DS path
//              lpFileSysPath    - File system path
//              lpDisplayName    - Friendly display name
//              lpGPOName        - GPO name
//              lpExtensions     - Extensions relevant to this GPO
//              lpDSObject       - LSDOU
//              pSD              - Ptr to security descriptor
//              cbSDLen          - Length of security descriptor in bytes
//              GPOLink          - GPO link type
//              lpLink       - SDOU this GPO is linked to
//              lParam           - lParam
//              bFront           - Head or end of list
//              bBlock           - Block from above flag
//              bVerbose         - Verbose output flag
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddGPO (PGROUP_POLICY_OBJECT * lpGPOList,
             DWORD dwFlags, BOOL bFound, BOOL bAccessGranted, BOOL bDisabled, DWORD dwOptions,
             DWORD dwVersion, LPTSTR lpDSPath, LPTSTR lpFileSysPath,
             LPTSTR lpDisplayName, LPTSTR lpGPOName, LPTSTR lpExtensions,
             PSECURITY_DESCRIPTOR pSD, DWORD cbSDLen,
             GPO_LINK GPOLink, LPTSTR lpLink,
             LPARAM lParam, BOOL bFront, BOOL bBlock, BOOL bVerbose, BOOL bProcessGPO)
{
    PGROUP_POLICY_OBJECT lpNew, lpTemp;
    DWORD dwSize;
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Check if this item should be excluded from the list
    //

    if (bBlock) {
        if (!(dwOptions & GPO_FLAG_FORCE)) {
            DebugMsg((DM_VERBOSE, TEXT("AddGPO:  GPO %s will not be added to the list since the Block flag is set and this GPO is not in enforce mode."),
                     lpDisplayName));
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_SKIP_GPO);
                ev.AddArg(lpDisplayName); ev.Report();
            }

            if (dwFlags & GP_PLANMODE) {
                DebugMsg((DM_VERBOSE, TEXT("AddGPO:  GPO %s will will still be queried for since this is planning mode."),
                         lpDisplayName));
                bProcessGPO = FALSE;
            }
            else 
                return TRUE;
        }
    }


    //
    // Calculate the size of the new GPO item
    //

    dwSize = sizeof (GROUP_POLICY_OBJECT);

    if (lpDSPath) {
        dwSize += ((lstrlen(lpDSPath) + 1) * sizeof(TCHAR));
    }

    if (lpFileSysPath) {
        dwSize += ((lstrlen(lpFileSysPath) + 1) * sizeof(TCHAR));
    }

    if (lpDisplayName) {
        dwSize += ((lstrlen(lpDisplayName) + 1) * sizeof(TCHAR));
    }

    if (lpExtensions) {
        dwSize += ((lstrlen(lpExtensions) + 1) * sizeof(TCHAR));
    }

    if (lpLink) {
        dwSize += ((lstrlen(lpLink) + 1) * sizeof(TCHAR));
    }

    dwSize += sizeof(GPOPROCDATA);

    //
    // Allocate space for it
    //

    lpNew = (PGROUP_POLICY_OBJECT) LocalAlloc (LPTR, dwSize);

    if (!lpNew) {
        DebugMsg((DM_WARNING, TEXT("AddGPO: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }

    //
    // Fill in item
    //

    LPGPOPROCDATA lpGpoProcData;

    lpNew->lParam2 = (LPARAM)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT));
    lpGpoProcData = (LPGPOPROCDATA)lpNew->lParam2;
    lpGpoProcData->bProcessGPO = bProcessGPO;



    lpNew->dwOptions = dwOptions;
    lpNew->dwVersion = dwVersion;

    if (lpDSPath) {
        lpNew->lpDSPath = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
        hr = StringCchCopy (lpNew->lpDSPath, lstrlen(lpDSPath) + 1, lpDSPath);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpFileSysPath) {
        if (lpDSPath) {
            lpNew->lpFileSysPath = lpNew->lpDSPath + lstrlen (lpNew->lpDSPath) + 1;
        } else {
            lpNew->lpFileSysPath = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
        }

        hr = StringCchCopy (lpNew->lpFileSysPath, lstrlen(lpFileSysPath) + 1, lpFileSysPath);
        ASSERT(SUCCEEDED(hr));
    }


    if (lpDisplayName) {
        if (lpFileSysPath) {
            lpNew->lpDisplayName = lpNew->lpFileSysPath + lstrlen (lpNew->lpFileSysPath) + 1;
        } else {

            if (lpDSPath)
            {
                lpNew->lpDisplayName = lpNew->lpDSPath + lstrlen (lpNew->lpDSPath) + 1;
            }
            else
            {
                lpNew->lpDisplayName = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
            }
        }

        hr = StringCchCopy (lpNew->lpDisplayName, lstrlen(lpDisplayName) + 1, lpDisplayName);
        ASSERT(SUCCEEDED(hr));
    }


    if (lpGPOName) {
        DmAssert( lstrlen(lpGPOName) < 50 );
        hr = StringCchCopy (lpNew->szGPOName, 50, lpGPOName);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpExtensions) {
        if (lpDisplayName) {
            lpNew->lpExtensions = lpNew->lpDisplayName + lstrlen(lpNew->lpDisplayName) + 1;
        } else {

            if (lpFileSysPath) {
                lpNew->lpExtensions = lpNew->lpFileSysPath + lstrlen(lpNew->lpFileSysPath) + 1;
            } else {

                if (lpDSPath) {
                    lpNew->lpExtensions = lpNew->lpDSPath + lstrlen(lpNew->lpDSPath) + 1;
                } else {
                    lpNew->lpExtensions = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
                }

            }
        }

        hr = StringCchCopy (lpNew->lpExtensions, lstrlen(lpExtensions) + 1, lpExtensions);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpLink) {
        if (lpExtensions) {
            lpNew->lpLink = lpNew->lpExtensions + lstrlen(lpNew->lpExtensions) + 1;
        } else {
            if (lpDisplayName) {
                lpNew->lpLink = lpNew->lpDisplayName + lstrlen(lpNew->lpDisplayName) + 1;
            } else {

                if (lpFileSysPath) {
                    lpNew->lpLink = lpNew->lpFileSysPath + lstrlen(lpNew->lpFileSysPath) + 1;
                } else {

                    if (lpDSPath) {
                        lpNew->lpLink = lpNew->lpDSPath + lstrlen(lpNew->lpDSPath) + 1;
                    } else {
                        lpNew->lpLink = (LPTSTR)(((LPBYTE)lpNew) + sizeof(GROUP_POLICY_OBJECT) + sizeof(GPOPROCDATA));
                    }
                }
            }
        }

        hr = StringCchCopy (lpNew->lpLink, lstrlen(lpLink) + 1, lpLink);
        ASSERT(SUCCEEDED(hr));
    }

    lpNew->GPOLink = GPOLink;
    lpNew->lParam = lParam;

    //
    // Add item to link list
    //

    if (*lpGPOList) {

        if (bFront) {

            (*lpGPOList)->pPrev = lpNew;
            lpNew->pNext = *lpGPOList;
            *lpGPOList = lpNew;

        } else {

            lpTemp = *lpGPOList;

            while (lpTemp->pNext != NULL) {
                lpTemp = lpTemp->pNext;
            }

            lpTemp->pNext = lpNew;
            lpNew->pPrev = lpTemp;
        }

    } else {

        //
        // First item in the list
        //

        *lpGPOList = lpNew;
    }

    return TRUE;
}


//*************************************************************
//
//  AddGPOToRsopList
//
//  Purpose:    Adds GPO to list of GPOs being logged by Rsop
//
//  Parameters: ppGpContainerList - List of Gp Containers
//              dwFlags           - Flags
//              bFound            - Was Gpo found ?
//              bAccessGranted    - Was access granted ?
//              bDisabled         - Is this Gpo disabled ?
//              dwOptions         - Options
//              dwVersion         - Version number
//              lpDSPath          - DS path
//              lpFileSysPath     - File system path
//              lpDisplayName     - Friendly display name
//              lpGPOName         - GPO name
//              pSD               - Pointer to security descriptor
//              cbSDLen           - Length of security descriptor in bytes
//              bFilterAllowed    - Does GPO pass filter check
//              pwszFilterId      - WQL filter id
//              szSOM             - SOM
//              dwGPOOptions      - GPO options
//
//*************************************************************

BOOL AddGPOToRsopList(  LPGPCONTAINER *ppGpContainerList,
                        DWORD dwFlags,
                        BOOL bFound,
                        BOOL bAccessGranted,
                        BOOL bDisabled,
                        DWORD dwVersion,
                        LPTSTR lpDSPath,
                        LPTSTR lpFileSysPath,
                        LPTSTR lpDisplayName,
                        LPTSTR lpGPOName,
                        PSECURITY_DESCRIPTOR pSD,
                        DWORD cbSDLen,
                        BOOL bFilterAllowed,
                        WCHAR *pwszFilterId,
                        LPWSTR szSOM,
                        DWORD  dwOptions)
{
    // Fixing bug 568213
    XLastError xe;

    GPCONTAINER *pGpContainer = AllocGpContainer( dwFlags,
                                                  bFound,
                                                  bAccessGranted,
                                                  bDisabled,
                                                  dwVersion,
                                                  lpDSPath,
                                                  lpFileSysPath,
                                                  lpDisplayName,
                                                  lpGPOName,
                                                  pSD,
                                                  cbSDLen,
                                                  bFilterAllowed,
                                                  pwszFilterId,
                                                  szSOM,
                                                  dwOptions );
    if ( pGpContainer == NULL ) {
        DebugMsg((DM_VERBOSE, TEXT("AddGPO: Failed to allocate memory for Gp Container.")));
        return FALSE;
    }

    //
    // Prepend to GpContainer list
    //

    pGpContainer->pNext = *ppGpContainerList;
    *ppGpContainerList = pGpContainer;

    return TRUE;
}


//*************************************************************
//
//  AddLocalGPO()
//
//  Purpose:    Adds a local Gpo to the list of SOMs
//
//  Parameters: ppSOMList - List of SOMs
//
//*************************************************************

BOOL AddLocalGPO( LPSCOPEOFMGMT *ppSOMList )
{
    GPLINK *pGpLink = NULL;
    XLastError xe;
    SCOPEOFMGMT *pSOM = AllocSOM( L"Local" );

    if ( pSOM == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AddLocalGPO: Unable to allocate memory for SOM object")));
        return FALSE;
    }

    pSOM->dwType = GPLinkMachine;
    // Local GPO cannot be blocked from above


    pGpLink = AllocGpLink( L"LocalGPO", 0 );
    if ( pGpLink == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AddLocalGPO: Unable to allocate memory for GpLink object")));
        FreeSOM( pSOM );
        return FALSE;
    }

    pSOM->pGpLinkList  = pGpLink;
    pSOM->pNext = *ppSOMList;
    *ppSOMList = pSOM;

    return TRUE;
}



//*************************************************************
//
//  ProcessGPO()
//
//  Purpose:    Processes a specific GPO
//
//  Parameters: lpGPOPath     - Path to the GPO
//              lpDSPath      - DS object
//              dwFlags       - GetGPOList flags
//              HANDLE        - user or machine aceess token
//              lpGPOList     - List of GPOs
//              ppGpContainerList - List of Gp containers
//              dwGPOOptions  - Link options
//              bDeferred     - Should ldap query be deferred ?
//              bVerbose      - Verbose output
//              GPOLink       - GPO link type
//              lpDSObject    - SDOU this gpo is linked to
//              pld           - LDAP info
//              pLDAP         - LDAP api
//              pLdapMsg      - LDAP message
//              bBlock        - Block flag
//              bRsopToken    - Rsop security token
//              pGpoFilter    - Gpo filter
//              pLocator      - WMI interface class
//              bAddGPO       - In planning mode we want to get the gpodata even if
//                              the GPO is not going to be applied
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPO(LPTSTR lpGPOPath,
                DWORD dwFlags,
                HANDLE hToken,
                PGROUP_POLICY_OBJECT *lpGPOList,
                LPGPCONTAINER *ppGpContainerList,
                DWORD dwGPOOptions,
                BOOL bDeferred,
                BOOL bVerbose,
                GPO_LINK GPOLink,
                LPTSTR lpDSObject,
                PLDAP  pld,
                PLDAP_API pLDAP,
                PLDAPMessage pMessage,
                BOOL bBlock,
                PRSOPTOKEN pRsopToken,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator,
                BOOL bProcessGPO )
{
    ULONG ulResult, i;
    BOOL bResult = FALSE;
    BOOL bFound = FALSE;
    BOOL bOwnLdapMsg = FALSE;  // LDAP message owned by us (if true) or caller (if false)
    BOOL bAccessGranted;
    DWORD dwFunctionalityVersion = 2;
    DWORD dwVersion = 0;
    DWORD dwGPOFlags = 0;
    DWORD dwGPTVersion = 0;
    TCHAR szGPOName[80];
    TCHAR *pszGPTPath = 0;
    TCHAR *pszFriendlyName = 0;
    LPTSTR lpPath, lpEnd, lpTemp;
    TCHAR *pszExtensions = 0;
    TCHAR szLDAP[] = TEXT("LDAP://");
    INT iStrLen = lstrlen(szLDAP);
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    LDAPControl referralControl = { LDAP_SERVER_DOMAIN_SCOPE_OID_W, { 0, NULL}, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, &referralControl, NULL };
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    TCHAR szCommonName[] = TEXT("cn");
    TCHAR szDisplayName[] = TEXT("displayName");
    TCHAR szFileSysPath[] = TEXT("gPCFileSysPath");
    TCHAR szVersion[] = TEXT("versionNumber");
    TCHAR szFunctionalityVersion[] = GPO_FUNCTIONALITY_VERSION;
    TCHAR szFlags[] = TEXT("flags");
    TCHAR szWmiFilter[] = TEXT("gPCWQLFilter");

    PWSTR rgAttribs[12] = {szSDProperty,
                           szFileSysPath,
                           szCommonName,
                           szDisplayName,
                           szVersion,
                           szFunctionalityVersion,
                           szFlags,
                           GPO_MACHEXTENSION_NAMES,
                           GPO_USEREXTENSION_NAMES,
                           szObjectClass,
                           szWmiFilter,
                           NULL };
    LPTSTR *lpValues;
    PSECURITY_DESCRIPTOR pSD = NULL;     // Security Descriptor
    DWORD cbSDLen = 0;                   // Length of security descriptor in bytes
    BOOL bRsopLogging = (ppGpContainerList != NULL);
    BOOL bOldGpoVersion = FALSE;
    BOOL bDisabled = FALSE;
    BOOL bNoGpoData = FALSE;
    BOOL bFilterAllowed = FALSE;
    WCHAR *pwszFilterId = NULL;
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  ==============================")));

    //
    // Skip the starting LDAP provider if found
    //

    if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       lpGPOPath, iStrLen, szLDAP, iStrLen) == CSTR_EQUAL)
    {
        lpPath = lpGPOPath + iStrLen;
    }
    else
    {
        lpPath = lpGPOPath;
    }

    if ( bDeferred )
    {
        bResult = AddGPO (lpGPOList, dwFlags, TRUE, TRUE, FALSE, dwGPOOptions, 0, lpPath,
                          0, 0, 0, 0, 0, 0, GPOLink, lpDSObject, 0,
                          FALSE, bBlock, bVerbose, bProcessGPO);
        if (!bResult)
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to add GPO <%s> to the list."), lpPath));

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Deferring search for <%s>"), lpGPOPath));

        return bResult;
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Searching <%s>"), lpGPOPath));

    //
    // Check if this user or machine has access to the GPO, and if so,
    // should that GPO be applied to them.
    //

    if (!CheckGPOAccess (pld, pLDAP, hToken, pMessage, szSDProperty, dwFlags, &pSD, &cbSDLen, &bAccessGranted, pRsopToken)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckGPOAccess failed for <%s>"), lpGPOPath));
        CEvents ev(TRUE, EVENT_FAILED_ACCESS_CHECK);
        ev.AddArg(lpGPOPath); ev.AddArgWin32Error(GetLastError()); ev.Report();

        goto Exit;
    }

    if (!bAccessGranted) {
        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to the GPO and so will not be applied.")));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to the GPO and so will not be applied.")));
        }
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_NO_ACCESS);
            ev.AddArg(lpGPOPath); ev.Report();
        }

        bResult = TRUE; // GPO is not getting applied
        if ( !bRsopLogging ) {
            goto Exit;
        }
    } else {

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine has access to this GPO.")));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User has access to this GPO.")));
        }

    }

    
    // only if access is granted will we eval WQL filters
    if ( bAccessGranted ) {

        if (!FilterCheck(pld, pLDAP, pMessage, pRsopToken, szWmiFilter, pGpoFilter, pLocator, &bFilterAllowed, &pwszFilterId ) ) {
            xe = GetLastError();

            if (xe == WBEM_E_NOT_FOUND) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>. Filter not found"), lpGPOPath));
                CEvents ev(TRUE, EVENT_WMIFILTER_NOTFOUND);
                ev.AddArg(lpGPOPath); ev.Report();
                bFilterAllowed = FALSE;
            }
            else if (xe == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>. WMI service is disabled"), lpGPOPath));
                CEvents ev(TRUE, EVENT_WMISERVICE_DISABLED);
                ev.AddArg(lpGPOPath); ev.Report();
                bFilterAllowed = FALSE;
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  CheckFilterAcess failed for <%s>"), lpGPOPath));
                CEvents ev(TRUE, EVENT_FAILED_FILTER_CHECK);
                ev.AddArg(lpGPOPath); ev.Report();
                goto Exit;
            }
        }

        
        if ( (dwFlags & GP_PLANMODE) && (dwFlags & GPO_LIST_FLAG_MACHINE) && (dwFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE) ) {
            bFilterAllowed = TRUE;
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine WQL filter is assumed to be true.")));
        }
        else if ( (dwFlags & GP_PLANMODE) && ((dwFlags & GPO_LIST_FLAG_MACHINE) == 0) && (dwFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE) ) {
            bFilterAllowed = TRUE;
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User WQL filter is assumed to be true.")));
        }

        if (!bFilterAllowed)
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  The GPO does not pass the filter check and so will not be applied.")));

            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_FILTER_ALLOWED);
                ev.AddArg(lpGPOPath); ev.Report();
            }

            bResult = TRUE; // GPO is not getting applied
            if ( !bRsopLogging ) {
                goto Exit;
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO passes the filter check.")));
        }

    }
    else {
        bFilterAllowed = FALSE; 
    }

    //
    // Either user has access to this GPO, or Rsop logging is enabled so retrieve remaining GPO attributes
    //

    //
    // Check if this object is a GPO
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szObjectClass);

    if (lpValues) {

        bFound = FALSE;
        for ( i=0; lpValues[i] != NULL; i++) {
            if ( lstrcmp( lpValues[i], szDSClassGPO ) == 0 ) {
                bFound = TRUE;
                break;
            }
        }

        pLDAP->pfnldap_value_free (lpValues);

        if ( !bFound ) {
            xe = ERROR_DS_MISSING_REQUIRED_ATT;
            // seems like objectclass=dsgpo is required attr
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Object <%s> is not a GPO"), lpGPOPath ));
            CEvents ev(TRUE, EVENT_INCORRECT_CLASS);
            ev.AddArg(lpGPOPath); ev.AddArg(szDSClassGPO); ev.Report();

            goto Exit;
        }

    }

    //
    // In the results, get the values that match the gPCFunctionalityVersion attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szFunctionalityVersion);

    if (lpValues) {

        dwFunctionalityVersion = StringToInt (*lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found functionality version of:  %d"),
                 dwFunctionalityVersion));
        pLDAP->pfnldap_value_free (lpValues);

    } else {

        ulResult = pLDAP->pfnLdapGetLastError();

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to <%s>"), lpGPOPath));
            } else {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to <%s>"), lpGPOPath));
            }
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_ACCESS);
                ev.AddArg(lpGPOPath); ev.Report();
            }
            bResult = TRUE;

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a functionality version number, error = 0x%x."), lpGPOPath, ulResult));
            CEvents ev(TRUE, EVENT_CORRUPT_GPO_FUNCVERSION);
            ev.AddArg(lpGPOPath); ev.Report();
        }
        goto Exit;
    }


    //
    // In the results, get the values that match the gPCFileSystemPath attribute
    //

    lpValues = pLDAP->pfnldap_get_values (pld, pMessage, szFileSysPath);

    if (lpValues) {
        // Fixing bug 568261
        
        DWORD dwGPTPathLength =  lstrlen(*lpValues) + MAX(lstrlen(TEXT("\\Machine")), lstrlen(TEXT("\\gpt.ini"))) + 1; //Take the MAX of MACHINE and gpt.ini

        pszGPTPath = (LPWSTR) LocalAlloc( LPTR, (dwGPTPathLength) * sizeof(TCHAR) );

        if ( pszGPTPath == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        hr = StringCchCopy (pszGPTPath, dwGPTPathLength, *lpValues);
        ASSERT(SUCCEEDED(hr));

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found file system path of:  <%s>"), pszGPTPath));
        pLDAP->pfnldap_value_free (lpValues);

        lpEnd = CheckSlash (pszGPTPath);

        //
        // Get the GPT version number
        //

        hr = StringCchCopy (lpEnd, dwGPTPathLength - (lpEnd - pszGPTPath), TEXT("gpt.ini"));
        ASSERT(SUCCEEDED(hr));

        //
        // Skip access to sysvol if AGP or filtercheck fails
        //

        if (bAccessGranted && bFilterAllowed) {
            WIN32_FILE_ATTRIBUTE_DATA fad;
    
            //
            // Check for the existence of the gpt.ini file.
            //
    
            if (GetFileAttributesEx(pszGPTPath, GetFileExInfoStandard, &fad)) {
                dwGPTVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, pszGPTPath);
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Couldn't find the group policy template file <%s>, error = 0x%x."), pszGPTPath, GetLastError()));
                CEvents ev(TRUE, EVENT_GPT_NOTACCESSIBLE);
                ev.AddArg(lpGPOPath); ev.AddArg(pszGPTPath); ev.AddArgWin32Error(GetLastError()); ev.Report();
                goto Exit;
            }
    
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Sysvol access skipped because GPO is not getting applied.")));
            dwGPTVersion = 0xffffffff;
        }
    
        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            hr = StringCchCopy (lpEnd, dwGPTPathLength - (lpEnd - pszGPTPath), TEXT("Machine"));
        } else {
            hr = StringCchCopy (lpEnd, dwGPTPathLength - (lpEnd - pszGPTPath), TEXT("User"));
        }
        ASSERT(SUCCEEDED(hr));

    } else {
        ulResult = pLDAP->pfnLdapGetLastError();

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            if (dwFlags & GPO_LIST_FLAG_MACHINE) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Machine does not have access to <%s>"), lpGPOPath));
            } else {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  User does not have access to <%s>"), lpGPOPath));
            }
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_NO_ACCESS);
                ev.AddArg(lpGPOPath); ev.Report();
            }
            bResult = TRUE;

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a file system path, error = 0x%x."), lpGPOPath, ulResult));
            CEvents ev(TRUE, EVENT_CORRUPT_GPO_FSPATH);
            ev.AddArg(lpGPOPath); ev.Report();
        }
        goto Exit;
    }


    //
    // In the results, get the values that match the common name attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szCommonName);

    if (lpValues && ValidateGuid(*lpValues)) {

        DmAssert( lstrlen(*lpValues) < 80 );

        hr = StringCchCopy (szGPOName, ARRAYSIZE(szGPOName), *lpValues);

        if (FAILED(hr)) {
            xe = ERROR_INSUFFICIENT_BUFFER;
            CEvents ev(TRUE, EVENT_CORRUPT_GPO_COMMONNAME);
            ev.AddArg(lpGPOPath); ev.Report();
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found common name of:  <%s>"), szGPOName));
        pLDAP->pfnldap_value_free (lpValues);

    } else {
        ulResult = pLDAP->pfnLdapGetLastError();
        xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a common name (a GUID)."), lpGPOPath));
        CEvents ev(TRUE, EVENT_CORRUPT_GPO_COMMONNAME);
        ev.AddArg(lpGPOPath); ev.Report();
        goto Exit;
    }


    //
    // In the results, get the values that match the display name attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szDisplayName);

    if (lpValues) {
        
        DWORD dwFriendlyLength = lstrlen(*lpValues)+1;
        pszFriendlyName = (LPWSTR) LocalAlloc( LPTR, (dwFriendlyLength) * sizeof(TCHAR) );
        if ( pszFriendlyName == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        hr = StringCchCopy (pszFriendlyName, dwFriendlyLength, *lpValues);
        ASSERT(SUCCEEDED(hr));
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found display name of:  <%s>"), pszFriendlyName));
        pLDAP->pfnldap_value_free (lpValues);


    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No display name for this object.")));

        pszFriendlyName = (LPWSTR) LocalAlloc( LPTR, 2 * sizeof(TCHAR) );
        if ( pszFriendlyName == 0) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
            goto Exit;
        }

        pszFriendlyName[0] = TEXT('\0');
    }


    //
    // In the results, get the values that match the version attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szVersion);

    if (lpValues) {

        dwVersion = StringToInt (*lpValues);

        if (dwFlags & GPO_LIST_FLAG_MACHINE) {
            dwVersion = MAKELONG(LOWORD(dwVersion), LOWORD(dwGPTVersion));
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found machine version of:  GPC is %d, GPT is %d"), LOWORD(dwVersion), HIWORD(dwVersion)));

        } else {
            dwVersion = MAKELONG(HIWORD(dwVersion), HIWORD(dwGPTVersion));
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found user version of:  GPC is %d, GPT is %d"), LOWORD(dwVersion), HIWORD(dwVersion)));
        }

        pLDAP->pfnldap_value_free (lpValues);

    } else {
        // start treating this as an error.
        xe = pLDAP->pfnLdapMapErrorToWin32(pLDAP->pfnLdapGetLastError());
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  GPO %s does not have a version number."), lpGPOPath));
        CEvents ev(TRUE, EVENT_NODSVERSION);
        ev.AddArg(lpGPOPath); ev.AddArgLdapError(pLDAP->pfnLdapGetLastError()); ev.Report();
        goto Exit;
    }


    //
    // In the results, get the values that match the flags attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage, szFlags);

    if (lpValues) {

        dwGPOFlags = StringToInt (*lpValues);
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found flags of:  %d"), dwGPOFlags));
        pLDAP->pfnldap_value_free (lpValues);


    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No flags for this object.")));
    }


    //
    // In the results, get the values that match the extension names attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pMessage,
                                         (dwFlags & GPO_LIST_FLAG_MACHINE) ? GPO_MACHEXTENSION_NAMES
                                                                           : GPO_USEREXTENSION_NAMES );
    if (lpValues) {

        if ( lstrcmpi( *lpValues, TEXT(" ") ) == 0 ) {

            //
            // A blank char is also a null property case, because Adsi doesn't commit null strings
            //
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No client-side extensions for this object.")));

        } else {
            DWORD dwExtLength = lstrlen(*lpValues)+1;
            pszExtensions = (LPWSTR) LocalAlloc( LPTR, (dwExtLength) * sizeof(TCHAR) );
            if ( pszExtensions == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Unable to allocate memory")));
                pLDAP->pfnldap_value_free (lpValues);
                goto Exit;

            }

            hr = StringCchCopy( pszExtensions, dwExtLength, *lpValues );
            ASSERT(SUCCEEDED(hr));

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  Found extensions:  %s"), pszExtensions));
        }

        pLDAP->pfnldap_value_free (lpValues);

    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  No client-side extensions for this object.")));
    }


    //
    // Log which GPO we found
    //

    if (bVerbose) {
        CEvents ev(FALSE, EVENT_FOUND_GPO);
        ev.AddArg(pszFriendlyName); ev.AddArg(szGPOName); ev.Report();
    }


    //
    // Check the functionalty version number
    //

    if (dwFunctionalityVersion < 2) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s was created by an old version of the Group Policy Editor.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_TOO_OLD);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bOldGpoVersion = TRUE;
    }


    //
    // Check if the GPO is disabled
    //

    if (((dwFlags & GPO_LIST_FLAG_MACHINE) &&
         (dwGPOFlags & GPO_OPTION_DISABLE_MACHINE)) ||
         (!(dwFlags & GPO_LIST_FLAG_MACHINE) &&
         (dwGPOFlags & GPO_OPTION_DISABLE_USER))) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s is disabled.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_DISABLED);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bDisabled = TRUE;
    }

    //
    // Check if the version number is 0, if so there isn't any data
    // in the GPO and we can skip it
    //

    if (dwVersion == 0) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  GPO %s doesn't contain any data since the version number is 0.  It will be skipped."), pszFriendlyName));
        if (bVerbose) {
            CEvents ev(FALSE, EVENT_GPO_NO_DATA);
            ev.AddArg(pszFriendlyName); ev.Report();
        }
        bNoGpoData = TRUE;
    }

    //
    // Put the correct container name on the front of the LDAP path
    //

    DWORD dwTempLength = lstrlen(lpGPOPath) + 20;
    lpTemp = (LPWSTR) LocalAlloc (LPTR, (dwTempLength) * sizeof(TCHAR));

    if (!lpTemp) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to allocate memory with %d"), GetLastError()));
        CEvents ev(TRUE, EVENT_OUT_OF_MEMORY);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    if (dwFlags & GPO_LIST_FLAG_MACHINE) {
        hr = StringCchCopy (lpTemp, dwTempLength, TEXT("LDAP://CN=Machine,"));
    } else {
        hr = StringCchCopy (lpTemp, dwTempLength, TEXT("LDAP://CN=User,"));
    }
    ASSERT(SUCCEEDED(hr));

    hr = StringCchCat (lpTemp, dwTempLength, lpPath);
    ASSERT(SUCCEEDED(hr));

    //
    // Add this GPO to the list
    //

    if ( bRsopLogging ) {
        bResult = AddGPOToRsopList( ppGpContainerList,
                                    dwFlags,
                                    TRUE,
                                    bAccessGranted,
                                    bDisabled,
                                    dwVersion,
                                    lpTemp,
                                    pszGPTPath,
                                    pszFriendlyName,
                                    szGPOName,
                                    pSD,
                                    cbSDLen,
                                    bFilterAllowed,
                                    pwszFilterId,
                                    lpDSObject,
                                    dwGPOOptions );
        if (!bResult) {
            xe = GetLastError();
            LocalFree(lpTemp);
            goto Exit;
        }
    }

    if (  bProcessGPO && bAccessGranted && !bOldGpoVersion && !bDisabled && !bNoGpoData && bFilterAllowed)
    {
        bResult = AddGPO (lpGPOList, dwFlags, TRUE, bAccessGranted, bDisabled,
                          dwGPOOptions, dwVersion, lpTemp,
                          pszGPTPath, pszFriendlyName, szGPOName, pszExtensions, pSD, cbSDLen, GPOLink, lpDSObject, 0,
                          FALSE, bBlock, bVerbose, bProcessGPO);
    }

    if (!bResult) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPO:  Failed to add GPO <%s> to the list."), pszFriendlyName));
    }

    LocalFree (lpTemp);

Exit:

    if ( pSD )
        LocalFree( pSD );

    if ( pszGPTPath )
        LocalFree( pszGPTPath );

    if ( pszFriendlyName )
        LocalFree( pszFriendlyName );

    if ( pszExtensions )
        LocalFree( pszExtensions );

    if ( pwszFilterId )
        LocalFree( pwszFilterId );

    if (pMessage && bOwnLdapMsg ) {
        pLDAP->pfnldap_msgfree (pMessage);
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPO:  ==============================")));

    return bResult;
}


//*************************************************************
//
//  SearchDSObject()
//
//  Purpose:    Searches the specified DS object for GPOs and
//              if found, adds them to the list.
//
//  Parameters: lpDSObject          - DS object to search
//              dwFlags             - GetGPOList & GP_PLANMODE flags
//              pGPOForcedList      - List of forced GPOs
//              pGPONonForcedList   - List of non-forced GPOs
//              ppSOMList           - List of LSDOUs
//              ppGpContainerList   - List of Gp Containers
//              bVerbose            - Verbose output
//              GPOLink             - GPO link type
//              pld                 - LDAP info
//              pLDAP               - LDAP api
//              bBlock              - Pointer to the block flag
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SearchDSObject (LPTSTR lpDSObject, DWORD dwFlags, HANDLE hToken, PGROUP_POLICY_OBJECT *pGPOForcedList,
                     PGROUP_POLICY_OBJECT *pGPONonForcedList,
                     LPSCOPEOFMGMT *ppSOMList, LPGPCONTAINER *ppGpContainerList,
                     BOOL bVerbose,
                     GPO_LINK GPOLink, PLDAP  pld, PLDAP_API pLDAP, PLDAPMessage pLDAPMsg,BOOL *bBlock, PRSOPTOKEN pRsopToken )
{
    PGROUP_POLICY_OBJECT pForced = NULL, pNonForced = NULL, lpGPO;
    LPTSTR *lpValues;
    ULONG ulResult;
    BOOL bResult = FALSE;
    BOOL bOwnLdapMsg = FALSE;  // LDAP message owned by us (if true) or caller (if false)
    DWORD dwGPOOptions, dwOptions = 0;
    LPTSTR lpTemp, lpList, lpDSClass;
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, NULL };
    
    TCHAR szGPLink[] = TEXT("gPLink");
    TCHAR szGPOPath[512];
    TCHAR szGPOOptions[12];
    TCHAR szGPOptions[] = TEXT("gPOptions");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    ULONG i = 0;
    LPTSTR lpFullDSObject = NULL;
    BOOL bFound = FALSE;
    LPTSTR lpAttr[] = { szGPLink,
                        szGPOptions,
//                        szObjectClass, not needed
                        szSDProperty,
                        NULL
                       };
    SCOPEOFMGMT *pSOM = NULL;
    BOOL bRsopLogging = (ppSOMList != NULL);
    BOOL bAllGPOs = (dwFlags & FLAG_NO_GPO_FILTER) && (dwFlags & GP_PLANMODE);
    XLastError xe;
    HRESULT hr = S_OK;
    
    //
    // Setup the BER encoding for the SD
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);


    if ( !pRsopToken )
    {
        //
        // if it is not planning mode, don't get the SD
        // 

        lpAttr[2] = NULL;
        ServerControls[0] = NULL;
    }

    
    //
    // Search for the object
    //

    DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Searching <%s>"), lpDSObject));
    if (bVerbose) {
        CEvents ev(FALSE, EVENT_SEARCHING);
        ev.AddArg(lpDSObject); ev.Report();
    }

    if ( bRsopLogging )
    {
        pSOM = AllocSOM( lpDSObject );
        if ( !pSOM ) {
             xe = GetLastError();
             DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Unable to allocate memory for SOM object.  Leaving. ")));
             goto Exit;
        }
        pSOM->dwType = GPOLink;
        pSOM->bBlocked = *bBlock;

    }

    if ( pLDAPMsg == NULL ) {

        bOwnLdapMsg = TRUE;

        ulResult = pLDAP->pfnldap_search_ext_s(pld, lpDSObject, LDAP_SCOPE_BASE,
                                               szDSClassAny, lpAttr, FALSE,
                                               (PLDAPControl*)ServerControls,
                                               NULL, NULL, 0, &pLDAPMsg);

        if (ulResult != LDAP_SUCCESS) {

            if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  No GPO(s) for this object.")));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_NO_GPOS); ev.AddArg(lpDSObject); ev.Report();
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_NO_SUCH_OBJECT) {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Object not found in DS (this is ok).  Leaving. ")));
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_NO_DS_OBJECT);
                    ev.AddArg(lpDSObject); ev.Report();
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
               xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
               DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Too many linked GPOs in search.") ));
               CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

            } else {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Failed to find DS object <%s> due to error %d."),
                         lpDSObject, ulResult));
                CEvents ev(TRUE, EVENT_GPLINK_NOT_FOUND);
                ev.AddArg(lpDSObject); ev.AddArgLdapError(ulResult); ev.Report();
            }

            goto Exit;

        }
    }

    if ( bRsopLogging && pRsopToken && !bAllGPOs )
    {
        //
        // In Rsop planning mode, check access to OU
        //

        BOOL bAccessGranted = FALSE;
        BOOL bOk;

        bOk = CheckOUAccess(pLDAP,
                            pld,
                            pLDAPMsg,
                            pRsopToken,
                            &bAccessGranted );

        if ( !bOk )
        {
            xe = GetLastError();
            goto Exit;
        }

        if ( !bAccessGranted )
        {
            //
            // no access for the user on the OU. Exit
            //

            DebugMsg((DM_VERBOSE, TEXT("SearchDSObject: Access denied in planning mode to SOM <%s>"), lpDSObject));

            if (pLDAPMsg && bOwnLdapMsg )
            {
                pLDAP->pfnldap_msgfree (pLDAPMsg);
                pLDAPMsg = 0;
            }

            CEvents ev(TRUE, EVENT_OU_ACCESSDENIED);
            ev.AddArg(lpDSObject); ev.Report();

            goto Exit;
        }
    }

    //
    // In the results, get the values that match the gPOptions attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pLDAPMsg, szGPOptions);

    if (lpValues && *lpValues) {
        dwOptions = StringToInt (*lpValues);
        pLDAP->pfnldap_value_free (lpValues);
    }


    //
    // In the results, get the values that match the gPLink attribute
    //

    lpValues = pLDAP->pfnldap_get_values(pld, pLDAPMsg, szGPLink);


    if (lpValues && *lpValues) {

        lpList = *lpValues;

        DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  Found GPO(s):  <%s>"), lpList));
        DWORD dwFullLength = lstrlen(lpDSObject) + 8;
        lpFullDSObject = (LPWSTR) LocalAlloc (LPTR, (dwFullLength) * sizeof(TCHAR));

        if (!lpFullDSObject) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Failed to allocate memory for full DS Object path name with %d"),
                     GetLastError()));
            pLDAP->pfnldap_value_free (lpValues);
            goto Exit;
        }

        hr = StringCchCopy (lpFullDSObject, dwFullLength, TEXT("LDAP://"));
        ASSERT(SUCCEEDED(hr));
        hr = StringCchCat (lpFullDSObject, dwFullLength, lpDSObject);
        ASSERT(SUCCEEDED(hr));

        while (*lpList) {
            DWORD   dwLenRemaining;   

            //
            // Pull off the GPO ldap path
            //

            lpTemp = szGPOPath;
            dwLenRemaining = (ARRAYSIZE(szGPOPath))-1; // (len of array) - (end of string character)
            dwGPOOptions = 0;

            while (*lpList && (*lpList != TEXT('['))) {
                lpList++;
            }

            if (!(*lpList)) {
                break;
            }

            lpList++;

            while ((dwLenRemaining) && *lpList && (*lpList != TEXT(';'))) {
                *lpTemp++ = *lpList++;
                dwLenRemaining--;
            }

            if (*lpList != TEXT(';')) {
                break;
            }

            *lpTemp = TEXT('\0');


            lpList++;

            lpTemp = szGPOOptions;
            dwLenRemaining = (ARRAYSIZE(szGPOOptions))-1; // (len of array) - (end of string character)
            *lpTemp = TEXT('\0');

            while ((dwLenRemaining) && *lpList && (*lpList != TEXT(']'))) {
                *lpTemp++ = *lpList++;
                dwLenRemaining--;
            }

            if (*lpList != TEXT(']')) {
                break;
            }


            *lpTemp = TEXT('\0');
            lpList++;

            dwGPOOptions = StringToInt (szGPOOptions);

            if ( bRsopLogging ) {

                GPLINK *pGpLink = AllocGpLink( szGPOPath, dwGPOOptions );
                if ( pGpLink == NULL ) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("SearchDSObject:  Unable to allocate memory for GpLink object.  Leaving. ")));
                    goto Exit;
                }

                //
                // Append GpLink to end of SOM list
                //

                if ( pSOM->pGpLinkList == NULL ) {
                    pSOM->pGpLinkList = pGpLink;
                } else {

                    GPLINK *pTrailPtr = NULL;
                    GPLINK *pCurPtr = pSOM->pGpLinkList;

                    while ( pCurPtr != NULL ) {
                        pTrailPtr = pCurPtr;
                        pCurPtr = pCurPtr->pNext;
                    }

                    pTrailPtr->pNext = pGpLink;
                }
            }


            //
            // Check if this link is disabled
            //

            BOOL    bProcessGPO = TRUE;

            if ( ( dwGPOOptions & GPO_FLAG_DISABLE ) && !bAllGPOs )
            {

                DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  The link to GPO %s is disabled.  It will be skipped for processing."), szGPOPath));
                if (bVerbose)
                {
                    CEvents ev(FALSE, EVENT_GPO_LINK_DISABLED);
                    ev.AddArg(szGPOPath); ev.Report();
                }

                bProcessGPO = FALSE;
            }
                
            if (bProcessGPO || (dwFlags & GP_PLANMODE)) {

                
                if (!bProcessGPO) {
                    DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  The link to GPO %s is disabled. GPO is still being queried. Planning mode."), szGPOPath));
                }

                if ( !ProcessGPO(   szGPOPath,
                                        dwFlags,
                                        hToken,
                                        (dwGPOOptions & GPO_FLAG_FORCE) ? &pForced : &pNonForced,
                                        ppGpContainerList,
                                        dwGPOOptions,
                                        TRUE,
                                        bVerbose,
                                        GPOLink,
                                        lpFullDSObject,
                                        pld,
                                        pLDAP,
                                        0,
                                        *bBlock,
                                        pRsopToken,
                                        0,
                                        0,
                                        bProcessGPO ) )
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("SearchDSObject:  ProcessGPO failed.")));
                    pLDAP->pfnldap_value_free (lpValues);
                    goto Exit;
                }
            }
        }

        pLDAP->pfnldap_value_free (lpValues);


        //
        // Set the block flag now if requested.  This way OU's, domains, etc
        // higher in the namespace will have GPOs removed if appropriate
        //

        if (dwOptions & GPC_BLOCK_POLICY) {
            *bBlock = TRUE;

            if ( bRsopLogging )
                pSOM->bBlocking = TRUE;

            DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  <%s> has the Block From Above attribute set"), lpDSObject));
            if (bVerbose) {
                CEvents ev(FALSE, EVENT_BLOCK_ENABLED);
                ev.AddArg(lpDSObject); ev.Report();
            }
        }


    } else {
        DebugMsg((DM_VERBOSE, TEXT("SearchDSObject:  No GPO(s) for this object.")));
        if (bVerbose) {
             CEvents ev(FALSE, EVENT_NO_GPOS); ev.AddArg(lpDSObject); ev.Report();
        }
    }

    //
    // Merge the temp and real lists together
    // First the non-forced lists
    //

    if (pNonForced) {

        lpGPO = pNonForced;

        while (lpGPO->pNext) {
            lpGPO = lpGPO->pNext;
        }

        lpGPO->pNext = *pGPONonForcedList;
        if (*pGPONonForcedList) {
            (*pGPONonForcedList)->pPrev = lpGPO;
        }

        *pGPONonForcedList = pNonForced;
    }

    //
    // Now the forced lists
    //

    if (pForced) {

        lpGPO = *pGPOForcedList;

        if (lpGPO) {
            while (lpGPO->pNext) {
                lpGPO = lpGPO->pNext;
            }

            lpGPO->pNext = pForced;
            pForced->pPrev = lpGPO;

        } else {
            *pGPOForcedList = pForced;
        }
    }

    bResult = TRUE;
    
Exit:
    if ( !bResult && pSOM != NULL ) {
        FreeSOM( pSOM );
    }
    else {
        if ( bResult && bRsopLogging ) {

            //
            // Insert SOM at the beginning
            //

            pSOM->pNext = *ppSOMList;
            *ppSOMList = pSOM;
        }
    }

    if (lpFullDSObject) {
        LocalFree (lpFullDSObject);
    }

    if (pLDAPMsg && bOwnLdapMsg ) {
        pLDAP->pfnldap_msgfree (pLDAPMsg);
    }

    return bResult;
}

//*************************************************************
//
//  AllocDnEntry()
//
//  Purpose:    Allocates a new struct for dn entry
//
//
//  Parameters: pwszDN  - Distinguished name
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

DNENTRY * AllocDnEntry( LPTSTR pwszDN )
{
    DNENTRY *pDnEntry = (DNENTRY *) LocalAlloc (LPTR, sizeof(DNENTRY));
    XLastError xe;
    HRESULT hr = S_OK;

    if ( pDnEntry == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocDnEntry: Failed to alloc pDnEntry with 0x%x."),
                  GetLastError()));
        return NULL;
    }

    pDnEntry->pwszDN = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pwszDN) + 1) * sizeof(TCHAR) );

    if ( pDnEntry->pwszDN == NULL ) {
        xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("AllocDnEntry: Failed to alloc pwszDN with 0x%x."),
                 GetLastError()));
       LocalFree( pDnEntry );
       return NULL;
    }

    hr = StringCchCopy( pDnEntry->pwszDN, lstrlen(pwszDN) + 1, pwszDN );
    ASSERT(SUCCEEDED(hr));

    return pDnEntry;
}


//*************************************************************
//
//  FreeDnEntry()
//
//  Purpose:    Frees dn entry struct
//
//*************************************************************

void FreeDnEntry( DNENTRY *pDnEntry )
{
    if ( pDnEntry ) {
        if ( pDnEntry->pwszDN )
            LocalFree( pDnEntry->pwszDN );

        LocalFree( pDnEntry );
    }
}

//*************************************************************
//
//  AllocLdapQuery()
//
//  Purpose:    Allocates a new struct for ldap query
//
//
//  Parameters: pwszDomain  - Domain of Gpo
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

LDAPQUERY * AllocLdapQuery( LPTSTR pwszDomain )
{
    const INIT_ALLOC_SIZE = 1000;
    LDAPQUERY *pQuery = (LDAPQUERY *) LocalAlloc (LPTR, sizeof(LDAPQUERY));
    XLastError xe;
    HRESULT hr = S_OK;

    if ( pQuery == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pQuery with 0x%x."),
                  GetLastError()));
        return NULL;
    }

    pQuery->pwszDomain = (LPTSTR) LocalAlloc (LPTR, (lstrlen(pwszDomain) + 1) * sizeof(TCHAR) );

    if ( pQuery->pwszDomain == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pwszDomain with 0x%x."),
                  GetLastError()));
        LocalFree( pQuery );
        return NULL;
    }

    pQuery->pwszFilter = (LPTSTR) LocalAlloc (LPTR, INIT_ALLOC_SIZE );

    if ( pQuery->pwszFilter == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocLdapQuery: Failed to alloc pwszFilter with 0x%x."),
                  GetLastError()));
        LocalFree( pQuery->pwszDomain );
        LocalFree( pQuery );
        return NULL;
    }

    hr = StringCchCopy( pQuery->pwszDomain, lstrlen(pwszDomain) + 1, pwszDomain );
    ASSERT(SUCCEEDED(hr));

    hr = StringCchCopy( pQuery->pwszFilter, INIT_ALLOC_SIZE, L"(|)" );
    ASSERT(SUCCEEDED(hr));

    pQuery->cbLen = 8;           // 8 = (lstrlen(L"(|)") + 1) * sizeof(TCHAR)
    pQuery->cbAllocLen = INIT_ALLOC_SIZE;

    return pQuery;
}


//*************************************************************
//
//  FreeLdapQuery()
//
//  Purpose:    Frees ldap query struct
//
//*************************************************************

void FreeLdapQuery( PLDAP_API pLDAP, LDAPQUERY *pQuery )
{
    DNENTRY *pDnEntry = NULL;

    if ( pQuery ) {

        if ( pQuery->pwszDomain )
            LocalFree( pQuery->pwszDomain );

        if ( pQuery->pwszFilter )
            LocalFree( pQuery->pwszFilter );

        if ( pQuery->pMessage )
            pLDAP->pfnldap_msgfree( pQuery->pMessage );

        if ( pQuery->pLdapHandle && pQuery->bOwnLdapHandle )
            pLDAP->pfnldap_unbind( pQuery->pLdapHandle );

        pDnEntry = pQuery->pDnEntry;

        while ( pDnEntry ) {
            DNENTRY *pTemp = pDnEntry->pNext;
            FreeDnEntry( pDnEntry );
            pDnEntry = pTemp;
        }

        LocalFree( pQuery );

    }
}


//*************************************************************
//
//  MatchDnWithDeferredItems()
//
//  Purpose:    Matches the dns from ldap query with the deferred items
//
//  Parameters: pLDAP         - LDAP function table pointer
//              ppLdapQuery   - LDAP query list
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL MatchDnWithDeferredItems( PLDAP_API pLDAP, LDAPQUERY *pLdapQuery, BOOL bOUProcessing )
{
    PLDAPMessage pMsg = pLDAP->pfnldap_first_entry( pLdapQuery->pLdapHandle, pLdapQuery->pMessage );

    while ( pMsg ) {

        WCHAR *pwszDN = pLDAP->pfnldap_get_dn( pLdapQuery->pLdapHandle, pMsg ); // fixing bug 568263
 
        if (!pwszDN)
        {
            return FALSE;
        }

        DNENTRY *pCurPtr = pLdapQuery->pDnEntry;

        while ( pCurPtr ) {

            INT iResult = CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                                          pwszDN, -1, pCurPtr->pwszDN, -1 );
            if ( iResult == CSTR_EQUAL ) {

                //
                // Store the pointer to ldap message so that it can be used
                // later to retrieve necessary attributes.
                //
                if ( bOUProcessing )
                    pCurPtr->pDeferredOU->pOUMsg = pMsg;
                else {
                    LPGPOPROCDATA lpGpoProcData = (LPGPOPROCDATA)pCurPtr->pDeferredGPO->lParam2;

                    pCurPtr->pDeferredGPO->lParam = (LPARAM) pMsg;
                    lpGpoProcData->pLdapHandle = pLdapQuery->pLdapHandle;
                }

                pCurPtr = pCurPtr->pNext;

            } else if ( iResult == CSTR_LESS_THAN ) {

                //
                // Since dns are in ascending order,
                // we are done.
                //

                break;

            } else {

                //
                // Advance down the list
                //

                pCurPtr = pCurPtr->pNext;

            } // final else

        }   // while pcurptr

        pLDAP->pfnldap_memfree( pwszDN );

        pMsg = pLDAP->pfnldap_next_entry( pLdapQuery->pLdapHandle, pMsg );

    }   // while pmsg

    return TRUE;
}

LPWSTR DsQuoteSearchFilter( LPCWSTR );

//*************************************************************
//
//  AddDnToFilter()
//
//  Purpose:    ORs in the new dn to the ldap filter
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pGPO              - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDnToFilter( LDAPQUERY *pLdapQuery, LPTSTR pwszDN )
{
    const  DN_SIZE = 20;      // 20 = # chars in "(dis..=)"
    BOOL   bSuccess = FALSE;
    LPWSTR szQuotedDN;
    HRESULT hr = S_OK;

    szQuotedDN = DsQuoteSearchFilter( pwszDN );

    if ( ! szQuotedDN )
    {
        DebugMsg((DM_WARNING, TEXT("GetGPOInfo: DsQuoteSearchFilter failed with = <%d>"), GetLastError() ));
        goto AddDnToFilter_ExitAndCleanup;
    }

    DWORD cbNew = (lstrlen(szQuotedDN) + DN_SIZE) * sizeof(TCHAR); // + 1 is not needed because \0 is already part of filter string

    DWORD cbSizeRequired = pLdapQuery->cbLen + cbNew;

    if ( cbSizeRequired >= pLdapQuery->cbAllocLen ) {

        //
        // Need to grow buffer because of overflow
        //

        LPTSTR pwszNewFilter = (LPTSTR) LocalAlloc (LPTR, cbSizeRequired * 2);

        if ( pwszNewFilter == NULL ) {
            DebugMsg((DM_WARNING, TEXT("AddDnToFilter: Unable to allocate new filter string") ));
            goto AddDnToFilter_ExitAndCleanup;
        }

        hr = StringCchCopy( pwszNewFilter, cbSizeRequired, pLdapQuery->pwszFilter );
        ASSERT(SUCCEEDED(hr));

        LocalFree( pLdapQuery->pwszFilter );
        pLdapQuery->pwszFilter = pwszNewFilter;

        pLdapQuery->cbAllocLen = cbSizeRequired * 2;
    }

    DmAssert( cbSizeRequired < pLdapQuery->cbAllocLen );

    //
    // Overwrite last ")" and then append the new dn name term
    //

    hr = StringCchCopy( &pLdapQuery->pwszFilter[pLdapQuery->cbLen/sizeof(WCHAR) - 2], (pLdapQuery->cbAllocLen - pLdapQuery->cbLen)/sizeof(WCHAR) + 2, L"(distinguishedName=" );
    ASSERT(SUCCEEDED(hr));
    hr = StringCchCat( pLdapQuery->pwszFilter, pLdapQuery->cbAllocLen/sizeof(WCHAR), szQuotedDN );
    ASSERT(SUCCEEDED(hr));
    hr = StringCchCat( pLdapQuery->pwszFilter, pLdapQuery->cbAllocLen/sizeof(WCHAR), L"))" );
    ASSERT(SUCCEEDED(hr));

    pLdapQuery->cbLen += cbNew;

    bSuccess = TRUE;

 AddDnToFilter_ExitAndCleanup:

    if ( szQuotedDN )
    {
        LocalFree( szQuotedDN );
    }

    return bSuccess;
}

//*************************************************************
//
//  InsertDN()
//
//  Purpose:    Adds a distinguished name entry to ldap query's
//              names linked list
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pwszDN            - DN
//              pDeferredOU       - Deferred OU
//              pDeferredGPO      - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL InsertDN( LDAPQUERY *pLdapQuery, LPTSTR pwszDN,
               DNENTRY *pDeferredOU, PGROUP_POLICY_OBJECT pDeferredGPO )
{
    DNENTRY *pNewEntry = NULL;
    DNENTRY *pTrailPtr = NULL;
    DNENTRY *pCurPtr = pLdapQuery->pDnEntry;
    XLastError xe;

    DmAssert( !( pDeferredOU && pDeferredGPO ) );

    while ( pCurPtr != NULL ) {

         INT iResult = CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                                       pwszDN, -1, pCurPtr->pwszDN, -1 );

         if ( iResult == CSTR_EQUAL || iResult == CSTR_LESS_THAN ) {

             //
             // Duplicate or since dn's are in ascending order, add new entry
             //

             pNewEntry = AllocDnEntry( pwszDN );
             if ( pNewEntry == NULL )
                 return FALSE;

             if ( !AddDnToFilter( pLdapQuery, pwszDN ) ) {
                 xe = GetLastError();
                 FreeDnEntry( pNewEntry );
                 return FALSE;
             }

             if ( pDeferredOU )
                 pNewEntry->pDeferredOU = pDeferredOU;
             else
                 pNewEntry->pDeferredGPO = pDeferredGPO;

             pNewEntry->pNext = pCurPtr;
             if ( pTrailPtr == NULL )
                 pLdapQuery->pDnEntry = pNewEntry;
             else
                 pTrailPtr->pNext = pNewEntry;

             return TRUE;

         } else {

             //
             // Advance down the list
             //

             pTrailPtr = pCurPtr;
             pCurPtr = pCurPtr->pNext;

         }

    }    // while

    //
    // Null list or end of list case.
    //

    pNewEntry = AllocDnEntry( pwszDN );
    if ( pNewEntry == NULL ) {
        xe = GetLastError();
        return FALSE;
    }

    if ( !AddDnToFilter( pLdapQuery, pwszDN ) ) {
        xe = GetLastError();
        FreeDnEntry( pNewEntry );
        return FALSE;
    }

    if ( pDeferredOU )
        pNewEntry->pDeferredOU = pDeferredOU;
    else
        pNewEntry->pDeferredGPO = pDeferredGPO;

    pNewEntry->pNext = pCurPtr;
    if ( pTrailPtr == NULL )
         pLdapQuery->pDnEntry = pNewEntry;
    else
        pTrailPtr->pNext = pNewEntry;

    return TRUE;
}



//*************************************************************
//
//  AddDN()
//
//  Purpose:    Adds a distinguished name entry to ldap query
//
//  Parameters: ppLdapQuery       - LDAP query list
//              pwszDN            - DN name
//              pDeferredOU       - Deferred OU
//              pDeferredGPO      - Deferred GPO
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDN( PLDAP_API pLDAP, LDAPQUERY **ppLdapQuery,
            LPTSTR pwszDN, DNENTRY *pDeferredOU, PGROUP_POLICY_OBJECT pDeferredGPO )
{
    LPTSTR pwszDomain = NULL;
    LPTSTR pwszTemp = pwszDN;
    LDAPQUERY *pNewQuery = NULL;
    LDAPQUERY *pTrailPtr = NULL;
    LDAPQUERY *pCurPtr = *ppLdapQuery;
    XLastError xe;

    DmAssert( !( pDeferredOU && pDeferredGPO ) );

    //
    // Find the domain to which the GPO belongs
    //

    if ( pwszTemp == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AddDN: Null pwszDN. Exiting.") ));
        return FALSE;
    }

    while ( *pwszTemp ) {

        //
        // The check below needs to be more sophisticated to take care
        // of spaces in names etc.
        //

        if (CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                            pwszTemp, 16, TEXT("cn=configuration"), 16) == CSTR_EQUAL ) {
            DebugMsg((DM_VERBOSE, TEXT("AddDN: DN %s is under cn=configuration container. queueing for rebinding"), pwszDN ));
            pwszDomain = pwszTemp;
            break;
        }

        if (CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                            pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
            pwszDomain = pwszTemp;
            break;
        }

        //
        // Move to the next chunk of the DN name
        //

        while ( *pwszTemp && (*pwszTemp != TEXT(',')))
            pwszTemp++;

        if ( *pwszTemp == TEXT(','))
            pwszTemp++;

    }

    if ( pwszDomain == NULL ) {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("AddDN: Domain not found for <%s>. Exiting."), pwszDN ));
        return FALSE;
    }

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                                      pwszDomain, -1, pCurPtr->pwszDomain, -1 );
        if ( iResult == CSTR_EQUAL ) {

            BOOL bOk = InsertDN( pCurPtr, pwszDN, pDeferredOU, pDeferredGPO );
            return bOk;

        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Since domains are in ascending order,
            // pwszDomain is not in list, so add.
            //

            pNewQuery = AllocLdapQuery( pwszDomain );
            if ( pNewQuery == NULL ) {
                xe = GetLastError();
                return FALSE;
            }

            if ( !InsertDN( pNewQuery, pwszDN, pDeferredOU, pDeferredGPO ) ) {
                xe = GetLastError();
                FreeLdapQuery( pLDAP, pNewQuery );
                return FALSE;
            }

            pNewQuery->pNext = pCurPtr;
            if ( pTrailPtr == NULL )
                *ppLdapQuery = pNewQuery;
            else
                pTrailPtr->pNext = pNewQuery;

            return TRUE;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }   // while

    //
    // Null list or end of list case.
    //

    pNewQuery = AllocLdapQuery( pwszDomain );

    if ( pNewQuery == NULL ) {
        xe = GetLastError();
        return FALSE;
    }

    if ( !InsertDN( pNewQuery, pwszDN, pDeferredOU, pDeferredGPO ) ) {
        xe = GetLastError();
        FreeLdapQuery( pLDAP, pNewQuery );
        return FALSE;
    }

    pNewQuery->pNext = pCurPtr;

    if ( pTrailPtr == NULL )
        *ppLdapQuery = pNewQuery;
    else
        pTrailPtr->pNext = pNewQuery;

    return TRUE;
}



//*************************************************************
//
//  EvalList()
//
//  Purpose:    Encapsulates common processing functionality for
//              forced and nonforced lists
//
//  Parameters: pLDAP                  - LDAP api
//              dwFlags                - GetGPOList flags
//              bVerbose               - Verbose flag
//              hToken                 - User or machine token
//              pDeferredList          - List of deferred GPOs
//              ppGPOList              - List of evaluated GPOs
//              ppGpContainerList      - List of Gp Containers
//              pGpoFilter             - Gpo filter
//              pLocator               - WMI interfaces
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvalList(  PLDAP_API pLDAP,
                DWORD dwFlags,
                HANDLE hToken,
                BOOL bVerbose,
                PGROUP_POLICY_OBJECT pDeferredList,
                PGROUP_POLICY_OBJECT *ppGPOList,
                LPGPCONTAINER *ppGpContainerList,
                PRSOPTOKEN pRsopToken,
                CGpoFilter *pGpoFilter,
                CLocator *pLocator  )
{
    PGROUP_POLICY_OBJECT pGPOTemp = pDeferredList;

    while ( pGPOTemp ) {

        PLDAPMessage pGPOMsg = (PLDAPMessage) pGPOTemp->lParam;

        if ( pGPOMsg == NULL ) {
            DebugMsg((DM_VERBOSE, TEXT("EvalList: Object <%s> cannot be accessed"),
                      pGPOTemp->lpDSPath ));

            if (dwFlags & GP_PLANMODE) {
                CEvents ev(TRUE, EVENT_OBJECT_NOT_FOUND_PLANNING);
                ev.AddArg(pGPOTemp->lpDSPath); ev.Report();
            }
            else {
                if (bVerbose) {
                    CEvents ev(FALSE, EVENT_OBJECT_NOT_FOUND);
                    ev.AddArg(pGPOTemp->lpDSPath); ev.AddArg((DWORD)0); ev.Report();
                }
            }

        } else {

            DmAssert( pGPOTemp->lParam2 != NULL );
            DmAssert( ((LPGPOPROCDATA)(pGPOTemp->lParam2))->pLdapHandle != NULL );

            if ( !ProcessGPO(   pGPOTemp->lpDSPath,
                                dwFlags,
                                hToken,
                                ppGPOList,
                                ppGpContainerList,
                                pGPOTemp->dwOptions,
                                FALSE,
                                bVerbose,
                                pGPOTemp->GPOLink,
                                pGPOTemp->lpLink,
                                ((LPGPOPROCDATA)(pGPOTemp->lParam2))->pLdapHandle,
                                pLDAP,
                                pGPOMsg,
                                FALSE,
                                pRsopToken,
                                pGpoFilter,
                                pLocator,
                                ((LPGPOPROCDATA)(pGPOTemp->lParam2))->bProcessGPO ) )
            {
                DebugMsg((DM_WARNING, TEXT("EvalList:  ProcessGPO failed") ));
                return FALSE;
            }

        }

        pGPOTemp = pGPOTemp->pNext;

    }

    return TRUE;
}

//*************************************************************
//
//  EvaluateDeferredGPOs()
//
//  Purpose:    Uses a single ldap query to evaluate deferred
//              GPO lists.
//
//  Parameters: pldBound               - Bound LDAP handle
//              pLDAP                  - LDAP api
//              pwszDomainBound        - Domain already bound to
//              dwFlags                - GetGPOList flags
//              hToken                 - User or machine token
//              pDeferredForcedList    - List of deferred forced GPOs
//              pDeferredNonForcedList - List of deferred non-forced GPOs
//              pGPOForcedList         - List of forced GPOs
//              pGPONonForcedList      - List of non-forced GPOs
//              ppGpContainerList      - List of Gp Containers
//              pGpoFilter             - Gpo filter
//              pLocator               - WMI interfaces
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvaluateDeferredGPOs (PLDAP pldBound,
                           PLDAP_API pLDAP,
                           LPTSTR pwszDomainBound,
                           DWORD dwFlags,
                           HANDLE hToken,
                           BOOL bVerbose,
                           PGROUP_POLICY_OBJECT pDeferredForcedList,
                           PGROUP_POLICY_OBJECT pDeferredNonForcedList,
                           PGROUP_POLICY_OBJECT *ppForcedList,
                           PGROUP_POLICY_OBJECT *ppNonForcedList,
                           LPGPCONTAINER *ppGpContainerList,
                           PRSOPTOKEN pRsopToken,
                           CGpoFilter *pGpoFilter,
                           CLocator *pLocator )
{
    ULONG ulResult;
    BOOL bResult = FALSE;
    BYTE berValue[8];
    LDAPControl SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    LDAPControl referralControl = { LDAP_SERVER_DOMAIN_SCOPE_OID_W, { 0, NULL}, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, &referralControl, NULL };
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    TCHAR szCommonName[] = TEXT("cn");
    TCHAR szDisplayName[] = TEXT("displayName");
    TCHAR szFileSysPath[] = TEXT("gPCFileSysPath");
    TCHAR szVersion[] = TEXT("versionNumber");
    TCHAR szFunctionalityVersion[] = GPO_FUNCTIONALITY_VERSION;
    TCHAR szFlags[] = TEXT("flags");
    TCHAR szWmiFilter[] = TEXT("gPCWQLFilter");

    PWSTR rgAttribs[12] = {szSDProperty,
                           szFileSysPath,
                           szCommonName,
                           szDisplayName,
                           szVersion,
                           szFunctionalityVersion,
                           szFlags,
                           GPO_MACHEXTENSION_NAMES,
                           GPO_USEREXTENSION_NAMES,
                           szObjectClass,
                           szWmiFilter,
                           NULL };
    PGROUP_POLICY_OBJECT pGPOTemp = pDeferredForcedList;
    LDAPQUERY *pLdapQuery = NULL, *pQuery = NULL;
    VOID *pData;
    PDS_API pdsApi;
    BOOL bRsopPlanningMode = (pRsopToken != 0);
    BOOL bConfigContainer = FALSE;

    *ppForcedList = NULL;
    *ppNonForcedList = NULL;
    XLastError xe;

    if ( pDeferredForcedList == NULL && pDeferredNonForcedList == NULL )
        return TRUE;

    //
    // Demand load ntdsapi.dll
    //

    pdsApi = LoadDSApi();

    if ( pdsApi == 0 ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGpos: Failed to load ntdsapi.dll")));
        goto Exit;
    }

    while ( pGPOTemp ) {

        if ( !AddDN( pLDAP, &pLdapQuery, pGPOTemp->lpDSPath, NULL, pGPOTemp ) ) {
            xe = GetLastError();
            goto Exit;
        }
        
        pGPOTemp = pGPOTemp->pNext;

    }

    pGPOTemp = pDeferredNonForcedList;
    while ( pGPOTemp ) {

        if ( !AddDN( pLDAP, &pLdapQuery, pGPOTemp->lpDSPath, NULL, pGPOTemp ) ) {
             xe = GetLastError();
             goto Exit;
        }
        pGPOTemp = pGPOTemp->pNext;

    }

    //
    // Setup the BER encoding
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);

    pQuery  = pLdapQuery;
    while ( pQuery ) {

        //
        // The check below needs to be more sophisticated to take care
        // of spaces in names etc. 
        // 
        // It is assumed that the configuration
        // container would be common across the whole forest and will
        // not need a new bind..
        //

        if (CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                            pQuery->pwszDomain, 16, TEXT("cn=configuration"), 16) == CSTR_EQUAL ) {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: DN %s is under cn=configuration container"), pQuery->pwszDomain ));
            bConfigContainer = TRUE;
        }
        else 
            bConfigContainer = FALSE;


        //
        // Check if this is a cross-domain Gpo and hence needs a new bind
        //

        WCHAR *pDomainString[1];
        PDS_NAME_RESULT pNameResult = NULL;
        PLDAP pLdapHandle = NULL;
    
        if (!bConfigContainer) 
            pDomainString[0] = pQuery->pwszDomain;
        else {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: The GPO is under the config container. Querying seperately\n")));
            
            //
            // This is a configuration container and we have to figure
            // out the domain name still..
            //

            LPTSTR pwszTemp = pQuery->pwszDomain;

            pDomainString[0] = NULL;

            while ( *pwszTemp ) {
                
                if (CompareString ( LOCALE_INVARIANT, NORM_IGNORECASE,
                                    pwszTemp, 3, TEXT("DC="), 3) == CSTR_EQUAL ) {
                    pDomainString[0] = pwszTemp;
                    break;
                }

                //
                // Move to the next chunk of the DN name
                //

                while ( *pwszTemp && (*pwszTemp != TEXT(',')))
                    pwszTemp++;

                if ( *pwszTemp == TEXT(','))
                    pwszTemp++;

            }

            if ( pDomainString[0] == NULL ) {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs: Domain not found for <%s>. Exiting."), pQuery->pwszDomain ));
                goto Exit;
            }
        }
    
        ulResult = pdsApi->pfnDsCrackNames( (HANDLE) -1,
                                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                          DS_FQDN_1779_NAME,
                                          DS_CANONICAL_NAME,
                                          1,
                                          pDomainString,
                                          &pNameResult );
    
        if ( ulResult != ERROR_SUCCESS
             || pNameResult->cItems == 0
             || pNameResult->rItems[0].status != ERROR_SUCCESS
             || pNameResult->rItems[0].pDomain == NULL ) {
    
            xe = ulResult;
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs:  DsCrackNames failed with 0x%x."), ulResult ));
            goto Exit;
        }
    
        //
        // Optimize same domain Gpo queries by not doing an unnecessary bind
        //
    
        pQuery->pLdapHandle = pldBound;
    
        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                           pwszDomainBound, -1, pNameResult->rItems[0].pDomain, -1) != CSTR_EQUAL) {
    
            //
            // Cross-domain Gpo query and so need to bind to new domain
            //
    
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: Doing an ldap bind to cross-domain <%s>"),
                      pNameResult->rItems[0].pDomain));
    
            pLdapHandle = pLDAP->pfnldap_init( pNameResult->rItems[0].pDomain, LDAP_PORT);
    
            if (!pLdapHandle) {
                xe = pLDAP->pfnLdapMapErrorToWin32(pLDAP->pfnLdapGetLastError());

                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  ldap_init for <%s> failed with = 0x%x or %d"),
                          pNameResult->rItems[0].pDomain, pLDAP->pfnLdapGetLastError(), GetLastError()));
                CEvents ev(TRUE, EVENT_FAILED_DS_INIT);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(pLDAP->pfnLdapGetLastError()); ev.Report();
    
                pdsApi->pfnDsFreeNameResult( pNameResult );
    
                goto Exit;
            }
    
            //
            // Turn on Packet integrity flag
            //

            pData = (VOID *) LDAP_OPT_ON;
            ulResult = pLDAP->pfnldap_set_option(pLdapHandle, LDAP_OPT_SIGN, &pData);
    
            if (ulResult != LDAP_SUCCESS) {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
                pdsApi->pfnDsFreeNameResult( pNameResult );
                pLDAP->pfnldap_unbind(pLdapHandle);
                pLdapHandle = 0;
                goto Exit;
            }

            ulResult = pLDAP->pfnldap_connect(pLdapHandle, 0);

            if (ulResult != LDAP_SUCCESS) {
                CEvents ev(TRUE, EVENT_FAILED_DS_CONNECT);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(ulResult); ev.Report();

                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Failed to connect with %d"), ulResult));
                pdsApi->pfnDsFreeNameResult( pNameResult );
                pLDAP->pfnldap_unbind(pLdapHandle);
                pLdapHandle = 0;
                goto Exit;
            }

            //
            // Transfer ownerhip of ldap handle to pQuery struct
            //
    
            pQuery->pLdapHandle = pLdapHandle;
            pQuery->bOwnLdapHandle = TRUE;
    
            if ( !bRsopPlanningMode && (dwFlags & GPO_LIST_FLAG_MACHINE) ) {
    
                //
                // For machine policies specifically ask for Kerberos as the only authentication
                // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
                // and localsystem context has no real credentials, which means that we won't get
                // any GPOs back.
                //
    
                SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;
    
                secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
                secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
                secIdentity.User = 0;
                secIdentity.UserLength = 0;
                secIdentity.Domain = 0;
                secIdentity.DomainLength = 0;
                secIdentity.Password = 0;
                secIdentity.PasswordLength = 0;
                secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                secIdentity.PackageList = wszKerberos;
                secIdentity.PackageListLength = lstrlen( wszKerberos );
    
                ulResult = pLDAP->pfnldap_bind_s (pLdapHandle, NULL, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI);
    
            } else
                ulResult = pLDAP->pfnldap_bind_s (pLdapHandle, NULL, NULL, LDAP_AUTH_SSPI);
    
            if (ulResult != LDAP_SUCCESS) {
    
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  ldap_bind_s failed with = <%d>"),
                          ulResult));
                CEvents ev(TRUE, EVENT_FAILED_DS_BIND);
                ev.AddArg(pNameResult->rItems[0].pDomain); ev.AddArgLdapError(ulResult); ev.Report();
    
                pdsApi->pfnDsFreeNameResult( pNameResult );
    
                goto Exit;
            }
    
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs: Bind sucessful")));
    
        }

        pdsApi->pfnDsFreeNameResult( pNameResult );

        //
        // Turn referrals off because this is a single domain call
        //

        pData = (VOID *) LDAP_OPT_OFF;
        ulResult = pLDAP->pfnldap_set_option( pQuery->pLdapHandle,  LDAP_OPT_REFERRALS, &pData );
        if ( ulResult != LDAP_SUCCESS )
        {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
            DebugMsg((DM_WARNING, TEXT("EvalauteDeferredGPOs:  Failed to turn off referrals with error %d"), ulResult));
            goto Exit;
        }

        //
        // Search for GPOs
        //

        //
        // restrict the search to just the policies container
        //

        DmAssert( pQuery->pwszDomain != NULL && pQuery->pwszFilter != NULL );

        XPtrLF<WCHAR>       xszGPOSearchBase;
        DWORD               cChLen;

        cChLen = (1+lstrlen(pQuery->pwszDomain)+lstrlen(DOMAIN_GPO_LOCATION_FMT));

        xszGPOSearchBase = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*cChLen);

        if (!xszGPOSearchBase)
        {
            xe = GetLastError();                
            DebugMsg((DM_WARNING, TEXT("EvalauteDeferredGPOs:  Failed to allocate memory for GPO base search with %d"), GetLastError()));
            goto Exit;
        }

        HRESULT hr;
        hr = StringCchPrintf(xszGPOSearchBase, cChLen,
                        DOMAIN_GPO_LOCATION_FMT, 
                        pQuery->pwszDomain);

        DmAssert(SUCCEEDED(hr));

        DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs:  Searching for GPOs in %s"), (LPWSTR)xszGPOSearchBase));

        ulResult = pLDAP->pfnldap_search_ext_s(pQuery->pLdapHandle, 
                                               (LPWSTR)xszGPOSearchBase, 
                                               LDAP_SCOPE_SUBTREE,
                                               pQuery->pwszFilter, rgAttribs, 0,
                                               (PLDAPControl*)ServerControls,
                                               NULL, NULL, 0x10000, &pQuery->pMessage);

        //
        // If the search fails, store the error code and return
        //

        if (ulResult != LDAP_SUCCESS) {

            if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
                DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredGPOs:  All objects can not be accessed.")));

                if (dwFlags & GP_PLANMODE) { 
                    CEvents ev(TRUE, EVENT_NO_GPOS2_PLANNING); ev.Report();
                }
                else {
                    if (bVerbose) {
                        CEvents ev(FALSE, EVENT_NO_GPOS2); ev.Report();
                    }
                }
                bResult = TRUE;

            } else if (ulResult == LDAP_NO_SUCH_OBJECT) {
                DebugMsg((DM_VERBOSE, TEXT("EvalateDeferredGPOs:  Objects do not exist.") ));
                
                if (dwFlags & GP_PLANMODE) { 
                    // Same error or different
                    CEvents ev(TRUE, EVENT_NO_GPOS2_PLANNING); ev.Report();
                }
                else {
                    if (bVerbose) {
                        CEvents ev(FALSE, EVENT_NO_GPOS2); ev.Report();
                    }
                }

                bResult = TRUE;

            } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvalateDeferredGPOs:  Too many GPOs in search.") ));
                CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

            } else {
                xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);                
                DebugMsg((DM_WARNING, TEXT("EvaluteDeferredGPOs:  Failed to search with error 0x%x"), ulResult));
                CEvents ev(TRUE, EVENT_FAILED_GPO_SEARCH);
                ev.AddArgLdapError(ulResult); ev.Report();
            }

            goto Exit;
        }

        //
        // If the search succeeds, but the message is empty,
        // store the error code and return
        //

        if ( pQuery->pMessage == NULL ) {
            xe = pLDAP->pfnLdapMapErrorToWin32(pQuery->pLdapHandle->ld_errno);                
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredGPOs:  Search returned an empty message structure.  Error = 0x%x"),
                     pQuery->pLdapHandle->ld_errno));
            goto Exit;
        }

        if ( !MatchDnWithDeferredItems( pLDAP, pQuery, FALSE ) ) {
            xe = GetLastError();
            goto Exit;
        }

        pQuery = pQuery->pNext;

    }   // while

    if ( !EvalList( pLDAP, dwFlags, hToken, bVerbose,
                    pDeferredForcedList, ppForcedList, ppGpContainerList, pRsopToken, pGpoFilter, pLocator ) ) {
        xe = GetLastError();
        goto Exit;
    }

    if ( !EvalList( pLDAP, dwFlags, hToken, bVerbose,
                    pDeferredNonForcedList, ppNonForcedList, ppGpContainerList, pRsopToken, pGpoFilter, pLocator ) ) {
        xe = GetLastError();
        goto Exit;
    }

    bResult = TRUE;

Exit:

    //
    // Free all resources except for ppForcedList, ppNonForcedList
    // which are owned by caller.
    //

    while ( pLdapQuery ) {
        pQuery = pLdapQuery->pNext;
        FreeLdapQuery( pLDAP, pLdapQuery );
        pLdapQuery = pQuery;
    }

    return bResult;
}


//*************************************************************
//
//  AddOU()
//
//  Purpose:    Appends an OU or domain to deferred list.
//
//  Parameters: ppOUList    - OU list to append to
//              pwszOU      - OU name
//              gpoLink     - Type of Gpo
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddOU( DNENTRY **ppOUList, LPTSTR pwszOU, GPO_LINK gpoLink )
{
    DNENTRY *pOUTemp = *ppOUList;
    DNENTRY *pOULast = NULL;

    DNENTRY *pOUNew = AllocDnEntry( pwszOU );
    if ( pOUNew == NULL ) {
        return FALSE;
    }

    pOUNew->gpoLink = gpoLink;

    while ( pOUTemp ) {
        pOULast = pOUTemp;
        pOUTemp = pOUTemp->pNext;
    }

    if ( pOULast )
        pOULast->pNext = pOUNew;
    else
        *ppOUList = pOUNew;

    return TRUE;
}


//*************************************************************
//
//  EvaluateDeferredOUs()
//
//  Purpose:    Uses a single Ldap query to evaluate all OUs
//
//  Parameters: ppOUList            - OU list to append to
//              dwFlags             - GetGPOList flags
//              pGPOForcedList      - List of forced GPOs
//              pGPONonForcedList   - List of non-forced GPOs
//              ppSOMList           - List of LSDOUs
//              ppGpContainerList   - List of Gp Containers
//              bVerbose            - Verbose output
//              pld                 - LDAP info
//              pLDAP               - LDAP api
//              pLDAPMsg            - LDAP message
//              bBlock              - Pointer to the block flag
//              hToken              - User / machine token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL EvaluateDeferredOUs(   DNENTRY *pOUList,
                            DWORD dwFlags,
                            HANDLE hToken,
                            PGROUP_POLICY_OBJECT *ppDeferredForcedList,
                            PGROUP_POLICY_OBJECT *ppDeferredNonForcedList,
                            LPSCOPEOFMGMT *ppSOMList,
                            LPGPCONTAINER *ppGpContainerList,
                            BOOL bVerbose,
                            PLDAP  pld,
                            PLDAP_API pLDAP,
                            BOOL *pbBlock,
                            PRSOPTOKEN pRsopToken)
{
    ULONG ulResult;
    BOOL bResult = FALSE;
    LDAPQUERY   *pLdapQuery = NULL;
    BYTE         berValue[8];
    LDAPControl  SeInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W, { 5, (PCHAR)berValue }, TRUE };
    PLDAPControl ServerControls[] = { &SeInfoControl, NULL };

    TCHAR szGPLink[] = TEXT("gPLink");
    TCHAR szGPOptions[] = TEXT("gPOptions");
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    LPTSTR lpAttr[] = { szGPLink,
                        szGPOptions,
                        szSDProperty,
                        NULL
                      };
    DNENTRY *pOUTemp = pOUList;
    VOID *pData;
    XLastError xe;


    //
    // Setup the BER encoding for the SD
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02; // denotes an integer
    berValue[3] = 0x01; // denotes size
    berValue[4] = (BYTE)((DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION) & 0xF);


    if ( !pRsopToken )
    {
        //
        // if it is not planning mode, don't get the SD
        // 

        lpAttr[2] = NULL;
        ServerControls[0] = NULL;
    }


    if ( pOUTemp == NULL )
        return TRUE;

    while ( pOUTemp ) {
        if ( !AddDN( pLDAP, &pLdapQuery, pOUTemp->pwszDN, pOUTemp, NULL ) ) {
            xe = GetLastError();
            goto Exit;
        }
        pOUTemp = pOUTemp->pNext;
    }

    pLdapQuery->pLdapHandle = pld;

    //
    // Turn referrals off because this is a single domain call
    //

    if ( !pRsopToken )
    {
        pData = (VOID *) LDAP_OPT_OFF;
        ulResult = pLDAP->pfnldap_set_option( pLdapQuery->pLdapHandle,  LDAP_OPT_REFERRALS, &pData );
        if ( ulResult != LDAP_SUCCESS ) {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvaluteDeferredOUs:  Failed to turn off referrals with error %d"), ulResult));
            goto Exit;
        }
    }
    

    ulResult = pLDAP->pfnldap_search_ext_s(pld, pLdapQuery->pwszDomain, LDAP_SCOPE_SUBTREE,
                                           pLdapQuery->pwszFilter, lpAttr, FALSE,
                                           (PLDAPControl*)ServerControls,
                                           NULL, NULL, 0, &pLdapQuery->pMessage);


    //
    // If the search fails, store the error code and return
    //

    if (ulResult != LDAP_SUCCESS) {

        if (ulResult == LDAP_NO_SUCH_ATTRIBUTE) {
            DebugMsg((DM_VERBOSE, TEXT("EvaluateDeferredOUs:  All objects can not be accessed.")));
            bResult = TRUE;

        } else if (ulResult == LDAP_NO_SUCH_OBJECT) {
            DebugMsg((DM_VERBOSE, TEXT("EvalateDeferredOUs:  Objects do not exist.") ));
            bResult = TRUE;

        } else if (ulResult == LDAP_SIZELIMIT_EXCEEDED) {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvalateDeferredOUs:  Too many linked GPOs in search.") ));
            CEvents ev(TRUE, EVENT_TOO_MANY_GPOS); ev.Report();

        } else {
            xe = pLDAP->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  Failed to search with error %d"), ulResult));
            CEvents ev(TRUE, EVENT_FAILED_OU_SEARCH);
            ev.AddArg(ulResult); ev.Report();
        }

        goto Exit;
    }

    //
    // If the search succeeds, but the message is empty,
    // store the error code and return
    //

    if ( pLdapQuery->pMessage == NULL ) {
        xe = pLDAP->pfnLdapMapErrorToWin32(pld->ld_errno);
        DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  Search returned an empty message structure.  Error = %d"),
                  pld->ld_errno));
        goto Exit;
    }

    if ( !MatchDnWithDeferredItems( pLDAP, pLdapQuery, TRUE ) ) {
        xe = GetLastError();
        goto Exit;
    }

    //
    // Evaluate the OU list
    //

    pOUTemp = pOUList;

    while ( pOUTemp ) {

        PLDAPMessage pOUMsg = pOUTemp->pOUMsg;

        if ( pOUMsg == NULL ) {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs: Object <%s> cannot be accessed"),
                      pOUTemp->pwszDN ));
            
            CEvents ev(TRUE, EVENT_OU_NOTFOUND);
            ev.AddArg(pOUTemp->pwszDN); ev.Report();

            goto Exit;

        } else {
               if ( !SearchDSObject( pOUTemp->pwszDN, dwFlags, hToken, ppDeferredForcedList, ppDeferredNonForcedList,
                                     ppSOMList, ppGpContainerList,
                                     bVerbose, pOUTemp->gpoLink, pld, pLDAP, pOUMsg, pbBlock, pRsopToken)) {
                   xe = GetLastError();
                   DebugMsg((DM_WARNING, TEXT("EvaluateDeferredOUs:  SearchDSObject failed") ));
                   goto Exit;
               }
        }

        pOUTemp = pOUTemp->pNext;

    }

    bResult = TRUE;

Exit:

    while ( pLdapQuery ) {
        LDAPQUERY *pQuery = pLdapQuery->pNext;
        FreeLdapQuery( pLDAP, pLdapQuery );
        pLdapQuery = pQuery;
    }

    return bResult;
}



//*************************************************************
//
//  GetMachineDomainDS()
//
//  Purpose:    Obtain the machine domain DS
//
//  Parameters: pNetApi32       - netapi32.dll
//              pLdapApi        - wldap32.dll
//
//  Return:     valid PLDAP if successful
//              0 if an error occurs
//
//*************************************************************
PLDAP
GetMachineDomainDS( PNETAPI32_API pNetApi32, PLDAP_API pLdapApi )
{
    PLDAP       pld = 0;

    DWORD       dwResult = 0;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;
    ULONG ulResult;
    VOID *pData;
    XLastError xe;

    //
    // get the machine domain name
    //

    dwResult = pNetApi32->pfnDsRoleGetPrimaryDomainInformation( NULL, 
                                                                DsRolePrimaryDomainInfoBasic,
                                                               (PBYTE *)&pDsInfo );
    if ( dwResult == ERROR_SUCCESS )
    {
        SEC_WINNT_AUTH_IDENTITY_EXW secIdentity;

        pld = pLdapApi->pfnldap_init( pDsInfo->DomainNameDns, LDAP_PORT );


        if (!pld) {
            xe = pLdapApi->pfnLdapMapErrorToWin32(pLdapApi->pfnLdapGetLastError());
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  ldap_open for <%s> failed with = 0x%x or %d"),
                                 pDsInfo->DomainNameDns, pLdapApi->pfnLdapGetLastError(), GetLastError()));
            return pld;
        }

        //
        // Turn on Packet integrity flag
        //

        pData = (VOID *) LDAP_OPT_ON;
        ulResult = pLdapApi->pfnldap_set_option(pld, LDAP_OPT_SIGN, &pData);

        if (ulResult != LDAP_SUCCESS) {

            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  Failed to turn on LDAP_OPT_SIGN with %d"), ulResult));
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
            return pld;
        }

        ulResult = pLdapApi->pfnldap_connect(pld, 0);

        if (ulResult != LDAP_SUCCESS) {

            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  Failed to connect with %d"), ulResult));
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
            return pld;
        }

        //
        // For machine policies specifically ask for Kerberos as the only authentication
        // mechanism. Otherwise if Kerberos were to fail for some reason, then NTLM is used
        // and localsystem context has no real credentials, which means that we won't get
        // any GPOs back.
        //

        secIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        secIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        secIdentity.User = 0;
        secIdentity.UserLength = 0;
        secIdentity.Domain = 0;
        secIdentity.DomainLength = 0;
        secIdentity.Password = 0;
        secIdentity.PasswordLength = 0;
        secIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        secIdentity.PackageList = wszKerberos;
        secIdentity.PackageListLength = lstrlen( wszKerberos );

        if ( (ulResult = pLdapApi->pfnldap_bind_s (pld, 0, (WCHAR *)&secIdentity, LDAP_AUTH_SSPI)) != LDAP_SUCCESS )
        {
            DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS: ldap_bind_s failed with %d"), ulResult));
            xe = pLdapApi->pfnLdapMapErrorToWin32(ulResult);
            pLdapApi->pfnldap_unbind(pld);
            pld = 0;
        }

        pNetApi32->pfnDsRoleFreeMemory( pDsInfo );
    }
    else
    {
        xe = dwResult;
        DebugMsg((DM_WARNING, TEXT("GetMachineDomainDS:  The domain does not have a DS")));
    }


    return pld;
}



//*************************************************************
//
//  AllocSOM()
//
//  Purpose:    Allocates a new struct for SOM
//
//
//  Parameters: pwszSOMId  - Name of SOM
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

SCOPEOFMGMT *AllocSOM( LPWSTR pwszSOMId )
{
    XLastError xe;
    HRESULT hr = S_OK;
    SCOPEOFMGMT *pSOM = (SCOPEOFMGMT *) LocalAlloc( LPTR, sizeof(SCOPEOFMGMT) );

    if ( pSOM == NULL ) {
        xe = GetLastError();
        return NULL;
    }

    pSOM->pwszSOMId = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszSOMId) + 1) * sizeof(WCHAR) );
    if ( pSOM->pwszSOMId == NULL ) {
        xe = GetLastError();
        LocalFree( pSOM );
        return NULL;
    }

    hr = StringCchCopy( pSOM->pwszSOMId, lstrlen(pwszSOMId) + 1, pwszSOMId );
    ASSERT(SUCCEEDED(hr));
    return pSOM;
}


//*************************************************************
//
//  FreeSOM()
//
//  Purpose:    Frees SOM struct
//
//  Parameters: pSOM - SOM to free
//
//*************************************************************

void FreeSOM( SCOPEOFMGMT *pSOM )
{
    GPLINK *pGpLink = NULL;

    if ( pSOM ) {

        LocalFree( pSOM->pwszSOMId );

        pGpLink = pSOM->pGpLinkList;
        while ( pGpLink ) {
            GPLINK *pTemp = pGpLink->pNext;
            FreeGpLink( pGpLink );
            pGpLink = pTemp;
        }

        LocalFree( pSOM );

    }
}



//*************************************************************
//
//  AllocGpLink()
//
//  Purpose:    Allocates a new struct for GpLink
//
//
//  Parameters: pwszGPO  - Name of GPO
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

GPLINK *AllocGpLink( LPWSTR pwszGPO, DWORD dwOptions )
{
    //
    // Strip out "LDAP://" prefix to get canonical Gpo path
    //

    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPath = pwszGPO;
    GPLINK *pGpLink = NULL;
    XLastError xe;
    HRESULT hr = S_OK;

    if ( (lstrlen(pwszGPO) > iPrefixLen)
         && CompareString( LOCALE_INVARIANT, NORM_IGNORECASE,
                           pwszGPO, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
       pwszPath = pwszGPO + iPrefixLen;
    }

    pGpLink = (GPLINK *) LocalAlloc( LPTR, sizeof(GPLINK) );

    if ( pGpLink == NULL ) {
        xe = GetLastError();
        return NULL;
    }

    pGpLink->pwszGPO = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszPath) + 1) * sizeof(WCHAR) );
    if ( pGpLink->pwszGPO == NULL ) {
        xe = GetLastError();
        LocalFree( pGpLink );
        return NULL;
    }

    hr = StringCchCopy( pGpLink->pwszGPO, lstrlen(pwszPath) + 1, pwszPath );
    ASSERT(SUCCEEDED(hr));

    pGpLink->bEnabled = (dwOptions & GPO_FLAG_DISABLE) ? FALSE : TRUE;

    if ( dwOptions & GPO_FLAG_FORCE )
        pGpLink->bNoOverride = TRUE;

    return pGpLink;
}



//*************************************************************
//
//  FreeGpLink()
//
//  Purpose:    Frees GpLink struct
//
//  Parameters: pGpLink - GpLink to free
//
//*************************************************************

void FreeGpLink( GPLINK *pGpLink )
{
    if ( pGpLink ) {
        LocalFree( pGpLink->pwszGPO );
        LocalFree( pGpLink );
    }
}


//*************************************************************
//
//  AllocGpContainer()
//
//  Purpose:    Allocates a new struct for GpContainer
//
//
//  Parameters: dwFlags        - Flags
//              bFound         - Was Gpo found ?
//              bAccessGranted - Was access granted ?
//              bDisabled      - Is Gp Container disabled ?
//              dwVersion      - Version #
//              lpDSPath       - DS path to Gpo
//              lpFileSysPath  - Sysvol path to Gpo
//              lpDisplayName  - Friendly name
//              lpGpoName      - Guid name
//              pSD            - Security descriptor
//              cbSDLen        - Length of security descriptor
//              bFilterAllowed    - Does GPO pass filter check
//              pwszFilterId      - WQL filter id
//
//  Return:     Pointer if successful
//              NULL if an error occurs
//
//*************************************************************

GPCONTAINER *AllocGpContainer(  DWORD dwFlags,
                                BOOL bFound,
                                BOOL bAccessGranted,
                                BOOL bDisabled,
                                DWORD dwVersion,
                                LPTSTR lpDSPath,
                                LPTSTR lpFileSysPath,
                                LPTSTR lpDisplayName,
                                LPTSTR lpGpoName,
                                PSECURITY_DESCRIPTOR pSD,
                                DWORD cbSDLen,
                                BOOL bFilterAllowed,
                                WCHAR *pwszFilterId,
                                LPWSTR szSOM,
                                DWORD  dwOptions )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPath = lpDSPath;
    BOOL bResult = FALSE;
    GPCONTAINER *pGpContainer = NULL;
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Strip out prefix, if any, to get the canonical path to Gpo
    //

    if ( (lstrlen(lpDSPath) > iUserPrefixLen)
         && CompareString( LOCALE_INVARIANT, NORM_IGNORECASE,
                           lpDSPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPath = lpDSPath + iUserPrefixLen;
    } else if ( (lstrlen(lpDSPath) > iMachPrefixLen)
                && CompareString( LOCALE_INVARIANT, NORM_IGNORECASE,
                                  lpDSPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPath = lpDSPath + iMachPrefixLen;
    }

    pGpContainer = (GPCONTAINER *) LocalAlloc( LPTR, sizeof(GPCONTAINER) );

    if ( pGpContainer == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
        return NULL;
    }

    pGpContainer->bAccessDenied = !bAccessGranted;
    pGpContainer->bFound = bFound;

    if ( dwFlags & GP_MACHINE ) {
        pGpContainer->bMachDisabled = bDisabled;
        pGpContainer->dwMachVersion = dwVersion;
    } else {
        pGpContainer->bUserDisabled  = bDisabled;
        pGpContainer->dwUserVersion  = dwVersion;
    }

    if ( pwszPath ) {

        pGpContainer->pwszDSPath = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszPath) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszDSPath == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        hr = StringCchCopy( pGpContainer->pwszDSPath, lstrlen(pwszPath) + 1, pwszPath );
        ASSERT(SUCCEEDED(hr));
    }

    if ( lpGpoName ) {

        pGpContainer->pwszGPOName = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpGpoName) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszGPOName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        hr = StringCchCopy( pGpContainer->pwszGPOName, lstrlen(lpGpoName) + 1, lpGpoName );
        ASSERT(SUCCEEDED(hr));
    }

    if ( lpDisplayName ) {

        pGpContainer->pwszDisplayName = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpDisplayName) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszDisplayName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        hr = StringCchCopy( pGpContainer->pwszDisplayName, lstrlen(lpDisplayName) + 1, lpDisplayName );
        ASSERT(SUCCEEDED(hr));
    }

    if ( lpFileSysPath ) {

        pGpContainer->pwszFileSysPath = (LPWSTR) LocalAlloc( LPTR, (lstrlen(lpFileSysPath) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszFileSysPath == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        hr = StringCchCopy( pGpContainer->pwszFileSysPath, lstrlen(lpFileSysPath) + 1, lpFileSysPath );
        ASSERT(SUCCEEDED(hr));
    }

    if ( cbSDLen != 0 ) {

        pGpContainer->pSD = (PSECURITY_DESCRIPTOR) LocalAlloc( LPTR, cbSDLen );
        if ( pGpContainer->pSD == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        CopyMemory( pGpContainer->pSD, pSD, cbSDLen );

    }

    pGpContainer->cbSDLen = cbSDLen;

    pGpContainer->bFilterAllowed = bFilterAllowed;

    if ( pwszFilterId ) {

        pGpContainer->pwszFilterId = (LPWSTR) LocalAlloc( LPTR, (lstrlen(pwszFilterId) + 1) * sizeof(WCHAR) );
        if ( pGpContainer->pwszFilterId == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }

        hr = StringCchCopy( pGpContainer->pwszFilterId, lstrlen(pwszFilterId) + 1, pwszFilterId );
        ASSERT(SUCCEEDED(hr));
    }

    if ( szSOM )
    {
        pGpContainer->szSOM = (LPWSTR) LocalAlloc( LPTR, (lstrlen(szSOM) + 1) * sizeof(WCHAR) );
        if ( !pGpContainer->szSOM )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AllocGpContainer: Unable to allocate memory for GpContainer object")));
            goto Exit;
        }
        hr = StringCchCopy( pGpContainer->szSOM, lstrlen(szSOM) + 1, szSOM );
        ASSERT(SUCCEEDED(hr));
    }

    pGpContainer->dwOptions = dwOptions;

    bResult = TRUE;

Exit:

    if ( !bResult )
    {
        LocalFree( pGpContainer->pwszDSPath );
        LocalFree( pGpContainer->pwszGPOName );
        LocalFree( pGpContainer->pwszDisplayName );
        LocalFree( pGpContainer->pwszFileSysPath );
        LocalFree( pGpContainer->pSD );
        LocalFree( pGpContainer->pwszFilterId );
        LocalFree( pGpContainer->szSOM );

        LocalFree( pGpContainer );

        return 0;
    }

    return pGpContainer;
}



//*************************************************************
//
//  FreeGpContainer()
//
//  Purpose:    Frees GpContainer struct
//
//  Parameters: pGpContainer - Gp Container to free
//
//*************************************************************

void FreeGpContainer( GPCONTAINER *pGpContainer )
{
    if ( pGpContainer ) {

        LocalFree( pGpContainer->pwszDSPath );
        LocalFree( pGpContainer->pwszGPOName );
        LocalFree( pGpContainer->pwszDisplayName );
        LocalFree( pGpContainer->pwszFileSysPath );
        LocalFree( pGpContainer->pSD );
        LocalFree( pGpContainer->pwszFilterId );
        LocalFree( pGpContainer->szSOM );
        LocalFree( pGpContainer );

    }
}


//*************************************************************
//
//  FreeSOMList()
//
//  Purpose:    Frees list of SOMs
//
//  Parameters: pSOMList - SOM list to free
//
//*************************************************************

void FreeSOMList( SCOPEOFMGMT *pSOMList )
{
    if ( pSOMList == NULL )
        return;

    while ( pSOMList ) {
        SCOPEOFMGMT *pTemp = pSOMList->pNext;
        FreeSOM( pSOMList );
        pSOMList = pTemp;
    }
}


//*************************************************************
//
//  FreeGpContainerList()
//
//  Purpose:    Frees list of Gp Containers
//
//  Parameters: pGpContainerList - Gp Container list to free
//
//*************************************************************

void FreeGpContainerList( GPCONTAINER *pGpContainerList )
{
    if ( pGpContainerList == NULL )
        return;

    while ( pGpContainerList ) {
        GPCONTAINER *pTemp = pGpContainerList->pNext;
        FreeGpContainer( pGpContainerList );
        pGpContainerList = pTemp;
    }
}

LPTSTR GetSomPath( LPTSTR szContainer )
{
    while (*szContainer) {

        //
        // See if the DN name starts with OU=
        //

        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                           szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
            break;
        }

        //
        // See if the DN name starts with DC=
        //

        else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
            break;
        }


        //
        // Move to the next chunk of the DN name
        //

        while (*szContainer && (*szContainer != TEXT(','))) {
            szContainer++;
        }

        if (*szContainer == TEXT(',')) {
            szContainer++;
        }
    }

    if (!*szContainer) {
        return NULL;
    }

    return szContainer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpreg.cpp ===
//*************************************************************
//
//  Group Policy Support for registry policies
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

static BOOL ExtractKeyOrValueName( LPBYTE * ppData, LPTSTR pszName, DWORD dwNameCch );

//*************************************************************
//
//  DeleteRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that deletes
//              registry policies
//
//  Parameters: lpGPOInfo   -  GPO Information
//              lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DeleteRegistryValue (LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                          LPTSTR lpValueName, DWORD dwType,
                          DWORD dwDataLength, LPBYTE lpData,
                          WCHAR *pwszGPO,
                          WCHAR *pwszSOM, REGHASHTABLE *pHashTable)
{
    DWORD dwDisp;
    HKEY hSubKey;
    LONG lResult;
    INT iStrLen;
    TCHAR szPolicies1[] = TEXT("Software\\Policies");
    TCHAR szPolicies2[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies");
    XLastError xe;


    //
    // Check if there is a keyname
    //

    if (!lpKeyName || !(*lpKeyName)) {
        return TRUE;
    }


    //
    // Check if the key is in one of the policies keys
    //

    iStrLen = lstrlen(szPolicies1);
    if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE, szPolicies1,
                       iStrLen, lpKeyName, iStrLen) != CSTR_EQUAL) {

        iStrLen = lstrlen(szPolicies2);
        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE, szPolicies2,
                           iStrLen, lpKeyName, iStrLen) != CSTR_EQUAL) {
            return TRUE;
        }
    }


    //
    // Check if the value name starts with **
    //

    if (lpValueName && (lstrlen(lpValueName) > 1)) {

        if ( (*lpValueName == TEXT('*')) && (*(lpValueName+1) == TEXT('*')) ) {
            return TRUE;
        }
    }


    //
    // We found a value that needs to be deleted
    //

    if (RegCleanUpValue (lpGPOInfo->hKeyRoot, lpKeyName, lpValueName)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteRegistryValue: Deleted %s\\%s"),
                 lpKeyName, lpValueName));
    } else {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DeleteRegistryValue: Failed to delete %s\\%s"),
                 lpKeyName, lpValueName));
        return FALSE;
    }


    return TRUE;
}


//*************************************************************
//
//  SetRegPermissionsOnPoliciesKey()
//
//  Purpose:    Set permissions on the policy keys to add LocalSystem permission
//              and become the owner
//
//  Parameters: lpGPOInfo   -   GPT information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
// Ideally it should set the owner and permissions for each subkey but that is
// proportinal to the number of subkeys
//
//*************************************************************

BOOL SetRegPermissionsOnPoliciesKey(LPGPOINFO lpGPOInfo, LPTSTR szSubKey)
{
    NTSTATUS                    Status          = STATUS_SUCCESS;
    BOOLEAN                     WasEnabled      = FALSE;
    SECURITY_DESCRIPTOR         sd;
    SID_IDENTIFIER_AUTHORITY    authNT          = SECURITY_NT_AUTHORITY;
    PSID                        psidSystem      = NULL;
    HKEY                        hSubKey         = NULL;
    BOOL                        bElevated       = FALSE;
    BOOL                        bRet            = TRUE;
    XLastError                  xe;
    DWORD                       dwErr           = ERROR_SUCCESS;
    DWORD                       dwDisp          = 0;


    DebugMsg((DM_VERBOSE, TEXT("SetRegPermissionsOnPoliciesKey: Resetting permission on the policy key")));

    if (lpGPOInfo->dwFlags & GP_MACHINE)
    {
        return TRUE;
    }

    DmAssert((szSubKey) && (szSubKey[0]));

    // presetup the sd etc. before elevating privileges

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         xe = GetLastError();
         DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorOwner(&sd, psidSystem, FALSE)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to set security descriptor owner.  Error = %d"), GetLastError()));
        goto Exit;
    }

    Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (!(NT_SUCCESS(Status))) {
        xe = RtlNtStatusToDosError(Status);
        DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to enable privilege.  Error = %d"), (DWORD)xe));
        goto Exit;
    }

    bElevated = TRUE;


    //
    // Open the registry key
    //

    dwErr = RegOpenKeyEx(lpGPOInfo->hKeyRoot,
                           szSubKey,
                           0,
                           WRITE_OWNER,
                           &hSubKey);

    if (dwErr != ERROR_SUCCESS) {
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            bRet = TRUE;
        }
        else {
            xe = dwErr;
            DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to open reg key.  Error = %d"), (DWORD)xe));
        }

        goto Exit;
    }

    dwErr = RegSetKeySecurity (hSubKey, OWNER_SECURITY_INFORMATION, &sd);

    RegCloseKey(hSubKey);

    if (dwErr != ERROR_SUCCESS) {
        xe = dwErr;
        DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to set security, error = %d"), dwErr));
        goto Exit;
    }

    
    if (bElevated)
    {
        Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
        if (!NT_SUCCESS(Status)) {
            DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey:  Failed to restore privilege to previous enabled state")));
            // nothing more we can do
        }
        else {
            bElevated = FALSE;
        }
    }


    if (!MakeRegKeySecure(lpGPOInfo->hToken,
                          lpGPOInfo->hKeyRoot,
                          szSubKey)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey: Failed to secure reg key.")));
        goto Exit;
    }


    bRet = TRUE;

Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (bElevated)
    {
        Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
        if (!NT_SUCCESS(Status)) {
            DebugMsg((DM_WARNING, TEXT("SetRegPermissionsOnPoliciesKey:  Failed to restore privilege to previous enabled state")));
            // nothing more we can do
        }
    }

    return bRet;
}

//*************************************************************
//
//  ResetPolicies()
//
//  Purpose:    Resets the Policies and old Policies key to their
//              original state.
//
//  Parameters: lpGPOInfo   -   GPT information
//              lpArchive   -   Name of archive file
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ResetPolicies (LPGPOINFO lpGPOInfo, LPTSTR lpArchive)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue = 0x91;
    XLastError xe;


    DebugMsg((DM_VERBOSE, TEXT("ResetPolicies: Entering.")));

    //
    // change ownership of the key and make sure that localsystem has full control
    //

    if (!SetRegPermissionsOnPoliciesKey(lpGPOInfo, TEXT("Software\\Policies")))
    {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to set permissions on the policy key(1) with %d"), GetLastError()));
        return FALSE;
    }

    if (!SetRegPermissionsOnPoliciesKey(lpGPOInfo, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")))
    {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to set permissions on the policy key(2) with %d"), GetLastError()));
        return FALSE;
    }


    //
    // Parse the archive file and delete any policies
    //

    if (!ParseRegistryFile (lpGPOInfo, lpArchive,
                            DeleteRegistryValue, NULL, NULL, NULL, NULL, FALSE  )) {
        DWORD   Status;
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: ParseRegistryFile failed with error %d. deleting policy keys"), GetLastError()));

        if ((Status = RegDelnode(lpGPOInfo->hKeyRoot, TEXT("Software\\Policies"))) != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to delete the reg key with %d"), Status));
        }
    
        if ((Status = RegDelnode(lpGPOInfo->hKeyRoot, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"))) != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to delete the reg key with %d"), Status));
        }

        // cannot fail if the path is too long
    }


    //
    // Recreate the new policies key
    //

    lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Policies"),
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult == ERROR_SUCCESS) {

        //
        // Re-apply security
        //

        RegCloseKey (hKey);

        if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                              lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Policies"))) {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to secure reg key.")));
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to create reg key with %d."), lResult));
    }


    //
    // Recreate the old policies key
    //

    lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult == ERROR_SUCCESS) {

        //
        // Re-apply security
        //

        RegCloseKey (hKey);

        if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                              lpGPOInfo->hKeyRoot,
                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"))) {
            DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to secure reg key.")));
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("ResetPolicies: Failed to create reg key with %d."), lResult));
    }


    //
    // If this is user policy, reset the NoDriveTypeAutoRun default value
    //

    if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {

        // override the default value with what the shell team wants on server

        if ((g_ProductType == PT_SERVER) || (g_ProductType == PT_DC))
        {
            DebugMsg((DM_VERBOSE, TEXT("ResetPolicies: resetting shell autorun value for server.")));
            dwValue = 0x95;
        }

        if (RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                          0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_WRITE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

            RegSetValueEx (hKey, TEXT("NoDriveTypeAutoRun"), 0,
                           REG_DWORD, (LPBYTE) &dwValue, sizeof(dwValue));

            RegCloseKey (hKey);
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ResetPolicies: Leaving.")));

    return TRUE;
}




//*************************************************************
//
//  ArchiveRegistryValue()
//
//  Purpose:    Archives a registry value in the specified file
//
//  Parameters: hFile - File handle of archive file
//              lpKeyName    -  Key name
//              lpValueName  -  Value name
//              dwType       -  Registry value type
//              dwDataLength -  Registry value size
//              lpData       -  Registry value
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ArchiveRegistryValue(HANDLE hFile, LPWSTR lpKeyName,
                          LPWSTR lpValueName, DWORD dwType,
                          DWORD dwDataLength, LPBYTE lpData)
{
    BOOL bResult = FALSE;
    DWORD dwBytesWritten;
    DWORD dwTemp;
    const WCHAR cOpenBracket = L'[';
    const WCHAR cCloseBracket = L']';
    const WCHAR cSemiColon = L';';
    XLastError xe;


    //
    // Write the entry to the text file.
    //
    // Format:
    //
    // [keyname;valuename;type;datalength;data]
    //

    // open bracket
    if (!WriteFile (hFile, &cOpenBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write open bracket with %d"),
                 GetLastError()));
        goto Exit;
    }


    // key name
    dwTemp = (lstrlen (lpKeyName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpKeyName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write key name with %d"),
                 GetLastError()));
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // value name
    dwTemp = (lstrlen (lpValueName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpValueName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write value name with %d"),
                 GetLastError()));
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // type
    if (!WriteFile (hFile, &dwType, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data type with %d"),
                 GetLastError()));
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // data length
    if (!WriteFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data type with %d"),
                 GetLastError()));
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write semicolon with %d"),
                 GetLastError()));
        goto Exit;
    }

    // data
    if (!WriteFile (hFile, lpData, dwDataLength, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwDataLength)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write data with %d"),
                 GetLastError()));
        goto Exit;
    }

    // close bracket
    if (!WriteFile (hFile, &cCloseBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ArchiveRegistryValue: Failed to write close bracket with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Sucess
    //

    bResult = TRUE;

Exit:

    return bResult;
}


//*************************************************************
//
//  ParseRegistryFile()
//
//  Purpose:    Parses a registry.pol file
//
//  Parameters: lpGPOInfo          -   GPO information
//              lpRegistry         -   Path to registry.pol
//              pfnRegFileCallback -   Callback function
//              hArchive           -   Handle to archive file
//              pwszGPO            -   Gpo
//              pwszSOM            -   Sdou that the Gpo is linked to
//              pHashTable         -   Hash table for registry keys
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ParseRegistryFile (LPGPOINFO lpGPOInfo, LPTSTR lpRegistry,
                        PFNREGFILECALLBACK pfnRegFileCallback,
                        HANDLE hArchive, WCHAR *pwszGPO,
                        WCHAR *pwszSOM, REGHASHTABLE *pHashTable,
                        BOOL bRsopPlanningMode)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength;
    LPWSTR lpKeyName = 0, lpValueName = 0, lpTemp;
    LPBYTE lpData = NULL;
    WCHAR  chTemp;
    HANDLE hOldToken;
    XLastError xe;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseRegistryFile: Entering with <%s>."),
             lpRegistry));


    //
    // Open the registry file
    //

    if(!bRsopPlanningMode) {
        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to impersonate user")));
            goto Exit;
        }
    }

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if(!bRsopPlanningMode) {
        RevertToUser(&hOldToken);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        if ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
            (GetLastError() == ERROR_PATH_NOT_FOUND))
        {
            bResult = TRUE;
            goto Exit;
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: CreateFile failed with %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_NO_REGISTRY);
            ev.AddArg(lpRegistry); ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read signature with %d"),
                 GetLastError()));
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Invalid file signature")));
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read version number with %d"),
                 GetLastError()));
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        xe = ERROR_INVALID_DATA;
        DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Invalid file version")));
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;
        dwTemp = 0;

        while (dwTemp < MAX_KEYNAME_SIZE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read keyname character with %d"),
                         GetLastError()));
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;

            dwTemp++;
        }

        if (dwTemp >= MAX_KEYNAME_SIZE)
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Keyname exceeded max size")));
            goto Exit;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;
        dwTemp = 0;

        while (dwTemp < MAX_VALUENAME_SIZE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read valuename character with %d"),
                         GetLastError()));
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;

            dwTemp++;
        }

        if (dwTemp >= MAX_VALUENAME_SIZE)
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Valuename exceeded max size")));
            goto Exit;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                xe = ERROR_INVALID_DATA;
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read first character with %d"),
                         GetLastError()));
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read type with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip semicolon with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to data length with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip semicolon with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to allocate memory for data with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to read data with %d"),
                     GetLastError()));
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Failed to skip closing bracket with %d"),
                     GetLastError()));
            goto Exit;
        }

        if (chTemp != L']')
        {
            xe = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Expected to find ], but found %c"),
                     chTemp));
            goto Exit;
        }


        //
        // Call the callback function
        //

        if (!pfnRegFileCallback (lpGPOInfo, lpKeyName, lpValueName,
                                 dwType, dwDataLength, lpData,
                                 pwszGPO, pwszSOM, pHashTable ))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: Callback function returned false.")));
            goto Exit;
        }


        //
        // Archive the data if appropriate
        //

        if (hArchive) {
            if (!ArchiveRegistryValue(hArchive, lpKeyName, lpValueName,
                                      dwType, dwDataLength, lpData)) {
                DebugMsg((DM_WARNING, TEXT("ParseRegistryFile: ArchiveRegistryValue returned false.")));
            }
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if ( !bResult )
    {
        CEvents ev(TRUE, EVENT_REGISTRY_TEMPLATE_ERROR);
        ev.AddArg(lpRegistry ? lpRegistry : TEXT("")); ev.AddArgWin32Error( xe ); ev.Report();
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseRegistryFile: Leaving.")));
    if (lpData) {
        LocalFree (lpData);
    }
    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle (hFile);
    }
    if ( lpKeyName ) {
        LocalFree (lpKeyName);
    }
    if ( lpValueName ) {
        LocalFree (lpValueName);
    }

    return bResult;
}


//*************************************************************
//
//  ProcessRegistryValue()
//
//  Purpose: Callback passed to ParseRegistryFile from ProcessRegistryFiles. Invokes AddRegHashEntry
//                  with appropriate parameters depending on the registry policy settings.
//
//  Parameters:
//                          pUnused -    Not used. It si there only to conform to the signature
//                                              expected by ParseRegistryFile.
//                          lpKeyName - registry key name
//                          lpValueName - Registry value name
//                          dwType -    Registry value type
//                          dwDataLength - Length of registry value data.
//                          lpData - Regsitry value data
//                          *pwszGPO - GPO associated with this registry setting
//                          *pwszSOM - SOM associated with the GPO
//                          *pHashTable - Hash table containing registry policy data for a policy target.
//
//  Return:     TRUE if successful
//                  FALSE if an error occurs
//
//*************************************************************

BOOL ProcessRegistryValue (   void* pUnused,
                                    LPTSTR lpKeyName,
                                    LPTSTR lpValueName,
                                    DWORD dwType,
                                    DWORD dwDataLength,
                                    LPBYTE lpData,
                                    WCHAR *pwszGPO,
                                    WCHAR *pwszSOM,
                                    REGHASHTABLE *pHashTable)
{
    BOOL bLoggingOk = TRUE;
    BOOL bStatus;

    //
    // Special case some values
    //

    if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**del."), 6, lpValueName, 6) == 2)
    {
        LPTSTR lpRealValueName = lpValueName + 6;


        //
        // Delete one specific value
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                      lpRealValueName, 0, 0, NULL,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**delvals."), 10, lpValueName, 10) == 2)
    {

        //
        // Delete all values in the destination key
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEALLVALUES, lpKeyName,
                                      NULL, 0, 0, NULL,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );

    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**DeleteValues"), 14, lpValueName, 14) == 2)
    {
        TCHAR szValueName[MAX_VALUENAME_SIZE];

        bLoggingOk = TRUE;

        while ( *lpData )
        {
            bStatus = ExtractKeyOrValueName( &lpData, szValueName, MAX_VALUENAME_SIZE );

            // This failure must be fatal.
            if ( ! bStatus )
            {
                bLoggingOk = FALSE;
                break;
            }

            // 
            // Failures here have always allowed processing to continue.  Not sure 
            // why, but not worth risking some wierd regression to change it.
            //
            bStatus = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                          szValueName, 0, 0, NULL,
                                          pwszGPO, pwszSOM, lpValueName, TRUE );
            if ( ! bStatus )
                bLoggingOk = FALSE;
        }
    }

    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**DeleteKeys"), 12, lpValueName, 12) == 2)
    {
        TCHAR szKeyName[MAX_KEYNAME_SIZE];

        bLoggingOk = TRUE;

        while ( *lpData ) 
        {
            bStatus = ExtractKeyOrValueName( &lpData, szKeyName, MAX_KEYNAME_SIZE );

            // This failure must be fatal.
            if ( ! bStatus )
            {
                bLoggingOk = FALSE;
                break;
            }

            // 
            // Failures here have always allowed processing to continue.  Not sure 
            // why, but not worth risking some wierd regression to change it.
            //
            bStatus = AddRegHashEntry( pHashTable, REG_DELETEKEY, lpKeyName,
                                          NULL, 0, 0, NULL,
                                          pwszGPO, pwszSOM, lpValueName, TRUE );
            if ( ! bStatus )
                bLoggingOk = FALSE;
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**soft."), 7, lpValueName, 7) == 2)
    {
        //
        // In planning mode we will assume the value does not exist in the target computer.
        // Therefore, we set it if no value exists in the hash table.
        //
        // Soft add is dealt with differently in planning mode vs. diag mode.
        // In diag mode, check is done while processing policy and it is logged as a add value
        // if the key doesn't exist.
        // In planning mode, key is not supposed to exist beforehand and the hash table itself is
        // used to determine whether to add the key or not.


        LPTSTR lpRealValueName = lpValueName + 7;

        bLoggingOk = AddRegHashEntry( pHashTable, REG_SOFTADDVALUE, lpKeyName,
                                      lpRealValueName, dwType, dwDataLength, lpData,
                                      pwszGPO, pwszSOM, lpValueName, TRUE );

    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**SecureKey"), 11, lpValueName, 11) == 2)
    {
        // There is nothing to do here.
    } else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**Comment:"), 10, lpValueName, 10) == 2)
    {
        //
        // Comment - can be ignored
        //
    }
    else
    {

        //
        // AddRegHashEntry needs to log a key being logged but no values.
        //

        bLoggingOk = AddRegHashEntry( pHashTable, REG_ADDVALUE, lpKeyName,
                                      lpValueName, dwType, dwDataLength, lpData,
                                      pwszGPO, pwszSOM, TEXT(""), TRUE );
    }

    return bLoggingOk;
}


//*************************************************************
//
//  ResetRegKeySecurity
//
//  Purpose:    Resets the security on a user's key
//
//  Parameters: hKeyRoot    -   Handle to the root of the hive
//              lpKeyName   -   Subkey name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ResetRegKeySecurity (HKEY hKeyRoot, LPTSTR lpKeyName)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwSize = 0;
    LONG lResult;
    HKEY hSubKey;
    XLastError xe;


    RegGetKeySecurity(hKeyRoot, DACL_SECURITY_INFORMATION, pSD, &dwSize);

    if (!dwSize) {
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: RegGetKeySecurity returned 0")));
       return FALSE;
    }

    pSD = LocalAlloc (LPTR, dwSize);

    if (!pSD) {
       xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to allocate memory")));
       return FALSE;
    }


    lResult = RegGetKeySecurity(hKeyRoot, DACL_SECURITY_INFORMATION, pSD, &dwSize);
    if (lResult != ERROR_SUCCESS) {
        xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to query key security with %d"),
                lResult));
       LocalFree (pSD);
       return FALSE;
    }


    lResult = RegOpenKeyEx(hKeyRoot,
                         lpKeyName,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &hSubKey);

    if (lResult != ERROR_SUCCESS) {
       xe = GetLastError();
       DebugMsg((DM_WARNING, TEXT("ResetRegKeySecurity: Failed to open sub key with %d"),
                lResult));
       LocalFree (pSD);
       return FALSE;
    }

    lResult = RegSetKeySecurity (hSubKey, DACL_SECURITY_INFORMATION, pSD);

    RegCloseKey (hSubKey);
    LocalFree (pSD);

    if (lResult != ERROR_SUCCESS) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ResetRegKeySecure: Failed to set security, error = %d"), lResult));
        return FALSE;
    }

    return TRUE;

}


//*************************************************************
//
//  SetRegistryValue()
//
//  Purpose:    Callback from ParseRegistryFile that sets
//              registry policies
//
//  Parameters: lpGPOInfo   -  GPO Information
//              lpKeyName   -  Key name
//              lpValueName -  Value name
//              dwType      -  Registry data type
//              lpData      -  Registry data
//              pwszGPO     -   Gpo
//              pwszSOM     -   Sdou that the Gpo is linked to
//              pHashTable  -   Hash table for registry keys
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetRegistryValue (LPGPOINFO lpGPOInfo, LPTSTR lpKeyName,
                       LPTSTR lpValueName, DWORD dwType,
                       DWORD dwDataLength, LPBYTE lpData,
                       WCHAR *pwszGPO,
                       WCHAR *pwszSOM, REGHASHTABLE *pHashTable)
{
    DWORD dwDisp;
    HKEY hSubKey;
    LONG lResult;
    BOOL bLoggingOk = TRUE;
    BOOL bRsopLogging = (pHashTable != NULL);  // Is diagnostic mode Rsop logging enabled ?
    BOOL bUseValueName = FALSE;
    BOOL bRegOpSuccess =  TRUE;
    XLastError xe;
    
    //
    // Special case some values
    //
    if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**del."), 6, lpValueName, 6) == 2)
    {
        LPTSTR lpRealValueName = lpValueName + 6;

        //
        // Delete one specific value
        //

        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            lResult = RegDeleteValue(hSubKey, lpRealValueName);

            if ((lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND))
            {
                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted value <%s>."),
                         lpRealValueName));
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_DELETED_VALUE);
                    ev.AddArg(lpRealValueName); ev.Report();
                }

                if ( bRsopLogging ) {
                    bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                                  lpRealValueName, 0, 0, NULL,
                                                  pwszGPO, pwszSOM, lpValueName, TRUE );
                    if (!bLoggingOk) {
                        DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE <%s>."), lpRealValueName));
                        pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to delete value <%s> with %d"),
                         lpRealValueName, lResult));
                xe = lResult;
                CEvents ev(TRUE, EVENT_FAIL_DELETE_VALUE);
                ev.AddArg(lpRealValueName); ev.AddArgWin32Error(lResult); ev.Report();
                bRegOpSuccess = FALSE;
            }

            RegCloseKey (hSubKey);
        }
        else if (lResult == ERROR_FILE_NOT_FOUND) {
            
            //
            // Log into rsop even if the key is not found
            //

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                              lpRealValueName, 0, 0, NULL,
                                              pwszGPO, pwszSOM, lpValueName, TRUE );
                if (!bLoggingOk) {
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE (notfound) <%s>."), lpRealValueName));
                }
            }
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**delvals."), 10, lpValueName, 10) == 2)
    {

        //
        // Delete all values in the destination key
        //
        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE | KEY_READ, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            if (!bRsopLogging)
                bRegOpSuccess = DeleteAllValues(hSubKey);
            else
                bRegOpSuccess = RsopDeleteAllValues(hSubKey, pHashTable, lpKeyName,
                                              pwszGPO, pwszSOM, lpValueName, &bLoggingOk );

            DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted all values in <%s>."),
                     lpKeyName));
            RegCloseKey (hSubKey);

            if (!bRegOpSuccess) {
                xe = GetLastError();
            }

            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: DeleteAllvalues finished for %s. bRegOpSuccess = %s, bLoggingOk = %s."), 
                      lpKeyName, (bRegOpSuccess ? TEXT("TRUE") : TEXT("FALSE")), (bLoggingOk ? TEXT("TRUE") : TEXT("FALSE"))));

        }
        else if (lResult == ERROR_FILE_NOT_FOUND) {
            
            //
            // Log into rsop even if the key is not found
            // as just deleteallvalues
            //

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEALLVALUES, lpKeyName,
                              NULL, 0, 0, NULL,
                              pwszGPO, pwszSOM, lpValueName, TRUE );

                if (!bLoggingOk) {
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEALLVALUES (notfound) key - <%s>, value <%s>."), lpKeyName, lpValueName));
                }
            }
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**DeleteValues"), 14, lpValueName, 14) == 2)
    {
        TCHAR   szValueName[MAX_VALUENAME_SIZE];
        LONG    lKeyResult;

        //
        // Delete the values  (semi-colon separated)
        //

        lKeyResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_WRITE, &hSubKey);

        while ( *lpData ) 
        {
            szValueName[0] = 0;

            if ( ExtractKeyOrValueName( &lpData, szValueName, MAX_VALUENAME_SIZE ) )
                lResult = ERROR_SUCCESS;
            else 
                lResult = ERROR_INVALID_DATA;

            // Check for OpenKey failures.
            if ( (lResult == ERROR_SUCCESS) && 
                 (lKeyResult != ERROR_SUCCESS) && (lKeyResult != ERROR_FILE_NOT_FOUND) )
                lResult = lKeyResult;

            if ( (lKeyResult == ERROR_SUCCESS) && (lResult == ERROR_SUCCESS) )
            {
                lResult = RegDeleteValue (hSubKey, szValueName);

                if ((lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND))
                {
                    DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted value <%s>."),
                             szValueName));
                    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                        CEvents ev(FALSE, EVENT_DELETED_VALUE);
                        ev.AddArg(szValueName); ev.Report();
                    }
                }
            }

            //
            // Checking if value name is valid, key open succeeded, and no unexpected 
            // error from value deletion.  Note that lKeyResult is not needed because 
            // it's value was factored into lResult above.
            //
            if ( (lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND) ) 
            {
                if ( bRsopLogging ) {
                    bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                                  szValueName, 0, 0, NULL,
                                                  pwszGPO, pwszSOM, lpValueName, TRUE );

                    if (!bLoggingOk) 
                    {
                        // 
                        // The debug message has always been different for the case where the key 
                        // existed and where the key did not exist.  This is merging what used 
                        // to be duplicated code.
                        //
                        if ( ERROR_SUCCESS == lKeyResult )
                        {
                            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE value <%s>."), szValueName));
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEVALUE value (not found case) <%s>."), szValueName));
                        }
                        pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to delete value <%s> with %d"),
                         szValueName, lResult));
                CEvents ev(TRUE, EVENT_FAIL_DELETE_VALUE);
                ev.AddArg(szValueName); ev.AddArgWin32Error(lResult); ev.Report();
                xe = lResult;
                bRegOpSuccess = FALSE;
                if ( ERROR_INVALID_DATA == lResult )
                    break;
            }
        }

        // lKeyResult is not changed after the intial call to RegOpenKey.
        if (lKeyResult == ERROR_SUCCESS)
        {
            RegCloseKey (hSubKey);
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**DeleteKeys"), 12, lpValueName, 12) == 2)
    {
        TCHAR szKeyName[MAX_KEYNAME_SIZE];
        BOOL  bStatus;

        while ( *lpData ) 
        {
            bStatus = ExtractKeyOrValueName( &lpData, szKeyName, MAX_KEYNAME_SIZE );

            if ( bStatus )
            {
                lResult = RegDelnode (lpGPOInfo->hKeyRoot, szKeyName);
                if ( ERROR_SUCCESS == lResult )
                {
                    DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Deleted key <%s>."),
                             szKeyName));
                    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                        CEvents ev(FALSE, EVENT_DELETED_KEY);
                        ev.AddArg(szKeyName); ev.Report();
                    }
                }
            }
            else
            {
                lResult = ERROR_INVALID_DATA;
            }

            if ( lResult != ERROR_SUCCESS )
            {
                xe = lResult;
                bRegOpSuccess = FALSE;
                // This is fatal and we must bail out, szKeyName is bad so skip the DebugMsg.
                if ( ERROR_INVALID_DATA == lResult )
                    break;
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: RegDelnode for key <%s>."), szKeyName));
            }

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEKEY, szKeyName,
                                              NULL, 0, 0, NULL,
                                              pwszGPO, pwszSOM, lpValueName, TRUE );
                if (!bLoggingOk) { 
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_DELETEKEY  <%s>."), szKeyName));
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                }
            }

        }

    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**soft."), 7, lpValueName, 7) == 2)
    {

        //
        // "soft" value, only set this if it doesn't already
        // exist in destination
        //

        lResult = RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, KEY_QUERY_VALUE, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            TCHAR TmpValueData[MAX_PATH+1];
            DWORD dwSize=sizeof(TmpValueData);

            lResult = RegQueryValueEx(hSubKey, lpValueName + 7,
                                      NULL,NULL,(LPBYTE) TmpValueData,
                                      &dwSize);

            RegCloseKey (hSubKey);

            if (lResult != ERROR_SUCCESS)
            {
                lpValueName += 7;
                bUseValueName = TRUE;
                goto SetValue;
            }
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**SecureKey"), 11, lpValueName, 11) == 2)
    {
        //
        // Secure / unsecure a key (user only)
        //
        if (!(lpGPOInfo->dwFlags & GP_MACHINE))
        {
            if (*((LPDWORD)lpData) == 1)
            {
                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Securing key <%s>."),
                         lpKeyName));
                bRegOpSuccess = MakeRegKeySecure(lpGPOInfo->hToken, lpGPOInfo->hKeyRoot, lpKeyName);
            }
            else
            {

                DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Unsecuring key <%s>."),
                         lpKeyName));

                bRegOpSuccess = ResetRegKeySecurity (lpGPOInfo->hKeyRoot, lpKeyName);
            }

            if (!bRegOpSuccess) {
                xe = GetLastError();
            }
        }
    }
    else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                       TEXT("**Comment:"), 10, lpValueName, 10) == 2)
    {
        //
        // Comment - can be ignored
        //

        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: Found comment %s."),
                 (lpValueName+10)));
    }
    else
    {
SetValue:
        //
        // Save registry value
        //

        lResult = RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                        lpKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_WRITE, NULL, &hSubKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
        {

            if ((dwType == REG_NONE) && (dwDataLength == 0) &&
                (*lpValueName == L'\0'))
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                lResult = RegSetValueEx (hSubKey, lpValueName, 0, dwType,
                                         lpData, dwDataLength);
            }

            if ( bRsopLogging ) {
                bLoggingOk = AddRegHashEntry( pHashTable, REG_ADDVALUE, lpKeyName,
                                              lpValueName, dwType, dwDataLength, lpData,
                                              pwszGPO, pwszSOM, bUseValueName ? lpValueName : TEXT(""), TRUE );
                if (!bLoggingOk) {
                    DebugMsg((DM_WARNING, TEXT("SetRegistryValue: AddRegHashEntry failed for REG_ADDVALUE key <%s>, value <%s>."), lpKeyName, lpValueName));
                    pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                }
            }


            RegCloseKey (hSubKey);

            if (lResult == ERROR_SUCCESS)
            {
                switch (dwType) {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s => %s  [OK]"),
                                 lpValueName, (LPTSTR)lpData));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_STRING_VALUE);
                            ev.AddArg(lpValueName); ev.AddArg((LPTSTR)lpData); ev.Report();
                        }

                        break;

                    case REG_DWORD:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s => %d  [OK]"),
                                 lpValueName, *((LPDWORD)lpData)));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_DWORD_VALUE);
                            ev.AddArg(lpValueName); ev.AddArg((DWORD)*lpData); ev.Report();
                        }

                        break;

                    case REG_NONE:
                        break;

                    default:
                        DebugMsg((DM_VERBOSE, TEXT("SetRegistryValue: %s was set successfully"),
                                 lpValueName));
                        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                            CEvents ev(FALSE, EVENT_SET_UNKNOWN_VALUE);
                            ev.AddArg(lpValueName); ev.Report();
                        }
                        break;
                }


                if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                   TEXT("Control Panel\\Colors"), 20, lpKeyName, 20) == 2) {
                    lpGPOInfo->dwFlags |= GP_REGPOLICY_CPANEL;

                } else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                   TEXT("Control Panel\\Desktop"), 21, lpKeyName, 21) == 2) {
                    lpGPOInfo->dwFlags |= GP_REGPOLICY_CPANEL;
                }


            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to set value <%s> with %d"),
                         lpValueName, lResult));
                xe = lResult;
                CEvents ev(TRUE, EVENT_FAILED_SET);
                ev.AddArg(lpValueName); ev.AddArgWin32Error(lResult); ev.Report();
                bRegOpSuccess = FALSE;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("SetRegistryValue: Failed to open key <%s> with %d"),
                     lpKeyName, lResult));
            xe = lResult;
            CEvents ev(TRUE, EVENT_FAILED_CREATE);
            ev.AddArg(lpKeyName); ev.AddArgWin32Error(lResult); ev.Report();
            bRegOpSuccess = FALSE;
        }
    }

    return bLoggingOk && bRegOpSuccess;
}

BOOL ExtractKeyOrValueName( LPBYTE * ppData, LPTSTR pszName, DWORD dwNameCch )
{
    LPTSTR lpszNameBegin, lpszNameEnd;

    lpszNameBegin = (LPTSTR) *ppData;

    while ( *lpszNameBegin == TEXT(' ') ) 
        lpszNameBegin++;

    lpszNameEnd = lpszNameBegin;

    while ( *lpszNameEnd && *lpszNameEnd != TEXT(';') ) 
        lpszNameEnd++;

    if ( dwNameCch < (DWORD) (lpszNameEnd - lpszNameBegin + 1) )
    {
        DebugMsg((DM_WARNING, 
                  TEXT("Key or value name %s of size %d exceeds maximum.  Further processing aborted."),
                  pszName,
                  lpszNameEnd - lpszNameBegin));
        return FALSE;
    }

    (void) StringCchCopyN( pszName, dwNameCch, lpszNameBegin, lpszNameEnd - lpszNameBegin );
    pszName[lpszNameEnd - lpszNameBegin] = 0;

    while ( *lpszNameEnd == TEXT(';') )
            lpszNameEnd++;

    *ppData = (LPBYTE) lpszNameEnd;

    return TRUE;
}

//*************************************************************
//
//  ProcessGPORegistryPolicy()
//
//  Purpose:    Proceses GPO registry policy
//
//  Parameters: lpGPOInfo       -   GPO information
//              pChangedGPOList - Link list of changed GPOs
//
//  Notes:      This function is called in the context of
//              local system, which allows us to create the
//              directory, write to the file etc.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPORegistryPolicy (LPGPOINFO lpGPOInfo,
                               PGROUP_POLICY_OBJECT pChangedGPOList, HRESULT *phrRsopLogging)
{
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szPath[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd, lpGPOComment;
    HANDLE hFile;
    DWORD dwTemp, dwBytesWritten;
    REGHASHTABLE *pHashTable = NULL;
    WIN32_FIND_DATA findData;
    ADMFILEINFO *pAdmFileCache = NULL;
    XLastError xe;
    HRESULT hr = S_OK;
    BOOL bStatus = FALSE;

    *phrRsopLogging = S_OK;

    //
    // Claim the registry lock before starting registry processing -- this will
    // allow internal components to synchronize on registry processing rather than
    // all policy processing, which means a much shorter wait time
    //
    // We wait for 60 seconds -- if the application does not release the lock
    // in that time, we continue, as 60 seconds should be sufficient to read
    // a few registry settings
    //

    HANDLE hRegistrySection = EnterCriticalPolicySectionEx(
        lpGPOInfo->dwFlags & GP_MACHINE,
        60000,
        ECP_REGISTRY_ONLY);

    if ( ! hRegistrySection )
    {
        goto ProcessGPORegistryPolicy_Exit;
    }

    //
    // Get the path name to the appropriate profile
    //

    szPath[0] = TEXT('\0');
    dwTemp = ARRAYSIZE(szPath);

    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        GetAllUsersProfileDirectoryEx(szPath, &dwTemp, TRUE);
    } else {
        GetUserProfileDirectory(lpGPOInfo->hToken, szPath, &dwTemp);
    }

    if (szPath[0] == TEXT('\0')) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to get path to profile root")));
        goto ProcessGPORegistryPolicy_Exit;
    }


    //
    // Tack on the archive file name
    //

    DmAssert( lstrlen(szPath) + lstrlen(TEXT("\\ntuser.pol")) < MAX_PATH );

    hr = StringCchCat (szPath, sizeof(szPath)/sizeof(WCHAR), TEXT("\\ntuser.pol"));
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        goto ProcessGPORegistryPolicy_Exit;
    }

    //
    // Delete any existing policies
    //

    if (!ResetPolicies (lpGPOInfo, szPath)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ResetPolicies failed.")));
        // couldn't undo the values set in local ntuser.pol
        // seems like the best we can do is abandon cleanup and
        // and apply new policies. 
        // If we return here, the user has a better chance of not 
        // getting tattooed though...

        // event is already logged
    }


    //
    // Delete the old archive file
    //

    SetFileAttributes (szPath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile (szPath);

    //
    // Recreate the archive file
    //

    hFile = CreateFile (szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to create archive file with %d"),
                 GetLastError()));
        goto ProcessGPORegistryPolicy_Exit;
    }

    //
    // Set the header information in the archive file
    //

    dwTemp = REGFILE_SIGNATURE;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to write signature with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        goto ProcessGPORegistryPolicy_Exit;
    }


    dwTemp = REGISTRY_FILE_VERSION;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to write version number with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        goto ProcessGPORegistryPolicy_Exit;
    }

    if ( lpGPOInfo->pWbemServices ) {

        //
        // If Rsop logging is enabled, setup hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            CloseHandle (hFile);
            *phrRsopLogging = HRESULT_FROM_WIN32(GetLastError());
            xe = GetLastError();
            goto ProcessGPORegistryPolicy_Exit;
        }

    }

    //
    // Now loop through the GPOs applying the registry.pol files
    //

    lpGPO = pChangedGPOList;

    while ( lpGPO ) {

        //
        // Add the source GPO comment
        //
        DWORD dwCommentLength = lstrlen(lpGPO->lpDisplayName) + 25;
        lpGPOComment = (LPTSTR) LocalAlloc (LPTR, (dwCommentLength) * sizeof(TCHAR));

        if (lpGPOComment) {

            hr = StringCchCopy (szKeyName, ARRAYSIZE(szKeyName), TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Objects\\"));
            ASSERT(SUCCEEDED(hr));
            hr = StringCchCat (szKeyName, ARRAYSIZE(szKeyName), lpGPO->szGPOName);
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCopy (lpGPOComment, dwCommentLength, TEXT("**Comment:GPO Name: "));
            ASSERT(SUCCEEDED(hr));
            hr = StringCchCat (lpGPOComment, dwCommentLength, lpGPO->lpDisplayName);
            ASSERT(SUCCEEDED(hr));

            if (!ArchiveRegistryValue(hFile, szKeyName, lpGPOComment, REG_SZ, 0, NULL)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ArchiveRegistryValue returned false.")));
            }

            LocalFree (lpGPOComment);
        }


        //
        // Build the path to registry.pol
        //

        DmAssert( lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 < MAX_PATH );

        hr = StringCchCopy (szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpGPO->lpFileSysPath);
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            CloseHandle (hFile);
            FreeHashTable( pHashTable );
            goto ProcessGPORegistryPolicy_Exit;
        }

        lpEnd = CheckSlash (szBuffer);

        hr = StringCchCopy (lpEnd, sizeof(szBuffer)/sizeof(WCHAR) - (lpEnd - szBuffer), c_szRegistryPol);
        if (FAILED(hr)) {
            xe = ERROR_INSUFFICIENT_BUFFER;
            CloseHandle (hFile);
            FreeHashTable( pHashTable );
            goto ProcessGPORegistryPolicy_Exit;
        }

        if (!ParseRegistryFile (lpGPOInfo, szBuffer, SetRegistryValue, hFile,
                                lpGPO->lpDSPath, lpGPO->lpLink, pHashTable, FALSE )) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed.")));
            CloseHandle (hFile);
            FreeHashTable( pHashTable );
            // no logging is done in any case
            goto ProcessGPORegistryPolicy_Exit;
        }

        if ( lpGPOInfo->pWbemServices ) {

            //
            // Log Adm data
            //

            HANDLE hFindFile;
            WIN32_FILE_ATTRIBUTE_DATA attrData;
            DWORD dwFilePathSize = lstrlen( lpGPO->lpFileSysPath );
            TCHAR szComputerName[3*MAX_COMPUTERNAME_LENGTH + 1];
            DWORD dwSize;

            dwSize = 3*MAX_COMPUTERNAME_LENGTH + 1;
            if (!GetComputerName(szComputerName, &dwSize)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Couldn't get the computer Name with error %d."), GetLastError()));
                szComputerName[0] = TEXT('\0');
            }


            dwSize = dwFilePathSize + MAX_PATH;

            WCHAR *pwszEnd;
            WCHAR *pwszFile = (WCHAR *) LocalAlloc( LPTR, dwSize * sizeof(WCHAR) );

            if ( pwszFile == 0 ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: ParseRegistryFile failed to allocate memory.")));
                CloseHandle (hFile);
                FreeHashTable( pHashTable );
                // no logging is done in any case
                goto ProcessGPORegistryPolicy_Exit;
            }

            hr = StringCchCopy( pwszFile, dwSize, lpGPO->lpFileSysPath );
            ASSERT(SUCCEEDED(hr));

            //
            // Strip off trailing 'machine' or 'user'
            //

            pwszEnd = pwszFile + lstrlen( pwszFile );

            if ( lpGPOInfo->dwFlags & GP_MACHINE )
                pwszEnd -= 7;   // length of "machine"
            else
                pwszEnd -= 4;   // length of "user"

            hr = StringCchCopy( pwszEnd, dwSize - (pwszEnd - pwszFile), L"Adm\\*.adm");
            ASSERT(SUCCEEDED(hr));

            //
            // Remember end point so that the actual Adm filename can be
            // easily concatenated.
            //

            pwszEnd = pwszEnd + lstrlen( L"Adm\\" );

            //
            // Enumerate all Adm files
            //

            hFindFile = FindFirstFile( pwszFile, &findData);

            if ( hFindFile != INVALID_HANDLE_VALUE )
            {
                do
                {
                    if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                    {
                        DmAssert( dwFilePathSize + lstrlen(findData.cFileName) + lstrlen( L"\\Adm\\" ) < dwSize );

                        hr = StringCchCopy( pwszEnd, dwSize - (pwszEnd - pwszFile), findData.cFileName);
                        if (FAILED(hr)) {
                            if (pHashTable->hrError == S_OK)
                                    pHashTable->hrError = ERROR_INSUFFICIENT_BUFFER;
                        }
                        else {
                            ZeroMemory (&attrData, sizeof(attrData));
    
                            if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 ) {
    
                                if ( !AddAdmFile( pwszFile, lpGPO->lpDSPath, &attrData.ftLastWriteTime,
                                                  szComputerName, &pAdmFileCache ) ) {
                                    DebugMsg((DM_WARNING,
                                              TEXT("ProcessGPORegistryPolicy: AddAdmFile failed.")));
    
                                    if (pHashTable->hrError == S_OK)
                                        pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
                                }
    
                            }
                        }
                    }   // if findData & file_attr_dir
                }  while ( FindNextFile(hFindFile, &findData) );//  do

                FindClose(hFindFile);

            }   // if hfindfile

            LocalFree( pwszFile );

        }   //  if rsoploggingenabled

        lpGPO = lpGPO->pNext;
    }

    //
    // Log registry data to Cimom database
    //

    if ( lpGPOInfo->pWbemServices ) {

        if ( ! LogRegistryRsopData( lpGPOInfo->dwFlags, pHashTable, lpGPOInfo->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Registry Rsop data. Continuing.")));

            if (pHashTable->hrError == S_OK)
                pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
        }
        if ( ! LogAdmRsopData( pAdmFileCache, lpGPOInfo->pWbemServices ) ) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Adm Rsop data. Continuing.")));

            if (pHashTable->hrError == S_OK)
                pHashTable->hrError = HRESULT_FROM_WIN32(GetLastError());
        }

        *phrRsopLogging = pHashTable->hrError;
    }


    FreeHashTable( pHashTable );
    FreeAdmFileCache( pAdmFileCache );

    CloseHandle (hFile);

#if 0
    //
    // Set the security on the file
    //

    if (!MakeFileSecure (szPath, 0)) {
        DebugMsg((DM_WARNING, TEXT("ProcessGPORegistryPolicy: Failed to set security on the group policy registry file with %d"),
                 GetLastError()));
    }
#endif

    bStatus = TRUE;

ProcessGPORegistryPolicy_Exit:    

    if ( hRegistrySection )
    {
        LeaveCriticalPolicySection( hRegistrySection );
    }

    return bStatus;
}


//*************************************************************
//
//  AddAdmFile()
//
//  Purpose:    Prepends to list of Adm files
//
//  Parameters: pwszFile       - File path
//              pwszGPO        - Gpo
//              pftWrite       - Last write time
//              ppAdmFileCache - List of Adm files processed
//
//*************************************************************

BOOL AddAdmFile( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite, WCHAR *szComputerName,
                 ADMFILEINFO **ppAdmFileCache )
{
    XPtrLF<WCHAR> xszLongPath;
    LPTSTR pwszUNCPath;

    DebugMsg((DM_VERBOSE, TEXT("AllocAdmFileInfo: Adding File name <%s> to the Adm list."), pwszFile));
    if ((szComputerName) && (*szComputerName) && (!IsUNCPath(pwszFile))) {
        xszLongPath = MakePathUNC(pwszFile, szComputerName);

        if (!xszLongPath) {
            DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to Make the path UNC with error %d."), GetLastError()));
            return FALSE;
        }
        pwszUNCPath = xszLongPath;
    }
    else
        pwszUNCPath = pwszFile;


    ADMFILEINFO *pAdmInfo = AllocAdmFileInfo( pwszUNCPath, pwszGPO, pftWrite );
    if ( pAdmInfo == NULL )
        return FALSE;

    pAdmInfo->pNext = *ppAdmFileCache;
    *ppAdmFileCache = pAdmInfo;

    return TRUE;
}


//*************************************************************
//
//  FreeAdmFileCache()
//
//  Purpose:    Frees Adm File list
//
//  Parameters: pAdmFileCache - List of Adm files to free
//
//
//*************************************************************

void FreeAdmFileCache( ADMFILEINFO *pAdmFileCache )
{
    ADMFILEINFO *pNext;

    while ( pAdmFileCache ) {
        pNext = pAdmFileCache->pNext;
        FreeAdmFileInfo( pAdmFileCache );
        pAdmFileCache = pNext;
    }
}


//*************************************************************
//
//  AllocAdmFileInfo()
//
//  Purpose:    Allocates a new struct for ADMFILEINFO
//
//  Parameters: pwszFile  -  File name
//              pwszGPO   -  Gpo
//              pftWrite  -  Last write time
//
//
//*************************************************************

ADMFILEINFO * AllocAdmFileInfo( WCHAR *pwszFile, WCHAR *pwszGPO, FILETIME *pftWrite )
{
    XLastError xe;
    HRESULT hr = S_OK;

    ADMFILEINFO *pAdmFileInfo = (ADMFILEINFO *) LocalAlloc( LPTR, sizeof(ADMFILEINFO) );
    if  ( pAdmFileInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        return NULL;
    }

    pAdmFileInfo->pwszFile = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszFile) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszFile == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    pAdmFileInfo->pwszGPO = (WCHAR *) LocalAlloc( LPTR, (lstrlen(pwszGPO) + 1) * sizeof(WCHAR) );
    if ( pAdmFileInfo->pwszGPO == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AllocAdmFileInfo: Failed to allocate memory.")));
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo );
        return NULL;
    }

    hr = StringCchCopy( pAdmFileInfo->pwszFile, lstrlen(pwszFile) + 1, pwszFile );
    ASSERT(SUCCEEDED(hr));
    hr = StringCchCopy( pAdmFileInfo->pwszGPO, lstrlen(pwszGPO) + 1, pwszGPO );
    ASSERT(SUCCEEDED(hr));

    pAdmFileInfo->ftWrite = *pftWrite;

    return pAdmFileInfo;
}


//*************************************************************
//
//  FreeAdmFileInfo()
//
//  Purpose:    Deletes a ADMFILEINFO struct
//
//  Parameters: pAdmFileInfo - Struct to delete
//              pftWrite   -  Last write time
//
//
//*************************************************************

void FreeAdmFileInfo( ADMFILEINFO *pAdmFileInfo )
{
    if ( pAdmFileInfo ) {
        LocalFree( pAdmFileInfo->pwszFile );
        LocalFree( pAdmFileInfo->pwszGPO );
        LocalFree( pAdmFileInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpt.cpp ===
//*************************************************************
//
//  Group Policy Support
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************


#include "gphdr.h"
#include <strsafe.h>

//
// DS Object class types
//

TCHAR szDSClassAny[]    = TEXT("(objectClass=*)");
TCHAR szDSClassGPO[]    = TEXT("groupPolicyContainer");
TCHAR szDSClassSite[]   = TEXT("site");
TCHAR szDSClassDomain[] = TEXT("domainDNS");
TCHAR szDSClassOU[]     = TEXT("organizationalUnit");
TCHAR szObjectClass[]   = TEXT("objectClass");

TCHAR wszKerberos[] = TEXT("Kerberos");

//
// Global flags for Gpo shutdown processing. These are accessed outside
// the lock because its value is either 0 or 1. Even if there is a race,
// all it means is that shutdown will start one iteration later.
//

BOOL g_bStopMachGPOProcessing = FALSE;
BOOL g_bStopUserGPOProcessing = FALSE;

//
// Critical section for handling concurrent, asynchronous completion
//

CRITICAL_SECTION g_GPOCS;
BOOL g_bGPOCSInited = FALSE;

//
// Global pointers for maintaining asynchronous completion context
//

LPGPINFOHANDLE g_pMachGPInfo = 0;
LPGPINFOHANDLE g_pUserGPInfo = 0;

//
// Status UI critical section, callback, and proto-types
//

CRITICAL_SECTION g_StatusCallbackCS;
BOOL g_bStatusCallbackInited = FALSE;

PFNSTATUSMESSAGECALLBACK g_pStatusMessageCallback = NULL;

DWORD WINAPI
SetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo info );
DWORD WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo info );

DWORD WINAPI
GetCurrentFgPolicyRefreshInfo(  LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo );
//*************************************************************
//
//  ApplyGroupPolicy()
//
//  Purpose:    Processes group policy
//
//  Parameters: dwFlags         -  Processing flags
//              hToken          -  Token (user or machine)
//              hEvent          -  Termination event for background thread
//              hKeyRoot        -  Root registry key (HKCU or HKLM)
//              pStatusCallback -  Callback function for display status messages
//
//  Return:     Thread handle if successful
//              NULL if an error occurs
//
//*************************************************************

HANDLE WINAPI ApplyGroupPolicy (DWORD dwFlags, HANDLE hToken, HANDLE hEvent,
                                HKEY hKeyRoot, PFNSTATUSMESSAGECALLBACK pStatusCallback)
{
    HANDLE hThread = NULL;
    DWORD dwThreadID;
    LPGPOINFO lpGPOInfo = NULL;
    SECURITY_ATTRIBUTES sa;
    OLE32_API *pOle32Api = NULL;
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    CSecDesc Csd;
    XLastError  xe;
    HANDLE      hProc;
    BOOL        bRet;

    //
    // Verbose output
    //
    DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Entering. Flags = %x"), dwFlags));


    //
    // Save the status UI callback function
    //
    EnterCriticalSection (&g_StatusCallbackCS);
    g_pStatusMessageCallback = pStatusCallback;
    LeaveCriticalSection (&g_StatusCallbackCS);


    //
    // Allocate a GPOInfo structure to work with.
    //
    lpGPOInfo = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

    if (!lpGPOInfo) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to alloc lpGPOInfo (%d)."),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    lpGPOInfo->dwFlags = dwFlags;

    //
    // Duplicate handle to prevent closing when winlogon abandons this thread
    //

    hProc = GetCurrentProcess();
    // this is not expected to fail
    if( hProc == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open current process handle with error (%d)."), GetLastError()));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Duplicating handles")));

    bRet = DuplicateHandle(
                          hProc,                        // Source of the handle 
                          hToken,                       // Source handle
                          hProc,                        // Target of the handle
                          &(lpGPOInfo->hToken),         // Target handle
                          0,                            // ignored since  DUPLICATE_SAME_ACCESS is set
                          FALSE,                        // no inherit on the handle
                          DUPLICATE_SAME_ACCESS
                          );
    
    if( !bRet ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open duplicate token handle with error (%d)."), GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_DUPHANDLE);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    bRet = DuplicateHandle(
                          hProc,                        // Source of the handle 
                          hEvent,                       // Source handle
                          hProc,                        // Target of the handle
                          &(lpGPOInfo->hEvent),         // Target handle
                          0,                            // ignored since  DUPLICATE_SAME_ACCESS is set
                          FALSE,                        // no inherit on the handle
                          DUPLICATE_SAME_ACCESS
                          );
    
    if( !bRet ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open duplicate event handle with error (%d)."), GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_DUPHANDLE);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    if (hKeyRoot != HKEY_LOCAL_MACHINE)
    {
        bRet = DuplicateHandle(
                              hProc,                        // Source of the handle 
                              (HANDLE)hKeyRoot,             // Source handle
                              hProc,                        // Target of the handle
                              (LPHANDLE)(&(lpGPOInfo->hKeyRoot)),       // Target handle
                              0,                            // ignored since  DUPLICATE_SAME_ACCESS is set
                              FALSE,                        // no inherit on the handle
                              DUPLICATE_SAME_ACCESS
                              );

        if( !bRet ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open duplicate key handle with error (%d)."), GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_DUPHANDLE);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }
    }
    else {
        lpGPOInfo->hKeyRoot = HKEY_LOCAL_MACHINE;
    }

    if (dwFlags & GP_MACHINE) {
        lpGPOInfo->pStatusCallback = MachinePolicyCallback;
    } else {
        lpGPOInfo->pStatusCallback = UserPolicyCallback;
    }


    //
    // Create an event so other processes can trigger policy
    // to be applied immediately
    //


    Csd.AddLocalSystem();
    Csd.AddAdministrators();
    
    if (!(dwFlags & GP_MACHINE)) {

        //
        // User events
        //
        XPtrLF<SID> xSid = (SID *)GetUserSid(hToken);

        if (!xSid) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to find user Sid %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_SETACLS);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        Csd.AddSid((SID *)xSid, 
                    STANDARD_RIGHTS_READ  | EVENT_QUERY_STATE |  // GENERIC_READ mask
                    STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE); // GENERIC_WRITE mask
    }
    else {

        //
        // Machine Events
        // Allow Everyone Access by default but can be overridden by policy or preference
        //

        DWORD dwUsersDenied = 0;
        HKEY  hSubKey;
        DWORD dwType=0, dwSize=0;

        //
        // Check for a preference
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                         &hSubKey) == ERROR_SUCCESS) {

            dwSize = sizeof(dwUsersDenied);
            RegQueryValueEx(hSubKey, MACHPOLICY_DENY_USERS, NULL, &dwType,  
                            (LPBYTE) &dwUsersDenied, &dwSize);

            RegCloseKey(hSubKey);
        }


        //
        // Check for a policy
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                         &hSubKey) == ERROR_SUCCESS) {

            dwSize = sizeof(dwUsersDenied);
            RegQueryValueEx(hSubKey, MACHPOLICY_DENY_USERS, NULL, &dwType,  
                            (LPBYTE) &dwUsersDenied, &dwSize);

            RegCloseKey(hSubKey);
        }


        if (!dwUsersDenied) {
            Csd.AddAuthUsers(
                            STANDARD_RIGHTS_READ  | EVENT_QUERY_STATE |  // GENERIC_READ mask
                            STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE);  // GENERIC_WRITE mask
        }
    }

    xsd = Csd.MakeSD();

    if (!xsd) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create Security Descriptor with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    sa.lpSecurityDescriptor = (SECURITY_DESCRIPTOR *)xsd;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(sa);

    lpGPOInfo->hTriggerEvent = CreateEvent (&sa, FALSE, FALSE,            
                                            (dwFlags & GP_MACHINE) ?
                                            MACHINE_POLICY_REFRESH_EVENT : USER_POLICY_REFRESH_EVENT);


    if (!lpGPOInfo->hTriggerEvent)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create trigger event with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    lpGPOInfo->hForceTriggerEvent = CreateEvent (&sa, FALSE, FALSE,
                                            (dwFlags & GP_MACHINE) ?
                                            MACHINE_POLICY_FORCE_REFRESH_EVENT : USER_POLICY_FORCE_REFRESH_EVENT);

    
    if (!lpGPOInfo->hForceTriggerEvent)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create force trigger event with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    //
    // Create the notification events. 
    // These should already be created in InitializePolicyProcessing..
    //

    lpGPOInfo->hNotifyEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,       
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_APPLIED_EVENT : USER_POLICY_APPLIED_EVENT);

    if (!lpGPOInfo->hNotifyEvent)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open notify event with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    //
    // Create the needfg event
    //

    lpGPOInfo->hNeedFGEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_REFRESH_NEEDFG_EVENT : 
                                           USER_POLICY_REFRESH_NEEDFG_EVENT);
                                           
    if (!lpGPOInfo->hNeedFGEvent)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open need fg event with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    //
    // Create the done event
    //

    lpGPOInfo->hDoneEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE,
                                           (dwFlags & GP_MACHINE) ?
                                           MACHINE_POLICY_DONE_EVENT : 
                                           USER_POLICY_DONE_EVENT);
                                           
    if (!lpGPOInfo->hDoneEvent)
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to open done event with %d"),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_SETACLS);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }

    //
    // Initilialize shutdown gpo processing support
    //

    if ( dwFlags & GP_MACHINE )
        g_bStopMachGPOProcessing = FALSE;
    else
        g_bStopUserGPOProcessing = FALSE;

    pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to load ole32.dll.") ));
    }
    else {

        HRESULT hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );

        if ( SUCCEEDED(hr) ) {
            lpGPOInfo->bFGCoInitialized = TRUE;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: CoInitializeEx failed with 0x%x."), hr ));
        }
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        lpGPOInfo->dwFlags |= GP_BACKGROUND_THREAD;
    }

    //
    // Process the GPOs
    //
    ProcessGPOs(lpGPOInfo);

    if ( lpGPOInfo->bFGCoInitialized ) {
        pOle32Api->pfnCoUnInitialize();
        lpGPOInfo->bFGCoInitialized = FALSE;
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        lpGPOInfo->dwFlags &= ~GP_ASYNC_FOREGROUND;
        lpGPOInfo->dwFlags &= ~GP_BACKGROUND_THREAD;
    }

    //
    // If requested, create a background thread to keep updating
    // the profile from the gpos
    //
    if (lpGPOInfo->dwFlags & GP_BACKGROUND_REFRESH) {
        // g_p<Mach/User>GPInfo->bNoBackgroupThread is defaulted to FALSE, which translates to this case,
        //  so there is no need to set it again.

        //
        // Create a thread which sleeps and processes GPOs
        //

        hThread = CreateThread (NULL, 64*1024, // 64k as the stack size
                                (LPTHREAD_START_ROUTINE) GPOThread,
                                (LPVOID) lpGPOInfo, CREATE_SUSPENDED, &dwThreadID);

        if (!hThread) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ApplyGroupPolicy: Failed to create background thread (%d)."),
                     GetLastError()));
            goto Exit;
        }

        SetThreadPriority (hThread, THREAD_PRIORITY_IDLE);
        lpGPOInfo->pStatusCallback = NULL;
        ResumeThread (hThread);

        //
        // Reset the status UI callback function
        //

        EnterCriticalSection (&g_StatusCallbackCS);
        g_pStatusMessageCallback = NULL;
        LeaveCriticalSection (&g_StatusCallbackCS);

        DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Leaving successfully.")));

        return hThread;
    }
    else {
        EnterCriticalSection( &g_GPOCS );
        if ( dwFlags & GP_MACHINE ) {
            if ( g_pMachGPInfo )
                g_pMachGPInfo->bNoBackgroupThread = TRUE;
        } else {
            if ( g_pUserGPInfo )
                g_pUserGPInfo->bNoBackgroupThread = TRUE;
        }
        LeaveCriticalSection( &g_GPOCS );

        //
        // Reset the status UI callback function
        //

        EnterCriticalSection (&g_StatusCallbackCS);
        g_pStatusMessageCallback = NULL;
        LeaveCriticalSection (&g_StatusCallbackCS);

        DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: Background refresh not requested.  Leaving successfully.")));
        hThread = (HANDLE) 1;
        return hThread;
    }


Exit:
    EnterCriticalSection( &g_GPOCS );
    if ( dwFlags & GP_MACHINE ) {

        if ( g_pMachGPInfo )
            LocalFree( g_pMachGPInfo );
        g_pMachGPInfo = 0;
    } else {
        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );
        g_pUserGPInfo = 0;
    }
    LeaveCriticalSection( &g_GPOCS );

    if (lpGPOInfo) {

        if (lpGPOInfo->hToken) {
            CloseHandle (lpGPOInfo->hToken);
        }

        if (lpGPOInfo->hEvent) {
            CloseHandle (lpGPOInfo->hEvent);
        }

        if (lpGPOInfo->hKeyRoot && (lpGPOInfo->hKeyRoot != HKEY_LOCAL_MACHINE)) {
            RegCloseKey(lpGPOInfo->hKeyRoot);
        }

        if (lpGPOInfo->hTriggerEvent) {
            CloseHandle (lpGPOInfo->hTriggerEvent);
        }

        if (lpGPOInfo->hForceTriggerEvent) {
            CloseHandle (lpGPOInfo->hForceTriggerEvent);
        }
        
        if (lpGPOInfo->hNotifyEvent) {
            CloseHandle (lpGPOInfo->hNotifyEvent);
        }

        if (lpGPOInfo->hNeedFGEvent) {
            CloseHandle (lpGPOInfo->hNeedFGEvent);
        }
          
        if (lpGPOInfo->lpwszSidUser)
            DeleteSidString( lpGPOInfo->lpwszSidUser );

        if (lpGPOInfo->szName)
            LocalFree(lpGPOInfo->szName);

        if (lpGPOInfo->szTargetName)
            LocalFree(lpGPOInfo->szTargetName);
            
        LocalFree (lpGPOInfo);
    }

    //
    // Reset the status UI callback function
    //

    EnterCriticalSection (&g_StatusCallbackCS);
    g_pStatusMessageCallback = NULL;
    LeaveCriticalSection (&g_StatusCallbackCS);

    return hThread;
}


extern "C" void ProfileProcessGPOs( void* );

//*************************************************************
//
//  GPOThread()
//
//  Purpose:    Background thread for GPO processing.
//
//  Parameters: lpGPOInfo   - GPO info
//
//  Return:     0
//
//*************************************************************

DWORD WINAPI GPOThread (LPGPOINFO lpGPOInfo)
{
    HINSTANCE hInst;
    HKEY hKey;
    HANDLE hHandles[4] = {NULL, NULL, NULL, NULL};
    DWORD dwType, dwSize, dwResult;
    DWORD dwTimeout, dwOffset;
    BOOL bSetBkGndFlag, bForceBkGndFlag;
    LARGE_INTEGER DueTime;
    HRESULT hr;
    ULONG TTLMinutes;
    XLastError  xe;

    OLE32_API *pOle32Api = LoadOle32Api();

    hInst = LoadLibrary (TEXT("userenv.dll"));  

    hHandles[0] = lpGPOInfo->hEvent;
    hHandles[1] = lpGPOInfo->hTriggerEvent;
    hHandles[2] = lpGPOInfo->hForceTriggerEvent;

    for (;;)
    {
        //
        // Initialize
        //

        bForceBkGndFlag = FALSE;
        

        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            if (lpGPOInfo->iMachineRole == 3) {
                dwTimeout = GP_DEFAULT_REFRESH_RATE_DC;
                dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET_DC;
            } else {
                dwTimeout = GP_DEFAULT_REFRESH_RATE;
                dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET;
            }
        } else {
            dwTimeout = GP_DEFAULT_REFRESH_RATE;
            dwOffset = GP_DEFAULT_REFRESH_RATE_OFFSET;
        }


        //
        // Query for the refresh timer value and max offset
        //

        if (RegOpenKeyEx (lpGPOInfo->hKeyRoot,
                          SYSTEM_POLICIES_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {


            if ((lpGPOInfo->iMachineRole == 3) && (lpGPOInfo->dwFlags & GP_MACHINE)) {

                dwSize = sizeof(dwTimeout);
                RegQueryValueEx (hKey,                              
                                 TEXT("GroupPolicyRefreshTimeDC"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwTimeout,
                                 &dwSize);

                dwSize = sizeof(dwOffset);
                RegQueryValueEx (hKey,                               
                                 TEXT("GroupPolicyRefreshTimeOffsetDC"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwOffset,
                                 &dwSize);

            } else {

                dwSize = sizeof(dwTimeout);
                RegQueryValueEx (hKey,
                                 TEXT("GroupPolicyRefreshTime"),      
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwTimeout,
                                 &dwSize);

                dwSize = sizeof(dwOffset);
                RegQueryValueEx (hKey,                              
                                 TEXT("GroupPolicyRefreshTimeOffset"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwOffset,
                                 &dwSize);
            }

            RegCloseKey (hKey);
        }


        //
        // Limit the timeout to once every 64800 minutes (45 days)
        //

        if (dwTimeout >= 64800) {
            dwTimeout = 64800;
        }


        //
       // Convert seconds to milliseconds
        //

        dwTimeout =  dwTimeout * 60 * 1000;


        //
        // Limit the offset to 1440 minutes (24 hours)
        //

        if (dwOffset >= 1440) {
            dwOffset = 1440;
        }


        //
        // Special case 0 milliseconds to be 7 seconds
        //

        if (dwTimeout == 0) {
            dwTimeout = 7000;

        } else {

            //
            // If there is an offset, pick a random number
            // from 0 to dwOffset and then add it to the timeout
            //

            if (dwOffset) {
                dwOffset = GetTickCount() % dwOffset;

                dwOffset = dwOffset * 60 * 1000;
                dwTimeout += dwOffset;
            }
        }


        //
        // Setup the timer
        //

        if (dwTimeout >= 60000) {
            DebugMsg((DM_VERBOSE, TEXT("GPOThread:  Next refresh will happen in %d minutes"),
                     ((dwTimeout / 1000) / 60)));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("GPOThread:  Next refresh will happen in %d seconds"),
                     (dwTimeout / 1000)));
        }

        hHandles[3] = CreateWaitableTimer (NULL, TRUE, NULL);

        if (hHandles[3] == NULL) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GPOThread: CreateWaitableTimer failed with error %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg( TEXT("CreateWaitableTimer")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            break;
        }

        DueTime.QuadPart = UInt32x32To64(10000, dwTimeout);
        DueTime.QuadPart *= -1;

        if (!SetWaitableTimer (hHandles[3], &DueTime, 0, NULL, 0, FALSE)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GPOThread: Failed to set timer with error %d"),
                     GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg(TEXT("SetWaitableTimer")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            break;
        }

        dwResult = WaitForMultipleObjects( 4, hHandles, FALSE, INFINITE );

        if ( (dwResult - WAIT_OBJECT_0) == 0 )
        {
            //
            // for machine policy thread, this is a shutdown.
            // for user policy thread, this is a logoff.
            //
            goto ExitLoop;
        }
        else if ( (dwResult - WAIT_OBJECT_0) == 2 ) {
            bForceBkGndFlag = TRUE;
        }
        else if ( dwResult == WAIT_FAILED )
        {
            xe = GetLastError();
            DebugMsg( ( DM_WARNING, L"GPOThread: MsgWaitForMultipleObjects with error %d", GetLastError() ) );
            CEvents ev(TRUE, EVENT_FAILED_TIMER);
            ev.AddArg(TEXT("WaitForMultipleObjects")); ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto ExitLoop;
        }

        //
        // Check if we should set the background flag.  We offer this
        // option for the test team's automation tests.  They need to
        // simulate logon / boot policy without actually logging on or
        // booting the machine.
        //

        bSetBkGndFlag = TRUE;

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,        
                          WINLOGON_KEY,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bSetBkGndFlag);
            RegQueryValueEx (hKey,                                  
                             TEXT("SetGroupPolicyBackgroundFlag"),
                             NULL,
                             &dwType,
                             (LPBYTE) &bSetBkGndFlag,
                             &dwSize);

            RegCloseKey (hKey);
        }


        lpGPOInfo->dwFlags &= ~GP_REGPOLICY_CPANEL;
        lpGPOInfo->dwFlags &= ~GP_SLOW_LINK;
        lpGPOInfo->dwFlags &= ~GP_VERBOSE;
        lpGPOInfo->dwFlags &= ~GP_BACKGROUND_THREAD;
        lpGPOInfo->dwFlags &= ~GP_FORCED_REFRESH;

        //
        // In case of forced refresh flag, we override the extensions nobackground policy and prevent 
        // it from getting skipped early on in the processing. We bypass the history logic and force 
        // policy to be applied for extensions that do not care abt. whether they are run in the 
        // foreground or background. for only foreground extensions we write a registry value saying 
        // that the extension needs to override the history logic when they get applied in the foreground 
        // next.
        // In addition we pulse the needfg event so that the calling app knows a reboot/relogon is needed
        // for application of fgonly extensions 
        //
        
        if (bForceBkGndFlag) {
            lpGPOInfo->dwFlags |= GP_FORCED_REFRESH;
        }
            
        //
        // Set the background thread flag so components known
        // when they are being called from the background thread
        // vs the main thread.
        //

        if (bSetBkGndFlag) {
            lpGPOInfo->dwFlags |= GP_BACKGROUND_THREAD;
        }

        if ( !lpGPOInfo->bBGCoInitialized && pOle32Api != NULL ) {

            hr = pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );
            if ( SUCCEEDED(hr) ) {
                lpGPOInfo->bBGCoInitialized = TRUE;
            }
        }

        ProcessGPOs(lpGPOInfo);

        if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

            //
            // Delete garbage-collectable namespaces under root\rsop that are
            // older than 1 week. We can have a policy to configure this time-to-live value.
            //

            TTLMinutes = 24 * 60;

            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              WINLOGON_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = sizeof(TTLMinutes);
                RegQueryValueEx (hKey,                                   
                                 TEXT("RSoPGarbageCollectionInterval"), 
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &TTLMinutes,
                                 &dwSize);

                RegCloseKey (hKey);
            }


            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              SYSTEM_POLICIES_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = sizeof(TTLMinutes);
                RegQueryValueEx (hKey,                                   
                                 TEXT("RSoPGarbageCollectionInterval"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &TTLMinutes,
                                 &dwSize);

                RegCloseKey (hKey);
            }



            //
            // Synchronize with other processes that may be concurrently creating namespaces,
            // during diagnostic mode or planning mode data generation. 
            //

            XCriticalPolicySection xCritSect( EnterCriticalPolicySection(TRUE ) );
            if ( xCritSect )
                GarbageCollectNamespaces(TTLMinutes);
        }

        CloseHandle (hHandles[3]);
        hHandles[3] = NULL;
    }

ExitLoop:

    //
    // Cleanup
    //

    if (hHandles[3]) {
        CloseHandle (hHandles[3]);
    }

    if (lpGPOInfo->hToken) {
        CloseHandle (lpGPOInfo->hToken);
    }

    if (lpGPOInfo->hEvent) {
        CloseHandle (lpGPOInfo->hEvent);
    }

    if (lpGPOInfo->hKeyRoot && (lpGPOInfo->hKeyRoot != HKEY_LOCAL_MACHINE)) {
        RegCloseKey(lpGPOInfo->hKeyRoot);
    }

    if (lpGPOInfo->hTriggerEvent) {
        CloseHandle (lpGPOInfo->hTriggerEvent);
    }

    if (lpGPOInfo->hForceTriggerEvent) {
        CloseHandle (lpGPOInfo->hForceTriggerEvent);
    }

    if (lpGPOInfo->hNotifyEvent) {
        CloseHandle (lpGPOInfo->hNotifyEvent);
    }

    if (lpGPOInfo->hNeedFGEvent) {
        CloseHandle (lpGPOInfo->hNeedFGEvent);
    }
    
    if (lpGPOInfo->hDoneEvent) {
        CloseHandle (lpGPOInfo->hDoneEvent);
    }
    
    if ( lpGPOInfo->bBGCoInitialized ) {

        pOle32Api = LoadOle32Api();
        if ( pOle32Api == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GPOThread: Failed to load ole32.dll.") ));
        }
        else {
            pOle32Api->pfnCoUnInitialize();
            lpGPOInfo->bBGCoInitialized = FALSE;
        }

    }

    EnterCriticalSection( &g_GPOCS );

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {

       if ( g_pMachGPInfo )
           LocalFree( g_pMachGPInfo );

       g_pMachGPInfo = 0;
    } else {

        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );

        g_pUserGPInfo = 0;
     }

    LeaveCriticalSection( &g_GPOCS );

    if (lpGPOInfo->lpwszSidUser)
        DeleteSidString( lpGPOInfo->lpwszSidUser );

    if (lpGPOInfo->szName)
        LocalFree(lpGPOInfo->szName);

    if (lpGPOInfo->szTargetName)
        LocalFree(lpGPOInfo->szTargetName);
        
    LocalFree (lpGPOInfo);

    FreeLibraryAndExitThread (hInst, 0);
    return 0;
}


//*************************************************************
//
//  GPOExceptionFilter()
//
//  Purpose:    Exception filter when procssing GPO extensions
//
//  Parameters: pExceptionPtrs - Pointer to exception pointer
//
//  Returns:    EXCEPTION_EXECUTE_HANDLER
//
//*************************************************************

LONG GPOExceptionFilter( PEXCEPTION_POINTERS pExceptionPtrs )
{
    PEXCEPTION_RECORD pExr = pExceptionPtrs->ExceptionRecord;
    PCONTEXT pCxr = pExceptionPtrs->ContextRecord;

    DebugMsg(( DM_WARNING, L"GPOExceptionFilter: Caught exception 0x%x, exr = 0x%x, cxr = 0x%x\n",
              pExr->ExceptionCode, pExr, pCxr ));

    DmAssert( ! L"Caught unhandled exception when processing group policy extension" );

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL WINAPI
GetFgPolicySetting( HKEY hKeyRoot );

//*************************************************************
//
//  ProcessGPOs()
//
//  Purpose:    Processes GPOs
//
//  Parameters: lpGPOInfo   -   GPO information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ProcessGPOs (LPGPOINFO lpGPOInfo)
{
    BOOL bRetVal = FALSE;
    DWORD dwThreadID;
    HANDLE hThread;
    DWORD dwType, dwSize, dwResult;
    HKEY hKey;
    BOOL bResult;
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;
    LPTSTR lpName = NULL;
    LPTSTR lpDomainDN = NULL;
    LPTSTR lpComputerName;
    PGROUP_POLICY_OBJECT lpGPO = NULL;
    PGROUP_POLICY_OBJECT lpGPOTemp;
    BOOL bAllSkipped;
    LPGPEXT lpExt;
    LPGPINFOHANDLE pGPHandle = NULL;
    ASYNCCOMPLETIONHANDLE pAsyncHandle = 0;
    HANDLE hOldToken;
    UINT uChangedExtensionCount = 0;
    PNETAPI32_API pNetAPI32;
    DWORD dwUserPolicyMode = 0;
    DWORD dwCurrentTime = 0;
    INT iRole;
    BOOL bSlow;
    BOOL bForceNeedFG = FALSE;
    CLocator locator;
    RSOPEXTSTATUS gpCoreStatus;
    XLastError    xe;
    LPWSTR  szNetworkName = 0;
    FgPolicyRefreshInfo info = { GP_ReasonUnknown, GP_ModeAsyncForeground };
    PTOKEN_GROUPS  pTokenGroups = NULL;
    BOOL bAsyncFg = lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ? TRUE : FALSE;
    LPWSTR szPolicyMode = 0;

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        szPolicyMode = L"Async forground";
    }
    else if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) )
    {
        szPolicyMode = L"Sync forground";
    }
    else
    {
        szPolicyMode = L"Background";
    }

    //
    // Allow debugging level to be changed dynamically between
    // policy refreshes.
    //

    InitDebugSupport( FALSE );

    //
    // Debug spew
    //

    memset(&gpCoreStatus, 0, sizeof(gpCoreStatus));      


    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:  Starting computer Group Policy (%s) processing..."),szPolicyMode ));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
    } else {
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs: Starting user Group Policy (%s) processing..."),szPolicyMode ));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
        DebugMsg(( DM_VERBOSE, TEXT("ProcessGPOs:")));
    }

    if ( !( lpGPOInfo->dwFlags & GP_MACHINE ) && lpGPOInfo->lpwszSidUser )
    {
        lpGPOInfo->lpwszSidUser = GetSidString( lpGPOInfo->hToken );
        if ( lpGPOInfo->lpwszSidUser == 0 )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetSidString failed.")));
            CEvents ev(TRUE, EVENT_FAILED_GET_SID); ev.Report();
            goto Exit;
        }
    }

    GetSystemTimeAsFileTime(&gpCoreStatus.ftStartTime);
    gpCoreStatus.bValid = TRUE;

    //
    // Check if we should be verbose to the event log
    //

    if (CheckForVerbosePolicy()) {
        lpGPOInfo->dwFlags |= GP_VERBOSE;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  Verbose output to eventlog requested.")));
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            CEvents ev(FALSE, EVENT_START_MACHINE_POLICY); ev.Report();
        } else {
            CEvents ev(FALSE, EVENT_START_USER_POLICY); ev.Report();
        }
    }


    //
    // Claim the critical section
    //

    lpGPOInfo->hCritSection = EnterCriticalPolicySection((lpGPOInfo->dwFlags & GP_MACHINE));

    if (!lpGPOInfo->hCritSection) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to claim the policy critical section with %d."),
                 GetLastError()));
        CEvents ev(TRUE, EVENT_FAILED_CRITICAL_SECTION);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }


    //
    // Set the security on the Group Policy registry key
    //

    if (!MakeRegKeySecure((lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                          lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy"))) {
        xe = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to secure reg key.")));
        CEvents ev(TRUE, EVENT_FAILED_CREATE);
        ev.AddArg(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy"));
        ev.AddArgWin32Error(xe);
        ev.Report();
        goto Exit;
    }

    //
    // Check if user's sid has changed
    // Check the change in user's sid before doing any rsop logging..
    //

    if ( !CheckForChangedSid( lpGPOInfo, &locator ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Check for changed sid failed")));
        goto Exit;
    }


    //
    // This flag will be used for all further Rsop Logging..
    //
    
    lpGPOInfo->bRsopLogging = RsopLoggingEnabled();

    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Get the role of this computer
    //

    if (!GetMachineRole (&iRole)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to get the role of the computer.")));
        CEvents ev(TRUE, EVENT_FAILED_ROLE); ev.Report();
        goto Exit;
    }

    lpGPOInfo->iMachineRole = iRole;

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  Machine role is %d."), iRole));

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {

        switch (iRole) {
        case 0:
               {
                    CEvents ev(FALSE, EVENT_ROLE_STANDALONE); ev.Report();
                    break;
               }

        case 1:
                {
                    CEvents ev(FALSE, EVENT_ROLE_DOWNLEVEL_DOMAIN); ev.Report();
                    break;
                }
        default:
                {
                    CEvents ev(FALSE, EVENT_ROLE_DS_DOMAIN); ev.Report();
                    break;
                }
        }
    }


    //
    // If we are going to apply policy from the DS
    // query for the user's DN name, domain name, etc
    //

    if (lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)
    {
        //
        // Query for the user's domain name
        //

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
            goto Exit;
        }

        lpDomainDN = MyGetDomainDNSName ();

        RevertToUser(&hOldToken);

        if (!lpDomainDN) {
            xe = GetLastError();
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: MyGetDomainName failed with %d."),
                     dwResult));
            goto Exit;
        }

        //
        // Query for the DS server name
        //
        DWORD   dwAdapterIndex = (DWORD) -1;

        dwResult = GetDomainControllerInfo( pNetAPI32,
                                            lpDomainDN,
                                            DS_DIRECTORY_SERVICE_REQUIRED | 
                                            DS_RETURN_DNS_NAME |
                                            ((lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ? DS_BACKGROUND_ONLY : 0),
                                            lpGPOInfo->hKeyRoot,
                                            &pDCI,
                                            &bSlow,
                                            &dwAdapterIndex );

        if (dwResult != ERROR_SUCCESS) {
            xe = dwResult;
            
            if ((dwResult == ERROR_BAD_NETPATH) ||
                (dwResult == ERROR_NETWORK_UNREACHABLE) ||
                (dwResult == ERROR_NO_SUCH_DOMAIN)) {

                //
                // couldn't find DC. Nothing more we can do, abort
                //
               if ( (!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) || 
                    (lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND) ||
                    (lpGPOInfo->iMachineRole == 3) ) 
                {
                   DebugMsg((DM_WARNING, TEXT("ProcessGPOs: The DC for domain %s is not available. aborting"),
                            lpDomainDN));

                    CEvents ev(TRUE, EVENT_FAILED_DSNAME);
                    ev.AddArgWin32Error(dwResult); ev.Report();
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: The DC for domain %s is not available."), lpDomainDN));

                    if (lpGPOInfo->dwFlags & GP_VERBOSE)
                    {
                        CEvents ev(FALSE, EVENT_FAILED_DSNAME);
                        ev.AddArgWin32Error(dwResult); ev.Report();
                    }
                }
            } else {

                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: DSGetDCName failed with %d."),
                         dwResult));
                CEvents ev(TRUE, EVENT_FAILED_DSNAME);
                ev.AddArgWin32Error(dwResult); ev.Report();
            }

            goto Exit;
        } else {

            //
            // success, slow link?
            //
            if (bSlow) {
                lpGPOInfo->dwFlags |= GP_SLOW_LINK;
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_SLOWLINK); ev.Report();
                }
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: A slow link was detected.")));
            }

            if ( ( lpGPOInfo->dwFlags & GP_MACHINE ) != 0 )
            {
                dwResult = GetNetworkName( &szNetworkName, dwAdapterIndex );
                if ( dwResult != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetNetworkName failed with %d."), dwResult ));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: network name is %s"), szNetworkName ? szNetworkName : L"" ));
                }
            }
        }

        //
        // Get the user's DN name
        //

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
            goto Exit;
        }

        lpName = MyGetUserName (NameFullyQualifiedDN);                  

        RevertToUser(&hOldToken);

        if (!lpName) {
            xe = GetLastError();
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: MyGetUserName failed with %d."),
                     dwResult));
            CEvents ev(TRUE, EVENT_FAILED_USERNAME);
            ev.AddArgWin32Error(dwResult); ev.Report();
            goto Exit;
        }


        if (lpGPOInfo->dwFlags & GP_VERBOSE) {
            CEvents ev(FALSE, EVENT_USERNAME); ev.AddArg(L"%.500s", lpName); ev.Report();
            CEvents ev1(FALSE, EVENT_DOMAINNAME); ev1.AddArg(L"%.500s", lpDomainDN); ev1.Report();
            CEvents ev2(FALSE, EVENT_DCNAME); ev2.AddArg(pDCI->DomainControllerName); ev2.Report();
        }

        lpGPOInfo->lpDNName = lpName;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  User name is:  %s, Domain name is:  %s"),
             lpName, lpDomainDN));

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Domain controller is:  %s  Domain DN is %s"),
                 pDCI->DomainControllerName, lpDomainDN));


        if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {
            CallDFS(pDCI->DomainName, pDCI->DomainControllerName);
        }


        //
        // Save the DC name in the registry for future reference
        //
        DWORD dwDisp;

        if (RegCreateKeyEx (lpGPOInfo->hKeyRoot,
                          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"),
                            0, NULL, REG_OPTION_NON_VOLATILE,
                          KEY_SET_VALUE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS)
        {
            dwSize = (lstrlen(pDCI->DomainControllerName) + 1) * sizeof(TCHAR);        
            RegSetValueEx (hKey, TEXT("DCName"), 0, REG_SZ,                            
                           (LPBYTE) pDCI->DomainControllerName, dwSize);

            if ( ( lpGPOInfo->dwFlags & GP_MACHINE ) != 0 )
            {
                LPWSTR szTemp = szNetworkName ? szNetworkName : L"";

                dwSize = ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR );
                RegSetValueEx(  hKey,
                                L"NetworkName",
                                0,
                                REG_SZ,
                               (LPBYTE) szTemp,
                               dwSize );
            }
            RegCloseKey (hKey);
        }
    }


    //
    // Read the group policy extensions from the registry
    //

    if ( !ReadGPExtensions( lpGPOInfo ) )
    {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: ReadGPExtensions failed.")));
        CEvents ev(TRUE, EVENT_READ_EXT_FAILED); ev.Report();
        goto Exit;
    }


    //
    // Get the user policy mode if appropriate
    //

    if (!(lpGPOInfo->dwFlags & GP_MACHINE)) {

        DWORD   dwRet;

        dwRet = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          SYSTEM_POLICIES_KEY,
                          0, KEY_READ, &hKey);
         
        if (dwRet == ERROR_SUCCESS) {

            dwSize = sizeof(dwUserPolicyMode);
            dwRet = RegQueryValueEx (hKey,
                             TEXT("UserPolicyMode"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwUserPolicyMode,
                             &dwSize);

            if (dwRet != ERROR_SUCCESS)
            {
                if (dwRet != ERROR_FILE_NOT_FOUND)
                {
                    xe = dwRet;
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Read userpolicy mode failed with %d."), dwRet));
                    CEvents ev(TRUE, EVENT_USERMODE_FAILED); ev.AddArgWin32Error(dwRet); ev.Report();
                    goto Exit;
                }
            }

            RegCloseKey (hKey);
        }
        else {
            if (dwRet != ERROR_FILE_NOT_FOUND)
            {
                xe = dwRet;
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Read userpolicy mode failed with %d."), dwRet));
                CEvents ev(TRUE, EVENT_USERMODE_FAILED); ev.AddArgWin32Error(dwRet); ev.Report();
                goto Exit;
            }
        }

        if (dwUserPolicyMode > 0) {

            if (!(lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Loopback is not allowed for downlevel or local user accounts.  Loopback will be disabled.")));
                CEvents ev(FALSE, EVENT_LOOPBACK_DISABLED1); ev.Report();
                dwUserPolicyMode = 0;
            }

            if (dwUserPolicyMode > 0) {
                if (lpGPOInfo->iMachineRole < 2) {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Loopback is not allowed on machines joined to a downlevel domain or running standalone.  Loopback will be disabled.")));
                    CEvents ev(TRUE, EVENT_LOOPBACK_DISABLED2); ev.Report();
                    dwUserPolicyMode = 0;
                }
            }
        }

        // If the user and computer are in different forests, check policy to override mode with loopback replace.
        if ( lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY )
        {
            BOOL bInSameForest = FALSE;
            dwRet = CheckUserInMachineForest(lpGPOInfo->hToken, &bInSameForest);
            if ( dwRet != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to check whether user is in machine forest with %d."), dwRet));
                
                CEvents ev(TRUE, EVENT_X_FOREST_DISCOVERY_FAILED); ev.AddArgWin32Error(dwRet); ev.Report();
                goto Exit;
            }
            
            if ( !bInSameForest )
            {
                DWORD dwAllowXForestPolicyAndRUP = 0;
                
                dwRet = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  SYSTEM_POLICIES_KEY,
                                  0, KEY_READ, &hKey);
                 
                if (dwRet == ERROR_SUCCESS) {

                    dwSize = sizeof(dwAllowXForestPolicyAndRUP);
                    dwRet = RegQueryValueEx (hKey,
                                     TEXT("AllowX-ForestPolicy-and-RUP"),
                                     NULL,
                                     &dwType,
                                     (LPBYTE) &dwAllowXForestPolicyAndRUP,
                                     &dwSize);

                    if (dwRet != ERROR_SUCCESS)
                    {
                        if (dwRet != ERROR_FILE_NOT_FOUND)
                        {
                            xe = dwRet;
                            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Read allow xforest policy failed with %d."), dwRet));
                            CEvents ev(TRUE, EVENT_USERMODE_FAILED); ev.AddArgWin32Error(dwRet); ev.Report();
                            goto Exit;
                        }
                    }

                    RegCloseKey (hKey);
                }
                else {
                    if (dwRet != ERROR_FILE_NOT_FOUND)
                    {
                        xe = dwRet;
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Read allow xforest policy failed with %d."), dwRet));
                        CEvents ev(TRUE, EVENT_USERMODE_FAILED); ev.AddArgWin32Error(dwRet); ev.Report();
                        goto Exit;
                    }
                }

                if ( dwAllowXForestPolicyAndRUP != 1 )
                {
                    dwUserPolicyMode = 2;

                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Loopback enforced for user logging in from different forest.")));

                    // Only log the xforest disabled event for foreground policy application
                    if ( ! ( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) )
                    {
                        CEvents ev(EVENT_WARNING_TYPE, EVENT_X_FOREST_GP_DISABLED); ev.AddArg(lpGPOInfo->lpDNName); ev.Report();
                    }
                }
            }
        }

    }
    
    
    if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to impersonate user")));
        CEvents ev(TRUE, EVENT_FAILED_IMPERSONATE);
        ev.AddArgWin32Error(GetLastError()); ev.Report();
        goto Exit;
    }


    //
    // Read each of the extensions status..
    //

    if (!ReadExtStatus(lpGPOInfo)) {
        // event logged by ReadExtStatus
        xe = GetLastError();
        RevertToUser(&hOldToken);
        goto Exit;
    }


    //
    // Check if any extensions can be skipped. If there is ever a case where
    // all extensions can be skipped, then exit successfully right after this check.
    // Currently RegistryExtension is always run unless there are no GPO changes,
    // but the GPO changes check is done much later.
    //

    if ( !CheckForSkippedExtensions( lpGPOInfo, FALSE ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Checking extensions for skipping failed")));
        //
        // LogEvent() is called by CheckForSkippedExtensions()
        //
        RevertToUser(&hOldToken);
        goto Exit;
    }

    LPWSTR szSiteName;
    dwResult = pNetAPI32->pfnDsGetSiteName(0, &szSiteName);

    if ( dwResult != ERROR_SUCCESS )
    {
        if ( dwResult == ERROR_NO_SITENAME )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs:  No site name defined.  Skipping site policy.")));

            if ( lpGPOInfo->dwFlags & GP_VERBOSE )
            {
                CEvents ev(TRUE, EVENT_NO_SITENAME);
                ev.Report();
            }
            szSiteName = 0;
        }
        else
        {
            xe = dwResult;
            CEvents ev(TRUE, EVENT_FAILED_QUERY_SITE);
            ev.AddArgWin32Error(dwResult); ev.Report();

            DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  DSGetSiteName failed with %d, exiting."), dwResult));
            RevertToUser(&hOldToken);
            goto Exit;
        }
    }

    lpGPOInfo->szSiteName = szSiteName;

    //
    // Query for the GPO list based upon the mode
    //
    // 0 is normal
    // 1 is merge.  Merge user list + machine list
    // 2 is replace.  use machine list instead of user list
    //

    
    if (dwUserPolicyMode == 0) {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for normal policy mode")));

        bResult = GetGPOInfo ((lpGPOInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0,
                              lpDomainDN, lpName, NULL, &lpGPOInfo->lpGPOList,
                              &lpGPOInfo->lpSOMList,
                              &lpGPOInfo->lpGpContainerList,
                              pNetAPI32, TRUE, 0, szSiteName, 0, &locator);

        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed.")));
            CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
        }


    } else if (dwUserPolicyMode == 2) {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for replacement user policy mode")));

        lpComputerName = MyGetComputerName (NameFullyQualifiedDN);   

        if (lpComputerName) {

            PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Using computer name %s for query."), lpComputerName));

            dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation( NULL, 
                                                                        DsRolePrimaryDomainInfoBasic,
                                                                       (PBYTE *)&pDsInfo );

            if ( dwResult == 0 )
            {
                bResult = GetGPOInfo (0, pDsInfo->DomainNameDns, lpComputerName, NULL,
                                      &lpGPOInfo->lpGPOList,
                                      &lpGPOInfo->lpLoopbackSOMList,
                                      &lpGPOInfo->lpLoopbackGpContainerList,
                                      pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

                if (!bResult) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed.")));
                    CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
                }

                pNetAPI32->pfnDsRoleFreeMemory( pDsInfo );
            }
            else
            {
                xe = dwResult;
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer domain name with %d"),
                             GetLastError()));
                CEvents ev(TRUE, EVENT_NO_MACHINE_DOMAIN);
                ev.AddArg(lpComputerName); ev.AddArgWin32Error(GetLastError()); ev.Report();
                bResult = FALSE;
            }
            LocalFree (lpComputerName);

        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer name with %d"),
                         GetLastError()));

            CEvents ev(TRUE, EVENT_FAILED_MACHINENAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            bResult = FALSE;
        }
    } else {

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for merging user policy mode")));

        lpComputerName = MyGetComputerName (NameFullyQualifiedDN);     

        if (lpComputerName) {

            lpGPOInfo->lpGPOList = NULL;
            bResult = GetGPOInfo (0, lpDomainDN, lpName, NULL,
                                  &lpGPOInfo->lpGPOList,
                                  &lpGPOInfo->lpSOMList,
                                  &lpGPOInfo->lpGpContainerList,
                                  pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

            if (bResult) {

                PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;

                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Using computer name %s for query."), lpComputerName));

                lpGPO = NULL;

                dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation( NULL, 
                                                                            DsRolePrimaryDomainInfoBasic,
                                                                           (PBYTE *)&pDsInfo );

                if ( dwResult == 0 )
                {
                    bResult = GetGPOInfo (0, pDsInfo->DomainNameDns, lpComputerName, NULL,
                                      &lpGPO,
                                      &lpGPOInfo->lpLoopbackSOMList,
                                      &lpGPOInfo->lpLoopbackGpContainerList,
                                      pNetAPI32, FALSE, 0, szSiteName, 0, &locator );

                    if (bResult) {

                        if (lpGPOInfo->lpGPOList && lpGPO) {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Both user and machine lists are defined.  Merging them together.")));

                            //
                            // Need to merge the lists together
                            //

                            lpGPOTemp = lpGPOInfo->lpGPOList;

                            while (lpGPOTemp->pNext) {
                                lpGPOTemp = lpGPOTemp->pNext;
                            }

                            lpGPOTemp->pNext = lpGPO;

                        } else if (!lpGPOInfo->lpGPOList && lpGPO) {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Only machine list is defined.")));
                            lpGPOInfo->lpGPOList = lpGPO;

                        } else {

                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Only user list is defined.")));
                        }

                    } else {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed for computer name.")));
                        CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
                    }
                    
                    pNetAPI32->pfnDsRoleFreeMemory( pDsInfo );
                }
                else
                {
                    xe = dwResult;
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer domain name with %d"),
                             GetLastError()));
                    CEvents ev(TRUE, EVENT_NO_MACHINE_DOMAIN);
                    ev.AddArg(lpComputerName); ev.AddArgWin32Error(GetLastError()); ev.Report();
                    bResult = FALSE;
                }

            } else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetGPOInfo failed for user name.")));
                CEvents ev(TRUE, EVENT_GPO_QUERY_FAILED); ev.Report();
            }

            LocalFree (lpComputerName);

        } else {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get the computer name with %d"),
                         GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_MACHINENAME);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            bResult = FALSE;
        }

    }


    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to revert to self")));
    }


    if (!bResult) {
        goto Exit;
    }

    bResult = SetupGPOFilter( lpGPOInfo );

    if (!bResult) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetupGPOFilter failed.")));
        CEvents ev(TRUE, EVENT_SETUP_GPOFILTER_FAILED); ev.Report();
        goto Exit;
    }

    //
    // Log Gpo info to WMI's database
    //

    //
    // Need to check if the security group membership has changed the first time around
    //

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) || (lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND) ) {

        if ((lpGPOInfo->dwFlags & GP_MACHINE) && (lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY)) {


            HANDLE hLocToken=NULL;

            //
            // if it is machine policy processing, get the machine token so that we can check
            // security group membership using the right token. This causes GetMachineToken to be called twice
            // but moving it to the beginning requires too much change.
            //


            hLocToken = GetMachineToken();

            if (hLocToken) {
                CheckGroupMembership( lpGPOInfo, hLocToken, &lpGPOInfo->bMemChanged, &lpGPOInfo->bUserLocalMemChanged, &pTokenGroups);
                CloseHandle(hLocToken);
            }
            else {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs:  Failed to get the machine token with  %d"), GetLastError()));
                goto Exit;
            }
        }
        else {

            //
            // In the user case just use the token passed in
            //

            CheckGroupMembership( lpGPOInfo, lpGPOInfo->hToken, &lpGPOInfo->bMemChanged, &lpGPOInfo->bUserLocalMemChanged, &pTokenGroups);
        }
    }


    if ( lpGPOInfo->bRsopLogging )
    {
        if ( SetRsopTargetName(lpGPOInfo) )
        {
            RSOPSESSIONDATA rsopSessionData;

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logging Data for Target <%s>."), lpGPOInfo->szTargetName));

            //
            // fill up the rsop data
            //
            rsopSessionData.pwszTargetName = lpGPOInfo->szName;
            rsopSessionData.pwszSOM = lpGPOInfo->lpDNName ? GetSomPath( lpGPOInfo->lpDNName ) : TEXT("Local");
            rsopSessionData.pSecurityGroups = pTokenGroups;
            rsopSessionData.bLogSecurityGroup = lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged;
            rsopSessionData.pwszSite =  lpGPOInfo->szSiteName;
            rsopSessionData.bMachine = (lpGPOInfo->dwFlags & GP_MACHINE);
            rsopSessionData.bSlowLink = bSlow;
            rsopSessionData.dwFlags = 0;

            //
            // Fill in the current time
            //

            BOOL bStateChanged = FALSE;
            BOOL bLinkChanged  = FALSE;
            BOOL bNoState = FALSE;

            //
            // log RSoP data only when policy has changed
            //
            dwResult = ComparePolicyState( lpGPOInfo, &bLinkChanged, &bStateChanged, &bNoState );
            if ( dwResult != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, L"ProcessGPOs: ComparePolicyState failed %d, assuming policy changed.", dwResult ));
            }

            //
            // bStateChanged is TRUE if dwResult is not kosher
            //

            if ( bStateChanged || bNoState || bLinkChanged || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) ||
                 lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged ) {

                //
                // Any changes get the wmi interface
                //

                lpGPOInfo->bRsopLogging = 
                            GetWbemServices( lpGPOInfo, RSOP_NS_DIAG_ROOT, FALSE, &(lpGPOInfo->bRsopCreated), &(lpGPOInfo->pWbemServices) );

                if (!lpGPOInfo->bRsopLogging)
                {
                    CEvents ev(TRUE, EVENT_FAILED_WBEM_SERVICES); ev.Report();
                }
                else 
                {
                    //
                    // all changes except link changes
                    //

                    if ( bStateChanged || bNoState || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) )
                    {
                        //
                        // treat no state as newly created
                        //

                        lpGPOInfo->bRsopCreated = (lpGPOInfo->bRsopCreated || bNoState);

                        lpGPOInfo->bRsopLogging = LogExtSessionStatus(  lpGPOInfo->pWbemServices,
                                                                        0,
                                                                        TRUE,
                                                                        lpGPOInfo->bRsopCreated || (lpGPOInfo->dwFlags & GP_FORCED_REFRESH)
                                                                        /* log the event sources only if the namespace is newly created or force refresh */
                                                                     );

                        if (!lpGPOInfo->bRsopLogging)
                        {
                            CEvents ev(TRUE, EVENT_FAILED_RSOPCORE_SESSION_STATUS); ev.AddArgWin32Error(GetLastError()); ev.Report();
                        }
                        else
                        {   
                            bResult = LogRsopData( lpGPOInfo, &rsopSessionData );

                            if (!bResult)
                            {
                                CEvents ev(TRUE, EVENT_RSOP_FAILED); ev.Report();

                                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Rsop data. Continuing.")));
                                lpGPOInfo->bRsopLogging = FALSE;
                            }
                            else
                            {
                                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logged Rsop Data successfully.")));            
                                //
                                // save state only when policy has changed and RSoP logging is successful
                                //
                                dwResult = SavePolicyState( lpGPOInfo );
                                if ( dwResult != ERROR_SUCCESS )
                                {
                                    DebugMsg((DM_WARNING, L"ProcessGPOs: SavePolicyState failed %d.", dwResult ));
                                }
                            }
                        }
                    }
                    else if ( bLinkChanged || lpGPOInfo->bMemChanged || lpGPOInfo->bUserLocalMemChanged )
                    {
                        bResult = LogSessionData( lpGPOInfo, &rsopSessionData );

                        if (!bResult)
                        {
                            CEvents ev(TRUE, EVENT_RSOP_FAILED); ev.Report();

                            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error when logging Rsop session. Continuing.")));
                            lpGPOInfo->bRsopLogging = FALSE;
                        }
                        else
                        {
                            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Logged Rsop Session successfully.")));            
                            //
                            // save state only when policy has changed and RSoP logging is successful
                            //
                            dwResult = SaveLinkState( lpGPOInfo );
                            if ( dwResult != ERROR_SUCCESS )
                            {
                                DebugMsg((DM_WARNING, L"ProcessGPOs: SaveLinkState failed %d.", dwResult ));
                            }
                        }
                    }
                }
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Error querying for targetname. not logging Gpos.Error = %d"), GetLastError()));
        }
    }


    DebugPrintGPOList( lpGPOInfo );

    //================================================================
    //
    // Now walk through the list of extensions
    //
    //================================================================

    EnterCriticalSection( &g_GPOCS );

    pGPHandle = (LPGPINFOHANDLE) LocalAlloc( LPTR, sizeof(GPINFOHANDLE) );

    //
    // Continue even if pGPHandle is 0, because all it means is that async completions (if any)
    // will fail. Remove old asynch completion context.
    //

    if ( pGPHandle )
    {
        pGPHandle->pGPOInfo = lpGPOInfo;
        pGPHandle->bNoBackgroupThread = FALSE; // Defaulting to this
    }

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ( g_pMachGPInfo )
            LocalFree( g_pMachGPInfo );

        g_pMachGPInfo = pGPHandle;
    } else {
        if ( g_pUserGPInfo )
            LocalFree( g_pUserGPInfo );

        g_pUserGPInfo = pGPHandle;
    }

    LeaveCriticalSection( &g_GPOCS );

    pAsyncHandle = (ASYNCCOMPLETIONHANDLE) pGPHandle;

    dwCurrentTime = GetCurTime();

    lpExt = lpGPOInfo->lpExtensions;

    //
    // Before going in, get the thread token and reset the thread token in case
    // one of the extensions hit an exception.
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ,
                          TRUE, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: OpenThreadToken failed with error %d, assuming thread is not impersonating"), GetLastError()));
        hOldToken = NULL;
    }

    while ( lpExt )
    {
        BOOL bProcessGPOs, bNoChanges, bUsePerUserLocalSetting;
        PGROUP_POLICY_OBJECT pDeletedGPOList;
        DWORD dwRet;
        HRESULT hrCSERsopStatus = S_OK;
        GPEXTSTATUS  gpExtStatus;

        //
        // Check for early shutdown or user logoff
        //
        if ( (lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopMachGPOProcessing
             || !(lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopUserGPOProcessing ) {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Aborting GPO processing due to machine shutdown or logoff")));
            CEvents ev(TRUE, EVENT_GPO_PROC_STOPPED); ev.Report();
            break;

        }

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: -----------------------")));
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Processing extension %s"),
                 lpExt->lpDisplayName));

        //
        // The extension has not gotten skipped at this point
        //
        bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

        //
        // read the CSEs status
        //
        ReadStatus( lpExt->lpKeyName,
                    lpGPOInfo,
                    bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : 0,
                    &gpExtStatus );


        //
        // Reset lpGPOInfo->lpGPOList based on extension filter list. If the extension
        // is being called to do delete processing on the history then the current GpoList
        // is null.
        //

        if ( lpExt->bHistoryProcessing )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s is being called to do delete processing on cached history."),
                      lpExt->lpDisplayName));
            lpGPOInfo->lpGPOList = NULL;
        }
        else
            FilterGPOs( lpExt, lpGPOInfo );

        DebugPrintGPOList( lpGPOInfo );

        if ( !CheckGPOs( lpExt, lpGPOInfo, dwCurrentTime,
                         &bProcessGPOs, &bNoChanges, &pDeletedGPOList ) )
        {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOs: CheckGPOs failed.")));
            lpExt = lpExt->pNext;
            continue;
        }

        if ( lpExt->dwNoBackgroundPolicy && ( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) )
        {
            if ( bProcessGPOs && ( pDeletedGPOList || lpGPOInfo->lpGPOList || lpExt->bRsopTransition ) )
            {
                info.mode = GP_ModeSyncForeground;
                info.reason = GP_ReasonCSERequiresSync;
            }
        }

        if ( lpExt->bSkipped )
        {
            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s skipped with flags 0x%x."),
                      lpExt->lpDisplayName, lpGPOInfo->dwFlags));
            if (lpGPOInfo->dwFlags & GP_VERBOSE)
            {
                CEvents ev(FALSE, EVENT_EXT_SKIPPED);
                ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(lpGPOInfo->dwFlags); ev.Report();
            }

            lpExt = lpExt->pNext;
            continue;
        }

        if ( bProcessGPOs )
        {
            if ( !pDeletedGPOList && !lpGPOInfo->lpGPOList && !lpExt->bRsopTransition )
            {
                DebugMsg((DM_VERBOSE,
                         TEXT("ProcessGPOs: Extension %s skipped because both deleted and changed GPO lists are empty."),
                         lpExt->lpDisplayName ));
                if (lpGPOInfo->dwFlags & GP_VERBOSE)
                {
                    CEvents ev(FALSE, EVENT_EXT_HAS_EMPTY_LISTS);
                    ev.AddArg(lpExt->lpDisplayName); ev.Report();
                }

                // clear out any previous extension status if this extension
                // is not applicable any more. We should do this only first time
                // and that means that we should have a state change for rsop. 
                // ie. ComparePolicyState should notice a difference first time around
                // and never again for this reason. which means we should have the
                // wbemservices is we could connect to WMI

                if (lpGPOInfo->pWbemServices)
                {
                    // ignore errors since the extension status might not actually be there
                    (void)DeleteExtSessionStatus(lpGPOInfo->pWbemServices, lpExt->lpKeyName);
                }

                lpExt = lpExt->pNext;

                continue;
            }

            if ( !(lpExt->bForcedRefreshNextFG) )
            {
                dwRet = ERROR_SUCCESS;

                if ( lpExt->dwEnableAsynch )
                {
                    //
                    // Save now to shadow area to avoid race between thread that returns from
                    // ProcessGPOList and the thread that does ProcessGroupPolicyCompleted and
                    // reads from shadow area.
                    //
                    if ( ! SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                 HKEY_LOCAL_MACHINE,
                                 bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                                 TRUE, lpGPOInfo->lpGPOList ) )
                    {
                        dwRet = GetLastError();
                    }
                }

                __try
                {
                    if ( ERROR_SUCCESS == dwRet )
                    {
                        dwRet = E_FAIL;
                        dwRet = ProcessGPOList( lpExt, lpGPOInfo, pDeletedGPOList,
                                                lpGPOInfo->lpGPOList, bNoChanges, pAsyncHandle, &hrCSERsopStatus );
                    }
                }
                __except( GPOExceptionFilter( GetExceptionInformation() ) )
                {

                    (void) SetThreadToken(NULL, hOldToken);  // SetThreadtoken(NULL, NULL) is not expected to fail which the case in the GP Engine threads 

                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy threw unhandled exception 0x%x."),
                                lpExt->lpDisplayName, GetExceptionCode() ));

                    CEvents ev(TRUE, EVENT_CAUGHT_EXCEPTION);
                    ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(GetExceptionCode()); ev.Report();
                }

                (void) SetThreadToken(NULL, hOldToken);  // SetThreadtoken(NULL, NULL) is not expected to fail which the case in the GP Engine threads 

                FreeGPOList( pDeletedGPOList );
                pDeletedGPOList = NULL;

                if ( dwRet == ERROR_SUCCESS || dwRet == ERROR_OVERRIDE_NOCHANGES )
                {
                    bResult = SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                 HKEY_LOCAL_MACHINE,
                                 NULL,
                                 FALSE, lpGPOInfo->lpGPOList );

                    if ( bResult && bUsePerUserLocalSetting )
                    {
                        bResult = SaveGPOList( lpExt->lpKeyName, lpGPOInfo,
                                     HKEY_LOCAL_MACHINE,
                                     lpGPOInfo->lpwszSidUser,
                                     FALSE, lpGPOInfo->lpGPOList );
                    }

                    if ( ! bResult )
                        dwRet = GetLastError();
                }

                if ( dwRet == ERROR_SUCCESS || dwRet == ERROR_OVERRIDE_NOCHANGES )
                {
                    //
                    // ERROR_OVERRIDE_NOCHANGES means that extension processed the list and so the cached list
                    // must be updated, but the extension will be called the next time even if there are
                    // no changes. Duplicate the saved data in the PerUserLocalSetting case to allow for deleted
                    // GPO information to be generated from a combination of HKCU and HKLM\{sid-user} data.
                    //

                    if ( ! bNoChanges )
                    {
                        uChangedExtensionCount++;
                    }

                    //
                    // the CSE required sync foreground previously and now returned ERROR_OVERRIDE_NOCHANGES,
                    // maintain the require sync foreground refresh flag
                    //
                    if ( gpExtStatus.dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED &&
                            dwRet == ERROR_OVERRIDE_NOCHANGES )
                    {
                        info.mode = GP_ModeSyncForeground;
                        info.reason = GP_ReasonCSESyncError;
                    }
                }
                else if ( dwRet == E_PENDING )
                {
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy returned e_pending."),
                              lpExt->lpDisplayName));
                }
                else if ( dwRet == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
                {
                    //
                    // a CSE returned ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED.
                    // Raise a flag to sync foreground refresh.
                    //
                    info.mode = GP_ModeSyncForeground;
                    info.reason = GP_ReasonCSERequiresSync;
                    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy returned sync_foreground."),
                              lpExt->lpDisplayName));
                    if ( lpGPOInfo->dwFlags & GP_FORCED_REFRESH )
                    {
                        bForceNeedFG = TRUE;
                    }
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extension %s ProcessGroupPolicy failed, status 0x%x."),
                              lpExt->lpDisplayName, dwRet));
                    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                        CEvents ev(FALSE, EVENT_CHANGES_FAILED);
                        ev.AddArg(lpExt->lpDisplayName); ev.AddArgWin32Error(dwRet); ev.Report();
                    }

                    //
                    // the CSE required foreground previously and now returned an error,
                    // maintain the require sync foreground refresh flag
                    //
                    if ( gpExtStatus.dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
                    {
                        info.mode = GP_ModeSyncForeground;
                        info.reason = GP_ReasonCSESyncError;
                    }
                }

                //
                // Fill up the status data.
                //
                ZeroMemory( &gpExtStatus, sizeof(gpExtStatus) );     
                gpExtStatus.dwSlowLink = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
                gpExtStatus.dwRsopLogging = lpGPOInfo->bRsopLogging;
                gpExtStatus.dwStatus = dwRet;
                gpExtStatus.dwTime = dwCurrentTime;
                gpExtStatus.bForceRefresh = bForceNeedFG;
                gpExtStatus.dwRsopStatus = hrCSERsopStatus;

                WriteStatus(lpExt->lpKeyName,
                            lpGPOInfo,
                            bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                            &gpExtStatus);
            }
            else
            {
                //
                // if it is force refresh next time around, all we need to do is readstatus and 
                // writestatus back with forcerefresh value set.
                //
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Extensions %s needs to run in ForeGround. Skipping after setting forceflag."),
                          lpExt->lpDisplayName));
                          
                if ( gpExtStatus.bStatus )
                {
                    gpExtStatus.bForceRefresh = TRUE;
                    
                    WriteStatus( lpExt->lpKeyName, lpGPOInfo, 
                                bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL, 
                                &gpExtStatus );
                        
                }
                else
                {
                    //
                    // We can ignore this because absence of a status automatically means processing
                    //
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Couldn't read status data for %s. Error %d. ignoring.. "),
                              lpExt->lpDisplayName, GetLastError()));
                }

                //
                // There is a policy that can only be force refreshed in foreground
                //
                bForceNeedFG = TRUE;
            }
        }
                
        //
        // Process next extension
        //
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: -----------------------")));
        lpExt = lpExt->pNext;
    }

    if ( hOldToken )
    {
       CloseHandle(hOldToken);
    }

    //================================================================
    //
    // Success
    //
    //================================================================
    bRetVal = TRUE;

Exit:
    //
    // change engine modes only if there is no error
    //
    if ( bRetVal )
    {
        //
        // if policy sez sync. mark it sync
        //
        if ( GetFgPolicySetting( HKEY_LOCAL_MACHINE ) )
        {
            info.mode = GP_ModeSyncForeground;
            info.reason = GP_ReasonSyncPolicy;
        }

        //
        // async only on Pro
        //
        OSVERSIONINFOEXW version;
        version.dwOSVersionInfoSize = sizeof(version);
        if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
        {
            //
            // conservatively assume non Pro SKU
            //
            info.mode = GP_ModeSyncForeground;
            info.reason = GP_ReasonSKU;
        }
        else
        {
            if ( version.wProductType != VER_NT_WORKSTATION )
            {
                //
                // force sync refresh on non Pro SKU
                //
                info.mode = GP_ModeSyncForeground;
                info.reason = GP_ReasonSKU;
            }
        }

        if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) || ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ) )
        {
            //
            // set the previous info only in the foreground refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            FgPolicyRefreshInfo curInfo = { GP_ReasonUnknown, GP_ModeUnknown };
            if ( GetCurrentFgPolicyRefreshInfo( szSid, &curInfo ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: GetCurrentFgPolicyRefreshInfo failed.")));
            }
            else
            {
                if (  lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
                {
                    curInfo.mode = GP_ModeAsyncForeground;
                }
                else
                {
                    curInfo.mode = GP_ModeSyncForeground;
                }

                if ( SetPreviousFgPolicyRefreshInfo( szSid, curInfo ) != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetPreviousFgPolicyRefreshInfo failed.") ));
                }
            }
        }

        if ( info.mode == GP_ModeSyncForeground )
        {
            //
            // need sync foreground, set in all refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
            }
        }
        else if ( info.mode == GP_ModeAsyncForeground )
        {
            //
            // sync foreground policy successfully applied, nobody needs sync foreground,
            // reset the GP_ModeSyncForeground only in the async foreground and background
            // refreshes
            //
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( !( lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD ) &&
                    !( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND ) )
            {
                if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
                {
                    DebugMsg((DM_WARNING, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
                }
            }
        }
    }
    
    if ( !lpGPOInfo->pWbemServices )
    {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: No WMI logging done in this policy cycle.")));
    }

    if (!bRetVal)
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Processing failed with error %d."), (DWORD)(xe)));

    GetSystemTimeAsFileTime(&gpCoreStatus.ftEndTime);
    gpCoreStatus.bValid = TRUE;
    gpCoreStatus.dwStatus = bRetVal ? 
                               ERROR_SUCCESS: 
                               ((xe ==ERROR_SUCCESS) ? E_FAIL : xe);

    // if rsop logging is not supported gp core status will appear dirty
    gpCoreStatus.dwLoggingStatus = RsopLoggingEnabled() ? ((lpGPOInfo->bRsopLogging) ? S_OK : E_FAIL) : HRESULT_FROM_WIN32(ERROR_CANCELLED);

    
    // No point in checking for error code here. 
    // The namespace is marked dirty. Diagnostic mode provider should expect all
    // values here or mark the namespace dirty.

    
    if ((lpGPOInfo->dwFlags & GP_MACHINE) || (lpGPOInfo->lpwszSidUser)) {

        SaveLoggingStatus(
                          (lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : (lpGPOInfo->lpwszSidUser),
                          NULL, &gpCoreStatus);
    }
        
    //
    // Unload the Group Policy Extensions
    //

    UnloadGPExtensions (lpGPOInfo);

    FreeLists( lpGPOInfo );

    lpGPOInfo->lpGPOList = NULL;
    lpGPOInfo->lpExtFilterList = NULL;

    if (szNetworkName) {
        LocalFree (szNetworkName );
        szNetworkName = NULL;
    }

    FreeSOMList( lpGPOInfo->lpSOMList );
    FreeSOMList( lpGPOInfo->lpLoopbackSOMList );
    FreeGpContainerList( lpGPOInfo->lpGpContainerList );
    FreeGpContainerList( lpGPOInfo->lpLoopbackGpContainerList );

    if ( lpGPOInfo->szSiteName )
    {
        pNetAPI32->pfnNetApiBufferFree(lpGPOInfo->szSiteName);
        lpGPOInfo->szSiteName = 0;
    }

    lpGPOInfo->lpSOMList = NULL;
    lpGPOInfo->lpLoopbackSOMList = NULL;
    lpGPOInfo->lpGpContainerList = NULL;
    lpGPOInfo->lpLoopbackGpContainerList = NULL;
    lpGPOInfo->bRsopCreated = FALSE; // reset this to false always.
                                     // we will know in the next iteration

    ReleaseWbemServices( lpGPOInfo );

    //
    // Token groups can change only at logon time, so reset to false
    //

    lpGPOInfo->bMemChanged = FALSE;
    lpGPOInfo->bUserLocalMemChanged = FALSE;

    //
    // We migrate the policy data from old sid only at logon time.
    // reset it to false.
    //

    lpGPOInfo->bSidChanged = FALSE;

    if (pDCI) {
        pNetAPI32->pfnNetApiBufferFree(pDCI);
    }

    lpGPOInfo->lpDNName = 0;
    if (lpName) {
        LocalFree (lpName);
    }

    if (lpDomainDN) {
        LocalFree (lpDomainDN);
    }

    if (pTokenGroups) {
        LocalFree(pTokenGroups);
        pTokenGroups = NULL;
    }

    //
    // Release the critical section
    //

    if (lpGPOInfo->hCritSection) {
        LeaveCriticalPolicySection (lpGPOInfo->hCritSection);
        lpGPOInfo->hCritSection = NULL;
    }


    //
    // Announce that policies have changed
    //

    if (bRetVal) {

        //
        // This needs to be set before NotifyEvent
        //

        if (bForceNeedFG)
        {
            info.reason = GP_ReasonSyncForced;
            info.mode = GP_ModeSyncForeground;
            LPWSTR szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;
            if ( SetNextFgPolicyRefreshInfo( szSid, info ) != ERROR_SUCCESS )
            {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: SetNextFgPolicyRefreshInfo failed.")));
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Forced option changed policy mode.")));
            }

            DmAssert(lpGPOInfo->dwFlags & GP_FORCED_REFRESH);
            SetEvent(lpGPOInfo->hNeedFGEvent);
        }

        //
        // If any extensions successfully processed gpo changes, we should notify components
        // so they can process the updated settings accordingly.  If no policy has changed,
        // we should not perform the notification, even if we called extensions, since
        // this could cause a costly broadcast on every single policy refresh, hurting
        // performance particularly on dc's that have a frequent refresh interval (5 minutes)
        // by default and cannot afford to have every desktop and every application updating
        // its settings
        //

        if (uChangedExtensionCount) {

            //
            // First, update User with new colors, bitmaps, etc.
            //

            if (lpGPOInfo->dwFlags & GP_REGPOLICY_CPANEL) {

                //
                // Something has changed in the control panel section
                // Start control.exe with the /policy switch so the
                // display is refreshed.
                //

                RefreshDisplay (lpGPOInfo);
            }


            //
            // Notify anyone waiting on an event handle
            //

            if (lpGPOInfo->hNotifyEvent) {
                PulseEvent (lpGPOInfo->hNotifyEvent);
            }            
        

            //
            // Create a thread to broadcast the WM_SETTINGCHANGE message
            //

            // copy the data to another structure so that this thread can safely free its structures

            LPPOLICYCHANGEDINFO   lpPolicyChangedInfo;

            lpPolicyChangedInfo = (LPPOLICYCHANGEDINFO)LocalAlloc(LPTR, sizeof(POLICYCHANGEDINFO));

            if (lpPolicyChangedInfo)
            {
                HANDLE  hProc;
                BOOL    bDupSucceeded = TRUE;

                lpPolicyChangedInfo->bMachine = (lpGPOInfo->dwFlags & GP_MACHINE) ? 1 : 0;

                if (!(lpPolicyChangedInfo->bMachine))
                {
                    hProc = GetCurrentProcess();

                    if( hProc == NULL ) {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to get process handle with error (%d)."), GetLastError()));
                        bDupSucceeded = FALSE;
                    }

                    if (bDupSucceeded && 
                        (!DuplicateHandle(
                                      hProc,                        // Source of the handle 
                                      lpGPOInfo->hToken,            // Source handle
                                      hProc,                        // Target of the handle
                                      &(lpPolicyChangedInfo->hToken),  // Target handle
                                      0,                            // ignored since  DUPLICATE_SAME_ACCESS is set
                                      FALSE,                        // no inherit on the handle
                                      DUPLICATE_SAME_ACCESS
                                      ))) {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to open duplicate token handle with error (%d)."), GetLastError()));
                        bDupSucceeded = FALSE;
                    }
                }

                if (bDupSucceeded) {
                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) PolicyChangedThread,
                                            (LPVOID) lpPolicyChangedInfo,
                                            CREATE_SUSPENDED, &dwThreadID);

                    if (hThread) {
                        SetThreadPriority (hThread, THREAD_PRIORITY_IDLE);
                        ResumeThread (hThread);
                        CloseHandle (hThread);

                    } else {
                        DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to create background thread (%d)."),
                                 GetLastError()));

                        // free the resources if the thread didn't get launched
                        if (!(lpPolicyChangedInfo->bMachine)) {
                            if (lpPolicyChangedInfo->hToken) {
                                CloseHandle(lpPolicyChangedInfo->hToken);
                                lpPolicyChangedInfo->hToken = NULL;
                            }
                        }

                        LocalFree(lpPolicyChangedInfo);
                    }
                }
                else {
                    LocalFree(lpPolicyChangedInfo);
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOs: Failed to allocate memory for policy changed structure with %d."), GetLastError()));
            }
        }
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            CEvents ev(FALSE, EVENT_MACHINE_POLICY_APPLIED); ev.Report();
        } else {
            CEvents ev(FALSE, EVENT_USER_POLICY_APPLIED); ev.Report();
        }
    }

    if (lpGPOInfo->hDoneEvent) {
        PulseEvent (lpGPOInfo->hDoneEvent);
    }            
    
    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Computer Group Policy has been applied.")));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: User Group Policy has been applied.")));
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Leaving with %d."), bRetVal));

    return bRetVal;
}

//*************************************************************
//
//  PolicyChangedThread()
//
//  Purpose:    Sends the WM_SETTINGCHANGE message announcing
//              that policy has changed.  This is done on a
//              separate thread because this could take many
//              seconds to succeed if an application is hung
//
//  Parameters: lpPolicyChangedInfo - GPO info
//
//  Return:     0
//
//*************************************************************

DWORD WINAPI PolicyChangedThread (LPPOLICYCHANGEDINFO lpPolicyChangedInfo)
{
    HINSTANCE hInst;
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    HANDLE hOldToken = NULL;
    XLastError  xe;


    hInst = LoadLibrary (TEXT("userenv.dll"));       

    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Calling UpdateUser with %d."), lpPolicyChangedInfo->bMachine));

    // impersonate and update system parameter if it is not machine
    if (!(lpPolicyChangedInfo->bMachine)) {
        if (!ImpersonateUser(lpPolicyChangedInfo->hToken, &hOldToken))
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: Failed to impersonate user")));
            goto Exit;
        }

        if (!UpdatePerUserSystemParameters(NULL, UPUSP_POLICYCHANGE)) {
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: UpdateUser failed with %d."), GetLastError()));
            // ignoring error and continuing the next notifications
        }

        if (!RevertToUser(&hOldToken)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PolicyChangedThread: Failed to revert user")));
            goto Exit;
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Broadcast message for %d."), lpPolicyChangedInfo->bMachine));

    //
    // Broadcast the WM_SETTINGCHANGE message
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if ( NT_SUCCESS(Status) )
    {
        DWORD dwBSM = BSM_ALLDESKTOPS | BSM_APPLICATIONS;

        BroadcastSystemMessage (BSF_IGNORECURRENTTASK | BSF_FORCEIFHUNG,
                                &dwBSM,
                                WM_SETTINGCHANGE,
                                lpPolicyChangedInfo->bMachine, (LPARAM) TEXT("Policy"));

        RtlAdjustPrivilege(SE_TCB_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }

    DebugMsg((DM_VERBOSE, TEXT("PolicyChangedThread: Leaving")));

Exit:
    if (!(lpPolicyChangedInfo->bMachine)) {
        if (lpPolicyChangedInfo->hToken) {
            CloseHandle(lpPolicyChangedInfo->hToken);
            lpPolicyChangedInfo->hToken = NULL;
        }
    }

    LocalFree(lpPolicyChangedInfo);

    FreeLibraryAndExitThread (hInst, 0);

    return 0;
}


//*************************************************************
//
//  GetCurTime()
//
//  Purpose:    Returns current time in minutes, or 0 if there
//              is a failure
//
//*************************************************************

DWORD GetCurTime()
{
    DWORD dwCurTime = 0;
    LARGE_INTEGER liCurTime;

    if ( NT_SUCCESS( NtQuerySystemTime( &liCurTime) ) ) {

        if ( RtlTimeToSecondsSince1980 ( &liCurTime, &dwCurTime) ) {

            dwCurTime /= 60;   // seconds to minutes
        }
    }

    return dwCurTime;
}



//*************************************************************
//
//  LoadGPExtension()
//
//  Purpose:    Loads a GP extension.
//
//  Parameters: lpExt -- GP extension
//              bRsopPlanningMode -- Is this during Rsop planning mode ?
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL LoadGPExtension( LPGPEXT lpExt, BOOL bRsopPlanningMode )
{
    XLastError xe;

    if ( !lpExt->bRegistryExt && lpExt->hInstance == NULL )
    {
        lpExt->hInstance = LoadLibrary( lpExt->lpDllName );
        if ( lpExt->hInstance )
        {
            if ( lpExt->bNewInterface )
            {
                lpExt->pEntryPointEx = (PFNPROCESSGROUPPOLICYEX)GetProcAddress(lpExt->hInstance,
                                                                               lpExt->lpFunctionName);
                if ( lpExt->pEntryPointEx == NULL )
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to query ProcessGroupPolicyEx function entry point in dll <%s> with %d"),
                              lpExt->lpDllName, GetLastError()));
                    CEvents ev(TRUE, EVENT_EXT_FUNCEX_FAIL);
                    ev.AddArg(lpExt->lpDllName); ev.Report();

                    return FALSE;
                }
            }
            else
            {
                lpExt->pEntryPoint = (PFNPROCESSGROUPPOLICY)GetProcAddress(lpExt->hInstance,
                                                                           lpExt->lpFunctionName);
                if ( lpExt->pEntryPoint == NULL )
                {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to query ProcessGroupPolicy function entry point in dll <%s> with %d"),
                              lpExt->lpDllName, GetLastError()));
                    CEvents ev(TRUE, EVENT_EXT_FUNC_FAIL);
                    ev.AddArg(lpExt->lpDllName); ev.Report();

                    return FALSE;
                }
            }

            if ( bRsopPlanningMode ) {

                if ( lpExt->lpRsopFunctionName ) {

                    lpExt->pRsopEntryPoint = (PFNGENERATEGROUPPOLICY)GetProcAddress(lpExt->hInstance,
                                                                                    lpExt->lpRsopFunctionName);
                    if ( lpExt->pRsopEntryPoint == NULL )
                    {
                        xe = GetLastError();
                        DebugMsg((DM_WARNING,
                                  TEXT("LoadGPExtension: Failed to query GenerateGroupPolicy function entry point in dll <%s> with %d"),
                                  lpExt->lpDllName, GetLastError()));
                        
                        CEvents ev(TRUE, EVENT_EXT_FUNCRSOP_FAIL);
                        ev.AddArg(lpExt->lpDisplayName); ev.AddArg(lpExt->lpDllName); ev.Report();

                        return FALSE;
                    }

                } else {

                    xe = ERROR_PROC_NOT_FOUND;
                    DebugMsg((DM_WARNING,
                              TEXT("LoadGPExtension: Failed to find Rsop entry point in dll <%s>"), lpExt->lpDllName ));
                    return FALSE;
                }
            }
        }
        else
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadGPExtension: Failed to load dll <%s> with %d"),
                      lpExt->lpDllName, GetLastError()));
            CEvents ev(TRUE, EVENT_EXT_LOAD_FAIL);
            ev.AddArg(lpExt->lpDllName); ev.AddArgWin32Error(GetLastError()); ev.Report();

            return FALSE;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  UnloadGPExtensions()
//
//  Purpose:    Unloads the Group Policy extension dlls
//
//  Parameters: lpGPOInfo   -   GP Information
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL UnloadGPExtensions (LPGPOINFO lpGPOInfo)
{
    if ( !lpGPOInfo )
    {
        return TRUE;
    }

    LPGPEXT lpExt, lpTemp;
    lpExt = lpGPOInfo->lpExtensions;

    while ( lpExt )
    {
        lpTemp = lpExt->pNext;

        if ( lpExt->hInstance )
        {
            FreeLibrary( lpExt->hInstance );
        }
        
        if ( lpExt->szEventLogSources )
        {
            LocalFree( lpExt->szEventLogSources );
        }
        if (lpExt->lpPrevStatus)
        {
            LocalFree(lpExt->lpPrevStatus);
        }

        LocalFree( lpExt );
        lpExt = lpTemp;
    }

    lpGPOInfo->lpExtensions = 0;

    return TRUE;
}

//*************************************************************
//
//  ProcessGPOList()
//
//  Purpose:    Calls client side extensions to process gpos
//
//  Parameters: lpExt           - GP extension
//              lpGPOInfo       - GPT Information
//              pDeletedGPOList - Deleted GPOs
//              pChangedGPOList - New/changed GPOs
//              bNoChanges      - True if there are no GPO changes
//                                  and GPO processing is forced
//              pAsyncHandle    - Context for async completion
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

DWORD ProcessGPOList (LPGPEXT lpExt,
                      LPGPOINFO lpGPOInfo,
                      PGROUP_POLICY_OBJECT pDeletedGPOList,
                      PGROUP_POLICY_OBJECT pChangedGPOList,
                      BOOL bNoChanges, ASYNCCOMPLETIONHANDLE pAsyncHandle,
                      HRESULT *phrRsopStatus )
{
    LPTSTR lpGPTPath, lpDSPath;
    INT iStrLen;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szStatusFormat[50];
    TCHAR szVerbose[100];
    DWORD dwSlowLinkCur = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
    IWbemServices *pLocalWbemServices;
    HRESULT        hr2 = S_OK;
    XLastError  xe;

    *phrRsopStatus=S_OK;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Entering for extension %s"), lpExt->lpDisplayName));

    if (lpGPOInfo->pStatusCallback) {
        if (!LoadString (g_hDllInstance, IDS_CALLEXTENSION, szStatusFormat, ARRAYSIZE(szStatusFormat))) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOList: LoadString failed with error %d."), GetLastError()));
            // continue without showing per cse status UI.
        }
        else {
            hr2 = StringCchPrintf (szVerbose, ARRAYSIZE(szVerbose), szStatusFormat, lpExt->lpDisplayName);
       
            ASSERT(SUCCEEDED(hr2));

            lpGPOInfo->pStatusCallback(TRUE, szVerbose);
        }
    }

    if (lpGPOInfo->dwFlags & GP_MACHINE) {
        dwFlags |= GPO_INFO_FLAG_MACHINE;
    }

    if (lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)
    {
        dwFlags |= GPO_INFO_FLAG_BACKGROUND;
    }

    if ( lpGPOInfo->dwFlags & GP_ASYNC_FOREGROUND )
    {
        dwFlags |= GPO_INFO_FLAG_ASYNC_FOREGROUND;
    }

    if (lpGPOInfo->dwFlags & GP_SLOW_LINK) {
        dwFlags |= GPO_INFO_FLAG_SLOWLINK;
    }

    if ( dwSlowLinkCur != lpExt->lpPrevStatus->dwSlowLink ) {
        dwFlags |= GPO_INFO_FLAG_LINKTRANSITION;
    }

    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
        dwFlags |= GPO_INFO_FLAG_VERBOSE;
    }

    if ( bNoChanges ) {
        dwFlags |= GPO_INFO_FLAG_NOCHANGES;
    }

    //
    // flag safe mode boot to CSE so that they can made a decision
    // whether or not to apply policy
    //
    if ( GetSystemMetrics( SM_CLEANBOOT ) )
    {
        dwFlags |= GPO_INFO_FLAG_SAFEMODE_BOOT;
    }

    if (lpExt->bRsopTransition) {
        dwFlags |= GPO_INFO_FLAG_LOGRSOP_TRANSITION;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Passing in the rsop transition flag to Extension %s"),
                  lpExt->lpDisplayName));
    }


    if ( (lpGPOInfo->dwFlags & GP_FORCED_REFRESH) || 
           ((!(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD)) && (lpExt->lpPrevStatus->bForceRefresh))) {

        dwFlags |= GPO_INFO_FLAG_FORCED_REFRESH;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Passing in the force refresh flag to Extension %s"),
                  lpExt->lpDisplayName));
    }   

    //
    // if it is rsop transition or changes case get the intf ptr
    //

    if ( (lpGPOInfo->bRsopLogging) && 
         ((lpExt->bRsopTransition) || (!bNoChanges) || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH)) ) {
        
        if (!(lpGPOInfo->pWbemServices) ) {
            BOOL    bCreated;

            //
            // Note that this code shouldn't be creating a namespace ever..
            //

            if (!GetWbemServices(lpGPOInfo, RSOP_NS_DIAG_ROOT, FALSE, NULL, &(lpGPOInfo->pWbemServices))) {
                DebugMsg((DM_WARNING, TEXT("ProcessGPOList: Couldn't get the wbemservices intf pointer")));
                lpGPOInfo->bRsopLogging = FALSE;
                hr2 = *phrRsopStatus = E_FAIL;
            }
        }
        
        pLocalWbemServices = lpGPOInfo->pWbemServices;
    }
    else {
        pLocalWbemServices = NULL;
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: No changes. CSE will not be passed in the IwbemServices intf ptr")));
    }
    
    dwRet = ERROR_SUCCESS;

    if ( lpExt->bRegistryExt )
    {
        //
        // Registry pseudo extension.
        //


        //
        // Log the extension specific status
        //
        
        if (pLocalWbemServices) {
            lpGPOInfo->bRsopLogging = LogExtSessionStatus(  pLocalWbemServices,
                                                            lpExt,
                                                            TRUE,
                                                            (lpExt->bRsopTransition || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH)
                                                            || (!bNoChanges)));        


            if (!lpGPOInfo->bRsopLogging) {
                hr2 = E_FAIL;
            }
        }

        if (!ProcessGPORegistryPolicy (lpGPOInfo, pChangedGPOList, phrRsopStatus)) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOList: ProcessGPORegistryPolicy failed.")));
            dwRet = E_FAIL;
        }        

    } else {    // if lpExt->bRegistryExt

        //
        // Regular extension
        //

        BOOL *pbAbort;
        ASYNCCOMPLETIONHANDLE pAsyncHandleTemp;

        if ( lpExt->dwRequireRegistry ) {

            GPEXTSTATUS gpExtStatus;

            ReadStatus( c_szRegistryExtName, lpGPOInfo, NULL, &gpExtStatus );

            if ( !gpExtStatus.bStatus || gpExtStatus.dwStatus != ERROR_SUCCESS ) {

                DebugMsg((DM_VERBOSE,
                          TEXT("ProcessGPOList: Skipping extension %s due to failed Registry extension."),
                          lpExt->lpDisplayName));
                if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                    CEvents ev(FALSE, EVENT_EXT_SKIPPED_DUETO_FAILED_REG);
                    ev.AddArg(lpExt->lpDisplayName); ev.Report();
                }

                dwRet = E_FAIL;

                goto Exit;

            }
        }
        

        //
        // Log the extension specific status
        //
        
        if (pLocalWbemServices)
        {
            lpGPOInfo->bRsopLogging = LogExtSessionStatus(  pLocalWbemServices,
                                                            lpExt,
                                                            lpExt->bNewInterface,
                                                            (lpExt->bRsopTransition || (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH) 
                                                            || (!bNoChanges)));        
            if (!lpGPOInfo->bRsopLogging) {
                hr2 = E_FAIL;
            }
        }

        BOOL bLoadedExtension = TRUE;

        if ( !LoadGPExtension( lpExt, FALSE ) ) {
            DebugMsg((DM_WARNING, TEXT("ProcessGPOList: LoadGPExtension %s failed."), lpExt->lpDisplayName));

            dwRet = GetLastError();

            //
            // Note that we don't just leave here -- we
            // continue so that we will log an extension
            // status that indicates that this extension
            // did not process
            //
            bLoadedExtension = FALSE;
        }

        if ( lpGPOInfo->dwFlags & GP_MACHINE )
            pbAbort = &g_bStopMachGPOProcessing;
        else
            pbAbort = &g_bStopUserGPOProcessing;

        //
        // Check if asynchronous processing is enabled
        //

        if ( lpExt->dwEnableAsynch )
            pAsyncHandleTemp = pAsyncHandle;
        else
            pAsyncHandleTemp = 0;

        if ( bLoadedExtension )
        {
            if ( lpExt->bNewInterface ) {
                dwRet = lpExt->pEntryPointEx( dwFlags,
                                            lpGPOInfo->hToken,
                                            lpGPOInfo->hKeyRoot,
                                            pDeletedGPOList,
                                            pChangedGPOList,
                                            pAsyncHandleTemp,
                                            pbAbort,
                                            lpGPOInfo->pStatusCallback,
                                            pLocalWbemServices,
                                            phrRsopStatus);
            } else {
                dwRet = lpExt->pEntryPoint( dwFlags,
                                            lpGPOInfo->hToken,
                                            lpGPOInfo->hKeyRoot,
                                            pDeletedGPOList,
                                            pChangedGPOList,
                                            pAsyncHandleTemp,
                                            pbAbort,
                                            lpGPOInfo->pStatusCallback );
            }
        }

        RevertToSelf();

        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s returned 0x%x."),
                  lpExt->lpDisplayName, dwRet));

        if ( dwRet != ERROR_SUCCESS &&
                dwRet != ERROR_OVERRIDE_NOCHANGES &&
                    dwRet != E_PENDING &&
                        dwRet != ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
        {
            CEvents ev(TRUE, EVENT_EXT_FAILED);
            ev.AddArg(lpExt->lpDisplayName); ev.Report();
        }

    }   // else of if lpext->bregistryext


    if (pLocalWbemServices) {
        if ((dwRet != E_PENDING) && (SUCCEEDED(*phrRsopStatus)) && (lpExt->bNewInterface)) {

            //
            // for the legacy extensions it will be marked clean
            //

            DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s was able to log data. RsopStatus = 0x%x, dwRet = %d, Clearing the dirty bit"),
                      lpExt->lpDisplayName, *phrRsopStatus, dwRet));

            (void)UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, FALSE, dwRet);
        }
        else {

            if (!lpExt->bNewInterface) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s doesn't support rsop logging"),
                          lpExt->lpDisplayName));

                (void)UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, TRUE, dwRet);
                // extension status will be marked dirty if it fails
            }
            else if (FAILED(*phrRsopStatus)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s was not able to log data. Error = 0x%x, dwRet = %d,leaving the log dirty"),
                          lpExt->lpDisplayName, *phrRsopStatus, dwRet ));

                CEvents ev(TRUE, EVENT_EXT_RSOP_FAILED);
                ev.AddArg(lpExt->lpDisplayName); ev.Report();

                (void)UpdateExtSessionStatus(pLocalWbemServices, lpExt->lpKeyName, TRUE, dwRet);
            }
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOList: Extension %s status was not updated because there was no changes and no transition or rsop wasn't enabled"),
                  lpExt->lpDisplayName));
    }

    //
    // if any of the things provider is supposed to log fails, log it as an error
    // so that provider tries to log it again next time
    //

    *phrRsopStatus = (SUCCEEDED(*phrRsopStatus)) && (FAILED(hr2)) ? hr2 : *phrRsopStatus;
    *phrRsopStatus = (!lpExt->bNewInterface) ? HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) : *phrRsopStatus;


Exit:

    return dwRet;
}


//*************************************************************
//
//  RefreshDisplay()
//
//  Purpose:    Starts control.exe
//
//  Parameters: lpGPOInfo   -   GPT information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RefreshDisplay (LPGPOINFO lpGPOInfo)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR szCmdLine[50];
    BOOL Result;
    HANDLE hOldToken;
    HRESULT hr = S_OK;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("RefreshDisplay: Starting control.exe")));


    //
    // Initialize process startup info
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = 0;
    si.wShowWindow = SW_HIDE;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = TEXT("");


    //
    // Impersonate the user so we get access checked correctly on
    // the file we're trying to execute
    //

    if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Create the app
    //

    hr = StringCchCopy (szCmdLine, ARRAYSIZE(szCmdLine), TEXT("control /policy"));
    ASSERT(SUCCEEDED(hr));

    Result = CreateProcessAsUser(lpGPOInfo->hToken, NULL, szCmdLine, NULL,
                                 NULL, FALSE, 0, NULL, NULL, &si, &pi);


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to revert to self")));
    }


    if (Result) {
        WaitForSingleObject (pi.hProcess, 120000);
        CloseHandle (pi.hThread);
        CloseHandle (pi.hProcess);

    } else {
        DebugMsg((DM_WARNING, TEXT("RefreshDisplay: Failed to start control.exe with %d"), GetLastError()));
    }

    return(Result);

}


//*************************************************************
//
//  RefreshPolicy()
//
//  Purpose:    External api that causes policy to be refreshed now
//
//  Parameters: bMachine -   Machine policy vs user policy
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI RefreshPolicy (BOOL bMachine)
{
    HANDLE hEvent;

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicy: Entering with %d"), bMachine));

    hEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE,
                        bMachine ? MACHINE_POLICY_REFRESH_EVENT : USER_POLICY_REFRESH_EVENT);

    if (hEvent) {
        BOOL bRet = SetEvent (hEvent);

        CloseHandle (hEvent);
        
        if (!bRet) {
            DebugMsg((DM_WARNING, TEXT("RefreshPolicy: Failed to set event with %d"), GetLastError()));
            return FALSE;
        }
    } else {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicy: Failed to open event with %d"), GetLastError()));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicy: Leaving.")));

    return TRUE;
}



//*************************************************************
//
//  RefreshPolicyEx()
//
//  Purpose:    External api that causes policy to be refreshed now
//
//  Parameters: bMachine -   Machine policy vs user policy.
//              This API is synchronous and waits for the refresh to
//              finish.
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI RefreshPolicyEx (BOOL bMachine, DWORD dwOption)
{
    XHandle xhEvent;

    if (!dwOption)
        return RefreshPolicy(bMachine);
    
    if (dwOption == RP_FORCE) {
        DebugMsg((DM_VERBOSE, TEXT("RefreshPolicyEx: Entering with force refresh %d"), bMachine));

        xhEvent = OpenEvent (EVENT_MODIFY_STATE, FALSE,
                            bMachine ? MACHINE_POLICY_FORCE_REFRESH_EVENT : USER_POLICY_FORCE_REFRESH_EVENT);
                            
    }                            
    else {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Invalid option")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    
    if (!xhEvent) {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Failed to open event with %d"), GetLastError()));
        return FALSE;
    }


    if (!SetEvent (xhEvent)) {
        DebugMsg((DM_WARNING, TEXT("RefreshPolicyEx: Failed to set event with %d"), GetLastError()));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("RefreshPolicyEx: Leaving.")));

    return TRUE;
}



//*************************************************************
//
//  EnterCriticalPolicySection()
//
//  Purpose:    External api that causes policy to pause
//              This allows an application to pause policy
//              so that values don't change while it reads
//              the settings.
//
//  Parameters: bMachine -   Pause machine policy or user policy
//              dwTimeOut-   Amount of time to wait for the policy handle
//              dwFlags  -   Various flags. Look at the defn.
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

HANDLE WINAPI EnterCriticalPolicySectionEx (BOOL bMachine, DWORD dwTimeOut, DWORD dwFlags )
{
    HANDLE hSection;
    DWORD  dwRet;
    WCHAR* wszMutex;

    DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: Entering with timeout %d and flags 0x%x"), dwTimeOut, dwFlags ));      

    //
    // Determine which lock to acquire
    //
    if ( ECP_REGISTRY_ONLY & dwFlags )
    {
        if ( bMachine )
        {            
            wszMutex = MACH_REGISTRY_EXT_MUTEX;
        }
        else
        {
            wszMutex = USER_REGISTRY_EXT_MUTEX;
        }
    }
    else
    {
        if ( bMachine )
        {
            wszMutex = MACHINE_POLICY_MUTEX;
        }
        else
        {
            wszMutex = USER_POLICY_MUTEX;
        }
    }

    //
    // Open the mutex
    //

    hSection = OpenMutex (SYNCHRONIZE, FALSE, wszMutex);

    if (!hSection) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySectionEx: Failed to open mutex with %d"),
                 GetLastError()));
        DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: Leaving unsuccessfully.")));      
        return NULL;
    }



    //
    // Claim the mutex
    //

    dwRet = WaitForSingleObject (hSection, dwTimeOut);
    
    if ( dwRet == WAIT_FAILED) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySectionEx: Failed to wait on the mutex.  Error = %d."),
                  GetLastError()));
        CloseHandle( hSection );
        DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: Leaving unsuccessfully.")));      
        return NULL;
    }

    if ( (dwFlags & ECP_FAIL_ON_WAIT_TIMEOUT) && (dwRet == WAIT_TIMEOUT) ) {
        DebugMsg((DM_WARNING, TEXT("EnterCriticalPolicySectionEx: Wait timed out on the mutex.")));
        CloseHandle( hSection );
        SetLastError(dwRet);
        DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: Leaving unsuccessfully.")));  
        return NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: %s critical section has been claimed.  Handle = 0x%x"),
             (bMachine ? TEXT("Machine") : TEXT("User")), hSection));


    DebugMsg((DM_VERBOSE, TEXT("EnterCriticalPolicySectionEx: Leaving successfully.")));      

    return hSection;
}


//*************************************************************
//
//  LeaveCriticalPolicySection()
//
//  Purpose:    External api that causes policy to resume
//              This api assumes the app has called
//              EnterCriticalPolicySection first
//
//  Parameters: hSection - mutex handle
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

BOOL WINAPI LeaveCriticalPolicySection (HANDLE hSection)
{

    if (!hSection) {
        DebugMsg((DM_WARNING, TEXT("LeaveCriticalPolicySection: null mutex handle.")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ReleaseMutex (hSection);
    CloseHandle (hSection);

    DebugMsg((DM_VERBOSE, TEXT("LeaveCriticalPolicySection: Critical section 0x%x has been released."),
             hSection));

    return TRUE;
}



//*************************************************************
//
//  EnterCriticalPolicySection()
//
//  Purpose:    External api that causes policy to pause
//              This allows an application to pause policy
//              so that values don't change while it reads
//              the settings.
//
//  Parameters: bMachine -   Pause machine policy or user policy
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************

HANDLE WINAPI EnterCriticalPolicySection (BOOL bMachine)
{
    return EnterCriticalPolicySectionEx(bMachine, 600000, 0);
}

//*************************************************************
//
//  FreeGpoInfo()
//
//  Purpose:    Deletes an LPGPOINFO struct
//
//  Parameters: pGpoInfo - Gpo info to free
//
//*************************************************************

BOOL FreeGpoInfo( LPGPOINFO pGpoInfo )
{
    if ( pGpoInfo == NULL )
        return TRUE;

    FreeLists( pGpoInfo );
    FreeSOMList( pGpoInfo->lpSOMList );
    FreeSOMList( pGpoInfo->lpLoopbackSOMList );
    FreeGpContainerList( pGpoInfo->lpGpContainerList );
    FreeGpContainerList( pGpoInfo->lpLoopbackGpContainerList );

    LocalFree( pGpoInfo->lpDNName );
    RsopDeleteToken( pGpoInfo->pRsopToken );
    ReleaseWbemServices( pGpoInfo );

    DeleteSidString(pGpoInfo->lpwszSidUser);

    LocalFree( pGpoInfo );

    return TRUE;
}


//*************************************************************
//
//  FreeGPOList()
//
//  Purpose:    Free's the link list of GPOs
//
//  Parameters: pGPOList - Pointer to the head of the list
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI FreeGPOList (PGROUP_POLICY_OBJECT pGPOList)
{
    PGROUP_POLICY_OBJECT pGPOTemp;

    while (pGPOList) {
        pGPOTemp = pGPOList->pNext;
        LocalFree (pGPOList);
        pGPOList = pGPOTemp;
    }

    return TRUE;
}


//*************************************************************
//
//  FreeLists()
//
//  Purpose:    Free's the lpExtFilterList and/or lpGPOList
//
//  Parameters: lpGPOInfo - GPO info
//
//*************************************************************

void FreeLists( LPGPOINFO lpGPOInfo )
{
    LPEXTFILTERLIST pExtFilterList = lpGPOInfo->lpExtFilterList;

    //
    // If bXferToExtList is True then it means that lpGPOInfo->lpExtFilterList
    // owns the list of GPOs. Otherwise lpGPOInfo->lpGPOList owns the list
    // of GPOs.
    //

    while ( pExtFilterList ) {

        LPEXTFILTERLIST pTemp = pExtFilterList->pNext;

        FreeExtList( pExtFilterList->lpExtList );

        if ( lpGPOInfo->bXferToExtList )
            LocalFree( pExtFilterList->lpGPO );

        LocalFree( pExtFilterList );
        pExtFilterList = pTemp;
    }

    if ( !lpGPOInfo->bXferToExtList )
        FreeGPOList( lpGPOInfo->lpGPOList );
}


//*************************************************************
//
//  FreeExtList()
//
//  Purpose:    Free's the lpExtList
//
//  Parameters: pExtList - Extensions list
//
//*************************************************************

void FreeExtList( LPEXTLIST pExtList )
{
    while (pExtList) {

        LPEXTLIST pTemp = pExtList->pNext;
        LocalFree( pExtList );
        pExtList = pTemp;
    }
}


//*************************************************************
//
//  ShutdownGPOProcessing()
//
//  Purpose:    Begins aborting GPO processing
//
//  Parameters: bMachine    -  Shutdown machine or user processing ?
//
//*************************************************************

void WINAPI ShutdownGPOProcessing( BOOL bMachine )
{
    LPGPOINFO lpGPOInfo = NULL;

    EnterCriticalSection( &g_GPOCS );
    if ( bMachine )
    {
        if ( g_pMachGPInfo )
        {
            if ( g_pMachGPInfo->bNoBackgroupThread )
            {
                lpGPOInfo = g_pMachGPInfo->pGPOInfo;
                LocalFree( g_pMachGPInfo );
                g_pMachGPInfo = 0;
            }
        }
        g_bStopMachGPOProcessing = TRUE;
    }
    else
    {
        if ( g_pUserGPInfo )
        {
            if ( g_pUserGPInfo->bNoBackgroupThread )
            {
                lpGPOInfo = g_pUserGPInfo->pGPOInfo;
                LocalFree( g_pUserGPInfo );
                g_pUserGPInfo = 0;
            }
        }
        g_bStopUserGPOProcessing = TRUE;
    }
    LeaveCriticalSection( &g_GPOCS );

    if (lpGPOInfo) {

        if (lpGPOInfo->hToken) {
            CloseHandle (lpGPOInfo->hToken);
        }

        if (lpGPOInfo->hEvent) {
            CloseHandle (lpGPOInfo->hEvent);
        }

        if (lpGPOInfo->hKeyRoot && (lpGPOInfo->hKeyRoot != HKEY_LOCAL_MACHINE)) {
            RegCloseKey(lpGPOInfo->hKeyRoot);
        }

        if (lpGPOInfo->hTriggerEvent) {
            CloseHandle (lpGPOInfo->hTriggerEvent);
        }

        if (lpGPOInfo->hForceTriggerEvent) {
            CloseHandle (lpGPOInfo->hForceTriggerEvent);
        }
        
        if (lpGPOInfo->hNotifyEvent) {
            CloseHandle (lpGPOInfo->hNotifyEvent);
        }

        if (lpGPOInfo->hNeedFGEvent) {
            CloseHandle (lpGPOInfo->hNeedFGEvent);
        }
          
        if (lpGPOInfo->lpwszSidUser)
            DeleteSidString( lpGPOInfo->lpwszSidUser );

        if (lpGPOInfo->szName)
            LocalFree(lpGPOInfo->szName);

        if (lpGPOInfo->szTargetName)
            LocalFree(lpGPOInfo->szTargetName);
            
        LocalFree (lpGPOInfo);
    }
    
}


//*************************************************************
//
//  InitializeGPOCriticalSection, CloseGPOCriticalSection
//
//  Purpose:   Initialization and cleanup routines for critical sections
//
//*************************************************************

void InitializeGPOCriticalSection()
{
    InitializeCriticalSection( &g_GPOCS );
    g_bGPOCSInited = TRUE;
    InitializeCriticalSection( &g_StatusCallbackCS );
    g_bStatusCallbackInited = TRUE;
}


void CloseGPOCriticalSection()
{
    if (g_bStatusCallbackInited)
        DeleteCriticalSection( &g_StatusCallbackCS );

    if (g_bGPOCSInited)
        DeleteCriticalSection( &g_GPOCS );
}


//*************************************************************
//
//  ProcessGroupPolicyCompletedEx()
//
//  Purpose:    Callback for asynchronous completion of an extension
//
//  Parameters: refExtensionId    -  Unique guid of extension
//              pAsyncHandle      -  Completion context
//              dwStatus          -  Asynchronous completion status
//              hrRsopStatus      -  Rsop Logging Status 
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD ProcessGroupPolicyCompletedEx( REFGPEXTENSIONID extensionGuid,
                                   ASYNCCOMPLETIONHANDLE pAsyncHandle,
                                   DWORD dwStatus, HRESULT hrRsopStatus )
{
    DWORD dwRet = E_FAIL;
    TCHAR szExtension[64];
    PGROUP_POLICY_OBJECT pGPOList = NULL;
    LPGPOINFO lpGPOInfo = NULL;
    BOOL bUsePerUserLocalSetting = FALSE;
    DWORD dwCurrentTime = GetCurTime();
    HRESULT hr = S_OK;

    LPGPINFOHANDLE pGPHandle = (LPGPINFOHANDLE) pAsyncHandle;;
     
    if( !pGPHandle ) // Fixing bug 561426
        return ERROR_INVALID_PARAMETER;

    if ( extensionGuid == 0 )
        return ERROR_INVALID_PARAMETER;

    

    GuidToString( extensionGuid, szExtension );

    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompleted: Entering. Extension = %s, dwStatus = 0x%x"),
              szExtension, dwStatus));

    EnterCriticalSection( &g_GPOCS );

    if ( !(pGPHandle == g_pMachGPInfo || pGPHandle == g_pUserGPInfo) ) {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion is stale"),
                  szExtension));
        goto Exit;
    }

    DmAssert( pGPHandle->pGPOInfo != NULL );

    if ( pGPHandle->pGPOInfo == NULL ) {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion has invalid pGPHandle->pGPOInfo"),
                  szExtension));
        goto Exit;
    }

    lpGPOInfo = pGPHandle->pGPOInfo;

    if ( (lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopMachGPOProcessing
         || !(lpGPOInfo->dwFlags & GP_MACHINE) && g_bStopUserGPOProcessing ) {

        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, aborting due to machine shutdown or logoff"),
                  szExtension));
        CEvents ev(TRUE, EVENT_GPO_PROC_STOPPED); ev.Report();
        goto Exit;

    }

    if ( dwStatus != ERROR_SUCCESS ) {

        //
        // Extension returned error code, so no need to update history
        //

        dwRet = ERROR_SUCCESS;
        goto Exit;
    }

    if ( pGPHandle == 0 ) {
         DebugMsg((DM_WARNING, TEXT("Extension %s is using 0 as asynchronous completion handle"),
                   szExtension));
         goto Exit;
    }

    bUsePerUserLocalSetting = !(lpGPOInfo->dwFlags & GP_MACHINE)
                              && ExtensionHasPerUserLocalSetting( szExtension, HKEY_LOCAL_MACHINE );

    if ( ReadGPOList( szExtension, lpGPOInfo->hKeyRoot,
                      HKEY_LOCAL_MACHINE,
                      lpGPOInfo->lpwszSidUser,
                      TRUE, &pGPOList ) ) {

        if ( SaveGPOList( szExtension, lpGPOInfo,
                          HKEY_LOCAL_MACHINE,
                          NULL,
                          FALSE, pGPOList ) ) {

            if ( bUsePerUserLocalSetting ) {

                if ( SaveGPOList( szExtension, lpGPOInfo,
                                  HKEY_LOCAL_MACHINE,
                                  lpGPOInfo->lpwszSidUser,
                                  FALSE, pGPOList ) ) {
                     dwRet = ERROR_SUCCESS;
                } else {
                    DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to save GPOList"),
                              szExtension));
                }

            } else
                dwRet = ERROR_SUCCESS;

        } else {
            DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to save GPOList"),
                      szExtension));
        }
    } else {
        DebugMsg((DM_WARNING, TEXT("Extension %s asynchronous completion, failed to read shadow GPOList"),
                  szExtension));
    }

Exit:
    
    FgPolicyRefreshInfo info = { GP_ReasonUnknown, GP_ModeAsyncForeground };
    LPWSTR szSid = 0;
    
    if (lpGPOInfo)
    {
        szSid = lpGPOInfo->dwFlags & GP_MACHINE ? 0 : lpGPOInfo->lpwszSidUser;

        DWORD dwError;
        if ( dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
        {
            FgPolicyRefreshInfo curInfo = { GP_ReasonUnknown, GP_ModeUnknown};
            GetCurrentFgPolicyRefreshInfo( szSid, &curInfo );
            SetPreviousFgPolicyRefreshInfo( szSid, curInfo );

            info.mode = GP_ModeSyncForeground;
            info.reason = GP_ReasonCSERequiresSync;
            dwError = SetNextFgPolicyRefreshInfo(   szSid,
                                                    info );
            if ( dwError != ERROR_SUCCESS )
            {
                DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: SetNextFgPolicyRefreshInfo failed, %x."), dwError ));
            }
        }

        if ( dwRet == ERROR_SUCCESS )
        {
            //
            // clear E_PENDING status code with status returned
            //
            bUsePerUserLocalSetting = !(lpGPOInfo->dwFlags & GP_MACHINE) && lpGPOInfo->lpwszSidUser != NULL;
            GPEXTSTATUS  gpExtStatus;

            gpExtStatus.dwSlowLink = (lpGPOInfo->dwFlags & GP_SLOW_LINK) != 0;
            gpExtStatus.dwRsopLogging = lpGPOInfo->bRsopLogging;
            gpExtStatus.dwStatus = dwStatus;
            gpExtStatus.dwTime = dwCurrentTime;
            gpExtStatus.bForceRefresh = FALSE;

            WriteStatus( szExtension, lpGPOInfo,
                         bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                         &gpExtStatus);

            //
            // Building up a dummy gpExt structure so that we can log the info required.
            //

            GPEXT        gpExt;
            TCHAR        szSubKey[MAX_PATH]; // same as the path in readgpextensions
            HKEY         hKey;
            TCHAR        szDisplayName[50]; // same as the path in readgpextensions
            DWORD        dwSize, dwType;
            CHAR         szFunctionName[100]; // same as the path in readgpextensions

            gpExt.lpKeyName = szExtension;

            hr = StringCchCopy(szSubKey, ARRAYSIZE(szSubKey), GP_EXTENSIONS);
            ASSERT(SUCCEEDED(hr));
            CheckSlash(szSubKey);
            hr = StringCchCat(szSubKey, ARRAYSIZE(szSubKey), szExtension);
            ASSERT(SUCCEEDED(hr));


            //
            // Read the displayname so that we can log it..
            //

            szDisplayName[0] = TEXT('\0');

            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {

                dwSize = sizeof(szDisplayName);
                if (RegQueryValueEx (hKey, NULL, NULL,
                                     &dwType, (LPBYTE) szDisplayName,
                                     &dwSize) != ERROR_SUCCESS)
                {
                    lstrcpyn (szDisplayName, szExtension, ARRAYSIZE(szDisplayName));
                }


                dwSize = sizeof(szFunctionName);
                if ( RegQueryValueExA (hKey, "ProcessGroupPolicyEx", NULL,
                                       &dwType, (LPBYTE) szFunctionName,
                                       &dwSize) == ERROR_SUCCESS )
                {
                    gpExt.bNewInterface = TRUE;
                }

                RegCloseKey(hKey);
            }

            gpExt.lpDisplayName = szDisplayName;

            if ((lpGPOInfo->bRsopLogging))
            {

                XInterface<IWbemServices> xWbemServices;

                GetWbemServices( lpGPOInfo, RSOP_NS_DIAG_ROOT, TRUE, FALSE, &xWbemServices);

                if (xWbemServices)
                {

                    if (!gpExt.bNewInterface)
                    {
                        DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: Extension %s doesn't support rsop logging."),
                                  szExtension));

                        UpdateExtSessionStatus(xWbemServices, szExtension, TRUE, dwRet);        
                    }
                    else if (SUCCEEDED(hrRsopStatus))
                    {
                        DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompletedEx: Extension %s was able to log data. Error = 0x%x, dwRet = %d. Clearing the dirty bit"),
                                  szExtension, hrRsopStatus, dwStatus));

                        UpdateExtSessionStatus(xWbemServices, szExtension, FALSE, dwRet);        
                    }
                    else
                    {
                        DebugMsg((DM_VERBOSE, TEXT("ProcessroupPolicyCompletedEx: Extension %s was not able to log data. Error = 0x%x, dwRet = %d. leaving the log dirty"),
                                  szExtension, hrRsopStatus, dwStatus));

                        CEvents ev(TRUE, EVENT_EXT_RSOP_FAILED);
                        ev.AddArg(gpExt.lpDisplayName); ev.Report();

                        UpdateExtSessionStatus(xWbemServices, szExtension, TRUE, dwRet);        
                    }
                }
            }
        }
    }

    LeaveCriticalSection( &g_GPOCS );

    DebugMsg((DM_VERBOSE, TEXT("ProcessGroupPolicyCompleted: Leaving. Extension = %s, Return status dwRet = 0x%x"),
              szExtension, dwRet));

    return dwRet;
}

//*************************************************************
//
//  ProcessGroupPolicyCompleted()
//
//  Purpose:    Callback for asynchronous completion of an extension
//
//  Parameters: refExtensionId    -  Unique guid of extension
//              pAsyncHandle      -  Completion context
//              dwStatus          -  Asynchronous completion status
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD ProcessGroupPolicyCompleted( REFGPEXTENSIONID extensionGuid,
                                   ASYNCCOMPLETIONHANDLE pAsyncHandle,
                                   DWORD dwStatus )
{
    //
    // Mark RSOP data as clean for legacy extensions
    //

    return ProcessGroupPolicyCompletedEx(extensionGuid, pAsyncHandle, dwStatus, 
                                       HRESULT_FROM_WIN32(S_OK));
}



//*************************************************************
//
//  DebugPrintGPOList()
//
//  Purpose:    Prints GPO list
//
//  Parameters: lpGPOInfo    -  GPO Info
//
//*************************************************************

void DebugPrintGPOList( LPGPOINFO lpGPOInfo )
{
    //
    // If we are in verbose mode, put the list of GPOs in the event log
    //

    PGROUP_POLICY_OBJECT lpGPO = NULL;
    DWORD dwSize;
    HRESULT hr = S_OK;

#if DBG
    if (TRUE) {
#else
    if (lpGPOInfo->dwFlags & GP_VERBOSE) {
#endif
        LPTSTR lpTempList;

        dwSize = 10;
        lpGPO = lpGPOInfo->lpGPOList;
        while (lpGPO) {
            if (lpGPO->lpDisplayName) {
                dwSize += (lstrlen (lpGPO->lpDisplayName) + 4);  
            }
            lpGPO = lpGPO->pNext;
        }

        lpTempList = (LPWSTR) LocalAlloc (LPTR, (dwSize * sizeof(TCHAR)));

        if (lpTempList) {

            hr = StringCchCopy (lpTempList, dwSize, TEXT(""));
            ASSERT(SUCCEEDED(hr));

            lpGPO = lpGPOInfo->lpGPOList;
            while (lpGPO) {
                if (lpGPO->lpDisplayName) {
                    hr = StringCchCat (lpTempList, dwSize, TEXT("\""));
                    ASSERT(SUCCEEDED(hr));
                    hr = StringCchCat (lpTempList, dwSize, lpGPO->lpDisplayName);
                    ASSERT(SUCCEEDED(hr));
                    hr = StringCchCat (lpTempList, dwSize, TEXT("\" "));
                    ASSERT(SUCCEEDED(hr));
                }
                lpGPO = lpGPO->pNext;
            }

            if (lpGPOInfo->dwFlags & GP_VERBOSE) {
                CEvents ev(FALSE, EVENT_GPO_LIST);
                ev.AddArg(lpTempList); ev.Report();
            }

            DebugMsg((DM_VERBOSE, TEXT("DebugPrintGPOList: List of GPO(s) to process: %s"),
                     lpTempList));

            LocalFree (lpTempList);
        }
    }
}




//*************************************************************
//
//  UserPolicyCallback()
//
//  Purpose:    Callback function for status UI messages
//
//  Parameters: bVerbose  - Verbose message or not
//              lpMessage - Message text
//
//  Return:     ERROR_SUCCESS if successful
//              Win32 error code if an error occurs
//
//*************************************************************

DWORD UserPolicyCallback (BOOL bVerbose, LPWSTR lpMessage)
{
    WCHAR szMsg[100];
    LPWSTR lpMsg;
    DWORD dwResult = ERROR_INVALID_FUNCTION;


    if (lpMessage) {
        lpMsg = lpMessage;
    } else {
        if (!LoadString (g_hDllInstance, IDS_USER_SETTINGS, szMsg, 100))
        {
            DebugMsg((DM_WARNING, TEXT("UserPolicyCallback: Couldn't load string from resource with %d"), GetLastError()));
            return GetLastError();
        }
        
        lpMsg = szMsg;
    }

    DebugMsg((DM_VERBOSE, TEXT("UserPolicyCallback: Setting status UI to %s"), lpMsg));

    EnterCriticalSection (&g_StatusCallbackCS);

    if (g_pStatusMessageCallback) {
        dwResult = g_pStatusMessageCallback(bVerbose, lpMsg);
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UserPolicyCallback: Extension requested status UI when status UI is not available.")));
    }

    LeaveCriticalSection (&g_StatusCallbackCS);

    return dwResult;
}

//*************************************************************
//
//  MachinePolicyCallback()
//
//  Purpose:    Callback function for status UI messages
//
//  Parameters: bVerbose  - Verbose message or not
//              lpMessage - Message text
//
//  Return:     ERROR_SUCCESS if successful
//              Win32 error code if an error occurs
//
//*************************************************************

DWORD MachinePolicyCallback (BOOL bVerbose, LPWSTR lpMessage)
{
    WCHAR szMsg[100];
    LPWSTR lpMsg;
    DWORD dwResult = ERROR_INVALID_FUNCTION;


    if (lpMessage) {
        lpMsg = lpMessage;
    } else {
        if (!LoadString (g_hDllInstance, IDS_COMPUTER_SETTINGS, szMsg, 100))
        {
            DebugMsg((DM_WARNING, TEXT("MachinePolicyCallback: Couldn't load string from resource with %d"), GetLastError()));
            return GetLastError();
        }

        lpMsg = szMsg;
    }

    DebugMsg((DM_VERBOSE, TEXT("MachinePolicyCallback: Setting status UI to %s"), lpMsg));

    EnterCriticalSection (&g_StatusCallbackCS);

    if (g_pStatusMessageCallback) {
        dwResult = g_pStatusMessageCallback(bVerbose, lpMsg);
    } else {
        DebugMsg((DM_VERBOSE, TEXT("MachinePolicyCallback: Extension requested status UI when status UI is not available.")));
    }

    LeaveCriticalSection (&g_StatusCallbackCS);

    return dwResult;
}



//*************************************************************
//
//  CallDFS()
//
//  Purpose:    Calls DFS to initialize the domain / DC name
//
//  Parameters:  lpDomainName  - Domain name
//               lpDCName      - DC name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

//
// Once upon a time when this file was a C file,
// the definition of POINTER_TO_OFFSET looked like this,
//
// #define POINTER_TO_OFFSET(field, buffer)  \
//     ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )
//
// Now, that we have decided to end antiquity and made this a C++ file,
// the new definition is,
//

#define POINTER_TO_OFFSET(field, buffer)  \
    ( field = (LPWSTR) ( (PCHAR)field -(ULONG_PTR)buffer ) )

NTSTATUS CallDFS(LPWSTR lpDomainName, LPWSTR lpDCName)
{
    HANDLE DfsDeviceHandle = NULL;
    PDFS_SPC_REFRESH_INFO DfsInfo;
    ULONG lpDomainNameLen, lpDCNameLen, sizeNeeded;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    UNICODE_STRING unicodeServerName;


    lpDomainNameLen = (wcslen(lpDomainName) + 1) * sizeof(WCHAR);         
    lpDCNameLen = (wcslen(lpDCName) + 1) * sizeof(WCHAR);                  

    sizeNeeded = sizeof(DFS_SPC_REFRESH_INFO) + lpDomainNameLen + lpDCNameLen;

    DfsInfo = (PDFS_SPC_REFRESH_INFO)LocalAlloc(LPTR, sizeNeeded);

    if (DfsInfo == NULL) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  LocalAlloc failed with %d"), GetLastError()));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DfsInfo->DomainName = (WCHAR *)((PCHAR)DfsInfo + sizeof(DFS_SPC_REFRESH_INFO));
    DfsInfo->DCName = (WCHAR *)((PCHAR)DfsInfo->DomainName + lpDomainNameLen);


    RtlCopyMemory(DfsInfo->DomainName,   
                  lpDomainName,
                  lpDomainNameLen);

    RtlCopyMemory(DfsInfo->DCName,       
                  lpDCName,
                  lpDCNameLen);

    POINTER_TO_OFFSET(DfsInfo->DomainName, DfsInfo);
    POINTER_TO_OFFSET(DfsInfo->DCName, DfsInfo);

    RtlInitUnicodeString( &unicodeServerName, L"\\Dfs");

    InitializeObjectAttributes(
          &objectAttributes,
          &unicodeServerName,
          OBJ_CASE_INSENSITIVE,
          NULL,
          NULL
          );

    status = NtOpenFile(
                &DfsDeviceHandle,
                SYNCHRONIZE | FILE_WRITE_DATA,
                &objectAttributes,
                &ioStatusBlock,
                0,
                FILE_SYNCHRONOUS_IO_NONALERT
                );



    if (!NT_SUCCESS(status) ) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  NtOpenFile failed with 0x%x"), status));
        LocalFree(DfsInfo);
        return status;
    }

    status = NtFsControlFile(
                DfsDeviceHandle,
                NULL,
                NULL,
                NULL,
                &ioStatusBlock,
                FSCTL_DFS_SPC_REFRESH,
                DfsInfo, sizeNeeded,
                NULL, 0);

    if (!NT_SUCCESS(status) ) {
        DebugMsg((DM_WARNING, TEXT("CallDFS:  NtFsControlFile failed with 0x%x"), status));
    }


    LocalFree(DfsInfo);
    NtClose(DfsDeviceHandle);
    return status;
}




//*************************************************************
//
//  InitializePolicyProcessing
//
//  Purpose:    Initialises mutexes corresponding to user and machine
//
//  Parameters: bMachine - Whether it is machine or user
//
//  Return:
//
//  Comments:
//      These events/Mutexes need to be initialised right at the beginning
// because the ACls on these needs to be set before ApplyGroupPolicy can
// be called..
// 
//*************************************************************

BOOL InitializePolicyProcessing(BOOL bMachine)
{
    HANDLE hSection, hEvent;
    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;
    XLastError xe;


    Csd.AddLocalSystem();
    Csd.AddAdministrators();
    Csd.AddEveryOne(SYNCHRONIZE);

    xsd = Csd.MakeSD();

    if (!xsd) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create Security Descriptor with %d"),
                 GetLastError()));
        // since this is happening in dll load we cannot log an event at this point..
        return FALSE;
    }


    sa.lpSecurityDescriptor = (SECURITY_DESCRIPTOR *)xsd;
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(sa);


    //
    // Synch mutex for group policies
    //

    hSection = CreateMutex (&sa, FALSE,    
                       (bMachine ? MACHINE_POLICY_MUTEX : USER_POLICY_MUTEX));

    if (!hSection) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create mutex with %d"),
                 GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyCritMutexMach = hSection;
    else
        g_hPolicyCritMutexUser = hSection;

    //
    // Mutex for registry policy only
    //
    HANDLE hRegistrySection = CreateMutex(&sa, FALSE,
        (bMachine ? MACH_REGISTRY_EXT_MUTEX : USER_REGISTRY_EXT_MUTEX ));

    if (!hRegistrySection) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create mutex with %d"),
                 GetLastError()));
        return FALSE;
    }
    
    if (bMachine)
        g_hRegistryPolicyCritMutexMach = hRegistrySection;
    else
        g_hRegistryPolicyCritMutexUser = hRegistrySection;



    //
    // Group Policy Notification events
    //


    //
    // Create the changed notification event
    //

    hEvent = CreateEvent (&sa, TRUE, FALSE,       
                               (bMachine) ? MACHINE_POLICY_APPLIED_EVENT : USER_POLICY_APPLIED_EVENT);


    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create NotifyEvent with %d"),
                 GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyNotifyEventMach = hEvent;
    else
        g_hPolicyNotifyEventUser = hEvent;

    //
    // Create the needfg event
    //

    hEvent = CreateEvent (&sa, FALSE, FALSE,            
                                (bMachine) ? MACHINE_POLICY_REFRESH_NEEDFG_EVENT : USER_POLICY_REFRESH_NEEDFG_EVENT);

    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create NeedFGEvent with %d"),
                    GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyNeedFGEventMach = hEvent;
    else
        g_hPolicyNeedFGEventUser = hEvent;
    
    
    //
    // Create the done event 
    //
    hEvent = CreateEvent (&sa, TRUE, FALSE,             
                                (bMachine) ? MACHINE_POLICY_DONE_EVENT : USER_POLICY_DONE_EVENT);
    if (!hEvent) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create hNotifyDoneEvent with %d"),
                    GetLastError()));
        return FALSE;
    }

    if (bMachine)
        g_hPolicyDoneEventMach = hEvent;
    else
        g_hPolicyDoneEventUser = hEvent;

    //
    // Create the machine policy - user policy sync event 
    //
    if ( bMachine )
    {
        hEvent = CreateEvent(   &sa,               
                                TRUE,
                                FALSE,
                                MACH_POLICY_FOREGROUND_DONE_EVENT );
        if ( !hEvent )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create m/c-user policy sync event with %d"),
                        GetLastError()));
            return FALSE;
        }
        else
        {
            g_hPolicyForegroundDoneEventMach = hEvent;
        }
    }
    else
    {
        hEvent = CreateEvent(   &sa,      
                                TRUE,
                                FALSE,
                                USER_POLICY_FOREGROUND_DONE_EVENT );
        if ( !hEvent )
        {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializePolicyProcessing: Failed to create user policy/logon script sync event with %d"),
                        GetLastError()));
            return FALSE;
        }
        else
        {
            g_hPolicyForegroundDoneEventUser = hEvent;
        }
    }
        
    DebugMsg((DM_VERBOSE, TEXT("InitializePolicyProcessing: Initialised %s Mutex/Events"),
             bMachine ? TEXT("Machine"): TEXT("User")));

    return TRUE;
}

USERENVAPI
DWORD
WINAPI
WaitForUserPolicyForegroundProcessing()
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hEvent = OpenEvent( SYNCHRONIZE, FALSE, USER_POLICY_FOREGROUND_DONE_EVENT );

    if ( hEvent )
    {
        if ( WaitForSingleObject( hEvent, INFINITE ) == WAIT_FAILED )
        {
            dwError = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("WaitForUserPolicyForegroundProcessing: Failed, %x"), dwError ));
        }
        CloseHandle( hEvent );
    }
    else
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("WaitForUserPolicyForegroundProcessing: Failed, %x"), dwError ));
    }
    return dwError;
}

USERENVAPI
DWORD
WINAPI
WaitForMachinePolicyForegroundProcessing()
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hEvent = OpenEvent( SYNCHRONIZE, FALSE, MACH_POLICY_FOREGROUND_DONE_EVENT );

    if ( hEvent )
    {
        if ( WaitForSingleObject( hEvent, INFINITE ) == WAIT_FAILED )
        {
            dwError = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("WaitForMachinePolicyForegroundProcessing: Failed, %x"), dwError ));
        }
        CloseHandle( hEvent );
    }
    else
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("WaitForMachinePolicyForegroundProcessing: Failed, %x"), dwError ));
    }
    return dwError;
}

extern "C" DWORD
SignalUserPolicyForegroundProcessingDone()
{
    DWORD dwError = ERROR_SUCCESS;
    if ( !SetEvent( g_hPolicyForegroundDoneEventUser ) )
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("SignalUserPolicyForegroundProcessingDone: Failed, %x"), dwError ));
    }
    return dwError;
}

extern "C" DWORD
SignalMachinePolicyForegroundProcessingDone()
{
    DWORD dwError = ERROR_SUCCESS;
    if ( !SetEvent( g_hPolicyForegroundDoneEventMach ) )
    {
        dwError = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("SignalForMachinePolicyForegroundProcessingDone: Failed, %x"), dwError ));
    }
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\plgpt.cpp ===
//*************************************************************
//
//  Group Policy Support for planning mode
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

DWORD GenerateRegistryPolicy( DWORD dwFlags,
                              BOOL *pbAbort,
                              WCHAR *pwszSite,
                              PRSOP_TARGET pComputerTarget,
                              PRSOP_TARGET pUserTarget );

BOOL GenerateGpoInfo( WCHAR *pwszDomain, WCHAR *pwszDomainDns, WCHAR *pwszAccount,
                      WCHAR *pwszNewSOM, SAFEARRAY *psaSecGroups,
                      DWORD dwFlags, BOOL bMachine, WCHAR *pwszSite, CGpoFilter *pGpoFilter, CLocator *pLocator, 
                       WCHAR *pwszMachAccount, WCHAR *pwszNewMachSOM, LPGPOINFO pGpoInfo, PNETAPI32_API pNetAPI32 );


BOOL GetCategory( WCHAR *pwszDomain, WCHAR *pwszAccount, WCHAR **ppwszDNName );

extern "C" DWORD ProcessMachAndUserGpoList( LPGPEXT lpExtMach, LPGPEXT lpExtUser, DWORD dwFlags, WCHAR *pwszSite,
                 WCHAR *pwszMach, WCHAR *pwszNewComputerOU, SAFEARRAY *psaComputerSecurityGroups, LPGPOINFO pGpoInfoMach,
                 WCHAR *pwszUser, WCHAR *pwszNewUserOU, SAFEARRAY *psaUserSecurityGroups, LPGPOINFO pGpoInfoUser );


BOOL ProcessRegistryFiles(PRSOP_TARGET pTarget, REGHASHTABLE *pHashTable);
BOOL ProcessRegistryValue ( void* pUnused,
                            LPTSTR lpKeyName,
                            LPTSTR lpValueName,
                            DWORD dwType,
                            DWORD dwDataLength,
                            LPBYTE lpData,
                            WCHAR *pwszGPO,
                            WCHAR *pwszSOM,
                            REGHASHTABLE *pHashTable);
BOOL ProcessAdmData( PRSOP_TARGET pTarget, BOOL bUser );



//*************************************************************
//
//  GenerateRsopPolicy()
//
//  Purpose:    Generates planning mode Rsop policy for specified target
//
//  Parameters: dwFlags          - Processing flags
//              bstrMachName     - Target computer name
//              bstrNewMachSOM   - New machine domain or OU
//              psaMachSecGroups - New machine security groups
//              bstrUserName     - Target user name
//              psaUserSecGroups - New user security groups
//              bstrSite         - Site of target computer
//              pwszNameSpace    - Namespace to write Rsop data
//              pvProgress       - Progress indicator class
//              pvGpoFilter       - GPO filter class
//
//  Return:     True if successful, False otherwise
//
//  Notes:      If a new SOM is specified then that is used instead of
//              the SOM the target belongs to. Similarly, if new
//              security groups are specified then that is used instead of
//              the security groups that the target belongs to. If
//              target name is null and both new SOM and new security
//              groups are non-null, then we simulate a dummy target; otherwise
//              we skip generating planning mode info for the target.
//
//*************************************************************

BOOL GenerateRsopPolicy( DWORD dwFlags, BSTR bstrMachName,
                         BSTR bstrNewMachSOM, SAFEARRAY *psaMachSecGroups,
                         BSTR bstrUserName, BSTR bstrNewUserSOM,
                         SAFEARRAY *psaUserSecGroups,
                         BSTR bstrSite,
                         WCHAR *pwszNameSpace,
                         LPVOID pvProgress,
                         LPVOID pvMachGpoFilter,
                         LPVOID pvUserGpoFilter )
{
    LPGPOINFO pGpoInfoMach = NULL;
    LPGPOINFO pGpoInfoUser = NULL;
    PNETAPI32_API pNetAPI32 = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDsInfo = NULL;
    BOOL bDC = FALSE;
    DWORD dwResult;
    LPWSTR pwszDomain = NULL;
    LPWSTR pwszMachDns = NULL;
    LPWSTR pwszDomainDns = NULL;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPGPEXT lpExtMach = NULL;
    LPGPEXT lpExtUser = NULL;
    LPGPEXT lpExt,lpTemp = NULL;
    WCHAR *pwszMach = (WCHAR *) bstrMachName;
    WCHAR *pwszUser = (WCHAR *) bstrUserName;
    DWORD   dwExtCount = 1;
    DWORD   dwIncrPercent;
    CProgressIndicator* pProgress = (CProgressIndicator*) pvProgress;
    CGpoFilter *pMachGpoFilter = (CGpoFilter *) pvMachGpoFilter;
    CGpoFilter *pUserGpoFilter = (CGpoFilter *) pvUserGpoFilter;
    RSOPSESSIONDATA rsopSessionData;
    LPRSOPSESSIONDATA  lprsopSessionData;
    BOOL bDummyMach = pwszMach == NULL && bstrNewMachSOM != NULL;
    BOOL bDummyUser  = pwszUser == NULL && bstrNewUserSOM != NULL;
    DWORD dwUserGPCoreError = ERROR_SUCCESS;
    DWORD dwMachGPCoreError = ERROR_SUCCESS;
    CLocator locator;
    HRESULT hr = S_OK;
    XLastError xe; 

    //
    // Allow debugging level to be changed dynamically
    //

    InitDebugSupport( FALSE );


    if ( pwszUser == NULL && pwszMach == NULL && !bDummyUser && !bDummyMach ) {
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Both user and machine names cannot be NULL.")));
        xe = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy:  Failed to load netapi32 with %d."),
                 GetLastError()));
        // error logged in LoadNetAPI32
        goto Exit;
    }

    //
    // Get the role of this computer
    //

    dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation( NULL, DsRolePrimaryDomainInfoBasic,
                                                               (PBYTE *)&pDsInfo );

    if (dwResult != ERROR_SUCCESS) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: DsRoleGetPrimaryDomainInformation failed with %d."), dwResult));
        goto Exit;
    }

    if ( pDsInfo->MachineRole == DsRole_RoleBackupDomainController
         || pDsInfo->MachineRole == DsRole_RolePrimaryDomainController ) {
        bDC = TRUE;
    }

    if ( !bDC ) {
        xe = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("GeneratRsopPolicy: Rsop data can be generated on a DC only")));
        goto Exit;
    }

    pwszDomain = pDsInfo->DomainNameFlat;

    //
    // Get the machine name in dns format, so that ldap_bind can be done to this specific DC.
    //

    dwSize = 0;
    GetComputerNameEx( ComputerNameDnsFullyQualified, pwszMachDns, &dwSize );

    if ( dwSize > 0 ) {

        pwszMachDns = (WCHAR *) LocalAlloc (LPTR, dwSize * sizeof(WCHAR) );
        if ( pwszMachDns == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Failed to allocate memory")));
            goto Exit;
        }

    } else {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GetComputerNameEx failed")));
        goto Exit;
    }

    bResult = GetComputerNameEx( ComputerNameDnsFullyQualified, pwszMachDns, &dwSize );
    if ( !bResult ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GetComputerNameEx failed")));
        goto Exit;
    }

    pwszDomainDns = pwszMachDns;

    //
    //  5% of the task is done
    //
    pProgress->IncrementBy( 5 );

    //
    // Setup computer target info, if any
    //

    bResult = FALSE;

    if ( pwszMach || bDummyMach ) {

        pGpoInfoMach = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

        if (!pGpoInfoMach) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to alloc lpGPOInfo (%d)."),
                      GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        pGpoInfoMach->dwFlags = GP_PLANMODE | GP_MACHINE;


        bResult = GetWbemServices( pGpoInfoMach, pwszNameSpace, TRUE, NULL, &(pGpoInfoMach->pWbemServices) );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when getting Wbemservices.")));
            goto Exit;
        }

        //
        // First set dirty to be true
        //

        bResult = LogExtSessionStatus(pGpoInfoMach->pWbemServices, NULL, TRUE);        
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            goto Exit;
        }

        if ( ! GenerateGpoInfo( pwszDomain, pwszDomainDns, pwszMach,
                                (WCHAR *) bstrNewMachSOM, psaMachSecGroups, dwFlags, TRUE,
                                (WCHAR *) bstrSite, pMachGpoFilter, &locator, NULL, NULL, pGpoInfoMach, pNetAPI32 ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GenerateGpoInfo failed with %d."), xe));
            dwMachGPCoreError = (xe) ? xe : E_FAIL;
        }
        else {
            dwMachGPCoreError = ERROR_SUCCESS;
        }

    }

    //
    //  10% of the task is done
    //
    pProgress->IncrementBy( 5 );

    //
    // Setup user target info, if any
    //

    if ( pwszUser || bDummyUser ) {
        pGpoInfoUser = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

        if (!pGpoInfoUser) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to alloc lpGPOInfo (%d)."),
                      GetLastError()));
            CEvents ev(TRUE, EVENT_FAILED_ALLOCATION);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            goto Exit;
        }

        pGpoInfoUser->dwFlags = GP_PLANMODE;


        bResult = GetWbemServices( pGpoInfoUser, pwszNameSpace, TRUE, NULL, &(pGpoInfoUser->pWbemServices));
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when getting Wbemservices.")));
            goto Exit;
        }

        //
        // First set dirty to be true
        //

        bResult = LogExtSessionStatus(pGpoInfoUser->pWbemServices, NULL, TRUE);        
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            goto Exit;
        }


        if ( ! GenerateGpoInfo( pwszDomain, pwszDomainDns, pwszUser,
                                (WCHAR *) bstrNewUserSOM, psaUserSecGroups, dwFlags, FALSE, (WCHAR *) bstrSite,
                                pUserGpoFilter, &locator, pwszMach, (WCHAR *) bstrNewMachSOM, pGpoInfoUser, pNetAPI32 ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: GenerateGpoInfo failed with %d."), xe));
            dwUserGPCoreError = (xe) ? xe : E_FAIL;
        }
        else {
            dwUserGPCoreError = ERROR_SUCCESS;
        }
    }

    //
    // Log Gpo info to WMI's database
    //


    lprsopSessionData = &rsopSessionData;

    if ( pwszMach || bDummyMach ) {

        XPtrLF<TOKEN_GROUPS> xGrps;

        if ( pGpoInfoMach->pRsopToken != NULL )
        {
            hr = RsopSidsFromToken(pGpoInfoMach->pRsopToken, &xGrps);

            if (FAILED(hr)) {
                xe = HRESULT_CODE(hr);
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: RsopSidsFromToken failed with error 0x%x."), hr));
                goto Exit;

            }
        }

        //
        // Fill up the rsop Session Data (Machine Specific)
        //

        //
        // Add the relevant flags corresponding to the input parameters for machine
        //

        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: Marking the flags for machine with appropriate input parameters")));

        lprsopSessionData->dwFlags = FLAG_PLANNING_MODE;
        lprsopSessionData->dwFlags |= (dwFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE);

        lprsopSessionData->pwszTargetName = pwszMach;
        lprsopSessionData->pwszSOM = GetSomPath(bstrNewMachSOM ? bstrNewMachSOM : pGpoInfoMach->lpDNName);
        if ( pGpoInfoMach->pRsopToken != NULL )
        {
            lprsopSessionData->pSecurityGroups = (PTOKEN_GROUPS)xGrps;
            lprsopSessionData->bLogSecurityGroup = TRUE;
        }
        else
        {
            lprsopSessionData->pSecurityGroups = 0;
            lprsopSessionData->bLogSecurityGroup = FALSE;
        }
        lprsopSessionData->pwszSite =  (WCHAR *) bstrSite;
        lprsopSessionData->bMachine = TRUE;
        lprsopSessionData->bSlowLink = ( dwFlags & FLAG_ASSUME_SLOW_LINK ) ? TRUE: FALSE;


        bResult = LogRsopData( pGpoInfoMach, lprsopSessionData );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging machine Rsop data.")));
            goto Exit;
        }

        pGpoInfoMach->bRsopLogging = TRUE;
    }

    if ( pwszUser || bDummyUser ) {
        
        XPtrLF<TOKEN_GROUPS> xGrps;

        if ( pGpoInfoUser->pRsopToken != NULL )
        {
            hr = RsopSidsFromToken(pGpoInfoUser->pRsopToken, &xGrps);

            if (FAILED(hr)) {
                xe = HRESULT_CODE(hr);
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: RsopSidsFromToken failed with error 0x%x."), hr));
                goto Exit;

            }
        }


        //
        // Fill up the rsop Session Data (User Specific)
        //

        lprsopSessionData->pwszTargetName = pwszUser;
        lprsopSessionData->pwszSOM = GetSomPath(bstrNewUserSOM ? bstrNewUserSOM : pGpoInfoUser->lpDNName);
        
        //
        // Add the relevant flags corresponding to the input parameters for user
        //

        lprsopSessionData->dwFlags = FLAG_PLANNING_MODE;
        lprsopSessionData->dwFlags |= (dwFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE);
        lprsopSessionData->dwFlags |= (dwFlags & FLAG_LOOPBACK_MERGE);
        lprsopSessionData->dwFlags |= (dwFlags & FLAG_LOOPBACK_REPLACE);
        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: Marking the flags for user with appropriate input parameters")));

        if ( pGpoInfoUser->pRsopToken != NULL )
        {
            lprsopSessionData->pSecurityGroups = (PTOKEN_GROUPS)xGrps;
            lprsopSessionData->bLogSecurityGroup = TRUE;
        }
        else
        {
            lprsopSessionData->pSecurityGroups = 0;
            lprsopSessionData->bLogSecurityGroup = FALSE;
        }
        lprsopSessionData->pwszSite =  (WCHAR *) bstrSite;
        lprsopSessionData->bMachine = FALSE;
        lprsopSessionData->bSlowLink = ( dwFlags & FLAG_ASSUME_SLOW_LINK ) ? TRUE: FALSE;


        bResult = LogRsopData( pGpoInfoUser, lprsopSessionData );
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Rsop data.")));
            goto Exit;
        }
        
        pGpoInfoUser->bRsopLogging = TRUE;
    }

    if ( ( dwUserGPCoreError != ERROR_SUCCESS) || ( dwMachGPCoreError != ERROR_SUCCESS) ){
        DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Couldn't fetch the user/computer GPO list. Exitting provider.")));
        // note that at this point bResult can be true and we want to actually return that
        // since this error will be part of the GP Core error...
        goto Exit;
    }

    //
    //  15% of the task is done
    //
    pProgress->IncrementBy( 5 );

    if ( dwFlags & FLAG_NO_CSE_INVOKE )
    {
        bResult = TRUE;
        goto Exit;
    }

    //
    // By this time, pGPOInfoMach should be defined if
    // we needed data for mach and pGPOInfoUser should be
    // defined if we needed the data for user.
    //
    // Assumption: lpExt is the same for both user and Machine
    //

    if (pGpoInfoMach) 
        lpExt = lpExtMach = pGpoInfoMach->lpExtensions;

    if (pGpoInfoUser)
        lpExt = lpExtUser = pGpoInfoUser->lpExtensions;


    //
    // count the number of extensions
    //

    DmAssert(lpExt);

    lpTemp = lpExt;

    while ( lpExt )
    {
        dwExtCount++;
        lpExt = lpExt->pNext;
    }

    lpExt = lpTemp;

    dwIncrPercent = ( pProgress->MaxProgress() - pProgress->CurrentProgress() ) / dwExtCount;

    //
    // Loop through registered extensions, asking them to generate planning mode info
    //

    while ( lpExt ) {

        //
        // Add check here for cancellation of policy generation
        //


        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: -----------------------")));
        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: Processing extension %s"), lpExt->lpDisplayName));

        if (lpExtMach) 
            FilterGPOs( lpExtMach, pGpoInfoMach );

        if (lpExtUser)
            FilterGPOs( lpExtUser, pGpoInfoUser );

        __try {

                dwResult = ProcessMachAndUserGpoList( lpExtMach, lpExtUser, dwFlags, (WCHAR *) bstrSite,
                                                      pwszMach, (WCHAR *) bstrNewMachSOM, psaMachSecGroups, pGpoInfoMach,
                                                      pwszUser, (WCHAR *) bstrNewUserSOM, psaUserSecGroups, pGpoInfoUser );
                pProgress->IncrementBy( dwIncrPercent );

        }
        __except( GPOExceptionFilter( GetExceptionInformation() ) ) {

            RevertToSelf();

            DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Extension %s ProcessGroupPolicy threw unhandled exception 0x%x."),
                      lpExt->lpDisplayName, GetExceptionCode() ));

            CEvents ev(TRUE, EVENT_CAUGHT_EXCEPTION);
            ev.AddArg(lpExt->lpDisplayName); ev.AddArgHex(GetExceptionCode()); ev.Report();
        }

        DebugMsg((DM_VERBOSE, TEXT("GenerateRsopPolicy: -----------------------")));

        if (lpExtMach) 
            lpExtMach = lpExtMach->pNext;

        if (lpExtUser)
            lpExtUser = lpExtUser->pNext;

        lpExt = lpExt->pNext;
    }

    bResult = TRUE;

Exit:

    //
    // if all logging was successful
    //
    
    if ((pGpoInfoUser) && (pGpoInfoUser->bRsopLogging)) {
        bResult = UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, NULL, (!bResult), dwUserGPCoreError );        
    }            

    
    if ((pGpoInfoMach) && (pGpoInfoMach->bRsopLogging)) {
        bResult = UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, NULL, (!bResult), dwMachGPCoreError);        
    }            
    

    UnloadGPExtensions( pGpoInfoMach );
    UnloadGPExtensions( pGpoInfoUser );  // Frees lpExtensions field

    if ( pDsInfo ) {
        pNetAPI32->pfnDsRoleFreeMemory (pDsInfo);
    }

    LocalFree( pwszMachDns );

    FreeGpoInfo( pGpoInfoUser );
    FreeGpoInfo( pGpoInfoMach );

    return bResult;
}



//*************************************************************
//
//  GenerateGpoInfo()
//
//  Purpose:    Allocates and fills in pGpoInfo for specified target
//
//  Parameters: pwszDomain      - Domain name
//              pwszDomainDns   - Dns name of machine for ldap binding
//              pwszAccount     - User or machine account name
//              pwszNewSOM      - New SOM of target
//              psaSecGroups    - New security groups of target
//              dwFlags         - Processing flags
//              bMachine        - Is this machine processing
//              pwszSite        - Site name
//              pGpoFilter      - Gpo filter
//              pLocator        - Wbem interface class
//              pwszMachAccount - Machine account
//              pwszNewMachSOM  - Machine SOM       (abv 2 are applicable only for loopback)
//              ppGpoInfo       - Gpo info returned here
//              pNetApi32       - Delay loaded netap32.dll
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

BOOL GenerateGpoInfo( WCHAR *pwszDomain, WCHAR *pwszDomainDns, WCHAR *pwszAccount,
                      WCHAR *pwszNewSOM, SAFEARRAY *psaSecGroups,
                      DWORD dwFlags, BOOL bMachine, WCHAR *pwszSite, CGpoFilter *pGpoFilter, CLocator *pLocator,
                      WCHAR *pwszMachAccount, WCHAR *pwszNewMachSOM, LPGPOINFO pGpoInfo, PNETAPI32_API pNetAPI32 )
{
    HRESULT hr;
    BOOL bResult = FALSE;
    XPtrLF<WCHAR> xszXlatName;
    PSECUR32_API pSecur32;
    XLastError xe; 
    DWORD dwError = ERROR_SUCCESS;
    XPtrLF<WCHAR> xwszTargetDomain;
    DWORD         dwUserPolicyMode = 0;
    DWORD         dwLocFlags;



    if (!bMachine) {
        if (dwFlags & FLAG_LOOPBACK_MERGE ) {
            dwUserPolicyMode = 1;
        }
        else if (dwFlags & FLAG_LOOPBACK_REPLACE ) {
            dwUserPolicyMode = 2;
        }
    }

    dwLocFlags = GP_PLANMODE | (dwFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE) | (dwFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE);

    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo:  Failed to load Secur32.")));
        return NULL;
    }


    if ( pwszAccount == NULL ) {
        if ( pwszNewSOM == NULL ) {

            //
            // When dummy user is specified then both SOM and security groups
            // must be specified.
            //

            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Incorrect SOM or security specification for dummy target"),
                  GetLastError()));
            goto Exit;
        }
    }

    if ( bMachine )
        dwFlags |= GP_MACHINE;

    dwFlags |= GP_PLANMODE; // mark the processing as planning mode processing

    pGpoInfo->dwFlags = dwFlags;

    //
    // caller can force slow link in planning mode
    //
    if ( dwFlags & FLAG_ASSUME_SLOW_LINK )
    {
        pGpoInfo->dwFlags |= GP_SLOW_LINK;
    }
    else
    {
        pGpoInfo->dwFlags &= ~GP_SLOW_LINK;
    }

    if ( pwszAccount ) {
        if ( !GetCategory( pwszDomain, pwszAccount, &pGpoInfo->lpDNName ) ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
            goto Exit;
        }
    }


    //
    // TranslateName to SamCompatible so that the rest of the functions work correctly
    // for any of the various name formats
    //

    if ( pwszAccount ) {
        DWORD dwSize = MAX_PATH+1;

        xszXlatName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*dwSize);

        if (!xszXlatName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - Couldn't allocate memory for Name...")));
            goto Exit;
        }

        if (!pSecur32->pfnTranslateName(  pwszAccount,
                                        NameUnknown,
                                        NameSamCompatible,
                                        xszXlatName,
                                        &dwSize )) {

            BOOL bOk = FALSE;

            if (dwSize >  (MAX_PATH+1)) {

                xszXlatName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*dwSize);

                if (!xszXlatName) {
                    xe = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - Couldn't allocate memory for Name...")));
                    goto Exit;
                }

                bOk = pSecur32->pfnTranslateName(  pwszAccount,
                                                NameUnknown,
                                                NameSamCompatible,
                                                xszXlatName,
                                                &dwSize );

            }          

            if (!bOk) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - TranslateName failed with error %d"), GetLastError()));
                goto Exit;
            }
        }
        
        DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: RsopCreateToken  for Account Name <%s>"), (LPWSTR)xszXlatName));
    }

    hr = RsopCreateToken( xszXlatName, psaSecGroups, &pGpoInfo->pRsopToken );
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to create Rsop token. Error - %d"), HRESULT_CODE(hr)));
        goto Exit;
    }


    dwError = GetDomain(pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName, &xwszTargetDomain);

    if (dwError != ERROR_SUCCESS) {
        xe = dwError;
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
        goto Exit;
    }


    //
    // Query for the GPO list based upon the mode
    //
    // 0 is normal
    // 1 is merge.  Merge user list + machine list
    // 2 is replace.  use machine list instead of user list
    //

    
    if (dwUserPolicyMode == 0) {
        DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Calling GetGPOInfo for normal policy mode")));

        bResult = GetGPOInfo( dwLocFlags | ((pGpoInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0),
                              xwszTargetDomain,
                              pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpSOMList, &pGpoInfo->lpGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
    
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }
    } else if (dwUserPolicyMode == 2) {
        
        XPtrLF<TCHAR> xMachDNName;
        XPtrLF<TCHAR> xwszMachDomain;


        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for replacement user policy mode")));

        if ( pwszMachAccount ) {
            if ( !GetCategory( pwszDomain, pwszMachAccount, &xMachDNName ) ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
                goto Exit;
            }
        }

        dwError = GetDomain(pwszNewMachSOM ? pwszNewMachSOM : xMachDNName, &xwszMachDomain);

        if (dwError != ERROR_SUCCESS) {
            xe = dwError;
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
            goto Exit;
        }

        bResult = GetGPOInfo( dwLocFlags | 0,
                              xwszMachDomain,
                              pwszNewMachSOM ? pwszNewMachSOM : xMachDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpLoopbackSOMList, 
                              &pGpoInfo->lpLoopbackGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }
    }
    else {
        XPtrLF<TCHAR> xMachDNName;
        XPtrLF<TCHAR> xwszMachDomain;
        PGROUP_POLICY_OBJECT lpGPO = NULL;
        PGROUP_POLICY_OBJECT lpGPOTemp;


        DebugMsg((DM_VERBOSE, TEXT("ProcessGPOs: Calling GetGPOInfo for merging user policy mode")));
        
        bResult = GetGPOInfo( dwLocFlags | ((pGpoInfo->dwFlags & GP_MACHINE) ? GPO_LIST_FLAG_MACHINE : 0),
                              xwszTargetDomain,
                              pwszNewSOM ? pwszNewSOM : pGpoInfo->lpDNName,
                              NULL,
                              &pGpoInfo->lpGPOList,
                              &pGpoInfo->lpSOMList, &pGpoInfo->lpGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
    
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }


        if ( pwszMachAccount ) {
            if ( !GetCategory( pwszDomain, pwszMachAccount, &xMachDNName ) ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo - getCategory failed with error - %d"), GetLastError()));
                goto Exit;
            }
        }

        dwError = GetDomain(pwszNewMachSOM ? pwszNewMachSOM : xMachDNName, &xwszMachDomain);

        if (dwError != ERROR_SUCCESS) {
            xe = dwError;
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Failed to Get domain. Error - %d"), dwError));
            goto Exit;
        }

        bResult = GetGPOInfo( 0 | dwLocFlags,
                              xwszMachDomain,
                              pwszNewMachSOM ? pwszNewMachSOM : xMachDNName,
                              NULL,
                              &lpGPO,
                              &pGpoInfo->lpLoopbackSOMList, 
                              &pGpoInfo->lpLoopbackGpContainerList,
                              pNetAPI32, FALSE, pGpoInfo->pRsopToken, pwszSite, pGpoFilter, pLocator );
        
        if ( !bResult ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: GetGPOInfo failed.")));
            CEvents ev( TRUE, EVENT_GPO_QUERY_FAILED ); ev.Report();
            goto Exit;
        }

        if (pGpoInfo->lpGPOList && lpGPO) {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Both user and machine lists are defined.  Merging them together.")));

            //
            // Need to merge the lists together
            //

            lpGPOTemp = pGpoInfo->lpGPOList;

            while (lpGPOTemp->pNext) {
                lpGPOTemp = lpGPOTemp->pNext;
            }

            lpGPOTemp->pNext = lpGPO;

        } else if (!pGpoInfo->lpGPOList && lpGPO) {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Only machine list is defined.")));
            pGpoInfo->lpGPOList = lpGPO;

        } else {

            DebugMsg((DM_VERBOSE, TEXT("GenerateGpoInfo: Only user list is defined.")));
        }
    }



    if ( !ReadGPExtensions( pGpoInfo ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: ReadGPExtensions failed.")));
        CEvents ev( TRUE, EVENT_READ_EXT_FAILED ); ev.Report();
        goto Exit;
    }

    if ( !CheckForSkippedExtensions( pGpoInfo, TRUE ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: Checking extensions for skipping failed")));
        goto Exit;
    }

    bResult = SetupGPOFilter( pGpoInfo );

    if ( !bResult ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GenerateGpoInfo: SetupGPOFilter failed.")));
        CEvents ev(TRUE, EVENT_SETUP_GPOFILTER_FAILED); ev.Report();
        goto Exit;
    }

Exit:

    return bResult;
}



//*************************************************************
//
//  GetCategory()
//
//  Purpose:    Gets the fully qualified domain name
//
//  Parameters: pwszDomain  -  Domain name
//              pwszAccount -  User or machine account name
//              pwszDNName  -  Fully qualified domain name returned here
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

BOOL GetCategory( WCHAR *pwszDomain, WCHAR *pwszAccount, WCHAR **ppwszDNName  )
{
    PSECUR32_API pSecur32Api;
    BOOL bResult = FALSE;
    ULONG ulSize = 512;
    XLastError xe; 

    *ppwszDNName = NULL;

    *ppwszDNName = (WCHAR *) LocalAlloc (LPTR, ulSize * sizeof(WCHAR) );
    if ( *ppwszDNName == NULL ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetCategory: Memory allocation failed.")));
        goto Exit;
    }

    pSecur32Api = LoadSecur32();

    if (!pSecur32Api) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetCategory:  Failed to load secur32 api.")));
        goto Exit;
    }

    bResult = pSecur32Api->pfnTranslateName( pwszAccount, NameUnknown, NameFullyQualifiedDN,
                                             *ppwszDNName, &ulSize );

    if ( !bResult && ulSize > 0 ) {

        LocalFree( *ppwszDNName );
        *ppwszDNName = (WCHAR *) LocalAlloc (LPTR, ulSize * sizeof(WCHAR) );
        if ( *ppwszDNName == NULL ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: Memory allocation failed.")));
            goto Exit;
        }

        bResult = pSecur32Api->pfnTranslateName( pwszAccount, NameUnknown, NameFullyQualifiedDN,
                                                 *ppwszDNName, &ulSize );

        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: TranslateName failed with error %d."), GetLastError()));
        }
    }
    else {
        if (!bResult) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("GetCategory: TranslateName failed with error %d."), GetLastError()));
        }
    }

Exit:

    if ( !bResult ) {
        LocalFree( *ppwszDNName );
        *ppwszDNName = NULL;
    }

    return bResult;
}


//*************************************************************
//
//  ProcessMachAndUserGpoList()
//
//  Purpose:    Calls the various extensions to do the planning
//              mode logging
//
//  Parameters: lpExtMach          -  Machine extension struct
//              lpExtUser          -  User extension struct
//              dwFlags            -  Processing flags
//              pwszSite           -  Site name
//              pwszNewComputerSOM -  New computer scope of management
//              psaCompSecGroups   -  New computer security groups
//              pGpoInfoMach       -  Machine Gpo info
//              ...                -  Similarly for user account
//
//  Return:     True if successful, False otherwise
//
//*************************************************************

DWORD ProcessMachAndUserGpoList( LPGPEXT lpExtMach, LPGPEXT lpExtUser, DWORD dwFlags, WCHAR *pwszSite,
                                 WCHAR *pwszMach, WCHAR *pwszNewComputerSOM, SAFEARRAY *psaComputerSecurityGroups, LPGPOINFO pGpoInfoMach,
                                 WCHAR *pwszUser, WCHAR *pwszNewUserSOM, SAFEARRAY *psaUserSecurityGroups, LPGPOINFO pGpoInfoUser )
{
    BOOL bAbort = FALSE;
    DWORD dwResult;

    RSOP_TARGET computerTarget, userTarget;
    PRSOP_TARGET pComputerTarget = NULL;
    PRSOP_TARGET pUserTarget = NULL;
    BOOL         bPlanningSupported = TRUE;
    LPGPEXT      lpExt;



    lpExt = (lpExtMach != NULL) ? lpExtMach : lpExtUser;

    if (!lpExt) {
        DebugMsg((DM_WARNING, TEXT("ProcessMachAndUserGpoList: Both user and computer exts are null, returning.")));
        return TRUE;
    }

    bPlanningSupported = lpExt->bRegistryExt || (lpExt->lpRsopFunctionName ? TRUE : FALSE);


    if ( lpExtMach && !lpExtMach->bSkipped && pGpoInfoMach->lpGPOList ) {

        //
        // Computer target is non-null
        //

        pComputerTarget = &computerTarget;
        pComputerTarget->pwszAccountName = pwszMach;
        pComputerTarget->pwszNewSOM = pwszNewComputerSOM;
        pComputerTarget->psaSecurityGroups = psaComputerSecurityGroups;
        pComputerTarget->pRsopToken = pGpoInfoMach->pRsopToken;
        pComputerTarget->pGPOList = pGpoInfoMach->lpGPOList;
        pComputerTarget->pWbemServices = pGpoInfoMach->pWbemServices;


        if (pGpoInfoMach->bRsopLogging) {
            pGpoInfoMach->bRsopLogging = LogExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach, 
                                                             bPlanningSupported);        
            if (!pGpoInfoMach->bRsopLogging) {
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            }
        }
    }



    if ( lpExtUser && !lpExtUser->bSkipped && pGpoInfoUser->lpGPOList ) {

        //
        // User target is non-null
        //

        pUserTarget = &userTarget;
        pUserTarget->pwszAccountName = pwszUser;
        pUserTarget->pwszNewSOM = pwszNewUserSOM;
        pUserTarget->psaSecurityGroups = psaUserSecurityGroups;
        pUserTarget->pRsopToken = pGpoInfoUser->pRsopToken;
        pUserTarget->pGPOList = pGpoInfoUser->lpGPOList;
        pUserTarget->pWbemServices = pGpoInfoUser->pWbemServices;


        if (pGpoInfoUser->bRsopLogging) {
            pGpoInfoUser->bRsopLogging = LogExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser, 
                                                             bPlanningSupported);        
            if (!pGpoInfoUser->bRsopLogging) {
                DebugMsg((DM_WARNING, TEXT("GenerateRsopPolicy: Error when logging user Session data.")));
            }
        }
    }
    


    if ( pComputerTarget == NULL && pUserTarget == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ProcessMachAndUserGpoList: Both user and computer targets are null, returning.")));
        return TRUE;
    }



    if ( lpExt->bRegistryExt ) {

        //
        // Registry pseudo extension
        //

        dwResult = GenerateRegistryPolicy( dwFlags,
                                           &bAbort,
                                           pwszSite,
                                           pComputerTarget,
                                           pUserTarget );

    } else {

        if ( LoadGPExtension( lpExt, TRUE ) ) {
            dwResult = lpExt->pRsopEntryPoint( dwFlags,
                                               &bAbort,
                                               pwszSite,
                                               pComputerTarget,
                                               pUserTarget );

        }
        else {
            dwResult = GetLastError();
        }
        
    }


    if ( lpExtUser && !lpExtUser->bSkipped && pGpoInfoUser->bRsopLogging) {
        if ( !bPlanningSupported ) 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, TRUE, ERROR_SUCCESS);        
        else if (dwResult != ERROR_SUCCESS) 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, TRUE, dwResult);        
        else 
            UpdateExtSessionStatus(pGpoInfoUser->pWbemServices, lpExtUser->lpKeyName, FALSE, dwResult);        
    }


    if ( lpExtMach && !lpExtMach->bSkipped && pGpoInfoMach->bRsopLogging) {
        if ( !bPlanningSupported ) 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, TRUE, ERROR_SUCCESS);        
        else if (dwResult != ERROR_SUCCESS) 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, TRUE, dwResult);        
        else 
            UpdateExtSessionStatus(pGpoInfoMach->pWbemServices, lpExtMach->lpKeyName, FALSE, dwResult);        
    }


    return dwResult;
}


//*********************************************************************
// * Planning mode registry stuff
//*********************************************************************


//*************************************************************
//
//  ProcessRegistryFiles()
//
//  Purpose: Called from GenerateRegsitryPolicy to process registry data from
//                  the registry files associated with a policy target.
//
//  Parameters:
//                  pTarget -     Policy for which registry policy is to be processed.
//                  pHashTable  - Hash table to keep registry policy information.
//
//  Return:     On success, TRUE. Otherwise, FALSE.
//
//*************************************************************

BOOL ProcessRegistryFiles(PRSOP_TARGET pTarget, REGHASHTABLE *pHashTable)
{
    PGROUP_POLICY_OBJECT lpGPO;
    TCHAR szRegistry[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr;
    XLastError xe;
    //
    // Check parameters
    //

    DmAssert(pHashTable);

    if(!pHashTable) {
        DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: Invalid parameter.")));
        return FALSE;
    }

    //
    // Spin through GPOs in the list.
    //

    lpGPO = pTarget->pGPOList;

    while ( lpGPO ) {

        //
        // Build the path to Registry.pol
        //

        DmAssert( lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 < MAX_PATH );
        if(lstrlen(lpGPO->lpFileSysPath) + lstrlen(c_szRegistryPol) + 1 >= MAX_PATH) {
            DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: Length of path to registry.pol exceeded MAX_PATH.")));
            return FALSE;
        }

        hr = StringCchCopy (szRegistry, ARRAYSIZE(szRegistry), lpGPO->lpFileSysPath);
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            return FALSE;
        }

        lpEnd = CheckSlash (szRegistry);
        
        hr = StringCchCopy (lpEnd, ARRAYSIZE(szRegistry) - (lpEnd - szRegistry), c_szRegistryPol);
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            return FALSE;
        }

        //
        // Process registry data for this particular file.
        //

        if (!ParseRegistryFile (NULL, szRegistry, (PFNREGFILECALLBACK)ProcessRegistryValue, NULL,
                                        lpGPO->lpDSPath, lpGPO->lpLink,pHashTable, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("ProcessRegistryFiles: ProcessRegistryFile failed.")));
            return FALSE;
        }

        lpGPO = lpGPO->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  ProcessAdmData()
//
//  Purpose: Called from GenerateRegistryPolicy in order to process Admin templates
//                  data associated with a registry policy target.
//
//  Parameters: pTarget - Target for which data is to be processed
//              bUser   - Is this for user or machine policy ?
//
//  Return:     On success, TRUE. Otherwise, FALSE.
//
//*************************************************************

BOOL ProcessAdmData( PRSOP_TARGET pTarget, BOOL bUser )
{
    PGROUP_POLICY_OBJECT lpGPO;

    WIN32_FIND_DATA findData;
    ADMFILEINFO *pAdmFileCache = 0;
    TCHAR szRegistry[MAX_PATH];
    LPTSTR lpEnd;

    HANDLE hFindFile;
    WIN32_FILE_ATTRIBUTE_DATA attrData;
    DWORD dwFilePathSize;
    DWORD dwSize;

    WCHAR *pwszEnd;
    WCHAR *pwszFile;

    HRESULT hr;

    //
    // Check parameters
    //
    if(pTarget == NULL ) {
        DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Invalid paramter.")));
        return FALSE;
    }

    lpGPO = pTarget->pGPOList;

    while(lpGPO) {

        //
        // Log Adm data
        //

        dwFilePathSize = lstrlen( lpGPO->lpFileSysPath );
        dwSize = dwFilePathSize + MAX_PATH;

        pwszFile = (WCHAR *) LocalAlloc( LPTR, dwSize * sizeof(WCHAR) );

        if ( pwszFile == 0 ) {
            DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Failed to allocate memory.")));
            FreeAdmFileCache( pAdmFileCache );
            return FALSE;
        }

        hr = StringCchCopy( pwszFile, dwSize, lpGPO->lpFileSysPath );
        ASSERT(SUCCEEDED(hr));

        //
        // Strip off trailing 'machine' or 'user'
        //

        pwszEnd = pwszFile + lstrlen( pwszFile );

        if ( !bUser )
            pwszEnd -= 7;   // length of "machine"
        else
            pwszEnd -= 4;   // length of "user"

        hr = StringCchCopy( pwszEnd, dwSize - (pwszEnd - pwszFile), L"Adm\\*.adm");
        ASSERT(SUCCEEDED(hr));

        //
        // Remember end point so that the actual Adm filename can be
        // easily concatenated.
        //

        pwszEnd = pwszEnd + lstrlen( L"Adm\\" );

        //
        // Enumerate all Adm files
        //

        hFindFile = FindFirstFile( pwszFile, &findData);

        if ( hFindFile != INVALID_HANDLE_VALUE )
        {
            do
            {
                if ( !(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                {
                    DmAssert( dwFilePathSize + lstrlen(findData.cFileName) + lstrlen( L"\\Adm\\" ) < dwSize );

                    hr = StringCchCopy( pwszEnd, dwSize - (pwszEnd - pwszFile), findData.cFileName);
                    ASSERT(SUCCEEDED(hr));

                    ZeroMemory (&attrData, sizeof(attrData));

                    if ( GetFileAttributesEx (pwszFile, GetFileExInfoStandard, &attrData ) != 0 ) {

                        if ( !AddAdmFile( pwszFile, lpGPO->lpDSPath,
                                          &attrData.ftLastWriteTime, NULL, &pAdmFileCache ) ) {
                            DebugMsg((DM_WARNING, TEXT("ProcessAdmData: NewAdmData failed.")));
                        }

                    }
                }   // if findData & file_attr_dir
            }  while ( FindNextFile(hFindFile, &findData) );//  do

            FindClose(hFindFile);

        }   // if hfindfile

        LocalFree( pwszFile );

        lpGPO = lpGPO->pNext;
    }

    if ( ! LogAdmRsopData( pAdmFileCache, pTarget->pWbemServices ) ) {
        DebugMsg((DM_WARNING, TEXT("ProcessAdmData: Error when logging Adm Rsop data. Continuing.")));
    }

    FreeAdmFileCache( pAdmFileCache );

    return TRUE;
}


//*************************************************************
//
//  GenerateRegistryPolicy()
//
//  Purpose: Implementation of Planning mode regsitry pseudo-extension
//
//  Parameters: dwFlags  - Flags
//              pbAbort  - Abort processing
//              pwszSite - Site of target
//              pComputerTarget - Computer target specification
//              pUserTarget     - User target specification
//
//  Return:     On success, S_OK. Otherwise, E_FAIL.
//
//*************************************************************

DWORD GenerateRegistryPolicy( DWORD dwFlags,
                              BOOL *pbAbort,
                              WCHAR *pwszSite,
                              PRSOP_TARGET pComputerTarget,
                              PRSOP_TARGET pUserTarget )
{
    REGHASHTABLE *pHashTable = NULL;
    BOOL bUser;

    if(pComputerTarget && pComputerTarget->pGPOList) {

        //
        // Setup computer hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: AllocHashTable failed.")));
            return E_FAIL;
        }

        //
        // Process computer GPO list
        //


        if(!ProcessRegistryFiles(pComputerTarget, pHashTable)) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessRegistryFiles failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }


        //
        // Log computer registry data to Cimom database
        //
        if ( ! LogRegistryRsopData( GP_MACHINE, pHashTable, pComputerTarget->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: LogRegistryRsopData failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }
        FreeHashTable( pHashTable );
        pHashTable = NULL;

        //
        // Process ADM data
        //

        bUser = FALSE;
        if (pComputerTarget && !ProcessAdmData( pComputerTarget, bUser ) ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessAdmData failed.")));
            return E_FAIL;
        }

    }

    //
    // Process user GPO list
    //

    if(pUserTarget && pUserTarget->pGPOList) {

        //
        // Setup user hash table
        //

        pHashTable = AllocHashTable();
        if ( pHashTable == NULL ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: AllocHashTable failed.")));
            return E_FAIL;
        }


        if(!ProcessRegistryFiles(pUserTarget, pHashTable)) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessRegistryFiles failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }

        //
        // Log user registry data to Cimom database
        //

        if ( ! LogRegistryRsopData( 0, pHashTable, pUserTarget->pWbemServices ) )  {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: LogRegistryRsopData failed.")));
            FreeHashTable( pHashTable );
            return E_FAIL;
        }
        FreeHashTable( pHashTable );
        pHashTable = NULL;

        //
        // Process ADM data
        //

        bUser = TRUE;
        if (pUserTarget && !ProcessAdmData( pUserTarget, bUser ) ) {
            DebugMsg((DM_WARNING, TEXT("GenerateRegistryPolicy: ProcessAdmData failed.")));
            return E_FAIL;
        }

    }


    return S_OK;
}


//*************************************************************
//
//  CheckOUAccess()
//
//  Purpose:    Determines if the user / machine has read access to
//              the OU.
//
//  Parameters: pld             -  LDAP connection
//              pLDAP           -  LDAP function table pointer
//              pMessage        -  LDAP message
//              pRsopToken      -  RSOP token of the user or machine
//              pSD             -  Security descriptor returned here
//              pcbSDLen        -  Length of security descriptor returned here
//              pbAccessGranted -  Receives the final yes / no status
//
//  Return:     TRUE if successful
//              FALSE if an error occurs.
//
//*************************************************************

BOOL CheckOUAccess( PLDAP_API pLDAP,
                    PLDAP pld,
                    PLDAPMessage    pMessage,
                    PRSOPTOKEN pRsopToken,
                    BOOL *pbAccessGranted )
{
    BOOL bResult = FALSE;
    TCHAR szSDProperty[] = TEXT("nTSecurityDescriptor");
    PWSTR *ppwszValues;

    *pbAccessGranted = FALSE;

    //
    // Get the security descriptor value
    //
    ppwszValues = pLDAP->pfnldap_get_values( pld, pMessage, szSDProperty );

    if (!ppwszValues)
    {
        if (pld->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
        {
            DebugMsg((DM_VERBOSE, TEXT("CheckOUAccess:  Object can not be accessed.")));
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  ldap_get_values failed with 0x%x"),
                 pld->ld_errno));
        }
    }
    else
    {
        PLDAP_BERVAL *pSize;
        //
        // Get the length of the security descriptor
        //
        pSize = pLDAP->pfnldap_get_values_len(pld, pMessage, szSDProperty);

        if (!pSize)
        {
            DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  ldap_get_values_len failed with 0x%x"),
                     pld->ld_errno));
        }
        else
        {
            //
            // Allocate the memory for the security descriptor
            //
            PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);

            if ( pSD == NULL )
            {
                DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  Failed to allocate memory for SD with  %d"),
                         GetLastError()));
            }
            else
            {
                //
                // OU {bf967aa8-0de6-11d0-a285-00aa003049e2}
                //
                GUID OrganizationalUnit = { 0xbf967aa5, 0x0de6, 0x11d0, 0xa2, 0x85, 0x00, 0xaa, 0x00, 0x30, 0x49, 0xe2 };

                //
                // gPOptions {f30e3bbf-9ff0-11d1-b603-0000f80367c1}
                //
                GUID gPOptionsGuid = {  0xf30e3bbf, 0x9ff0, 0x11d1, 0xb6, 0x03, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 };

                //
                // gPLink {f30e3bbe-9ff0-11d1-b603-0000f80367c1}
                //
                GUID gPLinkGuid = { 0xf30e3bbe, 0x9ff0, 0x11d1, 0xb6, 0x03, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 };

                OBJECT_TYPE_LIST ObjType[] = {  { ACCESS_OBJECT_GUID, 0, &OrganizationalUnit },
                                                { ACCESS_PROPERTY_SET_GUID, 0, &gPLinkGuid },
                                                { ACCESS_PROPERTY_SET_GUID, 0, &gPOptionsGuid } };
                HRESULT hr;
                PRIVILEGE_SET PrivSet;
                DWORD PrivSetLength = sizeof(PRIVILEGE_SET);
                DWORD dwGrantedAccess;
                BOOL bAccessStatus = TRUE;
                GENERIC_MAPPING DS_GENERIC_MAPPING = {  DS_GENERIC_READ,
                                                        DS_GENERIC_WRITE,
                                                        DS_GENERIC_EXECUTE,
                                                        DS_GENERIC_ALL };

                //
                // Copy the security descriptor
                //
                CopyMemory( pSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);

                //
                // Now we use RsopAccessCheckByType to determine if the user / machine
                // should have this GPO applied to them
                //

                hr = RsopAccessCheckByType(pSD,
                                           0,
                                           pRsopToken,
                                           ACTRL_DS_READ_PROP,
                                           ObjType,
                                           ARRAYSIZE(ObjType),
                                           &DS_GENERIC_MAPPING,
                                           &PrivSet,
                                           &PrivSetLength,
                                           &dwGrantedAccess,
                                           &bAccessStatus );
                if ( FAILED( hr ) )
                {
                    DebugMsg((DM_WARNING, TEXT("CheckOUAccess:  RsopAccessCheckByType failed with  %d"), GetLastError()));
                }
                else
                {
                    *pbAccessGranted = bAccessStatus;
                    bResult = TRUE;
                }

                LocalFree( pSD );
            }

            pLDAP->pfnldap_value_free_len(pSize);
        }

        pLDAP->pfnldap_value_free(ppwszValues);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpstate.cpp ===
//*************************************************************
//
//  Group Policy Support - State functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//*************************************************************

#include "gphdr.h"
#include <strsafe.h>

//*************************************************************
//
//  GetDeletedGPOList()
//
//  Purpose:    Get the list of deleted GPOs
//
//  Parameters: lpGPOList        -  List of old GPOs
//              ppDeletedGPOList -  Deleted list returned here
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetDeletedGPOList (PGROUP_POLICY_OBJECT lpGPOList,
                        PGROUP_POLICY_OBJECT *ppDeletedGPOList)
{
     //
     // It's possible that lpGPOList could be NULL.  This is ok.
     //

    if (!lpGPOList) {
        DebugMsg((DM_VERBOSE, TEXT("GetDeletedList: No old GPOs.  Leaving.")));
        return TRUE;
    }

    //
    // We need to do any delete operations in reverse order
    // of the way there were applied. Also, check that duplicates
    // of same GPO are not being added.
    //

    while ( lpGPOList ) {

        PGROUP_POLICY_OBJECT pCurGPO = lpGPOList;
        lpGPOList = lpGPOList->pNext;

        if ( pCurGPO->lParam & GPO_LPARAM_FLAG_DELETE ) {

            PGROUP_POLICY_OBJECT lpGPODest = *ppDeletedGPOList;
            BOOL bDup = FALSE;

            while (lpGPODest) {

                if (!lstrcmpi (pCurGPO->szGPOName, lpGPODest->szGPOName)) {
                    bDup = TRUE;
                    break;
                }

                lpGPODest = lpGPODest->pNext;
            }

            if (!bDup) {

                //
                // Not a duplicate, so prepend to deleted list
                //

                pCurGPO->pNext = *ppDeletedGPOList;
                pCurGPO->pPrev = NULL;

                if ( *ppDeletedGPOList )
                    (*ppDeletedGPOList)->pPrev = pCurGPO;

                *ppDeletedGPOList = pCurGPO;
            } else
                LocalFree( pCurGPO );

        } else
            LocalFree( pCurGPO );

    }

    DebugMsg((DM_VERBOSE, TEXT("GetDeletedGPOList: Finished.")));

    return TRUE;
}


//*************************************************************
//
//  ReadGPOList()
//
//  Purpose:    Reads the list of Group Policy Objects from
//              the registry
//
//  Parameters: pszExtName -  GP extension
//              hKeyRoot   -  Registry handle
//              hKeyRootMach - Registry handle to hklm
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              bShadow    -  Read from shadow or from history list
//              lpGPOList  -  pointer to the array of GPOs
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ReadGPOList ( TCHAR * pszExtName, HKEY hKeyRoot,
                   HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                   PGROUP_POLICY_OBJECT * lpGPOList)
{
    INT iIndex = 0;
    LONG lResult;
    HKEY hKey, hSubKey = NULL;
    BOOL bResult = FALSE;
    TCHAR szSubKey[CCH_MAX_DEC];
    DWORD dwOptions, dwVersion;
    GPO_LINK GPOLink;
    LPARAM lParam;
    TCHAR szGPOName[50];
    LPTSTR lpDSPath = NULL, lpFileSysPath = NULL, lpDisplayName = NULL, lpExtensions = NULL, lpLink = NULL;
    DWORD dwDisp, dwSize, dwType, dwTemp, dwMaxSize;
    PGROUP_POLICY_OBJECT lpGPO, lpGPOTemp;
    TCHAR szKey[400];
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Set default
    //

    *lpGPOList = NULL;


    //
    // Open the key that holds the GPO list
    //

    if ( lpwszSidUser == 0 ) {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey),
                  bShadow ? GP_SHADOW_KEY
                            : GP_HISTORY_KEY,
                  pszExtName );

    } else {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey), 
                  bShadow ? GP_SHADOW_SID_KEY
                          : GP_HISTORY_SID_KEY,
                          lpwszSidUser, pszExtName );
    }
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx ( lpwszSidUser ? hKeyRootMach : hKeyRoot,
                            szKey,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {

        if (lResult == ERROR_FILE_NOT_FOUND) {
            return TRUE;

        } else {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to open reg key with %d."), lResult));
            return FALSE;
        }
    }


    while (TRUE) {

        //
        // Enumerate through the subkeys.  The keys are named by index number
        // eg:  0, 1, 2, 3, etc...
        //

        IntToString (iIndex, szSubKey);

        lResult = RegOpenKeyEx (hKey, szSubKey, 0, KEY_READ, &hSubKey);

        if (lResult != ERROR_SUCCESS) {

            if (lResult == ERROR_FILE_NOT_FOUND) {
                bResult = TRUE;
                goto Exit;

            } else {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to open reg key <%s> with %d."), szSubKey, lResult));
                goto Exit;
            }
        }


        //
        // Read the size of the largest value in this key
        //

        lResult = RegQueryInfoKey (hSubKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                                   &dwMaxSize, NULL, NULL);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query max size with %d."), lResult));
            goto Exit;
        }


        //
        // RegQueryInfoKey does not account for trailing 0 in strings
        //

        dwMaxSize += sizeof( WCHAR );

        
        //
        // Allocate buffers based upon the value above
        //

        lpDSPath = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpDSPath) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpFileSysPath = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpFileSysPath) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpDisplayName = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpDisplayName) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpExtensions = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpExtensions) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        lpLink = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

        if (!lpLink) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to allocate memory with %d."), GetLastError()));
            goto Exit;
        }


        //
        // Read in the GPO
        //

        dwOptions = 0;
        dwSize = sizeof(dwOptions);
        lResult = RegQueryValueEx (hSubKey, TEXT("Options"), NULL, &dwType,
                                  (LPBYTE) &dwOptions, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query options reg value with %d."), lResult));
        }


        dwVersion = 0;
        dwSize = sizeof(dwVersion);
        lResult = RegQueryValueEx (hSubKey, TEXT("Version"), NULL, &dwType,
                                  (LPBYTE) &dwVersion, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query Version reg value with %d."), lResult));
        }


        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("DSPath"), NULL, &dwType,
                                  (LPBYTE) lpDSPath, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            if (lResult != ERROR_FILE_NOT_FOUND) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query DS reg value with %d."), lResult));
                goto Exit;
            }
            LocalFree (lpDSPath);
            lpDSPath = NULL;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("FileSysPath"), NULL, &dwType,
                                  (LPBYTE) lpFileSysPath, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query file sys path reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("DisplayName"), NULL, &dwType,
                                  (LPBYTE) lpDisplayName, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query display name reg value with %d."), lResult));
            goto Exit;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("Extensions"), NULL, &dwType,
                                  (LPBYTE) lpExtensions, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query extension names reg value with %d."), lResult));

            LocalFree(lpExtensions);
            lpExtensions = NULL;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hSubKey, TEXT("Link"), NULL, &dwType,
                                  (LPBYTE) lpLink, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            if (lResult != ERROR_FILE_NOT_FOUND) {
                DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query DS Object reg value with %d."), lResult));
            }
            LocalFree(lpLink);
            lpLink = NULL;
        }

        dwSize = sizeof(szGPOName);
        lResult = RegQueryValueEx (hSubKey, TEXT("GPOName"), NULL, &dwType,
                                  (LPBYTE) szGPOName, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query GPO name reg value with %d."), lResult));
            goto Exit;
        }

        GPOLink = GPLinkUnknown;
        dwSize = sizeof(GPOLink);
        lResult = RegQueryValueEx (hSubKey, TEXT("GPOLink"), NULL, &dwType,
                                  (LPBYTE) &GPOLink, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query reserved reg value with %d."), lResult));
        }


        lParam = 0;
        dwSize = sizeof(lParam);
        lResult = RegQueryValueEx (hSubKey, TEXT("lParam"), NULL, &dwType,
                                  (LPBYTE) &lParam, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to query lParam reg value with %d."), lResult));
        }


        //
        // Add the GPO to the list
        //

        if (!AddGPO (lpGPOList, 0, TRUE, TRUE, FALSE, dwOptions, dwVersion, lpDSPath, lpFileSysPath,
                     lpDisplayName, szGPOName, lpExtensions, 0, 0, GPOLink, lpLink, lParam, FALSE,
                     FALSE, FALSE, TRUE)) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ReadGPOList: Failed to add GPO to list.")));
            goto Exit;
        }


        //
        // Free the buffers allocated above
        //

        if (lpDSPath) {
            LocalFree (lpDSPath);
            lpDSPath = NULL;
        }

        LocalFree (lpFileSysPath);
        lpFileSysPath = NULL;

        LocalFree (lpDisplayName);
        lpDisplayName = NULL;

        if (lpExtensions) {
            LocalFree(lpExtensions);
            lpExtensions = NULL;
        }

        if (lpLink) {
            LocalFree(lpLink);
            lpLink = NULL;
        }

        //
        // Close the subkey handle
        //

        RegCloseKey (hSubKey);
        hSubKey = NULL;

        iIndex++;
    }

Exit:

    if (lpDSPath) {
        LocalFree (lpDSPath);
    }

    if (lpFileSysPath) {
        LocalFree (lpFileSysPath);
    }

    if (lpDisplayName) {
        LocalFree (lpDisplayName);
    }

    if (lpExtensions) {
        LocalFree(lpExtensions);
    }

    if (lpLink) {
        LocalFree(lpLink);
    }


    if (hSubKey) {
        RegCloseKey (hSubKey);
    }

    RegCloseKey (hKey);

    if (!bResult) {

        //
        // Free any entries in the list
        //

        lpGPO = *lpGPOList;

        while (lpGPO) {
            lpGPOTemp = lpGPO->pNext;
            LocalFree (lpGPO);
            lpGPO = lpGPOTemp;
        }

        *lpGPOList = NULL;
    }


    return bResult;
}

//*************************************************************
//
//  SaveGPOList()
//
//  Purpose:    Saves the list of Group Policy Objects in
//              the registry
//
//  Parameters: pszExtName -  GP extension
//              lpGPOInfo  -  Group policy info
//              hKeyRootMach - Registry handle to hklm
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              bShadow    -  Save to shadow or to history list
//              lpGPOList  -  Array of GPOs
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SaveGPOList (TCHAR *pszExtName, LPGPOINFO lpGPOInfo,
                  HKEY hKeyRootMach, LPTSTR lpwszSidUser, BOOL bShadow,
                  PGROUP_POLICY_OBJECT lpGPOList)
{
    INT iIndex = 0;
    LONG lResult;
    HKEY hKey = NULL;
    BOOL bResult = FALSE;
    TCHAR szSubKey[400];
    DWORD dwDisp, dwSize;
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // Start off with an empty key
    //
    if ( lpwszSidUser == 0 ) {
        hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey),
                  bShadow ? GP_SHADOW_KEY
                          : GP_HISTORY_KEY,
                  pszExtName);
    } else {
        hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey),
                  bShadow ? GP_SHADOW_SID_KEY
                          : GP_HISTORY_SID_KEY,
                  lpwszSidUser, pszExtName);
    }
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        return FALSE; // no need to go to exit as hkey is not got yet.
    }

    if (RegDelnode (lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot, szSubKey) != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("SaveGPOList: RegDelnode failed.")));
    }


    //
    // Check if we have any GPOs to store.  It's ok for this to be NULL.
    //

    if (!lpGPOList) {
        return TRUE;
    }

    //
    // Set the proper security on the registry key
    //

    if ( !MakeRegKeySecure( (lpGPOInfo->dwFlags & GP_MACHINE) ? NULL : lpGPOInfo->hToken,
                            lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot,
                            szSubKey ) ) {
        DebugMsg((DM_WARNING, TEXT("SaveGpoList: Failed to secure reg key.")));
        CEvents ev(TRUE, EVENT_FAILED_CREATE);
        ev.AddArg(szSubKey);
        ev.AddArgWin32Error(ERROR_ACCESS_DENIED);
        ev.Report();
        return FALSE;
    }

    //
    // Loop through the GPOs saving them in the registry
    //

    while (lpGPOList) {

        if ( lpwszSidUser == 0 ) {
            hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey),
                      bShadow ? TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Shadow\\%ws\\%d")
                              : TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\%ws\\%d"),
                      pszExtName,
                      iIndex);
        } else {
            hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey),
                      bShadow ? TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\Shadow\\%ws\\%d")
                              : TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History\\%ws\\%d"),
                      lpwszSidUser, pszExtName, iIndex);
        }
        if ( FAILED(hr) ) {
            xe = HRESULT_CODE(hr);
            goto Exit;
        }

        lResult = RegCreateKeyEx (lpwszSidUser ? hKeyRootMach : lpGPOInfo->hKeyRoot,
                                  szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to create reg key with %d."), lResult));
            goto Exit;
        }


        //
        // Save the GPO
        //

        dwSize = sizeof(lpGPOList->dwOptions);
        lResult = RegSetValueEx (hKey, TEXT("Options"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->dwOptions, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set options reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->dwVersion);
        lResult = RegSetValueEx (hKey, TEXT("Version"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->dwVersion, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set Version reg value with %d."), lResult));
            goto Exit;
        }


        if (lpGPOList->lpDSPath) {

            dwSize = (lstrlen (lpGPOList->lpDSPath) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("DSPath"), 0, REG_SZ,
                                     (LPBYTE) lpGPOList->lpDSPath, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set DS reg value with %d."), lResult));
                goto Exit;
            }
        }

        dwSize = (lstrlen (lpGPOList->lpFileSysPath) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("FileSysPath"), 0, REG_SZ,
                                  (LPBYTE) lpGPOList->lpFileSysPath, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set file sys path reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = (lstrlen (lpGPOList->lpDisplayName) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("DisplayName"), 0, REG_SZ,
                                (LPBYTE) lpGPOList->lpDisplayName, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set display name reg value with %d."), lResult));
            goto Exit;
        }

        if (lpGPOList->lpExtensions) {

            dwSize = (lstrlen (lpGPOList->lpExtensions) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("Extensions"), 0, REG_SZ,
                                    (LPBYTE) lpGPOList->lpExtensions, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set extension names reg value with %d."), lResult));
                goto Exit;
            }

        }

        if (lpGPOList->lpLink) {

            dwSize = (lstrlen (lpGPOList->lpLink) + 1) * sizeof(TCHAR);
            lResult = RegSetValueEx (hKey, TEXT("Link"), 0, REG_SZ,
                                    (LPBYTE) lpGPOList->lpLink, dwSize);

            if (lResult != ERROR_SUCCESS) {
                xe = lResult;
                DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set DSObject reg value with %d."), lResult));
                goto Exit;
            }

        }

        dwSize = (lstrlen (lpGPOList->szGPOName) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, TEXT("GPOName"), 0, REG_SZ,
                                  (LPBYTE) lpGPOList->szGPOName, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set GPO name reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->GPOLink);
        lResult = RegSetValueEx (hKey, TEXT("GPOLink"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->GPOLink, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set GPOLink reg value with %d."), lResult));
            goto Exit;
        }


        dwSize = sizeof(lpGPOList->lParam);
        lResult = RegSetValueEx (hKey, TEXT("lParam"), 0, REG_DWORD,
                                 (LPBYTE) &lpGPOList->lParam, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("SaveGPOList: Failed to set lParam reg value with %d."), lResult));
            goto Exit;
        }

        //
        // Close the handle
        //

        RegCloseKey (hKey);
        hKey = NULL;


        //
        // Prep for the next loop
        //

        iIndex++;
        lpGPOList = lpGPOList->pNext;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (hKey) {
        RegCloseKey (hKey);
    }

    return bResult;
}


//*************************************************************
//
//  WriteStatus()
//
//  Purpose:    Saves status in the registry
//
//  Parameters: lpGPOInfo  -  GPO info
//              lpExtName  -  GP extension name
//              dwStatus   -  Status to write
//              dwTime     -  Policy time to write
//              dwSlowLink -  Link speed to write
//              dwRsopLogging - Rsop Logging to Write
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WriteStatus( TCHAR *lpExtName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, LPGPEXTSTATUS lpExtStatus )
{
    HKEY hKey = NULL, hKeyExt = NULL;
    DWORD dwDisp, dwSize;
    LONG lResult;
    BOOL bResult = FALSE;
    TCHAR szKey[400];
    XLastError xe;
    HRESULT hr = S_OK;

    if ( lpwszSidUser == 0 ) {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey), 
                  GP_EXTENSIONS_KEY,
                  lpExtName);
    } else {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey),
                  GP_EXTENSIONS_SID_KEY,
                  lpwszSidUser, lpExtName);
    }
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        return FALSE; // no need to go to exit here
    }

    lResult = RegCreateKeyEx (lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                            szKey, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to create reg key with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwStatus);
    lResult = RegSetValueEx (hKey, TEXT("Status"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwStatus), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set status reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwRsopStatus);
    lResult = RegSetValueEx (hKey, TEXT("RsopStatus"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwRsopStatus), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set rsop status reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwTime);
    lResult = RegSetValueEx (hKey, TEXT("LastPolicyTime"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwTime), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set time reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwSlowLink);
    lResult = RegSetValueEx (hKey, TEXT("PrevSlowLink"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwSlowLink), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set slowlink reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(lpExtStatus->dwRsopLogging);
    lResult = RegSetValueEx (hKey, TEXT("PrevRsopLogging"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->dwRsopLogging), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set RsopLogging reg value with %d."), lResult));
        goto Exit;
    }


    dwSize = sizeof(lpExtStatus->bForceRefresh);
    lResult = RegSetValueEx (hKey, TEXT("ForceRefreshFG"), 0, REG_DWORD,
                             (LPBYTE) &(lpExtStatus->bForceRefresh), dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("WriteStatus: Failed to set ForceRefresh reg value with %d."), lResult));
        goto Exit;
    }
    

    bResult = TRUE;

Exit:
    if ( hKey != NULL )
        RegCloseKey( hKey );

    if ( hKeyExt != NULL )
        RegCloseKey( hKeyExt );
        
    return bResult;
}



//*************************************************************
//
//  ReadStatus()
//
//  Purpose:    Reads status from the registry
//
//  Parameters: lpKeyName   -  Extension name
//              lpGPOInfo   -  GPO info
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//        (out) lpExtStatus -  The extension status returned.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

void ReadStatus ( TCHAR *lpKeyName, LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser,  LPGPEXTSTATUS lpExtStatus )
{
    HKEY hKey = NULL, hKeyExt = NULL;
    DWORD dwType, dwSize;
    LONG lResult;
    BOOL bResult = FALSE;
    TCHAR szKey[400];
    XLastError xe;
    HRESULT hr = S_OK;

    memset(lpExtStatus, 0, sizeof(GPEXTSTATUS));

    if ( lpwszSidUser == 0 ) {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey), 
                  GP_EXTENSIONS_KEY,
                  lpKeyName);
    } else {
        hr = StringCchPrintf (szKey, ARRAYSIZE(szKey),
                  GP_EXTENSIONS_SID_KEY,
                  lpwszSidUser, lpKeyName);
    }
    if ( FAILED(hr) ) {
        xe = ERROR_INSUFFICIENT_BUFFER;
        return; // no need to go to exit here.
    }

    lResult = RegOpenKeyEx (lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                            szKey,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to open reg key with %d."), lResult));
        }
        xe = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("Status"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwStatus),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read status reg value with %d."), lResult));
        }
        xe = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("RsopStatus"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwRsopStatus),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_FILE_NOT_FOUND) {
            DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read rsop status reg value with %d."), lResult));
        }

        // rsop status was not found. treat it as a legacy cse not supporting rsop
        lpExtStatus->dwRsopStatus = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        xe = lResult;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("LastPolicyTime"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwTime),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read time reg value with %d."), lResult));
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("PrevSlowLink"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwSlowLink),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read slowlink reg value with %d."), lResult));
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx( hKey, TEXT("PrevRsopLogging"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->dwRsopLogging),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read rsop logging reg value with %d."), lResult));

        //
        // This can fail currently (first time or run first time after upgrade) with File not found.
        // we will treat it as if logging was not turned on.
    }


    lpExtStatus->bForceRefresh = FALSE;
    dwSize = sizeof(lpExtStatus->bForceRefresh);
    lResult = RegQueryValueEx( hKey, TEXT("ForceRefreshFG"), NULL,
                               &dwType, (LPBYTE) &(lpExtStatus->bForceRefresh),
                               &dwSize );

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Failed to read ForceRefreshFG value with %d."), lResult));

    }

    
    DebugMsg((DM_VERBOSE, TEXT("ReadStatus: Read Extension's Previous status successfully.")));
    bResult = TRUE;

Exit:
    if ( hKey != NULL )
        RegCloseKey( hKey );

    if ( hKeyExt != NULL )
        RegCloseKey( hKeyExt );
        
    lpExtStatus->bStatus = bResult;
}



//*************************************************************
//
//  ReadExtStatus()
//
//  Purpose:    Reads all the extensions status
//
//  Parameters: lpGPOInfo       -  GPOInfo structure
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL ReadExtStatus(LPGPOINFO lpGPOInfo)
{
    LPGPEXT lpExt = lpGPOInfo->lpExtensions;

    while ( lpExt ) {

        BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

        lpExt->lpPrevStatus = (LPGPEXTSTATUS) LocalAlloc(LPTR, sizeof(GPEXTSTATUS));

        if (!(lpExt->lpPrevStatus)) {
            DebugMsg((DM_WARNING, TEXT("ReadExtStatus: Couldn't allocate memory")));
            CEvents ev(TRUE, EVENT_OUT_OF_MEMORY);
            ev.AddArgWin32Error(GetLastError()); ev.Report();
            return FALSE;
            // Things that are already allocated will be freed by the caller
        }


        DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

        DebugMsg((DM_VERBOSE, TEXT("ReadExtStatus: Reading Previous Status for extension %s"), lpExt->lpKeyName));

        ReadStatus( lpExt->lpKeyName, lpGPOInfo,
                         bUsePerUserLocalSetting ? lpGPOInfo->lpwszSidUser : NULL,
                         lpExt->lpPrevStatus );

        lpExt = lpExt->pNext;
    }

    return TRUE;
}




//*************************************************************
//
//  HistoryPresent()
//
//  Purpose:    Checks if the current extension has any cached
//              GPOs
//
//  Parameters: lpGPOInfo   -   GPOInfo
//              lpExt       -   Extension
//              pbPresent   -   (out) returns true if history is present
//
//
//  Return:     TRUE on success
//              FALSE otherwise
//
//*************************************************************

BOOL HistoryPresent( LPGPOINFO lpGPOInfo, LPGPEXT lpExt, BOOL *pbPresent )
{
    TCHAR szKey[400];
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;
    XLastError  xe;

    hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_HISTORY_KEY, lpExt->lpKeyName );
    if ( FAILED(hr) ) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx ( lpGPOInfo->hKeyRoot,
                             szKey,
                             0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {

        RegCloseKey( hKey );
        *pbPresent = TRUE;
        return TRUE;

    }

    //
    // Check if history is cached on per user per machine basis
    //

    BOOL bUsePerUserLocalSetting = lpExt->dwUserLocalSetting && !(lpGPOInfo->dwFlags & GP_MACHINE);

    DmAssert( !bUsePerUserLocalSetting || lpGPOInfo->lpwszSidUser != 0 );

    if ( bUsePerUserLocalSetting ) {

        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_HISTORY_SID_KEY, lpGPOInfo->lpwszSidUser, lpExt->lpKeyName );
        if ( FAILED(hr) ) {
            xe = HRESULT_CODE(hr);
            return FALSE;
        }

        lResult = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                                 szKey,
                                 0, KEY_READ, &hKey);

        if (lResult == ERROR_SUCCESS) {
            RegCloseKey( hKey );
            *pbPresent = TRUE;
            return TRUE;
        } else {
            *pbPresent = FALSE;
            return TRUE;
        }
    }

    *pbPresent = FALSE;
    return TRUE;
}


//*************************************************************
//
//  MigrateMembershipData()
//
//  Purpose:    Moves group membership data from old sid to new
//              sid.
//
//  Parameters: lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateMembershipData( LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    DWORD dwCount = 0;
    DWORD dwSize, dwType, dwMaxSize, dwDisp;
    DWORD i= 0;
    LONG lResult;
    HKEY hKeyRead = NULL, hKeyWrite = NULL;
    BOOL bResult = TRUE;
    LPTSTR lpSid = NULL;
    TCHAR szKeyRead[250];
    TCHAR szKeyWrite[250];
    const DWORD dwGrpLength = 30;
    TCHAR szGroup[dwGrpLength];
    XLastError xe;
    HRESULT hr = S_OK;

    hr = StringCchPrintf( szKeyRead, ARRAYSIZE(szKeyRead), GP_MEMBERSHIP_KEY, lpwszSidUserOld );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKeyRead, 0, KEY_READ, &hKeyRead);

    if (lResult != ERROR_SUCCESS)
        return TRUE;

    hr = StringCchPrintf( szKeyWrite, ARRAYSIZE(szKeyWrite), GP_MEMBERSHIP_KEY, lpwszSidUserNew );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegDelnode( HKEY_LOCAL_MACHINE, szKeyWrite );
    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("MigrateMembershipData: RegDelnode failed.")));
        bResult = FALSE;
        goto Exit;
    }

    lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKeyWrite, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyWrite, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to create key with %d."), lResult));
        bResult = FALSE;
        goto Exit;
    }

    dwSize = sizeof(dwCount);
    lResult = RegQueryValueEx (hKeyRead, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCount, &dwSize);
    if ( lResult != ERROR_SUCCESS ) {
        xe = lResult;
        DebugMsg((DM_VERBOSE, TEXT("MigrateMembershipData: Failed to read membership count")));
        goto Exit;
    }


    lResult = RegQueryInfoKey (hKeyRead, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &dwMaxSize, NULL, NULL);
    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to query max size with %d."), lResult));
        goto Exit;
    }

    //
    // RegQueryInfoKey does not account for trailing 0 in strings
    //

    dwMaxSize += sizeof( WCHAR );

    
    //
    // Allocate buffer based upon the largest value
    //

    lpSid = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

    if (!lpSid) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to allocate memory with %d."), lResult));
        bResult = FALSE;
        goto Exit;
    }

    for ( i=0; i<dwCount; i++ ) {

        hr = StringCchPrintf( szGroup, dwGrpLength, TEXT("Group%d"), i );
        if ( FAILED(hr) ) {
            xe = HRESULT_CODE(hr);
            bResult = FALSE;
            goto Exit;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hKeyRead, szGroup, NULL, &dwType, (LPBYTE) lpSid, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to read value %ws"), szGroup ));
            goto Exit;
        }

        dwSize = (lstrlen(lpSid) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKeyWrite, szGroup, 0, REG_SZ, (LPBYTE) lpSid, dwSize);

        if (lResult != ERROR_SUCCESS) {
            xe = lResult;
            bResult = FALSE;
            DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to write value %ws"), szGroup ));
            goto Exit;
        }

    }

    dwSize = sizeof(dwCount);
    lResult = RegSetValueEx (hKeyWrite, TEXT("Count"), 0, REG_DWORD, (LPBYTE) &dwCount, dwSize);

    if (lResult != ERROR_SUCCESS) {
        xe = lResult;
        bResult = FALSE;
        DebugMsg((DM_WARNING, TEXT("MigrateMembershipData: Failed to write count value") ));
        goto Exit;
    }


Exit:

    if ( lpSid )
        LocalFree( lpSid );

    if ( hKeyRead )
        RegCloseKey (hKeyRead);

    if ( hKeyWrite )
        RegCloseKey (hKeyWrite);

    return bResult;
}


//*************************************************************
//
//  MigrateGPOData()
//
//  Purpose:    Moves cached GPOs from old sid to new
//              sid.
//
//  Parameters: lpGPOInfo       -   GPOInfo
//              lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateGPOData( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    TCHAR szKey[250];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    TCHAR szExtension[50];
    DWORD dwSize = 50;
    PGROUP_POLICY_OBJECT pGPOList, lpGPO, lpGPOTemp;
    BOOL bResult;
    XLastError xe;
    HRESULT hr = S_OK;

    hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_HISTORY_SID_ROOT_KEY, lpwszSidUserOld );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return TRUE;

    while (RegEnumKeyEx (hKey, dwIndex, szExtension, &dwSize,
                         NULL, NULL, NULL, NULL) == ERROR_SUCCESS ) {

        if ( ReadGPOList( szExtension, NULL, HKEY_LOCAL_MACHINE,
                         lpwszSidUserOld, FALSE, &pGPOList) ) {

            bResult = SaveGPOList( szExtension, lpGPOInfo, HKEY_LOCAL_MACHINE,
                                   lpwszSidUserNew, FALSE, pGPOList );
            lpGPO = pGPOList;

            while (lpGPO) {
                lpGPOTemp = lpGPO->pNext;
                LocalFree (lpGPO);
                lpGPO = lpGPOTemp;
            }

            if ( !bResult ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("MigrateGPOData: Failed to save GPO list") ));
                RegCloseKey( hKey );
                return FALSE;
            }

        }
        else {
            CEvents ev(TRUE, EVENT_READ_EXT_FAILED); // Fixing bug 569320 
            ev.AddArgWin32Error(GetLastError()); ev.Report();
        }

        dwSize = ARRAYSIZE(szExtension);
        dwIndex++;
    }

    RegCloseKey( hKey );
    return TRUE;
}


//*************************************************************
//
//  MigrateStatusData()
//
//  Purpose:    Moves extension status data from old sid to new
//              sid.
//
//  Parameters: lpGPOInfo       -   GPOInfo
//              lpwszSidUserNew - New sid
//              lpwszSidUserOld - Old sid
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL MigrateStatusData( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUserNew, LPTSTR lpwszSidUserOld )
{
    TCHAR szKey[250];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwIndex = 0;
    TCHAR szExtension[50];
    DWORD dwSize = 50;
    BOOL bTemp;
    XLastError xe;
    HRESULT hr = S_OK;

    hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_EXTENSIONS_SID_ROOT_KEY, lpwszSidUserOld );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return TRUE;

    while (RegEnumKeyEx (hKey, dwIndex, szExtension, &dwSize,
                         NULL, NULL, NULL, NULL) == ERROR_SUCCESS ) {

        GPEXTSTATUS gpExtStatus;

        ReadStatus( szExtension, lpGPOInfo, lpwszSidUserOld, &gpExtStatus);

        if (gpExtStatus.bStatus) {
            bTemp = WriteStatus( szExtension, lpGPOInfo, lpwszSidUserNew, &gpExtStatus );

            if ( !bTemp ) {
                xe = GetLastError();
                DebugMsg((DM_WARNING, TEXT("MigrateStatusData: Failed to save status") ));
                RegCloseKey( hKey );
                return FALSE;
            }
        }

        dwSize = ARRAYSIZE(szExtension);
        dwIndex++;
    }

    RegCloseKey( hKey );
    return TRUE;

}

//*************************************************************
//
//  CheckForChangedSid()
//
//  Purpose:    Checks if the user's sid has changed and if so,
//              moves history data from old sid to new sid.
//
//  Parameters: lpGPOInfo   -   GPOInfo
//
//  Return:     TRUE if success
//              FALSE otherwise
//
//*************************************************************

BOOL CheckForChangedSid (LPGPOINFO lpGPOInfo, CLocator *locator)
{
    TCHAR szKey[400];
    LONG lResult;
    HKEY hKey = NULL;
    LPTSTR lpwszSidUserOld = NULL;
    DWORD dwDisp;
    BOOL bCommit = FALSE;      // True, if move of history data should be committed
    XLastError xe;
    HRESULT hr = S_OK;

    //
    // initialize it to FALSE at the beginning and if the Sid has
    // changed we will set it to true later on..
    //

    lpGPOInfo->bSidChanged = FALSE;

    if ( lpGPOInfo->dwFlags & GP_MACHINE )
        return TRUE;


    if ( lpGPOInfo->lpwszSidUser == 0 ) {

        lpGPOInfo->lpwszSidUser = GetSidString( lpGPOInfo->hToken );
        if ( lpGPOInfo->lpwszSidUser == 0 ) {
            xe = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: GetSidString failed.")));
            CEvents ev(TRUE, EVENT_FAILED_GET_SID); ev.Report();
            return FALSE;
        }
    }

    if (!(lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY))
        return TRUE;

    //
    // Check if the key where history is cached exists
    //

    hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_POLICY_SID_KEY, lpGPOInfo->lpwszSidUser );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);

    if ( lResult == ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        return TRUE;
    }

    if ( lResult != ERROR_FILE_NOT_FOUND ) {
        xe = lResult;
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: Failed to open registry key with %d."),
                  lResult ));
        return FALSE;
    }

    //
    // This is the first time that we are seeing this sid, it can either be a brand new sid or
    // an old sid that has been renamed.
    //

    lpwszSidUserOld =  GetOldSidString( lpGPOInfo->hToken, POLICY_GUID_PATH );

    if ( !lpwszSidUserOld )
    {
        //
        // Brand new sid
        //

        if ( !SetOldSidString(lpGPOInfo->hToken, lpGPOInfo->lpwszSidUser, POLICY_GUID_PATH) ) {
             xe = GetLastError();
             DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: WriteSidMapping failed.") ));

             CEvents ev(TRUE, EVENT_FAILED_WRITE_SID_MAPPING); ev.Report();
             return FALSE;
        }

        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: RegCreateKey failed.") ));
            return TRUE;
        }

        RegCloseKey( hKey );

        return TRUE;
    }
    else
    {
        DeletePolicyState( lpwszSidUserOld );
    }

    //
    // Need to migrate history data from old sid to new sid
    //

    if ( !MigrateMembershipData( lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateMembershipData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }

    if ( !MigrateGPOData( lpGPOInfo, lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateGPOData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }

    if ( !MigrateStatusData( lpGPOInfo, lpGPOInfo->lpwszSidUser, lpwszSidUserOld ) ) {
        xe = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: MigrateStatusData failed.") ));
        CEvents ev(TRUE, EVENT_FAILED_MIGRATION); ev.Report();
        goto Exit;
    }


    //
    // Migrate Rsop Data, ignore failures
    //
    
    if (locator->GetWbemLocator()) {
        DWORD dwRSOPNSLength = lstrlen(RSOP_NS_DIAG_USER_FMT) + lstrlen(lpwszSidUserOld) + 10;
        XPtrLF<WCHAR> xszRsopNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*
                                            (dwRSOPNSLength));

        // convert the Sids to WMI Names
        XPtrLF<WCHAR> xszWmiNameOld = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpwszSidUserOld)+1));
        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpGPOInfo->lpwszSidUser)+1));


        if ((xszRsopNameSpace) && (xszWmiNameOld) && (xszWmiName)) {

            ConvertSidToWMIName(lpwszSidUserOld, xszWmiNameOld);
            ConvertSidToWMIName(lpGPOInfo->lpwszSidUser, xszWmiName);
        
            hr = StringCchPrintf(xszRsopNameSpace, dwRSOPNSLength, RSOP_NS_DIAG_USER_FMT, xszWmiNameOld);
            ASSERT(SUCCEEDED(hr));

            CreateAndCopyNameSpace(locator->GetWbemLocator(), xszRsopNameSpace, RSOP_NS_DIAG_USERROOT, 
                                   xszWmiName, NEW_NS_FLAGS_COPY_CLASSES | NEW_NS_FLAGS_COPY_INSTS, 
                                   NULL, NULL);

        } else {
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: couldn't allocate memory.") ));
        }
            
    } else {
        DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: couldn't get WMI locator.") ));
    }

    bCommit = TRUE;

Exit:

    if ( bCommit ) {

        if ( !SetOldSidString(lpGPOInfo->hToken, lpGPOInfo->lpwszSidUser, POLICY_GUID_PATH) )
             DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: SetOldString failed.") ));

        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
            RegCloseKey( hKey );
        else
            DebugMsg((DM_WARNING, TEXT("CheckForChangedSid: RegCreateKey failed.") ));

        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_POLICY_SID_KEY, lpwszSidUserOld );
        ASSERT(SUCCEEDED(hr));

        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_LOGON_SID_KEY, lpwszSidUserOld );
        ASSERT(SUCCEEDED(hr));

        RegDelnode( HKEY_LOCAL_MACHINE, szKey );


        //
        // if we managed to successfully migrate everything
        //

        lpGPOInfo->bSidChanged = TRUE;


    } else {

        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_POLICY_SID_KEY, lpGPOInfo->lpwszSidUser );
        ASSERT(SUCCEEDED(hr));
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), GP_LOGON_SID_KEY, lpGPOInfo->lpwszSidUser );
        ASSERT(SUCCEEDED(hr));
        RegDelnode( HKEY_LOCAL_MACHINE, szKey );

    }

    if ( lpwszSidUserOld )
        LocalFree( lpwszSidUserOld );

    return bCommit;
}


//*************************************************************
//
//  ReadGPExtensions()
//
//  Purpose:    Reads the group policy extenions from registry.
//              The actual loading of extension is deferred.
//
//  Parameters: lpGPOInfo   -   GP Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ReadGPExtensions (LPGPOINFO lpGPOInfo)
{
    TCHAR szSubKey[MAX_PATH];
    DWORD dwType;
    HKEY hKey, hKeyOverride;
    DWORD dwIndex = 0;
    DWORD dwSize = 50;
    TCHAR szDisplayName[50];
    TCHAR szKeyName[50];
    TCHAR szDllName[MAX_PATH+1];
    TCHAR szExpDllName[MAX_PATH+1];
    CHAR  szFunctionName[100];
    CHAR  szRsopFunctionName[100];
    HKEY hKeyExt;
    HINSTANCE hInstDLL;
    LPGPEXT lpExt, lpTemp;
    HRESULT hr = S_OK;
    XLastError  xe;

    //
    // Check if any extensions are registered
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      GP_EXTENSIONS,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {


        //
        // Enumerate the keys (each extension has its own key)
        //

        while (RegEnumKeyEx (hKey, dwIndex, szKeyName, &dwSize,
                                NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {


            //
            // Open the extension's key.
            //

            if (RegOpenKeyEx (hKey, szKeyName,
                              0, KEY_READ, &hKeyExt) == ERROR_SUCCESS) {

                if ( ValidateGuid( szKeyName ) ) {

                    if ( lstrcmpi(szKeyName, c_szRegistryExtName) != 0 ) {

                        //
                        // Every extension, other than RegistryExtension is required to have a value called
                        // DllName.  This value can be REG_SZ or REG_EXPAND_SZ type.
                        //

                        dwSize = sizeof(szDllName);
                        if (RegQueryValueEx (hKeyExt, TEXT("DllName"), NULL,
                                             &dwType, (LPBYTE) szDllName,
                                             &dwSize) == ERROR_SUCCESS) {

                            BOOL bFuncFound = FALSE;
                            BOOL bNewInterface = FALSE;

                            DWORD dwNoMachPolicy = FALSE;
                            DWORD dwNoUserPolicy = FALSE;
                            DWORD dwNoSlowLink   = FALSE;
                            DWORD dwNoBackgroundPolicy = FALSE;
                            DWORD dwNoGPOChanges = FALSE;
                            DWORD dwUserLocalSetting = FALSE;
                            DWORD dwRequireRegistry = FALSE;
                            DWORD dwEnableAsynch = FALSE;
                            DWORD dwMaxChangesInterval = 0;
                            DWORD dwLinkTransition = FALSE;
                            WCHAR szEventLogSources[MAX_PATH+1];
                            DWORD dwSizeEventLogSources = MAX_PATH+1;
                            DWORD cchDllName = 0;

                            cchDllName = ExpandEnvironmentStrings (szDllName, szExpDllName, MAX_PATH);

                            //
                            // Read new interface name, if failed read old interface name
                            //

                            dwSize = sizeof(szFunctionName);

                            if ( cchDllName > 0 )
                            {
                                if ( RegQueryValueExA (hKeyExt, "ProcessGroupPolicyEx", NULL,
                                                    &dwType, (LPBYTE) szFunctionName,
                                                    &dwSize) == ERROR_SUCCESS ) {
                                    bFuncFound = TRUE;
                                    bNewInterface = TRUE;

                                } else if ( RegQueryValueExA (hKeyExt, "ProcessGroupPolicy", NULL,
                                                            &dwType, (LPBYTE) szFunctionName,
                                                            &dwSize) == ERROR_SUCCESS ) {
                                    bFuncFound = TRUE;
                                }
                            }

                            if (  bFuncFound) {

                                //
                                // Read preferences
                                //

                                dwSize = sizeof(szDisplayName);
                                if (RegQueryValueEx (hKeyExt, NULL, NULL,
                                                     &dwType, (LPBYTE) szDisplayName,
                                                     &dwSize) != ERROR_SUCCESS) {
                                    lstrcpyn (szDisplayName, szKeyName, ARRAYSIZE(szDisplayName));
                                }

                                dwSize = sizeof(szRsopFunctionName);
                                if (RegQueryValueExA (hKeyExt, "GenerateGroupPolicy", NULL,
                                                      &dwType, (LPBYTE) szRsopFunctionName,
                                                      &dwSize) != ERROR_SUCCESS) {
                                    szRsopFunctionName[0] = 0;
                                    DebugMsg((DM_VERBOSE, TEXT("ReadGPExtensions: Rsop entry point not found for %s."),
                                                szExpDllName));

                                }

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoMachinePolicy"), NULL,
                                                 &dwType, (LPBYTE) &dwNoMachPolicy,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoUserPolicy"), NULL,
                                                 &dwType, (LPBYTE) &dwNoUserPolicy,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoSlowLink"), NULL,
                                                     &dwType, (LPBYTE) &dwNoSlowLink,
                                                     &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoGPOListChanges"), NULL,
                                                     &dwType, (LPBYTE) &dwNoGPOChanges,
                                                     &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NoBackgroundPolicy"), NULL,
                                                     &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                                                     &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("PerUserLocalSettings"), NULL,
                                                 &dwType, (LPBYTE) &dwUserLocalSetting,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("RequiresSuccessfulRegistry"), NULL,
                                                 &dwType, (LPBYTE) &dwRequireRegistry,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("EnableAsynchronousProcessing"), NULL,
                                                 &dwType, (LPBYTE) &dwEnableAsynch,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("MaxNoGPOListChangesInterval"), NULL,
                                                 &dwType, (LPBYTE) &dwMaxChangesInterval,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                RegQueryValueEx( hKeyExt, TEXT("NotifyLinkTransition"), NULL,
                                                 &dwType, (LPBYTE) &dwLinkTransition,
                                                 &dwSize );

                                dwSize = sizeof(DWORD);
                                if (RegQueryValueEx( hKeyExt, TEXT("EventSources"), 0,
                                                 &dwType, (LPBYTE) &(szEventLogSources[0]),
                                                 &dwSizeEventLogSources ) != ERROR_SUCCESS) {
                                    dwSizeEventLogSources = 0;
                                    szEventLogSources[0] = TEXT('\0');
                                }

                                //
                                // Read override policy values, if any
                                //

                                hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), GP_EXTENSIONS_POLICIES, szKeyName );
                                ASSERT(SUCCEEDED(hr));

                                if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                                  szSubKey,
                                                  0, KEY_READ, &hKeyOverride ) == ERROR_SUCCESS) {

                                    dwSize = sizeof(DWORD);
                                    RegQueryValueEx( hKeyOverride, TEXT("NoSlowLink"), NULL,
                                                     &dwType, (LPBYTE) &dwNoSlowLink,
                                                     &dwSize );

                                    dwSize = sizeof(DWORD);
                                    RegQueryValueEx( hKeyOverride, TEXT("NoGPOListChanges"), NULL,
                                                     &dwType, (LPBYTE) &dwNoGPOChanges,
                                                     &dwSize );

                                    dwSize = sizeof(DWORD);
                                    RegQueryValueEx( hKeyOverride, TEXT("NoBackgroundPolicy"), NULL,
                                                     &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                                                     &dwSize );

                                    RegCloseKey( hKeyOverride );
                                }

                            }

                            if ( bFuncFound ) {
                                DWORD dwExtSize = sizeof(GPEXT)
                                                          + ((lstrlen(szDisplayName) + 1) * sizeof(TCHAR))
                                                          + ((lstrlen(szKeyName) + 1) * sizeof(TCHAR))
                                                          + ((lstrlen(szExpDllName) + 1) * sizeof(TCHAR))
                                                          + lstrlenA(szFunctionName) + 1
                                                          + lstrlenA(szRsopFunctionName) + 1;
                                lpExt = (LPGPEXT) LocalAlloc (LPTR,  dwExtSize);
                                if (lpExt) {

                                    //
                                    // Set up all fields
                                    //

                                    lpExt->lpDisplayName = (LPTSTR)((LPBYTE)lpExt + sizeof(GPEXT));
                                    hr = StringCchCopy( lpExt->lpDisplayName, lstrlen(szDisplayName) + 1, szDisplayName );
                                    ASSERT(SUCCEEDED(hr));

                                    lpExt->lpKeyName = lpExt->lpDisplayName + lstrlen(lpExt->lpDisplayName) + 1;
                                    hr = StringCchCopy( lpExt->lpKeyName, lstrlen(szKeyName) + 1, szKeyName );
                                    ASSERT(SUCCEEDED(hr));

                                    StringToGuid( szKeyName, &lpExt->guid );

                                    lpExt->lpDllName = lpExt->lpKeyName + lstrlen(lpExt->lpKeyName) + 1;
                                    hr = StringCchCopy (lpExt->lpDllName, lstrlen(szExpDllName) + 1, szExpDllName);
                                    ASSERT(SUCCEEDED(hr));

                                    lpExt->lpFunctionName = (LPSTR)( (LPBYTE)lpExt->lpDllName + (lstrlen(lpExt->lpDllName) + 1) * sizeof(TCHAR) );
                                    hr = StringCchCopyA( lpExt->lpFunctionName, lstrlenA(szFunctionName) + 1, szFunctionName );
                                    ASSERT(SUCCEEDED(hr));

                                    if ( szRsopFunctionName[0] == 0 ) {
                                        lpExt->lpRsopFunctionName = 0;
                                    } else {
                                        lpExt->lpRsopFunctionName = (LPSTR)( (LPBYTE)lpExt->lpDllName + (lstrlen(lpExt->lpDllName) + 1) * sizeof(TCHAR)
                                                                             + lstrlenA(szFunctionName) + 1);
                                        hr = StringCchCopyA( lpExt->lpRsopFunctionName, lstrlenA(szRsopFunctionName) + 1, szRsopFunctionName );
                                        ASSERT(SUCCEEDED(hr));
                                    }

                                    lpExt->hInstance = NULL;
                                    lpExt->pEntryPoint = NULL;
                                    lpExt->pEntryPointEx = NULL;
                                    lpExt->bNewInterface = bNewInterface;

                                    lpExt->dwNoMachPolicy = dwNoMachPolicy;
                                    lpExt->dwNoUserPolicy = dwNoUserPolicy;
                                    lpExt->dwNoSlowLink = dwNoSlowLink;
                                    lpExt->dwNoBackgroundPolicy = dwNoBackgroundPolicy;
                                    lpExt->dwNoGPOChanges = dwNoGPOChanges;
                                    lpExt->dwUserLocalSetting = dwUserLocalSetting;
                                    lpExt->dwRequireRegistry = dwRequireRegistry;
                                    lpExt->dwEnableAsynch = dwEnableAsynch;
                                    lpExt->dwMaxChangesInterval = dwMaxChangesInterval;
                                    lpExt->dwLinkTransition = dwLinkTransition;

                                    if ( dwSizeEventLogSources )
                                    {
                                        lpExt->szEventLogSources = (LPTSTR) LocalAlloc( LPTR, dwSizeEventLogSources+ sizeof(TCHAR) );
                                        if ( lpExt->szEventLogSources )
                                        {
                                            memcpy( lpExt->szEventLogSources, szEventLogSources, dwSizeEventLogSources );
                                        }
                                    }

                                    lpExt->bRegistryExt = FALSE;
                                    lpExt->bSkipped = FALSE;
                                    lpExt->pNext = NULL;

                                    //
                                    // Append to end of extension list
                                    //

                                    if (lpGPOInfo->lpExtensions) {

                                        lpTemp = lpGPOInfo->lpExtensions;

                                        while (TRUE) {
                                            if (lpTemp->pNext) {
                                                lpTemp = lpTemp->pNext;
                                            } else {
                                                break;
                                            }
                                        }

                                        lpTemp->pNext = lpExt;

                                    } else {
                                        lpGPOInfo->lpExtensions = lpExt;
                                    }

                                } else {   // if lpExt
                                    DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to allocate memory with %d"),
                                              GetLastError()));
                                }
                            } else {       // if bFuncFound
                                DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to query for the function name.")));
                                CEvents ev(TRUE, EVENT_EXT_MISSING_FUNC);
                                ev.AddArg(szExpDllName); ev.Report();
                            }
                        } else {           // if RegQueryValueEx DllName
                            DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to query DllName value.")));
                            CEvents ev(TRUE, EVENT_EXT_MISSING_DLLNAME);
                            ev.AddArg(szKeyName); ev.Report();
                        }

                    } // if lstrcmpi(szKeyName, c_szRegistryExtName)

                }  // if validateguid

                RegCloseKey (hKeyExt);
            }     // if RegOpenKey hKeyExt

            dwSize = ARRAYSIZE(szKeyName);
            dwIndex++;
        }         // while RegEnumKeyEx

        RegCloseKey (hKey);
    }             // if RegOpenKey gpext

    //
    // Add the registry psuedo extension at the beginning
    //
    DWORD dwExtSize = 0;
    if ( LoadString (g_hDllInstance, IDS_REGISTRYNAME, szDisplayName, ARRAYSIZE(szDisplayName)) ) {
        dwExtSize = sizeof(GPEXT)
                    + ((lstrlen(szDisplayName) + 1) * sizeof(TCHAR))
                    + ((lstrlen(c_szRegistryExtName) + 1) * sizeof(TCHAR)) ;
        lpExt = (LPGPEXT) LocalAlloc (LPTR, dwExtSize);
    } else {

        lpExt = 0;
    }

    if (lpExt) {

        DWORD dwNoSlowLink = FALSE;
        DWORD dwNoGPOChanges = TRUE;
        DWORD dwNoBackgroundPolicy = FALSE;

        lpExt->lpDisplayName = (LPTSTR)((LPBYTE)lpExt + sizeof(GPEXT));
        hr = StringCchCopy( lpExt->lpDisplayName, lstrlen(szDisplayName) + 1, szDisplayName );
        ASSERT(SUCCEEDED(hr));

        lpExt->lpKeyName = lpExt->lpDisplayName + lstrlen(lpExt->lpDisplayName) + 1;
        hr = StringCchCopy( lpExt->lpKeyName, lstrlen(c_szRegistryExtName) + 1, c_szRegistryExtName );
        ASSERT(SUCCEEDED(hr));

        StringToGuid( lpExt->lpKeyName, &lpExt->guid );

        lpExt->lpDllName = L"userenv.dll";
        lpExt->lpFunctionName = NULL;
        lpExt->hInstance = NULL;
        lpExt->pEntryPoint = NULL;

        //
        // Read override policy values, if any
        //

        hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), GP_EXTENSIONS_POLICIES, lpExt->lpKeyName );
        if (FAILED(hr)) {
            LocalFree(lpExt);
            xe = HRESULT_CODE(hr);
            return FALSE;
        }

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                          szSubKey,
                          0, KEY_READ, &hKeyOverride ) == ERROR_SUCCESS) {

            dwSize = sizeof( dwNoGPOChanges );  
            RegQueryValueEx( hKeyOverride, TEXT("NoGPOListChanges"), NULL,
                             &dwType, (LPBYTE) &dwNoGPOChanges,
                             &dwSize );

            dwSize = sizeof( dwNoBackgroundPolicy );  
            RegQueryValueEx( hKeyOverride, TEXT("NoBackgroundPolicy"), NULL,
                             &dwType, (LPBYTE) &dwNoBackgroundPolicy,
                             &dwSize );
            RegCloseKey( hKeyOverride );

        }

        lpExt->dwNoMachPolicy = FALSE;
        lpExt->dwNoUserPolicy = FALSE;
        lpExt->dwNoSlowLink = dwNoSlowLink;
        lpExt->dwNoBackgroundPolicy = dwNoBackgroundPolicy;
        lpExt->dwNoGPOChanges = dwNoGPOChanges;
        lpExt->dwUserLocalSetting = FALSE;
        lpExt->dwRequireRegistry = FALSE;
        lpExt->dwEnableAsynch = FALSE;
        lpExt->dwLinkTransition = FALSE;

        lpExt->bRegistryExt = TRUE;
        lpExt->bSkipped = FALSE;
        lpExt->bNewInterface = TRUE;

        lpExt->pNext = lpGPOInfo->lpExtensions;
        lpGPOInfo->lpExtensions = lpExt;

    } else {
        DebugMsg((DM_WARNING, TEXT("ReadGPExtensions: Failed to allocate memory with %d"),
                  GetLastError()));

        return FALSE;

    }

    return TRUE;
}




//*************************************************************
//
//  ReadMembershipList()
//
//  Purpose:    Reads cached memberhip list and checks if the
//              security groups has changed.
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              pGroups   - List of token groups
//
//  Return:     TRUE if changed
//              FALSE otherwise
//
//*************************************************************

BOOL ReadMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroupsCur )
{
    DWORD i= 0;
    LONG lResult;
    TCHAR szGroup[30];
    TCHAR szKey[250];
    HKEY hKey = NULL;
    BOOL bDiff = TRUE;
    DWORD dwCountOld = 0;
    DWORD dwSize, dwType, dwMaxSize;
    LPTSTR lpSid = NULL;
    HRESULT hr = S_OK;
    DWORD dwCountCur = 0;
    XLastError  xe;

    //
    // Get current count of groups ignoring groups that have
    // the SE_GROUP_LOGON_ID attribute set as this sid will be different
    // for each logon session.
    //

    for ( i=0; i < pGroupsCur->GroupCount; i++) {
        if ( (SE_GROUP_LOGON_ID & pGroupsCur->Groups[i].Attributes) == 0 )
            dwCountCur++;
    }

    //
    // Read from cached group membership list
    //

    if ( lpwszSidUser == 0 )
        hr = StringCchCopy( szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership") );
    else
        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership"),
                  lpwszSidUser );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        goto Exit;
    }

    lResult = RegOpenKeyEx ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                             szKey,
                             0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS)
        return TRUE;

    dwSize = sizeof(dwCountOld);
    lResult = RegQueryValueEx (hKey, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCountOld, &dwSize);

    if ( lResult != ERROR_SUCCESS ) {
        DebugMsg((DM_VERBOSE, TEXT("ReadMembershipList: Failed to read old group count") ));
        goto Exit;
    }

    //
    // Now compare the old and new number of security groups
    //

    if ( dwCountOld != dwCountCur ) {
        DebugMsg((DM_VERBOSE, TEXT("ReadMembershipList: Old count %d is different from current count %d"),
                  dwCountOld, dwCountCur ));
        goto Exit;
    }

    //
    // Total group count is the same, now check that each individual group is the same.
    // First read the size of the largest value in this key.
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &dwMaxSize, NULL, NULL);
    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to query max size with %d."), lResult));
        goto Exit;
    }

    //
    // RegQueryInfoKey does not account for trailing 0 in strings
    //

    dwMaxSize += sizeof( WCHAR );
    
        
    //
    // Allocate buffer based upon the largest value
    //

    lpSid = (LPTSTR) LocalAlloc (LPTR, dwMaxSize);

    if (!lpSid) {
        DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to allocate memory with %d."), lResult));
        goto Exit;
    }

    for ( i=0; i<dwCountOld; i++ ) {

        hr = StringCchPrintf( szGroup, ARRAYSIZE(szGroup), TEXT("Group%d"), i );
        if (FAILED(hr)) {
            xe = HRESULT_CODE(hr);
            goto Exit;
        }

        dwSize = dwMaxSize;
        lResult = RegQueryValueEx (hKey, szGroup, NULL, &dwType,
                                   (LPBYTE) lpSid, &dwSize);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Failed to read value %ws"), szGroup ));
            goto Exit;
        }

        if ( !GroupInList( lpSid, pGroupsCur ) ) {
            DebugMsg((DM_WARNING, TEXT("ReadMembershipList: Group %ws not in current list of token groups"), lpSid ));
            goto Exit;
        }

    }

    bDiff = FALSE;

Exit:

    if ( lpSid )
        LocalFree( lpSid );

    if ( hKey )
        RegCloseKey (hKey);

    return bDiff;
}



//*************************************************************
//
//  SavesMembershipList()
//
//  Purpose:    Caches memberhip list
//
//  Parameters: lpGPOInfo - LPGPOINFO struct
//              lpwszSidUser - Sid of user, if non-null then it means
//                             per user local setting
//              pGroups   - List of token groups to cache
//
//  Notes:      The count is saved last because it serves
//              as a commit point for the entire save operation.
//
//*************************************************************

void SaveMembershipList( LPGPOINFO lpGPOInfo, LPTSTR lpwszSidUser, PTOKEN_GROUPS pGroups )
{
    TCHAR szKey[250];
    TCHAR szGroup[30];
    DWORD i;
    LONG lResult;
    DWORD dwCount = 0, dwSize, dwDisp;
    NTSTATUS ntStatus;
    UNICODE_STRING unicodeStr;
    HKEY hKey = NULL;
    HRESULT hr = S_OK;
    XLastError  xe;

    //
    // Start with clean key
    //

    if ( lpwszSidUser == 0 )
        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership") );
    else
        hr = StringCchPrintf( szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership"),
                  lpwszSidUser );
    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return;
    }

    if (RegDelnode ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot, szKey) != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("SaveMembershipList: RegDelnode failed.")));
        return;
    }

    lResult = RegCreateKeyEx ( lpwszSidUser ? HKEY_LOCAL_MACHINE : lpGPOInfo->hKeyRoot,
                               szKey, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisp);
    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveMemberList: Failed to create key with %d."), lResult));
        goto Exit;
    }

    for ( i=0; i < pGroups->GroupCount; i++) {

        if (SE_GROUP_LOGON_ID & pGroups->Groups[i].Attributes )
            continue;

        dwCount++;

        //
        // Convert user SID to a string.
        //

        ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                 pGroups->Groups[i].Sid,
                                                 (BOOLEAN)TRUE ); // Allocate
        if ( !NT_SUCCESS(ntStatus) ) {
            DebugMsg((DM_WARNING, TEXT("SaveMembershipList: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                      ntStatus));
            goto Exit;
        }

        hr = StringCchPrintf( szGroup, ARRAYSIZE(szGroup), TEXT("Group%d"), dwCount-1 );
        ASSERT(SUCCEEDED(hr));

        dwSize = (lstrlen (unicodeStr.Buffer) + 1) * sizeof(TCHAR);
        lResult = RegSetValueEx (hKey, szGroup, 0, REG_SZ,
                                 (LPBYTE) unicodeStr.Buffer, dwSize);

        RtlFreeUnicodeString( &unicodeStr );

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveMemberList: Failed to set value %ws with %d."),
                      szGroup, lResult));
            goto Exit;
        }

    }   // for

    //
    // Commit by writing count
    //

    dwSize = sizeof(dwCount);
    lResult = RegSetValueEx (hKey, TEXT("Count"), 0, REG_DWORD,
                             (LPBYTE) &dwCount, dwSize);

Exit:
    if (hKey)
        RegCloseKey (hKey);
}





//*************************************************************
//
//  ExtensionHasPerUserLocalSetting()
//
//  Purpose:    Checks registry if extension has per user local setting
//
//  Parameters: pwszExtension - Extension guid
//              hKeyRoot      - Registry root
//
//  Returns:    True if extension has per user local setting
//              False otherwise
//
//*************************************************************

BOOL ExtensionHasPerUserLocalSetting( LPTSTR pszExtension, HKEY hKeyRoot )
{
    TCHAR szKey[200];
    DWORD dwType, dwSetting = 0, dwSize = sizeof(DWORD);
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;

    hr = StringCchPrintf ( szKey, ARRAYSIZE(szKey), GP_EXTENSIONS_KEY, pszExtension );
    ASSERT(SUCCEEDED(hr));

    lResult = RegOpenKeyEx ( hKeyRoot, szKey, 0, KEY_READ, &hKey);
    if ( lResult != ERROR_SUCCESS )
        return FALSE;

    lResult = RegQueryValueEx( hKey, TEXT("PerUserLocalSettings"), NULL,
                               &dwType, (LPBYTE) &dwSetting,
                               &dwSize );
    RegCloseKey( hKey );

    if (lResult == ERROR_SUCCESS)
        return dwSetting;
    else
        return FALSE;
}



//*************************************************************
//
//  GetAppliedGPOList()
//
//  Purpose:    Queries for the list of applied Group Policy
//              Objects for the specified user or machine
//              and specified client side extension.
//
//  Parameters: dwFlags    -  User or machine policy, if it is GPO_LIST_FLAG_MACHINE
//                            then machine policy
//              pMachineName  - Name of remote computer in the form \\computername. If null
//                              then local computer is used.
//              pSidUser      - Security id of user (relevant for user policy). If pMachineName is
//                              null and pSidUser is null then it means current logged on user.
//                              If pMachine is null and pSidUser is non-null then it means user
//                              represented by pSidUser on local machine. If pMachineName is non-null
//                              then and if dwFlags specifies user policy, then pSidUser must be
//                              non-null.
//              pGuid      -  Guid of the specified extension
//              ppGPOList  -  Address of a pointer which receives the link list of GPOs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD GetAppliedGPOList( DWORD dwFlags,
                         LPCTSTR pMachineName,
                         PSID pSidUser,
                         GUID *pGuidExtension,
                         PGROUP_POLICY_OBJECT *ppGPOList)
{
    DWORD dwRet = E_FAIL;
    TCHAR szExtension[64];
    BOOL bOk;
    BOOL bMachine = dwFlags & GPO_LIST_FLAG_MACHINE;
    NTSTATUS ntStatus;
    UNICODE_STRING  unicodeStr;

    *ppGPOList = 0;

    if ( pGuidExtension == 0 )
        return ERROR_INVALID_PARAMETER;

    GuidToString( pGuidExtension, szExtension );

    DebugMsg((DM_VERBOSE, TEXT("GetAppliedGPOList: Entering. Extension = %s"),
              szExtension));

    if ( pMachineName == NULL ) {

        //
        // Local case
        //

        if ( bMachine ) {

            bOk = ReadGPOList( szExtension,
                               HKEY_LOCAL_MACHINE,
                               HKEY_LOCAL_MACHINE,
                               0,
                               FALSE, ppGPOList );

            return bOk ? ERROR_SUCCESS : E_FAIL;

        } else {

            BOOL bUsePerUserLocalSetting = ExtensionHasPerUserLocalSetting( szExtension, HKEY_LOCAL_MACHINE );
            LPTSTR lpwszSidUser = NULL;

            if ( pSidUser == NULL ) {

                //
                // Current logged on user
                //

                if ( bUsePerUserLocalSetting ) {

                    HANDLE hToken = NULL;
                    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
                        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
                            DebugMsg((DM_WARNING, TEXT("GetAppliedGPOList:  Failed to get user token with  %d"),
                                      GetLastError()));
                            return GetLastError();
                        }
                    }

                    lpwszSidUser = GetSidString( hToken );
                    CloseHandle( hToken );

                    if ( lpwszSidUser == NULL ) {
                        DebugMsg((DM_WARNING, TEXT("GetAppliedGPOList: GetSidString failed.")));
                        return E_FAIL;
                    }

                }

                bOk = ReadGPOList( szExtension,
                                   HKEY_CURRENT_USER,
                                   HKEY_LOCAL_MACHINE,
                                   lpwszSidUser,
                                   FALSE, ppGPOList );
                if ( lpwszSidUser )
                    DeleteSidString( lpwszSidUser );

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } else {

                //
                // User represented by pSidUser
                //

                HKEY hSubKey;

                ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                         pSidUser,
                                                         (BOOLEAN)TRUE  ); // Allocate
                if ( !NT_SUCCESS(ntStatus) )
                    return E_FAIL;

                dwRet = RegOpenKeyEx ( HKEY_USERS, unicodeStr.Buffer, 0, KEY_READ, &hSubKey);

                if (dwRet != ERROR_SUCCESS) {
                    RtlFreeUnicodeString(&unicodeStr);

                    if (dwRet == ERROR_FILE_NOT_FOUND)
                        return ERROR_SUCCESS;
                    else
                        return dwRet;
                }

                bOk = ReadGPOList( szExtension,
                                   hSubKey,
                                   HKEY_LOCAL_MACHINE,
                                   bUsePerUserLocalSetting ? unicodeStr.Buffer : NULL,
                                   FALSE, ppGPOList );

                RtlFreeUnicodeString(&unicodeStr);
                RegCloseKey(hSubKey);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            }  // else if psiduser == null

        }      // else if bmachine

    } else {   // if pmachine == null

        //
        // Remote case
        //

        if ( bMachine ) {

            HKEY hKeyRemote;

            dwRet = RegConnectRegistry( pMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hKeyRemote );
            if ( dwRet != ERROR_SUCCESS )
                return dwRet;

            bOk = ReadGPOList( szExtension,
                               hKeyRemote,
                               hKeyRemote,
                               0,
                               FALSE, ppGPOList );
            RegCloseKey( hKeyRemote );

            dwRet = bOk ? ERROR_SUCCESS : E_FAIL;
            return dwRet;

        } else {

            //
            // Remote user
            //

            HKEY hKeyRemoteMach;
            BOOL bUsePerUserLocalSetting;

            if ( pSidUser == NULL )
                return ERROR_INVALID_PARAMETER;

            ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                     pSidUser,
                                                     (BOOLEAN)TRUE  ); // Allocate
            if ( !NT_SUCCESS(ntStatus) )
                return E_FAIL;

            dwRet = RegConnectRegistry( pMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hKeyRemoteMach );
            if ( dwRet != ERROR_SUCCESS ) {
                RtlFreeUnicodeString(&unicodeStr);
                return dwRet;
            }

            bUsePerUserLocalSetting = ExtensionHasPerUserLocalSetting( szExtension, hKeyRemoteMach );

            if ( bUsePerUserLocalSetting ) {

                //
                // Account for per user local settings
                //

                bOk = ReadGPOList( szExtension,
                                   hKeyRemoteMach,
                                   hKeyRemoteMach,
                                   unicodeStr.Buffer,
                                   FALSE, ppGPOList );

                RtlFreeUnicodeString(&unicodeStr);
                RegCloseKey(hKeyRemoteMach);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } else {

                HKEY hKeyRemote, hSubKeyRemote;

                RegCloseKey( hKeyRemoteMach );

                dwRet = RegConnectRegistry( pMachineName,
                                            HKEY_USERS,
                                            &hKeyRemote );
                if ( dwRet != ERROR_SUCCESS ) {
                    RtlFreeUnicodeString(&unicodeStr);
                    return dwRet;
                }

                dwRet = RegOpenKeyEx (hKeyRemote, unicodeStr.Buffer, 0, KEY_READ, &hSubKeyRemote);

                RtlFreeUnicodeString(&unicodeStr);

                if (dwRet != ERROR_SUCCESS) {
                    RegCloseKey(hKeyRemote);

                    if (dwRet == ERROR_FILE_NOT_FOUND)
                        return ERROR_SUCCESS;
                    else
                        return dwRet;
                }

                bOk = ReadGPOList( szExtension,
                                   hSubKeyRemote,
                                   hSubKeyRemote,
                                   0,
                                   FALSE, ppGPOList );

                RegCloseKey(hSubKeyRemote);
                RegCloseKey(hKeyRemote);

                return bOk ? ERROR_SUCCESS : E_FAIL;

            } // else if bUsePerUserLocalSettings

        } // else if bMachine

    }   // else if pMachName == null

    return dwRet;
}

#define FORCE_FOREGROUND_LOGGING L"ForceForegroundLogging"

#define SITENAME    L"Site-Name"
// dn defined in gpt.h
#define LOOPBACKDN  L"Loopback-Distinguished-Name"
#define SLOWLINK    L"SlowLink"
#define GPO         L"GPO-List"
#define LOOPBACK    L"Loopback-GPO-List"
#define EXTENSION   L"Extension-List"
#define GPLINKLIST  L"GPLink-List"
#define LOOPBACKGPL L"Loopback-GPLink-List"

#define GPOID       L"GPOID"
#define VERSION     L"Version"
#define SOM         L"SOM"
#define WQL         L"WQLFilterPass"
#define ACCESS      L"AccessDenied"
#define DISPLAYNAME L"DisplayName"
#define DISABLED    L"GPO-Disabled"
#define WQLID       L"WQL-Id"
#define OPTIONS     L"Options"
#define STARTTIME1  L"StartTimeLo"
#define ENDTIME1    L"EndTimeLo"
#define STARTTIME2  L"StartTimeHi"
#define ENDTIME2    L"EndTimeHi"
#define STATUS      L"Status"
#define LOGSTATUS   L"LoggingStatus"
#define ENABLED     L"Enabled"
#define NOOVERRIDE  L"NoOverride"
#define DSPATH      L"DsPath"

DWORD RegSaveGPL(   HKEY hKeyState,
                    LPSCOPEOFMGMT pSOM,
                    LPWSTR szGPLKey )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // delete the existing list of GPLs
    //
    dwError = RegDelnode( hKeyState, szGPLKey );

    if ( dwError == ERROR_SUCCESS )
    {
        HKEY    hKeyGPL;

        //
        // recreate the GPL key
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szGPLKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyGPL,
                                    0 );
        if ( dwError == ERROR_SUCCESS )
        {
            DWORD   dwGPLs = 0;

            while ( pSOM )
            {
                LPGPLINK pGPLink = pSOM->pGpLinkList;

                while ( pGPLink )
                {
                    HKEY    hKeyNumber = 0;
                    WCHAR   szNumber[32];

                    //
                    // create the number key of GPLs
                    //
                    dwError = RegCreateKeyEx(   hKeyGPL,
                                                _itow( dwGPLs, szNumber, 16 ),
                                                0,
                                                0,
                                                0,
                                                KEY_ALL_ACCESS,
                                                0,
                                                &hKeyNumber,
                                                0 );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        break;
                    }

                    //
                    // Enabled
                    //
                    dwError = RegSetValueEx(hKeyNumber,
                                            ENABLED,
                                            0,
                                            REG_DWORD,
                                            (BYTE*) &( pGPLink->bEnabled ),
                                            sizeof( pGPLink->bEnabled ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // NoOverride
                    //
                    dwError = RegSetValueEx(hKeyNumber,
                                            NOOVERRIDE,
                                            0,
                                            REG_DWORD,
                                            (BYTE*) &( pGPLink->bNoOverride ),
                                            sizeof( pGPLink->bNoOverride ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // DS PATH
                    //
                    LPWSTR szTemp = pGPLink->pwszGPO ? pGPLink->pwszGPO : L"";
                    dwError = RegSetValueEx(hKeyNumber,
                                            DSPATH,
                                            0,
                                            REG_SZ,
                                            (BYTE*) szTemp,
                                            ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    //
                    // SOM
                    //
                    szTemp = pSOM->pwszSOMId ? pSOM->pwszSOMId : L"";
                    dwError = RegSetValueEx(hKeyNumber,
                                            SOM,
                                            0,
                                            REG_SZ,
                                            (BYTE*) szTemp,
                                            ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        RegCloseKey( hKeyNumber );
                        break;
                    }

                    RegCloseKey( hKeyNumber );
                    pGPLink = pGPLink->pNext;
                    dwGPLs++;
                }

                pSOM = pSOM->pNext;
            }
            RegCloseKey( hKeyGPL );
        }
    }

    return dwError;
}

DWORD RegCompareGPLs(   HKEY hKeyState,
                        LPSCOPEOFMGMT pSOM,
                        LPWSTR szGPLKey,
                        BOOL* pbChanged )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY  hKeyGPL;

    *pbChanged = FALSE;

    //
    // open the GPL key
    //
    dwError = RegOpenKeyEx( hKeyState,
                            szGPLKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyGPL );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        return dwError;
    }

    WCHAR   szNumber[32];
    HKEY    hKeyNumber = 0;

    //
    // compare each GPL and its corr. key for changes
    //
    DWORD dwGPLs = 0;
    while ( pSOM )
    {
        LPGPLINK pGPLink = pSOM->pGpLinkList;
        WCHAR*   szBuffer;

        szBuffer = NULL;

        while ( pGPLink && dwError == ERROR_SUCCESS && !*pbChanged )
        {
            DWORD   dwType;
            DWORD   dwSize;
            DWORD   dwBuffer;
            DWORD   dwBufferSize;
            DWORD   cbMaxValueLength;

            if ( szBuffer )
            {
                LocalFree( szBuffer );
                szBuffer = NULL;
            }

            //
            // open the key corr. to the GPL
            //
            dwError = RegOpenKeyEx( hKeyGPL,
                                    _itow( dwGPLs, szNumber, 16 ),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKeyNumber );
            if ( dwError != ERROR_SUCCESS )
            {
                *pbChanged = TRUE;
                continue;
            }
            
            //
            // Determine the maximum length of data in this key
            // so we can use this to query for values
            //
            dwError = RegQueryInfoKey(
                hKeyNumber,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                &cbMaxValueLength,
                0,
                0 );

            if ( dwError != ERROR_SUCCESS )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // The string data type of the registry does not include the null terminator
            //
            dwBufferSize = ( cbMaxValueLength + sizeof( WCHAR ) );

            szBuffer = (WCHAR*) LocalAlloc(LPTR, dwBufferSize);

            if ( ! szBuffer )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // Enabled
            //
            dwType = 0;
            dwBuffer = 0;
            dwSize = sizeof( dwBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        ENABLED,
                                        0,
                                        &dwType,
                                        (BYTE*) &dwBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || dwBuffer != pGPLink->bEnabled )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // NoOverride
            //
            dwType = 0;
            dwBuffer = 0;
            dwSize = sizeof( dwBuffer );
            dwError = RegQueryValueEx(  hKeyNumber,
                                        NOOVERRIDE,
                                        0,
                                        &dwType,
                                        (BYTE*) &dwBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || dwBuffer != pGPLink->bNoOverride )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // DS PATH
            //
            LPWSTR szTemp = pGPLink->pwszGPO ? pGPLink->pwszGPO : L"";
            dwType = 0;
            szBuffer[0] = 0;
            dwSize = dwBufferSize;
            dwError = RegQueryValueEx(  hKeyNumber,
                                        DSPATH,
                                        0,
                                        &dwType,
                                        (BYTE*) szBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
            {
                *pbChanged = TRUE;
                continue;
            }

            //
            // SOM
            //
            szTemp = pSOM->pwszSOMId ? pSOM->pwszSOMId : L"";
            dwType = 0;
            szBuffer[0] = 0;
            dwSize = dwBufferSize;
            dwError = RegQueryValueEx(  hKeyNumber,
                                        SOM,
                                        0,
                                        &dwType,
                                        (BYTE*) szBuffer,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
            {
                *pbChanged = TRUE;
                continue;
            }

            RegCloseKey( hKeyNumber );
            hKeyNumber = 0;
            pGPLink = pGPLink->pNext;
            dwGPLs++;
        }

        pSOM = pSOM->pNext;

        if ( szBuffer )
        {
            LocalFree( szBuffer );
        }
    }

    if ( hKeyNumber )
    {
        RegCloseKey( hKeyNumber );
    }
    RegCloseKey( hKeyGPL );

    return dwError;
}

DWORD RegSaveGPOs(  HKEY hKeyState,
                    LPGPCONTAINER pGPOs,
                    BOOL bMachine,
                    LPWSTR szGPOKey )
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // delete the existing list of GPOs
    //
    dwError = RegDelnode( hKeyState, szGPOKey );

    if ( dwError == ERROR_SUCCESS )
    {
        HKEY    hKeyGPO;

        //
        // recreate the GPO key
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szGPOKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyGPO,
                                    0 );
        if ( dwError == ERROR_SUCCESS )
        {
            DWORD   dwGPOs = 0;

            while ( pGPOs )
            {
                HKEY    hKeyNumber = 0;
                WCHAR   szNumber[32];

                //
                // create the number key of GPOs
                //
                dwError = RegCreateKeyEx(   hKeyGPO,
                                            _itow( dwGPOs, szNumber, 16 ),
                                            0,
                                            0,
                                            0,
                                            KEY_ALL_ACCESS,
                                            0,
                                            &hKeyNumber,
                                            0 );
                if ( dwError != ERROR_SUCCESS )
                {
                    break;
                }

                //
                // version
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        VERSION,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) ( bMachine ? &pGPOs->dwMachVersion : &pGPOs->dwUserVersion ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // WQL
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        WQL,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &pGPOs->bFilterAllowed,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // Access
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        ACCESS,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &pGPOs->bAccessDenied,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // disabled
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        DISABLED,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) ( bMachine ? &pGPOs->bMachDisabled : &pGPOs->bUserDisabled ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // Options
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        OPTIONS,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &( pGPOs->dwOptions ),
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // GPO GUID
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        GPOID,
                                        0,
                                        REG_SZ,
                                        (BYTE*) pGPOs->pwszGPOName,
                                        ( wcslen( pGPOs->pwszGPOName ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // SOM
                //
                dwError = RegSetValueEx(hKeyNumber,
                                        SOM,
                                        0,
                                        REG_SZ,
                                        (BYTE*) pGPOs->szSOM,
                                        ( wcslen( pGPOs->szSOM ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                LPWSTR  szTemp;

                //
                // display name
                //
                szTemp = pGPOs->pwszDisplayName ? pGPOs->pwszDisplayName : L"";
                dwError = RegSetValueEx(hKeyNumber,
                                        DISPLAYNAME,
                                        0,
                                        REG_SZ,
                                        (BYTE*) szTemp,
                                        ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                //
                // WQL filter
                //
                szTemp = pGPOs->pwszFilterId ? pGPOs->pwszFilterId : L"";
                dwError = RegSetValueEx(hKeyNumber,
                                        WQLID,
                                        0,
                                        REG_SZ,
                                        (BYTE*) szTemp,
                                        ( wcslen( szTemp ) + 1 ) * sizeof( WCHAR ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    RegCloseKey( hKeyNumber );
                    break;
                }

                RegCloseKey( hKeyNumber );
                pGPOs = pGPOs->pNext;
                dwGPOs++;
            }

            RegCloseKey( hKeyGPO );
        }
    }

    return dwError;
}

DWORD RegCompareGPOs(   HKEY hKeyState,
                        LPGPCONTAINER pGPOs,
                        BOOL bMachine,
                        LPWSTR szGPOKey,
                        BOOL* pbChanged,
                        BOOL* pbListChanged )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY    hKeyGPO;

    *pbChanged = FALSE;
    *pbListChanged = FALSE;

    //
    // open the GPO key
    //
    dwError = RegOpenKeyEx( hKeyState,
                            szGPOKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyGPO );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        return dwError;
    }

    DWORD dwSubKeys = 0;

    //
    // get the number of sub keys
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &dwSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbChanged = TRUE;
        *pbListChanged = TRUE;
        RegCloseKey( hKeyGPO );
        return dwError;
    }

    LPGPCONTAINER pTemp = pGPOs;
    DWORD dwGPOs = 0;

    //
    // count the number of GPOs
    //
    while ( pTemp )
    {
        dwGPOs++;
        pTemp = pTemp->pNext;
    }

    //
    // the number of GPOs and the keys should match
    //
    if ( dwGPOs != dwSubKeys )
    {
        *pbChanged = TRUE;
        *pbListChanged = TRUE;
        RegCloseKey( hKeyGPO );
        return dwError;
    }

    WCHAR   szNumber[32];
    HKEY    hKeyNumber = 0;
    WCHAR*  szBuffer = NULL;

    //
    // compare each GPO and its corr. key for changes
    //
    dwGPOs = 0;

    while ( pGPOs && dwError == ERROR_SUCCESS && !*pbChanged )
    {

        DWORD   dwType;
        DWORD   dwSize;
        DWORD   dwBuffer;

        DWORD   dwBufferSize;
        DWORD   cbMaxValueLength;

        if ( szBuffer )
        {
            LocalFree( szBuffer );
            szBuffer = NULL;
        }

        //
        // open the key corr. to the GPO
        //
        dwError = RegOpenKeyEx( hKeyGPO,
                                _itow( dwGPOs, szNumber, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyNumber );
        if ( dwError != ERROR_SUCCESS )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // Determine the maximum length of data in this key
        // so we can use this to query for values
        //
        dwError = RegQueryInfoKey(
            hKeyNumber,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &cbMaxValueLength,
            0,
            0 );

        if ( dwError != ERROR_SUCCESS )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // The string data type of the registry does not include the null terminator
        //
        dwBufferSize = ( cbMaxValueLength + sizeof( WCHAR ) );

        szBuffer = (WCHAR*) LocalAlloc(LPTR, dwBufferSize);

        if ( ! szBuffer )
        {
            *pbChanged = TRUE;
            continue;
        }
        
        //
        // version
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    VERSION,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != ( bMachine ? pGPOs->dwMachVersion : pGPOs->dwUserVersion ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // WQL
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    WQL,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != pGPOs->bFilterAllowed )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // Access
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    ACCESS,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != pGPOs->bAccessDenied )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // disabled
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    DISABLED,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || (BOOL) dwBuffer != ( bMachine ? pGPOs->bMachDisabled : pGPOs->bUserDisabled ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // Options
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyNumber,
                                    OPTIONS,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != pGPOs->dwOptions )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // GPO GUID
        //
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = dwBufferSize;
        dwError = RegQueryValueEx(  hKeyNumber,
                                    GPOID,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, pGPOs->pwszGPOName ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // SOM
        //
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = dwBufferSize;
        dwError = RegQueryValueEx(  hKeyNumber,
                                    SOM,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, pGPOs->szSOM ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        LPWSTR szTemp;

        //
        // display name
        //
        szTemp = pGPOs->pwszDisplayName ? pGPOs->pwszDisplayName : L"";
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = dwBufferSize;
        dwError = RegQueryValueEx(  hKeyNumber,
                                    DISPLAYNAME,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        //
        // WQL filter
        //
        szTemp = pGPOs->pwszFilterId ? pGPOs->pwszFilterId : L"";
        dwType = 0;
        szBuffer[0] = 0;
        dwSize = dwBufferSize;
        dwError = RegQueryValueEx(  hKeyNumber,
                                    WQLID,
                                    0,
                                    &dwType,
                                    (BYTE*) szBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || _wcsicmp( szBuffer, szTemp ) )
        {
            *pbChanged = TRUE;
            continue;
        }

        RegCloseKey( hKeyNumber );
        hKeyNumber = 0;
        LocalFree( szBuffer );
        szBuffer = NULL;
        pGPOs = pGPOs->pNext;
        dwGPOs++;
    }

    if ( szBuffer )
    {
        LocalFree( szBuffer );
    }

    if ( hKeyNumber )
    {
        RegCloseKey( hKeyNumber );
    }
    RegCloseKey( hKeyGPO );

    return dwError;
}

//*************************************************************
//
//  SavePolicyState()
//
//  Purpose:    Saves enough information about the policy application
//              to determine if RSoP data needs to be re-logged
//
//   HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State
//                                                                  |- Machine
//                                                                  |      |-SiteName
//                                                                  |      |-DN
//                                                                  |      |-GPO
//                                                                  |          |-0
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |          |-1
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |            ...
//                                                                  |          |-N
//                                                                  |            |-GPOID
//                                                                  |            |-SOM
//                                                                  |            |-Version
//                                                                  |            |-WQL
//                                                                  |            |-Access
//                                                                  |-{UserSID}
//                                                                         |-SiteName
//                                                                         |-DN
//                                                                         |-GPO
//                                                                             |-0
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//                                                                             |-1
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//                                                                               ...
//                                                                             |-N
//                                                                               |-GPOID
//                                                                               |-SOM
//                                                                               |-Version
//                                                                               |-WQL
//                                                                               |-Access
//  Parameters:
//              pInfo - current state of affairs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
SavePolicyState( LPGPOINFO pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    LPWSTR szSite = pInfo->szSiteName ? pInfo->szSiteName : L"";
    LPWSTR szDN = pInfo->lpDNName ? pInfo->lpDNName : L"";
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;
    HRESULT hr = S_OK;
    XLastError  xe;

    //
    // determine the subkey to create
    //
    if ( bMachine )
    {
        hr = StringCchPrintf( szKeyState, sizeof(szKeyState)/sizeof(WCHAR), GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( szKeyState, sizeof(szKeyState)/sizeof(WCHAR), GP_STATE_KEY, pInfo->lpwszSidUser );
    }
    if (FAILED(hr)) {
        xe = dwError = HRESULT_CODE(hr);
        goto Exit;
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // reset forced logging in foreground
    //
    if ( !(pInfo->dwFlags & GP_BACKGROUND_THREAD) )
    {
        //
        // set the FORCE_FOREGROUND_LOGGING value
        //
        DWORD dwFalse = 0;
        dwError = RegSetValueEx(hKeyState,
                                FORCE_FOREGROUND_LOGGING,
                                0,
                                REG_DWORD,
                                (BYTE*) &dwFalse,
                                sizeof( DWORD ) );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    //
    // set the SITENAME value
    //
    dwError = RegSetValueEx(hKeyState,
                            SITENAME,
                            0,
                            REG_SZ,
                            (BYTE*) szSite,
                            ( wcslen( szSite ) + 1 ) * sizeof( WCHAR ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // set the DN value
    //
    dwError = RegSetValueEx(hKeyState,
                            DN,
                            0,
                            REG_SZ,
                            (BYTE*) szDN,
                            ( wcslen( szDN ) + 1 ) * sizeof( WCHAR ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // slow link
    //
    dwError = RegSetValueEx(hKeyState,
                            SLOWLINK,
                            0,
                            REG_DWORD,
                            (BYTE*) ( &bSlowLink ),
                            sizeof( DWORD ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // save the list of GPOs
    //
    dwError =  RegSaveGPOs( hKeyState, pInfo->lpGpContainerList, bMachine, GPO );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    if ( !bMachine )
    {
        //
        // save the list of Loopback GPOs
        //
        dwError =  RegSaveGPOs( hKeyState, pInfo->lpLoopbackGpContainerList, bMachine, LOOPBACK );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    //
    // save the list of GPLinks
    //
    dwError = RegSaveGPL( hKeyState, pInfo->lpSOMList, GPLINKLIST );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    if ( !bMachine )
    {
        //
        // save the list of Loopback GPLinks
        //
        dwError =  RegSaveGPL( hKeyState, pInfo->lpLoopbackSOMList, LOOPBACKGPL );
    }

Exit:
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SavePolicyState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  SaveLinkState()
//
//  Purpose:    Saves link speed information for the policy application
//
//  Parameters:
//              pInfo - current state of affairs
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
SaveLinkState( LPGPOINFO pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;
    HRESULT hr = S_OK;
    XLastError  xe;

    //
    // determine the subkey to create
    //
    if ( bMachine )
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, pInfo->lpwszSidUser );
    }
    if (FAILED(hr)) 
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // slow link
        //
        dwError = RegSetValueEx(hKeyState,
                                SLOWLINK,
                                0,
                                REG_DWORD,
                                (BYTE*) ( &bSlowLink ),
                                sizeof( DWORD ) );

        RegCloseKey( hKeyState );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLinkState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  ComparePolicyState()
//
//  Purpose:    Compares the policy state saved in the registry
//              with the state in LPGPOINFO
//
//  Parameters:
//              pInfo       - current state of affairs
//              pbLinkChanged   - has the link speed changed?
//              pbStateChanged   - has the state changed?
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
ComparePolicyState( LPGPOINFO pInfo, BOOL* pbLinkChanged, BOOL* pbStateChanged, BOOL *pbNoState )
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (pInfo->dwFlags & GP_MACHINE) != 0;
    HKEY    hKeyState = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    DWORD   dwBuffer;
    BOOL    bSlowLink = (pInfo->dwFlags & GP_SLOW_LINK) != 0;
    BOOL    bListChanged = FALSE;
    WCHAR*  wszBuffer;
    HRESULT hr = S_OK;
    XLastError  xe;

    *pbStateChanged = FALSE;
    *pbLinkChanged = FALSE;
    *pbNoState = FALSE;
    wszBuffer = NULL;

    //
    // determine the subkey to open
    //
    if ( bMachine )
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, pInfo->lpwszSidUser );
    }
    if (FAILED(hr)) 
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        *pbStateChanged = TRUE;
        *pbNoState = TRUE;
        if (dwError == ERROR_FILE_NOT_FOUND) {
            return ERROR_SUCCESS;
        }
        else {
            goto Exit;
        }
    }

    DWORD   dwBufferSize;
    DWORD   dwType;
    DWORD   dwSize;

    //
    // Determine the maximum length of data in this key
    // so we can use this to query for values
    //
    dwError = RegQueryInfoKey(
        hKeyState,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        &dwBufferSize,
        0,
        0 );

    if ( dwError != ERROR_SUCCESS )
    {
        *pbStateChanged = TRUE;
        goto Exit;
    }

    //
    // The string data type of the registry does not include the null terminator
    //
    dwBufferSize += sizeof( WCHAR );

    wszBuffer = (WCHAR*) LocalAlloc(LPTR, dwBufferSize);

    if ( ! wszBuffer )
    {
        *pbStateChanged = TRUE;
        goto Exit;
    }

    //
    // check for forced logging in foreground
    //
    if ( !(pInfo->dwFlags & GP_BACKGROUND_THREAD) )
    {
        //
        // get the FORCE_FOREGROUND_LOGGING value
        //
        dwType = 0;
        dwBuffer = 0;
        dwSize = sizeof( dwBuffer );
        dwError = RegQueryValueEx(  hKeyState,
                                    FORCE_FOREGROUND_LOGGING,
                                    0,
                                    &dwType,
                                    (BYTE*) &dwBuffer,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS || dwBuffer != FALSE )
        {
            *pbStateChanged = TRUE;
            goto Exit;
        }
    }

    //
    // get the SITENAME value
    //
    dwSize = dwBufferSize;
    dwType = 0;
    dwError = RegQueryValueEx(  hKeyState,
                                SITENAME,
                                0,
                                &dwType,
                                (BYTE*) wszBuffer,
                                &dwSize );
    if ( dwError == ERROR_SUCCESS )
    {
        LPWSTR szSite = pInfo->szSiteName ? pInfo->szSiteName : L"";

        if ( _wcsicmp( wszBuffer, szSite ) )
        {
            *pbStateChanged = TRUE;
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // get the DN value
    //
    dwSize = dwBufferSize;
    dwType = 0;
    dwError = RegQueryValueEx(  hKeyState,
                                DN,
                                0,
                                &dwType,
                                (BYTE*) wszBuffer,
                                &dwSize );
    if ( dwError == ERROR_SUCCESS )
    {
        LPWSTR szDN = pInfo->lpDNName ? pInfo->lpDNName : L"";

        if ( _wcsicmp( wszBuffer, szDN ) )
        {
            *pbStateChanged = TRUE;
            //
            // set forced logging in foreground
            //
            if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) )
            {
                //
                // set the FORCE_FOREGROUND_LOGGING value
                //
                DWORD dwTrue = TRUE;
                dwError = RegSetValueEx(hKeyState,
                                        FORCE_FOREGROUND_LOGGING,
                                        0,
                                        REG_DWORD,
                                        (BYTE*) &dwTrue,
                                        sizeof( DWORD ) );
                if ( dwError != ERROR_SUCCESS )
                {
                    goto Exit;
                }
            }
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // slow link
    //
    dwType = 0;
    dwBuffer = 0;
    dwSize = sizeof( dwBuffer );
    dwError = RegQueryValueEx(  hKeyState,
                                SLOWLINK,
                                0,
                                &dwType,
                                (BYTE*) &dwBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS || dwBuffer != (DWORD)bSlowLink )
    {
        *pbLinkChanged = TRUE;
    }

    //
    // has the list of GPOs or the GPOs changed
    //
    dwError = RegCompareGPOs(   hKeyState,
                                pInfo->lpGpContainerList,
                                bMachine,
                                GPO,
                                pbStateChanged,
                                &bListChanged );
    //
    // set forced logging in foreground
    //
    if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) && bListChanged )
    {
        //
        // set the FORCE_FOREGROUND_LOGGING value
        //
        DWORD dwTrue = TRUE;
        dwError = RegSetValueEx(hKeyState,
                                FORCE_FOREGROUND_LOGGING,
                                0,
                                REG_DWORD,
                                (BYTE*) &dwTrue,
                                sizeof( DWORD ) );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Exit;
        }
    }

    if ( dwError == ERROR_SUCCESS && !*pbStateChanged && !bMachine )
    {
        //
        // has the list of loopback GPOs or the GPOs changed
        //
        dwError = RegCompareGPOs(   hKeyState,
                                    pInfo->lpLoopbackGpContainerList,
                                    bMachine,
                                    LOOPBACK,
                                    pbStateChanged,
                                    &bListChanged );
        //
        // set forced logging in foreground
        //
        if ( (pInfo->dwFlags & GP_BACKGROUND_THREAD) && bListChanged )
        {
            //
            // set the FORCE_FOREGROUND_LOGGING value
            //
            DWORD dwTrue = TRUE;
            dwError = RegSetValueEx(hKeyState,
                                    FORCE_FOREGROUND_LOGGING,
                                    0,
                                    REG_DWORD,
                                    (BYTE*) &dwTrue,
                                    sizeof( DWORD ) );
            if ( dwError != ERROR_SUCCESS )
            {
                goto Exit;
            }
        }
    }

    if ( dwError == ERROR_SUCCESS && !*pbStateChanged )
    {
        dwError = RegCompareGPLs(   hKeyState,
                                    pInfo->lpSOMList,
                                    GPLINKLIST,
                                    pbStateChanged );

        if ( dwError == ERROR_SUCCESS && !*pbStateChanged && !bMachine)
        {
            dwError = RegCompareGPLs(   hKeyState,
                                        pInfo->lpLoopbackSOMList,
                                        LOOPBACKGPL,
                                        pbStateChanged );
        }

        if (*pbStateChanged)
        {
            DebugMsg( ( DM_VERBOSE, L"ComparePolicyState: Links have changed") );
        }
    }

Exit:
    if ( wszBuffer )
    {
        LocalFree( wszBuffer );
    }
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }
    if ( dwError != ERROR_SUCCESS )
    {
        *pbStateChanged = TRUE;
        DebugMsg( ( DM_WARNING, L"ComparePolicyState: Failed Registry operation with %d", dwError ) );
    }

    return dwError;
}

//*************************************************************
//
//  DeletePolicyState()
//
//  Purpose:    deletes the policy state saved in the registry
//
//  Parameters:
//              szSID       - user SID or 0 for machine
//
//  Returns:    Win32 error code
//
//*************************************************************

DWORD
DeletePolicyState( LPCWSTR   szSid )
{
    DWORD   dwError = ERROR_SUCCESS;
    HKEY    hKeyState = 0;
    LPWSTR  szState = L"Machine";

    if ( szSid && *szSid )
    {
        szState = (LPWSTR) szSid;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            GP_STATE_ROOT_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError == ERROR_SUCCESS )
    {
        dwError = RegDelnode( hKeyState, (LPWSTR) szState );

        RegCloseKey( hKeyState );
    }

    return dwError;
}

//*************************************************************
//
//  SaveLoggingStatus()
//
//  Purpose:    Saving the extension status into the registry
//
//  Parameters:
//              szSid           - Null for machine, otherwise the user sid
//              lpExt           - Extension info (null for GP Engine itself)
//              lpRsopExtStatus - A pointer to the RsopExtStatus corresponding
//                                to this extension
//
//  Returns:    Win32 error code
//
//*************************************************************


DWORD SaveLoggingStatus(LPWSTR szSid, LPGPEXT lpExt, RSOPEXTSTATUS *lpRsopExtStatus)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (szSid == 0);
    HKEY    hKeyState = 0, hKeyExtState = 0, hKeyExt = 0;
    WCHAR   szKeyState[MAX_PATH+1];
    LPWSTR  lpExtId;
    HRESULT hr = S_OK;
    XLastError  xe;

    if ( bMachine )
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( szKeyState, ARRAYSIZE(szKeyState), GP_STATE_KEY, szSid );
    }
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                szKeyState,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyState,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create state key with %d", dwError ) );
        goto Exit;
    }

    dwError = RegCreateKeyEx(   hKeyState,
                                EXTENSION,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyExtState,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create extension key with %d", dwError ) );
        goto Exit;
    }


    lpExtId = lpExt ? lpExt->lpKeyName : GPCORE_GUID;

    dwError = RegCreateKeyEx(   hKeyExtState,
                                lpExtId,
                                0,
                                0,
                                0,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyExt,
                                0 );

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to create CSE key with %d", dwError ) );
        goto Exit;
    }


    dwError = RegSetValueEx(hKeyExt, STARTTIME1, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwLowDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, STARTTIME2, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwHighDateTime)),
                            sizeof(DWORD));
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STARTTIME2 with %d", dwError ) );
        goto Exit;
    }
    
    dwError = RegSetValueEx(hKeyExt, ENDTIME1, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwLowDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set ENDTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, ENDTIME2, 0, REG_DWORD, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwHighDateTime)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set ENDTIME2 with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, STATUS, 0, REG_DWORD, 
                            (BYTE *)(&(lpRsopExtStatus->dwStatus)),
                            sizeof(DWORD));
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set STATUS with %d", dwError ) );
        goto Exit;
    }

    dwError = RegSetValueEx(hKeyExt, LOGSTATUS, 0, REG_DWORD, 
                            (BYTE *)(&(lpRsopExtStatus->dwLoggingStatus)),
                            sizeof(DWORD));
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"SaveLoggingStatus: Failed to set LOGSTATUS with %d", dwError ) );
        goto Exit;
    }


Exit:
    
    if (hKeyExt) 
        RegCloseKey(hKeyExt);


    if (hKeyExtState) 
        RegCloseKey(hKeyExtState);


    if (hKeyState) 
        RegCloseKey(hKeyState);

    return dwError;

}

//*************************************************************
//
//  ReadLoggingStatus()
//
//  Purpose:    Read the extension status into the registry
//
//  Parameters:
//              szSid           - Null for machine, otherwise the user sid
//              szExtId         - Extension info (null for GP Engine itself)
//              lpRsopExtStatus - A pointer to the RsopExtStatus (that will be filled up)
//
//  Returns:    Win32 error code
//
//
//*************************************************************

DWORD ReadLoggingStatus(LPWSTR szSid, LPWSTR szExtId, RSOPEXTSTATUS *lpRsopExtStatus)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = (szSid == 0);
    HKEY    hKeyExt = 0;
    WCHAR   szKeyStateExt[MAX_PATH+1];
    LPWSTR  lpExtId;
    DWORD   dwType, dwSize;
    HRESULT hr = S_OK;
    XLastError  xe;

    if ( bMachine )
    {
        hr = StringCchPrintf( szKeyStateExt, ARRAYSIZE(szKeyStateExt), GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( szKeyStateExt, ARRAYSIZE(szKeyStateExt), GP_STATE_KEY, szSid );
    }
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    CheckSlash(szKeyStateExt);
    
    hr = StringCchCat(szKeyStateExt, ARRAYSIZE(szKeyStateExt), EXTENSION);
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    CheckSlash(szKeyStateExt);
    
    lpExtId = szExtId ? szExtId : GPCORE_GUID;    
    
    hr = StringCchCat(szKeyStateExt, ARRAYSIZE(szKeyStateExt), lpExtId);
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    // from this point on, go to exit.
    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                szKeyStateExt,
                                0,
                                KEY_READ,
                                &hKeyExt);

    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to create state key with %d", dwError ) );
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STARTTIME1, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwLowDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STARTTIME2, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftStartTime).dwHighDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STARTTIME1 with %d", dwError ) );
        goto Exit;
    }
    
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, ENDTIME1, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwLowDateTime)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set ENDTIME1 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, ENDTIME2, 0, &dwType, 
                            (BYTE *)(&((lpRsopExtStatus->ftEndTime).dwHighDateTime)),
                            &dwSize);
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set ENDTIME2 with %d", dwError ) );
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, STATUS, 0, &dwType, 
                            (BYTE *)(&(lpRsopExtStatus->dwStatus)),
                            &dwSize);
                            
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set STATUS with %d", dwError ) );
        goto Exit;
    }


    dwSize = sizeof(DWORD);
    dwError = RegQueryValueEx(hKeyExt, LOGSTATUS, 0, &dwType, 
                            (BYTE *)(&(lpRsopExtStatus->dwLoggingStatus)),
                            &dwSize);
                            
    if ( dwError != ERROR_SUCCESS )
    {
        DebugMsg( ( DM_WARNING, L"ReadLoggingStatus: Failed to set LOGSTATUS with %d", dwError ) );
        goto Exit;
    }


Exit:
    
    if (hKeyExt) 
        RegCloseKey(hKeyExt);

    return dwError;

}

#define POLICY_KEY          L"Software\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\winlogon"
#define PREFERENCE_KEY      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon"
#define GP_SYNCFGREFRESH    L"SyncForegroundPolicy"

BOOL WINAPI
GetFgPolicySetting( HKEY hKeyRoot )
{
    HKEY    hKeyPolicy = 0;
    HKEY    hKeyPreference = 0;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof( DWORD );
    BOOL    bSync = FALSE;
    
    //
    // async only on Pro
    //
    OSVERSIONINFOEXW version;
    version.dwOSVersionInfoSize = sizeof(version);
    if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
    {
        //
        // conservatively assume non Pro SKU
        //
        return TRUE;
    }
    else
    {
        if ( version.wProductType != VER_NT_WORKSTATION )
        {
            //
            // force sync refresh on non Pro SKU
            //
            return TRUE;
        }
    }

    dwError = RegOpenKeyEx( hKeyRoot,
                            PREFERENCE_KEY,
                            0,
                            KEY_READ,
                            &hKeyPreference );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // read the preference value
        //
        RegQueryValueEx(hKeyPreference,
                        GP_SYNCFGREFRESH,
                        0,
                        &dwType,
                        (LPBYTE) &bSync,
                        &dwSize );
        RegCloseKey( hKeyPreference );
    }

    dwError = RegOpenKeyEx( hKeyRoot,
                            POLICY_KEY,
                            0,
                            KEY_READ,
                            &hKeyPolicy );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // read the policy
        //
        RegQueryValueEx(hKeyPolicy,
                        GP_SYNCFGREFRESH,
                        0,
                        &dwType,
                        (LPBYTE) &bSync,
                        &dwSize );
        RegCloseKey( hKeyPolicy );
    }

    return bSync;
}

#define PREVREFRESHMODE     L"PrevRefreshMode"
#define NEXTREFRESHMODE     L"NextRefreshMode"
#define PREVREFRESHREASON   L"PrevRefreshReason"
#define NEXTREFRESHREASON   L"NextRefreshReason"

#define STATE_KEY           L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State\\"

DWORD WINAPI
gpGetFgPolicyRefreshInfo(BOOL bPrev,
                              LPWSTR szUserSid,
                              LPFgPolicyRefreshInfo pInfo )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szKeyState[MAX_PATH+1] = STATE_KEY;
    HKEY    hKeyState = 0;
    DWORD   dwType;
    DWORD   dwSize;
    HRESULT hr  = S_OK;
    XLastError  xe;

    if ( !pInfo )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    pInfo->mode = GP_ModeUnknown;
    pInfo->reason = GP_ReasonUnknown;

    //
    // determine the subkey to create
    //
    if ( !szUserSid )
    {
        hr = StringCchCat( szKeyState, ARRAYSIZE(szKeyState), L"Machine" );
    }
    else
    {
        hr = StringCchCat( szKeyState, ARRAYSIZE(szKeyState), szUserSid );
    }
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_READ,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh mode
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegQueryValueEx(  hKeyState,
                                bPrev ? PREVREFRESHMODE : NEXTREFRESHMODE ,
                                0,
                                &dwType,
                                (LPBYTE) &pInfo->mode,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh reason
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegQueryValueEx(  hKeyState,
                                bPrev ? PREVREFRESHREASON : NEXTREFRESHREASON ,
                                0,
                                &dwType,
                                (LPBYTE) &pInfo->reason,
                                &dwSize );

Exit:
    //
    // cleanup
    //
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }

    //
    // assume first logon/startup
    //
    if ( dwError == ERROR_FILE_NOT_FOUND )
    {
        pInfo->mode = GP_ModeSyncForeground;
        pInfo->reason = GP_ReasonFirstPolicy;
        dwError = ERROR_SUCCESS;
    }

    return dwError;
}

LPWSTR g_szModes[] = 
{
    L"Unknown",
    L"Synchronous",
    L"Asynchronous",
};

LPWSTR g_szReasons[] = 
{
    L"NoNeedForSync",
    L"FirstPolicyRefresh",
    L"CSERequiresForeground",
    L"CSEReturnedError",
    L"ForcedSyncRefresh",
    L"SyncPolicy",
    L"NonCachedCredentials",
    L"SKU",
};

DWORD WINAPI
gpSetFgPolicyRefreshInfo(BOOL bPrev,
                              LPWSTR szUserSid,
                              FgPolicyRefreshInfo info )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szKeyState[MAX_PATH+1] = STATE_KEY;
    HKEY    hKeyState = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof( DWORD );
    HRESULT hr = S_OK;
    XLastError  xe;

    //
    // determine the subkey to create
    //
    if ( !szUserSid )
    {
        hr = StringCchCat( szKeyState, ARRAYSIZE(szKeyState), L"Machine" );
    }
    else
    {
        hr = StringCchCat( szKeyState, ARRAYSIZE(szKeyState), szUserSid );
    }
    if (FAILED(hr))
    {
        xe = dwError = HRESULT_CODE(hr);
        return dwError;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szKeyState,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh mode
    //
    dwError = RegSetValueEx(hKeyState,
                            bPrev ? PREVREFRESHMODE : NEXTREFRESHMODE ,
                            0,
                            REG_DWORD,
                            (LPBYTE) &info.mode,
                            sizeof( DWORD ) );
    if ( dwError != ERROR_SUCCESS )
    {
        goto Exit;
    }

    //
    // refresh reason
    //
    dwType = REG_DWORD;
    dwSize = sizeof( DWORD );
    dwError = RegSetValueEx(hKeyState,
                            bPrev ? PREVREFRESHREASON : NEXTREFRESHREASON ,
                            0,
                            REG_DWORD,
                            (LPBYTE) &info.reason,
                            sizeof( DWORD ) );

Exit:
    //
    // cleanup
    //
    if ( hKeyState )
    {
        RegCloseKey( hKeyState );
    }

    if ( dwError == ERROR_SUCCESS )
    {
        DebugMsg( ( DM_VERBOSE,
                    L"SetFgRefreshInfo: %s %s Fg policy %s, Reason: %s.",
                    bPrev ? L"Previous" : L"Next",
                    szUserSid ? L"User" : L"Machine",
                    g_szModes[info.mode % ARRAYSIZE( g_szModes )],
                    g_szReasons[info.reason % ARRAYSIZE( g_szReasons )] ) );
    }
    
    return dwError;
}

USERENVAPI
DWORD
WINAPI
GetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo )

{
    return gpGetFgPolicyRefreshInfo( TRUE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
GetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo* pInfo )
{
    return gpGetFgPolicyRefreshInfo( FALSE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
GetCurrentFgPolicyRefreshInfo(  LPWSTR szUserSid,
                                      FgPolicyRefreshInfo* pInfo )
{
    return gpGetFgPolicyRefreshInfo( FALSE, szUserSid, pInfo );
}

USERENVAPI
DWORD
WINAPI
SetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                      FgPolicyRefreshInfo info )

{
    return gpSetFgPolicyRefreshInfo( TRUE, szUserSid, info );
}

USERENVAPI
DWORD
WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                                 FgPolicyRefreshInfo info )
{
    return gpSetFgPolicyRefreshInfo( FALSE, szUserSid, info );
}

USERENVAPI
DWORD
WINAPI
ForceSyncFgPolicy( LPWSTR szUserSid )
{
    FgPolicyRefreshInfo info = { GP_ReasonSyncForced, GP_ModeSyncForeground };
    return gpSetFgPolicyRefreshInfo( FALSE, szUserSid, info );
}

USERENVAPI
BOOL
WINAPI
IsSyncForegroundPolicyRefresh(   BOOL bMachine,
                                        HANDLE hToken )
{
    BOOL    bSyncRefresh;
    DWORD   dwError = ERROR_SUCCESS;

    bSyncRefresh = GetFgPolicySetting( HKEY_LOCAL_MACHINE );
    if ( bSyncRefresh )
    {
        //
        // policy sez sync
        //
        DebugMsg( ( DM_VERBOSE, L"IsSyncForegroundPolicyRefresh: Synchronous, Reason: policy set to SYNC" ) );

        return TRUE;
    }

    LPWSTR szSid = !bMachine ? GetSidString( hToken ) : 0;
    FgPolicyRefreshInfo info;
    
    dwError = GetCurrentFgPolicyRefreshInfo( szSid, &info );

    if ( szSid )
    {
        DeleteSidString( szSid );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        //
        // error reading the refresh mode, treat as sync
        //
        DebugMsg( ( DM_VERBOSE, L"IsSyncForegroundPolicyRefresh: Synchronous, Reason: Error 0x%x ", dwError ) );

        return TRUE;
    }

    bSyncRefresh = ( info.mode == GP_ModeAsyncForeground ) ? FALSE : TRUE;

    DebugMsg( ( DM_VERBOSE,
                L"IsSyncForegroundPolicyRefresh: %s, Reason: %s",
                g_szModes[info.mode % ARRAYSIZE( g_szModes )],
                g_szReasons[info.reason % ARRAYSIZE( g_szReasons )] ) );

    return bSyncRefresh;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\gpt.h ===
//*************************************************************
//
//  Group Policy Processing
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997-1998
//  All rights reserved
//
//  History:    28-Oct-98   SitaramR    Created
//
//*************************************************************


#ifdef __cplusplus
extern "C" {
#endif

void InitializeGPOCriticalSection();
void CloseGPOCriticalSection();
BOOL InitializePolicyProcessing(BOOL bMachine);

#define ECP_FAIL_ON_WAIT_TIMEOUT        1
#define ECP_REGISTRY_ONLY               2

HANDLE WINAPI EnterCriticalPolicySectionEx (BOOL bMachine, DWORD dwTimeOut, DWORD dwFlags );

#ifdef __cplusplus
}
#endif

//
// These keys are used in gpt.c. The per user per machine keys will
// be deleted when profile gets deleted. Changes in the following keys
// should be reflected in the prefixes as well...
//

#define GP_SHADOW_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\Shadow\\%ws")
#define GP_HISTORY_KEY        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\\%ws")
#define GP_STATE_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State\\%ws")
#define GP_STATE_ROOT_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State")
#define DN                    TEXT("Distinguished-Name")        // used elsewhere to get the som

#define GP_SHADOW_SID_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\Shadow\\%ws")
#define GP_HISTORY_SID_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History\\%ws")

#define GP_EXTENSIONS_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\%ws")
#define GP_EXTENSIONS_SID_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws\\GPExtensions\\%ws")

#define GP_HISTORY_SID_ROOT_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\History")
#define GP_MEMBERSHIP_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws\\GroupMembership")
#define GP_EXTENSIONS_SID_ROOT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws\\GPExtensions")

#define GP_POLICY_SID_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\%ws")
#define GP_LOGON_SID_KEY      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\%ws")

#define GPCORE_GUID           TEXT("{00000000-0000-0000-0000-000000000000}")


//
// Comon prefix for both history and shadow
//

#define GP_XXX_SID_PREFIX           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy")
#define GP_EXTENSIONS_SID_PREFIX    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")



//
// Structures
//

//
// Structure used to represent GP status from the previous policy run.
//

typedef struct _GPEXTSTATUS {
   DWORD          dwSlowLink;               // Slow link when policy applied previously ?
   DWORD          dwRsopLogging;            // Rsop Logging when policy applied previously ?
   DWORD          dwStatus;                 // Status returned previously
   HRESULT        dwRsopStatus;             // Rsop Status returned previously
   DWORD          dwTime;                   // Time when the policy was applied previously
   BOOL           bStatus;                  // If we failed to read the per ext status data
   BOOL           bForceRefresh;            // force refresh in this foreground prcessing..
} GPEXTSTATUS, *LPGPEXTSTATUS;


typedef struct _GPEXT {
    LPTSTR         lpDisplayName;            // Display name
    LPTSTR         lpKeyName;                // Extension name
    LPTSTR         lpDllName;                // Dll name
    LPSTR          lpFunctionName;           // Entry point name
    LPSTR          lpRsopFunctionName;       // Rsop entry point name
    HMODULE        hInstance;                // Handle to dll
    PFNPROCESSGROUPPOLICY   pEntryPoint;     // Entry point for ProcessGPO
    PFNPROCESSGROUPPOLICYEX pEntryPointEx;   // Diagnostic mode or Ex entry point
    PFNGENERATEGROUPPOLICY pRsopEntryPoint;  // Entry point for Rsop planning mode
    BOOL           bNewInterface;            // Are we using the new Ex entry point interface ?
    DWORD          dwNoMachPolicy;           // Mach policy setting
    DWORD          dwNoUserPolicy;           // User policy setting
    DWORD          dwNoSlowLink;             // Slow link setting
    DWORD          dwNoBackgroundPolicy;     // Background policy setting
    DWORD          dwNoGPOChanges;           // GPO changes setting
    DWORD          dwUserLocalSetting;       // Per user per machine setting
    DWORD          dwRequireRegistry;        // RequireSuccReg setting
    DWORD          dwEnableAsynch;           // Enable asynchronous processing setting
    DWORD          dwLinkTransition;         // Link speed transition setting
    DWORD          dwMaxChangesInterval;     // Max interval (mins) for which NoGpoChanges is adhered to
    BOOL           bRegistryExt;             // Is this the psuedo reg extension ?
    BOOL           bSkipped;                 // Should processing be skipped for this extension ?
    BOOL           bHistoryProcessing;       // Is processing needed to clean up cached Gpos ?
    BOOL           bForcedRefreshNextFG;     // Forced refresh next time it is processed in foreground.
    BOOL           bRsopTransition;          // Rsop Transition ?
    GUID           guid;                     // Guid of extension
    LPGPEXTSTATUS  lpPrevStatus;             // Previous Status
    LPTSTR         szEventLogSources;        // "(userenv,Application)\0(print,System)\0....\0"
    struct _GPEXT *pNext;                    // Singly linked list pointer
} GPEXT, *LPGPEXT;


typedef struct _GPOPROCDATA {                // Data that is needed while processing the data
    BOOL        bProcessGPO;                 // Actually add the GPOs to the processing list
    PLDAP       pLdapHandle;                 // LDAP handle corresponding to the query
} GPOPROCDATA, *LPGPOPROCDATA;


typedef struct _EXTLIST {
    GUID             guid;                   // Extension guid
    struct _EXTLIST *pNext;                  // Singly linked list pointer
} EXTLIST, *LPEXTLIST;



typedef struct _EXTFILTERLIST {
    PGROUP_POLICY_OBJECT   lpGPO;            // GPO
    LPEXTLIST              lpExtList;        // List of extension guids that apply to lpGPO
    BOOL                   bLogged;          // Is this link logged to RSoP db ?
    struct _EXTFILTERLIST *pNext;            // Singly linked list pointer
} EXTFILTERLIST, *LPEXTFILTERLIST;


typedef struct _GPLINK {
    LPWSTR                   pwszGPO;             // DS path to Gpo
    BOOL                     bEnabled;            // Is this link disabled ?
    BOOL                     bNoOverride;         // Is Gpo enforced ?
    struct _GPLINK          *pNext;               // Gpo linked in SOM order
} GPLINK, *LPGPLINK;


typedef struct _SCOPEOFMGMT {
    LPWSTR                   pwszSOMId;            // Dn name of SOM
    DWORD                    dwType;               // Type of SOM
    BOOL                     bBlocking;            // Does SOM have policies blocked from above ?
    BOOL                     bBlocked;             // This SOM is blocked by a SOM below ?
    LPGPLINK                 pGpLinkList;          // List of GPOs linked to this SOM
    struct _SCOPEOFMGMT     *pNext;
} SCOPEOFMGMT, *LPSCOPEOFMGMT;


typedef struct _GPCONTAINER {
    LPWSTR                   pwszDSPath;           // DS path to Gpo
    LPWSTR                   pwszGPOName;          // Guid from of Gpo name
    LPWSTR                   pwszDisplayName;      // Friendly name
    LPWSTR                   pwszFileSysPath;      // Sysvol path to Gpo
    BOOL                     bFound;               // Gpo found ?
    BOOL                     bAccessDenied;        // Access denied ?
    BOOL                     bUserDisabled;        // Disabled for user policy ?
    BOOL                     bMachDisabled;        // Disabled for machine policy ?
    DWORD                    dwUserVersion;        // Version # for user policy
    DWORD                    dwMachVersion;        // Version # for machine policy
    PSECURITY_DESCRIPTOR     pSD;                  // ACL on Gpo
    DWORD                    cbSDLen;              // Length of security descriptor in bytes
    BOOL                     bFilterAllowed;       // Does Gpo pass filter check ?
    WCHAR                   *pwszFilterId;         // Filter id
    LPWSTR                   szSOM;                // SOM that this GPO is linked to
    DWORD                    dwOptions;            // GPO options
    struct _GPCONTAINER     *pNext;                // Linked list ptr
} GPCONTAINER, *LPGPCONTAINER;


typedef struct _GPOINFO {
    DWORD                    dwFlags;
    INT                      iMachineRole;
    HANDLE                   hToken;
    PRSOPTOKEN               pRsopToken;
    WCHAR *                  lpDNName;
    HANDLE                   hEvent;
    HKEY                     hKeyRoot;
    BOOL                     bXferToExtList;     // Has the ownership been transferred from lpGPOList to lpExtFilterList ?
    LPEXTFILTERLIST          lpExtFilterList;    // List of extensions to be filtered, cardinality is same as GetGPOList's list
    PGROUP_POLICY_OBJECT     lpGPOList;          // Filtered GPO List, can vary from one extension to next
    LPTSTR                   lpwszSidUser;       // Sid of user in string form
    HANDLE                   hTriggerEvent;
    HANDLE                   hForceTriggerEvent; // force trigger event
    HANDLE                   hNotifyEvent;
    HANDLE                   hNeedFGEvent;
    HANDLE                   hDoneEvent;
    HANDLE                   hCritSection;
    LPGPEXT                  lpExtensions;
    BOOL                     bMemChanged;          // Has security group membership has changed ?
    BOOL                     bUserLocalMemChanged; // Has membership changed on per user local basis ?
    BOOL                     bSidChanged;          // Has the Sid changed since the last policy run?
    PFNSTATUSMESSAGECALLBACK pStatusCallback;
    LPSCOPEOFMGMT            lpSOMList;            // LSDOU list
    LPGPCONTAINER            lpGpContainerList;    // GP container list for Rsop logging
    LPSCOPEOFMGMT            lpLoopbackSOMList;    // Loopback LSDOU list
    LPGPCONTAINER            lpLoopbackGpContainerList;    // Loopback container list for Rsop logging
    BOOL                     bFGCoInitialized;     // CoInitialize called on foreground thread ?
    BOOL                     bBGCoInitialized;     // CoInitialize called on background thread ?
    IWbemServices *          pWbemServices;        // Namespace pointer for Rsop logging
    LPTSTR                   szName;               // Full Name of the User/Computer
    LPTSTR                   szTargetName;         // Rsop TargetName
    BOOL                     bRsopLogging;         // Is Rsop Logging turned on ?
    BOOL                     bRsopCreated;         // Rsop Name Space was created now ?
    LPWSTR                   szSiteName;           // site name of the target
} GPOINFO, *LPGPOINFO;


typedef struct _ADMFILEINFO {
    WCHAR *               pwszFile;            // Adm file path
    WCHAR *               pwszGPO;             // Gpo that the adm file is in
    FILETIME              ftWrite;             // Last write time of Adm file
    struct _ADMFILEINFO * pNext;               // Singly linked list pointer
} ADMFILEINFO;


typedef struct _RSOPSESSIONDATA {
    WCHAR *               pwszTargetName;               // Target user or computer
    WCHAR *               pwszSOM;                      // New group of target
    PTOKEN_GROUPS         pSecurityGroups;              // Security IDs of the new groups for target
    BOOL                  bLogSecurityGroup;            // Log the security groups
    WCHAR *               pwszSite;                     // Site of target
    BOOL                  bMachine;                     // Machine or user policy processing ?
    BOOL                  bSlowLink;                    // policy applied over slow link?
    DWORD                 dwFlags;
} RSOPSESSIONDATA, *LPRSOPSESSIONDATA;


typedef struct _RSOPEXTSTATUS {
    FILETIME              ftStartTime;                  // times between which the associated
    FILETIME              ftEndTime;                    // extension was processed
    DWORD                 dwStatus;                     // Processing status
    DWORD                 dwLoggingStatus;              // Logging Status
    BOOL                  bValid;                       // this struct is valid and can be used              
} RSOPEXTSTATUS, *LPRSOPEXTSTATUS;
                          


BOOL RsopDeleteUserNameSpace(LPTSTR szComputer, LPTSTR lpSid);

DWORD SaveLoggingStatus(LPWSTR szSid, LPGPEXT lpExt, RSOPEXTSTATUS *lpRsopExtStatus);
DWORD ReadLoggingStatus(LPWSTR szSid, LPWSTR szExtId, RSOPEXTSTATUS *lpRsopExtStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\policy.c ===
//*************************************************************
//
//  Functions to apply policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <regstr.h>
#include <winnetwk.h>
#include <lm.h>
#include <strsafe.h>
//
// Update mode constants
//

#define UM_OFF                  0
#define UM_AUTOMATIC            1
#define UM_MANUAL               2


//
// Prefix constants for value names
//

#define NUM_PREFIX              3
#define PREFIX_UNKNOWN          0
#define PREFIX_DELETE           1
#define PREFIX_SOFT             2
#define PREFIX_DELVALS          3


//
// Max size of a value's data
//

#define MAX_VALUE_DATA       4096

//
// Default group size
//

#define DEFAULT_GROUP_SIZE   8192


//
// Registry value names
//

TCHAR g_szUpdateModeValue[] = TEXT("UpdateMode");
TCHAR g_szNetPathValue[] = TEXT("NetworkPath");
TCHAR g_szLogonKey[] = WINLOGON_KEY;
CHAR  g_szPolicyHandler[] = "PolicyHandler";  // This needs to be ANSI
TCHAR g_szTmpKeyName[] = TEXT("AdminConfigData");
TCHAR g_szPrefixDel[] = TEXT("**del.");
TCHAR g_szPrefixSoft[] = TEXT("**soft.");
TCHAR g_szPrefixDelvals[] = TEXT("**delvals.");


//
// Function proto-types
//

HKEY OpenUserKey(HKEY hkeyRoot, LPCTSTR pszName, BOOL * pfFoundSpecific);
UINT MergeRegistryData(HKEY hkeySrc, HKEY hkeyDst, LPTSTR pszKeyNameBuffer,
                       UINT cbKeyNameBuffer);
UINT CopyKeyValues(HKEY hkeySrc,HKEY hkeyDst);
BOOL HasSpecialPrefix(LPTSTR szValueName, DWORD * pdwPrefix,
        LPTSTR szStrippedValueName, DWORD dwBufSize);
BOOL GetGroupProcessingOrder(HKEY hkeyHiveRoot,LPTSTR * pGroupBuffer, DWORD * pdwGroupSize);
BOOL FindGroupInList(LPTSTR pszGroupName, LPTSTR pszGroupList);
LPTSTR GetUserGroups (LPCTSTR lpServerName, LPCTSTR lpUserName, HANDLE hToken, DWORD * puEntriesRead);


//*************************************************************
//
//  ApplySystemPolicy()
//
//  Purpose:    Entry point for Windows NT4 System Policy.
//
//  Parameters: dwFlags         - Flags
//              hToken          - User's token
//              hKeyCurrentUser - Registry to the root of the user's hive
//              lpUserName      - User's name
//              lpPolicyPath    - Path to the policy file (ntconfig.pol). Can be NULL.
//              lpServerName    - Domain controller name used for group
//                                membership look up.  Can be NULL.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              05/30/95    ericflo    Created
//              10/12/98    ericflo    Update for NT5
//
//*************************************************************

BOOL WINAPI ApplySystemPolicy (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                               LPCTSTR lpUserName, LPCTSTR lpPolicyPath,
                               LPCTSTR lpServerName)
{
    LONG lResult;
    BOOL bResult = FALSE;
    BOOL fFoundUser=FALSE;
    HKEY hkeyMain=NULL, hkeyRoot=NULL, hkeyUser, hkeyLogon;
    DWORD dwUpdateMode=UM_AUTOMATIC;
    DWORD dwData, dwSize;
    TCHAR szFilePath[MAX_PATH];
    TCHAR szLocalPath[MAX_PATH];
    TCHAR szTempDir[MAX_PATH];
    TCHAR szTempKey[100];
    CHAR szHandler[MAX_PATH+50];  // This needs to be ANSI
    TCHAR szComputerName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH+1];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    LPTSTR lpEnd;
    HANDLE hOldToken;
    DWORD  dwRet = 0;
    HRESULT hr = S_OK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy: Entering")));



    //
    // Initialize szFilePath
    //

    szFilePath[0] = TEXT('\0');


    //
    // Check the registry to see if update is specified and get update path
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_UPDATE,
                            0,
                            KEY_READ,
                            &hkeyMain);


    if (lResult == ERROR_SUCCESS) {


        //
        // Look for the update mode.
        //

        dwSize=sizeof(dwUpdateMode);
        if (RegQueryValueEx(hkeyMain,g_szUpdateModeValue,NULL,NULL,
                (LPBYTE) &dwUpdateMode,&dwSize) != ERROR_SUCCESS) {
                dwUpdateMode = UM_OFF;
        }


        //
        // if manual update is specified, also get the path to update from
        // (UNC path or path with drive letter)
        //


        if (dwUpdateMode==UM_MANUAL) {

            dwSize=sizeof(szTempDir);

            lResult = RegQueryValueEx(hkeyMain, g_szNetPathValue, NULL, NULL,
                                      (LPBYTE) szTempDir, &dwSize);

            if (lResult != ERROR_SUCCESS) {
                TCHAR szErr[MAX_PATH];

                RegCloseKey(hkeyMain);
                ReportError(hToken, PI_NOUI, 1, EVENT_MISSINGPOLICYFILEENTRY, GetErrString(lResult, szErr));
                return FALSE;
            }

            dwRet = ExpandEnvironmentStrings (szTempDir, szFilePath, MAX_PATH);

            if (dwRet > MAX_PATH || dwRet == 0) { //Fixing bug 548728
                RegCloseKey(hkeyMain);
                return FALSE;    
            }
        }

        RegCloseKey(hkeyMain);
    }


    //
    // If this machine has policy turned off, then we can exit now.
    //

    if (dwUpdateMode == UM_OFF) {
        DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Policy is turned off on this machine.")));
        return TRUE;
    }


    //
    // If we are running in automatic mode, use the supplied
    // policy file.
    //

    if (dwUpdateMode == UM_AUTOMATIC) {

        if (lpPolicyPath && *lpPolicyPath) {
            hr = StringCchCopy (szFilePath, ARRAYSIZE(szFilePath), lpPolicyPath);
            if (FAILED(hr)) {
                SetLastError(HRESULT_CODE(hr));
                return FALSE;
            }
        }
    }


    //
    // If we don't have a policy file, then we can exit now.
    //

    if (szFilePath[0] == TEXT('\0')) {
        DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  No Policy file.  Leaving.")));
        return TRUE;
    }

    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  PolicyPath is: <%s>."), szFilePath));


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Test if the policy file exists
    //

    if (!GetFileAttributesEx (szFilePath, GetFileExInfoStandard, &fad)) {

        lResult = GetLastError();

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }


        if ( (lResult == ERROR_FILE_NOT_FOUND) ||
             (lResult == ERROR_PATH_NOT_FOUND) ) {

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  No policy file.")));
            return TRUE;

        } else {
            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Failed to query for policy file with error %d."), lResult));
            return FALSE;
        }
    }


    //
    //  Create a temporary file name
    //

    dwSize = ARRAYSIZE(szBuffer);

    if (!GetUserProfileDirectory(hToken, szBuffer, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to query user profile directory with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        return FALSE;
    }


    if (!GetTempFileName (szBuffer, TEXT("prf"), 0, szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to create temporary filename with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        return FALSE;
    }


    //
    // Copy the policy hive
    //

    if (!CopyFile(szFilePath, szLocalPath, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to copy policy file with error %d."), GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
        }
        goto Exit;
    }


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy: Failed to revert to self")));
    }


    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Local PolicyPath is: <%s>."), szLocalPath));


    //
    // Query for the computer name
    //

    dwSize = ARRAYSIZE(szComputerName);
    if (!GetComputerName(szComputerName, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  GetComputerName failed.")));
        goto Exit;
    }



    //
    // Check to see if an installable policy handler has been added.  If
    // so, call it and let it do the work.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           g_szLogonKey,
                           0,
                           KEY_READ,
                           &hkeyLogon);


    if (lResult == ERROR_SUCCESS) {
        HANDLE hDLL = NULL;
        BOOL fRet;
        PFNPROCESSPOLICIES pfn;


        dwSize = ARRAYSIZE(szHandler);
        lResult = RegQueryValueExA(hkeyLogon,
                                   g_szPolicyHandler,
                                   NULL, NULL,
                                   (LPBYTE) szHandler,
                                   &dwSize);


        RegCloseKey(hkeyLogon);

        if (lResult == ERROR_SUCCESS) {
            LPSTR lpEntryPoint = szHandler;

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Machine has a custom Policy Handler of:  %S."), szHandler));

            //
            // Search for the ,
            //

            while (*lpEntryPoint && *lpEntryPoint != ',') {
                lpEntryPoint++;
            }


            //
            // Check if we found the ,
            //

            if (*lpEntryPoint) {

                *lpEntryPoint = '\0';
                lpEntryPoint++;


                hDLL = LoadLibraryA(szHandler);

                if (hDLL) {

                    pfn = (PFNPROCESSPOLICIES) GetProcAddress(hDLL, lpEntryPoint);

                    if (pfn != NULL) {

                        //
                        // Call the function.
                        // Note that the parameters are UNICODE.
                        //

                        fRet = (*pfn) (NULL,
                                       szLocalPath,
                                       lpUserName,
                                       szComputerName,
                                       0);


                        //
                        // if callout policy downloader returns FALSE, then we don't
                        // do any processing on our own.  If it returns TRUE then we
                        // go ahead and process policies normally, in addition to whatever
                        // he may have done.
                        //

                        if (!fRet) {
                            FreeLibrary(hDLL);
                            bResult = TRUE;
                            goto Exit;
                        }

                    } else {
                       DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to find entry point %S in policy dll.  Error %d."),
                                lpEntryPoint, GetLastError()));
                    }

                    FreeLibrary(hDLL);

                } else {
                   DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to load %S with error %d."),
                            szHandler, GetLastError()));
                }
            }
        }
    }


    //
    // Load the policy hive into registry
    //

    hr = StringCchPrintf (szTempKey, ARRAYSIZE(szTempKey), TEXT("%s (%d)"), g_szTmpKeyName, GetTickCount());
    
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }

    lResult = MyRegLoadKey(HKEY_USERS, szTempKey, szLocalPath);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to load policy hive.  Error = %d"), lResult));
        goto Exit;
    }

    //
    // Open the policy hive.
    //

    lResult = RegOpenKeyEx (HKEY_USERS,
                            szTempKey,
                            0,
                            KEY_READ,
                            &hkeyMain);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to open policy hive.  Error = %d"), lResult));
        MyRegUnLoadKey(HKEY_USERS, szTempKey);
        goto Exit;
    }


    //
    // For user and machine policies, see if there is an appropriate entry
    // in policy file (either a key with user/computer name,
    // or a default user or workstation entry).  If there is, then merge
    // information under that key into registry.  (If there isn't, it's
    // not an error-- just nothing to do.)
    //

    if (dwFlags & SP_FLAG_APPLY_USER_POLICY) {

        //
        // Merge user-specific policies if user name was specified
        //

        if (RegOpenKeyEx(hkeyMain,
                         REGSTR_KEY_POL_USERS,
                         0,
                         KEY_READ,
                         &hkeyRoot) == ERROR_SUCCESS) {


            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Looking for user specific policy.")));

            hkeyUser = OpenUserKey(hkeyRoot, lpUserName, &fFoundUser);

            if (hkeyUser) {
                MergeRegistryData(hkeyUser,hKeyCurrentUser,szBuffer, ARRAYSIZE(szBuffer));
                RegCloseKey(hkeyUser);
            }

            RegCloseKey(hkeyRoot);
        }



        //
        // Merge group specific policies if user name specified, and we
        // *didn't* find a specific user entry above
        //

        if (!fFoundUser && lpServerName && *lpServerName) {
            HKEY hkeyGroups, hkeyGroup;
            LPTSTR GroupBuffer, ApiBuf;
            DWORD dwGroupSize = DEFAULT_GROUP_SIZE;
            DWORD uEntriesRead;


            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Processing group(s) policy.")));

            GroupBuffer = GlobalAlloc(GPTR, DEFAULT_GROUP_SIZE * sizeof(TCHAR));

            if (GroupBuffer) {

                //
                // if there is a group processing order specified in policy hive,
                // then process groups
                //

                if (RegOpenKeyEx(hkeyMain,
                                 REGSTR_KEY_POL_USERGROUPS,
                                 0,
                                 KEY_READ,
                                 &hkeyGroups) == ERROR_SUCCESS) {


                    if (GetGroupProcessingOrder(hkeyMain, &GroupBuffer, &dwGroupSize)) {

                        //
                        // Enumerate the groups that this user belongs to
                        //

                        ApiBuf = GetUserGroups (lpServerName, lpUserName, hToken, &uEntriesRead);

                        if (ApiBuf) {

                            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  User belongs to %d groups."), uEntriesRead));

                            if (uEntriesRead) {

                                //
                                // Walk through the list of groups (ordered lowest priority
                                // to highest priority).  for each group, if the user belongs
                                // to it then download policies for that group.
                                //

                                LPTSTR pszGroup = GroupBuffer;
                                TCHAR szKeyNameBuffer[MAX_PATH+1];

                                while (*pszGroup) {

                                    //
                                    // Does user belong to this group?
                                    //

                                    if (FindGroupInList(pszGroup, ApiBuf)) {

                                        //
                                        // Open the key in the hive for this group
                                        //

                                        if (RegOpenKeyEx (hkeyGroups,
                                                          pszGroup,
                                                          0,
                                                          KEY_READ,
                                                          &hkeyGroup) == ERROR_SUCCESS) {


                                            //
                                            // Merge group policies
                                            //

                                            MergeRegistryData(hkeyGroup,
                                                              hKeyCurrentUser,
                                                              szKeyNameBuffer,
                                                              ARRAYSIZE(szKeyNameBuffer));

                                            RegCloseKey (hkeyGroup);
                                        }
                                    }

                                    pszGroup += lstrlen(pszGroup) + 1;
                                }
                            }

                            GlobalFree (ApiBuf);

                        } else {
                           DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to get user's groups.")));
                        }

                    } else {
                        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to get group processing order.")));
                    }

                    RegCloseKey(hkeyGroups);

                } else {
                    DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to allocate memory for group policy.  Error = %d"), GetLastError()));
                }

                GlobalFree (GroupBuffer);

            } else {
                DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to allocate memory for group policy.  Error = %d"), GetLastError()));
            }
        }
    }


    if (dwFlags & SP_FLAG_APPLY_MACHINE_POLICY) {

        //
        // Merge machine-specific policies if computer name was specified
        //

        if (RegOpenKeyEx(hkeyMain,
                         REGSTR_KEY_POL_COMPUTERS,
                         0,
                         KEY_READ,
                         &hkeyRoot) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Looking for machine specific policy.")));

            hkeyUser = OpenUserKey(hkeyRoot, szComputerName, &fFoundUser);

            if (hkeyUser) {
                MergeRegistryData(hkeyUser, HKEY_LOCAL_MACHINE, szBuffer, ARRAYSIZE(szBuffer));
                RegCloseKey(hkeyUser);
            }

            RegCloseKey(hkeyRoot);
        }
    }



    //
    // Close the policy key
    //

    RegCloseKey(hkeyMain);


    //
    // Unload the policy hive.
    //

    if (!MyRegUnLoadKey(HKEY_USERS, szTempKey)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to unload policy hive.  Error = %d"), lResult));
        goto Exit;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    //
    // Delete the policy files
    //

    if (!DeleteFile (szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to delete policy file <%s>.  Error %d"),
                 szLocalPath, GetLastError()));
    }

    hr = StringCchCat (szLocalPath, ARRAYSIZE(szLocalPath), c_szLog);
    ASSERT(SUCCEEDED(hr));
    
    if (!DeleteFile (szLocalPath)) {
        DebugMsg((DM_WARNING, TEXT("ApplySystemPolicy:  Failed to delete policy log file <%s>.  Error %d"),
                 szLocalPath, GetLastError()));
    }


    DebugMsg((DM_VERBOSE, TEXT("ApplySystemPolicy:  Leaving with %d"), bResult));

    return bResult;
}


//*************************************************************
//
//  OpenUserKey()
//
//  Purpose:    Attempts to open the user specific key, or the
//              .default key.
//
//  Parameters: hkeyRoot       -   Root key
//              pszName        -   User name
//              fFoundSpecific -   Found the requested key
//
//  Return:     hkey if successful
//              NULL if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/13/95     ericflo    Ported
//
//*************************************************************

HKEY OpenUserKey(HKEY hkeyRoot,LPCTSTR pszName, BOOL *pfFoundSpecific)
{
    HKEY hkeyTest;
    *pfFoundSpecific = FALSE;

    //
    // See if there is a subkey under the specified key with the given
    // user name
    //

    if ((RegOpenKeyEx(hkeyRoot,
                      pszName,
                      0,
                      KEY_READ,
                      &hkeyTest)) == ERROR_SUCCESS) {

        *pfFoundSpecific = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  Found specific entry for %s ignoring .Default."), pszName));
        return hkeyTest;
    }

    //
    // If not, see if there is a default key
    //

    if ((RegOpenKeyEx(hkeyRoot,
                      REGSTR_KEY_POL_DEFAULT,
                      0,
                      KEY_READ,
                      &hkeyTest)) == ERROR_SUCCESS) {

        DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  No entry for %s, using .Default instead."), pszName));
        return hkeyTest;
    }


    //
    // No entry for this name in policy file
    //

    DebugMsg((DM_VERBOSE, TEXT("OpenUserKey:  No user/machine specific policy and no .Default policy.")));
    return NULL;
}


//*************************************************************
//
//  MergeRegistryData()
//
//  Purpose:    Merges hkeySrc and subkeys into hkeyDst.
//
//  Parameters: hkeySrc          -   Source
//              hkeyDst          -   Destination
//              pszKeyNameBuffer - Key name
//              cbKeyNameBuffer  - Size of key name buffer
//      
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise an error value
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/13/95     ericflo    Ported
//
//*************************************************************

UINT MergeRegistryData(HKEY hkeySrc, HKEY hkeyDst, LPTSTR pszKeyNameBuffer,
                       UINT cbKeyNameBuffer)
{
    UINT nIndex = 0,uRet=ERROR_SUCCESS;

    //
    // Look for any subkeys of the source key
    //

    while ((uRet=RegEnumKey(hkeySrc,nIndex,pszKeyNameBuffer,
        cbKeyNameBuffer)) == ERROR_SUCCESS) {

        HKEY hkeySubkeySrc,hkeySubkeyDst;


        //
        // Create the subkey under the destination key
        //

        if ((uRet=RegCreateKey(hkeyDst,pszKeyNameBuffer,
                &hkeySubkeyDst)) != ERROR_SUCCESS)
                return uRet;

        if ((uRet=RegOpenKey(hkeySrc, pszKeyNameBuffer,
                &hkeySubkeySrc)) != ERROR_SUCCESS) {
                RegCloseKey(hkeySubkeyDst);
                return uRet;
        }


        //
        // Copy the key values from source subkey to destination subkey
        //

        uRet=CopyKeyValues(hkeySubkeySrc,hkeySubkeyDst);

        if (uRet == ERROR_SUCCESS) {

             //
             // Merge recursively on subkeys of these keys, if any
             //

             uRet = MergeRegistryData(hkeySubkeySrc,hkeySubkeyDst,pszKeyNameBuffer,
                     cbKeyNameBuffer);
        }

        RegCloseKey(hkeySubkeySrc);
        RegCloseKey(hkeySubkeyDst);

        if (uRet != ERROR_SUCCESS) {
            return uRet;
        }

        nIndex ++;
    }


    if (uRet == ERROR_NO_MORE_ITEMS) {
        uRet=ERROR_SUCCESS;
    }

    return uRet;
}

//*************************************************************
//
//  CopyKeyValues()
//
//  Purpose:    Copies all key values from hkeySrc to hkeyDst
//
//  Parameters: hkeySrc -   Source
//              hkeyDst -   destination
//
//  Return:     Error code
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

UINT CopyKeyValues(HKEY hkeySrc, HKEY hkeyDst)
{
    DWORD dwSubkeyCount,dwMaxSubkeyNameLen,dwMaxClassNameLen,dwValueCount,
          dwMaxValueNameLen,dwMaxValueDataLen,dwDescriptorLen,dwClassNameLen;
    FILETIME ftLastWriteTime;
    UINT uRet=ERROR_SUCCESS;
    TCHAR szClassName[255];
    HRESULT hr = S_OK;

    //
    // Do RegQueryInfoKey to find out if there are values for the source key,
    // and the size of value name and value data buffes to alloc
    //

    dwClassNameLen = ARRAYSIZE(szClassName);

    uRet=RegQueryInfoKey(hkeySrc,szClassName,&dwClassNameLen,NULL,&dwSubkeyCount,
            &dwMaxSubkeyNameLen,&dwMaxClassNameLen,&dwValueCount,&dwMaxValueNameLen,
            &dwMaxValueDataLen,&dwDescriptorLen,&ftLastWriteTime);

    if (uRet != ERROR_SUCCESS) {
        return uRet;
    }


    //
    // If there are values...
    //


    if (dwValueCount) {
        TCHAR  ValueName[MAX_PATH];
        LPBYTE ValueData;
        DWORD  dwType,dwValueNameSize,dwValueDataSize;
        UINT nIndex = 0;


        ValueData = GlobalAlloc (GPTR, MAX_VALUE_DATA);

        if (!ValueData) {
            return GetLastError();
        }

        //
        // the "**delvals" control code is special, must be processed
        // first; look for it now and if it exists delete all existing
        // values under this key in destination registry
        //

        if (RegQueryValueEx(hkeySrc,g_szPrefixDelvals,NULL,NULL,NULL,NULL) == ERROR_SUCCESS) {

            DeleteAllValues(hkeyDst);
        }

        //
        // Enumerate the values of the source key, and create each value
        // under the destination key
        //

        do  {
            dwValueNameSize = MAX_PATH;
            dwValueDataSize = MAX_VALUE_DATA;

            if ((uRet=RegEnumValue(hkeySrc,nIndex, ValueName,
                    &dwValueNameSize,NULL,&dwType, ValueData,
                    &dwValueDataSize)) == ERROR_SUCCESS) {

                 DWORD dwPrefix;

                 //
                 // Look for special prefixes which indicate we should treat
                 // these values specially
                 //
                 TCHAR StrippedValueName[MAX_PATH];

                 if (HasSpecialPrefix(ValueName, &dwPrefix, StrippedValueName, MAX_PATH)) { // Fixing bug 548903

                     //
                     // ValueName now contains real value name stripped
                     // of prefix, filled in above by HasSpecialPrefix().
                     // Adjust value name size, the value name will shorten
                     // because the prefix has been removed.
                     //

                     hr = StringCchCopy(ValueName, MAX_PATH, StrippedValueName); 
                     ASSERT(SUCCEEDED(hr));

                     dwValueNameSize = lstrlen (ValueName) + 1;

                     switch (dwPrefix) {

                         case PREFIX_DELETE:

                             //
                             // Delete this value in destination
                             //

                             RegDeleteValue(hkeyDst, ValueName);
                             uRet = ERROR_SUCCESS;
                             DebugMsg((DM_VERBOSE, TEXT("Deleted value: %s"), ValueName));
                             break;

                         case PREFIX_SOFT:

                             //
                             // "soft" value, only set this if it doesn't already
                             // exist in destination
                             //

                             {

                             TCHAR TmpValueData[MAX_PATH+1];
                             DWORD dwSize=sizeof(TmpValueData);

                             if (RegQueryValueEx(hkeyDst, ValueName,
                                     NULL,NULL,(LPBYTE) TmpValueData,
                                     &dwSize) != ERROR_SUCCESS) {

                                 //
                                 // The value doesn't exist, set the value.
                                 //

                                 uRet=RegSetValueEx(hkeyDst, ValueName, 0,
                                                    dwType, ValueData,
                                                    dwValueDataSize);

                             } else {

                                 //
                                 // Value already exists, nothing to do
                                 //

                                 uRet = ERROR_SUCCESS;
                             }

                             }

                             break;

                         case PREFIX_DELVALS:
                             // processed early on above, fall through and ignore

                         default:

                             //
                             // Got some prefix that we don't understand... presumably,
                             // from a future version.  Ignore this value, rather than
                             // propagating it into the registry, prefix and all.
                             // This will give us less backward compatibility headaches
                             // down the road.
                             //

                             uRet = ERROR_SUCCESS;   // nothing to do

                             break;
                     }
                 } else {

                     //
                     // Copy the value normally to destination key
                     //

                     uRet=RegSetValueEx(hkeyDst,ValueName,0,
                             dwType,ValueData,dwValueDataSize);

#if DBG
                     if (uRet == ERROR_SUCCESS) {

                        switch (dwType) {
                            case REG_SZ:
                            case REG_EXPAND_SZ:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s => %s  [OK]"),
                                         ValueName, (LPTSTR)ValueData));
                                break;

                            case REG_DWORD:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s => %d  [OK]"),
                                         ValueName, (DWORD)*ValueData));
                                break;

                            default:
                                DebugMsg((DM_VERBOSE, TEXT("CopyKeyValues: %s was set successfully"),
                                         ValueName));
                        }

                     } else {
                         DebugMsg((DM_WARNING, TEXT("CopyKeyValues: Failed to set %s with error %d."),
                                  ValueName, uRet));
                     }
#endif

                 }
            }

            nIndex++;

        } while (uRet == ERROR_SUCCESS);


        if (uRet == ERROR_NO_MORE_ITEMS) {
            uRet=ERROR_SUCCESS;
        }

        GlobalFree (ValueData);
    }

    return uRet;
}


//*************************************************************
//
//  HasSpecialPrefix()
//
//  Purpose:    Checks to see if szValueName has a special prefix (a la
//              "**<something>."  Returns TRUE if it does, FALSE otherwise.
//              if TRUE, returns the numerical index of the prefix in *pdwPrefix,
//              and copies the rest of value name (after the ".") into
//              szStrippedValueName.  Buffer for szStrippedValueName must be at
//              least as large as szValueName.  It is safe to pass the same
//              buffer to szValueName and szStrippedValueName and have the name
//              modified in place.
//
//  Parameters: szValueName         -   Value Name
//              pdwPrefix           -   Index of the prefix
//              szStrippedValueName -   Value name without the **
//      
//
//  Return:     TRUE if value name has a prefix
//              FALSE if it does not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

typedef struct tagPREFIXMAP {
    const LPTSTR pszPrefix;
    DWORD dwPrefixIndex;
} PREFIXMAP;



BOOL HasSpecialPrefix(LPTSTR szValueName, DWORD * pdwPrefix,
                      LPTSTR szStrippedValueName, DWORD dwBufSize)
{

    PREFIXMAP PrefixMap[] = {
            {g_szPrefixDel, PREFIX_DELETE},
            {g_szPrefixSoft, PREFIX_SOFT},
            {g_szPrefixDelvals, PREFIX_DELVALS}
    };
    UINT nCount,nLen;
    HRESULT hr = S_OK;


    //
    // Does the value name begin with "**"?
    //

    if (!szValueName || (lstrlen(szValueName) < 2) ||
         szValueName[0] != TEXT('*') || szValueName[1] != TEXT('*'))

        return FALSE;   // not a special prefix


    //
    // Try all the prefixes we know to try to find a match
    //

    for (nCount = 0; nCount < ARRAYSIZE(PrefixMap); nCount++) {
         nLen = lstrlen (PrefixMap[nCount].pszPrefix);

         if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                            szValueName, nLen,
                            PrefixMap[nCount].pszPrefix, nLen) == 2) {

             *pdwPrefix = PrefixMap[nCount].dwPrefixIndex;

             //
             // make a copy of the value name, sans prefix, into
             // the stripped value name buffer
             //

             hr = StringCchCopy (szStrippedValueName, dwBufSize, szValueName + nLen);
             if (FAILED(hr)) {
                SetLastError(HRESULT_CODE(hr));
                return FALSE;
             }
             return TRUE;
         }
    }

    //
    // this is a prefix, but not one we know.
    //

    *pdwPrefix = PREFIX_UNKNOWN;
    hr = StringCchCopy (szStrippedValueName, dwBufSize, szValueName);
    if (FAILED(hr)) {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  GetGroupProcessingOrder()
//
//  Purpose:    Gets the list of groups in order
//
//  Parameters: hkeyHiveRoot    -   Registry key
//              GroupBuffer     -   Pointer to group buffer
//              pdwBufferSize   -   Buffer size
//
//  Return:     Number of entries if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

BOOL GetGroupProcessingOrder(HKEY hkeyHiveRoot, LPTSTR * pGroupBuffer,
                             DWORD * pdwGroupSize)
{
    DWORD cEntries,cMaxValueName,cMaxData;
    HKEY hkeyGroupData;
    UINT uRet;
    LPTSTR GroupBuffer = *pGroupBuffer;
    LPTSTR lpTemp;
    DWORD dwGroupSize = *pdwGroupSize;
    TCHAR szValueName[11], szGroupName[48+1]; // netware groups can be up to 48 chars
    DWORD dwUsed = 0, dwSize;       // amount of buffer used
    UINT nLen,nRead=0;
    HRESULT hr = S_OK;

    //
    // Open the group data key
    //

    uRet = RegOpenKeyEx(hkeyHiveRoot,
                        REGSTR_KEY_POL_USERGROUPDATA,
                        0,
                        KEY_READ,
                        &hkeyGroupData);

    if (uRet != ERROR_SUCCESS) {

        //
        // Group data key doesn't exist (most likely), no downloading to do
        //

        return FALSE;
    }


    //
    // Find out the number of values in group data key
    //

    if ((RegQueryInfoKey (hkeyGroupData,NULL,NULL,NULL,NULL,NULL,
            NULL,&cEntries,&cMaxValueName,&cMaxData,NULL,NULL ) != ERROR_SUCCESS) ||
            !cEntries) {

        RegCloseKey(hkeyGroupData);
        return FALSE;
    }


    //
    // The values are stored as "1"="<group name>", "2"="<group name>", etc.
    // where 1 is most important.  we will pack the names into a buffer lowest
    // priority to highest.  So if we have n values, start with value name "<n>"
    // and work down to "1".
    //

    while (cEntries) {

       hr = StringCchPrintf(szValueName, ARRAYSIZE(szValueName), TEXT("%lu"), cEntries);
       ASSERT(SUCCEEDED(hr));

       dwSize = sizeof(szGroupName);

       if (RegQueryValueEx(hkeyGroupData,szValueName,NULL,NULL,
               (LPBYTE) szGroupName,&dwSize) == ERROR_SUCCESS) {

               nLen = lstrlen(szGroupName) + 1;

               //
               // Resize buffer if neccessary (add 1 for extra terminating null)
               //

               if (nLen + dwUsed + 1 > dwGroupSize) {

                   //
                   // add a little extra so we don't realloc on every item
                   //

                   dwGroupSize = dwGroupSize + nLen + 256;

                   lpTemp = GlobalReAlloc(GroupBuffer,
                                          (dwGroupSize * sizeof(TCHAR)),
                                          GMEM_MOVEABLE);

                   if (!lpTemp) {

                       RegCloseKey(hkeyGroupData);
                       return FALSE;
                   }

                   GroupBuffer = lpTemp;
               }

               hr = StringCchPrintf(GroupBuffer + dwUsed, dwGroupSize - dwUsed, szGroupName);
               ASSERT(SUCCEEDED(hr));

               dwUsed += nLen;
               nRead++;
       }

       cEntries --;
    }

    //
    // Doubly null-terminate buffer
    //

    *(GroupBuffer + dwUsed) = TEXT('\0');

    RegCloseKey(hkeyGroupData);

    *pGroupBuffer = GroupBuffer;
    *pdwGroupSize = dwGroupSize;

    return (nRead > 0);
}

//*************************************************************
//
//  FindGroupInList()
//
//  Purpose:    Determines if the requested group
//              is in the list of groups
//
//  Parameters: pszGroupName    -   Group looking for
//              pszGroupList    -   List of groups null seperated
//
//  Return:     TRUE if found
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/15/95     ericflo    Ported
//
//*************************************************************

BOOL FindGroupInList(LPTSTR pszGroupName, LPTSTR pszGroupList)
{

    while (*pszGroupList) {

        if (!lstrcmpi(pszGroupList,pszGroupName)) {
            DebugMsg((DM_VERBOSE, TEXT("FindGroupInList:  User is a member of the %s group."), pszGroupName));
            return TRUE;
        }

        pszGroupList += lstrlen(pszGroupList) + 1;
    }

    DebugMsg((DM_VERBOSE, TEXT("FindGroupInList:  User is NOT a member of the %s group."), pszGroupName));
    return FALSE;
}

//*************************************************************
//
//  GetUserGroups()
//
//  Purpose:    Retrieves a list of groups this user belongs to
//
//  Parameters: lpServerName   -  Server name
//              lpUserName     -  User name
//              hToken         -  User's token
//              puEntriesRead  -  Number of groups
//
//  Return:     Pointer to list if successful
//              Null if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/15/95     ericflo    Created
//
//*************************************************************

LPTSTR GetUserGroups (LPCTSTR lpServerName, LPCTSTR lpUserName,
                      HANDLE hToken, DWORD * puEntriesRead)
{
    UINT nIndex;
    NET_API_STATUS status;
    LPBYTE lpGroups, lpTemp;
    PGROUP_INFO_0  pgi0;
    DWORD dwEntriesRead, dwTotalEntries;
    DWORD cchSizeNeeded;
    LPTSTR lpGroupNames, lpName;
    PNETAPI32_API pNetAPI32;
    HANDLE hOldToken;
    HRESULT hr = S_OK;

    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();
    
    if (!pNetAPI32) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups:  Failed to load netapi32 with %d."),
                 GetLastError()));
        return NULL;
    }


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to impersonate user")));
        return NULL;
    }


    //
    // Query for the groups
    //

    status = pNetAPI32->pfnNetUserGetGroups (lpServerName, lpUserName,
                                           0, &lpGroups, 0xFFFFFFFF, &dwEntriesRead,
                                           &dwTotalEntries);

    if (status == NERR_Success) {

        //
        // NetUserGetGroups opens a named pipe to the server.  To close
        // it, we need to call NetUserGetInfo on the local machine
        //

        if (pNetAPI32->pfnNetUserGetInfo (NULL, lpUserName,
                                        0, &lpTemp) == NERR_Success) {
            pNetAPI32->pfnNetApiBufferFree (lpTemp);
        }


    } else {
        DebugMsg((DM_VERBOSE, TEXT("GetUserGroups: NetUserGetGroups failed with %d"), status));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to revert to self")));
        }
        return NULL;
    }


    //
    // Revert to self
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGroups: Failed to revert to self")));
    }


    //
    // NetUserGetGroups returns names packed in structures with fixed-length
    // fields.  Need to copy that into caller's buffer packed with the names
    // packed end-to-end.
    //
    // Count the total buffer size we need, which will be smaller than the
    // API buffer to NetUserGetGroups because we're not using fixed-length
    // fields
    //

    cchSizeNeeded = 1;
    pgi0 = (PGROUP_INFO_0) lpGroups;

    for (nIndex=0; nIndex < dwEntriesRead; nIndex++) {

         cchSizeNeeded += lstrlen(pgi0->grpi0_name) + 1;
         pgi0++;
    }

    *puEntriesRead = dwEntriesRead;

    //
    // Build the list of group names
    //

    lpGroupNames = GlobalAlloc (GPTR, cchSizeNeeded * sizeof (TCHAR));

    if (!lpGroupNames) {
        pNetAPI32->pfnNetApiBufferFree (lpGroups);
        return NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetUserGroups: User is a member of the following global groups:")));

    lpName = lpGroupNames;
    pgi0 = (PGROUP_INFO_0) lpGroups;

    for (nIndex=0; nIndex < dwEntriesRead; nIndex++) {

         DebugMsg((DM_VERBOSE, TEXT("GetUserGroups:     %s"), pgi0->grpi0_name));
         hr = StringCchCopy (lpName, cchSizeNeeded - (lpName - lpGroupNames), pgi0->grpi0_name);
         ASSERT(SUCCEEDED(hr));
         lpName += lstrlen(pgi0->grpi0_name) + 1;
         pgi0++;
    }

    //
    // Free the memory allocated by NetUserGetGroups
    //

    pNetAPI32->pfnNetApiBufferFree (lpGroups);

    return lpGroupNames;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\copydir.c ===
//*************************************************************
//
//  Functions to copy the profile directory
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "strsafe.h"


//
// Local function proto-types
//

BOOL RecurseDirectory (HANDLE hTokenUser, LPTSTR lpSrcDir, DWORD cchSrcDir, LPTSTR lpDestDir, DWORD cchDestDir,
                       DWORD dwFlags, LPFILEINFO *llSrcDirs, LPFILEINFO *llSrcFiles,
                       BOOL bSkipNtUser, LPTSTR lpExcludeList, BOOL bRecurseDest);
BOOL AddFileInfoNode (LPFILEINFO *lpFileInfo, LPTSTR lpSrcFile,
                      LPTSTR lpDestFile, LPFILETIME ftLastWrite, LPFILETIME ftCreate,
                      DWORD dwFileSize, DWORD dwFileAttribs, BOOL bHive);
BOOL FreeFileInfoList (LPFILEINFO lpFileInfo);
BOOL SyncItems (LPFILEINFO lpSrcItems, LPFILEINFO lpDestItems,
                BOOL bFile, LPFILETIME ftDelRefTime);
void CopyFileFunc (LPTHREADINFO lpThreadInfo);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);
DWORD FindDirectorySize(LPTSTR lpDir, LPFILEINFO lpFiles, DWORD dwFlags, DWORD* pdwLargestHiveFile, DWORD* pdwTotalFiles);
DWORD FindTotalDiskSpaceNeeded(DWORD        dwTotalSrcFiles,
                               DWORD        dwTotalDestFiles,
                               DWORD        dwLargestHiveFile,
                               LPFILEINFO   lpSrcFiles,
                               DWORD        dwFlags);
DWORD FindTotalNMaxFileSize(LPFILEINFO lpSrcFiles, DWORD dwNumOfFiles);
BOOL ReconcileDirectory(LPTSTR lpSrcDir, LPTSTR lpDestDir, 
                        DWORD dwFlags, DWORD dwSrcAttribs);

//*************************************************************
//
//  CopyProfileDirectoryEx()
//
//  Purpose:    Copies the profile directory from the source
//              to the destination
//
//
//  Parameters: LPCTSTR     lpSourceDir     -  Source directory
//              LPCTSTR     lpDestDir       -  Destination directory
//              DWORD       dwFlags         -  Flags
//              LPFILETIME  ftDelRefTime    -  Delete file reference time
//              LPCTSTR     lpExclusionList -  List of directories to exclude
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:   Called after impersonating the user.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Created
//              4/09/98     ericflo    Converted to CopyProfileDirectoryEx
//              9/28/98     ushaji     Modified to check for free space
//              3/14/00     weiruc     Modified to copy hive file even if
//                                     hive is still loaded and ignore copy
//                                     hive file errors.
//
//*************************************************************

BOOL CopyProfileDirectoryEx (LPCTSTR lpSourceDir,
                             LPCTSTR lpDestinationDir,
                             DWORD dwFlags,
                             LPFILETIME ftDelRefTime,
                             LPCTSTR lpExclusionList)
{
    LPTSTR lpSrcDir = NULL, lpDestDir = NULL;
    LPTSTR lpSrcEnd, lpDestEnd;
    LPTSTR lpExcludeListSrc = NULL;
    LPTSTR lpExcludeListDest = NULL;
    LPFILEINFO lpSrcFiles = NULL, lpDestFiles = NULL;
    LPFILEINFO lpSrcDirs = NULL, lpDestDirs = NULL;
    LPFILEINFO lpTemp;
    THREADINFO ThreadInfo = {0, NULL, NULL, 0, NULL, NULL, NULL, NULL};
    DWORD dwThreadId;
    HANDLE hThreads[NUM_COPY_THREADS];
    HANDLE hStatusThread = 0;
    DWORD dwThreadCount = 0;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    BOOL bResult = FALSE;
    BOOL bSynchronize = FALSE;
    UINT i;
    DWORD dwTotalSrcFiles = 0;
    DWORD dwTotalDestFiles = 0;
    DWORD dwLargestHiveFile;
    DWORD dwTotalDiskSpaceNeeded;
    ULARGE_INTEGER ulFreeBytesAvailableToCaller, ulTotalNumberOfBytes, ulTotalNumberOfFreeBytes;   
    DWORD dwErr, dwErr1=0;
    TCHAR szErr[MAX_PATH];
    TCHAR szTmpHive[MAX_PATH];
    BOOL bReconcileHiveSucceeded;
    HKEY hkCurrentUser = NULL;
    HANDLE hTokenUser = NULL;
    size_t cchSrc, cchDest;
    DWORD cchSrcEnd, cchDestEnd;
    HRESULT hr;

    dwErr = GetLastError();

    //
    // Validate parameters
    //

    if (!lpSourceDir || !lpDestinationDir) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: received NULL pointer")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hr = StringCchLength((LPTSTR)lpSourceDir, MAX_PATH, &cchSrc);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: invalid src dir")));
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }        

    hr = StringCchLength((LPTSTR)lpDestinationDir, MAX_PATH, &cchDest);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: invalid dest dir")));
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }        

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Entering, lpSourceDir = <%s>, lpDestinationDir = <%s>, dwFlags = 0x%x"),
             lpSourceDir, lpDestinationDir, dwFlags));


    //
    // Get the caller's token
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE, TRUE, &hTokenUser)) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE, &hTokenUser)) {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Fail to get process token with error %d."), GetLastError()));
            return FALSE;
        }
    }

    //
    // If there is an exclusion list, convert it into an array of null
    // terminate strings (double null at the end) based upon the source
    // directory
    //

    if ((dwFlags & CPD_USEEXCLUSIONLIST) && lpExclusionList) {

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: lpExclusionList = <%s>"),
                 lpExclusionList));

        lpExcludeListSrc = ConvertExclusionList (lpSourceDir, lpExclusionList);

        if (!lpExcludeListSrc) {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx:  Failed to convert exclusion list for source")));
            dwErr = ERROR_INVALID_DATA;
            goto Exit;
        }

        if (!(dwFlags & CPD_DELDESTEXCLUSIONS)) {
            lpExcludeListDest = ConvertExclusionList (lpDestinationDir, lpExclusionList);

            if (!lpExcludeListDest) {
                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx:  Failed to convert exclusion list for destination")));
                dwErr = ERROR_INVALID_DATA;
                goto Exit;
            }
        }
    }


    //
    // Get the desktop handle
    //

    ThreadInfo.hDesktop = GetThreadDesktop(GetCurrentThreadId());

    //
    // Is this a full sync copy (delete extra files / directories in dest).
    //

    if (dwFlags & CPD_SYNCHRONIZE) {
        bSynchronize = TRUE;
    }


    //
    // Test / Create the destination directory
    //

    if (!CreateNestedDirectory(lpDestinationDir, NULL)) {

        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to create the destination directory.  Error = %d"),
                  GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Create and set up the directory buffers
    //

    cchSrc = cchDest = 2 * MAX_PATH;
    lpSrcDir = LocalAlloc(LPTR, cchSrc * sizeof(TCHAR));
    lpDestDir = LocalAlloc(LPTR, cchDest * sizeof(TCHAR));

    if (!lpSrcDir || !lpDestDir) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to allocate memory for working directories")));
        dwErr = GetLastError();
        goto Exit;
    }


    StringCchCopy (lpSrcDir, cchSrc, lpSourceDir);
    StringCchCopy (lpDestDir, cchDest, lpDestinationDir);


    //
    // Setup ending pointers
    //

    lpSrcEnd = CheckSlashEx (lpSrcDir, cchSrc, &cchSrcEnd);
    lpDestEnd = CheckSlashEx (lpDestDir, cchDest, &cchDestEnd);

    //
    // Recurse through the folders gathering info
    //

    if (!(dwFlags & CPD_COPYHIVEONLY)) {


        //
        // Recurse the source directory
        //

        if (!RecurseDirectory(hTokenUser, lpSrcDir, cchSrc, lpDestDir, cchDest, dwFlags,
                              &lpSrcDirs, &lpSrcFiles, TRUE, lpExcludeListSrc, FALSE)) {
            DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: RecurseDirectory returned FALSE")));
            dwErr = GetLastError();
            goto Exit;
        }


        if (bSynchronize) {

            //
            // Recurse the destination directory
            //

            if (!RecurseDirectory(hTokenUser, lpDestDir, cchDest, lpSrcDir, cchSrc, dwFlags,
                                  &lpDestDirs, &lpDestFiles, TRUE, lpExcludeListDest, TRUE)) {
                DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: RecurseDirectory returned FALSE")));
                dwErr = GetLastError();
                goto Exit;
            }
        }
    }


    //
    // determine the source and destination sizes
    //

    if(FindDirectorySize(lpSrcDir, lpSrcFiles, dwFlags, &dwLargestHiveFile, &dwTotalSrcFiles) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("FindDirectorySize: Error = %08x"), GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }
    if(FindDirectorySize(lpDestDir, lpDestFiles, dwFlags, NULL, &dwTotalDestFiles) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("FindDirectorySize: Error = %08x"), GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    // 
    // determine the disk space needed
    //

    dwTotalDiskSpaceNeeded = FindTotalDiskSpaceNeeded(dwTotalSrcFiles,
                                                      dwTotalDestFiles,
                                                      dwLargestHiveFile,
                                                      lpSrcFiles,
                                                      dwFlags);


    //
    // CopyProfileDirectoryEx is called with impersonation on
    //

    if (!GetDiskFreeSpaceEx(lpDestDir,  &ulFreeBytesAvailableToCaller, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes)) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to get the Free Disk Space <%s>.  Error = %d"),
                         lpDestDir, GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("Available\t\t%d"), ulFreeBytesAvailableToCaller.QuadPart));
    DebugMsg((DM_VERBOSE, TEXT("Needed\t\t%d"), dwTotalDiskSpaceNeeded));
    DebugMsg((DM_VERBOSE, TEXT("Src size\t\t%d"), dwTotalSrcFiles));
    DebugMsg((DM_VERBOSE, TEXT("Dest size\t\t%d"), dwTotalDestFiles));
    DebugMsg((DM_VERBOSE, TEXT("Largest hive file\t\t%d"), dwLargestHiveFile));

    if(dwTotalDiskSpaceNeeded > ulFreeBytesAvailableToCaller.QuadPart) {
        DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Not enough disk space on <%s>"), lpDestDir));

        dwErr = ERROR_DISK_FULL;
        goto Exit;
    }
        
    //
    // Synchronize the directories and files if appropriate
    //

    if (bSynchronize) {

        //
        //  Files first...
        //

        SyncItems (lpSrcFiles, lpDestFiles, TRUE,
                   (dwFlags & CPD_USEDELREFTIME) ? ftDelRefTime : NULL);

        //
        //  Now the directories...
        //

        SyncItems (lpSrcDirs, lpDestDirs, FALSE,
                   (dwFlags & CPD_USEDELREFTIME) ? ftDelRefTime : NULL);
    }


    //
    // Copy the actual hive, log, ini files first
    //

    if (!(dwFlags & CPD_IGNOREHIVE)) {


        //
        // Search for all user hives
        //

        if (dwFlags & CPD_WIN95HIVE) {

            StringCchCopy (lpSrcEnd, cchSrcEnd, c_szUserStar);

        } else {

            StringCchCopy (lpSrcEnd, cchSrcEnd, c_szNTUserStar);

        }


        //
        // Enumerate
        //

        hFile = FindFirstFile(lpSrcDir, &fd);

        if (hFile != INVALID_HANDLE_VALUE) {

            do  {

                //
                // Setup the filename
                //

                if((dwFlags & CPD_USETMPHIVEFILE) &&
                    (lstrcmpi(fd.cFileName, c_szNTUserMan) == 0 ||
                     lstrcmpi(fd.cFileName, c_szNTUserDat) == 0)) {

                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Hive is still loaded, use temporary hive file")));

                    //
                    // Use temporary hive file because unloading hive failed.
                    //

                    StringCchCopy(lpSrcEnd, cchSrcEnd, c_szNTUserTmp);
                    
                }
                else {
                    StringCchCopy (lpSrcEnd, cchSrcEnd, fd.cFileName);
                }
                StringCchCopy (lpDestEnd, cchDestEnd, fd.cFileName);


                //
                // Do not reconcile the log file if we are using the tmp hive
                // file. Skip it.
                //

                if((dwFlags & CPD_USETMPHIVEFILE) &&
                    lstrcmpi(fd.cFileName + lstrlen(fd.cFileName) - lstrlen(c_szLog), c_szLog) == 0) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Log file %s skipped"), lpDestDir));
                    continue;
                }

                //
                // Skip the temporary hive file here. Will deal with it when
                // we find an actual hive file.
                //

                if(lstrcmpi(fd.cFileName, c_szNTUserTmp) == 0) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: %s skipped"), fd.cFileName));
                    continue;
                }

                DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Found hive file %s"), fd.cFileName));
                    
                if(!ReconcileFile(lpSrcDir, lpDestDir, dwFlags, NULL,
                                  fd.nFileSizeLow, TRUE)) {
                    dwErr1 = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: ReconcileFile failed with error = %d"), dwErr1));
                    if (!(dwFlags & CPD_IGNORECOPYERRORS)) {
                        dwErr = dwErr1;
                        ReportError(hTokenUser,
                                    PI_NOUI,
                                    3,
                                    EVENT_COPYERROR,
                                    lpSrcDir,
                                    lpDestDir,
                                    GetErrString(dwErr, szErr));
                        FindClose(hFile);
                        goto Exit;
                    }
                    else {
                        ReportError(hTokenUser,
                                    PI_NOUI | EVENT_WARNING_TYPE,
                                    3,
                                    EVENT_COPYERROR,
                                    lpSrcDir,
                                    lpDestDir,
                                    GetErrString(dwErr1, szErr));
                    }
                }

                
            //
            // Find the next entry
            //

            } while (FindNextFile(hFile, &fd));

            FindClose(hFile);

            dwErr = ERROR_SUCCESS;

        } else {
            dwErr = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: FindFirstFile failed to find a hive!.  Error = %d"),
                     dwErr));
        }
    }


    //
    //  Create all the directories
    //

    if (!(dwFlags & CPD_COPYHIVEONLY)) {

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Calling ReconcileDirectory for all Directories")));

        lpTemp = lpSrcDirs;

        while (lpTemp) {

            if (!ReconcileDirectory(lpTemp->szSrc, lpTemp->szDest, dwFlags, lpTemp->dwFileAttribs)) {
                dwErr1 = GetLastError();

                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to create the destination directory <%s>.  Error = %d"),
                         lpTemp->szDest, GetLastError()));

                if (!(dwFlags & CPD_IGNORECOPYERRORS)) {
                    //
                    // Show the error UI and bail out.
                    //

                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                    dwErr = dwErr1;
                    goto Exit;
                }
                else {
                    ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                                lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                }
            }

            lpTemp = lpTemp->pNext;
        }

        DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Reconcile Directory Done for all Directories")));

        //
        // Copy the files
        //

        if (dwFlags & CPD_SLOWCOPY) {

            //
            // Copy the files one at a time...
            //

            lpTemp = lpSrcFiles;

            while (lpTemp) {

                if (lpTemp->bHive) {

                    //
                    // Hive files have already been copied..
                    //

                    lpTemp = lpTemp->pNext;
                    continue;
                }

                if (!ReconcileFile (lpTemp->szSrc, lpTemp->szDest, dwFlags,
                                    &lpTemp->ftLastWrite, 
                                    lpTemp->dwFileSize, FALSE)) {

                    dwErr1 = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to copy the file <%s> to <%s> due to error = %d"),
                             lpTemp->szSrc, lpTemp->szDest, GetLastError()));

                    if (!(dwFlags & CPD_IGNORECOPYERRORS)) {

                        //
                        // Show the error UI and since the user picks to abort
                        // then we leave now.
                        //

                        ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                    lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));

                        dwErr = dwErr1;
                        goto Exit;
                    }
                    else {
                        ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                                    lpTemp->szSrc, lpTemp->szDest, GetErrString(dwErr1, szErr));
                    }
                }

                lpTemp = lpTemp->pNext;
            }

        } else {

            if (lpSrcFiles) {

                HANDLE hThreadToken=NULL;


                if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE,
                                 TRUE, &hThreadToken)) {
                    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Failed to get token with %d. This is ok if thread is not impersonating"),
                             GetLastError()));
                }


                //
                // Multi-threaded copy
                //

                // Null sd, auto set, initially signalled, unnamed..

                if (!(ThreadInfo.hCopyEvent = CreateEvent(NULL, FALSE, TRUE, NULL))) {
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: CreateEvent for CopyEvent failed with error %d"), GetLastError()));
                    dwErr = GetLastError();
                    goto Exit;
                }

                ThreadInfo.dwFlags = dwFlags;
                ThreadInfo.lpSrcFiles = lpSrcFiles;
                ThreadInfo.hTokenUser = hTokenUser;

                //
                // Required for PrivCopyFileEx to work, threads should be created using the
                // process token
                //
                
                RevertToSelf();

                //
                // Create the file copy threads
                //

                for (i = 0; i < NUM_COPY_THREADS; i++) {

                    if (hThreads[dwThreadCount] = CreateThread (NULL,
                                                    0,
                                                    (LPTHREAD_START_ROUTINE) CopyFileFunc,
                                                    (LPVOID) &ThreadInfo,
                                                    CREATE_SUSPENDED,
                                                    &dwThreadId)) {
                        dwThreadCount++;
                    }
                }


                //
                // Put the token back.
                //

                if (!SetThreadToken(NULL, hThreadToken)) {
                    DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Impersonation failed with error %d"), GetLastError()));
                    dwErr = GetLastError();       

                    // terminate and close handles for all the threads 
                    for (i = 0; i < dwThreadCount; i++) {
                        TerminateThread (hThreads[i], 1);
                        CloseHandle (hThreads[i]);                        
                    }

                    if (hThreadToken)
                        CloseHandle (hThreadToken);

                    goto Exit;
                }


                for (i = 0; i < dwThreadCount; i++) {
                    if (!SetThreadToken(&hThreads[i], hThreadToken) || !ResumeThread (hThreads[i])) {
                        ThreadInfo.dwError = GetLastError();
                        TerminateThread(hThreads[i], 1);
                    }
                }

                //
                // Wait for the threads to finish
                //

                if (WaitForMultipleObjects (dwThreadCount, hThreads, TRUE, INFINITE) == WAIT_FAILED) {
                    ThreadInfo.dwError = GetLastError();
                }

                //
                // Clean up
                //

                if (hThreadToken)
                    CloseHandle (hThreadToken);

                for (i = 0; i < dwThreadCount; i++) {
                    CloseHandle (hThreads[i]);
                }


                if (ThreadInfo.dwError) {
                    dwErr = ThreadInfo.dwError;
                    goto Exit;
                }
            }
        }
    }


    //
    // Restore the time on the directories to be the same as from Src.
    // This is required because the times on directory have been modified by 
    // creation and deletion of files above.
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Setting Directory TimeStamps all Directories")));

    lpTemp = lpSrcDirs;

    while (lpTemp) {

        HANDLE hDestFile;

        SetFileAttributes (lpTemp->szDest, FILE_ATTRIBUTE_NORMAL);

        hDestFile = CreateFile(lpTemp->szDest, GENERIC_WRITE,
                            FILE_SHARE_DELETE | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);

        if (hDestFile != INVALID_HANDLE_VALUE) {
            if (!SetFileTime(hDestFile, NULL, NULL, &(lpTemp->ftLastWrite))) {
                DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: Failed to set the write time on the directory <%s>.  Error = %d"),
                             lpTemp->szDest, GetLastError()));
            }

            CloseHandle(hDestFile);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CopyProfileDirectoryEx: CreateFile failed for directory %s with error %d"), lpTemp->szDest, 
                                      GetLastError()));
        }

        SetFileAttributes (lpTemp->szDest, lpTemp->dwFileAttribs);

        lpTemp = lpTemp->pNext;
    }

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Set times on all directories")));

    //
    // Success
    //

    bResult = TRUE;


Exit:

    if (ThreadInfo.hCopyEvent) {
        CloseHandle (ThreadInfo.hCopyEvent);
    }

    if ( ThreadInfo.hDesktop ) {
        CloseDesktop( ThreadInfo.hDesktop );
    }

    //
    // Free the memory allocated above
    //

    if (hTokenUser) {
        CloseHandle(hTokenUser);
    }

    if (lpSrcDir) {
        LocalFree(lpSrcDir);
    }

    if (lpDestDir) {
        LocalFree(lpDestDir);
    }

    if (lpExcludeListSrc) {
        LocalFree (lpExcludeListSrc);
    }

    if (lpExcludeListDest) {
        LocalFree (lpExcludeListDest);
    }

    if (lpSrcFiles) {
        FreeFileInfoList(lpSrcFiles);
    }

    if (lpDestFiles) {
        FreeFileInfoList(lpDestFiles);
    }

    if (lpSrcDirs) {
        FreeFileInfoList(lpSrcDirs);
    }

    if (lpDestDirs) {
        FreeFileInfoList(lpDestDirs);
    }

    SetLastError(dwErr);

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CopyProfileDirectoryEx: Leaving with a return value of %d"), bResult));

    return bResult;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectory coping files.
//
//  Parameters: hTokenUser    -   User's token
//              lpSrcDir      -   Source directory working buffer
//              lpDestDir     -   Destination directory working buffer
//              dwFlags       -   dwFlags
//              llSrcDirs     -   Link list of directories
//              llSrcFiles    -   Link list of files
//              bSkipNtUser   -   Skip ntuser.* files
//              lpExcludeList -   List of directories to exclude
//              bRecurseDest  -   The destination Dir is being recursed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   1)  The source and dest directories will already have
//                  the trailing backslash when entering this function.
//              2)  The current working directory is the source directory.
//
//
// Notes:
//      CPD_SYSTEMDIRSONLY  Do not keep track of anything unless the dir is
//                          marked with system bit.
//      CPD_SYSTEMFILES     Only Systemfiles
//      CPD_NONENCRYPTEDONLY Only Non EncryptedFile/Directory.
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

BOOL RecurseDirectory (HANDLE hTokenUser, LPTSTR lpSrcDir, DWORD cchSrcDir, 
                       LPTSTR lpDestDir, DWORD cchDestDir, DWORD dwFlags,
                       LPFILEINFO *llSrcDirs, LPFILEINFO *llSrcFiles,
                       BOOL bMarkNtUser, LPTSTR lpExcludeList, BOOL bRecurseDest)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTSTR lpSrcEnd, lpDestEnd, lpTemp;
    BOOL bResult = FALSE;
    BOOL bSkip;
    DWORD dwErr, dwErr1 = 0;
    LPTSTR szErr = NULL;
    WIN32_FIND_DATA* pfd = NULL;
    BOOL  bHive;
    DWORD cchSrcEnd, cchDestEnd;
    HRESULT hr;

    dwErr = GetLastError();


    //
    // Setup the ending pointers
    //

    lpSrcEnd = CheckSlashEx (lpSrcDir, cchSrcDir, &cchSrcEnd);

    if (!lpSrcEnd)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        DebugMsg((DM_WARNING, TEXT("RecurseDirectory: failed to append slash to src dir.")));
        goto RecurseDir_Exit;
    }

    lpDestEnd = CheckSlashEx (lpDestDir, cchDestDir, &cchDestEnd);

    if (!lpDestEnd)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        DebugMsg((DM_WARNING, TEXT("RecurseDirectory: failed to append slash to dest dir.")));
        goto RecurseDir_Exit;
    }

    //
    // Append *.* to the source directory
    //

    hr = StringCchCopy (lpSrcEnd, cchSrcEnd, c_szStarDotStar);

    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("RecurseDirectory: failed to append '*.*' to src dir.")));
        goto RecurseDir_Exit;
    }

    //
    //  Allocate fd. Since this is a recursive func, we don't want to use a lot of stack space
    //
    
    pfd = (WIN32_FIND_DATA *) LocalAlloc (LPTR, sizeof(WIN32_FIND_DATA));

    if (!pfd)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RecurseDirectory: failed to allocate WIN32_FIND_DATA.")));
        goto RecurseDir_Exit;
    }

    //
    // Allocate szErr.
    //

    szErr = (LPTSTR) LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));
    
    if (!szErr)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RecurseDirectory: failed to allocate szErr.")));
        goto RecurseDir_Exit;
    }
    
    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpSrcDir, pfd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            bResult = TRUE;
            
        } else {
        
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: FindFirstFile failed.  Error = %d"), dwErr1));

            *lpSrcEnd = TEXT('\0');
            *lpDestEnd = TEXT('\0');

            if (!(dwFlags & CPD_IGNORECOPYERRORS)) {

                if (!bRecurseDest) {
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpSrcDir, lpDestDir, GetErrString(dwErr1, szErr));
                }
                else {
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                                lpDestDir, lpSrcDir, GetErrString(dwErr1, szErr));
                }
            
                dwErr = dwErr1;
                bResult = FALSE;
            }
            else // Ignore copy error, so we just set return value to TRUE
            {
                bResult = TRUE;
            }
        }

        goto RecurseDir_Exit;
    }


    do {

        bHive = FALSE;

        //
        // Check whether we have enough space in our buffers
        //

        *lpSrcEnd = TEXT('\0');
        *lpDestEnd = TEXT('\0');

        if ((lstrlen(lpSrcDir)+lstrlen(pfd->cFileName) >= MAX_PATH) ||
            (lstrlen(lpDestDir)+lstrlen(pfd->cFileName) >= MAX_PATH)) {

            LPTSTR lpErrSrc=NULL, lpErrDest=NULL;
            DWORD cchErrSrc, cchErrDest;
            BOOL bRet;

            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: %s is too long. src = %s, dest = %s"), pfd->cFileName, lpSrcDir, lpDestDir));

            if (dwFlags & CPD_IGNORELONGFILENAMES) 
                continue;

            //
            // Allocate a buffer to show the file names
            //

            cchErrSrc = lstrlen(lpSrcDir)+lstrlen(pfd->cFileName)+1;
            cchErrDest = lstrlen(lpDestDir)+lstrlen(pfd->cFileName)+1;
            lpErrSrc = LocalAlloc(LPTR, cchErrSrc * sizeof(TCHAR));
            lpErrDest = LocalAlloc(LPTR, cchErrDest * sizeof(TCHAR));
            
            //
            // Show the UI
            //
            
            if ((!lpErrSrc) || (!lpErrDest)) {
            
                if (!bRecurseDest) {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpSrcDir, lpDestDir, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                } else {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpDestDir, lpSrcDir, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                }
            }
            else {
                
                StringCchCopy(lpErrSrc, cchErrSrc, lpSrcDir); 
                StringCchCat(lpErrSrc, cchErrSrc, pfd->cFileName);
                
                StringCchCopy(lpErrDest, cchErrDest, lpDestDir);
                StringCchCat(lpErrDest, cchErrDest, pfd->cFileName);
                
                if (!bRecurseDest) {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpErrSrc, lpErrDest, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                } else {
                
                    ReportError(hTokenUser, ((dwFlags & CPD_NOERRORUI)? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpErrDest, lpErrSrc, GetErrString(ERROR_FILENAME_EXCED_RANGE, szErr));
                }
            }
            
            if (lpErrSrc)
                LocalFree(lpErrSrc);
            if (lpErrDest)
                LocalFree(lpErrDest);
            
               
            //
            // Set the error and quit.
            //
                
            dwErr = ERROR_FILENAME_EXCED_RANGE;
            bResult = FALSE;
            goto RecurseDir_Exit;
            
        }

        //
        // Append the file / directory name to the working buffers
        //

        StringCchCopy (lpSrcEnd, cchSrcEnd, pfd->cFileName);
        StringCchCopy (lpDestEnd, cchDestEnd, pfd->cFileName);


        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(pfd->cFileName, c_szDot)) {
                continue;
            }

            if (!lstrcmpi(pfd->cFileName, c_szDotDot)) {
                continue;
            }

            //
            // Check for reparse point
            //

            if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: Found a reparse point <%s>,  skip it!"), lpSrcDir));
                continue;
            }

            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpSrcDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> due to exclusion list."),
                             lpSrcDir));
                    continue;
               }
            }


            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Add to the list of directories
            //

            if (dwFlags & CPD_SYSTEMDIRSONLY) {

                //
                // if it is encrypted, don't recurse into it
                //

                if (!(pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {

                    DWORD dwNewFlags = dwFlags;

                    //
                    // Add to the list of directories only if marked as system, o/w just recurse through
                    //

                    if (pfd->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) {
                        if (!AddFileInfoNode (llSrcDirs, lpSrcDir, lpDestDir, &pfd->ftLastWriteTime,
                                              &pfd->ftCreationTime, 0, pfd->dwFileAttributes, bHive)) {
                            DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                            dwErr = GetLastError();
                            goto RecurseDir_Exit;
                        }

                        dwNewFlags ^= CPD_SYSTEMDIRSONLY;
                        DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Adding %s to the list of directories because system bit is on"), lpSrcDir));
                    }

                    //
                    // Recurse the subdirectory
                    //

                    if (!RecurseDirectory(hTokenUser, lpSrcDir, cchSrcDir, lpDestDir, cchDestDir, dwNewFlags,
                                          llSrcDirs, llSrcFiles, FALSE, lpExcludeList, bRecurseDest)) {
                        DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: RecurseDirectory returned FALSE")));
                        bResult = FALSE;
                        dwErr = GetLastError();
                        goto RecurseDir_Exit;
                    }

                } else {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set."),
                             lpSrcDir));
                }

                continue;
            }

            //
            // Popup time
            //

            if (dwFlags & CPD_NONENCRYPTEDONLY) {
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Detected Encrypted file %s, Aborting.."), lpSrcDir));
                    dwErr = ERROR_FILE_ENCRYPTED;
                    bResult = FALSE;
                    goto RecurseDir_Exit;
               }
            }

            //
            // Ignore encrypted file
            //

            if (dwFlags & CPD_IGNOREENCRYPTEDFILES) {
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set..."),
                             lpSrcDir));
                    continue;
               }
            }

            //
            // Add it to the list
            //

            if (!AddFileInfoNode (llSrcDirs, lpSrcDir, lpDestDir, &pfd->ftLastWriteTime,
                &pfd->ftCreationTime, 0, pfd->dwFileAttributes, bHive)) {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }
            
            //
            // Recurse the subdirectory
            //
            
            if (!RecurseDirectory(hTokenUser, lpSrcDir, cchSrcDir, lpDestDir, cchDestDir, dwFlags,
                llSrcDirs, llSrcFiles, FALSE, lpExcludeList, bRecurseDest)) {
                DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: RecurseDirectory returned FALSE")));
                bResult = FALSE;
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }
            
            DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Adding %s to the list of directories"), lpSrcDir));

        } else {

            //
            // if the directories only bit is set, don't copy anything else
            //

            if (dwFlags & CPD_SYSTEMDIRSONLY) {
                DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the system directories only attribute is set."),
                             lpSrcDir));
                continue;
            }

            //
            // If the filename found starts with "ntuser", then ignore
            // it because the hive will be copied below (if appropriate).
            //


            if (bMarkNtUser && lstrlen(pfd->cFileName) >= 6) {
                if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                   pfd->cFileName, 6,
                                   TEXT("ntuser"), 6) == CSTR_EQUAL) {
                    bHive = TRUE;
                }
            }

            //
            // Check if this file should be excluded
            //

            if (dwFlags & CPD_SYSTEMFILES) {
                if (!(pfd->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the system attribute is not set."),
                             lpSrcDir));
                    continue;
               }
            }

            //
            // if it is systemfile, it can not be encrypted. 
            //

            if (dwFlags & CPD_NONENCRYPTEDONLY) {
                
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {

                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Detected Encrypted file %s, Aborting..."), lpSrcDir));
                    dwErr = ERROR_FILE_ENCRYPTED;
                    bResult = FALSE;
                    goto RecurseDir_Exit;
               }
            }


            if (dwFlags & CPD_IGNOREENCRYPTEDFILES) {
                if (pfd->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                    DebugMsg((DM_VERBOSE, TEXT("RecurseDirectory: Skipping <%s> since the encrypted attribute is set."),
                             lpSrcDir));
                    continue;
               }
            }


            //
            // We found a file.  Add it to the list.
            //

            if (!AddFileInfoNode (llSrcFiles, lpSrcDir, lpDestDir,
                                  &pfd->ftLastWriteTime, &pfd->ftCreationTime,
                                  pfd->nFileSizeLow, pfd->dwFileAttributes, bHive)) {
                DebugMsg((DM_WARNING, TEXT("RecurseDirectory: AddFileInfoNode failed")));
                dwErr = GetLastError();
                goto RecurseDir_Exit;
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, pfd));

    bResult = TRUE;

RecurseDir_Exit:

    if (pfd)
        LocalFree(pfd);

    if (szErr)
        LocalFree(szErr);

    //
    // Remove the file / directory name appended above
    //

    if (lpSrcEnd)
        *lpSrcEnd = TEXT('\0');

    if (lpDestEnd)
        *lpDestEnd = TEXT('\0');


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    SetLastError(dwErr);
    return bResult;
}

//*************************************************************
//
//  CopyProgressRoutine()
//
//  Purpose:    Callback function for CopyFileEx
//
//  Parameters:  See doc's.
//
//  Return:     PROGRESS_CONTINUE
//
//*************************************************************

DWORD WINAPI CopyProgressRoutine(LARGE_INTEGER TotalFileSize,
                                 LARGE_INTEGER TotalBytesTransferred,
                                 LARGE_INTEGER StreamSize,
                                 LARGE_INTEGER StreamBytesTransferred,
                                 DWORD dwStreamNumber,
                                 DWORD dwCallbackReason,
                                 HANDLE hSourceFile,
                                 HANDLE hDestinationFile,
                                 LPVOID lpData)
{
    switch (dwCallbackReason)
    {
    case PRIVCALLBACK_ENCRYPTION_FAILED:
    case PRIVCALLBACK_COMPRESSION_FAILED:
    case PRIVCALLBACK_SPARSE_FAILED:
    case PRIVCALLBACK_OWNER_GROUP_FAILED:
    case PRIVCALLBACK_DACL_ACCESS_DENIED:
    case PRIVCALLBACK_SACL_ACCESS_DENIED:
    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        return PROGRESS_CANCEL;
    default:
        return PROGRESS_CONTINUE;   //all other conditions can be safely ignored
    }
}

//*************************************************************
//
//  ReconcileDirectory()
//
//  Purpose:     Compares the source and destination file.
//               If the source is newer, then it is copied
//               over the destination.
//
//  Parameters:  lpSrcDir   -   source filename
//               lpDestDir  -   destination filename
//               dwFlags    -   flags
//               dwSrcAttribs   Source Attributes for decompression,
//                              decryption later on.
//
//
//  Return:     1 if successful (no file copied)
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/26/99     ushaji     Created
//
//*************************************************************

BOOL ReconcileDirectory(LPTSTR lpSrcDir, LPTSTR lpDestDir, 
                        DWORD dwFlags, DWORD dwSrcAttribs)
{
    
    DWORD  dwCopyFlags=0, dwErr;
    BOOL   bCancel = FALSE;
    
    //
    // Clear any existing attributes
    //

    SetFileAttributes (lpDestDir, FILE_ATTRIBUTE_NORMAL);

    if (!CreateNestedDirectory(lpDestDir, NULL)) {        
        DebugMsg((DM_WARNING, TEXT("ReconcileDirectory: Failed to create the destination directory <%s>.  Error = %d"),
            lpDestDir, GetLastError()));
        return FALSE;
    }

    // 
    // Set up the copy flags to copy the encryption/compression on dirs over.
    //
    
    if (!(dwFlags & CPD_IGNORESECURITY))
        dwCopyFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SKIP_DACL;

     dwCopyFlags |= PRIVCOPY_FILE_DIRECTORY | PRIVCOPY_FILE_SUPERSEDE;


    if (!PrivCopyFileExW(lpSrcDir, lpDestDir,
                         (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                         NULL, &bCancel, dwCopyFlags)) {
        
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ReconcileDirectory: Failed to copy over the attributes src <%s> to destination directory <%s>.  Error = %d"),
            lpSrcDir, lpDestDir, dwErr));
        RemoveDirectory(lpDestDir);
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  ReconcileFile()
//
//  Purpose:     Compares the source and destination file.
//               If the source is newer, then it is copied
//               over the destination.
//
//  Parameters:  lpSrcFile  -   source filename
//               lpDestFile -   destination filename
//               dwFlags    -   flags
//               ftSrcTime  -   Src file time (can be NULL)
//               dwFileSize -   File size
//               bHiveFile  -   Flag to indicate hive file
//
//
//  Return:     1 if successful (no file copied)
//              2 if successful (and a file was copied)
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//              7/20/00     santanuc   added flag bHiveFile
//
//*************************************************************

INT ReconcileFile (LPCTSTR lpSrcFile, LPCTSTR lpDestFile,
                     DWORD dwFlags, LPFILETIME ftSrcTime,
                     DWORD dwFileSize, BOOL bHiveFile)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;
    FILETIME ftWriteSrc, ftWriteDest;
    INT iCopyFile = 0;
    DWORD dwErr = ERROR_SUCCESS, dwErr1 = 0;

    //
    // If the flags have CPD_FORCECOPY, then skip to the
    // copy file call without checking the timestamps.
    //

    if (!(dwFlags & CPD_FORCECOPY)) {


        //
        // If we were given a source file time, use that
        //

        if (ftSrcTime) {
            ftWriteSrc.dwLowDateTime = ftSrcTime->dwLowDateTime;
            ftWriteSrc.dwHighDateTime = ftSrcTime->dwHighDateTime;

        } else {


            //
            // Query for the source file time
            //

            if (!GetFileAttributesEx (lpSrcFile, GetFileExInfoStandard, &fad)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributes on the source failed with error = %d"),
                         dwErr));
                goto Exit;
            }

            ftWriteSrc.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            ftWriteSrc.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        }


        //
        // Attempt to open the destination file
        //

        if (!GetFileAttributesEx (lpDestFile, GetFileExInfoStandard, &fad)) {
            DWORD dwError;

            //
            // GetFileAttributesEx failed to query the destination
            // file.  If the last error is file not found
            // then we automaticaly will copy the file.
            //

            dwError = GetLastError();

            if (dwError == ERROR_FILE_NOT_FOUND) {

                iCopyFile = 1;

            } else {

                //
                // GetFileAttributesEx failed with some other error
                //

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributesEx on the destination failed with error = %d"),
                         dwError));
                dwErr = dwError;
                goto Exit;
            }

        } else {

            ftWriteDest.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            ftWriteDest.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        }

    } else {

        //
        // The CPD_FORCECOPY flag is turned on, set iCopyFile to 1.
        //

        iCopyFile = 1;
    }


    //
    // If iCopyFile is still zero, then we need to compare
    // the last write time stamps.
    //

    if (!iCopyFile) {
        LONG lResult;

        //
        // If the source is later than the destination
        // we need to copy the file.
        //

        lResult = CompareFileTime(&ftWriteSrc, &ftWriteDest);

        if (lResult == 1) {
            iCopyFile = 1;
        }

        if ( (dwFlags & CPD_COPYIFDIFFERENT) && (lResult == -1) ) {
            iCopyFile = 1;
        }
    }


    //
    // Copy the file if appropriate
    //

    if (iCopyFile) {
        BOOL bCancel = FALSE;
        TCHAR szTempFile[MAX_PATH];
        TCHAR szTempDir[MAX_PATH];
        LPTSTR lpTemp;
        DWORD  dwCopyFlags;

        //
        // Clear any existing attributes
        //

        SetFileAttributes (lpDestFile, FILE_ATTRIBUTE_NORMAL);
    
        if (!(dwFlags & CPD_IGNORESECURITY))
            dwCopyFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SKIP_DACL;
        else
            dwCopyFlags = 0;

        dwCopyFlags |= PRIVCOPY_FILE_SUPERSEDE;

        //
        // Figure out what the destination directory is
        //

        StringCchCopy (szTempDir, ARRAYSIZE(szTempDir), lpDestFile);
        lpTemp = szTempDir + lstrlen (szTempDir);

        while ((lpTemp > szTempDir) && (*lpTemp != TEXT('\\'))) {
            lpTemp--;
        }

        if (lpTemp == szTempDir) {
            StringCchCopy (szTempDir, ARRAYSIZE(szTempDir), TEXT("."));
        } else {
            *lpTemp = TEXT('\0');
        }


        //
        // Generate a temporary file name
        //

        if (GetTempFileName (szTempDir, TEXT("prf"), 0, szTempFile)) {


            //
            // Copy the file to the temp file name
            //

            if (PrivCopyFileExW(lpSrcFile, szTempFile,
                                (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                                NULL, &bCancel, dwCopyFlags)) {

                // If it is hive file then open the temporary file, flush and close it to make it more transacted

                if (bHiveFile) {
                    HANDLE hTempFile;

                    hTempFile = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if ( hTempFile != INVALID_HANDLE_VALUE ) {
                        if ( !FlushFileBuffers(hTempFile) ) 
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to flush temporary file")));

                        if ( !CloseHandle(hTempFile) ) 
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to close temporary file handle")));
                    }
                    else
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Unable to open temporary file")));
                }
                        

                //
                // Delete the original file
                //

                if (!DeleteFile (lpDestFile)) {
                    if (GetLastError() != ERROR_FILE_NOT_FOUND) {
                        dwErr1 = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Failed to delete file <%s> with error = %d"),
                                 lpDestFile, dwErr1));

                        DeleteFile(szTempFile);
                        goto CopyError;
                    }
                }


                //
                // Rename the temp file to the original file name
                //

                if (!MoveFile (szTempFile, lpDestFile)) {
                    DWORD dwError = ERROR_SUCCESS;   //isolate MoveFile error from other below
                    dwErr1 = GetLastError();

                    //
                    // If we get access denied, let's try to remove the READ ONLY attribute (can't rename files
                    // with +r attribute on a Netware Server) from the temp file, do the rename and restore the
                    // attributes
                    //
                    if ( dwErr1 == ERROR_ACCESS_DENIED ) {
                        if (!GetFileAttributesEx (szTempFile, GetFileExInfoStandard, &fad)) {
                            dwError = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetFileAttributes on file <%s> failed with error = %d\n"),
                                     szTempFile,dwError));
                        } else {
                            if ( fad.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) {
                                dwErr1 = ERROR_SUCCESS ;
                                if (!SetFileAttributes (szTempFile, fad.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                                    dwError = GetLastError();
                                    DebugMsg((DM_WARNING, TEXT("ReconcileFile: SetFileAttributes on file <%s> failed with error = %d\n"),
                                             szTempFile,dwError));
                                } else {
                                    if (!MoveFile (szTempFile,lpDestFile)) {
                                        // Debug message displayed below
                                        dwErr1 = GetLastError();
                                    } else {
                                        if ( !SetFileAttributes (lpDestFile,fad.dwFileAttributes) ) {
                                            dwError = GetLastError();
                                            DebugMsg((DM_WARNING, TEXT("ReconcileFile: SetFileAttributes on file <%s> failed with error = %d\n"),
                                                     szTempFile,dwError));
                                        }
                                    }
                                }
                            }
                        }
                    }   // End of ERROR_ACCESS_DENIED test

                    if (dwErr1 != ERROR_SUCCESS || dwError != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("ReconcileFile: Failed to rename file <%s> to <%s> with error = %d"),
                                 szTempFile, lpDestFile, dwErr1));

                        // do not remove it in this case.
                        goto CopyError;
                    }
                }

                DebugMsg((DM_VERBOSE, TEXT("ReconcileFile: %s ==> %s  [OK]"),
                         lpSrcFile, lpDestFile));
                iCopyFile = 2;

            } else {
                dwErr1 = GetLastError();
                DeleteFile(szTempFile);

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: %s ==> %s  [FAILED!!!]"),
                         lpSrcFile, szTempFile));

                DebugMsg((DM_WARNING, TEXT("ReconcileFile: CopyFile failed with error = %d"),
                         dwErr1));

                goto CopyError;
            }

        } else {
            dwErr1 = GetLastError();

            DebugMsg((DM_WARNING, TEXT("ReconcileFile: GetTempFileName failed with %d"),
                     dwErr1));

            goto CopyError;
        }

    } else {

        //
        // No need to copy the file since the time stamps are the same
        // Set iCopyFile to 1 so the return value is success without
        // copying a file.
        //

        iCopyFile = 1;
    }
    goto Exit;

CopyError:
    iCopyFile = 0;
    dwErr = dwErr1;

Exit:

    SetLastError(dwErr);
    return iCopyFile;
}


//*************************************************************
//
//  AddFileInfoNode()
//
//  Purpose:    Adds a node to the linklist of files
//
//  Parameters: lpFileInfo     -   Link list to add to
//              lpSrcFile      -   Source filename
//              lpDestFile     -   Destination filename
//              ftLastWrite    -   Last write time stamp
//              ftCreationTime -   File creation time
//              dwFileSize     -   Size of the file
//              dwFileAttribs  - File attributes
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL AddFileInfoNode (LPFILEINFO *lpFileInfo, LPTSTR lpSrcFile,
                      LPTSTR lpDestFile, LPFILETIME ftLastWrite,
                      LPFILETIME ftCreationTime, DWORD dwFileSize,
                      DWORD dwFileAttribs, BOOL bHive)
{
    LPFILEINFO lpNode;


    lpNode = (LPFILEINFO) LocalAlloc(LPTR, sizeof(FILEINFO));

    if (!lpNode) {
        return FALSE;
    }


    StringCchCopy (lpNode->szSrc, MAX_PATH, lpSrcFile);
    StringCchCopy (lpNode->szDest, MAX_PATH, lpDestFile);

    lpNode->ftLastWrite.dwLowDateTime = ftLastWrite->dwLowDateTime;
    lpNode->ftLastWrite.dwHighDateTime = ftLastWrite->dwHighDateTime;

    lpNode->ftCreationTime.dwLowDateTime = ftCreationTime->dwLowDateTime;
    lpNode->ftCreationTime.dwHighDateTime = ftCreationTime->dwHighDateTime;

    lpNode->dwFileSize = dwFileSize;
    lpNode->bHive = bHive;
    lpNode->dwFileAttribs = (dwFileAttribs & ~FILE_ATTRIBUTE_DIRECTORY);

    lpNode->pNext = *lpFileInfo;

    *lpFileInfo = lpNode;

    return TRUE;

}

//*************************************************************
//
//  FreeFileInfoList()
//
//  Purpose:    Free's a file info link list
//
//  Parameters: lpFileInfo  -   List to be freed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL FreeFileInfoList (LPFILEINFO lpFileInfo)
{
    LPFILEINFO lpNext;


    if (!lpFileInfo) {
        return TRUE;
    }


    lpNext = lpFileInfo->pNext;

    while (lpFileInfo) {
        LocalFree (lpFileInfo);
        lpFileInfo = lpNext;

        if (lpFileInfo) {
            lpNext = lpFileInfo->pNext;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  SyncItems()
//
//  Purpose:    Removes unnecessary items from the destination
//              directory tree
//
//  Parameters: lpSrcItems  -   Link list of source items
//              lpDestItems -   Link list of dest items
//              bFile       -   File or directory list
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              9/28/95     ericflo    Created
//
//*************************************************************

BOOL SyncItems (LPFILEINFO lpSrcItems, LPFILEINFO lpDestItems,
                BOOL bFile, LPFILETIME ftDelRefTime)
{
    LPFILEINFO lpTempSrc, lpTempDest;


    //
    // Check for NULL pointers
    //

#ifdef DBG
    if (ftDelRefTime)
    {
        SYSTEMTIME SystemTime;
        FileTimeToSystemTime(ftDelRefTime, &SystemTime); 
        DebugMsg((DM_VERBOSE, TEXT("SyncItems: DelRefTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
    }
#endif                 

    if (!lpSrcItems || !lpDestItems) {
        return TRUE;
    }


    //
    // Loop through everyitem in lpDestItems to see if it
    // is in lpSrcItems.  If not, delete it.
    //

    lpTempDest = lpDestItems;

    while (lpTempDest) {

        lpTempSrc = lpSrcItems;

        while (lpTempSrc) {

            if (lstrcmpi(lpTempDest->szSrc, lpTempSrc->szDest) == 0) {
                break;
            }

            lpTempSrc = lpTempSrc->pNext;
        }

        //
        // If lpTempSrc is NULL, then this file / directory is a candidate
        // for being deleted
        //

        if (!lpTempSrc) {
            BOOL bDelete = TRUE;


            //
            // If a delete reference time was offered, compare the
            // source time with the ref time and only delete files
            // which have a source time older than the ref time
            //

            if (ftDelRefTime) {

                if (CompareFileTime (&lpTempDest->ftLastWrite, ftDelRefTime) == 1) {                    
                    bDelete = FALSE;
                }
                else if (CompareFileTime (&lpTempDest->ftCreationTime, ftDelRefTime) == 1) {
                    bDelete = FALSE;
                }
            }


            if (bDelete) {

                //
                // Delete the file / directory
                //

                DebugMsg((DM_VERBOSE, TEXT("SyncItems: removing <%s>"),
                         lpTempDest->szSrc));


                if (bFile) {
                   SetFileAttributes(lpTempDest->szSrc, FILE_ATTRIBUTE_NORMAL);
                   if (!DeleteFile (lpTempDest->szSrc)) {
                       DebugMsg((DM_WARNING, TEXT("SyncItems: Failed to delete <%s>.  Error = %d."),
                                lpTempDest->szSrc, GetLastError()));
                   }

                } else {
                   SetFileAttributes(lpTempDest->szSrc, FILE_ATTRIBUTE_NORMAL);
                   if (!RemoveDirectory (lpTempDest->szSrc)) {
                       DebugMsg((DM_WARNING, TEXT("SyncItems: Failed to remove <%s>.  Error = %d"),
                                lpTempDest->szSrc, GetLastError()));
                   }

                }
            }
            else
            {
                    DebugMsg((DM_VERBOSE, TEXT("SyncItems: New file or directory <%s> in destination since this profile was loaded.  This will NOT be deleted."),
                              lpTempDest->szSrc));
#ifdef DBG
                    {
                        SYSTEMTIME SystemTime;
                        FileTimeToSystemTime(&lpTempDest->ftLastWrite, &SystemTime); 
                        DebugMsg((DM_VERBOSE, TEXT("SyncItems: File WriteTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                                                     SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
                        FileTimeToSystemTime(&lpTempDest->ftCreationTime, &SystemTime); 
                        DebugMsg((DM_VERBOSE, TEXT("SyncItems: File CreationTime. Year: %d, Month %d, Day %d, Hour %d, Minute %d"), SystemTime.wYear, 
                                                                     SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute));                
                    }
#endif                 
            }
        }

        lpTempDest = lpTempDest->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  CopyFileFunc()
//
//  Purpose:    Copies files
//
//  Parameters: lpThreadInfo    -   Thread information
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/23/96     ericflo    Created
//
//*************************************************************

void CopyFileFunc (LPTHREADINFO lpThreadInfo)
{
    HANDLE      hInstDll;
    LPFILEINFO  lpSrcFile;
    BOOL        bRetVal = TRUE;
    DWORD       dwError;
    TCHAR       szErr[MAX_PATH];

    hInstDll = LoadLibrary (TEXT("userenv.dll"));

    SetThreadDesktop (lpThreadInfo->hDesktop);

    while (TRUE) {

        if (lpThreadInfo->dwError) {
            break;
        }

        //
        // Query for the next file to copy..
        // ignore the hive file since it is already copied..
        //

        WaitForSingleObject(lpThreadInfo->hCopyEvent, INFINITE);

        do {
            lpSrcFile = lpThreadInfo->lpSrcFiles;
            if (lpSrcFile)
                lpThreadInfo->lpSrcFiles = lpThreadInfo->lpSrcFiles->pNext;

        } while (lpSrcFile && (lpSrcFile->bHive));


        SetEvent(lpThreadInfo->hCopyEvent);


        //
        // If NULL, then we're finished.
        //

        if (!lpSrcFile || lpThreadInfo->dwError) {
            break;
        }


        //
        // Copy the file
        //

        if (!ReconcileFile (lpSrcFile->szSrc, lpSrcFile->szDest,
                            lpThreadInfo->dwFlags, &lpSrcFile->ftLastWrite,
                            lpSrcFile->dwFileSize, FALSE)) {

            if (!(lpThreadInfo->dwFlags & CPD_IGNORECOPYERRORS)) {

                WaitForSingleObject(lpThreadInfo->hCopyEvent, INFINITE);
                
                if (!(lpThreadInfo->dwError)) {
                    dwError = GetLastError();

                    ReportError(lpThreadInfo->hTokenUser, ((lpThreadInfo->dwFlags & CPD_NOERRORUI) ? PI_NOUI:0), 3, EVENT_COPYERROR, 
                            lpSrcFile->szSrc, lpSrcFile->szDest, GetErrString(dwError, szErr));

                    lpThreadInfo->dwError = dwError;
                    bRetVal = FALSE;
                }

                SetEvent(lpThreadInfo->hCopyEvent);
                break;
            }
            else {
                dwError = GetLastError();
                ReportError(lpThreadInfo->hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 3, EVENT_COPYERROR, 
                            lpSrcFile->szSrc, lpSrcFile->szDest, GetErrString(dwError, szErr));
            }
        }
    }
    
    //
    // Clean up
    //

    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, bRetVal);
    } else {
        ExitThread (bRetVal);
    }
}


//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;  
    HRESULT hr = E_FAIL;
    DWORD cchEnd;

    //
    // Setup a temp buffer to work with
    //

    hr = StringCchCopy (szTemp, ARRAYSIZE(szTemp), lpSourceDir);
    
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to copy src dir.")));
        goto Exit;
    }

    lpEnd = CheckSlashEx (szTemp, ARRAYSIZE(szTemp), &cchEnd);

    if (!lpEnd)
    {
        hr = E_FAIL;
        DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to append slash.")));
        goto Exit;
    }


    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }


        //
        // Remove any leading spaces
        //

        while (*lpDir && ((*lpDir) == TEXT(' '))) {
            lpDir++;
        }

        //
        //  Skip empty entry
        //
        if (lpTemp != lpDir)
        {
            //
            // Note: 
            // Empty Spaces will not make the whole profile dir excluded
            // in RecurseDirectory.
            //

            //
            // Put the directory name on the temp buffer, not include ';'
            //

            *lpEnd = TEXT('\0');
            hr = StringCchCatN (lpEnd, cchEnd, lpDir, (int)(lpTemp - lpDir));
            
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to append new list item.")));
                goto Exit;
            }
            
            DebugMsg((DM_VERBOSE, TEXT("ConvertExclusionList: Adding %s to ExclusionList"), szTemp));

            //
            // Add the string to the exclusion list
            //

            if (lpExcludeList) {

                dwStrLen = lstrlen (szTemp) + 1;
                dwSize += dwStrLen;

                lpTempList = LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                           LMEM_MOVEABLE | LMEM_ZEROINIT);

                if (!lpTempList) {
                    hr = E_FAIL;
                    DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to realloc memory with %d"), GetLastError()));
                    goto Exit;
                }

                lpExcludeList = lpTempList;

                lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
                StringCchCopy (lpInsert, dwStrLen, szTemp);

            } else {

                dwSize += lstrlen (szTemp);
                lpExcludeList = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

                if (!lpExcludeList) {
                    hr = E_FAIL;
                    DebugMsg((DM_WARNING, TEXT("ConvertExclusionList: Failed to alloc memory with %d"), GetLastError()));
                    goto Exit;
                }

                StringCchCopy (lpExcludeList, dwSize, szTemp);
                lpExcludeList[dwSize - 1] = TEXT('\0'); // The last null terminator 
            }
        }

        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            break;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

    hr = S_OK;

Exit:

    if (FAILED(hr))
    {
        if (lpExcludeList)
        {
            LocalFree(lpExcludeList);
            lpExcludeList = NULL;
        }
    }
    return lpExcludeList;
}

//*************************************************************
//
//  FindDirectorySize()
//
//  Purpose:    Takes the Directory Name and the list of files
//              returned by RecurseDir and gets the total size.
//
//  Parameters: lpDir          -  '\' terminated Source Directory 
//              lpFiles        -  List of files to be copied
//              dwFlags        -  Flags
//              pdwLargestHiveFile  - optional parameter that
//                                    returns the largest hive
//                                    file size.
//              pdwTotalFiles  - the size of the directory
//
//  Return:     Win32 error code.
//
//*************************************************************

DWORD FindDirectorySize(LPTSTR lpDir, LPFILEINFO lpFiles, DWORD dwFlags, DWORD* pdwLargestHiveFile, DWORD* pdwTotalFiles)
{
    LPFILEINFO      lpTemp = NULL;

    if(pdwLargestHiveFile) {
        *pdwLargestHiveFile = 0;
    }
    if(!pdwTotalFiles) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
    else {
        *pdwTotalFiles = 0;
    }

    lpTemp = lpFiles;

    while (lpTemp) {
        if (lpTemp->bHive) {
            if (!(dwFlags & CPD_IGNOREHIVE)) {
                if(pdwLargestHiveFile && (*pdwLargestHiveFile < lpTemp->dwFileSize)) {
                    *pdwLargestHiveFile = lpTemp->dwFileSize;
                }
                
                *pdwTotalFiles += lpTemp->dwFileSize;
            }
        }
        else {
            *pdwTotalFiles += lpTemp->dwFileSize;
        }

        lpTemp = lpTemp->pNext;
    }
    
    return ERROR_SUCCESS;
}


//*************************************************************
//
//  FindTotalDiskSpaceNeeded()
//
//  Purpose:    Calculate the maximum amount of disk space on the
//              destination drive that is needed to reconcile the
//              source and the destination directories. The
//              algorithm is as follows:
//                  max(source size, destination size) +
//                  NUM_COPY_THREADS * size of the largest file in source dir -
//                  destination size
//              The reason for this algorithm is that the copy
//              operation is done by NUM_COPY_THREADS threads.
//              They copy the files to a temp file and then delete
//              the destination file and rename the temp file.
//
//  Parameters: dwTotalSrcFiles   total size of the source files 
//              dwTotalDestFiles  total size of the destination files
//              dwLargestHiveFile largest hive file                   
//              lpSrcFiles        List of source files
//              dwFlags        -  Flags
//
//  Return:     Disk space needed.
//
//  History:    Created     WeiruC      2/10/2000
//
//*************************************************************

DWORD FindTotalDiskSpaceNeeded(DWORD        dwTotalSrcFiles,
                               DWORD        dwTotalDestFiles,
                               DWORD        dwLargestHiveFile,
                               LPFILEINFO   lpSrcFiles,
                               DWORD        dwFlags)
{
    DWORD       dwNumOfCopyThreads = NUM_COPY_THREADS;
    DWORD       dwDiskSpaceNeeded = 0;
    LPFILEINFO  lpCur = lpSrcFiles;
    DWORD       i, j;          // loop counters


    //
    // Check for empty file list.
    //

    if(!lpSrcFiles) {
        return dwLargestHiveFile;
    }


    //
    // How many copy threads are there actually?
    //

    if(dwFlags & CPD_SLOWCOPY) {
        dwNumOfCopyThreads = 1;
    }


    //
    // Find the size of the largest file in the source file list. The hive
    // files are not in this file list, be careful not to forget them. Hive
    // files have to be treated very carefully because they are always copied
    // over before we create those copy threads.
    //

    dwDiskSpaceNeeded = FindTotalNMaxFileSize(lpSrcFiles, dwNumOfCopyThreads);

    DebugMsg((DM_VERBOSE, TEXT("FindTotalDiskSpaceNeeded: Largest %d file size is %d"), dwNumOfCopyThreads, dwDiskSpaceNeeded)); 


    //
    // The actual disk space needed.
    //

    if(dwDiskSpaceNeeded < dwLargestHiveFile) {
        dwDiskSpaceNeeded = dwLargestHiveFile;
    }

    if(dwTotalSrcFiles > dwTotalDestFiles) {
        dwDiskSpaceNeeded += dwTotalSrcFiles - dwTotalDestFiles;
    }

    //
    // It is too much of a pain to actually figure out cluster size impact.
    // We'll just add an extra 10% of the disk space needed.
    //

    dwDiskSpaceNeeded += dwDiskSpaceNeeded / 10;

    return dwDiskSpaceNeeded;
}

//*************************************************************
//
//  FindTotalNMaxFileSize()
//
//  Purpose:    Calculates the total size for dwNumOfFiles
//              number of largest files. 
//
//  Parameters: lpSrcFiles     -  List of source files
//              dwNumOfFiles   -  Number of files. 
//                                dwNumOfFiles <= NUM_COPY_THREADS
//
//  Return:     Disk space needed for n largest files.
//
//  History:    Created     santanuc      10/03/2000
//
//*************************************************************
DWORD FindTotalNMaxFileSize(LPFILEINFO lpSrcFiles, DWORD dwNumOfFiles) 
{
    DWORD      pdwNMaxVal[NUM_COPY_THREADS], dwIndex;
    LPFILEINFO lpCur;
    DWORD      dwTotalSize = 0, dwTmp;

    if (!lpSrcFiles)
        return 0;

    for(dwIndex = 0; dwIndex < dwNumOfFiles; dwIndex++) {
        pdwNMaxVal[dwIndex] = 0;
    }

    for(lpCur = lpSrcFiles; lpCur; lpCur = lpCur->pNext) {
        if (!lpCur->bHive) {
            dwIndex = dwNumOfFiles-1;
            if (lpCur->dwFileSize > pdwNMaxVal[dwIndex]) {
                pdwNMaxVal[dwIndex] = lpCur->dwFileSize;

                while (dwIndex > 0 && pdwNMaxVal[dwIndex] > pdwNMaxVal[dwIndex-1]) {
                    dwTmp = pdwNMaxVal[dwIndex-1];
                    pdwNMaxVal[dwIndex-1] = pdwNMaxVal[dwIndex];
                    pdwNMaxVal[dwIndex] = dwTmp;
                    dwIndex--;
                }
            }
        }
    }

    for(dwIndex = 0; dwIndex < dwNumOfFiles; dwIndex++) {
        dwTotalSize += pdwNMaxVal[dwIndex];
    }

    return dwTotalSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\copydir.h ===
//*************************************************************
//
//  Header file for copydir.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


//
// File copy structure
//

typedef struct _FILEINFO {
    TCHAR            szSrc[MAX_PATH];
    TCHAR            szDest[MAX_PATH];
    FILETIME         ftLastWrite;
    FILETIME         ftCreationTime;
    DWORD            dwFileSize;
    DWORD            dwFileAttribs;
    BOOL             bHive;
    struct _FILEINFO *pNext;
} FILEINFO, * LPFILEINFO;


#define NUM_COPY_THREADS        7

//
// ThreadInfo structure
//

typedef struct _THREADINFO {
    DWORD              dwFlags;
    HANDLE             hCopyEvent;
    LPFILEINFO         lpSrcFiles;
    DWORD              dwError;
    HWND               hStatusDlg;
    HANDLE             hStatusInitEvent;
    HANDLE             hStatusTermEvent;
    HDESK              hDesktop;
    HANDLE             hTokenUser;
} THREADINFO, * LPTHREADINFO;


//
// Error dialog structure
//

typedef struct _COPYERRORINFO {
    LPTSTR     lpSrc;
    LPTSTR     lpDest;
    DWORD      dwError;
    DWORD      dwTimeout;
} COPYERRORINFO, * LPCOPYERRORINFO;



INT ReconcileFile (LPCTSTR lpSrcFile, LPCTSTR lpDestFile,
                   DWORD dwFlags, LPFILETIME ftSrcTime,
                   DWORD dwFileSize, BOOL bHiveFile);

INT_PTR APIENTRY CopyStatusDlgProc (HWND hDlg, UINT uMsg,
                                 WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY CopyErrorDlgProc (HWND hDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\policy\policy.h ===
//*************************************************************
//
//  Policy functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

BOOL ApplyPolicy (LPPROFILE lpProfile);

typedef struct _ADTTHREADINFO {
    LPPROFILE lpProfile;
    HDESK     hDesktop;
    FILETIME  ftPolicyFile;
    LPTSTR    lpADTPath;
} ADTTHREADINFO, *LPADTTHREADINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\envvar.c ===
//*************************************************************
//  File name: envvar.c
//
//  Description:  Contains the environment variable functions
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "strsafe.h"

//
// Max environment variable length
//

#define MAX_VALUE_LEN              1024

//
// Environment variables
//

#define COMPUTERNAME_VARIABLE      TEXT("COMPUTERNAME")
#define HOMEDRIVE_VARIABLE         TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE         TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE          TEXT("HOMEPATH")
#define SYSTEMDRIVE_VARIABLE       TEXT("SystemDrive")
#define SYSTEMROOT_VARIABLE        TEXT("SystemRoot")
#define USERNAME_VARIABLE          TEXT("USERNAME")
#define USERDOMAIN_VARIABLE        TEXT("USERDOMAIN")
#define USERDNSDOMAIN_VARIABLE     TEXT("USERDNSDOMAIN")
#define USERPROFILE_VARIABLE       TEXT("USERPROFILE")
#define ALLUSERSPROFILE_VARIABLE   TEXT("ALLUSERSPROFILE")
#define PATH_VARIABLE              TEXT("Path")
#define LIBPATH_VARIABLE           TEXT("LibPath")
#define OS2LIBPATH_VARIABLE        TEXT("Os2LibPath")
#define PROGRAMFILES_VARIABLE      TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE TEXT("CommonProgramFiles")
#if defined(WX86) || defined(_WIN64)
#define PROGRAMFILESX86_VARIABLE   TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE TEXT("CommonProgramFiles(x86)")
#endif
#define USER_ENV_SUBKEY            TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY   TEXT("Volatile Environment")

//
// Parsing information for autoexec.bat
//
#define AUTOEXECPATH_VARIABLE      TEXT("AutoexecPath")
#define PARSE_AUTOEXEC_KEY         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY       TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT     TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER  2


#define SYS_ENVVARS                TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

BOOL UpdateSystemEnvironment(PVOID *pEnv);
BOOL GetUserNameAndDomain(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain);
BOOL GetUserNameAndDomainSlowly(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain);
LPTSTR GetUserDNSDomainName(LPTSTR lpDomain, HANDLE hUserToken);
LONG GetHKeyCU(HANDLE hToken, HKEY *hKeyCU);
BOOL ProcessAutoexec(PVOID *pEnv);
BOOL AppendNTPathWithAutoexecPath(PVOID *pEnv, LPTSTR lpPathVariable, LPTSTR lpAutoexecPath);
BOOL SetEnvironmentVariables(PVOID *pEnv, LPTSTR lpRegSubKey, HKEY hKeyCU);
#ifdef _X86_
BOOL IsPathIncludeRemovable(LPTSTR lpValue);
#endif


__inline BOOL SafeGetEnvironmentVariable(LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize)
{
    DWORD   dwRet = GetEnvironmentVariable(lpName, lpBuffer, nSize);
    return (dwRet > 0) && (dwRet < nSize);
}


//*************************************************************
//
//  CreateEnvironmentBlock()
//
//  Purpose:    Creates the environment variables for the
//              specificed hToken.  If hToken is NULL, the
//              environment block will only contain system
//              variables.
//
//  Parameters: pEnv            -   Receives the environment block
//              hToken          -   User's token or NULL
//              bInherit        -   Inherit the current process environment
//
//  Return:     TRUE if successful
//              FALSE if not
//
//  Comments:   The pEnv value must be destroyed by
//              calling DestroyEnvironmentBlock
//
//  History:    Date        Author     Comment
//              6/19/96     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateEnvironmentBlock (LPVOID *pEnv, HANDLE  hToken, BOOL bInherit)
{
    LPTSTR szBuffer = NULL;
    LPTSTR szValue = NULL;
    LPTSTR szExpValue = NULL;
    DWORD dwBufferSize = MAX_PATH+1;
    NTSTATUS Status;
    LPTSTR UserName = NULL;
    LPTSTR UserDomain = NULL;
    LPTSTR UserDNSDomain = NULL;
    HKEY  hKey, hKeyCU;
    DWORD dwDisp, dwType, dwSize;
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER];
    LONG  dwError;
    BOOL  bRetVal = FALSE;


    //
    // Arg check
    //

    if (!pEnv) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    Status = RtlCreateEnvironment((BOOLEAN)bInherit, pEnv);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szBuffer = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH+1)*sizeof(TCHAR));
    if (!szBuffer) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, (MAX_VALUE_LEN+1)*sizeof(TCHAR));
    if (!szValue) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }

    szExpValue = (LPTSTR)LocalAlloc(LPTR, (MAX_VALUE_LEN+1)*sizeof(TCHAR));
    if (!szExpValue) {
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock: Out of memory")));
        goto Exit;
    }


    //
    // First start by getting the systemroot and systemdrive values and
    // setting it in the new environment.
    //

    if ( SafeGetEnvironmentVariable(SYSTEMROOT_VARIABLE, szBuffer, dwBufferSize) )
    {
        SetEnvironmentVariableInBlock(pEnv, SYSTEMROOT_VARIABLE, szBuffer, TRUE);
    }

    if ( SafeGetEnvironmentVariable(SYSTEMDRIVE_VARIABLE, szBuffer, dwBufferSize) )
    {
        SetEnvironmentVariableInBlock(pEnv, SYSTEMDRIVE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the all users profile location.
    //

    dwBufferSize = MAX_PATH+1;
    if (GetAllUsersProfileDirectory(szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, ALLUSERSPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // We must examine the registry directly to pull out
    // the system environment variables, because they
    // may have changed since the system was booted.
    //

    if (!UpdateSystemEnvironment(pEnv)) {
        RtlDestroyEnvironment(*pEnv);
        goto Exit;
    }


    //
    // Set the computername
    //

    dwBufferSize = MAX_PATH+1;
    if (GetComputerName (szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, COMPUTERNAME_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the default user profile location
    //

    dwBufferSize = MAX_PATH+1;
    if (GetDefaultUserProfileDirectory(szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, USERPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Set the Program Files environment variable
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("ProgramFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            if (SUCCEEDED(SafeExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1))))
                SetEnvironmentVariableInBlock(pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("CommonFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            if (SUCCEEDED(SafeExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1))))
                SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

#if defined(WX86) || defined(_WIN64)
        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("ProgramFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            if (SUCCEEDED(SafeExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1))))
                SetEnvironmentVariableInBlock(pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwSize = (MAX_VALUE_LEN+1)*sizeof(TCHAR);
        if (RegQueryValueEx (hKey, TEXT("CommonFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS) {

            if (SUCCEEDED(SafeExpandEnvironmentStrings (szValue, szExpValue, (MAX_VALUE_LEN+1))))
                SetEnvironmentVariableInBlock(pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }
#endif

        RegCloseKey (hKey);
    }


    //
    // If hToken is NULL, we can exit now since the caller only wants
    // system environment variables.
    //

    if (!hToken) {
        bRetVal = TRUE;
        goto Exit;
    }


    //
    // Open the HKEY_CURRENT_USER for this token.
    //

    dwError = GetHKeyCU(hToken, &hKeyCU);

    //
    // if the hive is not found assume that the caller just needs the system attribute.
    //

    if ((!hKeyCU) && (dwError == ERROR_FILE_NOT_FOUND)) {
        bRetVal = TRUE;
        goto Exit;
    }

    if (!hKeyCU) {
        RtlDestroyEnvironment(*pEnv);
        DebugMsg((DM_WARNING, TEXT("CreateEnvironmentBlock:  Failed to open HKEY_CURRENT_USER, error = %d"), dwError));
        goto Exit;
    }


    //
    // Set the user's name and domain.
    //

    if (!GetUserNameAndDomain(hToken, &UserName, &UserDomain)) {
        GetUserNameAndDomainSlowly(hToken, &UserName, &UserDomain);
    }
    UserDNSDomain = GetUserDNSDomainName(UserDomain, hToken);
    SetEnvironmentVariableInBlock( pEnv, USERNAME_VARIABLE, UserName, TRUE);
    SetEnvironmentVariableInBlock( pEnv, USERDOMAIN_VARIABLE, UserDomain, TRUE);
    SetEnvironmentVariableInBlock( pEnv, USERDNSDOMAIN_VARIABLE, UserDNSDomain, TRUE);
    LocalFree(UserName);
    LocalFree(UserDomain);
    LocalFree(UserDNSDomain);


    //
    // Set the user's profile location.
    //

    dwBufferSize = MAX_PATH+1;
    if (GetUserProfileDirectory(hToken, szBuffer, &dwBufferSize)) {
        SetEnvironmentVariableInBlock(pEnv, USERPROFILE_VARIABLE, szBuffer, TRUE);
    }


    //
    // Process autoexec.bat
    //

    StringCchCopy (szParseAutoexec, ARRAYSIZE(szParseAutoexec), PARSE_AUTOEXEC_DEFAULT);

    if (RegCreateKeyEx (hKeyCU, PARSE_AUTOEXEC_KEY, 0, 0,
                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


        //
        // Query the current value.  If it doesn't exist, then add
        // the entry for next time.
        //

        dwBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
        if (RegQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                        (LPBYTE) szParseAutoexec, &dwBufferSize)
                         != ERROR_SUCCESS) {

            //
            // Set the default value
            //

            RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                           (LPBYTE) szParseAutoexec,
                           sizeof (TCHAR) * lstrlen (szParseAutoexec) + 1);
        }

        //
        // Close key
        //

        RegCloseKey (hKey);
     }


    //
    // Process autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(pEnv);
    }


    //
    // Set User environment variables.
    //
    SetEnvironmentVariables(pEnv, USER_ENV_SUBKEY, hKeyCU);


    //
    // Set User volatile environment variables.
    //
    SetEnvironmentVariables(pEnv, USER_VOLATILE_ENV_SUBKEY, hKeyCU);


    //
    // Merge the paths
    //

    AppendNTPathWithAutoexecPath(pEnv, PATH_VARIABLE, AUTOEXECPATH_VARIABLE);


    RegCloseKey (hKeyCU);

    bRetVal = TRUE;

Exit:

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    if (szValue) {
        LocalFree(szValue);
    }

    if (szExpValue) {
        LocalFree(szExpValue);
    }
 
    return bRetVal;
}


//*************************************************************
//
//  DestroyEnvironmentBlock()
//
//  Purpose:    Frees the environment block created by
//              CreateEnvironmentBlock
//
//  Parameters: lpEnvironment   -   Pointer to variables
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/96     ericflo    Created
//
//*************************************************************

BOOL WINAPI DestroyEnvironmentBlock (LPVOID lpEnvironment)
{

    if (!lpEnvironment) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlDestroyEnvironment(lpEnvironment);

    return TRUE;
}


//*************************************************************
//
//  UpdateSystemEnvironment()
//
//  Purpose:    Reads the system environment variables from the
//              registry.
//
//  Parameters: pEnv    -   Environment block pointer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL UpdateSystemEnvironment(PVOID *pEnv)
{

    HKEY KeyHandle = NULL;
    DWORD Result;
    DWORD ValueNameLength;
    DWORD Type;
    DWORD DataLength;
    DWORD cValues;          /* address of buffer for number of value identifiers    */
    DWORD chMaxValueName;   /* address of buffer for longest value name length      */
    DWORD cbMaxValueData;   /* address of buffer for longest value data length      */
    FILETIME FileTime;
    PTCHAR ValueName = NULL;
    PTCHAR  ValueData = NULL;
    DWORD i;
    BOOL Bool;
    PTCHAR ExpandedValue;
    BOOL rc = TRUE;

    Result = RegOpenKeyEx (
                 HKEY_LOCAL_MACHINE,
                 SYS_ENVVARS,
                 0,
                 KEY_QUERY_VALUE,
                 &KeyHandle
                 );

    if ( Result != ERROR_SUCCESS ) {

        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment:  RegOpenKeyEx failed, error = %d"),Result));
        return( TRUE );
    }

    Result = RegQueryInfoKey(
                 KeyHandle,
                 NULL,               /* address of buffer for class string */
                 NULL,               /* address of size of class string buffer */
                 NULL,               /* reserved */
                 NULL,               /* address of buffer for number of subkeys */
                 NULL,               /* address of buffer for longest subkey */
                 NULL,               /* address of buffer for longest class string length */
                 &cValues,           /* address of buffer for number of value identifiers */
                 &chMaxValueName,    /* address of buffer for longest value name length */
                 &cbMaxValueData,    /* address of buffer for longest value data length */
                 NULL,               /* address of buffer for descriptor length */
                 &FileTime           /* address of buffer for last write time */
                 );

    if ( Result != NO_ERROR && Result != ERROR_MORE_DATA ) {
        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment:  RegQueryInfoKey failed, error = %d"),Result));
        rc = TRUE;
        goto Cleanup;
    }

    //
    // No need to adjust the datalength for TCHAR issues
    //

    ValueData = LocalAlloc(LPTR, cbMaxValueData);

    if ( ValueData == NULL ) {
        rc = FALSE;
        goto Cleanup;
    }

    //
    // The maximum value name length comes back in characters, convert to bytes
    // before allocating storage.  Allow for trailing NULL also.
    //

    ValueName = LocalAlloc(LPTR, (++chMaxValueName) * sizeof( TCHAR ) );

    if ( ValueName == NULL ) {
        rc = FALSE;
        goto Cleanup;
    }

    //
    // To exit from here on, set rc and jump to Cleanup
    //

    for (i=0; i<cValues ; i++) {

        ValueNameLength = chMaxValueName;
        DataLength      = cbMaxValueData;

        Result = RegEnumValue (
                     KeyHandle,
                     i,
                     ValueName,
                     &ValueNameLength,    // Size in TCHARs
                     NULL,
                     &Type,
                     (LPBYTE)ValueData,
                     &DataLength          // Size in bytes
                     );

        if ( Result != ERROR_SUCCESS ) {

            //
            // Problem getting the value.  We can either try
            // the rest or punt completely.
            //

            goto Cleanup;
        }

        //
        // If the buffer size is greater than the max allowed,
        // terminate the string at MAX_VALUE_LEN - 1.
        //

        if (DataLength >= (MAX_VALUE_LEN * sizeof(TCHAR))) {
            ValueData[MAX_VALUE_LEN-1] = TEXT('\0');
        }

        switch ( Type ) {
            case REG_SZ:
                {

                    Bool = SetEnvironmentVariableInBlock(
                               pEnv,
                               ValueName,
                               ValueData,
                               TRUE
                               );

                    if ( !Bool ) {
                        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment: Failed to set environment variable <%s> to <%s> with %d."),
                                 ValueName, ValueData, GetLastError()));
                    }

                    break;
                }
            default:
                {
                    continue;
                }
        }
    }

    //
    // To exit from here on, set rc and jump to Cleanup
    //

    for (i=0; i<cValues ; i++) {

        ValueNameLength = chMaxValueName;
        DataLength      = cbMaxValueData;

        Result = RegEnumValue (
                     KeyHandle,
                     i,
                     ValueName,
                     &ValueNameLength,    // Size in TCHARs
                     NULL,
                     &Type,
                     (LPBYTE)ValueData,
                     &DataLength          // Size in bytes
                     );

        if ( Result != ERROR_SUCCESS ) {

            //
            // Problem getting the value.  We can either try
            // the rest or punt completely.
            //

            goto Cleanup;
        }

        //
        // If the buffer size is greater than the max allowed,
        // terminate the string at MAX_VALUE_LEN - 1.
        //

        if (DataLength >= (MAX_VALUE_LEN * sizeof(TCHAR))) {
            ValueData[MAX_VALUE_LEN-1] = TEXT('\0');
        }

        switch ( Type ) {
            case REG_EXPAND_SZ:
                {

                    ExpandedValue =  AllocAndExpandEnvironmentStrings( ValueData );

                    Bool = SetEnvironmentVariableInBlock(
                               pEnv,
                               ValueName,
                               ExpandedValue,
                               TRUE
                               );

                    LocalFree( ExpandedValue );

                    if ( !Bool ) {
                        DebugMsg((DM_WARNING, TEXT("UpdateSystemEnvironment: Failed to set environment variable <%s> to <%s> with %d."),
                                 ValueName, ValueData, GetLastError()));
                    }

                    break;
                }
            default:
                {
                    continue;
                }
        }
    }

   
Cleanup:

    if (KeyHandle)
        RegCloseKey(KeyHandle);

    if (ValueName)
        LocalFree( ValueName );

    if (ValueData)
        LocalFree( ValueData );

    return( rc );
}

//*************************************************************
//
//  GetUserNameAndDomain()
//
//  Purpose:    Gets the user's name and domain
//
//  Parameters: hToken      -   User's token
//              UserName    -   Receives pointer to user's name
//              UserDomain  -   Receives pointer to user's domain
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL GetUserNameAndDomain(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain)
{
    BOOL bResult = FALSE;
    LPTSTR lpTemp, lpDomain = NULL;
    LPTSTR lpUserName, lpUserDomain;
    HANDLE hOldToken;
    DWORD   dwSize;


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserNameAndDomain Failed to impersonate user")));
        goto Exit;
    }


    //
    // Get the username in NT4 format
    //

    lpDomain = MyGetUserNameEx (NameSamCompatible);

    RevertToUser(&hOldToken);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain:  MyGetUserNameEx failed for NT4 style name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to find slash in NT4 style name:  <%s>"),
                 lpDomain));
        goto Exit;
    }

    *lpTemp = TEXT('\0');
    lpTemp++;


    //
    // Allocate space for the results
    //

    dwSize = lstrlen(lpTemp) + 1;
    lpUserName = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!lpUserName) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }

    StringCchCopy (lpUserName, dwSize, lpTemp);


    dwSize = lstrlen(lpDomain) + 1;
    lpUserDomain = LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!lpUserDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameAndDomain  Failed to allocate memory with %d"),
                 GetLastError()));
        LocalFree (lpUserName);
        goto Exit;
    }

    StringCchCopy (lpUserDomain, dwSize, lpDomain);


    //
    // Save the results in the outbound arguments
    //

    *UserName = lpUserName;
    *UserDomain = lpUserDomain;


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    return(bResult);
}

//*************************************************************
//
//  GetUserNameAndDomainSlowly()
//
//  Purpose:    Gets the user's name and domain from a DC
//
//  Parameters: hToken      -   User's token
//              UserName    -   Receives pointer to user's name
//              UserDomain  -   Receives pointer to user's domain
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL GetUserNameAndDomainSlowly(HANDLE hToken, LPTSTR *UserName, LPTSTR *UserDomain)
{
    LPTSTR lpUserName = NULL;
    LPTSTR lpUserDomain = NULL;
    DWORD cbAccountName = 0;
    DWORD cbUserDomain = 0;
    SID_NAME_USE SidNameUse;
    BOOL bRet = FALSE;
    PSID pSid;


    //
    // Get the user's sid
    //

    pSid = GetUserSid (hToken);

    if (!pSid) {
        return FALSE;
    }


    //
    // Get the space needed for the User name and the Domain name
    //
    if (!LookupAccountSid(NULL,
                         pSid,
                         NULL, &cbAccountName,
                         NULL, &cbUserDomain,
                         &SidNameUse
                         ) ) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Error;
        }
    }

    lpUserName = (LPTSTR)LocalAlloc(LPTR, cbAccountName*sizeof(TCHAR));
    if (!lpUserName) {
        goto Error;
    }

    lpUserDomain = (LPTSTR)LocalAlloc(LPTR, cbUserDomain*sizeof(WCHAR));
    if (!lpUserDomain) {
        LocalFree(lpUserName);
        goto Error;
    }

    //
    // Now get the user name and domain name
    //
    if (!LookupAccountSid(NULL,
                         pSid,
                         lpUserName, &cbAccountName,
                         lpUserDomain, &cbUserDomain,
                         &SidNameUse
                         ) ) {

        LocalFree(lpUserName);
        LocalFree(lpUserDomain);
        goto Error;
    }

    *UserName = lpUserName;
    *UserDomain = lpUserDomain;
    bRet = TRUE;

Error:
    DeleteUserSid (pSid);

    return(bRet);
}

//*************************************************************
//
//  GetUserDNSDomainName()
//
//  Purpose:    Gets the DNS domain name for the user
//
//  Parameters: lpDomain   - User's flat domain name
//              hUserToken - User's token
//
//
//  Return:     DNS domain name if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR GetUserDNSDomainName(LPTSTR lpDomain, HANDLE hUserToken)
{
    LPTSTR  lpDnsDomain = NULL, lpTemp = NULL;
    DWORD   dwBufferSize;
    TCHAR   szBuffer[MAX_PATH];
    INT     iRole;
    HANDLE  hOldToken;
    BOOL    bResult = FALSE;


    //
    // Check if this machine is running standalone, if so, there won't be
    // a DNS domain name
    //

    if (!GetMachineRole (&iRole)) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  Failed to get the role of the computer.")));
        return NULL;
    }

    if (iRole == 0) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Computer is running standalone.  No DNS domain name available.")));
        return NULL;
    }


    //
    // Get the computer name to see if the user logged on locally
    //

    dwBufferSize = ARRAYSIZE(szBuffer);

    if (GetComputerName (szBuffer, &dwBufferSize)) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Local user account.  No DNS domain name available.")));
            return NULL;
        }
    }

    if (LoadString (g_hDllInstance, IDS_NT_AUTHORITY, szBuffer, ARRAYSIZE(szBuffer))) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Domain name is NT Authority.  No DNS domain name available.")));
            return NULL;
        }
    }

    if (LoadString (g_hDllInstance, IDS_BUILTIN, szBuffer, ARRAYSIZE(szBuffer))) {
        if (!lstrcmpi(lpDomain, szBuffer)) {
            DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName:  Domain name is BuiltIn.  No DNS domain name available.")));
            return NULL;
        }
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(hUserToken, &hOldToken)) {
        DebugMsg((DM_VERBOSE, TEXT("GetUserDNSDomainName: Failed to impersonate user")));
        goto Exit;
    }


    //
    // Get the username in DnsDomainName format
    //

    lpDnsDomain = MyGetUserNameEx (NameDnsDomain);

    RevertToUser(&hOldToken);

    if (!lpDnsDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  MyGetUserNameEx failed for NameDnsDomain style name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDnsDomain;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserDNSDomainName:  Failed to find slash in NameDnsDomain style name: <%s>"),
                 lpDnsDomain));
        goto Exit;
    }

    *lpTemp = TEXT('\0');
    bResult = TRUE;

Exit:

    if (!bResult && lpDnsDomain) {
        LocalFree(lpDnsDomain);
        lpDnsDomain = NULL;
    }

    return lpDnsDomain;
}

//*************************************************************
//
//  GetHKeyCU()
//
//  Purpose:    Get HKEY_CURRENT_USER for the given hToken
//
//  Parameters: hToken  -   token handle
//
//  Return:     hKey if successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Created
//
//*************************************************************

LONG GetHKeyCU(HANDLE hToken, HKEY *hKeyCU)
{
    LPTSTR lpSidString;
    LONG    dwError;


    *hKeyCU = NULL;

    lpSidString = GetSidString (hToken);

    if (!lpSidString) {
        return GetLastError();
    }

    dwError = RegOpenKeyEx (HKEY_USERS, lpSidString, 0, KEY_READ, hKeyCU);

    if (dwError != ERROR_SUCCESS)
        DebugMsg((DM_VERBOSE, TEXT("GetHkeyCU: RegOpenKey failed with error %d"), dwError));

    DeleteSidString(lpSidString);

    return dwError;
}

/***************************************************************************\
* ProcessAutoexecPath
*
* Creates AutoexecPath environment variable using autoexec.bat
* LpValue may be freed by this routine.
*
* History:
* 06-02-92  Johannec     Created.
*
\***************************************************************************/
LPTSTR ProcessAutoexecPath(PVOID pEnv, LPTSTR lpValue, DWORD cb)
{
    LPTSTR lpt;
    LPTSTR lpStart;
    LPTSTR lpPath;
    DWORD ccht;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    BOOL bPrevAutoexecPath;
    WCHAR ch;
    DWORD dwTemp, dwCount = 0;

    ccht = 1024;
    lpt = (LPTSTR)LocalAlloc(LPTR, ccht*sizeof(WCHAR));
    if (!lpt) {
        return(lpValue);
    }
    *lpt = 0;
    lpStart = lpValue;

    RtlInitUnicodeString(&Name, AUTOEXECPATH_VARIABLE);
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, ccht*sizeof(WCHAR));
    if (!Value.Buffer) {
        goto Fail;
    }

    while (NULL != (lpPath = wcsstr (lpValue, TEXT("%")))) {
        if (!_wcsnicmp(lpPath+1, TEXT("PATH%"), 5)) {
            //
            // check if we have an autoexecpath already set, if not just remove
            // the %path%
            //
            Value.Length = (USHORT)ccht * sizeof(WCHAR);
            Value.MaximumLength = (USHORT)ccht * sizeof(WCHAR);
            bPrevAutoexecPath = (BOOL)!RtlQueryEnvironmentVariable_U(pEnv, &Name, &Value);

            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < ccht) {
               StringCchCat(lpt, ccht, lpValue);
               dwCount = dwTemp;
            }
            if (bPrevAutoexecPath) {
                dwTemp = dwCount + lstrlen (Value.Buffer);
                if (dwTemp < ccht) {
                    StringCchCat(lpt, ccht, Value.Buffer);
                    dwCount = dwTemp;
                }
            }

            *lpPath++ = TEXT('%');
            lpPath += 5;  // go passed %path%
            lpValue = lpPath;
        }
        else {
            lpPath = wcsstr(lpPath+1, TEXT("%"));
            if (!lpPath) {
                lpStart = NULL;
                goto Fail;
            }
            lpPath++;
            ch = *lpPath;
            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < ccht) {
                StringCchCat(lpt, ccht, lpValue);
                dwCount = dwTemp;
            }
            *lpPath = ch;
            lpValue = lpPath;
        }
    }

    if (*lpValue) {
       dwTemp = dwCount + lstrlen (lpValue);
       if (dwTemp < ccht) {
           StringCchCat(lpt, ccht, lpValue);
           dwCount = dwTemp;
       }
    }

    LocalFree(Value.Buffer);
    LocalFree(lpStart);

    return(lpt);
Fail:
    LocalFree(lpt);
    return(lpStart);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    LPTSTR lpExpandedValue = NULL;
    WCHAR c;
    DWORD cch, cchNeeded;
    LPTSTR lpu;
    DWORD cchVariable, cchValue;

    //
    // convert to Unicode
    //
    lpu = (LPTSTR)LocalAlloc(LPTR, (cch=lstrlenA(lpStart)+1)*sizeof(WCHAR));

    if (!lpu) {
        return FALSE;
    }

    if (!MultiByteToWideChar(CP_OEMCP, 0, lpStart, -1, lpu, cch)) {
        LocalFree(lpu);
        return FALSE;
    }

    //
    // Find environment variable.
    //
    for (lpt = lpu; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;

    if (!*lpt) {
        LocalFree (lpu);
        return(FALSE);
    }


    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;

    c = *lpt;
    *lpt = 0;
    cchVariable = lstrlen(lptt) + 1;
    lpVariable = (LPTSTR)LocalAlloc(LPTR, cchVariable*sizeof(WCHAR));
    if (!lpVariable) {
        LocalFree (lpu);
        return(FALSE);
    }

    StringCchCopy(lpVariable, cchVariable, lptt);
    *lpt = c;

    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;

    if (!*lpt) {
        // if we have a blank path statement in the autoexec file,
        // then we don't want to pass "PATH" as the environment
        // variable because it trashes the system's PATH.  Instead
        // we want to change the variable AutoexecPath.  This would have
        // be handled below if a value had been assigned to the
        // environment variable.
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, PATH_VARIABLE, -1) == CSTR_EQUAL) 
        {
            SetEnvironmentVariableInBlock(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
        }
        else
        {
            SetEnvironmentVariableInBlock(pEnv, lpVariable, TEXT(""), TRUE);
        }
        LocalFree (lpVariable);
        LocalFree (lpu);
        return(FALSE);
    }

    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;

    c = *lpt;
    *lpt = 0;
    cchValue = lstrlen(lptt) + 1;
    lpValue = (LPTSTR)LocalAlloc(LPTR, cchValue*sizeof(WCHAR));
    if (!lpValue) {
        LocalFree (lpu);
        LocalFree(lpVariable);
        return(FALSE);
    }

    StringCchCopy(lpValue, cchValue, lptt);
    *lpt = c;

#ifdef _X86_
    // NEC98
    //
    // If the path includes removable drive,
    //  it is assumed that the drive assignment has changed from DOS.
    //
    if (IsNEC_98 &&
        (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, PATH_VARIABLE, -1) == CSTR_EQUAL) &&
        IsPathIncludeRemovable(lpValue)) 
    {
        LocalFree (lpu);
        LocalFree(lpVariable);
        LocalFree(lpValue);
        return(FALSE);
    }
#endif

    cch = 1024;
    lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    if (lpExpandedValue) {
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, PATH_VARIABLE, -1) == CSTR_EQUAL) 
        {
            lpValue = ProcessAutoexecPath(*pEnv, lpValue, (lstrlen(lpValue)+1)*sizeof(WCHAR));
        }
        cchNeeded = ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cch);
        if (cchNeeded > cch) {
            LocalFree(lpExpandedValue);
            cch = cchNeeded;
            lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
            if (lpExpandedValue) {
                ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cch);
            }
        }
    }

    if (!lpExpandedValue) {
        lpExpandedValue = lpValue;
    }
    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, PATH_VARIABLE, -1) == CSTR_EQUAL)
    {
        SetEnvironmentVariableInBlock(pEnv, AUTOEXECPATH_VARIABLE, lpExpandedValue, TRUE);
    }
    else {
        SetEnvironmentVariableInBlock(pEnv, lpVariable, lpExpandedValue, FALSE);
    }

    if (lpExpandedValue != lpValue) {
        LocalFree(lpExpandedValue);
    }
    LocalFree(lpVariable);
    LocalFree(lpValue);
    LocalFree (lpu);

    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPSTR lpStart, PVOID *pEnv)
{
    LPSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt)
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL
ProcessAutoexec(
    PVOID *pEnv
    )
{
    HANDLE fh = NULL;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
#ifdef _X86_
    TCHAR szTemp[3];
#endif
    UINT uiErrMode;


    // There is a case where the OS might not be booting from drive
    // C, so we can not assume that the autoexec.bat file is on c:\.
    // Set the error mode so the user doesn't see the critical error
    // popup and attempt to open the file on c:\.

    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef _X86_
    if (IsNEC_98) {
        if (GetEnvironmentVariable (TEXT("SystemDrive"), szTemp, 3)) {
            szAutoExecBat[0] = szTemp[0];
        }
    }
#endif

    // if autoexec.bat is encrypted then ignore it as it creates cyclic-dependency 
    // and don't allow any user to logon

    if (GetFileAttributes(szAutoExecBat) & FILE_ATTRIBUTE_ENCRYPTED) {
        SetErrorMode(uiErrMode);
        goto Exit;
    }

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        goto Exit;  //could not open autoexec.bat file, we're done.
    }
    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = (PCHAR)LocalAlloc(LPTR, dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    DmAssert(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

    token = strtok(lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "Path", 4)) {
            ProcessCommand(token, pEnv);
        }
        if (!_strnicmp(token, "SET", 3)) {
            ProcessSetCommand(token, pEnv);
        }
        token = strtok(NULL, Seps);
    }
Exit:
    if (fh) {
        CloseHandle(fh);
    }
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }
    if (!Status) {
        DebugMsg((DM_WARNING, TEXT("ProcessAutoexec: Cannot process autoexec.bat.")));
    }
    return(Status);
}

/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(PVOID *pEnv,
                          LPTSTR lpPathVariable,
                          LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR lpTemp[1025];
    DWORD cch;


    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cch = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cch);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cch);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        StringCchCopy(lpTemp, ARRAYSIZE(lpTemp), Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            StringCchCat(lpTemp, ARRAYSIZE(lpTemp), TEXT(";"));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cch)) {
        StringCchCat(lpTemp, ARRAYSIZE(lpTemp), lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR AutoexecPathValue[1024];
    DWORD cch;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpAutoexecPath);
    cch = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = (USHORT)cch*sizeof(WCHAR);
    Value.MaximumLength = (USHORT)cch*sizeof(WCHAR);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        StringCchCopy(AutoexecPathValue, ARRAYSIZE(AutoexecPathValue), Value.Buffer);
    }

    LocalFree(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable( pEnv, &Name, NULL);

    return(Success);
}

/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetEnvironmentVariables(
    PVOID *pEnv,
    LPTSTR lpRegSubKey,
    HKEY hKeyCU
    )
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cchDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cchValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(hKeyCU, lpRegSubKey, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cchDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cchDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cchDataBuffer * sizeof(WCHAR);
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cchValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cchValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, PATH_VARIABLE, -1) == CSTR_EQUAL ||
                    CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, LIBPATH_VARIABLE, -1) == CSTR_EQUAL ||
                    CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, OS2LIBPATH_VARIABLE, -1) == CSTR_EQUAL ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetEnvironmentVariableInBlock(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cchDataBuffer * sizeof(WCHAR);
        cchValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cchDataBuffer * sizeof(WCHAR);
    cchValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cchValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cchValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cch, cchNeeded;

                cch = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cchNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cch);
                    if (cchNeeded > cch) {
                        LocalFree(lpExpandedValue);
                        cch = cchNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(WCHAR));
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cch);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, PATH_VARIABLE, -1) == CSTR_EQUAL ||
                    CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, LIBPATH_VARIABLE, -1) == CSTR_EQUAL ||
                    CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpValueName, -1, OS2LIBPATH_VARIABLE, -1) == CSTR_EQUAL ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetEnvironmentVariableInBlock(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);
                }

                LocalFree(lpExpandedValue);

            }

        }
        dwIndex++;
        cbData = cchDataBuffer * sizeof(WCHAR);
        cchValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

//*************************************************************
//
//  ExpandEnvironmentStringsForUser()
//
// Purpose:  Expands the source string using the environment block for the
//           specified user.  If hToken is null, the system environment block
//           will be used (no user environment variables).
//
//  Parameters: hToken  -  User's token (or null for system env vars)
//              lpSrc   -  String to be expanded
//              lpDest  -  Buffer to receive string
//              dwSize  -  Size of dest buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI ExpandEnvironmentStringsForUser(HANDLE hToken, LPCTSTR lpSrc,
                                            LPTSTR lpDest, DWORD dwSize)
{
    LPVOID pEnv;
    DWORD  dwNeeded;
    BOOL bResult = FALSE;


    //
    // Arg check
    //
    
    if ( !lpDest || !lpSrc )
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    
    //
    // Get the user's environment block
    //

    if (!CreateEnvironmentBlock (&pEnv, hToken, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("ExpandEnvironmentStringsForUser:  CreateEnvironmentBlock failed with = %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Expand the string
    //

    dwNeeded = ExpandUserEnvironmentStrings(pEnv, lpSrc, lpDest, dwSize);

    if (dwNeeded && (dwNeeded < dwSize)) {
        bResult = TRUE;
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER );
    }


    //
    // Free the environment block
    //

    DestroyEnvironmentBlock (pEnv);


    return bResult;
}

//*************************************************************
//
//  GetSystemTempDirectory()
//
//  Purpose:    Gets the system temp directory in short form
//
//  Parameters: lpDir     - Receives the directory
//              lpcchSize - Size of the lpDir buffer
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI GetSystemTempDirectory(LPTSTR lpDir, LPDWORD lpcchSize)
{
    TCHAR  szTemp[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    DWORD  dwLength;
    HKEY   hKey;
    LONG   lResult;
    DWORD  dwSize, dwType;
    BOOL   bRetVal = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HRESULT hr;


    szTemp[0] = TEXT('\0');
    szDirectory[0] = TEXT('\0');

    //
    // Look in the system environment variables
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, SYS_ENVVARS, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for TEMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        //
        // Check for TMP
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx (hKey, TEXT("TMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
            RegCloseKey (hKey);
            goto FoundTemp;
        }


        RegCloseKey (hKey);
    }


    //
    // Check if %SystemRoot%\Temp exists
    //

    StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%SystemRoot%\\Temp"));
    if (FAILED(hr = SafeExpandEnvironmentStrings (szDirectory, szTemp, ARRAYSIZE (szTemp))))
    {
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Check if %SystemDrive%\Temp exists
    //

    StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%SystemDrive%\\Temp"));
    if (FAILED(hr = SafeExpandEnvironmentStrings (szDirectory, szTemp, ARRAYSIZE (szTemp))))
    {
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }

    if (GetFileAttributesEx (szTemp, GetFileExInfoStandard, &fad) &&
        fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        goto FoundTemp;
    }


    //
    // Last resort is %SystemRoot%
    //

    StringCchCopy (szTemp, ARRAYSIZE (szTemp), TEXT("%SystemRoot%"));



FoundTemp:

    if (FAILED(hr = SafeExpandEnvironmentStrings (szTemp, szDirectory, ARRAYSIZE (szDirectory))))
    {
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }
    dwLength = GetShortPathName (szDirectory, szTemp, ARRAYSIZE(szTemp));
    if (dwLength > ARRAYSIZE(szTemp) || dwLength == 0)
    {
        goto Exit;
    }

    dwLength = lstrlen(szTemp) + 1;

    if (lpDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpDir, *lpcchSize, szTemp);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

Exit:
    return bRetVal;
}

#ifdef _X86_
BOOL
IsPathIncludeRemovable(LPTSTR lpValue)
{
    LPTSTR      lpt, tmp;
    BOOL        ret = FALSE;
    WCHAR       c;
    DWORD cchTmp;

    cchTmp = lstrlen(lpValue) + 1;
    tmp = LocalAlloc(LPTR, cchTmp * sizeof(WCHAR));
    if (!tmp) {
        DebugMsg((DM_WARNING, TEXT("IsPathIncludeRemovable : Failed to LocalAlloc (%d)"), GetLastError()));
    }
    else {
        StringCchCopy(tmp, cchTmp, lpValue);

        lpt = tmp;
        while (*lpt) {
            // skip spaces
            for ( ; *lpt && *lpt == TEXT(' '); lpt++)
                ;

            // check if the drive is removable
            if (lpt[0] && lpt[1] && lpt[1] == TEXT(':') && lpt[2]) {        // ex) "A:\"
                c = lpt[3];
                lpt[3] = 0;
                if (GetDriveType(lpt) == DRIVE_REMOVABLE) {
                    lpt[3] = c;
                    ret = TRUE;
                    break;
                }
                lpt[3] = c;
            }

            // skip to the next path
            for ( ; *lpt && *lpt != TEXT(';'); lpt++)
                ;
            if (*lpt)
                lpt++;
        }
        LocalFree(tmp);
    }
    return(ret);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\hkcr.c ===
//*************************************************************
//
//  HKCR management routines
//
//  hkcr.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

/*++

Abstract:

    This module contains the code executed at logon for 
    creating a user classes hive and mapping it into the standard
    user hive.  The user classes hive and its machine classes
    counterpart make up the registry subtree known as 
    HKEY_CLASSES_ROOT.

Author:

    Adam P. Edwards     (adamed)  10-Oct-1997
    Gregory Jensenworth (gregjen) 1-Jul-1997

Key Functions:

    LoadUserClasses
    UnloadClasses

Notes:

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for 
    HKLM\Software\Classes.  

    The per-user HKCR combines machine classes stored it the 
    traditional HKLM\Software\Classes location with classes
    stored in HKCU\Software\Classes.

    Certain keys, such as CLSID, will have subkeys that come
    from both the machine and user locations.  When there is a conflict
    in key names, the user oriented key overrides the other one --
    only the user key is seen in that case.

    Originally, the code in this module was responsible for 
    creating this combined view.  That responsibility has moved
    to the win32 registry api's, so the main responsibility of 
    this module is the mapping of the user-specific classes into
    the registry.

    It should be noted that HKCU\Software\Classes is not the true
    location of the user-only class data.  If it were, all the class
    data would be in ntuser.dat, which roams with the user.  Since
    class data can get very large, installation of a few apps
    would cause HKCU (ntuser.dat) to grow from a few hundred thousand K
    to several megabytes.  Since user-only class data comes from
    the directory, it does not need to roam and therefore it was
    separated from HKCU (ntuser.dat) and stored in another hive
    mounted under HKEY_USERS.

    It is still desirable to allow access to this hive through
    HKCU\Software\Classes, so we use some trickery (symlinks) to
    make it seem as if the user class data exists there.


--*/

#include "uenv.h"
#include <malloc.h>
#include <wow64reg.h>
#include "strsafe.h"

#define USER_CLASSES_HIVE_NAME     TEXT("\\UsrClass.dat")
#define CLASSES_SUBTREE            TEXT("Software\\Classes\\")

#define CLASSES_SUBDIRECTORY       TEXT("\\Microsoft\\Windows\\")
#define MAX_HIVE_DIR_CCH           (MAX_PATH + 1 + lstrlen(CLASSES_SUBDIRECTORY))

#define TEMPHIVE_FILENAME          TEXT("TempClassesHive.dat")

#define CLASSES_CLSID_SUBTREE      TEXT("Software\\Classes\\Clsid\\")
#define EXPLORER_CLASSES_SUBTREE   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Clsid\\")
#define LENGTH(x)                  (sizeof(x) - sizeof(WCHAR))
#define INIT_SPECIALKEY(x)         x

typedef WCHAR* SpecialKey;

SpecialKey SpecialSubtrees[]= {
    INIT_SPECIALKEY(L"*"),
    INIT_SPECIALKEY(L"*\\shellex"),
    INIT_SPECIALKEY(L"*\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"*\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"AppID"),
    INIT_SPECIALKEY(L"ClsID"), 
    INIT_SPECIALKEY(L"Component Categories"),
    INIT_SPECIALKEY(L"Drive"),
    INIT_SPECIALKEY(L"Drive\\shellex"),
    INIT_SPECIALKEY(L"Drive\\shellex\\ContextMenuHandlers"),
    INIT_SPECIALKEY(L"Drive\\shellex\\PropertyShellHandlers"),
    INIT_SPECIALKEY(L"FileType"),
    INIT_SPECIALKEY(L"Folder"),
    INIT_SPECIALKEY(L"Folder\\shellex"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ColumnHandler"),
    INIT_SPECIALKEY(L"Folder\\shellex\\ContextMenuHandlers"), 
    INIT_SPECIALKEY(L"Folder\\shellex\\ExtShellFolderViews"),
    INIT_SPECIALKEY(L"Folder\\shellex\\PropertySheetHandlers"),
    INIT_SPECIALKEY(L"Installer\\Components"),
    INIT_SPECIALKEY(L"Installer\\Features"),
    INIT_SPECIALKEY(L"Installer\\Products"),
    INIT_SPECIALKEY(L"Interface"),
    INIT_SPECIALKEY(L"Mime"),
    INIT_SPECIALKEY(L"Mime\\Database"), 
    INIT_SPECIALKEY(L"Mime\\Database\\Charset"),
    INIT_SPECIALKEY(L"Mime\\Database\\Codepage"),
    INIT_SPECIALKEY(L"Mime\\Database\\Content Type"),
    INIT_SPECIALKEY(L"Typelib")
};
    
#define NUM_SPECIAL_SUBTREES    (sizeof(SpecialSubtrees)/sizeof(*SpecialSubtrees))


//*************************************************************
//
//  CreateRegLink()
//
//  Purpose:    Create a link from the hkDest + SubKeyName
//              pointing to lpSourceRootName
//
//              if the key (link) already exists, do nothing
//
//  Parameters: hkDest            - root of destination
//              SubKeyName        - subkey of destination
//              lpSourceName      - target of link
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************/

LONG CreateRegLink(HKEY hkDest,
                   LPTSTR SubKeyName,
                   LPTSTR lpSourceName)
{
    NTSTATUS Status;
    UNICODE_STRING  LinkTarget;
    UNICODE_STRING  SubKey;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE hkInternal;
    UNICODE_STRING  SymbolicLinkValueName;

    //
    // Initialize special key value used to make symbolic links
    //
    RtlInitUnicodeString(&SymbolicLinkValueName, L"SymbolicLinkValue");

    //
    // Initialize unicode string for our in params
    //
    RtlInitUnicodeString(&LinkTarget, lpSourceName);
    RtlInitUnicodeString(&SubKey, SubKeyName);

    //
    // See if this link already exists -- this is necessary because
    // NtCreateKey fails with STATUS_OBJECT_NAME_COLLISION if a link
    // already exists and will not return a handle to the existing
    // link.
    //
    InitializeObjectAttributes(&Attributes,
                               &SubKey,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkDest,
                               NULL);

    //
    // If this call succeeds, we get a handle to the existing link
    //
    Status = NtOpenKey( &hkInternal,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

        //
        // There is no existing link, so use NtCreateKey to make a new one
        //
        Status = NtCreateKey( &hkInternal,
                              KEY_CREATE_LINK | KEY_SET_VALUE,
                              &Attributes,
                              0,
                              NULL,
                              REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                              NULL);
    }

    //
    // Whether the link existed already or not, we should still set
    // the value which determines the link target
    //
    if (NT_SUCCESS(Status)) {

        Status = NtSetValueKey( hkInternal,
                                &SymbolicLinkValueName,
                                0,
                                REG_LINK,
                                LinkTarget.Buffer,
                                LinkTarget.Length);
        NtClose(hkInternal);
    }

    return RtlNtStatusToDosError(Status);
}


//*************************************************************
//
//  DeleteRegLink()
//
//  Purpose:    Deletes a registry key (or link) without
//              using the advapi32 registry apis
//
//
//  Parameters: hkRoot          -   parent key
//              lpSubKey        -   subkey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************

LONG DeleteRegLink(HKEY hkRoot, LPTSTR lpSubKey)
{
    OBJECT_ATTRIBUTES Attributes;
    HKEY              hKey;
    NTSTATUS          Status;
    UNICODE_STRING    Subtree;

    //
    // Initialize string for lpSubKey param
    //
    RtlInitUnicodeString(&Subtree, lpSubKey);

    InitializeObjectAttributes(&Attributes,
                               &Subtree,
                               OBJ_CASE_INSENSITIVE | OBJ_OPENLINK,
                               hkRoot,
                               NULL);

    //
    // Open the link
    //
    Status = NtOpenKey( &hKey,
                        MAXIMUM_ALLOWED,
                        &Attributes );

    //
    // If we succeeded in opening it, delete it
    //
    if (NT_SUCCESS(Status)) {

        Status = NtDeleteKey(hKey);
        NtClose(hKey);
    }

    return RtlNtStatusToDosError(Status);
}


//*************************************************************
//
//  MapUserClassesIntoUserHive()
//
//  Purpose:    Makes HKCU\\Software\\Classes point to
//              the user classes hive. This is done by using
//              a symbolic link, a feature of the kernel's
//              object manager.  We use this to make 
//              HKCU\Software\Classes poing to another hive
//              where the classes exist physically.
//              If there is an existing HKCU\\Software\\Classes,
//              it is deleted along with everything below it.
//
//
//  Parameters: lpProfile       -   user's profile
//              lpSidString     -   string representing user's sid
//
//  Return:     ERROR_SUCCESS if successful
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG MapUserClassesIntoUserHive(
    LPPROFILE lpProfile,
    LPTSTR lpSidString)
{
    LONG   Error;
    LPTSTR lpClassesKeyName = NULL;
    DWORD  cchClassesKeyName;

    //
    // get memory for user classes keyname
    //
    cchClassesKeyName = lstrlen(lpSidString) + 
                        lstrlen(USER_CLASSES_HIVE_SUFFIX) +
                        lstrlen(USER_KEY_PREFIX) + 
                        1;
                        
    lpClassesKeyName = (LPTSTR) LocalAlloc(LPTR, cchClassesKeyName * sizeof(TCHAR));

    //
    // Can't continue if no memory;
    //
    if ( !lpClassesKeyName ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // concoct user classes keyname
    //
    StringCchCopy( lpClassesKeyName, cchClassesKeyName, USER_KEY_PREFIX);
    StringCchCat ( lpClassesKeyName, cchClassesKeyName, lpSidString );
    StringCchCat ( lpClassesKeyName, cchClassesKeyName, USER_CLASSES_HIVE_SUFFIX);

    //
    // Eliminate any existing form of HKCU\Software\Classes
    //
    
    //
    // First, delete existing link
    //
    Error = DeleteRegLink(lpProfile->hKeyCurrentUser, CLASSES_SUBTREE);

    //
    // It's ok if the deletion fails because the classes key, link or nonlink,
    // doesn't exist.  It's also ok if it fails because the key exists but is not
    // a link and has children -- in this case, the key and its children will
    // be eliminated by a subsequent call to RegDelNode.
    //
    if (ERROR_SUCCESS != Error) {
        if ((ERROR_FILE_NOT_FOUND != Error) && (ERROR_ACCESS_DENIED != Error)) {
            goto Exit;
        }
    }

    //
    // Just to be safe, destroy any existing HKCU\Software\Classes and children.
    // This key may exist from previous unreleased versions of NT5, or from
    // someone playing around with hive files and adding bogus keys
    //
    if ((Error = RegDelnode (lpProfile->hKeyCurrentUser, CLASSES_SUBTREE)) != ERROR_SUCCESS) {
        //
        // It's ok if this fails because the key doesn't exist, since
        // nonexistence is our goal.
        //
        if (ERROR_FILE_NOT_FOUND != Error) {
            goto Exit;
        }
    }

    //
    // At this point, we know that no HKCU\Software\Classes exists, so we should
    // be able to make a link there which points to the hive with the user class
    // data.
    // 
    Error = CreateRegLink(lpProfile->hKeyCurrentUser,
                         CLASSES_SUBTREE,
                         lpClassesKeyName);

Exit:
    if (lpClassesKeyName)
        LocalFree(lpClassesKeyName);
        
    return Error;
}


//*************************************************************
//
//  CreateClassesFolder()
//
//  Purpose:    Create the directory for the classes hives
//
//
//  Parameters:
//              pProfile        - pointer to profile struct
//              szLocalHiveDir  - out param for location of
//                                classes hive folder.
//              cchLocalHiveDir - size of the buffer, in TCHARs
//
//  Return:     ERROR_SUCCESS if successful
//              other error if an error occurs
//
//
//*************************************************************
LONG CreateClassesFolder(LPPROFILE pProfile, LPTSTR szLocalHiveDir, DWORD cchLocalHiveDir)
{
    BOOL   fGotLocalData;
    BOOL   fCreatedSubdirectory;

    //
    // Find out the correct shell location for our subdir --
    // this call will create it if it doesn't exist.
    // This is a subdir of the user profile which does not 
    // roam.
    //

    //
    // Need to do this to fix up a localisation prob. in NT4
    //

    
    PatchLocalAppData(pProfile->hTokenUser);
    
    fGotLocalData = GetFolderPath (
        CSIDL_LOCAL_APPDATA,
        pProfile->hTokenUser,
        szLocalHiveDir);

    if (!fGotLocalData) {
        // a bogus error, check the debug output of GetFolderPath() for correct 
        // error code.
        return ERROR_INVALID_FUNCTION; 
    }


    //
    // append the terminating pathsep so we can
    // add more paths to the newly retrieved subdir
    //
    StringCchCat(szLocalHiveDir, cchLocalHiveDir, CLASSES_SUBDIRECTORY);

    //
    // We will now create our own subdir, CLASSES_SUBDIRECTORY,
    // inside the local appdata subdir we just received above.
    //
    fCreatedSubdirectory = CreateNestedDirectory(szLocalHiveDir, NULL);

    if (fCreatedSubdirectory) {
        return ERROR_SUCCESS;
    }

    return GetLastError();
}


//*************************************************************
//
//  UnloadClassHive()
//
//  Purpose:    unmounts a classes hive
//
//  Parameters: lpSidString     -   string representing user's
//                                  sid
//              lpSuffix        -   hive name suffix
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG UnloadClassHive(
    LPTSTR lpSidString,
    LPTSTR lpSuffix)
{
    LPTSTR lpHiveName = NULL;
    LONG error;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    HKEY hKey;
    UNICODE_STRING ClassesFullPath;
    DWORD cchHiveName;

    //
    // Get memory for the combined hive key name 
    //
    cchHiveName = lstrlen(lpSidString) +
                  lstrlen(USER_KEY_PREFIX) + 
                  lstrlen(lpSuffix) + 
                  1;
                  
    lpHiveName = (LPTSTR) LocalAlloc(LPTR, cchHiveName * sizeof(TCHAR));

    if (!lpHiveName)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // build the key name of the combined hive
    //
    StringCchCopy( lpHiveName, cchHiveName, USER_KEY_PREFIX );
    StringCchCat ( lpHiveName, cchHiveName, lpSidString );
    StringCchCat ( lpHiveName, cchHiveName, lpSuffix);

    //
    // Prepare to open the root of the classes hive
    // 
    RtlInitUnicodeString(&ClassesFullPath, lpHiveName);

    InitializeObjectAttributes(&Attributes,
                               &ClassesFullPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &Attributes );

    if (NT_SUCCESS(Status)) {

        //
        // Make sure the hive is persisted properly
        //
        RegFlushKey(hKey);
        RegCloseKey(hKey);

        //
        // Unmount the hive -- this should only fail if
        // someone has a subkey of the hive open -- this 
        // should not normally happen and probably means there's a service
        // that is leaking keys.
        //
        if (MyRegUnLoadKey(HKEY_USERS,
                           lpHiveName + ((sizeof(USER_KEY_PREFIX) / sizeof(TCHAR))-1))) {
            error = ERROR_SUCCESS;
        } else {
            error = GetLastError();
        }

    } else {

        error = RtlNtStatusToDosError(Status);
    }


Exit:
    if (lpHiveName)
        LocalFree(lpHiveName);
        
    if (error != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnLoadClassHive: failed to unload classes key with %x"), error));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UnLoadClassHive: Successfully unmounted %s%s"), lpSidString, lpSuffix));
    }


    return  error;
}

//*************************************************************
//
//  UnloadClasses()
//
//  Purpose:    Free the special combined hive
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//
//  Return:     TRUE if successful
//              FALSE if not
//
//*************************************************************
BOOL UnloadClasses(
    LPTSTR lpSidString)
{
    LONG Error;
  
    // unload user classes hive
    Error = UnloadClassHive(
        lpSidString,
        USER_CLASSES_HIVE_SUFFIX);

    return ERROR_SUCCESS == Error;
}


HRESULT MyRegLoadKeyEx(HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpFile, HKEY hKeyTrustClass)
{
    HRESULT             hr = E_FAIL;
    NTSTATUS            Status;
    TCHAR               lpKeyName[MAX_PATH];
    UNICODE_STRING      UnicodeKeyName;
    UNICODE_STRING      UnicodeFileName;
    OBJECT_ATTRIBUTES   keyAttributes;
    OBJECT_ATTRIBUTES   fileAttributes;
    BOOLEAN             WasEnabled;
    BOOL                bAdjustPriv = FALSE;
    BOOL                bAllocatedFileName = FALSE;
    HANDLE              hToken = NULL;
    

    DebugMsg((DM_VERBOSE, TEXT("MyRegLoadKeyEx:  Loading key <%s>"), lpSubKey));

    //
    //  Only support loading hive to HKU or HKLM
    //

    if (hKeyRoot != HKEY_USERS && hKeyRoot != HKEY_LOCAL_MACHINE)
    {
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx:  only HKU or HKLM is supported!")));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
    
    //
    //  Construct the key name for kernel object
    //
    
    hr =  StringCchCopy(lpKeyName, ARRAYSIZE(lpKeyName), (hKeyRoot == HKEY_USERS) ? TEXT("\\Registry\\User\\") : TEXT("\\Registry\\Machine\\"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx: StringCchCopy failed, hr = %08X"), hr));
        goto Exit;
    }

    hr = StringCchCat (lpKeyName, ARRAYSIZE(lpKeyName), lpSubKey);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx: StringCchCat failed, hr = %08X"), hr));
        goto Exit;
    }

    //
    //  Initialize the key object attribute
    //

    RtlInitUnicodeString(&UnicodeKeyName, lpKeyName);

    InitializeObjectAttributes(&keyAttributes,
                               &UnicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    //  Convert the file name to kernel file name
    //

    if (!RtlDosPathNameToNtPathName_U(lpFile,
                                      &UnicodeFileName,
                                      NULL,
                                      NULL))
    {
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx: RtlDosPathNameToNtPathName_U failed for <%s>!"), lpFile));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    bAllocatedFileName = TRUE;
    
    //
    //  Initialize the file object attribute
    //

    InitializeObjectAttributes(&fileAttributes,
                               &UnicodeFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Check to see if we are impersonating, if not, we need to enable the Restore privilege
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL)
    {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

        if (!NT_SUCCESS(Status))
        {
            DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx:  Failed to enable restore privilege to load registry key, Status = %08x"), Status));
            hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
            goto Exit;
        }

        bAdjustPriv = TRUE;
    }
    else
    {
        CloseHandle(hToken);
    }

    //
    //  Now loading the key
    //

    
/*
    Status = NtLoadKey(&keyAttributes,
                       &fileAttributes);
*/
    Status = NtLoadKeyEx(&keyAttributes,
                         &fileAttributes,
                         0,
                         hKeyTrustClass);
    
    if (!NT_SUCCESS(Status))
    {
        TCHAR   szErr[MAX_PATH];
        DWORD   dwErr;
        
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx: NtLoadKey failed for <%s>, Status = %08x"), lpSubKey, Status));
        dwErr = RtlNtStatusToDosError(Status); 
        ReportError(NULL, PI_NOUI, 2, EVENT_REGLOADKEYFAILED, GetErrString(dwErr, szErr), lpFile);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

#if defined(_WIN64)
    else
    {
        //
        // Notify Wow64 service that it need to watch this hive if it care to do so
        //
        if ( hKeyRoot == HKEY_USERS )
            Wow64RegNotifyLoadHiveUserSid ( lpSubKey );
    }
#endif

    DebugMsg((DM_VERBOSE, TEXT("MyRegLoadKeyEx: Successfully loaded <%s>"), lpSubKey));
    hr = S_OK;

Exit:

    //
    // Restore the privilege to its previous state
    //

    if(bAdjustPriv)
    {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
        
        if (!NT_SUCCESS(Status))
        {
            DebugMsg((DM_WARNING, TEXT("MyRegLoadKeyEx:  Failed to restore RESTORE privilege to previous enabled state. Status = %08X"), Status));
        }
    }

    if (bAllocatedFileName)
    {
        RtlFreeUnicodeString(&UnicodeFileName);
    }
    
    return hr;
}


//*************************************************************
//
//  CreateUserClasses()
//
//  Purpose:    Creates necessary hives for user classes
//
//  Parameters: lpProfile   -   Profile information
//              lpSidString -   User's Sid as a string
//              lpSuffix    -   Suffix to follow the user's sid
//                              when naming the hive
//              lpHiveFileName - full path for backing hive file
//                               of user classes
//              phkResult      - root of created hive on
//                               success
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************
LONG CreateClassHive(
    LPPROFILE lpProfile,
    LPTSTR    lpSidString,
    LPTSTR    lpSuffix,
    LPTSTR    lpHiveFilename,
    BOOL      bNewlyIssued)
{
    LONG                      res;
    LPTSTR                    lpHiveKeyName = NULL;
    WIN32_FILE_ATTRIBUTE_DATA fd;
    BOOL                      fHiveExists;
    HKEY                      hkRoot = NULL;
    DWORD                     cchHiveKeyName;
    HKEY                      hKeyUser = NULL;
    HRESULT                   hr;

    //
    // allocate a space big enough for the hive name
    //
    cchHiveKeyName = lstrlen(lpSidString) +
                     lstrlen(lpSuffix) + 
                     1;
                     
    lpHiveKeyName = (LPTSTR) LocalAlloc(LPTR, cchHiveKeyName * sizeof(TCHAR) );

    if ( !lpHiveKeyName )
    {
        res = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Open the HKU\{Sid} first, we use this handle as the trust class
    //
    StringCchCopy(lpHiveKeyName, cchHiveKeyName, lpSidString);

    res = RegOpenKeyEx(HKEY_USERS,
                       lpHiveKeyName,
                       0,
                       KEY_READ,
                       &hKeyUser);

    if (res != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CreateClassHive: fail to open user hive. Error %d"),res));
        goto Exit;
    }

    //
    // Append the suffix to construct the class hive key name
    //
    StringCchCat (lpHiveKeyName, cchHiveKeyName, lpSuffix);
   
    //
    // First, see if this hive already exists. We need to do this rather than just letting
    // RegLoadKey create or load the existing hive because if the hive is new,
    // we need to apply security. 
    //
    fHiveExists = GetFileAttributesEx(
        lpHiveFilename,
        GetFileExInfoStandard,
        &fd );

    //
    // mount the hive
    //
    hr = MyRegLoadKeyEx(HKEY_USERS, lpHiveKeyName, lpHiveFilename, hKeyUser);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateClassHive: MyRegLoadKeyEx failed, hr = %08X"), hr));
        res = HRESULT_CODE(hr);
        goto Exit;
    } 

    //
    // If we succeeded, open the root
    //

    res = RegOpenKeyEx( HKEY_USERS,
                        lpHiveKeyName,
                        0,
                        WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                        &hkRoot);

    if (ERROR_SUCCESS != res) {
        MyRegUnLoadKey(HKEY_USERS, lpHiveKeyName);
        DebugMsg((DM_WARNING, TEXT("CreateClassHive: fail to open classes hive. Error %d"),res));
        goto Exit;
    }

    if (!fHiveExists || bNewlyIssued) {

        if (!fHiveExists) {
            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive not found")));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: user classes hive copied from Default User")));
        }

        //
        // This hive is newly issued i.e. either created fresh or copied from
        // "Default User" profile, so we need to set security on the new hive
        //

        //
        // set security on this hive
        //
        if (!SetDefaultUserHiveSecurity(lpProfile, NULL, hkRoot)) {
            res = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CreateClassHive: Fail to assign proper security on new classes hive")));
        }
        
        //
        // If we succeed, set the hidden attribute on the backing hive file
        //
        if (ERROR_SUCCESS == res) {

            if (!SetFileAttributes (lpHiveFilename, FILE_ATTRIBUTE_HIDDEN)) {
                DebugMsg((DM_WARNING, TEXT("CreateClassHive: unable to set file attributes")
                          TEXT(" on classes hive %s with error %x"), lpHiveFilename, GetLastError()));
            }
        }

    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateClassHive: existing user classes hive found")));
    }

    

Exit:

    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }
    
    if (hkRoot) {
        RegCloseKey(hkRoot);
    }

    if (lpHiveKeyName)
        LocalFree(lpHiveKeyName);
        
    return res;
}


//*************************************************************
//
//  CreateUserClassesHive()
//
//  Purpose:    create the user-specific classes hive
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//              szLocalHiveDir - directory in userprofile 
//                               where hive should be located
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/6/98      adamed     Created
//
//*************************************************************
LONG CreateUserClassesHive(
    LPPROFILE lpProfile,
    LPTSTR SidString,
    LPTSTR szLocalHiveDir,
    BOOL   bNewlyIssued)
{
    LPTSTR  lpHiveFilename = NULL;
    LONG    res;
    DWORD   cchHiveFilename;

    // allocate a space big enough for the hive filename (including trailing null)
    cchHiveFilename = lstrlen(szLocalHiveDir) +
                      lstrlen(USER_CLASSES_HIVE_NAME) +
                      1;
                      
    lpHiveFilename = (LPTSTR) LocalAlloc(LPTR, cchHiveFilename * sizeof(TCHAR));

    if ( !lpHiveFilename ) {
        res = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    StringCchCopy( lpHiveFilename, cchHiveFilename, szLocalHiveDir);
    StringCchCat ( lpHiveFilename, cchHiveFilename, USER_CLASSES_HIVE_NAME);

    res = CreateClassHive(
        lpProfile,
        SidString,
        USER_CLASSES_HIVE_SUFFIX,
        lpHiveFilename,
        bNewlyIssued);

    if (ERROR_SUCCESS != res) {
        goto Exit;
    }

    res = MapUserClassesIntoUserHive(lpProfile, SidString);

Exit:
    if (lpHiveFilename)
        LocalFree(lpHiveFilename);
        
    return res;
}


//*************************************************************
//
//  MoveUserClassesBeforeMerge
//
//  Purpose:    move HKCU\Software\Classes before
//              MapUserClassesIntoUserHive() deletes it.
//
//  Parameters: lpProfile -   Profile information
//              lpcszLocalHiveDir - Temp Hive location
//
//  Return:     ERROR_SUCCESS if successful,
//              other error if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/6/99      vtan       Created
//
//*************************************************************
LONG MoveUserClassesBeforeMerge(
    LPPROFILE lpProfile,
    LPCTSTR lpcszLocalHiveDir)
{
    LONG    res;
    HKEY    hKeySource;

    // Open HKCU\Software\Classes and see if there is a subkey.
    // No subkeys would indicate that the move has already been
    // done or there is no data to move.

    res = RegOpenKeyEx(lpProfile->hKeyCurrentUser, CLASSES_CLSID_SUBTREE, 0, KEY_ALL_ACCESS, &hKeySource);
    if (ERROR_SUCCESS == res)
    {
        DWORD   dwSubKeyCount;

        if ((ERROR_SUCCESS == RegQueryInfoKey(hKeySource, NULL, NULL, NULL, &dwSubKeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) &&
            (dwSubKeyCount > 0))
        {
            LPTSTR  pszLocalTempHive;
            DWORD   cchLocalTempHive;

            // Allocate enough space for the local hive directory and the temp hive filename.

            cchLocalTempHive = lstrlen(lpcszLocalHiveDir) + lstrlen(TEMPHIVE_FILENAME) + 1;
            pszLocalTempHive = (LPTSTR) LocalAlloc(LPTR, cchLocalTempHive * sizeof(TCHAR));

            // Get a path to a file to save HKCU\Software\Classes into.

            if (pszLocalTempHive != NULL)
            {
                HANDLE  hToken = NULL;
                BOOL    bAdjustPriv = FALSE;

                StringCchCopy(pszLocalTempHive, cchLocalTempHive, lpcszLocalHiveDir);
                StringCchCat (pszLocalTempHive, cchLocalTempHive, TEMPHIVE_FILENAME);

                // RegSaveKey() fails if the file exists so delete it first.

                DeleteFile(pszLocalTempHive);

                //
                // Check to see if we are impersonating.
                //

                if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
                    bAdjustPriv = TRUE;
                }
                else {
                    CloseHandle(hToken);
                }

                if(!bAdjustPriv) {

                    DWORD   dwDisposition;
                    HKEY    hKeyTarget;
                    BOOL    fSavedHive;

                    // Save HKCU\Software\Classes into the temp hive
                    // and restore the state of SE_BACKUP_NAME privilege

                    res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                    
                    if (ERROR_SUCCESS == res)
                    {
                        res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                        if (ERROR_SUCCESS == res)
                        {

                            // Restore temp hive to a new location at
                            // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                            // This performs the upgrade from NT4 to NT5.

                            res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                            if (ERROR_SUCCESS != res)
                            {
                                DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                            }
                            RegCloseKey(hKeyTarget);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                    }
                }
                else {
                    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                    {
                        DWORD               dwReturnTokenPrivilegesSize;
                        TOKEN_PRIVILEGES    oldTokenPrivileges, newTokenPrivileges;

                        // Enable SE_BACKUP_NAME privilege

                        if (LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &newTokenPrivileges.Privileges[0].Luid))
                        {
                            newTokenPrivileges.PrivilegeCount = 1;
                            newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                            if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                            {
                                BOOL    fSavedHive;

                                // Save HKCU\Software\Classes into the temp hive
                                // and restore the state of SE_BACKUP_NAME privilege

                                res = RegSaveKey(hKeySource, pszLocalTempHive, NULL);
                                if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                {
                                    DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                }
                                if (ERROR_SUCCESS == res)
                                {

                                    // Enable SE_RESTORE_NAME privilege.

                                    if (LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &newTokenPrivileges.Privileges[0].Luid))
                                    {
                                        newTokenPrivileges.PrivilegeCount = 1;
                                        newTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                                        if (AdjustTokenPrivileges(hToken, FALSE, &newTokenPrivileges, sizeof(newTokenPrivileges), &oldTokenPrivileges, &dwReturnTokenPrivilegesSize))
                                        {
                                            DWORD   dwDisposition;
                                            HKEY    hKeyTarget;

                                            res = RegCreateKeyEx(lpProfile->hKeyCurrentUser, EXPLORER_CLASSES_SUBTREE, 0, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTarget, &dwDisposition);
                                            if (ERROR_SUCCESS == res)
                                            {

                                                // Restore temp hive to a new location at
                                                // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer
                                                // This performs the upgrade from NT4 to NT5.

                                                res = RegRestoreKey(hKeyTarget, pszLocalTempHive, 0);
                                                if (ERROR_SUCCESS != res)
                                                {
                                                    DebugMsg((DM_WARNING, TEXT("RegRestoreKey failed with error %d"), res));
                                                }
                                                RegCloseKey(hKeyTarget);
                                            }
                                            else
                                            {
                                                DebugMsg((DM_WARNING, TEXT("RegCreateKeyEx failed to create key %s with error %d"), EXPLORER_CLASSES_SUBTREE, res));
                                            }
                                            if (!AdjustTokenPrivileges(hToken, FALSE, &oldTokenPrivileges, 0, NULL, NULL))
                                            {
                                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed to restore old privileges with error %d"), GetLastError()));
                                            }
                                        }
                                        else
                                        {
                                            res = GetLastError();
                                            DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                                        }
                                    }
                                    else
                                    {
                                        res = GetLastError();
                                        DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("RegSaveKey failed with error %d"), res));
                                }
                            }
                            else
                            {
                                res = GetLastError();
                                DebugMsg((DM_WARNING, TEXT("AdjustTokenPrivileges failed with error %d"), res));
                            }
                        }
                        else
                        {
                            res = GetLastError();
                            DebugMsg((DM_WARNING, TEXT("LookupPrivilegeValue failed with error %d"), res));
                        }
                        CloseHandle(hToken);
                    }
                    else
                    {
                        res = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("OpenProcessToken failed to get token with error %d"), res));
                    }
                } // if(!bAdjustPriv) else

                // Delete local temporary hive file.

                DeleteFile(pszLocalTempHive);

                LocalFree(pszLocalTempHive);
            }
            else
            {
                res = ERROR_NOT_ENOUGH_MEMORY;
                DebugMsg((DM_WARNING, TEXT("LocalAlloc failed to allocate temp hive path buffer")));
            }
        }
        RegCloseKey(hKeySource);
    }
    else if (ERROR_FILE_NOT_FOUND == res)
    {
        res = ERROR_SUCCESS;
    }
    return res;
}


//*************************************************************
//
//  LoadUserClasses()
//
//  Purpose:    Combines the HKLM\Software\Classes subtree with the
//              HKCU\Software\Classes subtree
//
//  Parameters: lpProfile -   Profile information
//              SidString -   User's Sid as a string
//
//  Return:     ERROR_SUCCESS if successful
//              other NTSTATUS if an error occurs
//
//*************************************************************
LONG LoadUserClasses( LPPROFILE lpProfile, LPTSTR SidString, BOOL bNewlyIssued)
{
    LONG   error;
    LPTSTR szLocalHiveDir = NULL;

    error = ERROR_SUCCESS;

    //
    // first, we will create a directory for the user-specific
    // classes hive -- we need memory for it:
    //
    szLocalHiveDir = (LPTSTR) LocalAlloc(LPTR, MAX_HIVE_DIR_CCH * sizeof(TCHAR));

    if (!szLocalHiveDir) {
        error =ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // create the directory for the user-specific classes hive
    //
    error = CreateClassesFolder(lpProfile, szLocalHiveDir, MAX_HIVE_DIR_CCH);

    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("LoadUserClasses: Failed to create folder for combined hive (%d)."),
                 error));
        goto Exit;
    }

    // Move HKCU\Software\Classes before merging the two
    // branches. Ignore any errors here as this branch is
    // about to be deleted by the merge anyway.
    // The reason for this move is because NT4 stores customized
    // shell icons in HKCU\Software\Classes\CLSID\{CLSID_x} and
    // NT5 stores this at HKCU\Software\Microsoft\Windows\
    // CurrentVersion\Explorer\CLSID\{CLSID_x} and must be moved
    // now before being deleted.

    error = MoveUserClassesBeforeMerge(lpProfile, szLocalHiveDir);
    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("MoveUserClassesBeforeMerge: Failed unexpectedly (%d)."),
                 error));
    }

    //
    // Now create the user classes hive
    //
    error = CreateUserClassesHive( lpProfile, SidString, szLocalHiveDir, bNewlyIssued);

    if (ERROR_SUCCESS != error) {
        DebugMsg((DM_WARNING, TEXT("LoadUserClasses: Failed to create user classes hive (%d)."),
                 error));
    }

Exit:
    if (szLocalHiveDir)
        LocalFree(szLocalHiveDir);
        
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\migrate.c ===
//*************************************************************
//
//  User Profile migration routines
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "strsafe.h"

UINT CountItems (LPTSTR lpDirectory);

BOOL SearchAndReplaceIEHistory(LPTSTR szIEHistKeyRoot, LPTSTR szHistOld, LPTSTR szHistNew);


//*************************************************************
//
//  DetermineLocalSettingsLocation()
//
//  Purpose:    Determines where to put the local settings
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
// Look at all the shell folders and see which of them are expected to go to
// local settings on nt5. Some of them might already be moved to random
// locations based on the localisations. We should figure out where it is
// pointing to by looking at these locations and make a call
//*************************************************************


BOOL DetermineLocalSettingsLocation(LPTSTR szLocalSettings, DWORD cchLocalSettings)
{
    TCHAR  szPath[MAX_PATH];
    LPTSTR lpEnd, lpBgn;
    HKEY hKey, hKeyRoot;
    DWORD dwDisp, dwSize, dwType, i;

    if (RegOpenCurrentUser(KEY_READ | KEY_WRITE, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegOpenKeyEx(hKeyRoot, USER_SHELL_FOLDERS,
                            0, KEY_READ, &hKey) == ERROR_SUCCESS) {


            for (i=0; i < g_dwNumShellFolders; i++) {
                if (c_ShellFolders[i].bNewNT5 && c_ShellFolders[i].bLocalSettings) {

                    dwSize = sizeof(szPath);

                    if (RegQueryValueEx(hKey, c_ShellFolders[i].lpFolderName,
                                        0, &dwType, (LPBYTE)szPath, &dwSize) == ERROR_SUCCESS) {

                        if (lstrlen(szPath) > lstrlen(TEXT("%userprofile%"))) {

                            DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: Considering shell folder %s"), szPath));

                            //
                            // Move the pointer upto the next slash
                            //

                            lpBgn = szPath + lstrlen(TEXT("%userprofile%"))+1;
                            lpEnd = lpBgn;

                            for (;(*lpEnd != TEXT('\0'));lpEnd++) {

                                //
                                // we have found a shellfolder of the form %userprofile%\subdir\xxx
                                // assume this subdir as the localsettings path
                                //

                                if (( (*lpEnd) == TEXT('\\') ) && ( (*(lpEnd+1)) != TEXT('\0')) )
                                    break;
                            }


                            if ((*lpEnd == TEXT('\\')) && (*(lpEnd+1) != TEXT('\0'))) {
                                *lpEnd = TEXT('\0');
                                StringCchCopy(szLocalSettings, cchLocalSettings, lpBgn);

                                DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: Assuming %s to be the local settings directory"), lpBgn));
                                RegCloseKey(hKey);
                                RegCloseKey(hKeyRoot);
                                return TRUE;
                            }

                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }

        RegCloseKey(hKeyRoot);
    }

    //
    // otherwise load it from the rc file
    //

    LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS, szLocalSettings, MIN(MAX_FOLDER_SIZE , cchLocalSettings));
    DebugMsg((DM_VERBOSE, TEXT("DetermineLocalSettingsLocation: No Local Settings was found, using %s"), szLocalSettings));

    return TRUE;
}


//*************************************************************
//
//  MigrateNT4ToNT5()
//
//  Purpose:    Migrates a user profile from NT4 to NT5
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI MigrateNT4ToNT5 (void)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_PATH];
    TCHAR szLocalSettings[MAX_PATH];
    LPTSTR lpEnd, lpEnd1, lpBgn=NULL;
    HKEY hKey = NULL, hKeyRoot = NULL;
    DWORD dwDisp, dwSize, dwType, i;
    BOOL bSetTemp = TRUE;
    BOOL bCleanUpTemp = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    const LPTSTR szUserProfile = TEXT("%USERPROFILE%\\");
    DWORD dwUserProfile = lstrlen(szUserProfile);
    DWORD dwString = 0;
    int StringLen;
    DWORD cchEnd;

    //
    // Get the root registry key handle
    //

    if (RegOpenCurrentUser(KEY_READ | KEY_WRITE, &hKeyRoot) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("MigrateNT4ToNT5: Failed to get root registry key with %d"),
                 GetLastError()));
    }


    //
    // Convert Personal to My Documents
    //
    // We have to be careful with this directory.  We'll rename
    // Personal to My Documents only if the Personal directory
    // is empty.  After this, we'll fix up the registry special folder
    // location only if it is still pointing at the default Personal location.
    //

    StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);

    if ( LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2)) )
    {
        //lstrcpyn (szTemp + dwUserProfile, szTemp2, ARRAYSIZE(szTemp) - dwUserProfile);
        StringCchCat(szTemp, ARRAYSIZE(szTemp), szTemp2);

        if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))))
        {

            //
            // Check if the personal directory exists
            //

            if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

                //
                // Check if the personal directory is empty
                //

                if (!CountItems (szTemp2)) {

                    //
                    // The directory is empty, so rename it to My Documents
                    //

                    LoadString (g_hDllInstance, IDS_SH_PERSONAL, szTemp3, ARRAYSIZE(szTemp3));
                    StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
                    StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp3);
                    
                    if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3))))
                    {

                        if (MoveFileEx(szTemp2, szTemp3, 0)) {

                            //
                            // Now we need to fix up the registry value if it is still set
                            // to the default of %USERPROFILE%\Personal
                            //

                            if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                                          0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS) {

                                dwSize = sizeof(szTemp3);
                                szTemp3[0] = TEXT('\0');
                                if (RegQueryValueEx (hKey, TEXT("Personal"), NULL, &dwType,
                                                 (LPBYTE) szTemp3, &dwSize) == ERROR_SUCCESS) {

                                    LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp2, ARRAYSIZE(szTemp2));
                                    StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
                                    StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp2);

                                    if (lstrcmpi(szTemp, szTemp3) == 0) {

                                        LoadString (g_hDllInstance, IDS_SH_PERSONAL, szTemp3, ARRAYSIZE(szTemp3));
                                        StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
                                        StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp3);

                                        RegSetValueEx (hKey, TEXT("Personal"), 0, REG_EXPAND_SZ,
                                                    (LPBYTE) szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));


                                        //
                                        // We need to reinitialize the global variables now because
                                        // the path to the My Documents and My Pictures folder has changed.
                                        //

                                        InitializeGlobals(g_hDllInstance);
                                    }
                                }

                                RegCloseKey (hKey);
                                hKey = NULL;
                            }
                        }
                    }
                }
            }
        }
    }


    //
    // Get the user profile directory
    //

    dwString = GetEnvironmentVariable (TEXT("USERPROFILE"), szTemp, ARRAYSIZE (szTemp));

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Upgrading <%s> from NT4 to NT5"),
             szTemp));


    //
    // Hide ntuser.dat and ntuser.dat.log
    //

    if(dwString < ARRAYSIZE(szTemp) - 1 && dwString > 0) {
        lpEnd = CheckSlashEx (szTemp, ARRAYSIZE(szTemp), &cchEnd);
        StringCchCopy (lpEnd, cchEnd, TEXT("ntuser.dat"));
    }
    else {
        goto Exit;
    }
    SetFileAttributes (szTemp, FILE_ATTRIBUTE_HIDDEN);

    StringCchCopy (lpEnd, cchEnd, TEXT("ntuser.dat.log"));
    SetFileAttributes (szTemp, FILE_ATTRIBUTE_HIDDEN);


    DetermineLocalSettingsLocation(szLocalSettings, ARRAYSIZE(szLocalSettings));


    //
    // Check if Temporary Internet Files exists in the root of the
    // user's profile.  If so, move it to the new location
    //
    // migrate these stuff before we nuke the old User_shell_folders
    //

    if (RegOpenKeyEx(hKeyRoot, USER_SHELL_FOLDERS,
                        0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx(hKey, TEXT("Cache"), 0, &dwType, (LPBYTE)szTemp, &dwSize) != ERROR_SUCCESS) {

            //
            // if this value is not there go by the default location from the
            // resources
            //

            LoadString (g_hDllInstance, IDS_TEMPINTERNETFILES, szTemp2, ARRAYSIZE(szTemp2));

            StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
            StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp2);
        }


        if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2)))) {

            if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

                LoadString (g_hDllInstance, IDS_SH_CACHE, szTemp3, ARRAYSIZE(szTemp3));
                StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);

                //
                // append the newly found localsettings
                //
                StringCchCat (szTemp, ARRAYSIZE(szTemp), szLocalSettings);

                if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                    lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchEnd);
                    StringCchCopy (lpEnd, cchEnd, szTemp3);
                }
                else {
                    goto Exit;
                }
                if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3)))) {

                    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: New temp int files folder (expand path) %s"), szTemp3));
                    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Old temp int files folder (expand path) %s"), szTemp2));

                    if (lstrcmpi(szTemp2, szTemp3) != 0) {
                        if (CopyProfileDirectory (szTemp2, szTemp3, CPD_IGNOREHIVE)) {
                            Delnode (szTemp2);
                        }
                    }
                }
            }
        }

        //
        // Check if History exists in the root of the user's profile.
        // If so, move it to the new location
        //

        dwSize = sizeof(szTemp);

        if (RegQueryValueEx(hKey, TEXT("History"), 0, &dwType, (LPBYTE)szTemp, &dwSize) != ERROR_SUCCESS) {

            //
            // if this value is not there go by the default location from the
            // resources
            //

            LoadString (g_hDllInstance, IDS_HISTORY, szTemp2, ARRAYSIZE(szTemp2));

            StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
            StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp2);
        }


        if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2)))) {
        
            if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

                LoadString (g_hDllInstance, IDS_SH_HISTORY, szTemp3, ARRAYSIZE(szTemp3));
                StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);

                //
                // append the newly found localsettings
                //
                StringCchCat (szTemp, ARRAYSIZE(szTemp), szLocalSettings);
                if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                    lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchEnd);
                }
                else {
                    goto Exit;
                }

                StringCchCopy (lpEnd, cchEnd, szTemp3);
                if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp3, ARRAYSIZE(szTemp3)))) {
 
                    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: New histroy folder (expand path) %s"), szTemp3));
                    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Old histroy folder (expand path) %s"), szTemp2));

                    if (lstrcmpi(szTemp2, szTemp3) != 0) {
                        if (CopyProfileDirectory (szTemp2, szTemp3, CPD_IGNOREHIVE)) {
                            Delnode (szTemp2);
                            SearchAndReplaceIEHistory(IE4_CACHE_KEY, szTemp2, szTemp3);
                            SearchAndReplaceIEHistory(IE5_CACHE_KEY, szTemp2, szTemp3);
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }


    //
    // Update the local settings key with the new value
    //

    StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
    if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchEnd);
    }
    else {
        goto Exit;
    }

    if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        StringCchCopy(lpEnd, cchEnd, szLocalSettings); 

        RegSetValueEx (hKey, TEXT("Local Settings"),
                     0, REG_EXPAND_SZ, (LPBYTE) szTemp,
                     ((lstrlen(szTemp) + 1) * sizeof(TCHAR)));

        RegCloseKey (hKey);
        hKey = NULL;
    }

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Update the local settings folder with %s"), szTemp));


    //
    // Globals needs to reinitialised because LocalSettings might be different from
    // the one specified in the rc file
    //

    InitializeGlobals(g_hDllInstance);


    //
    // Get the user profile directory
    //

    dwString = GetEnvironmentVariable (TEXT("USERPROFILE"), szTemp, ARRAYSIZE (szTemp));

    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Upgrading <%s> from NT4 to NT5"),
             szTemp));

    if(dwString < ARRAYSIZE(szTemp) - 1 && dwString > 0) {
        lpEnd = CheckSlashEx (szTemp, ARRAYSIZE(szTemp), &cchEnd);
    }
    else {
        goto Exit;
    }


    //
    // Create the new special folders
    //

    for (i=0; i < g_dwNumShellFolders; i++) {

        if (c_ShellFolders[i].bNewNT5) {

            StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation); 

            if (!CreateNestedDirectory(szTemp, NULL)) {
                DebugMsg((DM_WARNING, TEXT("MigrateNT4ToNT5: Failed to create the destination directory <%s>.  Error = %d"),
                         szTemp, GetLastError()));
            }

            if (c_ShellFolders[i].bHidden) {
                SetFileAttributes(szTemp, FILE_ATTRIBUTE_HIDDEN);
            } else {
                SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL);
            }
        }
    }


    //
    // Set the new special folders in the User Shell Folder registry key
    //

    StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
    if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
        lpEnd = CheckSlashEx (szTemp, ARRAYSIZE(szTemp), &cchEnd);
    }
    else {
        goto Exit;
    }

    if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bNewNT5 && c_ShellFolders[i].bAddCSIDL) {
                StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation); 

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szTemp,
                             ((lstrlen(szTemp) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }



    //
    // Query the user's environment for a TEMP environment variable.
    //

    if (RegCreateKeyEx (hKeyRoot, TEXT("Environment"), 0,
                        NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {


        szTemp2[0] = TEXT('\0');
        dwSize = sizeof(szTemp2);
        RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                         (LPBYTE) szTemp2, &dwSize);


        //
        // Decide if we should set the temp and tmp environment variables.
        // We need to be careful to not blast someone's custom temp variable
        // if it already exists, but at the same time it's ok to remap this if
        // temp is still set to the NT4 default of %SystemDrive%\TEMP.
        //

        if (szTemp2[0] != TEXT('\0')) {
            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szTemp2, -1, TEXT("%SystemDrive%\\TEMP"), -1) != CSTR_EQUAL) {
                bSetTemp = FALSE;
            }

            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szTemp2, -1, TEXT("%USERPROFILE%\\TEMP"), -1) == CSTR_EQUAL) {
                bSetTemp = TRUE;
                bCleanUpTemp = TRUE;
            }
        }


        if (bSetTemp) {
            LoadString (g_hDllInstance, IDS_SH_TEMP, szTemp2, ARRAYSIZE(szTemp2));
            StringCchCopy(lpEnd, cchEnd, szLocalSettings); 
            if(lstrlen(szTemp) < ARRAYSIZE(szTemp) - 1) {
                lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchEnd);
                StringCchCopy (lpEnd, cchEnd, szTemp2); 
            }
            else {
                goto Exit;
            }

            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Setting the Temp directory to <%s>"), szTemp));


            RegSetValueEx (hKey, TEXT("TEMP"), 0, REG_EXPAND_SZ,
                           (LPBYTE) szTemp, (lstrlen (szTemp) + 1) * sizeof(TCHAR));

            RegSetValueEx (hKey, TEXT("TMP"), 0, REG_EXPAND_SZ,
                           (LPBYTE) szTemp, (lstrlen (szTemp) + 1) * sizeof(TCHAR));
        }

        if (bCleanUpTemp) {
            if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))) && 
                SUCCEEDED(SafeExpandEnvironmentStrings (TEXT("%USERPROFILE%\\TEMP"), szTemp, ARRAYSIZE(szTemp)))) {

                if (CopyProfileDirectory (szTemp, szTemp2, CPD_IGNOREHIVE)) {
                    Delnode (szTemp);
                }
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }


    //
    // Migrate the Template Directory if it exists. Copy it from %systemroot%\shellnew
    // to Templates directory userprofile..
    //

    if ((LoadString (g_hDllInstance, IDS_SH_TEMPLATES2, szTemp2, ARRAYSIZE(szTemp2))) &&
            (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp2, szTemp3, ARRAYSIZE(szTemp3)))) &&
            (LoadString (g_hDllInstance, IDS_SH_TEMPLATES, szTemp2, ARRAYSIZE(szTemp2)))) {

        //
        // if all of the above succeeded
        // szTemp3 will have the full path for the old templates dir..
        //

        StringCchCopy (szTemp, ARRAYSIZE(szTemp), szUserProfile);
        StringCchCat (szTemp, ARRAYSIZE(szTemp), szTemp2);

        if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2)))) {

            if (GetFileAttributesEx (szTemp3, GetFileExInfoStandard, &fad)) {
                DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Copying Template files from %s to %s"), szTemp3, szTemp2));
                CopyProfileDirectory(szTemp3, szTemp2, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE);
            }
        }
    }


    //
    // Set the user preference exclusion list.  This will
    // prevent the Local Settings folder from roaming
    //

    if (LoadString (g_hDllInstance, IDS_EXCLUSIONLIST,
                    szTemp, ARRAYSIZE(szTemp))) {

        if (RegCreateKeyEx (hKeyRoot, WINLOGON_KEY,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {


            dwSize = sizeof(szTemp);

            RegQueryValueEx (hKey, TEXT("ExcludeProfileDirs"),
                                 NULL, &dwType, (LPBYTE) szTemp,
                                 &dwSize);

            //
            // Read in the value of the local settings
            //

            LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS,
                    szTemp2, ARRAYSIZE(szTemp2));


            //
            // Loop through the list
            //

            lpBgn = lpEnd = szTemp;
            *szTemp3 = TEXT('\0');

            while (*lpEnd) {

                //
                // Look for the semicolon separator
                //

                while (*lpEnd && ((*lpEnd) != TEXT(';'))) {
                    lpEnd++;
                }


                //
                // Remove any leading spaces
                //

                while (*lpBgn == TEXT(' ')) {
                    lpBgn++;
                }


                //
                // if it has come here we are going to attach something
                // to the end of szTmp3
                //

                StringLen = (int)(lpEnd - lpBgn);

                if (*szTemp3)
                    StringCchCat(szTemp3, ARRAYSIZE(szTemp3), TEXT(";"));

                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   lpBgn, StringLen, szTemp2, lstrlen(szTemp2)) != CSTR_EQUAL) {

                    StringCchCatN (szTemp3, ARRAYSIZE(szTemp3), lpBgn, StringLen);
                }
                else {
                    StringCchCat (szTemp3, ARRAYSIZE(szTemp3), szLocalSettings);
                }


                //
                // If we are at the end of the exclusion list, we're done
                //

                if (!(*lpEnd)) {
                    break;
                }


                //
                // Prep for the next entry
                //

                lpEnd++;
                lpBgn = lpEnd;
            }


            RegSetValueEx (hKey, TEXT("ExcludeProfileDirs"),
                           0, REG_SZ, (LPBYTE) szTemp3,
                           ((lstrlen(szTemp3) + 1) * sizeof(TCHAR)));

            DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Set the exclusionlist value to default")));

            RegCloseKey (hKey);
            hKey = NULL;
        }
    }


    //
    // Make sure the hidden bit is set correctly for each special folder
    //

    if (RegOpenKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            dwSize = sizeof(szTemp);
            szTemp[0] = TEXT('\0');

            if (RegQueryValueEx (hKey, c_ShellFolders[i].lpFolderName,
                                 NULL, &dwType, (LPBYTE) szTemp,
                                  &dwSize) == ERROR_SUCCESS) {

                if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))))
                {
                    if (c_ShellFolders[i].bHidden) {
                        SetFileAttributes(szTemp2, FILE_ATTRIBUTE_HIDDEN);
                    } else {
                        SetFileAttributes(szTemp2, FILE_ATTRIBUTE_NORMAL);
                    }
                }
            }
        }

        RegCloseKey (hKey);
        hKey = NULL;
    }


Exit:


    if(hKey != NULL) {
        RegCloseKey(hKey);
    }


    if (hKeyRoot != NULL) {
        RegCloseKey (hKeyRoot);
    }


    DebugMsg((DM_VERBOSE, TEXT("MigrateNT4ToNT5: Finished.")));

    return TRUE;
}

//*************************************************************
//
//  ResetUserSpecialFolderPaths()
//
//  Purpose:    Sets all of the user special folder paths back
//              to their defaults
//
//  Parameters: none
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI ResetUserSpecialFolderPaths(void)
{
    TCHAR szDirectory [MAX_PATH];
    HKEY hKey, hKeyRoot;
    DWORD dwDisp, i;
    LPTSTR lpEnd;
    DWORD cchEnd;


    //
    // Set the User Shell Folder paths in the registry
    //

    StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%USERPROFILE%"));
    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd );

    if (RegOpenCurrentUser(KEY_WRITE, &hKeyRoot) == ERROR_SUCCESS) {

        if (RegCreateKeyEx (hKeyRoot, USER_SHELL_FOLDERS,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {

            for (i=0; i < g_dwNumShellFolders; i++) {

                if (c_ShellFolders[i].bAddCSIDL) {
                    StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation);

                    RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                                 0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                                 ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
                }
            }

            RegCloseKey (hKey);
        }
        RegCloseKey (hKeyRoot);
    }

    return TRUE;
}

//*************************************************************
//
//  CountItems()
//
//  Purpose:    Counts the number of files and subdirectories
//              in the given subdirectory
//
//  Parameters: lpDirectory - parent directory
//
//  Return:     Item count
//
//*************************************************************

UINT CountItems (LPTSTR lpDirectory)
{
    TCHAR szDirectory[MAX_PATH];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    UINT uiCount = 0;


    //
    // Search through the directory
    //

    if (SUCCEEDED(StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), lpDirectory)) &&
        SUCCEEDED(StringCchCat  (szDirectory, ARRAYSIZE(szDirectory), TEXT("\\*.*"))))
    {

        hFile = FindFirstFile(szDirectory, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {
            return uiCount;
        }


        do {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, TEXT("."))) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
                continue;
            }

            uiCount++;

            //
            // Find the next entry
            //

        } while (FindNextFile(hFile, &fd));


        FindClose(hFile);
    }
    
    return uiCount;
}


//*************************************************************
//
//  SearchAndReplaceIEHistory()
//
//  Purpose:    Searches and Replaces the registry kesy pointing to
//              the old location in IE Cahe to point to New Location
//
//  Parameters:
//          szIEHistKeyRoot     - Root of the history key
//          szHistOld           - Old History Key
//          szHistNew           - New Location of History Key
//
//  Return:     TRUE if success, else False
//
//  Created:
//
// Notes:
//      Change the "HKCU\S\M\W\CV\Internet Settings\Cache\Extensible Cache\"MSHist***\CachePath" and
//      Change the "HKCU\S\M\W\CV\Internet Settings\5.0\Cache\Extensible Cache\MSHis***\CachePath"
//      value to the new place
//*************************************************************

BOOL SearchAndReplaceIEHistory(LPTSTR szIEHistKeyRoot, LPTSTR szHistOld, LPTSTR szHistNew)
{
    DWORD dwIndex = 0, dwMsHistLen, dwLen;
    TCHAR szSubKey[MAX_PATH+1], szSubKey1[MAX_PATH+1];
    TCHAR szCachePath[MAX_PATH];
    TCHAR szCachePath1[MAX_PATH];
    FILETIME ftWrite;
    HKEY hIECacheKey, hKey;

    DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Fixing up the IE Registry keys")));

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szIEHistKeyRoot, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {


        DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Enumerating the keys under %s"), szIEHistKeyRoot));

        dwMsHistLen = lstrlen(IE_CACHEKEY_PREFIX);

        dwLen = ARRAYSIZE(szSubKey);

        while (RegEnumKeyEx(hKey, dwIndex, szSubKey, &dwLen, NULL, NULL, NULL, &ftWrite) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Testing Key %s"), szSubKey));

            StringCchCopy(szSubKey1, ARRAYSIZE(szSubKey1), szSubKey);
            szSubKey1[dwMsHistLen] = TEXT('\0');

            //
            // if the key name starts with MSHist
            //

            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szSubKey1, -1, IE_CACHEKEY_PREFIX, -1) == CSTR_EQUAL) {

                if (RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hIECacheKey) == ERROR_SUCCESS) {
                    DWORD dwLen1;

                    //
                    // Get the current value
                    //


                    dwLen1 = sizeof(szCachePath);
                    if (RegQueryValueEx(hIECacheKey, TEXT("CachePath"), 0, NULL, (LPBYTE)szCachePath, &dwLen1) == ERROR_SUCCESS) {

                        //
                        // Replace the szHistOld prefix with szHistNew value
                        //

                        StringCchCopy(szCachePath1, ARRAYSIZE(szCachePath1), szHistNew);

                        StringCchCopy(szSubKey1, ARRAYSIZE(szSubKey1), szCachePath);
                        szSubKey1[lstrlen(szHistOld)] = TEXT('\0');

                        if (lstrcmpi(szSubKey1, szHistOld) == 0) {


                            StringCchCat(szCachePath1, ARRAYSIZE(szCachePath1), szCachePath+lstrlen(szHistOld));

                            RegSetValueEx(hIECacheKey, TEXT("CachePath"), 0, REG_SZ, (LPBYTE)szCachePath1, (lstrlen(szCachePath1)+1)*sizeof(TCHAR));

                            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Finally,  under %s Replacing %s with %s"), szSubKey, szCachePath, szCachePath1));

                        }
                        else {
                            DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Existing CachePath %s doesn't have %s, skipping.."), szCachePath, szHistOld));
                        }
                    }
                    else {
                        DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Could not open CachePath value")));
                    }

                    RegCloseKey(hIECacheKey);
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Could not open %s subkey"), szSubKey));
                }
           }
           else {
               DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: %s subkey does not have %s prefix"), szSubKey, IE_CACHEKEY_PREFIX));
           }

           dwIndex++;
           dwLen = ARRAYSIZE(szSubKey);

          DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Getting %d subkey next.."), dwIndex+1));

        }

        //
        // Close if the open succeeded
        //

        RegCloseKey(hKey);
    }
    else {
          DebugMsg((DM_VERBOSE, TEXT("SearchAndReplaceIEHistory: Failed to open the root of the key %s"), szIEHistKeyRoot));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\profile.cpp ===
//*************************************************************
//
//  Profile management routines. Implements IUserProfile.
//  The organization of this file is as follows:
//      Implementation of CUserProfile object
//      Implementation of CUserProfile2 object
//      LoadUserProfile
//      UnloadUserProfile
//      All other global functions
//      Implementation of various other objects and data structures
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#include "uenv.h"
#include <wincred.h>
#include <wincrypt.h>
#include <credp.h>
#include <wow64reg.h>
#include <tchar.h>
#include <stdio.h>
#include "profmgr.hxx"
#include "strsafe.h"
#include "ntregapi.h"

//
// Length of const strings.
//

DWORD   USER_KEY_PREFIX_LEN = lstrlen(USER_KEY_PREFIX);
DWORD   USER_CLASSES_HIVE_SUFFIX_LEN = lstrlen(USER_CLASSES_HIVE_SUFFIX);

//
// CProfileDialog : Helper Class for IProfileDialog interface. 
//
// This class includes a security cookie. Since the process which calls LoadUserProfile()
// and UnloadUserProfile() will register an IProfileDialog interface to recieve
// error messages from console winlogon, we need a method to identify the caller
// of this interface is truely from console winlogon. However, RPC impersonation
// will not work since in console winlogon, we impersonate the user before we 
// call into this interface. So we generate a security cookie (a random number)
// for each process that called LoadUserProfile()/UnloadUserProfile(), and pass
// it to the interface function LoadUserProfileI() and UnloadUserProfileI(). 
// When console winlogon calls back to the IProfileDialog interface, it will
// pass back the cookie, so we can match the cookie to identify the caller. 
// 
// It is also used to generate a random endpoint name used in this interface. All threads 
// now use the same endpoint name for the dialog interface.
//

class CProfileDialog
{
private:

    const static DWORD m_dwLen = 16; // Currently, the cookie is 128 bit
    const static DWORD m_dwEndPointLen = 16; // Endpoing random number length, also set to 128 bits

private:

    BYTE m_pbCookie[m_dwLen];
    BOOL m_bInit;
    CRITICAL_SECTION m_cs;
    LPTSTR m_szEndPoint;
    LONG   m_lRefCount; 

public:

    CProfileDialog() : m_bInit(FALSE), m_szEndPoint(NULL), m_lRefCount(0)
    {
        InitializeCriticalSection(&m_cs);
    };
    ~CProfileDialog()
    {
        if (m_szEndPoint)
            LocalFree(m_szEndPoint);
        DeleteCriticalSection(&m_cs);
    }

    BYTE*   GetCookie() { return m_bInit ? m_pbCookie : NULL; };
    DWORD   CookieLen() { return m_bInit ? m_dwLen : 0; };

    HRESULT Initialize(); 
    HRESULT RegisterInterface(LPTSTR* lppEndPoint);
    HRESULT UnRegisterInterface();

public:

    static RPC_STATUS RPC_ENTRY SecurityCallBack(RPC_IF_HANDLE hIF, handle_t hBinding);
};

//
//  Global shared data for profile dialog
//

CProfileDialog   g_ProfileDialog;

//
// Tells us if we are loaded by winlogon or not.
//

extern "C" DWORD       g_dwLoadFlags = 0;


//
// The user profile manager. There's only one instance of this object,
// it resides in console winlogon.
//

CUserProfile      cUserProfileManager;

//
// Local function proto-types
//

LPTSTR  AllocAndExpandProfilePath(LPPROFILEINFO lpProfileInfo);
DWORD   ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD);
BOOL    CheckForSlowLink(LPPROFILE lpProfile, DWORD dwTime, LPTSTR lpPath, BOOL bDlgLogin);
BOOL    CheckNetDefaultProfile(LPPROFILE lpProfile);
BOOL    APIENTRY ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                      LPARAM lParam);
BOOL    CompareProfileInfo(LPPROFILEINFO pProfileInfo1, LPPROFILEINFO pProfileInfo2);
LPPROFILEINFO   CopyProfileInfo(LPPROFILEINFO pProfileInfo);
BOOL    CreateLocalProfileImage(LPPROFILE lpProfile, LPTSTR lpBaseName);
BOOL    CreateLocalProfileKey(LPPROFILE lpProfile, PHKEY phKey, BOOL *bKeyExists);
DWORD   DecrementProfileRefCount(LPPROFILE lpProfile);
DWORD   DeletePolicyState(LPCWSTR szSid );
void    DeleteProfileInfo(LPPROFILEINFO pProfileInfo);
void    HiveLeakBreak();
void    DumpOpenRegistryHandle(LPTSTR lpkeyName);
BOOL    GetExistingLocalProfileImage(LPPROFILE lpProfile);
void    ReleaseClientContext_s(PPCONTEXT_HANDLE pphContext);
BOOL    GetUserDomainName(LPPROFILE lpProfile, LPTSTR lpDomainName,
                          LPDWORD lpDomainNameSize);
DWORD   GetUserPreferenceValue(HANDLE hToken);
DWORD   IncrementProfileRefCount(LPPROFILE lpProfile, BOOL bInitialize);
BOOL    IsCacheDeleted();
BOOL    IsCentralProfileReachable(LPPROFILE lpProfile, BOOL *bCreateCentralProfile,
                                  BOOL *bMandatory, BOOL *bOwnerOK);
BOOL    IssueDefaultProfile(LPPROFILE lpProfile, LPTSTR lpDefaultProfile,
                            LPTSTR lpLocalProfile, LPTSTR lpSidString,
                            BOOL bMandatory);
BOOL    IsTempProfileAllowed();
LPPROFILE LoadProfileInfo(HANDLE hTokenClient, HANDLE hTokenUser, HKEY hKeyCurrentUser);
BOOL    ParseProfilePath(LPPROFILE lpProfile, LPTSTR lpProfilePath, BOOL *bpCSCBypassed, TCHAR *cpDrive);
BOOL    PatchNewProfileIfRequired(HANDLE hToken);
BOOL    PrepareProfileForUse(LPPROFILE lpProfile, LPVOID pEnv);
BOOL    RestoreUserProfile(LPPROFILE lpProfile);
BOOL    SaveProfileInfo(LPPROFILE lpProfile);
BOOL    SetNtUserIniAttributes(LPTSTR szDir);
BOOL    SetProfileTime(LPPROFILE lpProfile);
BOOL    TestIfUserProfileLoaded(HANDLE hUserToken, LPPROFILEINFO lpProfileInfo);
DWORD   ThreadMain(PMAP pThreadMap);
BOOL    UpgradeCentralProfile(LPPROFILE lpProfile, LPTSTR lpOldProfile);
BOOL    UpgradeProfile(LPPROFILE lpProfile, LPVOID pEnv);
BOOL    IsProfileInUse (LPCTSTR szComputer, LPCTSTR lpSid);
BOOL    IsUIRequired(HANDLE hToken);
void    CheckRUPShare(LPTSTR lpProfilePath);
INT_PTR APIENTRY LoginSlowLinkDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY LogoffSlowLinkDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL    IsPartialRoamingProfile(LPPROFILE lpProfile);
void    TouchLocalHive(LPPROFILE lpProfile);
BOOL    IsLRPC(handle_t hBinding);
RPC_STATUS RPC_ENTRY IProfileSecurityCallBack(RPC_IF_HANDLE hIF, handle_t hBinding);
RPC_STATUS RegisterClientAuthInfo(handle_t hBinding);
HRESULT CheckRoamingShareOwnership(LPTSTR lpDir, HANDLE hTokenUser);

#define USERNAME_VARIABLE          TEXT("USERNAME")

//*************************************************************
//
//  LoadUserProfile()
//
//  Purpose:    Loads the user's profile, if unable to load
//              use the cached profile or issue the default profile.
//
//  Parameters: hToken          -   User's token
//              lpProfileInfo   -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This is a wrapper around IUserProfile::LoadUserProfile
//              and LoadUserProfileP.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//              6/14/00     weiruc     changed to be a wrapper for
//                                     IUserProfile->LoadUserProfileP.
//
//*************************************************************

BOOL WINAPI LoadUserProfile(HANDLE hToken, LPPROFILEINFO lpProfileInfo)
{
    BOOL            bResult = FALSE;        // Return value
    HANDLE          hOldToken = NULL;
    NTSTATUS        status;
    BOOLEAN         bRestoreWasEnabled;
    BOOLEAN         bBackupWasEnabled;
    BOOL            bRestoreEnabled = FALSE;
    BOOL            bBackupEnabled = FALSE;
    TCHAR           ProfileDir[MAX_PATH];
    DWORD           dwProfileDirSize = MAX_PATH;
    BOOL            bCoInitialized = FALSE;
    long            lResult;
    LPTSTR          pSid = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    PCONTEXT_HANDLE phContext = NULL;
    handle_t        hIfUserProfile;
    BOOL            bBindInterface = FALSE;
    LPTSTR          lpRPCEndPoint = NULL;
    size_t          cchLength;
    HRESULT         hr;
    RPC_STATUS      rpc_status;
    
    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );


    //
    //  Check Parameters
    //

    if (!lpProfileInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: NULL lpProfileInfo")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if (lpProfileInfo->dwSize != sizeof(PROFILEINFO)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: lpProfileInfo->dwSize != sizeof(PROFILEINFO)")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if (!lpProfileInfo->lpUserName || !(*lpProfileInfo->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: received a NULL pointer for lpUserName.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  Make sure all the input strings are less than MAX_PATH in length and NULL terminated
    //
    
    hr = StringCchLength(lpProfileInfo->lpUserName, MAX_PATH, &cchLength);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: invalid length for lpUserName.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    
    if (lpProfileInfo->lpProfilePath)
    {
        hr = StringCchLength(lpProfileInfo->lpProfilePath, MAX_PATH, &cchLength);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: invalid length for lpProfilePath.")));
            dwErr = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (lpProfileInfo->lpDefaultPath)
    {
        hr = StringCchLength(lpProfileInfo->lpDefaultPath, MAX_PATH, &cchLength);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: invalid length for lpDefaultPath.")));
            dwErr = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (lpProfileInfo->lpServerName)
    {
        hr = StringCchLength(lpProfileInfo->lpServerName, MAX_PATH, &cchLength);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: invalid length for lpServerName.")));
            dwErr = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (lpProfileInfo->lpPolicyPath)
    {
        hr = StringCchLength(lpProfileInfo->lpPolicyPath, MAX_PATH, &cchLength);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: invalid length for lpPolicyPath.")));
            dwErr = ERROR_INVALID_PARAMETER;
            goto Exit;
        }
    }


    //
    // Make sure we can impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to impersonate user with %d."), dwErr));
        goto Exit;
    }
    
    //
    // Revert to ourselves.
    //

    if (!RevertToUser(&hOldToken))
    {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to revert to user with %d."), GetLastError()));
    }
    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Yes, we can impersonate the user. Running as self")));

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Entering, hToken = <0x%x>, lpProfileInfo = 0x%x"),
             hToken, lpProfileInfo));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->dwFlags = <0x%x>"),
             lpProfileInfo->dwFlags));

    if (lpProfileInfo->lpUserName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpUserName = <%s>"),
                 lpProfileInfo->lpUserName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL user name!")));
    }

    if (lpProfileInfo->lpProfilePath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpProfilePath = <%s>"),
                 lpProfileInfo->lpProfilePath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL central profile path")));
    }

    if (lpProfileInfo->lpDefaultPath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpDefaultPath = <%s>"),
                 lpProfileInfo->lpDefaultPath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL default profile path")));
    }

    if (lpProfileInfo->lpServerName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpServerName = <%s>"),
                 lpProfileInfo->lpServerName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL server name")));
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpPolicyPath = <%s>"),
                      lpProfileInfo->lpPolicyPath));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL policy path")));
        }
    }

    //
    // If we are in console winlogon process, call
    // IUserProfile::LoadUserProfileP directly. Otherwise get the COM interface
    //

    if(cUserProfileManager.IsConsoleWinlogon()) {
        
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: In console winlogon process")));
        
        //
        // Call the private load user profile function.
        //

        if (!cUserProfileManager.LoadUserProfileP(NULL, hToken, lpProfileInfo, NULL, NULL, 0)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: LoadUserProfileP failed with error %d"), dwErr));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: LoadUserProfileP succeeded")));
    }
    else {

        //
        // Enable restore and backup privilege (LoadUserClasses requires both).
        // Winlogon won't be able to enable the privilege for us.
        //

        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bRestoreWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to enable the restore privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bRestoreEnabled = TRUE;

        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &bBackupWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to enable the backup privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bBackupEnabled = TRUE;

        //
        // Get the IUserProfile interface.
        //

        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: GetInterface failed with error %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Register Client Authentication Info, required to do mutual authentication
        //

        rpc_status =  RegisterClientAuthInfo(hIfUserProfile);
        if (rpc_status != RPC_S_OK)
        {
            dwErr = (DWORD) rpc_status;
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RegisterAuthInfo failed with error %d"), rpc_status));
            goto Exit;
        }
        
        //
        // Call IUserProfile->DropClientToken, this will let us drop off our
        // client token and give us back the context.
        //

        RpcTryExcept {
            dwErr = cliDropClientContext(hIfUserProfile, lpProfileInfo, &phContext);            
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling DropClientContext took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling DropClientContext failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Calling DropClientToken (as self) succeeded")));
        }

        //
        // Register the dialog interface
        //
       
        if (!(lpProfileInfo->dwFlags & (PI_NOUI | PI_LITELOAD)))
        {
            hr = g_ProfileDialog.RegisterInterface(&lpRPCEndPoint);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("LoadUserProfile: register dialog interface fails, hr = %08X"), hr));
                lpRPCEndPoint = NULL;
            }
        }              

        //
        // Impersonate the user and call IUserProfile->LoadUserProfileI().
        //

        if(!ImpersonateUser(hToken, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ImpersonateUser failed. err = %d"), dwErr));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliLoadUserProfileI(hIfUserProfile,
                                        lpProfileInfo,
                                        phContext,
                                        lpRPCEndPoint,
                                        g_ProfileDialog.GetCookie(),
                                        g_ProfileDialog.CookieLen());
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling LoadUserProfileI took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        if (!RevertToUser(&hOldToken))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to revert to user with %d."), GetLastError()));
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Running as self")));
        }

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Calling LoadUserProfileI failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Calling LoadUserProfileI (as user) succeeded")));
        }


        //
        // Open the user's hive.
        //

        pSid = GetSidString(hToken);
        if(pSid == NULL) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  GetSidString failed, err = %d"), dwErr));
            goto Exit;
        }
        lResult = RegOpenKeyEx(HKEY_USERS, pSid, 0, KEY_ALL_ACCESS,
                               (PHKEY)&lpProfileInfo->hProfile);

        if(lResult != ERROR_SUCCESS)
        {
            dwErr = lResult;
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  Failed to open current user <%s> key. Error = %d"), pSid, lResult));
            DeleteSidString(pSid);

            //
            //  For non-admin user, we will fail now. But for admin, it may due to the fact that
            //  admin is logged on using the .Default hive, so we will let it go on. 
            //

            if (!IsUserAnAdminMember(hToken))
            {
                goto Exit;
            }

            DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  user is admin,  logon using .Default key.")));
        }
        else
        {
            DeleteSidString(pSid);
        }
       
    } // Is console winlogon?

    //
    // Set the USERPROFILE environment variable just so that there's no change
    // of behavior with the old in process LoadUserProfile API. Callers
    // expecting this env to be set is under the risk that while
    // SetEnvironmentVariable is per process but LoadUserProfile can be called
    // on multiple threads.
    //

    if(!GetUserProfileDirectory(hToken, ProfileDir, &dwProfileDirSize)) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: GetUserProfileDirectory failed with %08x"), GetLastError()));
    }
    else {
        SetEnvironmentVariable (TEXT("USERPROFILE"), ProfileDir);
    }

    bResult = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile:  Returning success.  Final Information follows:")));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->UserName = <%s>"), lpProfileInfo->lpUserName));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->lpProfilePath = <%s>"), lpProfileInfo->lpProfilePath));
    DebugMsg((DM_VERBOSE, TEXT("lpProfileInfo->dwFlags = 0x%x"), lpProfileInfo->dwFlags));

Exit:

    //
    // Restore the previous privileges.
    //

    if(bRestoreEnabled && !bRestoreWasEnabled) {
        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bRestoreWasEnabled, FALSE, &bRestoreWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Failed to restore the original restore privilege setting. error = %08x"), status));
        }
    }
    
    if(bBackupEnabled && !bBackupWasEnabled) {
        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, bBackupWasEnabled, FALSE, &bBackupWasEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Failed to restore the original backup privilege setting. error = %08x"), status));
        }
    }
    
    //
    // Unregister the Dialog interface
    //

    if (lpRPCEndPoint)
    {
        hr = g_ProfileDialog.UnRegisterInterface();
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: unregister dialog interface fails, hr =%08X"), hr));
        }
    }        

    //
    // Release the context handle
    //

    if (phContext) {
        RpcTryExcept {
            cliReleaseClientContext(hIfUserProfile, &phContext);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseClientContext took exception."), RpcExceptionCode()));
        }
        RpcEndExcept
    }

    //
    // Release the interface
    //

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseInterface failed.")));
        }
    }

    //
    // Release the tokens.
    //

    if(hOldToken) {
        CloseHandle(hOldToken);
    }

    if(bResult) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Returning TRUE. hProfile = <0x%x>"), lpProfileInfo->hProfile));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Returning FALSE. Error = %d"), dwErr));
    }

    //
    // Set the last error to win32 error code.
    //

    SetLastError(dwErr);

    //
    // Return.
    //

    return bResult;
}


//*************************************************************
//
//  UnloadUserProfile()
//
//  Purpose:    Unloads the user's profile.
//
//  Parameters: hToken    -   User's token
//              hProfile  -   Profile handle created in LoadUserProfile
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/7/95      ericflo    Created
//              6/15/00     weiruc     Modified to wrap
//                                     IUserProfile->UnloadUserProfileP.
//
//*************************************************************

BOOL WINAPI UnloadUserProfile(HANDLE hToken, HANDLE hProfile)
{
    HANDLE          hOldToken = NULL;
    BOOL            bResult = FALSE;
    NTSTATUS        status;
    BOOLEAN         bWasBackupEnabled, bWasRestoreEnabled;
    BOOL            bBackupEnabled = FALSE, bRestoreEnabled = FALSE;
    BOOL            bCoInitialized = FALSE;
    DWORD           dwErr = ERROR_SUCCESS;
    PCONTEXT_HANDLE phContext = NULL;
    handle_t        hIfUserProfile;
    BOOL            bBindInterface = FALSE;
    LPTSTR          lpRPCEndPoint = NULL;
    RPC_STATUS      rpc_status;
    HRESULT         hr;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Entering, hProfile = <0x%x>"), hProfile));

    //
    // Check Parameters
    //

    if (!hProfile || hProfile == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: received a NULL hProfile.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    if(!hToken || hToken == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: received a NULL hToken.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Make sure we can impersonate the user
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to impersonate user with %d."), dwErr));
        goto Exit;
    }

    //
    // Revert to ourselves.
    //

    if (!RevertToUser(&hOldToken))
    {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to revert to user with %d."), GetLastError()));
    }

    //
    // If we are in console winlogon process, call
    // IUserProfile::UnloadUserProfileP directly. Otherwise get the COM interface
    //

    if(cUserProfileManager.IsConsoleWinlogon()) {
        
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: In console winlogon process")));
        
        //
        // Call the private UnloadUserProfile function.
        //

        if(!cUserProfileManager.UnloadUserProfileP(NULL, hToken, (HKEY)hProfile, NULL, NULL, 0)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: UnloadUserProfileP failed with %d"), dwErr));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: UnloadUserProfileP succeeded")));
    }
    else {

        //
        // Close the hProfile key user passed in.
        //

        RegCloseKey((HKEY)hProfile);
    
        //
        // Enable the restore & backup privilege before calling over to winlogon.
        // Winlogon won't be able to enable the privilege for us.
        //

        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasRestoreEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to enable the restore privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status); 
            goto Exit;
        }
        bRestoreEnabled = TRUE;

        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &bWasBackupEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to enable the backup privilege. error = %08x"), status));
            dwErr = RtlNtStatusToDosError(status);  
            goto Exit;
        }
        bBackupEnabled = TRUE;

        //
        // Get the IUserProfile interface.
        //

        if(!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: GetInterface failed with error %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Register Client Authentication Info, required to do mutual authentication
        //

        rpc_status =  RegisterClientAuthInfo(hIfUserProfile);
        if (rpc_status != RPC_S_OK)
        {
            dwErr = (DWORD) rpc_status;
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: RegisterAuthInfo failed with error %d"), rpc_status));
            goto Exit;
        }

        //
        // Call IUserProfile->DropClientToken, this will let us drop off our
        // client token and give us back the context.
        //

        RpcTryExcept {
            dwErr = cliDropClientContext(hIfUserProfile, NULL, &phContext);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling DropClientToken took exception. error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling DropClientContext failed. err = %d"), dwErr));
            goto Exit;
        }
        else {           
            DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfile: Calling DropClientToken (as self) succeeded")));
        }

        //
        // Register the dialog interface if req
        //
       
        if (IsUIRequired(hToken))
        {
            hr = g_ProfileDialog.RegisterInterface(&lpRPCEndPoint);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: register dialog interface fails, hr = %08X"), hr));
                lpRPCEndPoint = NULL;
            }
        }              

        //
        // Impersonate the user and call IUserProfile->UnloadUserProfileI().
        //

        if (!ImpersonateUser(hToken, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: ImpersonateUser failed. err = %d"), dwErr));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliUnloadUserProfileI(hIfUserProfile,
                                          phContext,
                                          lpRPCEndPoint,
                                          g_ProfileDialog.GetCookie(),
                                          g_ProfileDialog.CookieLen());
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling UnLoadUserProfileI took exception. err = %d"), dwErr));
        }
        RpcEndExcept

        //
        // Revert back.
        //

        if (!RevertToUser(&hOldToken))
        {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfile: Failed to revert to user with %d."), GetLastError()));
        }

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: Calling UnLoadUserProfileI failed. err = %d"), dwErr));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Calling UnloadUserProfileI succeeded")));
        }

    } // Is console winlogon?

    bResult = TRUE;

Exit:

    //
    // Restore the previous privilege.
    //

    if(bRestoreEnabled && !bWasRestoreEnabled) {
        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasRestoreEnabled, FALSE, &bWasRestoreEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Failed to restore the original restore privilege setting. error = %08x"), status));
        }
    }
    
    if(bBackupEnabled && !bWasBackupEnabled) {
        status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, bWasBackupEnabled, FALSE, &bWasBackupEnabled);
        if(!NT_SUCCESS(status)) {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Failed to restore the original backup privilege setting. error = %08x"), status));
        }
    }
    
    //
    // Unregister the Dialog interface
    //

    if (lpRPCEndPoint)
    {
        HRESULT hr;
        hr = g_ProfileDialog.UnRegisterInterface();
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: unregister dialog interface fails, hr = %08X"), hr));
        }
    }        

    //
    // Release the context handle
    //

    if (phContext) {
        RpcTryExcept {
            cliReleaseClientContext(hIfUserProfile, &phContext);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfile: ReleaseClientContext took exception."), RpcExceptionCode()));
        }
        RpcEndExcept
    }

    //
    // Release the interface
    //

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ReleaseInterface failed.")));
        }
    }

    //
    // Release the tokens.
    //

    if(hOldToken) {
        CloseHandle(hOldToken);
    }

    //
    // Set the last error to win32 error code.
    //

    SetLastError(dwErr);

    //
    // Return.
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: returning %d"), bResult));
    return bResult;
}

//*************************************************************
//
//  CUserProfile::Initialize()
//
//      Initializes the class. Called by and only by console winlogon.
//
//  Return value:
//
//      This function does not return a value.
//
//  History:
//
//      Created         weiruc          2/29/2000
//
//*************************************************************

void CUserProfile::Initialize()
{
    LONG        lResult;
    HKEY        hkProfileList = NULL;
    DWORD       i = 0;
    TCHAR       tszSubKeyName[MAX_PATH];
    DWORD       dwcSubKeyName = MAX_PATH;
    FILETIME    ftLWT;      // last write time.
    HRESULT     hres;
    BOOL        bCSInitialized = FALSE;
    RPC_STATUS  status;
   

    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::Initialize ...")));


    //
    // If the caller is not winlogon, do nothing and return.
    //

    if(g_dwLoadFlags != WINLOGON_LOAD) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize called by non-winlogon process, %d"), g_dwLoadFlags));
        goto Exit;
    }
    bConsoleWinlogon = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize called by winlogon")));

    //
    // If this function is already called, do nothing but return.
    //

    if(bInitialized) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize already called")));
        goto Exit;
    }

    //
    // Initialize the critical section that protects the map.
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&csMap, 0x80000000)) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), GetLastError()));
            goto Exit;
        }
        bCSInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: InitializeCriticalSection failed")));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: critical section initialized")));


    //
    // Initialize the whrc data
    //

    pMap = NULL;
    cTable.Initialize();
    
    
    //
    // Initialize the sync manager.
    //

    if(!cSyncMgr.Initialize()) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: Initialize sync manager failed")));
        goto Exit;
    }


    //
    // Clean up the unloaded hives and undeleted profiles that we didn't handle
    // before last shutdown.
    //

    //
    // Open the profile list key.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PROFILE_LIST_PATH,
                           0,
                           KEY_READ,
                           &hkProfileList);
    if(lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize:  Failed to open profile list key with error %d"), lResult));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: registry key %s opened"), PROFILE_LIST_PATH));

    //
    // Enumerate users, if we got the number of subkeys, we will enumerate 
    // the key backwards so that the cleanup (deletion of the subkey) won't
    // affect the enumeration. If we cannot get the number of subkeys, just
    // try to enumerate from very beginning, until we encounter error for the
    // RegEnumKeyEx API.
    //

    BOOL    bGotNumSubkeys = TRUE;
    DWORD   dwNumSubkeys = 0;
    
    lResult = RegQueryInfoKey(hkProfileList,
                              NULL,
                              NULL,
                              NULL,
                              &dwNumSubkeys,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if(lResult != ERROR_SUCCESS) {
        bGotNumSubkeys = FALSE;
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize:  Failed to query subkey under profile list key with error %d"), lResult));
    }

    i = bGotNumSubkeys ? dwNumSubkeys - 1 :  0;
    while((lResult = RegEnumKeyEx(hkProfileList,
                                  i,
                                  tszSubKeyName,
                                  &dwcSubKeyName,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &ftLWT)) == ERROR_SUCCESS) {
        
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: Proccessing %s"), tszSubKeyName));
        CleanupUserProfile(tszSubKeyName, &hkProfileList);
        i = bGotNumSubkeys ? i - 1 : i + 1;        
        dwcSubKeyName = MAX_PATH;
    }


    if(lResult != ERROR_SUCCESS && lResult != ERROR_NO_MORE_ITEMS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RegEnumKeyEx returned %08x"), lResult));
    }

    //
    // Specify to use the local rpc protocol sequence 
    //

    status = RpcServerUseProtseqEp(cszRPCProtocol,                  // ncalrpc prot seq
                                   cdwMaxRpcCalls,                  // max concurrent calls
                                   cszRPCEndPoint,
                                   NULL);                           // Security descriptor
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RpcServerUseProtseqEp fails with error %ld"), status));
        goto Exit;
    }
 
    //
    // Register the IUserProfile interface
    //

    status = RpcServerRegisterIfEx(IUserProfile_v1_0_s_ifspec,        // interface to register
                                   NULL,                              // MgrTypeUuid
                                   NULL,                              // MgrEpv; null means use default
                                   RPC_IF_AUTOLISTEN,                 // auto-listen interface
                                   cdwMaxRpcCalls,                    // max concurrent calls
                                   IProfileSecurityCallBack);         // callback function to check security
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::Initialize: RpcServerRegisterIfEx fails with error %ld"), status));
        goto Exit;
    }
 
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::Initialize: RpcServerRegisterIfEx successful")));

    bInitialized = TRUE;

Exit:
      
    if(bInitialized == FALSE && bCSInitialized == TRUE) {
        DeleteCriticalSection(&csMap);
    }

    if(hkProfileList != NULL) {
        RegCloseKey(hkProfileList);
    }

    if(bInitialized == TRUE) {
        DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::Initialize, successful")));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::Initialize, unsuccessful")));
        //ReportError(NULL, PI_NOUI | EVENT_ERROR_TYPE, 0, EVENT_INIT_PROFILE_FAIL);
    }
}

//*************************************************************
//
//  CUserProfile::LoadUserProfileP()
//
//  Purpose:    Loads the user's profile, if unable to load
//              use the cached profile or issue the default profile.
//
//  Parameters: hTokenClient    -   the client who's trying to load the
//                                  user's profile. A NULL value indicate
//                                  that this is a in-proccess call.
//              hTokenUser      -   the user who's profile is being loaded.
//              lpProfileInfo   -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//              6/27/00     weiruc     Made a private function called
//                                     by the win32 API LoadUserProfile to do
//                                     the actual work.
//
//*************************************************************

BOOL CUserProfile::LoadUserProfileP(HANDLE hTokenClient,
                                    HANDLE hTokenUser,
                                    LPPROFILEINFO lpProfileInfo,
                                    LPTSTR lpRPCEndPoint,
                                    BYTE* pbCookie,
                                    DWORD cbCookie)
{
    LPPROFILE           lpProfile = NULL;
    BOOL                bResult = FALSE, bNewProfileLoaded = FALSE;
    HANDLE              hOldToken = NULL;
    HANDLE              hTmpToken = NULL;
    DWORD               dwRef, dwErr = ERROR_SUCCESS;
    LPTSTR              SidString = NULL;
    LPVOID              pEnv = NULL;
    NTSTATUS            status;
    BOOL                bInCS = FALSE;
    BOOL                bCSCBypassed = FALSE;
    TCHAR               cDrive;
    DWORD               cch;

    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );
    
    DebugMsg((DM_VERBOSE, TEXT("In LoadUserProfileP")));

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {

        //
        // Check the client's identity
        //

        if (!IsUserAnAdminMember(hTokenClient) && !IsUserALocalSystemMember(hTokenClient)) {
            dwErr = ERROR_ACCESS_DENIED;
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Unable to load profile for client %08x. Not enough permission. Error %d."), hTokenClient, dwErr));
            goto Exit;
        }
        
        //
        // Run under the client's identity rather than winlogon's.
        //

        if(!ImpersonateUser(hTokenClient, &hTmpToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ImpersonateUser <%08x> failed with %08x"), hTokenClient, dwErr));
            goto Exit;
        }
        LPTSTR lpSidClient = GetSidString(hTokenClient);
        if (lpSidClient)
        {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Running as client, sid = %s"), lpSidClient));
            DeleteSidString(lpSidClient);
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Running as client, cannot get sid")));
        }
    }
    
    //
    //  Check Parameters
    //

    if (!lpProfileInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: NULL lpProfileInfo")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }


    if (!lpProfileInfo->lpUserName || !(*lpProfileInfo->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: received a NULL pointer for lpUserName.")));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // if the profile path or default path is greater than MAX_PATH, ignore them.
    //

    if ((lpProfileInfo->lpProfilePath) && (lstrlen(lpProfileInfo->lpProfilePath) >= MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: long profile path name %s. ignoring"), lpProfileInfo->lpProfilePath));
        ReportError(hTokenUser, PI_NOUI, 1, EVENT_PROFILE_PATH_TOOLONG, lpProfileInfo->lpProfilePath);
        (lpProfileInfo->lpProfilePath)[0] = TEXT('\0');
    }

    if ((lpProfileInfo->lpDefaultPath) && (lstrlen(lpProfileInfo->lpDefaultPath) >= MAX_PATH)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: long default profile path name %s. ignoring"), lpProfileInfo->lpDefaultPath));
        (lpProfileInfo->lpDefaultPath)[0] = TEXT('\0');
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Entering, hToken = <0x%x>, lpProfileInfo = 0x%x"),
             hTokenUser, lpProfileInfo));

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->dwFlags = <0x%x>"),
             lpProfileInfo->dwFlags));

    if (lpProfileInfo->lpUserName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpUserName = <%s>"),
                 lpProfileInfo->lpUserName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL user name!")));
    }

    if (lpProfileInfo->lpProfilePath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpProfilePath = <%s>"),
                 lpProfileInfo->lpProfilePath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL central profile path")));
    }

    if (lpProfileInfo->lpDefaultPath) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpDefaultPath = <%s>"),
                 lpProfileInfo->lpDefaultPath));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL default profile path")));
    }

    if (lpProfileInfo->lpServerName) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpServerName = <%s>"),
                 lpProfileInfo->lpServerName));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL server name")));
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: lpProfileInfo->lpPolicyPath = <%s>"),
                      lpProfileInfo->lpPolicyPath));
        } else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: NULL policy path")));
        }
    }


    //
    // Make sure someone isn't loading a profile during
    // GUI mode setup (eg: mapi)
    //

    if (IsGuiSetupInProgress()) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: LoadUserProfile can not be called during GUI mode setup.")));
        dwErr = ERROR_NOT_READY;
        goto Exit;
    }


    //
    // Wait for the profile setup event to be signalled
    //

    if (g_hProfileSetup) {
        if ((WaitForSingleObject (g_hProfileSetup, 600000) != WAIT_OBJECT_0)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to wait on the profile setup event.  Error = %d."),
                      GetLastError()));
            dwErr = GetLastError();
            goto Exit;
        }
    }

    //
    // Get the user's sid in string form
    //

    SidString = GetSidString(hTokenUser);

    if (!SidString) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile:  Failed to get sid string for user")));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: User sid: %s"), SidString));

    //
    // Enter the critical section.
    //

    if(!cSyncMgr.EnterLock(SidString, lpRPCEndPoint, pbCookie, cbCookie)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile:: Failed to get the user profile lock")));
        goto Exit;
    }
    bInCS = TRUE;
    

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Wait succeeded. In critical section.")));


    //-------------------  BEGIN CRITICAL SECTION ------------------------
    //
    // We are in the critical section at this point, no doddling now...
    //

    //
    // Check if the profile is loaded already.
    //

    if (TestIfUserProfileLoaded(hTokenUser, lpProfileInfo)) {
        DWORD  dwFlags = lpProfileInfo->dwFlags;

        //
        // This profile is already loaded.  Grab the info from the registry
        // and add the missing chunks.
        //

        lpProfile = LoadProfileInfo(hTokenClient, hTokenUser, (HKEY)lpProfileInfo->hProfile);

        if (!lpProfile) {
            RegCloseKey ((HKEY)lpProfileInfo->hProfile);
            lpProfileInfo->hProfile = NULL;
            dwErr = GetLastError();
            goto Exit;
        }

        //
        // LoadProfileInfo will overwrite the dwFlags field with the
        // value from the previous profile loading.  Restore the flags.
        //

        lpProfile->dwFlags = dwFlags;

        if (lpProfile->dwFlags & PI_LITELOAD) {
            lpProfile->dwFlags |= PI_NOUI;
        }


        //
        // LoadProfileInfo doesn't restore username, servername, policypath so
        // special case these.
        //

        cch = lstrlen(lpProfileInfo->lpUserName) + 1;
        lpProfile->lpUserName = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

        if (!lpProfile->lpUserName) {
            RegCloseKey ((HKEY)lpProfileInfo->hProfile);
            dwErr = GetLastError();
            goto Exit;
        }

        StringCchCopy (lpProfile->lpUserName, cch, lpProfileInfo->lpUserName);

        if (lpProfileInfo->lpServerName) {
            cch = lstrlen(lpProfileInfo->lpServerName) + 1;
            lpProfile->lpServerName = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

            if (lpProfile->lpServerName) {
                StringCchCopy (lpProfile->lpServerName, cch, lpProfileInfo->lpServerName);
            }
        }

        if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
            if (lpProfileInfo->lpPolicyPath) {
                cch = lstrlen(lpProfileInfo->lpPolicyPath) + 1;
                lpProfile->lpPolicyPath = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

                if (lpProfile->lpPolicyPath) {
                    StringCchCopy (lpProfile->lpPolicyPath, cch, lpProfileInfo->lpPolicyPath);
                }
            }
        }

        //
        // If the profile is already loaded because it was leaked,
        // then the classes root may not be loaded.  Insure that it
        // is loaded.
        //

        if (!(lpProfile->dwFlags & PI_LITELOAD)) {
            dwErr = LoadUserClasses( lpProfile, SidString, FALSE );

            if (dwErr != ERROR_SUCCESS) {

                LPTSTR szErr = NULL;

                szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
                if (!szErr) {
                    dwErr = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("LoadUserProfileP: Out of memory")));
                    goto Exit;
                }

                //
                // If the user is an Admin, then let him/her log on with
                // either the .default profile, or an empty profile.
                //

                if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_ADMIN_OVERRIDE, GetErrString(dwErr, szErr));

                    dwErr = ERROR_SUCCESS;
                    LocalFree(szErr);
                } 
                else {
                    DebugMsg((DM_WARNING, TEXT("LoadUserProfileP: Could not load the user class hive. Error = %d"), dwErr));
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_PROFILE, GetErrString(dwErr, szErr));

                    RegCloseKey ((HKEY)lpProfileInfo->hProfile);
                    lpProfileInfo->hProfile = NULL;
                    LocalFree(szErr);
                    goto Exit;
                }
            }

        }

        //
        // Jump to the end of the profile loading code.
        //

        goto ProfileLoaded;
    }


    //
    // If we are here, the profile isn't loaded yet, so we are
    // starting from scratch.
    //

    //
    // Clone the process's environment block. This is passed to CreateProcess
    // by userdiff and system policy because they rely on the USERPROFILE
    // environment variable, but setting USERPROFILE for the whole process
    // is not thread safe.
    //
    
    status = RtlCreateEnvironment(TRUE, &pEnv);
    if(!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RtlCreateEnvironment returned %08x"), status));
        dwErr = status;
        goto Exit;
    }

    //
    // Allocate an internal Profile structure to work with.
    //

    lpProfile = (LPPROFILE) LocalAlloc (LPTR, sizeof(USERPROFILE));

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to allocate memory")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Save the data passed in.
    //

    lpProfile->dwFlags = lpProfileInfo->dwFlags;

    //
    // No UI in case of Lite_Load
    //

    if (lpProfile->dwFlags & PI_LITELOAD) {
        lpProfile->dwFlags |= PI_NOUI;
    }

    lpProfile->dwUserPreference = GetUserPreferenceValue(hTokenUser);
    lpProfile->hTokenUser = hTokenUser;
    lpProfile->hTokenClient = hTokenClient;

    cch = lstrlen(lpProfileInfo->lpUserName) + 1;
    lpProfile->lpUserName = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

    if (!lpProfile->lpUserName) {
        dwErr = GetLastError();
        goto Exit;
    }

    StringCchCopy (lpProfile->lpUserName, cch, lpProfileInfo->lpUserName);

    if (lpProfileInfo->lpDefaultPath) {

        cch = lstrlen(lpProfileInfo->lpDefaultPath) + 1;
        lpProfile->lpDefaultProfile = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

        if (lpProfile->lpDefaultProfile) {
            StringCchCopy (lpProfile->lpDefaultProfile, cch, lpProfileInfo->lpDefaultPath);
        }
    }

    if (lpProfileInfo->lpProfilePath) {
        lpProfile->lpProfilePath = AllocAndExpandProfilePath (lpProfileInfo);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Expanded profile path is %s"),
                  lpProfile->lpProfilePath?lpProfile->lpProfilePath:TEXT("NULL")));
    }

    if (lpProfileInfo->lpServerName) {

        cch = lstrlen(lpProfileInfo->lpServerName) + 1;
        lpProfile->lpServerName = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

        if (lpProfile->lpServerName) {
            StringCchCopy (lpProfile->lpServerName, cch, lpProfileInfo->lpServerName);
        }
    }

    if (lpProfileInfo->dwFlags & PI_APPLYPOLICY) {
        if (lpProfileInfo->lpPolicyPath) {

            cch = lstrlen(lpProfileInfo->lpPolicyPath) + 1;
            lpProfile->lpPolicyPath = (LPTSTR)LocalAlloc (LPTR, cch * sizeof(TCHAR));

            if (lpProfile->lpPolicyPath) {
                StringCchCopy (lpProfile->lpPolicyPath, cch, lpProfileInfo->lpPolicyPath);
            }
        }
    }

    lpProfile->lpLocalProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpLocalProfile) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpProfile->lpRoamingProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpRoamingProfile) {
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // If there is a central profile, check for 3.x or 4.0 format.
    //

    if (lpProfileInfo->lpProfilePath && (*lpProfileInfo->lpProfilePath)) {

        //
        // Call ParseProfilePath to work some magic on it
        //

        if (!ParseProfilePath(lpProfile, lpProfile->lpProfilePath, &bCSCBypassed, &cDrive)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ParseProfilePath returned FALSE")));
            goto Exit;
        }

        //
        // The real central profile directory is...
        //

        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: ParseProfilePath returned a directory of <%s>"),
                  lpProfile->lpRoamingProfile));
    }

    //
    // Load the user's profile
    //

    if (!RestoreUserProfile(lpProfile)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: RestoreUserProfile returned FALSE")));
        dwErr = GetLastError();
        goto Exit;
    }

    GetSystemTimeAsFileTime (&lpProfile->ftProfileLoad);

    //
    // Save the profile information in the registry
    //

    SaveProfileInfo (lpProfile);

    //
    // Set the USERPROFILE environment variable into the block.
    // This allows ExpandEnvironmentStrings to be used
    // in the userdiff processing.
    //

    SetEnvironmentVariableInBlock(&pEnv, TEXT("USERPROFILE"), lpProfile->lpLocalProfile, TRUE);

    //
    // Flush the special folder pidls stored in shell32.dll
    //

    FlushSpecialFolderCache();

    //
    // Set attributes on ntuser.ini
    //

    SetNtUserIniAttributes(lpProfile->lpLocalProfile);


    //
    // Upgrade the profile if appropriate.
    //

    if (!(lpProfileInfo->dwFlags & PI_LITELOAD)) {
        if (!UpgradeProfile(lpProfile, pEnv)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: UpgradeProfile returned FALSE")));
        }
    }


    //
    // Prepare the profile for use on this machine
    //

    PrepareProfileForUse (lpProfile, pEnv);

    bNewProfileLoaded = TRUE;


ProfileLoaded:

    //
    // Increment the profile Ref count
    //

    dwRef = IncrementProfileRefCount(lpProfile, bNewProfileLoaded);

    if (!bNewProfileLoaded && (dwRef <= 1)) {
        DebugMsg((DM_WARNING, TEXT("Profile was loaded but the Ref Count is %d !!!"), dwRef));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("Profile Ref Count is %d"), dwRef));
    }

    //
    // This will leave the critical section so other threads/process can
    // continue.
    //

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Leaving critical Section.")));
    if(cSyncMgr.LeaveLock(SidString)) {
        bInCS = FALSE;
    }
    else {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfile: User profile lock not released %08x"), GetLastError()));
    }


    //
    // Notify LSA that the profile has loaded 
    //
    if (!(lpProfile->dwFlags & PI_LITELOAD))
    {
        if (!ImpersonateUser(hTokenUser, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to impersonate user with %d."), dwErr ));
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Impersonated user: %08x, %08x"), hTokenUser, hOldToken));
        }

        if (!CredProfileLoaded()) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: Failed to notify LSA that profile loaded %d."), dwErr ));
            RevertToUser(&hOldToken);
            DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted to user: %08x"), hOldToken));
            goto Exit;
        }

        RevertToUser(&hOldToken);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted to user: %08x"), hOldToken));
    }
    
    //
    // The critical section is now released so we can do slower things like
    // apply policy...
    //
    //-------------------  END MUTEX SECTION ------------------------


    //
    // Apply Policy
    //

    if (lpProfile->dwFlags & PI_APPLYPOLICY) {
        //
        // Group Policy does not run on personal
        //
        OSVERSIONINFOEXW version;
        version.dwOSVersionInfoSize = sizeof(version);
        if ( !GetVersionEx( (LPOSVERSIONINFO) &version ) )
        {
            return ERROR_SUCCESS;
        }
        else
        {
            if ( ( version.wSuiteMask & VER_SUITE_PERSONAL ) != 0 )
            {
                return ERROR_SUCCESS;
            }
        }

        if (!ApplySystemPolicy((SP_FLAG_APPLY_MACHINE_POLICY | SP_FLAG_APPLY_USER_POLICY),
                               lpProfile->hTokenUser, lpProfile->hKeyCurrentUser,
                               lpProfile->lpUserName, lpProfile->lpPolicyPath,
                               lpProfile->lpServerName)) {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfile: ApplySystemPolicy returned FALSE")));
        }
    }

    //
    // Save the outgoing parameters
    //

    lpProfileInfo->hProfile = (HANDLE) lpProfile->hKeyCurrentUser;

    //
    // Success!
    //

    bResult = TRUE;
    
Exit:

    if (bCSCBypassed) {
        CancelCSCBypassedConnection(lpProfile->hTokenUser, cDrive);
    }

    if(bInCS) {
        cSyncMgr.LeaveLock(SidString);
    }


    if(SidString) {
        DeleteSidString(SidString);
    }


    //
    // Free the structure
    //

    if (lpProfile) {

        if (lpProfile->lpUserName) {
            LocalFree (lpProfile->lpUserName);
        }

        if (lpProfile->lpDefaultProfile) {
            LocalFree (lpProfile->lpDefaultProfile);
        }

        if (lpProfile->lpProfilePath) {
            LocalFree (lpProfile->lpProfilePath);
        }

        if (lpProfile->lpServerName) {
            LocalFree (lpProfile->lpServerName);
        }

        if (lpProfile->lpPolicyPath) {
            LocalFree (lpProfile->lpPolicyPath);
        }

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        if (lpProfile->lpExclusionList) {
            LocalFree (lpProfile->lpExclusionList);
        }

        //
        // Caller will release these handles.
        //

        lpProfile->hTokenClient = NULL;
        lpProfile->hTokenUser = NULL;

        LocalFree (lpProfile);
    }

    //
    // Free the cloned environment block.
    //

    if (pEnv) {
        RtlDestroyEnvironment(pEnv);
    }

    //
    // Revert to ourselves
    //

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {
        RevertToUser(&hTmpToken);
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Reverted back to user <%08x>"), hTmpToken));
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfile: Leaving with a value of %d."), bResult));

    DebugMsg((DM_VERBOSE, TEXT("=========================================================")));

    SetLastError(dwErr);
    return bResult;
}

//*************************************************************
//
//  CUserProfile::UnloadUserProfileP()
//
//  Purpose:    Unloads the user's profile.
//
//  Parameters: hTokenClient    -   The client who's trying to load
//                                  the user's profile.
//              hTokenUser      -   User's token
//              hProfile        -   Profile handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/7/95      ericflo    Created
//              6/27/00     weiruc     Modified to be a private function
//                                     called by UnloadUserProfile to do
//                                     the actual work.
//
//*************************************************************

BOOL CUserProfile::UnloadUserProfileP(HANDLE hTokenClient,
                                      HANDLE hTokenUser,
                                      HKEY hProfile,
                                      LPTSTR lpRPCEndPoint,
                                      BYTE* pbCookie,
                                      DWORD cbCookie)
{
    LPPROFILE lpProfile=NULL;
    LPTSTR lpSidString = NULL, lpEnd, SidStringTemp = NULL;
    LONG err, IgnoreError, lResult;
    BOOL bProfileCopied = FALSE, bRetVal = FALSE, bDeleteCache, bRoaming = FALSE;
    HKEY hKey;
    DWORD dwSize, dwType, dwDisp;
    LPTSTR szExcludeList1 = NULL;
    LPTSTR szExcludeList2 = NULL;
    LPTSTR szExcludeList = NULL;
    LPTSTR szBuffer = NULL;
    DWORD dwFlags, dwRef = 0;
    HANDLE hOldToken = NULL;
    HANDLE hTmpToken = NULL;
    DWORD dwErr=0, dwErr1 = ERROR_SUCCESS, dwCSCErr;  // dwErr1 is what gets set in SetLastError()
    LPTSTR szErr = NULL;
    LPTSTR szKeyName = NULL;
    DWORD dwCopyTmpHive = 0;
    DWORD dwWatchHiveFlags = 0;
    LPTSTR tszTmpHiveFile = NULL;
    BOOL bUnloadHiveSucceeded = TRUE;
    BOOL bInCS = FALSE;
    BOOL bCSCBypassed = FALSE;
    LPTSTR lpCscBypassedPath = NULL;
    TCHAR  cDrive;
    DWORD cchKeyName;
    DWORD cchBuffer;
    UINT cchEnd;
    DWORD cchExcludeList;
    HRESULT hr;
    
    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Entering, hProfile = <0x%x>"), hProfile));

    //
    // Run under the client's identity rather than winlogon's.
    //

    if(hTokenClient && hTokenClient != INVALID_HANDLE_VALUE) {
        if(!ImpersonateUser(hTokenClient, &hTmpToken)) {
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: ImpersonateUser <%08x> failed with %08x"), hTokenClient, dwErr1));
            RegCloseKey((HKEY)hProfile);
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: ImpersonateUser <%08x>, old token is <%08x>"), hTokenClient, hTmpToken));
    }
    
    //
    // Get the Sid string for the current user
    //

    lpSidString = GetProfileSidString(hTokenUser);

    if (!lpSidString) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to get sid string for user %08x"), dwErr1));
        RegCloseKey((HKEY)hProfile);
        goto Exit;
    }

    //
    // Load profile information
    //

    lpProfile = LoadProfileInfo(hTokenClient, hTokenUser, (HKEY)hProfile);

    if (!lpProfile) {
        dwErr1 = GetLastError();
        RegCloseKey((HKEY)hProfile);
        goto Exit;
    }

    //
    // Get the user's sid in string form
    //

    SidStringTemp = GetSidString(hTokenUser);

    if (!SidStringTemp) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to get sid string for user")));
        RegCloseKey(lpProfile->hKeyCurrentUser);
        goto Exit;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    cchKeyName = MAX_PATH;
    szKeyName = (LPTSTR)LocalAlloc(LPTR, cchKeyName * sizeof(TCHAR));
    if (!szKeyName) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szErr) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    cchBuffer = MAX_PATH;
    szBuffer = (LPTSTR)LocalAlloc(LPTR, cchBuffer * sizeof(TCHAR));
    if (!szBuffer) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1 = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szExcludeList1) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    szExcludeList2 = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szExcludeList2) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    cchExcludeList = 2 * MAX_PATH;
    szExcludeList = (LPTSTR)LocalAlloc(LPTR, cchExcludeList * sizeof(TCHAR));
    if (!szExcludeList) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
        goto Exit;
    }

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      WINLOGON_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH*sizeof(TCHAR);
        err = RegQueryValueEx (hKey,
                               TEXT("ExcludeProfileDirs"),
                               NULL,
                               &dwType,
                               (LPBYTE) szExcludeList1,
                               &dwSize);

        if (err != ERROR_SUCCESS)
        {
            szExcludeList1[0] = TEXT('\0');
        }
        else
        {
            //
            //  Make sure it is null terminated
            //
            szExcludeList1[MAX_PATH - 1] = TEXT('\0'); 
        }

        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH*sizeof(TCHAR);
        err = RegQueryValueEx (hKey,
                               TEXT("ExcludeProfileDirs"),
                               NULL,
                               &dwType,
                               (LPBYTE) szExcludeList2,
                               &dwSize);

        if (err != ERROR_SUCCESS)
        {
            szExcludeList2[0] = TEXT('\0');
        }
        else
        {
            //
            //  Make sure it is null terminated
            //
            szExcludeList1[MAX_PATH - 1] = TEXT('\0'); 
        }

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        StringCchCopy (szExcludeList, cchExcludeList, szExcludeList1);
        CheckSemicolon(szExcludeList); // We sure will have enough buffer in szExcludeList
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        StringCchCat  (szExcludeList, cchExcludeList, szExcludeList2);
    }

    //
    // Check if the cached copy of the profile should be deleted
    //

    bDeleteCache = IsCacheDeleted();


    //
    // Enter the critical section.
    //

    if(!cSyncMgr.EnterLock(SidStringTemp, lpRPCEndPoint, pbCookie, cbCookie)) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:: Failed to get the user profile lock %08x"), dwErr1));
        goto Exit;
    }
    bInCS = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Wait succeeded.  In critical section.")));

    //
    // Flush out the profile which will also sync the log.
    //

    err = RegFlushKey(lpProfile->hKeyCurrentUser);
    if (err != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to flush the current user key, error = %d"), err));
    }


    //
    // Close the current user key that was opened in LoadUserProfile.
    //

    err = RegCloseKey(lpProfile->hKeyCurrentUser);
    if (err != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to close the current user key, error = %d"), err));
    }


    dwRef = DecrementProfileRefCount(lpProfile);

    if (dwRef != 0) {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Didn't unload user profile, Ref Count is %d"), dwRef));
        bRetVal = TRUE;
        goto Exit;
    }


    //
    //  Unload the user profile
    //

    err = MyRegUnLoadKey(HKEY_USERS, lpSidString);

    if (!err) {

        if((dwErr1 = GetLastError()) == ERROR_ACCESS_DENIED) {

            //
            // We failed to unload the hive due to leaked reg keys.
            //

            dwWatchHiveFlags |= WHRC_UNLOAD_HIVE;

            if (!(lpProfile->dwFlags & PI_LITELOAD)) {

                if (dwDebugLevel != DL_NONE)
                {
                    //
                    // Call Special Registry APIs to dump handles
                    // only if it is not called through Lite_load
                    // there are known problems with liteLoad loading because
                    // of which eventlog can get full during stress
                    //

                    StringCchCopy(szKeyName, cchKeyName, TEXT("\\Registry\\User\\"));
                    StringCchCat (szKeyName, cchKeyName, lpSidString);

                    //
                    //  Put this part in the protected block so that we won't crash winlogon
                    //
                    
                    __try
                    {
                        DumpOpenRegistryHandle(szKeyName);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle caused an exception!!! Code = %d"), GetExceptionCode()));
                    }
                }
                //
                //  Break into debugger if neccesory
                //
                HiveLeakBreak();
            }        
        }

        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Didn't unload user profile <err = %d>"), GetLastError()));

        //
        // Only in the case of reg leak do we want to call WatchHiveRefCount.
        // So use this flag to tell later code the the hive failed to
        // unload, no matter what the reason.
        //

        bUnloadHiveSucceeded = FALSE;
    } else {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Succesfully unloaded profile")));
    }


    //
    //  Unload HKCU
    //

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {
        
        err = UnloadClasses(lpSidString);

        if (!err) {

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Didn't unload user classes.")));

            if((dwErr1 = GetLastError()) == ERROR_ACCESS_DENIED) {

                if (dwDebugLevel != DL_NONE)
                {
                    //
                    // Call Special Registry APIs to dump handles
                    //

                    StringCchCopy(szKeyName, cchKeyName, TEXT("\\Registry\\User\\"));
                    StringCchCat (szKeyName, cchKeyName, lpSidString);
                    StringCchCat (szKeyName, cchKeyName, TEXT("_Classes"));

                    //
                    //  Put this part in the protected block so that we won't crash winlogon
                    //
                    
                    __try
                    {
                        DumpOpenRegistryHandle(szKeyName);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle caused an exception!!! Code = %d"), GetExceptionCode()));
                    }
                }
                
                //
                //  Break into debugger if neccesory
                //
                HiveLeakBreak();

                ReportError(hTokenUser, PI_NOUI | EVENT_WARNING_TYPE, 0, EVENT_FAILED_CLASS_HIVE_UNLOAD);

                dwWatchHiveFlags = dwWatchHiveFlags | WHRC_UNLOAD_CLASSESROOT;
            }

            bRetVal = TRUE;
        } else {
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Successfully unloaded user classes")));
        }
    }


    //
    // Figure out if we need to do anything special in the event of registry
    // key leak.
    //

    if(dwWatchHiveFlags != 0 || !bUnloadHiveSucceeded) {
        tszTmpHiveFile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
        if (!tszTmpHiveFile) {
            dwErr1 = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileP: Out of memory")));
            goto Exit;
        }

        dwErr = HandleRegKeyLeak(lpSidString,
                                 lpProfile,
                                 bUnloadHiveSucceeded,
                                 &dwWatchHiveFlags,
                                 &dwCopyTmpHive,
                                 tszTmpHiveFile,
                                 MAX_PATH);

        //
        // If registry leak is handled successfully, the last error code should
        // be ERROR_SUCCESS. Otherwise, it should be whatever MyRegUnLoadKey
        // returned, which is in dwErr1.
        //
        if(dwErr == ERROR_SUCCESS) {
            dwErr1 = dwErr;
        }
    }

    //
    // If this is a mandatory or a guest profile, unload it now,
    // Guest profiles are always deleted so one guest can't see
    // the profile of a previous guest. Only do this if the user's
    // hive had been successfully unloaded.
    //

    if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
        (lpProfile->dwInternalFlags & PROFILE_READONLY) ||
        (lpProfile->dwInternalFlags & PROFILE_GUEST_USER)) {

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  flushing HKEY_USERS")));

        IgnoreError = RegFlushKey(HKEY_USERS);
        if (IgnoreError != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to flush HKEY_USERS, error = %d"), IgnoreError));
        }


        // Don't delete the guest account if machine is in workgroup 
        INT iRole;

        if (bDeleteCache || 
            ((lpProfile->dwInternalFlags & PROFILE_GUEST_USER) && 
             GetMachineRole(&iRole) && (iRole != 0))) {

            //
            // Delete the profile, including all other user related stuff
            //

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: deleting profile because it is a guest user or cache needs to be deleted")));

            if (!DeleteProfile (lpSidString, NULL, NULL)) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false.  Error = %d"), GetLastError()));
            }
            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Successfully deleted profile because it is a guest/mandatory user")));
        }

        if (err) {
            bRetVal = TRUE;
        }


        if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {

            //
            // Just delete the user profile, backup should never exist for mandatory profile
            //

            if (!DeleteProfileEx (lpSidString, lpProfile->lpLocalProfile, 0, HKEY_LOCAL_MACHINE, NULL)) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
            }
        }

        goto Exit;
    }


    // Store the actual roaming profile path before mapping it to drive

    lpProfile->lpProfilePath = lpProfile->lpRoamingProfile;

    // 
    // Try to bypass CSC to avoid conflicts in syncing files between roaming share & local profile
    //

    if (IsUNCPath(lpProfile->lpRoamingProfile)) {
        if ((dwCSCErr = AbleToBypassCSC(hTokenUser, lpProfile->lpRoamingProfile, &lpCscBypassedPath, &cDrive)) == ERROR_SUCCESS) {
            bCSCBypassed = TRUE;
            lpProfile->lpRoamingProfile = lpCscBypassedPath;
            DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed.")));
        }
        else {
            if (dwCSCErr == WN_BAD_LOCALNAME || dwCSCErr == WN_ALREADY_CONNECTED || dwCSCErr == ERROR_BAD_PROVIDER) {
                DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed failed. Profile path %s"), lpProfile->lpRoamingProfile));
            }
            else {
                // Share is not up. So we do not need to do any further check
                lpProfile->lpRoamingProfile = NULL;
                DebugMsg((DM_VERBOSE, TEXT("UnLoadUserProfileP: CSC bypassed failed. Ignoring Roaming profile path")));
            }
        }    
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        dwErr1 = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to impersonate user")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Impersonated user")));

    //
    // Copy local profileimage to remote profilepath
    //

    if ( ((lpProfile->dwInternalFlags & PROFILE_UPDATE_CENTRAL) ||
          (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL)) &&  
         !(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) ) {

        if ((lpProfile->dwUserPreference != USERINFO_LOCAL) &&
            !(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {

            //
            // Copy to the profile path
            //

            if (lpProfile->lpRoamingProfile && *lpProfile->lpRoamingProfile) {
                BOOL bRoamDirectoryExist;

                DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP:  Copying profile back to %s"),
                                lpProfile->lpRoamingProfile));

                bRoaming = TRUE;

                //
                // Check roaming profile directory exist or not. If not exist, try to create it with proper acl's
                //

                bRoamDirectoryExist = TRUE;
                if (GetFileAttributes(lpProfile->lpRoamingProfile) == -1) {

                    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Roaming profile directory does not exist.")));

                    //
                    // Check whether we need to give access to the admin on the RUP share
                    //

                    //
                    // Check for a roaming profile security preference
                    //
 
                    BOOL  bAddAdminGroup = FALSE;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                                     &hKey) == ERROR_SUCCESS) {

                        dwSize = sizeof(bAddAdminGroup);
                        RegQueryValueEx(hKey, ADD_ADMIN_GROUP_TO_RUP, NULL, NULL,
                                        (LPBYTE) &bAddAdminGroup, &dwSize);

                        RegCloseKey(hKey);
                    }


                    //
                    // Check for a roaming profile security policy
                    //

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                                     &hKey) == ERROR_SUCCESS) {

                        dwSize = sizeof(bAddAdminGroup);
                        RegQueryValueEx(hKey, ADD_ADMIN_GROUP_TO_RUP, NULL, NULL,
                                        (LPBYTE) &bAddAdminGroup, &dwSize);

 
                        RegCloseKey(hKey);
                    } 

                    if (!CreateSecureDirectory(lpProfile, lpProfile->lpRoamingProfile, NULL, !bAddAdminGroup) ) {
                    
                        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: CreateSecureDirectory failed to create roaming profile directory.")));
                        bRoamDirectoryExist = FALSE;
                        bProfileCopied = FALSE;
                    }
                    lpProfile->dwInternalFlags |= PROFILE_NEW_CENTRAL; // Since we created a empty profile now
                }

                
                if (bRoamDirectoryExist) {

                    DWORD dwAttributes, dwStart, dwDelta;

                    //
                    // We have to call GetFileAttributes twice.  The
                    // first call sets up the session so we can call it again and
                    // get accurate timing information for slow link detection.
                    //


                    dwAttributes = GetFileAttributes(lpProfile->lpProfilePath);

                    if (dwAttributes != -1) {
                        //
                        // if it is success, find out whether the profile is
                        // across a slow link.
                        //

                        dwStart = GetTickCount();

                        dwAttributes = GetFileAttributes(lpProfile->lpProfilePath);

                        dwDelta = GetTickCount() - dwStart;

                        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Tick Count = %d"), dwDelta));

                        CheckForSlowLink (lpProfile, dwDelta, lpProfile->lpProfilePath, FALSE);
                        if (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK) {
                            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Profile is across a slow link. Do not sync roaming profile")));
                        }
                    }
                }

                if (!(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {
                    if (bRoamDirectoryExist) {

                        //
                        // Copy the profile
                        //

                        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
                        dwFlags |= (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) ? (CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY) :
                                                                    (CPD_SYNCHRONIZE | CPD_NONENCRYPTEDONLY);

                        dwFlags |= CPD_USEDELREFTIME |
                                   CPD_USEEXCLUSIONLIST | CPD_DELDESTEXCLUSIONS;

                        bProfileCopied = CopyProfileDirectoryEx (lpProfile->lpLocalProfile,
                                                       lpProfile->lpRoamingProfile,
                                                       dwFlags | dwCopyTmpHive,
                                                       &lpProfile->ftProfileLoad,
                                                       (szExcludeList[0] != TEXT('\0')) ?
                                                       szExcludeList : NULL);

                    }

                    //
                    // Save the exclusion list we used for the profile copy
                    //

                    if (bProfileCopied) {
                        // save it on the roaming profile.

                        hr = AppendName(szBuffer, cchBuffer, lpProfile->lpRoamingProfile, c_szNTUserIni, &lpEnd, &cchEnd);
                        if (SUCCEEDED(hr))
                        {

                            bProfileCopied = WritePrivateProfileString (PROFILE_GENERAL_SECTION,
                                                       PROFILE_EXCLUSION_LIST,
                                                       (szExcludeList[0] != TEXT('\0')) ?
                                                       szExcludeList : NULL,
                                                       szBuffer);

                            if (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) {
                                bProfileCopied = WritePrivateProfileString (PROFILE_LOAD_TYPE,
                                                           PROFILE_LAST_UPLOAD_STATE,
                                                           (lpProfile->dwFlags & PI_LITELOAD) ?
                                                           PARTIAL_PROFILE : COMPLETE_PROFILE,
                                                           szBuffer);
                            }
                            else if (IsPartialRoamingProfile(lpProfile)) {
                                bProfileCopied = WritePrivateProfileString (PROFILE_LOAD_TYPE,
                                                           PROFILE_LAST_UPLOAD_STATE,
                                                           (lpProfile->dwFlags & PI_LITELOAD) ?
                                                           PARTIAL_PROFILE : COMPLETE_PROFILE,
                                                           szBuffer);
                            }

                            if (!bProfileCopied) {
                                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to write to ntuser.ini on profile server with error 0x%x"), GetLastError()));
                                dwErr = GetLastError();
                            }
                            else {
                                SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);
                            }
                        }
                    }
                    else {
                        dwErr = GetLastError();

                        if (dwErr == ERROR_FILE_ENCRYPTED) {
                            ReportError(hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                        }
                    }

                    //
                    // Check return value
                    //

                    if (bProfileCopied) {
                 
                        //
                        // The profile is copied, now we want to make sure the timestamp on
                        // both the remote profile and the local copy are the same, so we don't
                        // ask the user to update when it's not necessary. In the case we 
                        // save the hive to a temporary file and
                        // upload from the tmp file rather than the actual hive file. Do not
                        // synchronize the profile time in this case because the hive file
                        // will still be in use and there's no point in setting time on the
                        // tmp hive file because it will be deleted after we upload it.
                        //

                        if(bUnloadHiveSucceeded) {
                            SetProfileTime(lpProfile);
                        }
                    } else {
                        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  CopyProfileDirectory returned FALSE for primary profile.  Error = %d"), dwErr));
                        ReportError(hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_UPDATE_FAILED, GetErrString(dwErr, szErr));
                    }
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Network share not available.")));
                ReportError(hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_UPDATE_FAILED, GetErrString(dwCSCErr, szErr));
            }
        }
    }

    //
    // if it is roaming, write only if copy succeeded otherwise write
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Writing local ini file")));
    if (!bRoaming || bProfileCopied) {

        //
        // Mark the file with system bit before trying to write to it
        //

        SetNtUserIniAttributes(lpProfile->lpLocalProfile);

        // save it locally

        hr = AppendName(szBuffer, cchBuffer, lpProfile->lpLocalProfile, c_szNTUserIni, &lpEnd, &cchEnd);
        if (SUCCEEDED(hr))
        {
            err = WritePrivateProfileString (PROFILE_GENERAL_SECTION,
                                            PROFILE_EXCLUSION_LIST,
                                            (szExcludeList[0] != TEXT('\0')) ?
                                            szExcludeList : NULL,
                                            szBuffer);

            if (!err) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to write to ntuser.ini on client with error 0x%x"), GetLastError()));
                dwErr = GetLastError();
            }
        }
    }


    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP: Failed to revert to self")));
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Reverting to Self")));

    //
    // Save the profile unload time
    //

    if (bProfileCopied && !bDeleteCache && !(lpProfile->dwFlags & PI_LITELOAD) &&
        !(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED)) {

        GetSystemTimeAsFileTime (&lpProfile->ftProfileUnload);

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfile: Got the System Time")));

        GetProfileListKeyName(szBuffer, cchBuffer, lpSidString);

        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, 0, 0,
                                 KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult == ERROR_SUCCESS) {

            lResult = RegSetValueEx (hKey,
                                     PROFILE_UNLOAD_TIME_LOW,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &lpProfile->ftProfileUnload.dwLowDateTime,
                                     sizeof(DWORD));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to save low profile load time with error %d"), lResult));
            }


            lResult = RegSetValueEx (hKey,
                                     PROFILE_UNLOAD_TIME_HIGH,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE) &lpProfile->ftProfileUnload.dwHighDateTime,
                                     sizeof(DWORD));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  Failed to save high profile load time with error %d"), lResult));
            }


            RegCloseKey (hKey);

            DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Setting the unload Time")));
        }
    }


    if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
        DWORD dwDeleteFlags=0;

        //
        // Just delete the user profile
        //

        if (lpProfile->dwInternalFlags & PROFILE_BACKUP_EXISTS) {
            dwDeleteFlags |= DP_BACKUPEXISTS;
        }

        if (!DeleteProfileEx (lpSidString, lpProfile->lpLocalProfile, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
        }
    }


    if (bUnloadHiveSucceeded && bRoaming && bProfileCopied && bDeleteCache) {

        //
        // Delete the profile and all the related stuff
        //

        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Deleting the cached profile")));
        if (!DeleteProfile (lpSidString, NULL, NULL)) {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileP:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
        }
    }

    if(!(dwWatchHiveFlags & WHRC_UNLOAD_HIVE)) {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: exitting and cleaning up")));
        bRetVal = TRUE;
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: exitting without cleaning up due to hive unloading failure")));
    }

Exit:

    if(hTokenClient) {
    
        //
        // Revert to ourselves.
        //

        RevertToUser(&hTmpToken);
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Reverted back to user <%08x>"), hTmpToken));
    }

    //
    // Leave the critical section.
    //

    if(bInCS) {
        cSyncMgr.LeaveLock(SidStringTemp);
        DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Leave critical section.")));
    }

    //
    // Delete the tmp hive file.
    //

    if (dwCopyTmpHive & CPD_USETMPHIVEFILE) {
        DeleteFile(tszTmpHiveFile);
    }

    if (bCSCBypassed) {
        CancelCSCBypassedConnection(hTokenUser, cDrive);
    }

    if(SidStringTemp) {
        DeleteSidString(SidStringTemp);
    }

    if (lpSidString) {
        DeleteSidString(lpSidString);
    }

    if (lpProfile) {

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            if (lpProfile->lpProfilePath && (lpProfile->lpProfilePath != lpProfile->lpRoamingProfile)) {
                LocalFree (lpProfile->lpProfilePath);
            }

            LocalFree (lpProfile->lpRoamingProfile);
            lpProfile->lpProfilePath = NULL;
        }

        if (lpProfile->lpProfilePath) {
            LocalFree(lpProfile->lpProfilePath);
        }

        LocalFree (lpProfile);
    }

    if (szExcludeList1) {
        LocalFree(szExcludeList1);
    }

    if (szExcludeList2) {
        LocalFree(szExcludeList2);
    }

    if (szExcludeList) {
        LocalFree(szExcludeList);
    }

    if (tszTmpHiveFile) {
        LocalFree(tszTmpHiveFile);
    }

    if (szKeyName) {
        LocalFree(szKeyName);
    }

    if (szErr) {
        LocalFree(szErr);
    }

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileP: Leaving with a return value of %d"), bRetVal));

    SetLastError(dwErr1);
    return bRetVal;
}


//*************************************************************
//
//  CUserProfile::EnterUserProfileLockLocal()
//
//  Purpose:
//
//      Get the user profile lock (for winlogon only, other processes use
//      EnterUserProfileLockRemote). This is just a wrapper for
//      CSyncManager::EnterLock.
//
//  Parameters:
//
//      pSid     - User's sid string
//
//  Return:
//
//      TRUE/FALSE
//
//  History:    Date        Author     Comment
//              5/15/00     weiruc     Created
//
//*************************************************************

BOOL CUserProfile::EnterUserProfileLockLocal(LPTSTR pSid)
{
    return cSyncMgr.EnterLock(pSid, NULL, NULL, 0);
}


//*************************************************************
//
//  CUserProfile::LeaveUserProfileLockLocal()
//
//  Purpose:
//
//      Release the user profile mutex (winlogon only. Remote processes call
//      LeaveUserProfileLockRemote().
//
//  Parameters:
//
//      pSid    - User's sid string
//
//  Return:
//
//      TRUE/FALSE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/11/00     weiruc     Created
//
//*************************************************************

BOOL CUserProfile::LeaveUserProfileLockLocal(LPTSTR pSid)
{
    return cSyncMgr.LeaveLock(pSid);
}

//*************************************************************
//
//  CUserProfile::GetRPCEndPointAndCookie()
//
//  Purpose:
//
//      Returns the rpc end point associated with client registered
//      interface
//
//  Comments: See CSyncManager::GetRPCEndPointAndCookie
//
//  History:    Date        Author     Comment
//              10/25/2000  santanuc   Created
//              05/03/2002  mingzhu    Added Security Cookie
//
//*************************************************************

HRESULT CUserProfile::GetRPCEndPointAndCookie(LPTSTR pSid, LPTSTR* lplpEndPoint, BYTE** ppbCookie, DWORD* pcbCookie)
{
    return cSyncMgr.GetRPCEndPointAndCookie(pSid, lplpEndPoint, ppbCookie, pcbCookie);
}


//*************************************************************
//
//  DropClientContext()
//
//  Purpose:    Allows the caller to drop off it's own token.
//
//  Parameters: hBindHandle     - explicit binding handle
//              lpProfileInfo   - Profile Information
//              ppfContext      - server context
//              
//
//  Return:     DWORD
//              ERROR_SUCCESS - If everything ok
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD DropClientContext(IN handle_t hBindHandle, IN LPPROFILEINFO lpProfileInfo, OUT PPCONTEXT_HANDLE pphContext)
{
    LPPROFILEINFO   pProfileInfoCopy = NULL;
    HANDLE          hClientToken = NULL;
    PCLIENTINFO     pClientInfo = NULL;
    RPC_STATUS      status;
    DWORD           dwErr = ERROR_ACCESS_DENIED;
    LPTSTR          lpSid;

    //
    // Initialize the debug flags.
    //

    InitDebugSupport( FALSE );

    if (!pphContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("DropClientContext: NULL context %d"), dwErr));
        goto Exit;
    }

    //
    // Impersonate the client to get it's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("DropClientContext: RpcImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }

    //
    // Get the client's token.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hClientToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DropClientContext: OpenThreadToken failed with %d"), dwErr));
        status = RpcRevertToSelf();
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("DropClientContext: RpcRevertToSelf failed with %d"), status));
        }
        goto Exit;
    }
    status = RpcRevertToSelf();
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("DropClientContext: RpcRevertToSelf failed with %d"), status));
    }
    
    lpSid = GetSidString(hClientToken);
    if (lpSid)
    {
        DebugMsg((DM_VERBOSE, TEXT("DropClientContext: Got client token %08X, sid = %s"), hClientToken, lpSid));
        DeleteSidString(lpSid);
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("DropClientContext: Got client token %08X, cannot get sid."), hClientToken));
    }

    //
    // Check the client's identity
    //

    if (!IsUserAnAdminMember(hClientToken) && !IsUserALocalSystemMember(hClientToken)) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("DropClientContext: Client %08x doesn not have enough permission. Error %d."), hClientToken, dwErr));
        goto Exit;
    }

    //
    // Make a copy of the PROFILEINFO structure the user passed in.
    //

    if (lpProfileInfo) {
        if(!(pProfileInfoCopy = CopyProfileInfo(lpProfileInfo))) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("DropClientContext: CopyProfileInfo failed with %d"), dwErr));
            goto Exit;
        }
    }
    
    //
    // Make the user's load profile object.
    //

    pClientInfo = (PCLIENTINFO)MIDL_user_allocate(sizeof(CLIENTINFO));
    if(!pClientInfo) {
        dwErr = ERROR_OUTOFMEMORY;
        DebugMsg((DM_WARNING, TEXT("DropClientContext: new failed")));
        goto Exit;
    }
    pClientInfo->hClientToken = hClientToken;
    pClientInfo->pProfileInfo = pProfileInfoCopy;
    *pphContext = (PCONTEXT_HANDLE)pClientInfo;
    DebugMsg((DM_VERBOSE, TEXT("DropClientContext: load profile object successfully made")));

    hClientToken = NULL;
    pProfileInfoCopy = NULL;
    dwErr = ERROR_SUCCESS;
    
Exit:

    if(hClientToken) {
        CloseHandle(hClientToken);
    }

    if(pProfileInfoCopy) {
        DeleteProfileInfo(pProfileInfoCopy);
    }

    DebugMsg((DM_VERBOSE, TEXT("DropClientContext: Returning %d"), dwErr));
    return dwErr;
}

//*************************************************************
//
//  ReleaseClientContext()
//
//  Purpose:    Release the client's context handle
//
//  Parameters: hBindHandle     - explicit binding handle
//              ppfContext      - server context
//              
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

void ReleaseClientContext(IN handle_t hBindHandle, IN OUT PPCONTEXT_HANDLE pphContext)
{
    DebugMsg((DM_VERBOSE, TEXT("ReleaseClientContext: Releasing context")));
    ReleaseClientContext_s(pphContext);
}

//
// This function also called from server rundown routine
//

void ReleaseClientContext_s(PPCONTEXT_HANDLE pphContext)
{
    PCLIENTINFO pClientInfo;

    DebugMsg((DM_VERBOSE, TEXT("ReleaseClientContext_s: Releasing context")));

    if (*pphContext) {
        pClientInfo = (PCLIENTINFO)*pphContext;
        CloseHandle(pClientInfo->hClientToken);
        DeleteProfileInfo(pClientInfo->pProfileInfo);
        MIDL_user_free(pClientInfo);
        *pphContext = NULL;
    }
}


//*************************************************************
//
//  EnterUserProfileLockRemote()
//
//      Get the lock for loading/unloading a user's profile.
//
//  Return value:
//
//      HRESULT
//
//  History:
//
//      Created         weiruc          6/16/2000
//
//*************************************************************
DWORD EnterUserProfileLockRemote(IN handle_t hBindHandle, IN LPTSTR pSid)
{
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;
    HANDLE      hToken = NULL;

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, TRUE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: OpenThreadToken failed with %d"), dwErr));
        status = RpcRevertToSelf();
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: RpcRevertToSelf failed with %d"), status));
        }
        goto Exit;
    }

    status = RpcRevertToSelf();
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: RpcRevertToSelf failed with %d"), status));
    }

    //
    // Only admin users are allowed to lock a user's profile from being loaded/unloaded.
    //

    if(!IsUserAnAdminMember(hToken)) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: Non-admin user!!!")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::EnterUserProfileLockRemote: Locking user %s"), pSid));

    if(!cUserProfileManager.EnterUserProfileLockLocal(pSid)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::EnterUserProfileLockRemote: Failed with %d"), dwErr));
        goto Exit;
    }

    dwErr = ERROR_SUCCESS;

Exit:

    if(hToken) {
        CloseHandle(hToken);
    }

    return dwErr;
}


//*************************************************************
//
//  LeaveUserProfileLockRemote()
//
//      Release the lock for loading/unloading a user's profile.
//
//  Return value:
//
//      HRESULT
//
//  History:
//
//      Created         weiruc          6/16/2000
//
//*************************************************************

DWORD LeaveUserProfileLockRemote(IN handle_t hBindHandle, IN LPTSTR pSid)
{
    HANDLE      hToken = NULL;
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE, TRUE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: OpenThreadToken failed with %d"), dwErr));
        status = RpcRevertToSelf();
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: RpcRevertToSelf failed with %d"), status));
        }
        goto Exit;
    }

    status = RpcRevertToSelf();
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: RpcRevertToSelf failed with %d"), status));
    }
    
    //
    // Only admin users are allowed to lock a user's profile from being loaded/unloaded.
    //

    if(!IsUserAnAdminMember(hToken)) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: Non-admin user!!!")));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::LeaveUserProfileLockRemote: Unlocking user %s"), pSid));

    if(!cUserProfileManager.LeaveUserProfileLockLocal(pSid)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CUserProfile::LeaveUserProfileLockRemote: Failed with %d"), dwErr));
        goto Exit;
    }

    dwErr = ERROR_SUCCESS;

Exit:

    if(hToken) {
        CloseHandle(hToken);
    }

    return dwErr;
}

//*************************************************************
//
//  CUserProfile::WorkerThreadMain
//
//      Main function for the worker thread
//
//  Parameters:
//
//      pThreadMap            the work queue for this thread
//
//  Return value:
//
//      Always returns ERROR_SUCCESS.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

DWORD CUserProfile::WorkerThreadMain(PMAP pThreadMap)
{
    DWORD           index;
    HKEY            hkProfileList = NULL;
    long            lResult;
    BOOL            bCleanUp;
    LPTSTR          ptszSid, lpTmp;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::WorkerThreadMain")));

    while(TRUE) {

        bCleanUp = FALSE;
        ptszSid  = NULL;

        index = WaitForMultipleObjects(pThreadMap->dwItems,
                                       pThreadMap->rghEvents,
                                       FALSE,
                                       INFINITE);
        index = index - WAIT_OBJECT_0;

        EnterCriticalSection(&csMap);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: In critical section")));


        if(index > 0 && index < pThreadMap->dwItems) {
            LPTSTR  lpUserName;
            
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: WaitForMultipleObjects successful")));
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: hive %s unloaded"), pThreadMap->rgSids[index]));
            lpUserName = GetUserNameFromSid(pThreadMap->rgSids[index]);
            ReportError(NULL, PI_NOUI | EVENT_INFO_TYPE, 1, EVENT_HIVE_UNLOADED, lpUserName);
            if (lpUserName != pThreadMap->rgSids[index]) {
                LocalFree(lpUserName);
            }
            
            //
            // Save the sid and Delete the work item from the map and the hash
            // table.
            //
            
            ptszSid = pThreadMap->GetSid(index);
            pThreadMap->Delete(index);
            cTable.HashDelete(ptszSid);
            
            // Convert Sid_Classes entry to Sid as CleanupUserProfile takes only Sid
            lpTmp = ptszSid;
            if (lpTmp) {
                while (*lpTmp && (*lpTmp != TEXT('_')))
                    lpTmp++;
                if (*lpTmp) {
                    *lpTmp = TEXT('\0');
                }
            }
        
            //
            // Set the flag to clean up here because we want to do it after
            // we leave the critical section.
            //

            bCleanUp = TRUE;
        } // if waken up because a hive is unloaded

        //
        // Check to see if the map is empty. If it is, delete the map.
        //

        if(pThreadMap->IsEmpty()) {

            PMAP pTmpMap = pMap;

            //
            // We always have at least 1 item left: the thread event, So now
            // we know we don't have any work item anymore. Delete pThreadMap.
            //

            if(pThreadMap == pMap) {
                // pThreadMap is at the beginning of the list.
                pMap = pThreadMap->pNext;
            }
            else {
                for(pTmpMap = pMap; pTmpMap->pNext != pThreadMap; pTmpMap = pTmpMap->pNext);
                pTmpMap->pNext = pThreadMap->pNext;
            }
            pThreadMap->pNext = NULL;

            pThreadMap->Delete(0);
            delete pThreadMap;

            //
            // Leave the critical section.
            //

            LeaveCriticalSection(&csMap);
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Leave critical section")));

            if(bCleanUp) {                

                //
                // Clean up user's profile.
                //

                CleanupUserProfile(ptszSid, &hkProfileList);
                LocalFree(ptszSid);
            }
            
            //
            // Close the profile list key.
            //

            if(hkProfileList) {
                RegCloseKey(hkProfileList);
                hkProfileList = NULL;
            }

            //
            // Exit the thread because we don't have any work items anymore.
            //
        
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: No more work items, leave thread")));
            return ERROR_SUCCESS;
        }   // if thread map is empty

        //
        // Leave the critical section.
        //

        LeaveCriticalSection(&csMap);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Leave critical section")));

        if(bCleanUp) {
            
            //
            // Clean up user's profile.
            //

            CleanupUserProfile(ptszSid, &hkProfileList);
            LocalFree(ptszSid);
        }

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WorkerThreadMain: Back to waiting...")));
    }   // while

    
    //
    // Never executed.
    //

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  CUserProfile::WatchHiveRefCount
//
//      Implementation of the interface IWatchHiveRefCount.
//
//  Parameters:
//
//      pctszSid            the user's sid
//      dwWHRCFlags         indicate which hives to unload
//
//  Return value:
//
//      HRESULT error code.
//
//  History:
//
//      Created         weiruc          5/4/2000
//
//*************************************************************

STDMETHODIMP CUserProfile::WatchHiveRefCount(LPCTSTR pSid, DWORD dwWHRCFlags)
{
    LPTSTR                  pSidCopy = NULL;
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       oa;
    TCHAR                   tszHiveName[MAX_PATH], *pTmp;
    UNICODE_STRING          sHiveName;
    BOOLEAN                 bWasEnabled;
    HRESULT                 hres = S_OK;
    HANDLE                  hEvent = INVALID_HANDLE_VALUE;
    DWORD                   dwSidLen = lstrlen(pSid);
    BOOL                    bInCriticalSection = FALSE;
    BOOL                    bClassesHiveWatch, bEventCreated;
    DWORD                   cchTemp;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::WatchHiveRefCount: %s, %d"), pSid, dwWHRCFlags));

    //
    // Are we initialized?
    //

    if(!bInitialized) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount not initialized")));
        return E_FAIL;
    }

    //
    // parameter validation
    //

    if(dwSidLen >= sizeof(tszHiveName) / sizeof(TCHAR) - USER_KEY_PREFIX_LEN - USER_CLASSES_HIVE_SUFFIX_LEN ||
       dwSidLen >= sizeof(tszHiveName) / sizeof(TCHAR) - USER_KEY_PREFIX_LEN ||
       lstrcmpi(DEFAULT_HKU, pSid) == 0) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: Invalid parameter")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Setup the hive name to be used by NtUnloadKeyEx.
    //
    
    StringCchCopy(tszHiveName, ARRAYSIZE(tszHiveName), USER_KEY_PREFIX);
    pTmp = tszHiveName + USER_KEY_PREFIX_LEN;
    cchTemp = ARRAYSIZE(tszHiveName) - USER_KEY_PREFIX_LEN;
    StringCchCopy(pTmp, cchTemp, pSid);
    *pTmp = (TCHAR)_totupper(*pTmp);
    
    //
    // Enable the restore privilege. Don't give up even if fails. In the case
    // of impersonation, this call will fail. But we still might still have
    // the privilege needed.
    //

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);
    if(!NT_SUCCESS(status)) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: Failed to enable the restore privilege. error = %08x"), status));
    }

    //
    // Enter the critical section.
    //

    EnterCriticalSection(&csMap);
    bInCriticalSection = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: In critical section")));

    //
    // Register for the hive to be unloaded.
    //
 
    while (dwWHRCFlags & (WHRC_UNLOAD_HIVE | WHRC_UNLOAD_CLASSESROOT)) {

        // init the variable at the start of loop
        bClassesHiveWatch = FALSE;
        bEventCreated = FALSE;

        if(dwWHRCFlags & WHRC_UNLOAD_HIVE) {
           dwWHRCFlags &= ~WHRC_UNLOAD_HIVE;
        }
        else if (dwWHRCFlags & WHRC_UNLOAD_CLASSESROOT) {
           dwWHRCFlags &= ~WHRC_UNLOAD_CLASSESROOT;
           StringCchCat(tszHiveName, ARRAYSIZE(tszHiveName), USER_CLASSES_HIVE_SUFFIX);
           bClassesHiveWatch = TRUE;
        }

        //
        // First make sure that the item is not already in our work list.
        //

        if(cTable.IsInTable(pTmp)) {
            if (!bClassesHiveWatch) {
                DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: %s already in work list"), pTmp));
                continue;
            }

            //
            // So we have a classes hive which was earlier leaked and never
            // unloaded - so the event never got signaled. We have to reuse 
            // the event earlier registered for hive unload notification
            //

            if ((hEvent = GetWorkItem(pTmp)) == NULL) {
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: %s was in work list but we fail to get the event!!"), pTmp));
                continue;
            }
        }
        else {
            if((hEvent = CreateEvent(NULL,
                                     FALSE,
                                     FALSE,
                                     NULL)) == NULL) {
                hres = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: CreateEvent failed. error = %08x"), hres));
                goto Exit;
            }
            bEventCreated = TRUE;
        }

        //
        // Initialize the object attributes.
        //

        RtlInitUnicodeString(&sHiveName, tszHiveName);
        InitializeObjectAttributes(&oa,
                                   &sHiveName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Unload the hive.
        //

        if(!NT_SUCCESS(status = NtUnloadKeyEx(&oa, hEvent))) {
            hres = HRESULT_FROM_WIN32(status);
            DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: NtUnloadKeyEx failed with %08x"), status));
            if (bEventCreated) {
                CloseHandle(hEvent);
            }
            goto Exit;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("CUserProfile::WatchHiveRefCount: NtUnloadKeyEx succeeded for %s"), tszHiveName));
        }

        //
        // If we are reusing the event from work item list then we do not
        // need to add it anymore
        //

        if (bEventCreated) {
            //
            // Add the work item to clean up the profile when the hive is unloaded.
            //

            hres = AddWorkItem(pTmp, hEvent);

            //
            // Do not return error if we fail to add the work item because
            // cleaning up is a best effort. The important thing is that we
            // unloaded the hive successfully, or at least registered
            // successfully to do so.
            //

            if(hres != S_OK) {
                DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: AddWorkItem failed with %08x"), hres));
                CloseHandle(hEvent);
                hres = S_OK;
            }
        }
    } 


Exit:

    if(bInCriticalSection) {
        LeaveCriticalSection(&csMap);
    }

    //
    // Restore the privilege to its previous state.
    //

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    if(!bWasEnabled && !NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::WatchHiveRefCount: Failed to restore the privilege. error = %08x"), status));
    }

    return hres;
}


//*************************************************************
//
//  CUserProfile::AddWorkItem
//
//      Add a new work item.
//
//  Parameters:
//
//      pSid               the user's sid
//      hEvent             the event registry will set when hive is unloaded.
//
//  Return value:
//
//      HRESULT error code.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

HRESULT CUserProfile::AddWorkItem(LPCTSTR pSid, HANDLE hEvent)
{
    PMAP                    pThreadMap = NULL;
    HRESULT                 hres = E_FAIL;
    HANDLE                  hThreadEvent = INVALID_HANDLE_VALUE;
    HANDLE                  hThread = INVALID_HANDLE_VALUE;
    BOOL                    bHashDelete = TRUE;
    LPTSTR                  pSidCopy = NULL;
    DWORD                   cchSidCopy;


    DebugMsg((DM_VERBOSE, TEXT("Entering CUserProfile::AddWorkItem: %s"), pSid));

    cchSidCopy = lstrlen(pSid) + 1;
    pSidCopy = (LPTSTR)LocalAlloc(LPTR, cchSidCopy * sizeof(TCHAR));
    if(!pSidCopy) {
        hres = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: Out of memory")));
        goto Exit;
    }
    StringCchCopy(pSidCopy, cchSidCopy, pSid);

    //
    // Make sure the leading 's' is in uppercase.
    //

    *pSidCopy = (TCHAR)_totupper(*pSidCopy);

    //
    // Verify that this sid is not already in our work list.
    //

    if(!cTable.HashAdd(pSidCopy)) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: sid %s already in work list"), pSidCopy));
        bHashDelete = FALSE;
        goto Exit;
    }


    //
    // Look through the work item thread map list to find a thread that is not
    // fully loaded;
    //

    for(pThreadMap = pMap; pThreadMap != NULL; pThreadMap = pThreadMap->pNext) {
        if(pThreadMap->dwItems < MAXIMUM_WAIT_OBJECTS) {
            break;
        }
    }


    if(!pThreadMap) {

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: No thread available, create a new one.")));

        //
        // Create the thread event.
        //

        pThreadMap = new MAP();
        if(!pThreadMap) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: new operator failed. error = %08x"), hres));
            goto Exit;
        }
        if((hThreadEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL)) == NULL) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: CreateEvent failed for thread event. error = %08x"), hres));
            goto Exit;
        }
        pThreadMap->Insert(hThreadEvent, NULL);


        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Signal event item inserted")));

        //
        // Create the thread.
        //

        if((hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadMain,
                                   pThreadMap,
                                   0,
                                   NULL)) == NULL) {
            hres = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CUserProfile::AddWorkItem: CreateThread failed. error = %08x"), hres));
            
            //
            // Delete the thread signal event item.
            //

            pThreadMap->Delete(0);
            goto Exit;
        }
        else {
            CloseHandle(hThread);
        }
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: New thread created")));

        //
        // Successful return. Insert the work item into pThreadMap.
        //

        pThreadMap->Insert(hEvent, pSidCopy);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Work Item inserted")));
        
        //
        // Insert pThreadMap into the map list.
        //

        pThreadMap->pNext = pMap;
        pMap = pThreadMap;
    }
    else {
    
        //
        // Found an existing thread. Insert the work item into it's map.
        //

        pThreadMap->Insert(hEvent, pSidCopy);

        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: Work item inserted")));
    }

    //
    // Wake up the thread. If the thread can not be waken up by setting the
    // event here, then it'll be stuck in sleep state until one day this
    // SetEvent call succeeds. Leave the work item in and continue.
    //

    if(!SetEvent(pThreadMap->rghEvents[0])) {
        hres = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("SetEvent failed. error = %08x"), hres));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::AddWorkItem: thread woken up")));
    }
    
    pThreadMap = NULL;
    hres = S_OK;
    bHashDelete = FALSE;
    pSidCopy = NULL;

Exit:

    if(bHashDelete && pSidCopy) {
        cTable.HashDelete(pSidCopy);
    }

    if(pSidCopy) {
        LocalFree(pSidCopy);
    }
    
    if(pThreadMap) {
        delete pThreadMap;
    }
    
    DebugMsg((DM_VERBOSE, TEXT("Exiting CUserProfile::AddWorkItem with %08x"), hres));
    return hres;
}


//*************************************************************
//
//  CUserProfile::GetWorkItem
//
//      Get the event of an existing work item.
//
//  Parameters:
//
//      pSid               the user's sid
//
//  Return value:
//
//      Handle to the event found in map structure
//      NULL if no such entry
//
//  History:
//
//      Created         santanuc        8/23/01
//
//*************************************************************

HANDLE CUserProfile::GetWorkItem(LPCTSTR pSid)
{
    HANDLE hEvent = NULL;
    PMAP   pThreadMap = NULL;
    DWORD  dwIndex;

    //
    // Look through the work item thread map list to find an entry 
    // that has same sid
    //

    for(pThreadMap = pMap; pThreadMap != NULL; pThreadMap = pThreadMap->pNext) {
        for (dwIndex = 1; dwIndex < pThreadMap->dwItems; dwIndex++) {
            if (lstrcmpi(pSid, pThreadMap->rgSids[dwIndex]) == 0) {
                hEvent = pThreadMap->rghEvents[dwIndex];
                break;
            }
        }
    }

    return hEvent;
}


//*************************************************************
//
//  CUserProfile::CleanupUserProfile
//
//      Unload the hive and delete the profile directory if necessary.
//
//  Parameters:
//
//      ptszSid         - User's sid string
//      phkProfileList  - in/out parameter. Handle to the profile list key.
//                        if NULL, will fill in the handle. And this handle
//                        has to be closed by the caller.
//
//  Comment:
//
//      Always ignore error and continue because this is a best effort.
//
//*************************************************************

void CUserProfile::CleanupUserProfile(LPTSTR ptszSid, HKEY* phkProfileList)
{
    DWORD   dwInternalFlags = 0;
    DWORD   dwRefCount;
    BOOL    bInCS = FALSE;


    //
    // Enter the critical section.
    //

    if(!EnterUserProfileLockLocal(ptszSid)) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile:: Failed to get the user profile lock for %s"), ptszSid));
        goto Exit;
    }
    bInCS = TRUE;
    
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: Enter critical section.")));

    //
    // Get the reference count and the internal flags.
    //

    if(GetRefCountAndFlags(ptszSid, phkProfileList, &dwRefCount, &dwInternalFlags) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: Can not get ref count and flags")));
        goto Exit;
    }

    //
    // If the ref count is 0, clean up the user's profile. If not, give up.
    //

    if(dwRefCount != 0) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: Ref Count is not 0")));
        goto Exit;
    }   
    
    //
    // Delete the temporary profile if:
    // guest user profile           or
    // temp profile                 or
    // mandatory profile
    // Profiles that are none of the above will not be cleaned up even if
    // Delete cache bit is set in the registry or the policy says delete
    // cached profiles. This is because even though now we unloaded the
    // hive we don't upload the profile. Deleting the local profile might
    // result in user's data loss.
    //

    // Don't delete the guest account if machine is in workgroup 
    INT iRole;

    if(dwInternalFlags & PROFILE_MANDATORY ||
       dwInternalFlags & PROFILE_TEMP_ASSIGNED ||
       ((dwInternalFlags & PROFILE_GUEST_USER) && GetMachineRole(&iRole) && (iRole != 0))) {
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: DeleteProfile")));
        if(!DeleteProfile(ptszSid, NULL, NULL)) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::CleanupUserProfile: DeleteProfile returned FALSE. error = %08x"), GetLastError()));
        }
    }
    
Exit:

    if(bInCS) {
        LeaveUserProfileLockLocal(ptszSid);
        DebugMsg((DM_VERBOSE, TEXT("CUserProfile::CleanupUserProfile: Leave critical section")));
    }
}


//*************************************************************
//
//  CUserProfile::GetRefCountAndFlags
//
//      Get the ref count and internal flags from the registry for a user.
//
//  Parameters:
//
//      ptszSid         - User's sid string
//      phkPL           - in/out parameter. Handle to the profile list key.
//                        If NULL, will be filled with an opened key to the
//                        profile list. The caller is responsible for
//                        closing it.
//      dwRefCount      - buffer for the ref count.
//      dwInternalFlags - buffer for the internal flags.
//
//  History:
//
//      Created         weiruc         5/23/2000 
//
//*************************************************************

long CUserProfile::GetRefCountAndFlags(LPCTSTR ptszSid, HKEY* phkPL, DWORD* dwRefCount, DWORD* dwInternalFlags)
{
    HKEY        hkUser = NULL;
    DWORD       dwType, dwSize = sizeof(DWORD);
    long        lResult = ERROR_SUCCESS;

    *dwRefCount = 0;
    *dwInternalFlags = 0;

    if (!ptszSid)
    {
        lResult = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    
    if(!*phkPL) {
        
        //
        // Open the profile list if it's not already opened.
        //

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               PROFILE_LIST_PATH,
                               0,
                               KEY_READ,
                               phkPL);
        if(lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags:  Failed to open profile list key with error %d"), lResult));
            goto Exit;
        }
    }

    //
    // Open the user's key in the profile list.
    //

    if((lResult = RegOpenKeyEx(*phkPL,
                  ptszSid,
                  0,
                  KEY_READ,
                  &hkUser)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegOpenKeyEx failed with error %08x"), lResult));
        goto Exit;
    }


    //
    // Query for the ref count and the internal flags.
    //

    if((lResult = RegQueryValueEx(hkUser,
                                  PROFILE_REF_COUNT,
                                  0,
                                  &dwType,
                                  (LPBYTE)dwRefCount,
                                  &dwSize)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegQueryValueEx failed, key = %s, error = %08x"), ptszSid, lResult));
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    if((lResult = RegQueryValueEx(hkUser,
                                  PROFILE_STATE,
                                  0,
                                  &dwType,
                                  (LPBYTE)dwInternalFlags,
                                  &dwSize)) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CUserProfile::GetRefCountAndFlags: RegQueryValueEx failed, key = %s, error = %08x"), ptszSid, lResult));
        goto Exit;
    }
    DebugMsg((DM_VERBOSE, TEXT("CUserProfile::GetRefCountAndFlags: Ref count is %d, state is %08x"), *dwRefCount, *dwInternalFlags));

Exit:

    if(hkUser) {
        RegCloseKey(hkUser);
    }

    return lResult;
}


//*************************************************************
//
//  LoadUserProfileI()
//
//  Purpose:    Just a wrapper around CUserProfile::LoadUserProfileP
//
//  Parameters: hBindHandle   - server explicit binding handle
//              pProfileInfo  - Profile Information
//              phContext     - server context for client
//              lpRPCEndPoint - RPCEndPoint of the registered IProfileDialog interface 
//
//  Return:     DWORD
//              ERROR_SUCCESS - if everything is ok
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD LoadUserProfileI(IN handle_t hBindHandle,
                       IN LPPROFILEINFO lpProfileInfo,
                       IN PCONTEXT_HANDLE phContext,
                       IN LPTSTR lpRPCEndPoint,
                       IN BYTE* pbCookie,
                       IN DWORD cbCookie)
{
    HANDLE      hUserToken = NULL;
    BOOL        bImpersonatingUser = FALSE;
    PCLIENTINFO pClientInfo;
    DWORD       dwErr = ERROR_ACCESS_DENIED;
    RPC_STATUS  status;

    if (lpRPCEndPoint) {
        DebugMsg((DM_VERBOSE, TEXT("LoadUserProfileI: RPC end point %s"), lpRPCEndPoint));
    }

    //
    // Get the context
    //

    if (!phContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: NULL context")));
        goto Exit;
    }

    pClientInfo = (PCLIENTINFO)phContext;

    //
    // Verify that the PROFILEINFO structure passed in is the same one.
    //

    if(!CompareProfileInfo(lpProfileInfo, pClientInfo->pProfileInfo)) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: PROFILEINFO structure passed in is different")));
        goto Exit;
    }

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != S_OK) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    bImpersonatingUser = TRUE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hUserToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: OpenThreadToken failed with %d"), dwErr));
        goto Exit;
    }

    status = RpcRevertToSelf();
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: RpcRevertToSelf failed with %d"), status));
    }
    bImpersonatingUser = FALSE;

    //
    // Now that we have both the client and the user's token, call
    // LoadUserProfileP to do the work.
    //

    if(!cUserProfileManager.LoadUserProfileP(pClientInfo->hClientToken, hUserToken, pClientInfo->pProfileInfo, lpRPCEndPoint, pbCookie, cbCookie)) {
        dwErr = GetLastError();   
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: LoadUserProfileP failed with %d"), dwErr));
        goto Exit;
    }

    //
    // Close the registry handle to the user hive opened by LoadUserProfileP.
    //

    RegCloseKey((HKEY)pClientInfo->pProfileInfo->hProfile);
    dwErr = ERROR_SUCCESS;

Exit:

    if(bImpersonatingUser) {
        status = RpcRevertToSelf();
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("LoadUserProfileI: RpcRevertToSelf failed with %d"), status));
        }
    }

    if(hUserToken) {
        CloseHandle(hUserToken);
    }

    DebugMsg((DM_VERBOSE, TEXT("LoadUserProfileI: returning %d"), dwErr));
    return dwErr;
}


//*************************************************************
//
//  UnloadUserProfileI()
//
//  Purpose:    Just a wrapper around CUserProfile::UnloadUserProfileP
//
//  Parameters: hBindHandle   - server explicit binding handle
//              phContext     - server context for client
//              lpRPCEndPoint - RPCEndPoint of the registered IProfileDialog interface 
//
//  Return:     DWORD
//              ERROR_SUCCESS - if everything is ok
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

DWORD UnloadUserProfileI(IN handle_t hBindHandle,
                         IN PCONTEXT_HANDLE phContext,
                         IN LPTSTR lpRPCEndPoint,
                         IN BYTE* pbCookie,
                         IN DWORD cbCookie)
{
    HANDLE  hUserToken = NULL;
    HKEY    hProfile = NULL;
    BOOL    bImpersonatingUser = FALSE;
    PCLIENTINFO pClientInfo;
    LPTSTR  pSid = NULL;
    long    lResult;
    RPC_STATUS  status;
    DWORD   dwErr = ERROR_ACCESS_DENIED;

    //
    // Get the context
    //

    if (!phContext) {
        dwErr = ERROR_INVALID_PARAMETER;
        DebugMsg((DM_WARNING, TEXT("UnLoadUserProfileI: NULL context")));
        goto Exit;
    }

    pClientInfo = (PCLIENTINFO)phContext;

    //
    // Impersonate the client to get the user's token.
    //

    if((status = RpcImpersonateClient(0)) != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: CoImpersonateClient failed with %ld"), status));
        dwErr = status;
        goto Exit;
    }
    bImpersonatingUser = TRUE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ, TRUE, &hUserToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: OpenThreadToken failed with %d"), dwErr));
        goto Exit;
    }

    status = RpcRevertToSelf();
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: RpcRevertToSelf failed with %d"), status));
    }
    bImpersonatingUser = FALSE;

    //
    // Open the user's registry hive root.
    //

    pSid = GetSidString(hUserToken);
    if (!pSid)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: GetSidString failed with %d"), dwErr));
        goto Exit;
    }
    
    if((lResult = RegOpenKeyEx(HKEY_USERS, pSid, 0, KEY_ALL_ACCESS, &hProfile)) != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: RegOpenKeyEx failed with %d"), dwErr));
        goto Exit;
    }

    //
    // Now that we have both the client and the user's token, call
    // UnloadUserProfileP to do the work. hProfile gets closed in
    // UnloadUserProfileP so don't close it again.
    //

    if(!cUserProfileManager.UnloadUserProfileP(pClientInfo->hClientToken, hUserToken, hProfile, lpRPCEndPoint, pbCookie, cbCookie)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: UnloadUserProfileP failed with %d"), dwErr));
        goto Exit;
    }
    
    dwErr = ERROR_SUCCESS;

Exit:

    if(bImpersonatingUser) {
        status = RpcRevertToSelf();
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("UnloadUserProfileI: RpcRevertToSelf failed with %d"), status));
        }
    }

    if(hUserToken) {
        CloseHandle(hUserToken);
    }

    if(pSid) {
        DeleteSidString(pSid);
    }

    DebugMsg((DM_VERBOSE, TEXT("UnloadUserProfileI: returning %d"), dwErr));
    SetLastError(dwErr);
    return dwErr;
}


//*************************************************************
//
//  CompareProfileInfo()
//
//  Purpose:    Compare field by field two PROFILEINFO structures
//              except for the hProfile field.
//
//  Parameters: pInfo1, pInfo2
//
//  Return:     TRUE    -   Same
//              FALSE   -   Not the same
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

BOOL CompareProfileInfo(LPPROFILEINFO pInfo1, LPPROFILEINFO pInfo2)
{
    BOOL    bRet = TRUE;


    if(!pInfo1 || !pInfo2) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: Invalid parameter")));
        return FALSE;
    }

    if(pInfo1->dwSize != pInfo2->dwSize) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: dwSize %d != %d"), pInfo1->dwSize, pInfo2->dwSize));
        return FALSE;
    }

    if(pInfo1->dwFlags != pInfo2->dwFlags) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: dwFlags %d != %d"), pInfo1->dwFlags, pInfo2->dwFlags));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpUserName, pInfo2->lpUserName)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpUserName <%s> != <%s>"), pInfo1->lpUserName, pInfo2->lpUserName));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpProfilePath, pInfo2->lpProfilePath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpProfilePath <%s> != <%s>"), pInfo1->lpProfilePath, pInfo2->lpProfilePath));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpDefaultPath, pInfo2->lpDefaultPath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpDefaultPath <%s> != <%s>"), pInfo1->lpDefaultPath, pInfo2->lpDefaultPath));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpServerName, pInfo2->lpServerName)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpServerName <%s> != <%s>"), pInfo1->lpServerName, pInfo2->lpServerName));
        return FALSE;
    }

    if(lstrcmpi(pInfo1->lpPolicyPath, pInfo2->lpPolicyPath)) {
        DebugMsg((DM_WARNING, TEXT("CompareProfileInfo: lpPolicyPath <%s> != <%s>"), pInfo1->lpPolicyPath, pInfo2->lpPolicyPath));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CopyProfileInfo()
//
//  Purpose:    Allocate and copy a PROFILEINFO structure.
//
//  Parameters: pProfileInfo    -   To be copied
//
//  Return:     The copy
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

LPPROFILEINFO CopyProfileInfo(LPPROFILEINFO pProfileInfo)
{
    LPPROFILEINFO   pInfoCopy = NULL;
    BOOL            bSuccess = FALSE;
    DWORD           cch;

    //
    // Allocate and initialize memory for the PROFILEINFO copy.
    //

    pInfoCopy = (LPPROFILEINFO)LocalAlloc(LPTR, sizeof(PROFILEINFO));
    if(!pInfoCopy) {
        goto Exit;
    }

    //
    // Copy field by field.
    //

    pInfoCopy->dwSize = pProfileInfo->dwSize;

    pInfoCopy->dwFlags = pProfileInfo->dwFlags;

    if(pProfileInfo->lpUserName) {
        cch = lstrlen(pProfileInfo->lpUserName) + 1;
        pInfoCopy->lpUserName = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if(!pInfoCopy->lpUserName) {
            goto Exit;
        }
        StringCchCopy(pInfoCopy->lpUserName, cch, pProfileInfo->lpUserName);
    }

    if(pProfileInfo->lpProfilePath) {
        cch = lstrlen(pProfileInfo->lpProfilePath) + 1;
        pInfoCopy->lpProfilePath = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if(!pInfoCopy->lpProfilePath) {
            goto Exit;
        }
        StringCchCopy(pInfoCopy->lpProfilePath, cch, pProfileInfo->lpProfilePath);
    }

    if(pProfileInfo->lpDefaultPath) {
        cch = lstrlen(pProfileInfo->lpDefaultPath) + 1;
        pInfoCopy->lpDefaultPath = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if(!pInfoCopy->lpDefaultPath) {
            goto Exit;
        }
        StringCchCopy(pInfoCopy->lpDefaultPath, cch, pProfileInfo->lpDefaultPath);
    }

    if(pProfileInfo->lpServerName) {
        cch = lstrlen(pProfileInfo->lpServerName) + 1;
        pInfoCopy->lpServerName = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if(!pInfoCopy->lpServerName) {
            goto Exit;
        }
        StringCchCopy(pInfoCopy->lpServerName, cch, pProfileInfo->lpServerName);
    }

    if(pProfileInfo->lpPolicyPath) {
        cch = lstrlen(pProfileInfo->lpPolicyPath) + 1;
        pInfoCopy->lpPolicyPath = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if(!pInfoCopy->lpPolicyPath) {
            goto Exit;
        }
        StringCchCopy(pInfoCopy->lpPolicyPath, cch, pProfileInfo->lpPolicyPath);
    }

    bSuccess = TRUE;

Exit:

    if(!bSuccess && pInfoCopy) {
        DeleteProfileInfo(pInfoCopy);
        pInfoCopy = NULL;
    }

    return pInfoCopy;
}


//*************************************************************
//
//  DeleteProfileInfo()
//
//  Purpose:    Delete a PROFILEINFO structure
//
//  Parameters: pInfo
//
//  Return:     void
//
//  History:    Date        Author     Comment
//              6/29/00     weiruc     Created
//
//*************************************************************

void DeleteProfileInfo(LPPROFILEINFO pInfo)
{
    if(!pInfo) {
        return;
    }

    if(pInfo->lpUserName) {
        LocalFree(pInfo->lpUserName);
    }

    if(pInfo->lpProfilePath) {
        LocalFree(pInfo->lpProfilePath);
    }

    if(pInfo->lpDefaultPath) {
        LocalFree(pInfo->lpDefaultPath);
    }

    if(pInfo->lpServerName) {
        LocalFree(pInfo->lpServerName);
    }

    if(pInfo->lpPolicyPath) {
        LocalFree(pInfo->lpPolicyPath);
    }

    LocalFree(pInfo);
}


//*************************************************************
//
//  GetInterface()
//
//  Purpose:    Get the rpc binding handle 
//
//  Parameters: phIfHandle    - rpc binding handle to initialize
//              lpRPCEndPoint - RPCEndPoint of interface
//
//  Return:     TRUE if successful.
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

BOOL GetInterface(handle_t * phIfHandle, LPTSTR lpRPCEndPoint)
{
    RPC_STATUS              status;
    LPTSTR                  pszStringBinding = NULL;
    BOOL                    bStringBinding = FALSE, bRetVal = FALSE;

    // compose string to pass to binding api

    status = RpcStringBindingCompose(NULL,
                                     cszRPCProtocol,
                                     NULL,
                                     lpRPCEndPoint,
                                     NULL,
                                     &pszStringBinding);
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("GetInterface:  RpcStringBindingCompose fails with error %ld"), status));
        goto Exit;
    }
    bStringBinding = TRUE;

    // set the binding handle that will be used to bind to the server.

    status = RpcBindingFromStringBinding(pszStringBinding,
                                         phIfHandle);
    if (status != RPC_S_OK) {
        DebugMsg((DM_WARNING, TEXT("GetInterface:  RpcStringBindingCompose fails with error %ld"), status));
        goto Exit;
    }
   
    bRetVal = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("GetInterface: Returning rpc binding handle")));

Exit:
    // free string

    if (bStringBinding) 
        RpcStringFree(&pszStringBinding);

    return bRetVal;
}

//*************************************************************
//
//  ReleaseInterface()
//
//  Purpose:    Release the rpc binding handle 
//
//  Parameters: phIfHandle    - rpc binding handle to initialize
//
//  Return:     TRUE if successful.
//
//  History:    Date        Author     Comment
//              10/24/00    santanuc   Created
//
//*************************************************************

BOOL ReleaseInterface(handle_t * phIfHandle)
{
    RPC_STATUS    status;

    // free binding handle

    DebugMsg((DM_VERBOSE, TEXT("ReleaseInterface: Releasing rpc binding handle")));
    status = RpcBindingFree(phIfHandle);

    return (status == RPC_S_OK);
}

//*************************************************************
//
//  CheckNetDefaultProfile()
//
//  Purpose:    Checks if a network profile exists
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This routine assumes we are working
//              in the user's context.
//
//  History:    Date        Author     Comment
//              9/21/95     ericflo    Created
//              4/10/99     ushaji     modified to remove local caching
//
//*************************************************************

BOOL CheckNetDefaultProfile (LPPROFILE lpProfile)
{
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szLocalDir[MAX_PATH];
    DWORD dwSize, dwFlags, dwErr;
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    LPTSTR lpNetPath = lpProfile->lpDefaultProfile;
    HANDLE hOldToken;
    DWORD cchBuffer = ARRAYSIZE(szBuffer);
    UINT cchEnd;
    HRESULT hr;


    //
    // Get the error at the beginning of the call.
    //

    dwErr = GetLastError();


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: Entering, lpNetPath = <%s>"),
             (lpNetPath ? lpNetPath : TEXT("NULL"))));


    if (!lpNetPath || !(*lpNetPath)) {
        return bRetVal;
    }

    //
    //  Check for cross forest logon
    //

    hr = CheckXForestLogon(lpProfile->hTokenUser);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CheckNetDefaultProfile: CheckXForestLogon failed, hr = %08X"), hr));
    }
    else if (hr == S_FALSE)
    {
        //
        //  cross forest logon detected, disable network default profile.
        //
        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: CheckXForestLogon returned S_FALSE, disable net default profile")));
        if (lpProfile->lpDefaultProfile)
        {
            lpProfile->lpDefaultProfile[0] = TEXT('\0');
        }
        lpProfile->dwInternalFlags |= DEFAULT_NET_READY;
        return bRetVal;
    }

    //
    // Impersonate the user....
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {

        if (lpProfile->lpDefaultProfile) {
            *lpProfile->lpDefaultProfile = TEXT('\0');
        }

        //
        // Last error is set
        //

        return bRetVal;
    }

    //
    // See if network copy exists
    //

    hFile = FindFirstFile (lpNetPath, &fd);

    if (hFile != INVALID_HANDLE_VALUE) {


        //
        // Close the find handle
        //

        FindClose (hFile);


        //
        // We found something.  Is it a directory?
        //

        if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  FindFirstFile found a file. ignoring Network Defaul profile")));
            dwErr = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }


        //
        // Is there a ntuser.* file in this directory?
        //

        hr = AppendName(szBuffer, cchBuffer, lpNetPath, c_szNTUserStar, &lpEnd, &cchEnd);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CheckNetDefaultProfile: failed to append ntuser.* to lpNetPath.")));
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

        hFile = FindFirstFile (szBuffer, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  FindFirstFile found a directory, but no ntuser files.")));
            dwErr = ERROR_FILE_NOT_FOUND;
            goto Exit;
        }

        FindClose (hFile);

        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Found a valid network profile.")));

        bRetVal = TRUE;
    }
    else {
        dwErr = ERROR_FILE_NOT_FOUND;
    }

Exit:

    //
    // If we are leaving successfully, then
    // save the local profile directory.
    //

    if (bRetVal) {
        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: setting default profile to <%s>"), lpNetPath));

    } else {
        DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile: setting default profile to NULL")));

        //
        // resetting it to NULL in case we didn't see the server directory.
        //

        if (lpProfile->lpDefaultProfile) {
            *lpProfile->lpDefaultProfile = TEXT('\0');
        }
    }


    //
    // Tag the internal flags so we don't do this again.
    //

    lpProfile->dwInternalFlags |= DEFAULT_NET_READY;

    //
    // Now set the last error
    //

    //
    // Revert before trying to delete the local default network profile
    //

    RevertToUser(&hOldToken);

    //
    // We will keep this on always so that we can delete any preexisting
    // default network profile, try to delete it and ignore
    // the failure if it happens

    //
    // Expand the local profile directory
    //


    dwSize = ARRAYSIZE(szLocalDir);
    if (!GetProfilesDirectoryEx(szLocalDir, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("CheckNetDefaultProfile:  Failed to get default user profile.")));
        SetLastError(dwErr);
        return bRetVal;
    }


    lpEnd = CheckSlashEx (szLocalDir, ARRAYSIZE(szLocalDir), &cchEnd);
    StringCchCopy (lpEnd, cchEnd, DEFAULT_USER_NETWORK);


    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Removing local copy of network default user profile.")));
    Delnode (szLocalDir);


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("CheckNetDefaultProfile:  Leaving with a value of %d."), bRetVal));


    SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  ParseProfilePath()
//
//  Purpose:    Parses the profile path to determine if
//              it points at a directory or a filename.
//              In addition it determines whether a profile is
//              acoss a slow link and whether the user has access
//              to the profile.
//
//  Parameters: lpProfile       -   Profile Information
//              lpProfilePath   -   Input path
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

BOOL ParseProfilePath(LPPROFILE lpProfile, LPTSTR lpProfilePath, BOOL *bpCSCBypassed, TCHAR *cpDrive)
{
    DWORD           dwAttributes;
    LPTSTR          lpEnd;
    BOOL            bRetVal = FALSE;
    BOOL            bMandatory = FALSE;
    DWORD           dwStart, dwDelta, dwErr = ERROR_SUCCESS;
    DWORD           dwStrLen;
    HANDLE          hOldToken;
    TCHAR           szErr[MAX_PATH];
    BOOL            bAddAdminGroup = FALSE;
    BOOL            bReadOnly = FALSE;
    HKEY            hSubKey;
    DWORD           dwSize, dwType;
    BOOL            bImpersonated = FALSE;
    LPTSTR          lpCscBypassedPath = NULL;
    HRESULT         hr;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Entering, lpProfilePath = <%s>"),
             lpProfilePath));

    //
    //  Check "LocalProfile" policy and user preference
    //
    if (lpProfile->dwUserPreference == USERINFO_LOCAL) {
        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: User preference is local. Ignoring roaming profile path")));
        goto DisableAndExit;
    }

    //
    //  Check for cross forest logon
    //

    hr = CheckXForestLogon(lpProfile->hTokenUser);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: CheckXForestLogon failed, hr = %08X"), hr));
    }
    else if (hr == S_FALSE)
    {
        //
        //  cross forest logon detected, disable RUP and network default profile.
        //
        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CheckXForestLogon returned S_FALSE, disable RUP")));
        if (lpProfile->lpDefaultProfile)
        {
            lpProfile->lpDefaultProfile[0] = TEXT('\0');
        }
        ReportError(lpProfile->hTokenUser, EVENT_WARNING_TYPE, 0, EVENT_X_FOREST_LOGON_DISABLED);
        //
        //  Also, set this USERINFO_LOCAL flag, so we will treat this profile as a roaming profile but
        //  user preference set to local. This way, the user can modify there prefrence to "Local" to
        //  avoid seeing the xforest error message.
        //
        lpProfile->dwUserPreference = USERINFO_LOCAL;
        goto DisableAndExit;
    }


    //
    // Check for .man extension
    //

    dwStrLen = lstrlen (lpProfilePath);

    if (dwStrLen >= 4) {

        lpEnd = lpProfilePath + dwStrLen - 4;
        if (!lstrcmpi(lpEnd, c_szMAN)) {
            bMandatory = TRUE;
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Mandatory profile (.man extension)")));
        }
    }


    //
    // Check whether we need to give access to the admin on the RUP share
    //

    //
    // Check for a roaming profile security/read only preference
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bAddAdminGroup);
        RegQueryValueEx(hSubKey, ADD_ADMIN_GROUP_TO_RUP, NULL, &dwType,
                        (LPBYTE) &bAddAdminGroup, &dwSize);

        dwSize = sizeof(bReadOnly);
        RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                        (LPBYTE) &bReadOnly, &dwSize);

        RegCloseKey(hSubKey);
    }


    //
    // Check for a roaming profile security/read only policy
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bAddAdminGroup);
        RegQueryValueEx(hSubKey, ADD_ADMIN_GROUP_TO_RUP, NULL, &dwType,
                        (LPBYTE) &bAddAdminGroup, &dwSize);

        dwSize = sizeof(bReadOnly);
        RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                        (LPBYTE) &bReadOnly, &dwSize);
        RegCloseKey(hSubKey);
    }


    if (bReadOnly) {
        lpProfile->dwInternalFlags |= PROFILE_READONLY;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to impersonate user")));
        // last error is already set.
        return FALSE;
    }

    bImpersonated = TRUE;

    // Check whether RUP share is CSCed, if it is give a warning.

    CheckRUPShare(lpProfilePath);

    // 
    // Try to bypass CSC to avoid conflicts in syncing files between roaming share & local profile
    //

    if (IsUNCPath(lpProfilePath)) {
        if ((dwErr = AbleToBypassCSC(lpProfile->hTokenUser, lpProfilePath, &lpCscBypassedPath, cpDrive)) == ERROR_SUCCESS) {
            *bpCSCBypassed = TRUE;
            lpProfilePath = lpCscBypassedPath;
            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed. Profile path %s"), lpProfilePath));
        }
        else {
            if (dwErr == WN_BAD_LOCALNAME || dwErr == WN_ALREADY_CONNECTED || dwErr == ERROR_BAD_PROVIDER) {
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed failed. Profile path %s"), lpProfilePath));
                dwErr = ERROR_SUCCESS;
            }
            else {
                // Share is not up. So we do not need to do any further check
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: CSC bypassed failed. Ignoring Roaming profile path")));
                goto Exit;
            }
        }    
    }

    //
    // Start by calling GetFileAttributes so we have file attributes
    // to work with.  We have to call GetFileAttributes twice.  The
    // first call sets up the session so we can call it again and
    // get accurate timing information for slow link detection.
    //


    dwAttributes = GetFileAttributes(lpProfilePath);

    if (dwAttributes != -1) {
        dwStart = GetTickCount();

        dwAttributes = GetFileAttributes(lpProfilePath);
    
        dwDelta = GetTickCount() - dwStart;

        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Tick Count = %d"), dwDelta));

        //
        // if it is success, find out whether the profile is
        // across a slow link.
        //
        // Looks like this is possible at least when a
        // share doesn't exist on a server across a slow link.
        // if this is not possible
        //      then checkforslowlink will have to be moved down to check
        //      after we have found a valid share
        //


        if (!bMandatory && !bReadOnly) {
            CheckForSlowLink (lpProfile, dwDelta, lpProfile->lpProfilePath, TRUE);
            if (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK) {
                DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Profile is across a slow link. Ignoring roaming profile path")));
                goto DisableAndExit;
            }
        }
    }
    else {
        dwErr = GetLastError(); // get the error now for later use
    }

    //
    // if we have got a valid handle
    //

    if (dwAttributes != -1) {

        //
        // GetFileAttributes found something.
        // look at the file attributes.
        //

        DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: GetFileAttributes found something with attributes <0x%x>"),
                 dwAttributes));

        //
        // If we found a directory, we have a proper profile
        // directory. exit.
        //

        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Found a directory")));
            bRetVal = TRUE;
            goto Exit;
        }
        else {

            //
            // We found a file.
            //
            // In 3.51, we used to have a file for the profile.
            //
            // In the migration part of the code, we used to take this file
            // nad migrate to a directory that ends in .pds (for normal profiles)
            // and .pdm for (for mandatory profiles).
            //

            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Found a file")));

        }

        dwErr = ERROR_PATH_NOT_FOUND;
        goto Exit;

    }


    //
    // GetFileAttributes failed.  Look at the error to determine why.
    //

    DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: GetFileAttributes failed with error %d"),
              dwErr));


    if (bMandatory) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Couldn't access mandatory profile <%s> with error %d"), lpProfilePath, GetLastError()));
        goto Exit;
    }


    if (bReadOnly) {
        DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Couldn't access mandatory profile <%s> with error %d"), lpProfilePath, GetLastError()));
        goto Exit;
    }


    //
    // To fix bug #414176, the last error code chk has been added.
    //
    // ERROR_BAD_NET_NAME is the error code that is returned by GetFileAttributes
    // when the profile directory for a user actually points to the root
    // of the share.
    // CreateDirectory should succeed.
    //

    if ( (dwErr == ERROR_FILE_NOT_FOUND) ||
         (dwErr == ERROR_PATH_NOT_FOUND) ||
         (dwErr == ERROR_BAD_NET_NAME) ) {

        //
        // Nothing found with this name.
        //
        // In 3.51, we used to have a file for the profile.
        //
        // In the migration part of the code, we used to take this file
        // nad migrate to a directory that ends in .pds (for normal profiles)
        // and .pdm for (for mandatory profiles).
        //

        if (CreateSecureDirectory(lpProfile, lpProfilePath, NULL, !bAddAdminGroup)) {

            //
            // Successfully created the directory.
            //

            DebugMsg((DM_VERBOSE, TEXT("ParseProfilePath: Succesfully created the sub-directory")));
            bRetVal = TRUE;
            goto Exit;

        } else {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to create user sub-directory.  Error = %d"),
                     GetLastError()));
            goto Exit;
        }
    }

    goto Exit;


Exit:

    if (!bRetVal) {


        //
        // We have failed to connect to the profile server for some reason.
        // Now evaluate whether we want to disable profile and log the user in
        // or prevent the user from logging on.
        //
        // In addition give an appropriate popup..
        //


        if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
            if (bMandatory) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }
            else if (bReadOnly) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
            }

            goto DisableAndExit;
        }
        else {
            if (bMandatory) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_ERROR, GetErrString(dwErr, szErr));
            }
            else if (bReadOnly) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
                goto DisableAndExit;

                // temporary profile decisions will kick in, in restoreuserprofile later on..
             }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE_DISABLE, GetErrString(dwErr, szErr));
                goto DisableAndExit;

                // temporary profile decisions will kick in, in restoreuserprofile later on..
            }
        }
    }
    else {
        StringCchCopy(lpProfile->lpRoamingProfile, MAX_PATH, lpProfilePath);
    }

    goto CleanupAndExit;


DisableAndExit:

    lpProfile->lpRoamingProfile[0] = TEXT('\0');

    bRetVal = TRUE;


CleanupAndExit:

    //
    // Revert to being 'ourself'
    //

    if(bImpersonated) {
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ParseProfilePath: Failed to revert to self")));
        }
    }

    if (lpCscBypassedPath) {
        LocalFree(lpCscBypassedPath);
    }

    if (!bRetVal)
        SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  GetExclusionList()
//
//  Purpose:    Get's the exclusion list used at logon
//
//  Parameters: lpProfile   - Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetExclusionList (LPPROFILE lpProfile)
{
    LPTSTR szExcludeListLocal = NULL;
    LPTSTR szExcludeListServer = NULL;
    LPTSTR szNTUserIni = NULL;
    LPTSTR lpEnd;
    HANDLE hOldToken;
    BOOL   bRetVal = FALSE;
    UINT  cchNTUserIni;
    UINT  cchEnd;
    UINT  cchExclusionList;
    HRESULT hr;


    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szExcludeListLocal = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR));
    if (!szExcludeListLocal) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    szExcludeListServer = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR));
    if (!szExcludeListServer) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    cchNTUserIni = MAX_PATH;
    szNTUserIni = (LPTSTR)LocalAlloc(LPTR, cchNTUserIni * sizeof(TCHAR));
    if (!szNTUserIni) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Out of memory")));
        goto Exit;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Failed to impersonate user")));
        // last error is set
        goto Exit;
    }

    //
    // Get the exclusion list from the server
    //

    szExcludeListServer[0] = TEXT('\0');

    hr = AppendName(szNTUserIni, cchNTUserIni, lpProfile->lpRoamingProfile, c_szNTUserIni, &lpEnd, &cchEnd);
    if (SUCCEEDED(hr))
    {
        GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                                 PROFILE_EXCLUSION_LIST,
                                 TEXT(""), szExcludeListServer,
                                 2*MAX_PATH,
                                 szNTUserIni);
    }

    //
    // Get the exclusion list from the cache
    //

    szExcludeListLocal[0] = TEXT('\0');

    hr = AppendName(szNTUserIni, cchNTUserIni, lpProfile->lpLocalProfile, c_szNTUserIni, &lpEnd, &cchEnd);
    if (SUCCEEDED(hr))
    {
        GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                                 PROFILE_EXCLUSION_LIST,
                                 TEXT(""), szExcludeListLocal,
                                 2*MAX_PATH,
                                 szNTUserIni);
    }

    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetExclusionList: Failed to revert to self")));
    }


    //
    // See if the lists are the same
    //

    if (!lstrcmpi (szExcludeListServer, szExcludeListLocal)) {

        if (szExcludeListServer[0] != TEXT('\0')) {

            cchExclusionList = lstrlen (szExcludeListServer) + 1;
            lpProfile->lpExclusionList = (LPTSTR)LocalAlloc (LPTR, cchExclusionList * sizeof(TCHAR));

            if (lpProfile->lpExclusionList) {
                StringCchCopy (lpProfile->lpExclusionList, cchExclusionList, szExcludeListServer);

                DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion lists on both server and client are the same.  The list is: <%s>"),
                         szExcludeListServer));
            } else {
                DebugMsg((DM_WARNING, TEXT("GetExclusionList:  Failed to allocate memory for exclusion list with error %d"),
                         GetLastError()));
            }
        } else {
            DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion on both server and client is empty.")));
        }

    } else {
        DebugMsg((DM_VERBOSE, TEXT("GetExclusionList:  The exclusion lists between server and client are different.  Server is <%s> and client is <%s>"),
                 szExcludeListServer, szExcludeListLocal));
    }

    bRetVal = TRUE;

Exit:

    if (szExcludeListLocal) {
        LocalFree(szExcludeListLocal);
    }

    if (szExcludeListServer) {
        LocalFree(szExcludeListServer);
    }

    if (szNTUserIni) {
        LocalFree(szNTUserIni);
    }

    return bRetVal;
}


//*************************************************************
//
//  RestoreUserProfile()
//
//  Purpose:    Downloads the user's profile if possible,
//              otherwise use either cached profile or
//              default profile.
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************

BOOL RestoreUserProfile(LPPROFILE lpProfile)
{
    BOOL  IsCentralReachable = FALSE;
    BOOL  IsLocalReachable = FALSE;
    BOOL  IsMandatory = FALSE;
    BOOL  IsProfilePathNULL = FALSE;
    BOOL  bCreateCentralProfile = FALSE;
    BOOL  bDefaultUsed = FALSE;
    BOOL  bCreateLocalProfile = TRUE;
    LPTSTR lpRoamingProfile = NULL;
    LPTSTR lpLocalProfile;
    BOOL  bProfileLoaded = FALSE;
    BOOL  bDefaultProfileIssued = FALSE;
    BOOL  bOwnerOK = TRUE;
    BOOL bNewUser = TRUE;
    LPTSTR SidString;
    LONG error = ERROR_SUCCESS;
    LPTSTR szProfile = NULL;
    LPTSTR szDefaultProfile = NULL;
    LPTSTR lpEnd;
    BOOL bRet;
    DWORD dwSize, dwFlags, dwErr=0, dwErr1;
    HANDLE hOldToken;
    LPTSTR szErr = NULL;
    DWORD cchProfile;
    UINT cchEnd;
    HRESULT hr;
 

    //
    // Get the error at the beginning of the call.
    //

    dwErr1 = GetLastError();

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Entering")));


    //
    // Get the Sid string for the current user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to get sid string for user")));
        return FALSE;
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    cchProfile = MAX_PATH;
    szProfile = (LPTSTR)LocalAlloc(LPTR, cchProfile*sizeof(TCHAR));
    if (!szProfile) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    szDefaultProfile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szDefaultProfile) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    szErr = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szErr) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Out of memory")));
        goto CleanUp;
    }

    //
    // Test if this user is a guest.
    //

    if (IsUserAGuest(lpProfile->hTokenUser)) {
        lpProfile->dwInternalFlags |= PROFILE_GUEST_USER;
        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  User is a Guest")));
    }

    //
    // Test if this user is an admin.
    //

    if (IsUserAnAdminMember(lpProfile->hTokenUser)) {
        lpProfile->dwInternalFlags |= PROFILE_ADMIN_USER;
        lpProfile->dwInternalFlags &= ~PROFILE_GUEST_USER;
        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  User is a Admin")));
    }

    //
    // Decide if the central profilemage is available.
    //

    IsCentralReachable = IsCentralProfileReachable(lpProfile,
                                                   &bCreateCentralProfile,
                                                   &IsMandatory,
                                                   &bOwnerOK);

    if (IsCentralReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is reachable")));

        if (IsMandatory) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is mandatory")));

        } else {
            lpProfile->dwInternalFlags |= PROFILE_UPDATE_CENTRAL;
            lpProfile->dwInternalFlags |= bCreateCentralProfile ? PROFILE_NEW_CENTRAL : 0;
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Central Profile is roaming")));

            if ((lpProfile->dwUserPreference == USERINFO_LOCAL) ||
                (lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) {
                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Ignoring central profile due to User Preference of Local only (or slow link).")));
                IsProfilePathNULL = TRUE;
                IsCentralReachable = FALSE;
                goto CheckLocal;
            }
        }

    } else {
        if (*lpProfile->lpRoamingProfile) {
            error = GetLastError();
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile: IsCentralProfileReachable returned FALSE. error = %d"),
                     error));

            if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
                dwErr = error;
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_MANDATORY_NOT_AVAILABLE_ERROR, GetErrString(error, szErr));
                goto Exit;

            } else if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_READONLY_NOT_AVAILABLE, GetErrString(error, szErr));
                *lpProfile->lpRoamingProfile = TEXT('\0');
            } else if (!bOwnerOK) {
                ReportError(lpProfile->hTokenUser, EVENT_ERROR_TYPE, 0, EVENT_LOGON_RUP_NOT_SECURE);
                *lpProfile->lpRoamingProfile = TEXT('\0');
            } else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_CENTRAL_NOT_AVAILABLE, GetErrString(error, szErr));
                *lpProfile->lpRoamingProfile = TEXT('\0');
            }
        }
    }

    //
    // do not create a new profile locally if there is a central profile and
    // it is not reachable and if we do not have slow link or user preferences set 
    // or read only profile.
    //

    if ((lpProfile->lpProfilePath) && (*lpProfile->lpProfilePath)) {
        if ((!IsCentralReachable) &&
            (lpProfile->dwUserPreference != USERINFO_LOCAL) && 
            (!(lpProfile->dwInternalFlags & PROFILE_SLOW_LINK)) &&
            (!(lpProfile->dwInternalFlags & PROFILE_READONLY)))

            bCreateLocalProfile = FALSE;
    }

    lpRoamingProfile = lpProfile->lpRoamingProfile;

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Profile path = <%s>"), lpRoamingProfile ? lpRoamingProfile : TEXT("")));
    if (!lpRoamingProfile || !(*lpRoamingProfile)) {
        IsProfilePathNULL = TRUE;
    }


CheckLocal:

    //
    // Determine if the local copy of the profilemage is available.
    //

    IsLocalReachable = GetExistingLocalProfileImage(lpProfile);

    if (IsLocalReachable) {
        DebugMsg((DM_VERBOSE, TEXT("Local Existing Profile Image is reachable")));

        //
        // If we assign a TEMP profile from previous session due to leak
        // then issue a error message
        //
 
        if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
        }

    } else {

        bNewUser = FALSE;
        if (bCreateLocalProfile)
        {
            bNewUser = CreateLocalProfileImage(lpProfile, lpProfile->lpUserName);
            if (!bNewUser) {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfileImage failed. Unable to create a new profile!")));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("Creating Local Profile")));
                IsLocalReachable = TRUE;
            }
        }

        if (!bNewUser) {

            if (lpProfile->dwFlags & PI_LITELOAD) {

                //
                // in lite load conditions we do not load a profile if it is not going to be cached on the machine.
                //

                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Profile not loaded because server is unavailable during liteload")));
                goto Exit;
            }

            //
            // if the user is not admin and is not allowed to create temp profile log him out.
            //

            if ((!(lpProfile->dwInternalFlags & PROFILE_ADMIN_USER)) && (!IsTempProfileAllowed())) {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because of no temp profile policy")));

                //
                // We have already lost the error returned from parseprofilepath. PATH_NOT_FOUND sounds quite close.
                // returning this.
                //

                dwErr = ERROR_PATH_NOT_FOUND;
                goto Exit;
            }

            if (!CreateLocalProfileImage(lpProfile, TEMP_PROFILE_NAME_BASE)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfileImage with TEMP failed with error %d.  Unable to issue temporary profile!"), dwErr));
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_TEMP_DIR_FAILED, GetErrString(dwErr, szErr));
                goto Exit;
            }
            else {
                lpProfile->dwInternalFlags |= PROFILE_TEMP_ASSIGNED;

                if (!bCreateLocalProfile)
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
                else {
                    //
                    // We have failed to create a local profile. So issue a proper error message.
                    //
                    ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED2);
                }
            }
        }

        // clear any partly loaded flag if it exists, since this is a new profile.
        lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;
        lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
    }


    lpLocalProfile = lpProfile->lpLocalProfile;

    DebugMsg((DM_VERBOSE, TEXT("Local profile name is <%s>"), lpLocalProfile));

    //
    // If we assign a TEMP profile from previous session due to leak
    // then do not reconcile RUP with TEMP profile
    //

    if ((lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) && IsCentralReachable) {
        IsCentralReachable = FALSE;
    }


    //
    // We can do a couple of quick checks here to filter out
    // new users.
    //

    if (( (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) &&
          (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL) ) ||
          (!IsCentralReachable &&
          (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL) )) {

       DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Working with a new user.  Go straight to issuing a default profile.")));
       goto IssueDefault;
    }


    //
    // If both central and local profileimages exist, reconcile them
    // and load.
    //

    if (IsCentralReachable && IsLocalReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Reconciling roaming profile with local profile")));

        GetExclusionList (lpProfile);


        //
        // Impersonate the user
        //

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            bProfileLoaded = FALSE;
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to impersonate user")));
            goto Exit;
        }


        //
        // Copy the profile
        //

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;


        //
        // if the roaming profile is empty and the local profile is
        // mandatory, treat the profile as mandatory.
        //
        // Same as Win2k
        //

        if ((lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) &&
            (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY)) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
        }


        //
        // This can possibly be a transition from mandatory to non mandatory.
        // In that case, since the local profile is mandatory
        // we wouldn't expect any items from here to be synced with the
        // server yet. Go for a full sync with server but the profile will
        // not be marked mandatory from now on.
        //

        if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
            (lpProfile->dwInternalFlags & PROFILE_READONLY)  ||
            (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY)) {
            dwFlags |= (CPD_COPYIFDIFFERENT | CPD_SYNCHRONIZE);
        }

        if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
            dwFlags |= CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
        }
        else
            dwFlags |= CPD_NONENCRYPTEDONLY;

        //
        // Profile unload time does not exist for mandatory, temp and read only profile.
        // But for read only profile we still want to use exclusion list without any ref time
        //

        if (lpProfile->lpExclusionList && *lpProfile->lpExclusionList) {
            if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                dwFlags |= CPD_USEEXCLUSIONLIST;
            }            
            else if (lpProfile->ftProfileUnload.dwHighDateTime || lpProfile->ftProfileUnload.dwLowDateTime) {
                dwFlags |= (CPD_USEDELREFTIME | CPD_SYNCHRONIZE | CPD_USEEXCLUSIONLIST);
            }
        }

        //
        // If roaming copy is partial (due to LITE upload) then ignore the hive and 
        // synchronize logic as it will end up deleting files from destination - a 
        // massive data loss.
        //

        if (IsPartialRoamingProfile(lpProfile)) {
            dwFlags &= ~CPD_SYNCHRONIZE;
            dwFlags |= CPD_IGNOREHIVE;
        }

        //
        // Check whether in local machine user profile is switching from local to 
        // roaming for first time. If yes and we have a existing hive in RUP share 
        // then always overwrite the local hive with hive in RUP share. This is 
        // to avoid wrong hive usage due to cached login
        //

        TouchLocalHive(lpProfile);

        bRet = CopyProfileDirectoryEx (lpRoamingProfile,
                                       lpLocalProfile,
                                       dwFlags, &lpProfile->ftProfileUnload,
                                       lpProfile->lpExclusionList);


        //
        // Revert to being 'ourself'
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to revert to self")));
        }


        if (!bRet) {
            error = GetLastError();
            if (error == ERROR_DISK_FULL) {
                dwErr = error;
                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  CopyProfileDirectory failed because of DISK_FULL, Exitting")));
                goto Exit;
            }

            if (error == ERROR_FILE_ENCRYPTED) {
                dwErr = error;
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
                // show the popup but exit only in the case if it is a new local profile

                if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
                    goto IssueDefault;
            }
            else {

                DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  CopyProfileDirectory failed.  Issuing default profile")));
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
                lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
                goto IssueDefault;
            }
        }

        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserMan, &lpEnd, &cchEnd);
        } else {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserDat, &lpEnd, &cchEnd);
        }

        if (SUCCEEDED(hr))
        {
            error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);
        }
        else
        {
            error = HRESULT_CODE(hr);
        }
        bProfileLoaded = (error == ERROR_SUCCESS);


        //
        // If we failed to load the central profile for some
        // reason, don't update it when we log off.
        //

        if (bProfileLoaded) {
            goto Exit;

        } else {
            dwErr = error;

            lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;
            lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;

            if (error == ERROR_BADDB) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
                goto IssueDefault;
            } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
                goto Exit;
            }
            else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_LOCAL, GetErrString(error, szErr));
                goto IssueDefault;
            }
        }
    }


    //
    // Only a local profile exists so use it.
    //

    if (!IsCentralReachable && IsLocalReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  No central profile.  Attempting to load local profile.")));

        //
        // If the central profile is unreachable and the local profile
        // is manatory, treat it as mandatory. This is the same as Win2k
        //
        // We are not copying anything from the server
        //

        if (lpProfile->dwInternalFlags & PROFILE_LOCALMANDATORY) {
            lpProfile->dwInternalFlags |= PROFILE_MANDATORY;
        }
        
        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserMan, &lpEnd, &cchEnd);
        } else {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserDat, &lpEnd, &cchEnd);
        }

        if (SUCCEEDED(hr))
        {
            error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);
        }
        else
        {
            error = HRESULT_CODE(hr);
        }
        bProfileLoaded = (error == ERROR_SUCCESS);

        if (!bProfileLoaded) {

            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  MyRegLoadKey returned FALSE.")));
            dwErr = error;

            if (error == ERROR_BADDB) {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
                lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
                goto IssueDefault;
            } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
                goto Exit;
            } else {
                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_LOCAL, GetErrString(error, szErr));
            }
        }

        if (!bProfileLoaded && IsProfilePathNULL) {
            DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Failed to load local profile and profile path is NULL, going to overwrite local profile")));
            lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
            goto IssueDefault;
        }
        goto Exit;
    }


    //
    // Last combination.  Unable to access a local profile cache,
    // but a central profile exists.  Use the temporary profile.
    //


    if (IsCentralReachable) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Using temporary cache with central profile")));

        GetExclusionList (lpProfile);

        //
        // Impersonate the user
        //


        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to impersonate user")));
            dwErr = GetLastError();
            goto Exit;
        }

        //
        // Local is not reachable. So Localmandatory will not be set..
        //

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_SYNCHRONIZE;

        if ((lpProfile->dwInternalFlags & PROFILE_MANDATORY) ||
            (lpProfile->dwInternalFlags & PROFILE_READONLY)) {
            dwFlags |= CPD_COPYIFDIFFERENT;
        }

        if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
            dwFlags |= CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
        }
        else
            dwFlags |= CPD_NONENCRYPTEDONLY;

        //
        // Profile unload time does not exist for mandatory, temp and read only profile.
        // But for read only profile we still want to use exclusion list without any ref time
        //

        if (lpProfile->lpExclusionList && *lpProfile->lpExclusionList) {
            if (lpProfile->dwInternalFlags & PROFILE_READONLY) {
                dwFlags |= CPD_USEEXCLUSIONLIST;
            }            
            else if (lpProfile->ftProfileUnload.dwHighDateTime || lpProfile->ftProfileUnload.dwLowDateTime) {
                dwFlags |= (CPD_USEDELREFTIME | CPD_SYNCHRONIZE | CPD_USEEXCLUSIONLIST);
            }
        }

        bRet = CopyProfileDirectoryEx (lpRoamingProfile,
                                       lpLocalProfile,
                                       dwFlags, &lpProfile->ftProfileUnload,
                                       lpProfile->lpExclusionList);


        //
        // Revert to being 'ourself'
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Failed to revert to self")));
        }


        //
        // Check return value
        //

        if (!bRet) {
            error = GetLastError();

            if (error == ERROR_FILE_ENCRYPTED) {
                dwErr = error;
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));

                ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_PROFILEUPDATE_6002);
                lpProfile->dwInternalFlags &= ~PROFILE_UPDATE_CENTRAL;

                // show the popup but exit only in the case if it is a new local profile
                if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
                    goto IssueDefault;

            }
            else {
                DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), error));
                goto Exit;
            }
        }

        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserMan, &lpEnd, &cchEnd);
        } else {
            hr = AppendName(szProfile, cchProfile, lpLocalProfile, c_szNTUserDat, &lpEnd, &cchEnd);
        }

        if (SUCCEEDED(hr))
        {
            error = MyRegLoadKey(HKEY_USERS, SidString, szProfile);
        }
        else
        {
            error = HRESULT_CODE(hr);
        }

        bProfileLoaded = (error == ERROR_SUCCESS);


        if (bProfileLoaded) {
            goto Exit;
        }

        SetLastError(error);
        dwErr = error;

        if (error == ERROR_BADDB) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
            // fall through
        } else if (error == ERROR_NO_SYSTEM_RESOURCES) {
            goto Exit;
        }

        //
        // we will delete the contents at this point
        //

        lpProfile->dwInternalFlags |= PROFILE_DELETE_CACHE;
    }


IssueDefault:

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Issuing default profile")));

    //
    // If a cache exists, delete it, since we will
    // generate a new one below.
    //

    if (lpProfile->dwInternalFlags & PROFILE_DELETE_CACHE) {
        DWORD dwDeleteFlags=0;

        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Deleting cached profile directory <%s>."), lpLocalProfile));

        lpProfile->dwInternalFlags &= ~PROFILE_DELETE_CACHE;


        if ((!(lpProfile->dwInternalFlags & PROFILE_ADMIN_USER)) && (!IsTempProfileAllowed())) {

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because of no temp profile policy and is not an admin")));

            //
            // We should have some error from a prev. operation. depending on that.
            //

            goto Exit;
        }


        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  User being logged off because the profile is mandatory")));

            //
            // We should have some error from a prev. operation. depending on that.
            //

            goto Exit;
        }


        //
        // backup only if we are not using a temp profile already.
        //

        if (!(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED))
            dwDeleteFlags |= DP_BACKUP | DP_BACKUPEXISTS;

        if ((dwDeleteFlags & DP_BACKUP) && (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {
            dwDeleteFlags = 0;
        }

        if (!DeleteProfileEx (SidString, lpLocalProfile, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  DeleteProfileDirectory returned false.  Error = %d"), dwErr));
            goto Exit;
        }
        else {
            if (dwDeleteFlags & DP_BACKUP) {
                lpProfile->dwInternalFlags |= PROFILE_BACKUP_EXISTS;
                ReportError(lpProfile->hTokenUser, PI_NOUI, 0, EVENT_PROFILE_DIR_BACKEDUP);
            }
        }

        if (lpProfile->dwFlags & PI_LITELOAD) {

            //
            // in lite load conditions we do not load a profile if it is not going to be cached on the machine.
            //

            // dwErr should be set before, use the same.

            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Profile not loaded because server is unavailable during liteload")));
            goto Exit;
        }


        //
        // Create a local profile to work with
        //

        if (!CreateLocalProfileImage(lpProfile, TEMP_PROFILE_NAME_BASE)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  CreateLocalProfile Image with TEMP failed.")));
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_TEMP_DIR_FAILED, GetErrString(dwErr, szErr));
            goto Exit;
        }
        else
        {
            lpProfile->dwInternalFlags |= PROFILE_TEMP_ASSIGNED;
            lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
            // clear any partly loaded flag if it exists, since this is a new profile.
            lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;

            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_TEMPPROFILEASSIGNED);
        }
    }


    //
    // If a default profile location was specified, try
    // that first.
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) )
    {
        CheckNetDefaultProfile (lpProfile);
    }


    if ( lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

          if (IssueDefaultProfile (lpProfile, lpProfile->lpDefaultProfile,
                                    lpLocalProfile, SidString,
                                    (lpProfile->dwInternalFlags & PROFILE_MANDATORY))) {

              DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Successfully setup the specified default.")));
              bProfileLoaded = TRUE;
              goto IssueDefaultExit;
          }

          DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  IssueDefaultProfile failed with specified default.")));
    }

    //
    // IssueLocalDefault
    //

    //
    // Issue the local default profile.
    //

    dwSize = MAX_PATH;
    if (!GetDefaultUserProfileDirectory(szDefaultProfile, &dwSize)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to get default user profile.")));
        goto Exit;
    }

    if (IssueDefaultProfile (lpProfile, szDefaultProfile,
                              lpLocalProfile, SidString,
                              (lpProfile->dwInternalFlags & PROFILE_MANDATORY))) {

        DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Successfully setup the local default.")));
        bProfileLoaded = TRUE;
        goto IssueDefaultExit;
    }

    DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  IssueDefaultProfile failed with local default.")));
    dwErr = GetLastError();

IssueDefaultExit:

    //
    // If the default profile was successfully issued, then
    // we need to set the security on the hive.
    //

    if (bProfileLoaded) {
        if (!SetupNewHive(lpProfile, SidString, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  SetupNewHive failed")));
            bProfileLoaded = FALSE;
        }
        else {
            bDefaultProfileIssued = TRUE;
        }

    }


Exit:

    //
    // If the profile was loaded, then save the profile type in the
    // user's hive, and setup the "User Shell Folders" section for
    // Explorer.
    //

    if (bProfileLoaded) {

        //
        // Open the Current User key.  This will be closed in
        // UnloadUserProfile.
        //

        error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_ALL_ACCESS,
                             &lpProfile->hKeyCurrentUser);

        if (error != ERROR_SUCCESS) {
            bProfileLoaded = FALSE;
            dwErr = error;
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to open current user key. Error = %d"), error));
        }

    }

    if ((bProfileLoaded) && (!(lpProfile->dwFlags & PI_LITELOAD))) {

        //
        // merge the subtrees to create the HKCR tree
        //

        error = LoadUserClasses( lpProfile, SidString, bDefaultProfileIssued );

        if (error != ERROR_SUCCESS) {
            bProfileLoaded = FALSE;
            dwErr = error;
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  Failed to merge classes root. Error = %d"), error));
        }
    }


    if ((!bProfileLoaded) && (!(lpProfile->dwFlags & PI_LITELOAD))) {

        error = dwErr;

        //
        // If the user is an Admin, then let him/her log on with
        // either the .default profile, or an empty profile.
        //

        if (lpProfile->dwInternalFlags & PROFILE_ADMIN_USER) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_ADMIN_OVERRIDE, GetErrString(error, szErr));

            bProfileLoaded = TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("RestoreUserProfile: Could not load the user profile. Error = %d"), error));
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 1, EVENT_FAILED_LOAD_PROFILE, GetErrString(error, szErr));

            if (lpProfile->hKeyCurrentUser) {
                RegCloseKey (lpProfile->hKeyCurrentUser);
            }

            MyRegUnLoadKey(HKEY_USERS, SidString);

            if ((lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {
                if (!DeleteProfileEx (SidString, lpLocalProfile, 0, HKEY_LOCAL_MACHINE, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("RestoreUserProfile:  DeleteProfileDirectory returned false.  Error = %d"), GetLastError()));
                }
            }
        }
    }


CleanUp:

    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  About to Leave.  Final Information follows:")));
    DebugMsg((DM_VERBOSE, TEXT("Profile was %s loaded."), bProfileLoaded ? TEXT("successfully") : TEXT("NOT successfully")));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->lpRoamingProfile = <%s>"), lpProfile->lpRoamingProfile));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->lpLocalProfile = <%s>"), lpProfile->lpLocalProfile));
    DebugMsg((DM_VERBOSE, TEXT("lpProfile->dwInternalFlags = 0x%x"), lpProfile->dwInternalFlags));


    //
    // Free up the user's sid string
    //

    DeleteSidString(SidString);

    if (szProfile) {
        LocalFree(szProfile);
    }

    if (szDefaultProfile) {
        LocalFree(szDefaultProfile);
    }

    if (szErr) {
        LocalFree(szErr);
    }

    if (bProfileLoaded) {
        if (!(lpProfile->dwFlags & PI_LITELOAD)) {
            // clear any partly loaded flag if it exists, since this is a new profile.
            lpProfile->dwInternalFlags &= ~PROFILE_PARTLY_LOADED;
        }
        else {
            if (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)
               lpProfile->dwInternalFlags |= PROFILE_PARTLY_LOADED;
        }
    }

    if (bProfileLoaded)
        SetLastError(dwErr1);
    else {

        //
        // Make sure that at least some error is returned.
        //

        if (!dwErr) {
            dwErr = ERROR_BAD_ENVIRONMENT;
        }
        SetLastError(dwErr);
    }

 
    DebugMsg((DM_VERBOSE, TEXT("RestoreUserProfile:  Leaving.")));

    return bProfileLoaded;
}


//***************************************************************************
//
//  GetProfileSidString
//
//  Purpose:    Allocates and returns a string representing the sid that we should
//              for the profiles
//
//  Parameters: hToken          -   user's token
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//              Tries to get the old sid that we used using the profile guid.
//              if it doesn't exist get the sid directly from the token
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetProfileSidString(HANDLE hToken)
{
    LPTSTR lpSidString;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG error;
    HKEY hSubKey;

    //
    // First, get the current user's sid and see if we have
    // profile information for them.
    //

    lpSidString = GetSidString(hToken);

    if (lpSidString) {

        GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), lpSidString);

        error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0,
                             KEY_READ, &hSubKey);

        if (error == ERROR_SUCCESS) {
           RegCloseKey(hSubKey);
           return lpSidString;
        }

        StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), c_szBAK);

        error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0,
                             KEY_READ, &hSubKey);

        if (ERROR_SUCCESS == error) {
           RegCloseKey(hSubKey);
           return lpSidString;
        }

        DeleteSidString(lpSidString);
    }


    //
    // Check for an old sid string
    //

    lpSidString = GetOldSidString(hToken, PROFILE_GUID_PATH);

    if (!lpSidString) {

        //
        // Last resort, use the user's current sid
        //

        DebugMsg((DM_VERBOSE, TEXT("GetProfileSid: No Guid -> Sid Mapping available")));
        lpSidString = GetSidString(hToken);
    }

    return lpSidString;
}


//*************************************************************
//
//  TestIfUserProfileLoaded()
//
//  Purpose:    Test to see if this user's profile is loaded.
//
//  Parameters: hToken          -   user's token
//              lpProfileInfo   -   Profile information from app
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL TestIfUserProfileLoaded(HANDLE hToken, LPPROFILEINFO lpProfileInfo)
{
    LPTSTR SidString;
    DWORD error;
    HKEY hSubKey;
    

    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("TestIfUserProfileLoaded:  Failed to get sid string for user")));
        return FALSE;
    }


    error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_ALL_ACCESS, &hSubKey);


    DeleteSidString(SidString);


    if (error == ERROR_SUCCESS) {

        DebugMsg((DM_VERBOSE, TEXT("TestIfUserProfileLoaded:  Profile already loaded.")));

        //
        // This key will be closed in before IUserProfile->LoadUserProfile
        // returns. It'll be reopened on the client side.
        //

        lpProfileInfo->hProfile = hSubKey;
    }

    
    SetLastError(error);
    return(error == ERROR_SUCCESS);
}


//*************************************************************
//
//  SecureUserKey()
//
//  Purpose:    Sets security on a key in the user's hive
//              so only admin's can change it.
//
//  Parameters: lpProfile       -   Profile Information
//              lpKey           -   Key to secure
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL SecureUserKey(LPPROFILE lpProfile, LPTSTR lpKey, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex, dwDisp;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;
    DWORD dwFlags = 0;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureUserKey:  Entering")));


    //
    // Create the security descriptor
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
        dwFlags = PI_NOUI;
    } else {
        psidUser = GetUserSid(lpProfile->hTokenUser);
        dwFlags = lpProfile->dwFlags;
    }

    if (!psidUser) {
        DebugMsg((DM_WARNING, TEXT("SecureUserKey:  Failed to get user sid")));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize restricted sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2 * GetLengthSid (psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("SecureUserKey: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegCreateKeyEx(HKEY_USERS,
                         lpKey,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         NULL,
                         &RootKey,
                         &dwDisp);

    if (Error != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SecureUserKey: Failed to open root of user registry, error = %d"), Error));

    } else {

        //
        // Set the security descriptor on the key
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;

        } else {

            DebugMsg((DM_WARNING, TEXT("SecureUserKey:  Failed to apply security to registry key, error = %d"), Error));
            SetLastError(Error);
        }

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureUserKey:  Leaving with a return value of %d"), bRetVal));


    return(bRetVal);

}


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error, IgnoreError;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = (LPTSTR)GlobalAlloc (GPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        DebugMsg((DM_WARNING, TEXT("ApplySecurityToRegistryTree:  Failed to allocate memory, error = %d"), GetLastError()));
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

                DebugMsg((DM_WARNING, TEXT("ApplySecurityToRegistryTree:  Registry enumeration failed with error = %d"), Error));
            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}


//*************************************************************
//
//  SetDefaultUserHiveSecurity()
//
//  Purpose:    Initializes a user hive with the
//              appropriate acls
//
//  Parameters: lpProfile       -   Profile Information
//              pSid            -   Sid (used by CreateNewUser)
//              RootKey         -   registry handle to hive root
//
//  Return:     ERROR_SUCCESS if successful
//              other error code  if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created as part of
//                                       SetupNewHive
//              3/29/98     adamed     Moved out of SetupNewHive
//                                       to this function
//
//*************************************************************

BOOL SetDefaultUserHiveSecurity(LPPROFILE lpProfile, PSID pSid, HKEY RootKey)
{
    DWORD Error;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;
    DWORD dwFlags = 0;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity:  Entering")));


    //
    // Create the security descriptor that will be applied to each key
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
        dwFlags = PI_NOUI;
    } else {
        psidUser = GetUserSid(lpProfile->hTokenUser);
        dwFlags = lpProfile->dwFlags;
    }

    if (!psidUser) {
        DebugMsg((DM_WARNING, TEXT("SetDefaultUserHiveSecurity:  Failed to get user sid")));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize system sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize admin sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }

    //
    // Get the Restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize restricted sid.  Error = %d"),
                   GetLastError()));
         goto Exit;
    }



    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2*GetLengthSid(psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for Restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to add ace for restricted.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("SetDefaultUserHiveSecurity: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Set the security descriptor on the entire tree
    //

    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (ERROR_SUCCESS == Error) {
        bRetVal = TRUE;
    }
    else
        SetLastError(Error);

Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


//*************************************************************
//
//  SetupNewHive()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpProfile       -   Profile Information
//              lpSidString     -   Sid string
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL SetupNewHive(LPPROFILE lpProfile, LPTSTR lpSidString, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    BOOL bRetVal = FALSE;
    DWORD dwFlags = 0;
    TCHAR szErr[MAX_PATH];


    //
    // Verbose Output
    //

    if ((!lpProfile && !pSid) || !lpSidString) {
        DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Invalid parameter")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Entering")));


    if (pSid) {
        dwFlags = PI_NOUI;
    } else {
        dwFlags = lpProfile->dwFlags;
    }

    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpSidString,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to open root of user registry, error = %d"), Error));

    } else {

        //
        // First Secure the entire hive -- use security that
        // will be sufficient for most of the hive.
        // After this, we can add special settings to special
        // sections of this hive.
        //

        if (SetDefaultUserHiveSecurity(lpProfile, pSid, RootKey)) {

            TCHAR szSubKey[MAX_PATH];
            HRESULT hr;

            //
            // Change the security on certain keys in the user's registry
            // so that only Admin's and the OS have write access.
            //

            hr = AppendName(szSubKey, ARRAYSIZE(szSubKey), lpSidString, WINDOWS_POLICIES_KEY, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                if (!SecureUserKey(lpProfile, szSubKey, pSid)) {
                    DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to secure windows policies key")));
                }
            }
            
            hr = AppendName(szSubKey, ARRAYSIZE(szSubKey), lpSidString, ROOT_POLICIES_KEY, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                if (!SecureUserKey(lpProfile, szSubKey, pSid)) {
                    DebugMsg((DM_WARNING, TEXT("SetupNewHive: Failed to secure root policies key")));
                }
            }

            bRetVal = TRUE;

        } else {
            Error = GetLastError();
            DebugMsg((DM_WARNING, TEXT("SetupNewHive:  Failed to apply security to user registry tree, error = %d"), Error));
            ReportError(lpProfile->hTokenUser, dwFlags, 1, EVENT_SECURITY_FAILED, GetErrString(Error, szErr));
        }

        RegFlushKey (RootKey);

        IgnoreError = RegCloseKey(RootKey);
        if (IgnoreError != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SetupNewHive:  Failed to close reg key, error = %d"), IgnoreError));
        }
    }

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("SetupNewHive:  Leaving with a return value of %d"), bRetVal));

    if (!bRetVal)
        SetLastError(Error);
    return(bRetVal);

}


//*************************************************************
//
//  IsCentralProfileReachable()
//
//  Purpose:    Checks to see if the user can access the
//              central profile.
//
//  Parameters: lpProfile             - User's token
//              bCreateCentralProfile - Should the central profile be created
//              bMandatory            - Is this a mandatory profile
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//
//*************************************************************

BOOL IsCentralProfileReachable(LPPROFILE lpProfile, BOOL *bCreateCentralProfile,
                               BOOL *bMandatory, BOOL* bOwnerOK)
{
    HANDLE  hFile;
    TCHAR   szProfile[MAX_PATH];
    LPTSTR  lpProfilePath, lpEnd;
    BOOL    bRetVal = FALSE;
    DWORD   dwError;
    HANDLE  hOldToken;
    UINT    cchEnd;
    HRESULT hr;

    dwError = GetLastError();

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Entering")));


    //
    // Setup default values
    //

    *bMandatory = FALSE;
    *bCreateCentralProfile = FALSE;
    *bOwnerOK = TRUE;


    //
    // Check parameters
    //

    if (lpProfile->lpRoamingProfile[0] == TEXT('\0')) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Null path.  Leaving")));
        return FALSE;
    }


    lpProfilePath = lpProfile->lpRoamingProfile;


    //
    // Make sure we don't overrun our temporary buffer
    //

    if ((lstrlen(lpProfilePath) + 2 + lstrlen(c_szNTUserMan)) > MAX_PATH) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Failed because temporary buffer is too small.")));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }


    //
    // Copy the profile path to a temporary buffer
    // we can munge it.
    //

    StringCchCopy (szProfile, ARRAYSIZE(szProfile), lpProfilePath);


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Failed to impersonate user")));
        return FALSE;
    }

    //
    //  Check ownership of the profile
    //

    hr = CheckRoamingShareOwnership(szProfile, lpProfile->hTokenUser);
    
    if (FAILED(hr))
    {
        //
        //  Only set the bOwnerOK to false when we encountered the invalid owner error, 
        //  this would allow us to discover other reasons for failure
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_OWNER))
            *bOwnerOK = FALSE;
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Ownership check failed with %08X"), hr));
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }

    //
    // Add the slash if appropriate and then tack on
    // ntuser.man.
    //

    lpEnd = CheckSlashEx(szProfile, ARRAYSIZE(szProfile), &cchEnd);
    StringCchCopy(lpEnd, cchEnd, c_szNTUserMan);

    //
    // See if this file exists
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Testing <%s>"), szProfile));

    hFile = CreateFile(szProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Found a mandatory profile.")));
        CloseHandle(hFile);
        *bMandatory = TRUE;
        bRetVal = TRUE;
        goto Exit;
    }


    dwError = GetLastError();
    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Profile is not reachable, error = %d"),
                          dwError));


    //
    // If we received an error other than file not
    // found, bail now because we won't be able to
    // access this location.
    //

    if (dwError != ERROR_FILE_NOT_FOUND) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable:  Profile path <%s> is not reachable, error = %d"),
                                        szProfile, dwError));
        goto Exit;
    }


    //
    // Now try ntuser.dat
    //

    StringCchCopy(lpEnd, cchEnd, c_szNTUserDat);


    //
    // See if this file exists.
    //

    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Testing <%s>"), szProfile));

    hFile = CreateFile(szProfile, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Found a user profile.")));
        CloseHandle(hFile);
        bRetVal = TRUE;
        goto Exit;
    }


    dwError = GetLastError();
    DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Profile is not reachable, error = %d"),
                          dwError));

    //
    // If file not found than central profile is empty. For read
    // only profile ignore the empty central profile.
    //

    if ((dwError == ERROR_FILE_NOT_FOUND) && !(lpProfile->dwInternalFlags & PROFILE_READONLY)) {
        DebugMsg((DM_VERBOSE, TEXT("IsCentralProfileReachable:  Ok to create a user profile.")));
        *bCreateCentralProfile = TRUE;
        bRetVal = TRUE;
        goto Exit;
    }


    DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable:  Profile path <%s> is not reachable(2), error = %d"),
                                    szProfile, dwError));

Exit:


    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IsCentralProfileReachable: Failed to revert to self")));
    }

    return bRetVal;
}


//*************************************************************
//
//  MyRegLoadKey()
//
//  Purpose:    Loads a hive into the registry
//
//  Parameters: hKey        -   Key to load the hive into
//              lpSubKey    -   Subkey name
//              lpFile      -   hive filename
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN WasEnabled;
    int error;
    TCHAR szErr[MAX_PATH];
    BOOL bAdjustPriv = FALSE;
    HANDLE hToken = NULL;
    

    //
    // Check to see if we are impersonating.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
        bAdjustPriv = TRUE;
    }
    else {
        CloseHandle(hToken);
    }

    //
    // Enable the restore privilege
    //

    if(bAdjustPriv) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    }

    if (NT_SUCCESS(Status)) {

        error = RegLoadKey(hKey, lpSubKey, lpFile);

        //
        // Restore the privilege to its previous state
        //

        if(bAdjustPriv) {
            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to restore RESTORE privilege to previous enabled state")));
            }
        }


        //
        // Check if the hive was loaded
        //

        if (error != ERROR_SUCCESS) {
            ReportError(NULL, PI_NOUI, 2, EVENT_REGLOADKEYFAILED, GetErrString(error, szErr), lpFile);
            DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to load subkey <%s>, error =%d"), lpSubKey, error));
        }
#if defined(_WIN64)
        else {
            //
            // Notify Wow64 service that it need to watch this hive if it care to do so
            //
            if ( hKey == HKEY_USERS )
                Wow64RegNotifyLoadHiveUserSid ( lpSubKey );
        }
#endif

    } else {
        error = Status;
        DebugMsg((DM_WARNING, TEXT("MyRegLoadKey:  Failed to enable restore privilege to load registry key, err = %08x"), error));
    }

    DebugMsg((DM_VERBOSE, TEXT("MyRegLoadKey: Returning %08x"), error));

    return error;
}


//*************************************************************
//
//  MyRegUnLoadKey()
//
//  Purpose:    Unloads a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey)
{
    BOOL     bResult = TRUE;
    LONG     error;
    LONG     eTmp;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WasEnabled;
    HKEY     hSubKey;
    HANDLE   hToken = NULL;
    BOOL     bAdjustPriv = FALSE;
    

#if defined(_WIN64)
    //
    // Notify wow64 service to release any resources
    //

    if ( hKey == HKEY_USERS )
        Wow64RegNotifyUnloadHiveUserSid ( lpSubKey );
#endif

    //
    // Check to see if we are impersonating.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
        bAdjustPriv = TRUE;
    }
    else {
        CloseHandle(hToken);
    }

    //
    // Enable the restore privilege
    //

    if (bAdjustPriv) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    }

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        //
        // If the key didn't unload, check to see if it exists.
        // If the key doesn't exist, then it was probably cleaned up by
        // WatchHiveRefCount, but it certainly isn't loaded, so this
        // function should succeed.
        //

        if (error != ERROR_SUCCESS) {
            eTmp = RegOpenKeyEx(hKey, lpSubKey, 0, KEY_READ, &hSubKey);
            if (eTmp == ERROR_FILE_NOT_FOUND) {
                error = ERROR_SUCCESS;
            }
            else if (eTmp == ERROR_SUCCESS) {
                RegCloseKey( hSubKey );
            }
        }

        if ( error != ERROR_SUCCESS) {

            //
            // RegUnlodKey returns ERROR_WRITE_PROTECT if hive is already scheduled for unloading
            //

            if (error == ERROR_WRITE_PROTECT) {
                DebugMsg((DM_VERBOSE, TEXT("MyRegUnloadKey: user hive is already scheduled for unloading")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to unmount hive %08x"), error));
            }
            bResult = FALSE;
        }

        //
        // Restore the privilege to its previous state
        //

        if (bAdjustPriv) {
            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
        
            if (!NT_SUCCESS(Status)) {
                DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to restore RESTORE privilege to previous enabled state")));
            }
        }

    } else {
        DebugMsg((DM_WARNING, TEXT("MyRegUnLoadKey:  Failed to enable restore privilege to unload registry key")));
        error = Status;
        bResult = FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("MyRegUnLoadKey: Returning %d."), bResult));

    SetLastError(error);
    return bResult;
}

//*************************************************************
//
//  UpgradeLocalProfile()
//
//  Purpose:    Upgrades a local profile from a 3.x profile
//              to a profile directory structure.
//
//  Parameters: lpProfile       -   Profile Information
//              lpOldProfile    -   Previous profile file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/6/95      ericflo    Created
//
//*************************************************************

BOOL UpgradeLocalProfile (LPPROFILE lpProfile, LPTSTR lpOldProfile)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrcEnd, lpDestEnd;
    BOOL bRetVal = FALSE;
    DWORD dwSize, dwFlags;
    HANDLE hOldToken;
    DWORD dwErr;
    UINT cchEnd;
    HRESULT hr;

    dwErr = GetLastError();

    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeLocalProfile:  Entering")));


    //
    // Setup the temporary buffers
    //

    hr = StringCchCopy (szSrc, ARRAYSIZE(szSrc), lpOldProfile);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed copy lpOldProfile error = %d"), HRESULT_CODE(hr)));
        return FALSE;
    }
        
    hr = AppendName(szDest, ARRAYSIZE(szDest), lpProfile->lpLocalProfile, c_szNTUserDat, &lpDestEnd, &cchEnd);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed append name error = %d"), HRESULT_CODE(hr)));
        return FALSE;
    }


    //
    // Copy the hive
    //

    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: CopyFile failed to copy hive with error = %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Delete the old hive
    //

    DeleteFile (szSrc);



    //
    // Copy log file
    //

    hr = StringCchCat(szSrc, ARRAYSIZE(szSrc), c_szLog);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed cat .log to src, error = %d"), HRESULT_CODE(hr)));
        return FALSE;
    }
    
    hr = StringCchCat(szDest, ARRAYSIZE(szDest), c_szLog);
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed cat .log to dest, error = %d"), HRESULT_CODE(hr)));
        return FALSE;
    }


    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: CopyFile failed to copy hive log with error = %d"),
                 GetLastError()));
    }


    //
    // Delete the old hive log
    //

    DeleteFile (szSrc);


    //
    // Copy in the new shell folders from the default
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) ) {

        CheckNetDefaultProfile (lpProfile);
    }

    if (lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

        if (FAILED(SafeExpandEnvironmentStrings(lpProfile->lpDefaultProfile, szSrc, MAX_PATH)))
        {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to expand env string.")));
            goto IssueLocalDefault;
        }

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to impersonate user")));
            goto IssueLocalDefault;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        if (CopyProfileDirectoryEx (szSrc, lpProfile->lpLocalProfile,
                                    dwFlags,
                                    NULL, NULL)) {

            bRetVal = TRUE;
        }

        //
        // Go back to system security context
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to revert to self")));
        }

        if ((!bRetVal) && (GetLastError() == ERROR_DISK_FULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to Copy default profile. Disk is FULL")));
            goto Exit;
        }
    }


IssueLocalDefault:

    if (!bRetVal) {

        dwSize = ARRAYSIZE(szSrc);
        if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile:  Failed to get default user profile.")));
            goto Exit;
        }

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to impersonate user")));
            goto Exit;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        bRetVal = CopyProfileDirectoryEx (szSrc,
                                          lpProfile->lpLocalProfile,
                                          dwFlags,
                                          NULL, NULL);

        //
        // Go back to system security context
        //

        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to revert to self")));
        }
    }

    if (!bRetVal)
        dwErr = GetLastError();

Exit:

    SetLastError(dwErr);

    return bRetVal;
}


//*************************************************************
//
//  UpgradeCentralProfile()
//
//  Purpose:    Upgrades a central profile from a 3.x profile
//              to a profile directory structure.
//
//  Parameters: lpProfile       -   Profile Information
//              lpOldProfile    -   Previous profile file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/6/95      ericflo    Created
//
//*************************************************************

BOOL UpgradeCentralProfile (LPPROFILE lpProfile, LPTSTR lpOldProfile)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrcEnd, lpDestEnd, lpDot;
    BOOL bRetVal = FALSE;
    BOOL bMandatory = FALSE;
    DWORD dwSize, dwFlags;
    HANDLE hOldToken;
    DWORD dwErr;
    UINT cchEnd;
    HRESULT hr;

    dwErr = GetLastError();


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile:  Entering")));


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Setup the source buffer
    //

    hr = StringCchCopy (szSrc, ARRAYSIZE(szSrc), lpOldProfile);
    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: failed copy lpOldProfile, error = %d"), dwErr));
        goto Exit;
    }


    //
    // Determine the profile type
    //

    lpDot = szSrc + lstrlen(szSrc) - 4;

    if (*lpDot == TEXT('.')) {
        if (!lstrcmpi (lpDot, c_szMAN)) {
            bMandatory = TRUE;
        }
    }

    //
    // Setup the destination buffer
    //

    if (bMandatory) {
        hr = AppendName(szDest, ARRAYSIZE(szDest), lpProfile->lpRoamingProfile, c_szNTUserMan, &lpDestEnd, &cchEnd);
    } else {
        hr = AppendName(szDest, ARRAYSIZE(szDest), lpProfile->lpRoamingProfile, c_szNTUserDat, &lpDestEnd, &cchEnd);
    }
    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: failed append ntuser.* to dest, error = %d"), dwErr));
        goto Exit;
    }


    //
    // Copy the hive
    //

    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: CopyFile failed to copy hive with error = %d"),
                 GetLastError()));
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Source = <%s>"), szSrc));
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Destination = <%s>"), szDest));
        dwErr = GetLastError();
        goto Exit;
    }



    //
    // Copy log file
    //

    //lstrcpy (lpDot, c_szLog);  a bug??
    hr = StringCchCat(szSrc, ARRAYSIZE(szSrc), c_szLog);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed cat .log to src, error = %d"), HRESULT_CODE(hr)));
        goto Exit;
    }
    
    hr = StringCchCat(szDest, ARRAYSIZE(szDest), c_szLog);
    {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed cat .log to dest, error = %d"), HRESULT_CODE(hr)));
        goto Exit;
    }


    if (!CopyFile(szSrc, szDest, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: CopyFile failed to copy hive log with error = %d"),
                 GetLastError()));
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: Source = <%s>"), szSrc));
        DebugMsg((DM_VERBOSE, TEXT("UpgradeCentralProfile: Destination = <%s>"), szDest));

    }


    //
    // Copy in the new shell folders from the default
    //

    if ( !(lpProfile->dwInternalFlags & DEFAULT_NET_READY) ) {
        CheckNetDefaultProfile (lpProfile);
    }


    if (lpProfile->lpDefaultProfile && *lpProfile->lpDefaultProfile) {

        if (FAILED(SafeExpandEnvironmentStrings(lpProfile->lpDefaultProfile, szSrc, MAX_PATH)))
        {
            DebugMsg((DM_WARNING, TEXT("UpgradeLocalProfile: Failed to expand env string.")));
        }
        else
        {
            dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
            dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
            dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

            if (CopyProfileDirectoryEx (szSrc, lpProfile->lpRoamingProfile,
                                        dwFlags,
                                        NULL, NULL)) {

                bRetVal = TRUE;
            }
        }
    }


    if (!bRetVal) {

        dwSize = ARRAYSIZE(szSrc);
        if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile:  Failed to get default user profile.")));
            dwErr = GetLastError();
            goto Exit;
        }

        dwFlags = (lpProfile->dwFlags & PI_NOUI) ? CPD_NOERRORUI : 0;
        dwFlags |= CPD_IGNOREHIVE | CPD_CREATETITLE;
        dwFlags |= CPD_IGNOREENCRYPTEDFILES | CPD_IGNORELONGFILENAMES;

        bRetVal = CopyProfileDirectoryEx (szSrc,
                                          lpProfile->lpRoamingProfile,
                                          dwFlags,
                                          NULL, NULL);
    }

    if (!bRetVal)
        dwErr = GetLastError();


Exit:

    //
    // Go back to system security context
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("UpgradeCentralProfile: Failed to revert to self")));
    }


    return bRetVal;
}


//*************************************************************
//
//  CreateSecureDirectory()
//
//  Purpose:    Creates a secure directory that only the user,
//              admin, and system have access to in the normal case
//              and for only the user and system in the restricted case.
//
//
//  Parameters: lpProfile   -   Profile Information
//              lpDirectory -   Directory Name
//              pSid        -   Sid (used by CreateUserProfile)
//              fRestricted -   Flag to set restricted access.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//              9/30/98     ushaji     added fRestricted flag
//              7/18/00     santanuc   modified to avoid deadlock when Documents and Settings directory is encrypted
//
//*************************************************************

BOOL CreateSecureDirectory (LPPROFILE lpProfile, LPTSTR lpDirectory, PSID pSid, BOOL fRestricted)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Entering with <%s>"), lpDirectory));

 
    if (!lpProfile && !pSid) {

        //
        // Attempt to create the directory
        //

        if (CreateNestedDirectoryEx(lpDirectory, NULL, FALSE)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));
            bRetVal = TRUE;

        } else {

            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
        }

        goto Exit;
    }


    //
    // Get the SIDs we'll need for the DACL
    //

    if (pSid) {
        psidUser = pSid;
        bFreeSid = FALSE;
    } else {
        if((psidUser = GetUserSid(lpProfile->hTokenUser)) == NULL) {
            DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: GetUserSid returned NULL. error = %08x"), GetLastError()));
            goto Exit;
        }
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid only if Frestricted is off
    //

    if (!fRestricted)
    {
        if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("SetupNewHive: Failed to initialize admin sid.  Error = %d"), GetLastError()));
            goto Exit;
        }
    }


    //
    // Allocate space for the ACL
    //

    if (!fRestricted)
    {
        cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
                (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
                (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    }
    else
    {
        cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
                sizeof(ACL) +
                (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    }


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    if (!fRestricted)
    {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (!fRestricted)
    {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
            DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID*)&lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Attempt to create the directory
    //

    if (CreateNestedDirectoryEx(lpDirectory, &sa, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));
        bRetVal = TRUE;

    } else {

        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
    }



Exit:

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;

}


//*************************************************************
//
//  GetUserDomainName()
//
//  Purpose:    Gets the current user's domain name
//
//  Parameters: lpProfile        - Profile Information
//              lpDomainName     - Receives the user's domain name
//              lpDomainNameSize - Size of the lpDomainName buffer (truncates the name to this size)
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetUserDomainName (LPPROFILE lpProfile, LPTSTR lpDomainName, LPDWORD lpDomainNameSize)
{
    BOOL bResult = FALSE;
    LPTSTR lpTemp, lpDomain = NULL;
    HANDLE hOldToken;
    DWORD dwErr;
    TCHAR szErr[MAX_PATH];

    dwErr = GetLastError();


    //
    // if no lpProfile is passed e.g. in setup.c and so just ignore.
    //

    lpDomainName[0] = TEXT('\0');

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName: lpProfile structure is NULL, returning")));
        return FALSE;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName: Failed to impersonate user")));
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Get the username in NT4 format
    //

    lpDomain = MyGetUserNameEx (NameSamCompatible);

    RevertToUser(&hOldToken);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName:  MyGetUserNameEx failed for NT4 style name with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        ReportError (NULL, PI_NOUI, 1, EVENT_FAILED_USERNAME, GetErrString(dwErr, szErr));
        goto Exit;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserDomainName:  Failed to find slash in NT4 style name:  <%s>"),
                 lpDomain));
        dwErr = ERROR_INVALID_DATA;
        goto Exit;
    }

    *lpTemp = TEXT('\0');

    StringCchCopy (lpDomainName, *lpDomainNameSize, lpDomain);


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("GetUserDomainName: DomainName = <%s>"), lpDomainName));

    bResult = TRUE;

Exit:

    if (lpDomain) {
        LocalFree (lpDomain);
    }

    SetLastError(dwErr);

    return bResult;
}


//*************************************************************
//
//  ComputeLocalProfileName()
//
//  Purpose:    Constructs the pathname of the local profile
//              for this user.  It will attempt to create
//              a directory of the username, and then if
//              unsccessful it will try the username.xxx
//              where xxx is a three digit number
//
//  Parameters: lpProfile             -   Profile Information
//              lpUserName            -   UserName
//              lpProfileImage        -   Profile directory (unexpanded)
//              cchMaxProfileImage    -   lpProfileImage buffer size
//              lpExpProfileImage     -   Expanded directory
//              cchMaxExpProfileImage -   lpExpProfileImage buffer size
//              pSid                  -   User's sid
//              bWin9xUpg             -   Flag to say whether it is win9x upgrade
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   lpProfileImage should be initialized with the
//              root profile path and the trailing backslash.
//              if it is a win9x upgrade give back the user's dir and don't do
//              conflict resolution.
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL ComputeLocalProfileName (LPPROFILE lpProfile, LPCTSTR lpUserName,
                              LPTSTR lpProfileImage, DWORD  cchMaxProfileImage,
                              LPTSTR lpExpProfileImage, DWORD  cchMaxExpProfileImage,
                              PSID pSid, BOOL bWin9xUpg)
{
    int i = 0;
    TCHAR szNumber[5], lpUserDomain[50], szDomainName[50+3];
    LPTSTR lpEnd;
    BOOL bRetVal = FALSE;
    BOOL bResult;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    DWORD   dwDomainNamelen;
    DWORD dwErr;
    UINT cchEnd;
    HRESULT hr;

    //
    // Check buffer size
    //

    dwDomainNamelen = ARRAYSIZE(lpUserDomain);

    if ((DWORD)(lstrlen(lpProfileImage) + lstrlen(lpUserName) + dwDomainNamelen + 2 + 5 + 1) > cchMaxProfileImage) {
        DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: buffer too small")));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    //
    // Place the username onto the end of the profile image
    //

    lpEnd = CheckSlashEx (lpProfileImage, cchMaxProfileImage, &cchEnd);
    StringCchCopy (lpEnd, cchEnd, lpUserName);


    //
    // Expand the profile path
    //

    hr = SafeExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);
    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: expand env string failed.")));
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }



    //
    // Does this directory exist?
    //

    hFile = FindFirstFile (lpExpProfileImage, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // Attempt to create the directory, if it returns an error bail
        // CreateSecureDirectory does not return an error for already_exists
        // so this should be ok.
        //

        bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

        if (bResult) {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
            bRetVal = TRUE;
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
            bRetVal = FALSE;
        }
        goto Exit;

    } else {

        FindClose (hFile);
        if (bWin9xUpg) {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s> in win9xupg case"), lpExpProfileImage));
            bRetVal = TRUE;
            goto Exit;
        }
    }



    //
    // get the User Domain Name
    //

    if (!GetUserDomainName(lpProfile, lpUserDomain, &dwDomainNamelen)) {
        DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: Couldn't get the User Domain")));
        *lpUserDomain = TEXT('\0');
    }

    lpEnd = lpProfileImage + lstrlen(lpProfileImage);
    cchEnd = cchMaxProfileImage - lstrlen(lpProfileImage);

    //
    // Place the " (DomainName)" onto the end of the username
    //

    if ((*lpUserDomain) != TEXT('\0')) {
        TCHAR szFormat[30];

        LoadString (g_hDllInstance, IDS_PROFILEDOMAINNAME_FORMAT, szFormat,
                            ARRAYSIZE(szFormat));
        StringCchPrintf(szDomainName, ARRAYSIZE(szDomainName), szFormat, lpUserDomain);
        StringCchCopy(lpEnd, cchEnd, szDomainName);

        //
        // Expand the profile path
        //

        hr = SafeExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);
        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: expand env string failed.")));
            SetLastError(HRESULT_CODE(hr));
            goto Exit;
        }


        //
        // Does this directory exist?
        //

        hFile = FindFirstFile (lpExpProfileImage, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {

            //
            // Attempt to create the directory
            //

            bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

            if (bResult) {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
                bRetVal = TRUE;
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
                bRetVal = FALSE;
            }

            goto Exit;

        } else {

            FindClose (hFile);
        }
    }

    //
    // Failed to create the directory for some reason.
    // Now try username (DomanName).000, username (DomanName).001, etc
    //

    lpEnd = lpProfileImage + lstrlen(lpProfileImage);
    cchEnd = cchMaxProfileImage - lstrlen(lpProfileImage);

    for (i=0; i < 1000; i++) {

        //
        // Convert the number to a string and attach it.
        //

        StringCchPrintf (szNumber, ARRAYSIZE(szNumber), TEXT(".%.3d"), i);
        StringCchCopy (lpEnd, cchEnd, szNumber);


        //
        // Expand the profile path
        //

        hr = SafeExpandEnvironmentStrings(lpProfileImage, lpExpProfileImage, cchMaxExpProfileImage);
        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: expand env string failed.")));
            SetLastError(HRESULT_CODE(hr));
            goto Exit;
        }


        //
        // Does this directory exist?
        //

        hFile = FindFirstFile (lpExpProfileImage, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {

            //
            // Attempt to create the directory
            //

            bResult = CreateSecureDirectory(lpProfile, lpExpProfileImage, pSid, FALSE);

            if (bResult) {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: generated the profile directory <%s>"), lpExpProfileImage));
                bRetVal = TRUE;
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("ComputeLocalProfileName: trying to create dir <%s> returned %d"), lpExpProfileImage, GetLastError()));
                bRetVal = FALSE;
            }

            goto Exit;

        } else {

            FindClose (hFile);
        }
    }


    DebugMsg((DM_WARNING, TEXT("ComputeLocalProfileName: Could not generate a profile directory.  Error = %d"), GetLastError()));

Exit:

    if (bRetVal && lpProfile && (lpProfile->dwFlags & PI_HIDEPROFILE)) {
        SetFileAttributes(lpExpProfileImage, 
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM |
                          GetFileAttributes(lpExpProfileImage));
    }

    return bRetVal;
}


//*************************************************************
//
//  CreateLocalProfileKey()
//
//  Purpose:    Creates a registry key pointing at the user profile
//
//  Parameters: lpProfile   -   Profile information
//              phKey       -   Handle to registry key if successful
//              bKeyExists  -   TRUE if the registry key already existed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//              04/20/2002  mingzhu    Changed the logic of user preference key
//
//*************************************************************

BOOL CreateLocalProfileKey (LPPROFILE lpProfile, PHKEY phKey, BOOL *bKeyExists)
{
    HRESULT hr = E_FAIL;
    LONG    lResult;
    TCHAR   szLocalProfileKey[MAX_PATH];
    DWORD   dwDisposition;
    LPTSTR  lpSidString = NULL;

    //
    //  Create the subkey under ProfileList
    //
    
    lpSidString = GetSidString(lpProfile->hTokenUser);
    
    if (lpSidString == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  Failed to get sid string.")));
        hr = E_FAIL;
        goto Exit;
    }
    
    hr = GetProfileListKeyName(szLocalProfileKey, ARRAYSIZE(szLocalProfileKey), lpSidString);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  Failed to create the profile list key, hr = %08X."), hr));
        goto Exit;
    }

    lResult  = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szLocalProfileKey,
                              0,
                              0,
                              0,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              phKey,
                              &dwDisposition);
                              
    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  Failed to create the profile list key <%s>, error = %d."), szLocalProfileKey, lResult));
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    //
    //  Check if the key exists already
    //
    
    *bKeyExists = (BOOL)(dwDisposition & REG_OPENED_EXISTING_KEY);

    //
    // If the central profile is given, try to see what we should do for the Preference key
    //

    if ( lpProfile->lpProfilePath )
    {
        //
        //  For mandatory user, we should try to delete the preference key so that the user
        //  won't be able to change the value to skip their mandatory profile.
        //
        if (lpProfile->dwInternalFlags & PROFILE_MANDATORY)
        {
            lResult = RegDeleteKey(*phKey, PREFERENCE_KEYNAME);

            if (lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileKey:  user <%s> is mandatory, deleting Preference key succeeded!"), lpSidString));
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  user <%s> is mandatory, but deleting Preference key failed! Error = %d"), lpSidString, lResult));
            }
        }
        //
        //  For normal roaming user, if the Preference key does not exit, create it.
        //
        else
        {
            HKEY    hKeyPreference = NULL;
            BOOL    bSetPreference = TRUE;
            
            if (*bKeyExists)
            {
                lResult = RegOpenKeyEx(*phKey,
                                       PREFERENCE_KEYNAME,
                                       0,
                                       KEY_READ,
                                       &hKeyPreference);
                                       
                if (lResult == ERROR_SUCCESS)
                {
                    bSetPreference = FALSE;
                    RegCloseKey(hKeyPreference);
                }
            }

            if (bSetPreference)
            {
                DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileKey:  user <%s> is roaming, setting preference key"), lpSidString));

                hr = SetupPreferenceKey(lpSidString);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CreateLocalProfileKey:  SetupPreferenceKey Failed. hr = %08X"), hr));
                }
            }
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileKey:  user <%s> is local, not setting preference key"), lpSidString));
    }

    hr = S_OK;

Exit:
    if (lpSidString)
        DeleteSidString(lpSidString);

    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//*************************************************************
//
//  GetExistingLocalProfileImage()
//
//  Purpose:    opens the profileimagepath
//
//  Parameters: lpProfile            - Profile information
//
//  Return:     TRUE if the profile image is reachable
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//              9/26/98     ushaji     Modified
//
//*************************************************************
BOOL GetExistingLocalProfileImage(LPPROFILE lpProfile)
{
    HKEY hKey = NULL;
    BOOL bKeyExists;
    LPTSTR lpProfileImage = NULL;
    LPTSTR lpExpProfileImage = NULL;
    LPTSTR lpOldProfileImage = NULL;
    LPTSTR lpExpandedPath, lpEnd;
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    DWORD cb;
    DWORD err;
    DWORD dwType;
    DWORD dwSize;
    LONG lResult;
    DWORD dwInternalFlags = 0;
    BOOL bRetVal = FALSE;
    LPTSTR SidString;
    HANDLE hOldToken;
    HRESULT hr;
    UINT cchEnd;

    lpProfile->lpLocalProfile[0] = TEXT('\0');


    if (!PatchNewProfileIfRequired(lpProfile->hTokenUser)) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Patch Profile Image failed")));
        return FALSE;
    }

    if (!CreateLocalProfileKey(lpProfile, &hKey, &bKeyExists)) {
        return FALSE;   // not reachable and cannot keep a local copy
    }

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    lpProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    lpExpProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpExpProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    lpOldProfileImage = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!lpOldProfileImage) {
        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Out of memory")));
        goto Exit;
    }

    if (bKeyExists) {

        //
        // Check if the local profile image is valid.
        //

        DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found entry in profile list for existing local profile")));

        err = RegQueryValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0, &dwType,
            (LPBYTE)lpExpProfileImage, &cbExpProfileImage);
        if (err == ERROR_SUCCESS && cbExpProfileImage) {
            DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename = <%s>"), lpExpProfileImage));

            if (dwType == REG_EXPAND_SZ) {

                //
                // Expand the profile image filename
                //

                cb = sizeof(TCHAR)*MAX_PATH;
                lpExpandedPath = (LPTSTR)LocalAlloc(LPTR, cb);
                if (lpExpandedPath) {
                    hr = SafeExpandEnvironmentStrings(lpExpProfileImage, lpExpandedPath, MAX_PATH);
                    if (SUCCEEDED(hr))
                    {
                        StringCchCopy(lpExpProfileImage, MAX_PATH, lpExpandedPath);
                        LocalFree(lpExpandedPath);
                    }
                    else
                    {
                        LocalFree(lpExpandedPath);
                        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: failed to expand env string.")));
                        goto Exit;
                    }
                }

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Expanded local profile image filename = <%s>"), lpExpProfileImage));
            }


            //
            // Query for the internal flags
            //

            dwSize = sizeof(DWORD);
            err = RegQueryValueEx (hKey, PROFILE_STATE, NULL,
                &dwType, (LPBYTE) &dwInternalFlags, &dwSize);

            if (err != ERROR_SUCCESS) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query internal flags with error %d"), err));
            }


            //
            // if we do not have a fully loaded profile, mark it as new
            // if it was not called with Liteload
            //

            if (dwInternalFlags & PROFILE_PARTLY_LOADED) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  We do not have a fully loaded profile on this machine")));

                //
                // retain the partially loaded flag and remove it at the end of
                // restoreuserprofile..
                //

                lpProfile->dwInternalFlags |= PROFILE_PARTLY_LOADED;

                if (!(lpProfile->dwFlags & PI_LITELOAD)) {
                    DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Treating this profile as new")));
                    lpProfile->dwInternalFlags |= PROFILE_NEW_LOCAL;
                }
            }

            //
            // if due to leak we are getting the old TEMP profile then preserve 
            // the internal flag. This will allow to revert back to .bak profile
            // correctly when the leak is fixed. 
            //

            if (dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
                lpProfile->dwInternalFlags |= dwInternalFlags;
            }


            //
            //  Call FindFirst to see if we need to migrate this profile
            //

            hFile = FindFirstFile (lpExpProfileImage, &fd);

            if (hFile == INVALID_HANDLE_VALUE) {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename we got from our profile list doesn't exit.  Error = %d"), GetLastError()));
                bRetVal = FALSE;
                goto Exit;
            }

            FindClose(hFile);


            //
            // If this is a file, then we need to migrate it to
            // the new directory structure. (from a 3.5 machine)
            //

            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                StringCchCopy (lpOldProfileImage, MAX_PATH, lpExpProfileImage);

                if (CreateLocalProfileImage(lpProfile, lpProfile->lpUserName)) {
                    if (UpgradeLocalProfile (lpProfile, lpOldProfileImage))
                        bRetVal = TRUE;
                    else {
                        DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to upgrade 3.5 profiles")));
                        bRetVal = FALSE;
                    }
                }
                else {
                    DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to create a new profile to upgrade")));
                    bRetVal = FALSE;
                }
                goto Exit;
            }

            //
            // Test if a mandatory profile exists
            //
            lpEnd = CheckSlashEx (lpExpProfileImage, MAX_PATH, &cchEnd);
            if (!lpEnd)
            {
                DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to append slash")));
                goto Exit;
            }
            
            hr = StringCchCopy (lpEnd, cchEnd, c_szNTUserMan);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to append ntuser.man")));
                goto Exit;
            }

            //
            // Impersonate the user, before trying to access ntuser, ntuser.man
            // fail, if we can not access..
            //

            if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
                DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage: Failed to impersonate user")));
                bRetVal = FALSE;
                goto Exit;
            }

            if (GetFileAttributes(lpExpProfileImage) != -1) {

                //
                // This is just to tag that the local profile is a mandatory profile
                //

                lpProfile->dwInternalFlags |= PROFILE_LOCALMANDATORY;

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found local mandatory profile image file ok <%s>"),
                    lpExpProfileImage));

                *(lpEnd - 1) = TEXT('\0');
                StringCchCopy(lpProfile->lpLocalProfile, MAX_PATH, lpExpProfileImage);

                //
                // Since this profile was mandatory, treat it as if it has never
                // synced with the server.
                //

                lpProfile->ftProfileUnload.dwLowDateTime = 0;
                lpProfile->ftProfileUnload.dwHighDateTime = 0;

                RevertToUser(&hOldToken);

                bRetVal = TRUE;   // local copy is valid and reachable
                goto Exit; 
            } else {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  No local mandatory profile.  Error = %d"), GetLastError()));
            }


            //
            // Test if a normal profile exists
            //

            StringCchCopy (lpEnd, cchEnd, c_szNTUserDat);

            if (GetFileAttributes(lpExpProfileImage) != -1) {

                RevertToUser(&hOldToken);

                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Found local profile image file ok <%s>"),
                    lpExpProfileImage));

                *(lpEnd - 1) = TEXT('\0');
                StringCchCopy(lpProfile->lpLocalProfile, MAX_PATH, lpExpProfileImage);


                //
                // Read the time this profile was unloaded
                //

                dwSize = sizeof(lpProfile->ftProfileUnload.dwLowDateTime);

                lResult = RegQueryValueEx (hKey,
                    PROFILE_UNLOAD_TIME_LOW,
                    NULL,
                    &dwType,
                    (LPBYTE) &lpProfile->ftProfileUnload.dwLowDateTime,
                    &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    dwSize = sizeof(lpProfile->ftProfileUnload.dwHighDateTime);

                    lResult = RegQueryValueEx (hKey,
                        PROFILE_UNLOAD_TIME_HIGH,
                        NULL,
                        &dwType,
                        (LPBYTE) &lpProfile->ftProfileUnload.dwHighDateTime,
                        &dwSize);

                    if (lResult != ERROR_SUCCESS) {
                        DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query high profile unload time with error %d"), lResult));
                        lpProfile->ftProfileUnload.dwLowDateTime = 0;
                        lpProfile->ftProfileUnload.dwHighDateTime = 0;
                    }

                } else {
                    DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query low profile unload time with error %d"), lResult));
                    lpProfile->ftProfileUnload.dwLowDateTime = 0;
                    lpProfile->ftProfileUnload.dwHighDateTime = 0;
                }

                bRetVal = TRUE;  // local copy is valid and reachable
                goto Exit; 
            } else {
                DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Local profile image filename we got from our profile list doesn't exit.  <%s>  Error = %d"),
                    lpExpProfileImage, GetLastError()));
            }

            //
            // Revert to User before continuing
            //

            RevertToUser(&hOldToken);

        }
    }

Exit:

    if (lpProfileImage) {
        LocalFree(lpProfileImage);
    }

    if (lpExpProfileImage) {
        LocalFree(lpExpProfileImage);
    }

    if (lpOldProfileImage) {
        LocalFree(lpOldProfileImage);
    }

    if (hKey) {
        err = RegCloseKey(hKey);

        if (err != STATUS_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("GetExistingLocalProfileImage:  Failed to close registry key, error = %d"), err));
        }
    }

    return bRetVal;
}


//*************************************************************
//
//  CreateLocalProfileImage()
//
//  Purpose:    creates the profileimagepath
//
//  Parameters: lpProfile   -   Profile information
//              lpBaseName  -   Base Name from which profile dir name
//                              will be generated.
//
//  Return:     TRUE if the profile image is creatable
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Ported
//              9/26/98     ushaji     Modified
//
//*************************************************************
BOOL CreateLocalProfileImage(LPPROFILE lpProfile, LPTSTR lpBaseName)
{
    HKEY hKey;
    BOOL bKeyExists;
    TCHAR lpProfileImage[MAX_PATH];
    TCHAR lpExpProfileImage[MAX_PATH];
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    DWORD err;
    DWORD dwSize;
    PSID UserSid;
    BOOL bRetVal = FALSE;

    lpProfile->lpLocalProfile[0] = TEXT('\0');

    if (!CreateLocalProfileKey(lpProfile, &hKey, &bKeyExists)) {
        return FALSE;   // not reachable and cannot keep a local copy
    }

    //
    // No local copy found, try to create a new one.
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateLocalProfileImage:  One way or another we haven't got an existing local profile, try and create one")));

    dwSize = ARRAYSIZE(lpProfileImage);
    if (!GetProfilesDirectoryEx(lpProfileImage, &dwSize, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to get profile root directory.")));
        goto Exit;
    }

    if (ComputeLocalProfileName(lpProfile, lpBaseName,
        lpProfileImage, MAX_PATH,
        lpExpProfileImage, MAX_PATH, NULL, FALSE)) {


        //
        // Add this image file to our profile list for this user
        //

        err = RegSetValueEx(hKey,
            PROFILE_IMAGE_VALUE_NAME,
            0,
            REG_EXPAND_SZ,
            (LPBYTE)lpProfileImage,
            sizeof(TCHAR)*(lstrlen(lpProfileImage) + 1));

        if (err == ERROR_SUCCESS) {

            StringCchCopy(lpProfile->lpLocalProfile, MAX_PATH, lpExpProfileImage);

            //
            // Get the sid of the logged on user
            //

            UserSid = GetUserSid(lpProfile->hTokenUser);
            if (UserSid != NULL) {

                //
                // Store the user sid under the Sid key of the local profile
                //

                err = RegSetValueEx(hKey,
                    TEXT("Sid"),
                    0,
                    REG_BINARY,
                    (BYTE*)UserSid,
                    RtlLengthSid(UserSid));


                if (err != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to set 'sid' value of user in profile list, error = %d"), err));
                    SetLastError(err);
                }

                //
                // We're finished with the user sid
                //

                DeleteUserSid(UserSid);

                bRetVal = TRUE;

            } else {
                DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to get sid of logged on user, so unable to update profile list")));
                SetLastError(err);
            }
        } else {
            DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to update profile list for user with local profile image filename, error = %d"), err));
            SetLastError(err);
        }
    }


Exit:
    err = RegCloseKey(hKey);

    if (err != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CreateLocalProfileImage:  Failed to close registry key, error = %d"), err));
        SetLastError(err);
    }

    return bRetVal;
}


//*************************************************************
//
//  IssueDefaultProfile()
//
//  Purpose:    Issues the specified default profile to a user
//
//  Parameters: lpProfile         -   Profile Information
//              lpDefaultProfile  -   Default profile location
//              lpLocalProfile    -   Local profile location
//              lpSidString       -   User's sid
//              bMandatory        -   Issue mandatory profile
//
//  Return:     TRUE if profile was successfully setup
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

BOOL IssueDefaultProfile (LPPROFILE lpProfile, LPTSTR lpDefaultProfile,
                          LPTSTR lpLocalProfile, LPTSTR lpSidString,
                          BOOL bMandatory)
{
    LPTSTR lpEnd, lpTemp;
    TCHAR szProfile[MAX_PATH];
    TCHAR szTempProfile[MAX_PATH];
    BOOL bProfileLoaded = FALSE;
    WIN32_FIND_DATA fd;
    HANDLE hFile;
    LONG error;
    DWORD dwFlags;
    HANDLE hOldToken;
    UINT cchEnd;
    HRESULT hr;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Entering.  lpDefaultProfile = <%s> lpLocalProfile = <%s>"),
             lpDefaultProfile, lpLocalProfile));


    //
    // First expand the default profile
    //

    if (FAILED(SafeExpandEnvironmentStrings(lpDefaultProfile, szProfile, MAX_PATH))) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: ExpandEnvironmentStrings Failed with error %d"), GetLastError()));
        return FALSE;
    }

    //
    //  Make sure the overall path length for the hive file is less than MAX_PATH
    //

    if (lstrlen(szProfile) + lstrlen(c_szNTUserDat) + 2 > MAX_PATH ||
        lstrlen(lpLocalProfile) + lstrlen(c_szNTUserDat) + 2 > MAX_PATH)
    {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: path is too long!")));
        return FALSE;
    }

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Does the default profile directory exist?
    //

    hFile = FindFirstFile (szProfile, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Default profile <%s> does not exist."), szProfile));
        RevertToUser(&hOldToken);
        return FALSE;
    }

    FindClose(hFile);


    //
    // Copy profile to user profile
    //

    dwFlags = CPD_CREATETITLE | CPD_IGNORESECURITY | 
              CPD_IGNORELONGFILENAMES | CPD_IGNORECOPYERRORS;

    if (lpProfile->dwFlags & (PI_LITELOAD | PI_HIDEPROFILE)) {
        dwFlags |=  CPD_SYSTEMFILES | CPD_SYSTEMDIRSONLY;
    }
    else
        dwFlags |= CPD_IGNOREENCRYPTEDFILES;

    //
    // Call it with force copy unless there might be a partial profile locally
    //

    if (!(lpProfile->dwInternalFlags & PROFILE_PARTLY_LOADED)) {
        dwFlags |= CPD_FORCECOPY;
    }

    if (!CopyProfileDirectoryEx (szProfile, lpLocalProfile, dwFlags, NULL, NULL)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile:  CopyProfileDirectory returned FALSE.  Error = %d"), GetLastError()));
        RevertToUser(&hOldToken);
        return FALSE;
    }

    //
    // Rename the profile is a mandatory one was requested.
    //

    StringCchCopy (szProfile, ARRAYSIZE(szProfile), lpLocalProfile);
    lpEnd = CheckSlashEx (szProfile, ARRAYSIZE(szProfile), &cchEnd);

    if (bMandatory) {

        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Mandatory profile was requested.")));

        StringCchCopy (szTempProfile, ARRAYSIZE(szTempProfile), szProfile);
        StringCchCopy (lpEnd, cchEnd, c_szNTUserMan);

        hFile = FindFirstFile (szProfile, &fd);

        if (hFile != INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Mandatory profile already exists.")));
            FindClose(hFile);

        } else {
            DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Renaming ntuser.dat to ntuser.man")));

            lpTemp = CheckSlashEx(szTempProfile, ARRAYSIZE(szTempProfile), NULL);
            StringCchCat (szTempProfile, ARRAYSIZE(szTempProfile), c_szNTUserDat);

            if (!MoveFile(szTempProfile, szProfile)) {
                DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  MoveFile returned false.  Error = %d"), GetLastError()));
            }
        }

    } else {
        StringCchCopy (lpEnd, cchEnd, c_szNTUserDat);
    }

    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("IssueDefaultProfile: Failed to revert to self")));
    }


    //
    // Try to load the new profile
    //

    error = MyRegLoadKey(HKEY_USERS, lpSidString, szProfile);

    bProfileLoaded = (error == ERROR_SUCCESS);


    if (!bProfileLoaded) {
        DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  MyRegLoadKey failed with error %d"),
                 error));

        SetLastError(error);

        if (error == ERROR_BADDB) {
            ReportError(lpProfile->hTokenUser, lpProfile->dwFlags, 0, EVENT_FAILED_LOAD_1009);
        } 

        return FALSE;
    }


    DebugMsg((DM_VERBOSE, TEXT("IssueDefaultProfile:  Leaving successfully")));

    return TRUE;
}


//*************************************************************
//
//  DeleteProfileEx ()
//
//  Purpose:    Deletes the specified profile from the
//              registry and disk.
//
//  Parameters: lpSidString     -   Registry subkey
//              lpProfileDir    -   Profile directory
//              bBackup         -   Backup profile before deleting
//              szComputerName  -   Computer name. This parameter will be NULL 
//                                  for local computer.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//
//*************************************************************

BOOL DeleteProfileEx (LPCTSTR lpSidString, LPTSTR lpLocalProfile, DWORD dwDeleteFlags, HKEY hKeyLM, LPCTSTR szComputerName)
{
    LONG lResult;
    TCHAR szTemp[MAX_PATH];
    TCHAR szUserGuid[MAX_PATH], szBuffer[MAX_PATH];
    TCHAR szRegBackup[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize, dwErr;
    BOOL bRetVal=TRUE;
    LPTSTR lpEnd = NULL;
    BOOL bBackup;

    bBackup = dwDeleteFlags & DP_BACKUP;

    dwErr = GetLastError();

    //
    // Cleanup the registry first.
    // delete the guid only if we don't have a bak to keep track of
    //

    if (lpSidString && *lpSidString) {

       // 
       // If profile in use then do not delete it
       //

       if (IsProfileInUse(szComputerName, lpSidString)) {
           DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as it is still in use."), lpSidString));
           dwErr = ERROR_INVALID_PARAMETER;
           bRetVal = FALSE;
           goto Exit;
       }

       if (!(dwDeleteFlags & DP_BACKUPEXISTS)) {

            GetProfileListKeyName(szTemp, ARRAYSIZE(szTemp), (LPTSTR) lpSidString);

            //
            // get the user guid
            //

            lResult = RegOpenKeyEx(hKeyLM, szTemp, 0, KEY_READ, &hKey);

            if (lResult == ERROR_SUCCESS) {

                //
                // Query for the user guid
                //

                dwSize = MAX_PATH * sizeof(TCHAR);
                lResult = RegQueryValueEx (hKey, PROFILE_GUID, NULL, &dwType, (LPBYTE) szUserGuid, &dwSize);

                if (lResult != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to query profile guid with error %d"), lResult));
                }
                else {


                    StringCchCopy(szTemp, ARRAYSIZE(szTemp), PROFILE_GUID_PATH);
                    StringCchCat (szTemp, ARRAYSIZE(szTemp), TEXT("\\"));
                    StringCchCat (szTemp, ARRAYSIZE(szTemp), szUserGuid);

                    //
                    // Delete the profile guid from the guid list
                    //

                    lResult = RegDeleteKey(hKeyLM, szTemp);

                    if (lResult != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  failed to delete profile guid.  Error = %d"), lResult));
                    }
                }

                RegCloseKey(hKey);
            }
        }

        GetProfileListKeyName(szTemp, ARRAYSIZE(szTemp), (LPTSTR) lpSidString);

        if (bBackup) {

            StringCchCopy(szRegBackup, ARRAYSIZE(szRegBackup), szTemp);
            StringCchCat (szRegBackup, ARRAYSIZE(szRegBackup), c_szBAK);

            lResult = RegRenameKey(hKeyLM, szTemp, szRegBackup);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Unable to rename registry entry.  Error = %d"), lResult));
                dwErr = lResult;
                bRetVal = FALSE;
            }
        }
        else
        {
            //
            //  Delete Preference key first
            //

            LPTSTR  lpTempEnd;
            UINT    cchTempEnd;

            lpTempEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchTempEnd);
            StringCchCopy(lpTempEnd, cchTempEnd, PREFERENCE_KEYNAME);

            lResult = RegDeleteKey(hKeyLM, szTemp);

            if (lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND)
            {
                dwErr = lResult;
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Unable to delete registry entry <%s>.  Error = %d"), szTemp, dwErr));
                bRetVal = FALSE;
            }
            else
            {
                //
                //  Delete ProfileList\{Sid} key
                //

                *lpTempEnd = TEXT('\0');

                lResult = RegDeleteKey(hKeyLM, szTemp);

                if (lResult != ERROR_SUCCESS)
                {
                    dwErr = lResult;
                    DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Unable to delete registry entry <%s>.  Error = %d"), szTemp, dwErr));
                    bRetVal = FALSE;
                }
            }
        }
    }


    if (bBackup) {
        lResult = RegOpenKeyEx(hKeyLM, szRegBackup, 0, KEY_ALL_ACCESS, &hKey);

        if (lResult == ERROR_SUCCESS) {
            DWORD dwInternalFlags;

            dwSize = sizeof(DWORD);
            lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwInternalFlags, &dwSize);

            if (lResult == ERROR_SUCCESS) {

                dwInternalFlags |= PROFILE_THIS_IS_BAK;
                lResult = RegSetValueEx (hKey, PROFILE_STATE, 0, REG_DWORD,
                                 (LPBYTE) &dwInternalFlags, sizeof(dwInternalFlags));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to query profile internalflags  with error %d"), lResult));
            }


            RegCloseKey(hKey);
        }


    } else {

        if (!Delnode (lpLocalProfile)) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Delnode failed.  Error = %d"), GetLastError()));
            dwErr = GetLastError();
            bRetVal = FALSE;
        }
    }

    if (dwDeleteFlags & DP_DELBACKUP) {
        goto Exit;
        // don't delete any more stuff because the user actually might be logged in.
    }

    //
    // Delete the Group Policy per user stuff..
    //

    AppendName(szBuffer, ARRAYSIZE(szBuffer), GP_XXX_SID_PREFIX, lpSidString, NULL, NULL);

    if (RegDelnode (hKeyLM, szBuffer) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to delete the group policy key %s"), szBuffer));
    }

    AppendName(szBuffer, ARRAYSIZE(szBuffer), GP_EXTENSIONS_SID_PREFIX, lpSidString, NULL, NULL);

    if (RegDelnode (hKeyLM, szBuffer) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to delete the group policy extensions key %s"), szBuffer));
    }

    DeletePolicyState( lpSidString );

Exit:
    SetLastError(dwErr);
    return bRetVal;
}


//*************************************************************
//
//  UpgradeProfile()
//
//  Purpose:    Called after a profile is successfully loaded.
//              Stamps build number into the profile, and if
//              appropriate upgrades the per-user settings
//              that NT setup wants done.
//
//  Parameters: lpProfile   -   Profile Information
//              pEnv        -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/7/95     ericflo    Created
//
//*************************************************************

BOOL UpgradeProfile (LPPROFILE lpProfile, LPVOID pEnv)
{
    HKEY hKey;
    DWORD dwDisp, dwType, dwSize, dwBuildNumber;
    LONG lResult;
    BOOL bUpgrade = FALSE;
    BOOL bDoUserdiff = TRUE;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Entering")));


    //
    // Query for the build number
    //

    lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser, WINLOGON_KEY,
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("UpgradeProfile: Failed to open winlogon key. Error = %d"), lResult));
        return FALSE;
    }


    dwSize = sizeof(dwBuildNumber);
    lResult = RegQueryValueEx (hKey, PROFILE_BUILD_NUMBER,
                               NULL, &dwType, (LPBYTE)&dwBuildNumber,
                               &dwSize);

    if (lResult == ERROR_SUCCESS) {

        //
        // Found the build number.  If the profile build is greater,
        // we don't want to process the userdiff hive
        //

        if (dwBuildNumber >= g_dwBuildNumber) {
            DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Build numbers match")));
            bDoUserdiff = FALSE;
        }
    } else {

        dwBuildNumber = 0;
    }


    if (bDoUserdiff) {

        //
        // Set the build number
        //

        lResult = RegSetValueEx (hKey, PROFILE_BUILD_NUMBER, 0, REG_DWORD,
                                 (LPBYTE) &g_dwBuildNumber, sizeof(g_dwBuildNumber));

        if (lResult != ERROR_SUCCESS) {
           DebugMsg((DM_WARNING, TEXT("UpgradeProfile: Failed to set build number. Error = %d"), lResult));
        }
    }


    //
    // Close the registry key
    //

    RegCloseKey (hKey);



    if (bDoUserdiff) {

        //
        // Apply changes to user's hive that NT setup needs.
        //

        if (!ProcessUserDiff(lpProfile, dwBuildNumber, pEnv)) {
            DebugMsg((DM_WARNING, TEXT("UpgradeProfile: ProcessUserDiff failed")));
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("UpgradeProfile: Leaving Successfully")));

    return TRUE;

}

//*************************************************************
//
//  SetProfileTime()
//
//  Purpose:    Sets the timestamp on the remote profile and
//              local profile to be the same regardless of the
//              file system type being used.
//
//  Parameters: lpProfile        -   Profile Information
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/25/95     ericflo    Ported
//
//*************************************************************

BOOL SetProfileTime(LPPROFILE lpProfile)
{
    HANDLE hFileCentral;
    HANDLE hFileLocal;
    FILETIME ft;
    TCHAR szProfile[MAX_PATH];
    LPTSTR lpEnd;
    HANDLE hOldToken;
    HRESULT hr;


    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to impersonate user")));
        return FALSE;
    }


    //
    // Create the central filename
    //

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
        hr = AppendName(szProfile, ARRAYSIZE(szProfile), lpProfile->lpRoamingProfile, c_szNTUserMan, NULL, NULL);
    } else {
        hr = AppendName(szProfile, ARRAYSIZE(szProfile), lpProfile->lpRoamingProfile, c_szNTUserDat, NULL, NULL);
    }

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to append ntuser.* to roaming profile.")));
        RevertToUser(&hOldToken);
        return FALSE;
    }

    hFileCentral = CreateFile(szProfile,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFileCentral == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't open central profile <%s>, error = %d"),
                 szProfile, GetLastError()));
        if (!RevertToUser(&hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
        }
        return FALSE;

    } else {

        if (!GetFileTime(hFileCentral, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't get time of central profile, error = %d"), GetLastError()));
        }
    }

    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
    }


    //
    // Create the local filename
    //

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY) {
        hr = AppendName(szProfile, ARRAYSIZE(szProfile), lpProfile->lpLocalProfile, c_szNTUserMan, NULL, NULL);
    } else {
        hr = AppendName(szProfile, ARRAYSIZE(szProfile), lpProfile->lpLocalProfile, c_szNTUserDat, NULL, NULL);
    }

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to append ntuser.* to local profile.")));
        return FALSE;
    }

    hFileLocal = CreateFile(szProfile,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFileLocal == INVALID_HANDLE_VALUE) {

        DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't open local profile <%s>, error = %d"),
                 szProfile, GetLastError()));

    } else {

        if (!SetFileTime(hFileLocal, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime: couldn't set time on local profile, error = %d"), GetLastError()));
        }
        if (!GetFileTime(hFileLocal, NULL, NULL, &ft)) {
            DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't get time on local profile, error = %d"), GetLastError()));
        }
        CloseHandle(hFileLocal);
    }

    //
    // Reset time of central profile in case of discrepencies in
    // times of different file systems.
    //

    //
    // Impersonate the user
    //

    if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to impersonate user")));
        CloseHandle(hFileCentral);
        return FALSE;
    }


    //
    // Set the time on the central profile
    //

    if (!SetFileTime(hFileCentral, NULL, NULL, &ft)) {
         DebugMsg((DM_WARNING, TEXT("SetProfileTime:  couldn't set time on local profile, error = %d"), GetLastError()));
    }

    CloseHandle(hFileCentral);


    //
    // Revert to being 'ourself'
    //

    if (!RevertToUser(&hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("SetProfileTime: Failed to revert to self")));
    }

    return TRUE;
}


//*************************************************************
//
//  IsCacheDeleted()
//
//  Purpose:    Determines if the locally cached copy of the
//              roaming profile should be deleted.
//
//  Parameters: void
//
//  Return:     TRUE if local cache should be deleted
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/28/96     ericflo    Created
//
//*************************************************************

BOOL IsCacheDeleted (void)
{
    BOOL bRetVal = FALSE;
    DWORD dwSize, dwType;
    HKEY hKey;

    //
    // Open the winlogon registry key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      WINLOGON_KEY,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for the flag.
        //

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         DELETE_ROAMING_CACHE,
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }


    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      SYSTEM_POLICIES_KEY,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for the flag.
        //

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         DELETE_ROAMING_CACHE,
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }

    return bRetVal;
}


//*************************************************************
//
//  GetProfileType()
//
//  Purpose:    Finds out some characterstics of a loaded profile
//
//  Parameters: dwFlags   -   Returns the various profile flags
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments: should be called after impersonation.
//
//  History:    Date        Author     Comment
//              11/10/98    ushaji     Created
//
//*************************************************************

BOOL WINAPI GetProfileType(DWORD *dwFlags)
{
    LPTSTR SidString;
    DWORD error, dwErr;
    HKEY hSubKey;
    BOOL bRetVal = FALSE;
    LPPROFILE lpProfile = NULL;
    HANDLE hToken;

    if (!dwFlags) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *dwFlags = 0;

    dwErr = GetLastError();

    //
    // Get the token for the caller
    //

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            DebugMsg((DM_WARNING, TEXT("GetProfileType: Failed to get token with %d"), GetLastError()));
            return FALSE;
        }
    }

    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Failed to get sid string for user")));
        dwErr = GetLastError();
        goto Exit;
    }

    error = RegOpenKeyEx(HKEY_USERS, SidString, 0, KEY_READ, &hSubKey);

    if (error == ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("GetProfileType:  Profile already loaded.")));
        RegCloseKey(hSubKey);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Profile is not loaded.")));
        dwErr = error;
        goto Exit;
    }

    lpProfile = LoadProfileInfo(NULL, hToken, NULL);

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("GetProfileType:  Couldn't load Profile Information.")));
        dwErr = GetLastError();
        *dwFlags = 0;
        goto Exit;
    }

    if (lpProfile->dwInternalFlags & PROFILE_GUEST_USER)
        *dwFlags |= PT_TEMPORARY;

    if (lpProfile->dwInternalFlags & PROFILE_MANDATORY)
        *dwFlags |= PT_MANDATORY;

    // external API, retaining the mandatory flag
    if (lpProfile->dwInternalFlags & PROFILE_READONLY)
        *dwFlags |= PT_MANDATORY;

    if (((lpProfile->dwUserPreference != USERINFO_LOCAL)) &&
        ((lpProfile->dwInternalFlags & PROFILE_UPDATE_CENTRAL) ||
        (lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL))) {

        *dwFlags |= PT_ROAMING;

        if (IsCacheDeleted()) {
            DebugMsg((DM_VERBOSE, TEXT("GetProfileType:  Profile is to be deleted")));
            *dwFlags |= PT_TEMPORARY;
        }
    }


    if (lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED)
        *dwFlags |= PT_TEMPORARY;

    bRetVal = TRUE;

Exit:
    if (SidString)
        DeleteSidString(SidString);

    SetLastError(dwErr);

    if (lpProfile) {

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        LocalFree (lpProfile);
    }

    CloseHandle (hToken);

    if (bRetVal) {
        DebugMsg((DM_VERBOSE, TEXT("GetProfileType: ProfileFlags is %d"), *dwFlags));
    }

    return bRetVal;
}

//*************************************************************
//
//  HiveLeakBreak()
//
//  Purpose:    For debugging sometimes it is necessary to break at the point of failure,
//              this feature is turned on by setting a regsitry value.
//
//  Return:     Nothing
//
//  Comments:
//
//  History:    Date        Author     Comment
//*************************************************************

void HiveLeakBreak()
{
    BOOL    bBreakOnUnloadFailure = FALSE;
    HKEY    hKey;
    DWORD   dwSize, dwType;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bBreakOnUnloadFailure);
        RegQueryValueEx (hKey,
                         TEXT("BreakOnHiveUnloadFailure"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bBreakOnUnloadFailure,
                         &dwSize);

        RegCloseKey (hKey);
    }

    if (bBreakOnUnloadFailure)
        DebugBreak();
}

NTSTATUS GetProcessName(HANDLE pid, BYTE* pbImageName, ULONG cbImageName)
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    CLIENT_ID           ClientId;
    HANDLE              hProcess;

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ClientId.UniqueProcess = pid;
    ClientId.UniqueThread = NULL;
    
    status = NtOpenProcess(&hProcess,
                           PROCESS_QUERY_INFORMATION,
                           &ObjectAttributes,
                           &ClientId);

    if (NT_SUCCESS(status))
    {
        status = NtQueryInformationProcess(hProcess,
                                           ProcessImageFileName,
                                           pbImageName,
                                           cbImageName,
                                           NULL);
        NtClose(hProcess);
    }

    return status;
}


//*****************************************************************************
//
//  CProcInfo class
//
//  Purpose:    Process information class, it is used to retrieve the
//              information about the process that leaking a reg key.
//
//  Return:     
//
//  Comments:   We can simply use GetProcessName() to retieve a process name
//              given the process id. However, it requires DEBUG privilege which
//              we don't have. As a work around, we added the following class
//              and functions to retrieve all the process information on the
//              system, further more, we added the part that retrieve the 
//              services names hosted by each process to make the debug output
//              for the reg leak even more useful. See NT bug # 645644 for more
//              detail.
//
//  History:    Date        Author     Comment
//              08/20/2002  mingzhu    Created
//
//*****************************************************************************



class CProcInfo
{
private:

    const static int    MAX_NAME = 64;

private:

    DWORD       m_dwProcessId;
    TCHAR       m_szProcessName[MAX_NAME];
    LPTSTR      m_szServiceNames;

public:

    CProcInfo() : m_dwProcessId(0), m_szServiceNames(NULL)
    {
        m_szProcessName[0] = TEXT('\0');
    }

    ~CProcInfo()
    {
        if (m_szServiceNames)
            LocalFree(m_szServiceNames);
    }

    DWORD       ProcessId()     { return m_dwProcessId; }
    LPCTSTR     ProcessName()   { return m_szProcessName; }
    LPCTSTR     ServiceNames()  { return m_szServiceNames; }
    

    HRESULT SetProcessId(DWORD dwId)
    {
        m_dwProcessId = dwId;
        return S_OK;
    }
    
    HRESULT SetProcessName(LPCTSTR szName)
    {
        return StringCchCopy(m_szProcessName, ARRAYSIZE(m_szProcessName), szName);
    }
    
    HRESULT SetProcessName(PUNICODE_STRING pName)
    {
        return StringCchCopyN(m_szProcessName, 
                              ARRAYSIZE(m_szProcessName),
                              pName->Buffer,
                              pName->Length/2);
    }
    
    HRESULT SetServiceNames(LPCTSTR szNames)
    {
        HRESULT     hr = E_FAIL;
        size_t      cchNames = lstrlen(szNames) + 1;

        m_szServiceNames = (LPTSTR) LocalAlloc (LPTR, cchNames * sizeof(TCHAR));
        if (!m_szServiceNames)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;                                    
        }
                
        hr = StringCchCopy(m_szServiceNames, cchNames, szNames);

    Exit:
        return hr;
    }
};


//*****************************************************************************
//
//  GetServiceProcessInfo()
//
//  Purpose:    Getting a list of process information for Win32 services that
//              are running at the time of the function call and put the names
//              into the process info list 
//
//  Parameters: pProcList - an array of process info class 
//              nNumProcs - number of entries in the list
//
//  Return:     HRESULT
//
//  Comments:   We use this EnumServicesStatusEx() API to retieve the services
//              information and go through the process list to put the service
//              names into the data structure. Part of the code is from tlist
//              utility.
//              
//
//  History:    Date        Author     Comment
//              08/20/2002  mingzhu    Created
//
//*****************************************************************************

HRESULT GetServiceProcessInfo(CProcInfo* pProcList, DWORD nNumProcs)
{
    HRESULT                         hr = E_FAIL;
    SC_HANDLE                       hSCM = NULL;
    LPENUM_SERVICE_STATUS_PROCESS   pInfo = NULL;
    DWORD                           cbInfo = 4 * 1024;
    DWORD                           cbExtraNeeded = 0;
    DWORD                           dwNumServices = 0;
    DWORD                           dwResume = 0;
    DWORD                           dwErr;
    BOOL                            bRet;
    LPTSTR                          szNames = NULL;
    ULONG                           nProc = 0;
    const int                       MAX_SERVICE_NAMES = 1024;

    //
    //  Connect to the service controller.
    //

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    if (!hSCM)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("OpenSCManager failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

Retry:

    //
    //  Allocate the memory
    //

    pInfo = (LPENUM_SERVICE_STATUS_PROCESS) LocalAlloc (LPTR, cbInfo);

    if (!pInfo)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    //  Call the API to retieve the info
    //

    bRet = EnumServicesStatusEx(hSCM,
                                SC_ENUM_PROCESS_INFO,
                                SERVICE_WIN32,
                                SERVICE_ACTIVE,
                                (LPBYTE)pInfo,
                                cbInfo,
                                &cbExtraNeeded,
                                &dwNumServices,
                                &dwResume,
                                NULL);

    //
    //  Check the error code, if it fails because of a small buffer,
    //  adjust the buffer size and try again.
    //

    if (!bRet)
    {
        dwErr = GetLastError();

        if (dwErr != ERROR_MORE_DATA)
        {
            DebugMsg((DM_WARNING, TEXT("EnumServicesStatusEx failed, error = %d"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr); 
            goto Exit;
        }

        LocalFree(pInfo);
        pInfo = NULL;
        cbInfo += cbExtraNeeded;
        dwResume = 0;
        goto Retry;
    }

    //
    //  Locate memory to store service names 
    //
    
    szNames = (LPTSTR) LocalAlloc (LPTR, MAX_SERVICE_NAMES * sizeof(TCHAR));

    if (!szNames)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    //  For each process, search the services list and add its service names
    //
    
    for (nProc = 0; nProc < nNumProcs; nProc++)
    {
        szNames[0] = TEXT('\0');

        for (DWORD iSvc = 0; iSvc < dwNumServices; iSvc++)
        {
            if (pProcList[nProc].ProcessId() != pInfo[iSvc].ServiceStatusProcess.dwProcessId)
            {
                continue;
            }
            hr = StringCchCat(szNames, MAX_SERVICE_NAMES, TEXT(" "));
            if (FAILED(hr))
            {
                goto Exit;
            }
            hr = StringCchCat(szNames, MAX_SERVICE_NAMES, pInfo[iSvc].lpServiceName);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }

        if (szNames[0] != TEXT('\0'))
        {
            hr = pProcList[nProc].SetServiceNames(szNames);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }

        /*
        DebugMsg((DM_VERBOSE,
                  TEXT("Process(%4d,%16s) : %s"),
                  pProcList[nProc].ProcessId(),
                  pProcList[nProc].ProcessName(),
                  pProcList[nProc].ServiceNames() ? pProcList[nProc].ServiceNames() : TEXT("None") ));
        */

    }

    //
    //  Success, set the output parameter
    //
    
    hr = S_OK;

Exit:
    if (szNames)
        LocalFree(szNames);

    if (pInfo)
        LocalFree(pInfo);
        
    if (hSCM)
        CloseServiceHandle(hSCM);

    return hr;
}

//*****************************************************************************
//
//  GetProcessList()
//
//  Purpose:    Getting a list of all processes in the system along with the
//              services hosted by each of them. It will be used to dump the
//              information if the process is leaking a reg key.
//
//  Parameters: ppProcList  - returned array of process info class 
//              pdwNumProcs - returned number of entries in the list
//
//  Return:     HRESULT
//
//  Comments:   We use this NtQuerySystemInformation() API to retieve the 
//              process information. Note that the ppProcList is allocated
//              using C++ new operator, so please use "delete []" to free
//              the memory.
//
//  History:    Date        Author     Comment
//              08/20/2002  mingzhu    Created
//
//*****************************************************************************

HRESULT GetProcessList(CProcInfo** ppProcList, DWORD* pdwNumProcs)
{
    HRESULT                         hr = E_FAIL;
    BYTE*                           pbBuffer = NULL;
    ULONG                           cbBuffer = 16*1024;
    NTSTATUS                        status;
    PSYSTEM_PROCESS_INFORMATION     pProcessInfo;
    ULONG                           cbOffset;
    CProcInfo*                      pProcList = NULL;
    ULONG                           nNumProcs = 0;
    ULONG                           nProc = 0;

    //
    //  Set the output parameters
    //

    *ppProcList = NULL;
    *pdwNumProcs = 0;

Retry:

    //
    //  Allocate memory for the buffer
    //

    pbBuffer = (BYTE*) LocalAlloc (LPTR, cbBuffer);

    if (!pbBuffer)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    //  Call the API to retrieve process information
    //
    
    status = NtQuerySystemInformation(SystemProcessInformation,
                                      pbBuffer,
                                      cbBuffer,
                                      NULL);

    //
    //  Check the return value, if the buffer is too small, 
    //  relocate and try again.
    //
    
    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        cbBuffer += 4096;
        LocalFree(pbBuffer);
        pbBuffer = NULL;
        goto Retry;
    }

    //
    //  For other failure, just return
    //

    if (!NT_SUCCESS(status))                                                    
    {
        DebugMsg((DM_WARNING, TEXT("NtQuerySystemInformation failed, status = %08X"), status));
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));                                         
        goto Exit;                                                              
    }                                                                           


    //
    //  Type case the information
    //

    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;

    //
    //  Figure out how many processes are there
    //
    
    cbOffset = 0;
    nNumProcs = 1;

    while (TRUE)
    {
        //
        //  Check if we reach the end of task list
        //
        
        if (pProcessInfo->NextEntryOffset == 0)
        {
            break;
        }

        //
        //  Get the next entry
        //
        
        cbOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) (pbBuffer + cbOffset);
        nNumProcs ++;
    }

    //
    //  Allocate process list 
    //

    pProcList = new CProcInfo [nNumProcs];

    if (!pProcList)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Exit;
    }

    //
    //  Copy the process id and name to the process info list
    //

    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;
    cbOffset = 0;
    nProc = 0;

    while (TRUE)
    {
        if (pProcessInfo->ImageName.Buffer)
        {
            hr = pProcList[nProc].SetProcessName(&pProcessInfo->ImageName);
        }
        else
        {
            hr = pProcList[nProc].SetProcessName(TEXT("System Process"));
        }
        if (FAILED(hr))
        {
            goto Exit;
        }

        pProcList[nProc].SetProcessId((DWORD)(DWORD_PTR)pProcessInfo->UniqueProcessId);
       
        if (pProcessInfo->NextEntryOffset == 0)
        {
            break;
        }

        nProc ++;        
        cbOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) (pbBuffer + cbOffset);

    }

    //
    //  We're done with the buffer, release it
    //

    LocalFree(pbBuffer);
    pbBuffer = NULL;
    
    //
    //  Get the service names hosted by every process, even it fails, it's 
    //  not critical, we can still proceed.
    //  

    hr = GetServiceProcessInfo(pProcList, nNumProcs);
    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GetServiceProcessInfo failed, hr = %08X"), hr));
    }

    //
    //  Success, copy the return values
    //
    
    hr = S_OK;
    *ppProcList = pProcList;
    pProcList = NULL;
    *pdwNumProcs = nNumProcs;
    
Exit:
        
    if (pProcList)
        delete [] pProcList;

    if (pbBuffer)
        LocalFree(pbBuffer);

    return hr;
}



//*****************************************************************************
//
//  DumpOpenRegistryHandle()
//
//  Purpose:    Dumps the existing reg handle into the debugger
//
//  Parameters: lpKeyName -   The key name to the key in the form of
//                            \registry\user....
//
//  Return:     Nothing
//
//  Comments:
//
//  History:    Date        Author     Comment
//              06/25/2002  mingzhu    a new API call to NtQueryOpenKeyEx() is added.
//              08/20/2002  mingzhu    due to the DEBUG privilege, added several
//                                     functions to retrieve the process info
//
//*****************************************************************************

void DumpOpenRegistryHandle(LPTSTR lpkeyName)
{
    UNICODE_STRING                  UnicodeKeyName;
    OBJECT_ATTRIBUTES               KeyAttributes;
    NTSTATUS                        status;
    BYTE*                           pbBuffer = NULL;
    ULONG                           cbBuffer = 1024;
    ULONG                           cbRequired; 
    BOOLEAN                         bWasEnabled;
    BOOLEAN                         bEnabled = FALSE;
    PKEY_OPEN_SUBKEYS_INFORMATION   pOpenKeys;

    //
    // Initialize unicode string for our in params
    //
    RtlInitUnicodeString(&UnicodeKeyName, lpkeyName);

    //
    // Initialize the Object structure
    //
    InitializeObjectAttributes(&KeyAttributes,
                               &UnicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    //  Allocate the default size buffer to receive the opened key info
    //
    pbBuffer = (BYTE*) LocalAlloc (LPTR, cbBuffer);
    if (!pbBuffer)
    {
        DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: failed to allocate buffer, error = %d"), GetLastError()));
        goto Exit;
    }

    //
    //  Enable RESTORE privilege on the thread
    //
    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);
    if (!NT_SUCCESS(status))
    {
        DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: failed to enable RESTORE privilege, status = %08X"), status));
        goto Exit;
    }
    bEnabled = TRUE;

    //
    //  Call this special API to get the info
    //
    
    status = NtQueryOpenSubKeysEx(&KeyAttributes, cbBuffer, pbBuffer, &cbRequired);


    //
    //  If the buffer is too small, relocate it and call the API again.
    //
    
    if (status == STATUS_BUFFER_OVERFLOW)
    {
        LocalFree(pbBuffer);
        cbBuffer = cbRequired;
        pbBuffer = (BYTE*) LocalAlloc (LPTR, cbBuffer);
        if (!pbBuffer)
        {
            DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: failed to allocate buffer, error = %d"), GetLastError()));
            goto Exit;
        }
        status = NtQueryOpenSubKeysEx(&KeyAttributes, cbBuffer, pbBuffer, &cbRequired);
    }

    if (status != STATUS_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("NtQueryOpenSubKeysEx failed, status = %08X"), status));
        goto Exit;
    }

    //
    //  Casting the buffer to the data structure
    //
    pOpenKeys = (PKEY_OPEN_SUBKEYS_INFORMATION) pbBuffer;


    //
    //  Get the list of processes in the system
    //

    DWORD       nNumProcs = 0;
    CProcInfo*  pProcList = NULL;

    HRESULT hr = GetProcessList(&pProcList, &nNumProcs);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetProcessList failed, hr = %08X"), hr));
    }
    
    //
    //  Dumping information
    //
    
    DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: %d user registry handles leaked from %s"), pOpenKeys->Count, lpkeyName));
    
    for(ULONG nKey=0; nKey < pOpenKeys->Count; nKey++)
    {
        if (pProcList)
        {
            ULONG nProc;        
            for (nProc=0; nProc<nNumProcs; nProc++)
            {
                if (pProcList[nProc].ProcessId() == (DWORD)(DWORD_PTR) pOpenKeys->KeyArray[nKey].PID)
                    break;
            }

            DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: Process %d (%s) has opened key %.*s"),
                pOpenKeys->KeyArray[nKey].PID,
                nProc < nNumProcs ? pProcList[nProc].ProcessName() : TEXT("<Unknown>"),
                pOpenKeys->KeyArray[nKey].KeyName.Length/sizeof(WCHAR),
                pOpenKeys->KeyArray[nKey].KeyName.Buffer));   

            if (nProc < nNumProcs && pProcList[nProc].ServiceNames())
            {
                DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: Services in the process are : %s"), pProcList[nProc].ServiceNames()));
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: Process %d has opened key %.*s"),
                pOpenKeys->KeyArray[nKey].PID,
                pOpenKeys->KeyArray[nKey].KeyName.Length/sizeof(WCHAR),
                pOpenKeys->KeyArray[nKey].KeyName.Buffer));        
        }
    }


Exit:

    //
    //  Set the RESTORE privilege back to its original state
    //

    if (bEnabled && !bWasEnabled)
    {
        status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
        if (!NT_SUCCESS(status))
        {
            DebugMsg((DM_WARNING, TEXT("DumpOpenRegistryHandle: failed to set RESTORE privilege back, status = %08X"), status));
        }
    }

    if (pProcList)
        delete [] pProcList;
        
    if (pbBuffer)
        LocalFree(pbBuffer);

}


//*************************************************************
//
//  ExtractProfileFromBackup()
//
//  Purpose:  Extracts the profile from backup if required.
//
//  Parameters: hToken          -   User Token
//              SidString       -
//              dwBackupFlags   -   Backup Flags.
//                                  indicating that profile already exists.
//                                  Profile created from backup
//                                  0 indicates no such profile exists
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/21/99     ushaji     Created
//
//*************************************************************

#define EX_ALREADY_EXISTS   1
#define EX_PROFILE_CREATED  2

BOOL ExtractProfileFromBackup(HANDLE hToken, LPTSTR SidString, DWORD *dwBackupFlags)
{
    TCHAR LocalKey[MAX_PATH], *lpEnd, szLocalProfile;
    TCHAR LocalBackupKey[MAX_PATH];
    HKEY  hKey=NULL;
    DWORD dwType, dwSize;
    DWORD lResult;
    LPTSTR lpExpandedPath;
    DWORD cbExpProfileImage = sizeof(TCHAR)*MAX_PATH;
    TCHAR lpExpProfileImage[MAX_PATH];
    BOOL  bRetVal = TRUE;
    DWORD dwInternalFlags;
    DWORD cb;
    HRESULT hr;


    *dwBackupFlags = 0;

    GetProfileListKeyName(LocalKey, ARRAYSIZE(LocalKey), SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalKey, 0, KEY_ALL_ACCESS, &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL,
                               &dwType, (LPBYTE) &dwInternalFlags, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            //
            // if there is a sid key, check whether this is a temp profile
            //

            if (dwInternalFlags & PROFILE_TEMP_ASSIGNED) {
                DWORD dwDeleteFlags = 0;

                if (dwInternalFlags & PROFILE_BACKUP_EXISTS) {
                    dwDeleteFlags |= DP_BACKUPEXISTS;
                }


                //
                // We need the path to pass to DeleteProfile
                //

                lResult = RegQueryValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0, &dwType,
                                        (LPBYTE)lpExpProfileImage, &cbExpProfileImage);

                if (lResult == ERROR_SUCCESS && cbExpProfileImage) {
                    DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Local profile image filename = <%s>"), lpExpProfileImage));

                    if (dwType == REG_EXPAND_SZ) {

                        //
                        // Expand the profile image filename
                        //

                        cb = sizeof(lpExpProfileImage);
                        lpExpandedPath = (LPTSTR)LocalAlloc(LPTR, cb);
                        if (lpExpandedPath) {
                            hr = SafeExpandEnvironmentStrings(lpExpProfileImage, lpExpandedPath, ARRAYSIZE(lpExpProfileImage));
                            if (SUCCEEDED(hr))
                            {
                                StringCchCopy(lpExpProfileImage, ARRAYSIZE(lpExpProfileImage), lpExpandedPath);
                                LocalFree(lpExpandedPath);
                            }
                            else
                            {
                                DebugMsg((DM_WARNING, TEXT("ExtractProfileFromBackup:  failed to expand env string.  Error = %d"), HRESULT_CODE(hr)));
                                goto Exit;
                            }
                        }

                        DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Expanded local profile image filename = <%s>"), lpExpProfileImage));
                    }

                    if (!DeleteProfileEx (SidString, lpExpProfileImage, dwDeleteFlags, HKEY_LOCAL_MACHINE, NULL)) {
                        DebugMsg((DM_WARNING, TEXT("ExtractProfileFromBackup:  DeleteProfileDirectory returned false (2).  Error = %d"), GetLastError()));
                        lResult = GetLastError();
                        goto Exit;
                    }
                    else {
                        if (!(dwInternalFlags & PROFILE_BACKUP_EXISTS)) {
                            DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Temprorary profile but there is no backup")));
                            bRetVal = TRUE;
                            goto Exit;
                        }
                    }
                }
                else {
                    DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Couldn't get the local profile path")));
                    bRetVal = FALSE;
                    goto Exit;
                }
            }
            else {
                *dwBackupFlags |= EX_ALREADY_EXISTS;
                DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  A profile already exists")));
                goto Exit;
            }
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("GetExistingLocalProfileImage:  Failed to query internal flags with error %d"), lResult));
            bRetVal = FALSE;
            goto Exit;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }
    else {
       DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Failed to open key %s with error %d"), LocalKey, lResult));
    }


    //
    // Now try to get the profile from the backup
    //

    StringCchCopy(LocalBackupKey, ARRAYSIZE(LocalBackupKey), LocalKey);
    StringCchCat (LocalBackupKey, ARRAYSIZE(LocalBackupKey), c_szBAK);


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalBackupKey, 0, KEY_ALL_ACCESS, &hKey);

    if (lResult == ERROR_SUCCESS) {

        RegCloseKey(hKey);
        hKey = NULL;

        //
        // Check whether the key exists should already be done before this
        //

        lResult = RegRenameKey(HKEY_LOCAL_MACHINE, LocalBackupKey, LocalKey);
        if (lResult == ERROR_SUCCESS) {

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, LocalKey, 0, KEY_ALL_ACCESS, &hKey);

            if (lResult == ERROR_SUCCESS) {
                DWORD dwFlags;

                dwSize = sizeof(DWORD);
                lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwFlags, &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    dwFlags &= ~PROFILE_THIS_IS_BAK;
                    lResult = RegSetValueEx (hKey, PROFILE_STATE, 0, REG_DWORD,
                                             (LPBYTE) &dwFlags, sizeof(dwFlags));
                }

                RegCloseKey(hKey);
                hKey = NULL;
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfileEx:  Failed to open LocalKey with error %d"), lResult));
            }

            bRetVal = TRUE;
            *dwBackupFlags |= EX_PROFILE_CREATED;
            DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Profile created from Backup")));
            goto Exit;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("ExtractProfileFromBackup:  Couldn't rename key %s -> %s.  Error = %d"), LocalBackupKey, LocalKey, lResult));
            bRetVal = FALSE;
            goto Exit;
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("ExtractProfileFromBackup:  Couldn't open backup profile key.  Error = %d"), lResult));
    }

Exit:
    if (hKey)
        RegCloseKey(hKey);

    if (!bRetVal)
        SetLastError(lResult);

    return bRetVal;
}


//*************************************************************
//
//  PatchNewProfileIfRequired()
//
//  Purpose:  if the old sid and the new sid are not the same, delete the old
//             from the profile list and update the guidlist
//
//  Parameters: hToken   -   User Token
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/16/98    ushaji     Created
//
//*************************************************************
BOOL PatchNewProfileIfRequired(HANDLE hToken)
{
    TCHAR LocalOldProfileKey[MAX_PATH], LocalNewProfileKey[MAX_PATH], *lpEnd;
    HKEY  hNewKey=NULL;
    BOOL bRetVal = FALSE;
    DWORD dwType, dwDisp, dwSize;
    LONG lResult;
    LPTSTR OldSidString=NULL, SidString=NULL;
    PSID UserSid;
    DWORD dwBackupFlags;
    HMODULE hMsiLib = NULL;
    PFNMSINOTIFYSIDCHANGE pfnMsiNotifySidChange;

    //
    // Get the current sid.
    //

    SidString = GetSidString(hToken);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: No SidString found")));
        return FALSE;
    }

    if (ExtractProfileFromBackup(hToken, SidString, &dwBackupFlags)) {
        if ((dwBackupFlags & EX_ALREADY_EXISTS) || (dwBackupFlags & EX_PROFILE_CREATED)) {
            DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: A profile already exists with the current sid, exitting")));
            bRetVal = TRUE;
            goto Exit;
        }
    }
    else {

        //
        // Treat it as if no such profile exists
        //
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: ExtractProfileFromBackup returned error %d"), GetLastError()));
    }


    //
    // Get the old sid.
    //

    OldSidString = GetOldSidString(hToken, PROFILE_GUID_PATH);

    if (!OldSidString) {
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: No OldSidString found")));
        bRetVal = TRUE;
        goto Exit;
    }


    //
    // if old sid and new sid are the same quit
    //

    if (lstrcmpi(OldSidString, SidString) == 0) {
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: Old and the new sid are the same, exitting")));
        bRetVal = TRUE;
        goto Exit;
    }


    if (ExtractProfileFromBackup(hToken, OldSidString, &dwBackupFlags)) {
        if ((dwBackupFlags & EX_ALREADY_EXISTS) || (dwBackupFlags & EX_PROFILE_CREATED)) {
            DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: A profile with the old sid found")));
        }
    }
    else {

        //
        // Treat it as if no such profile exists
        //
        DebugMsg((DM_VERBOSE, TEXT("PatchNewProfileIfRequred: ExtractProfileFromBackup returned error %d"), GetLastError()));
    }

    GetProfileListKeyName(LocalNewProfileKey, ARRAYSIZE(LocalNewProfileKey), SidString);
    GetProfileListKeyName(LocalOldProfileKey, ARRAYSIZE(LocalOldProfileKey), OldSidString);

    lResult = RegRenameKey(HKEY_LOCAL_MACHINE, LocalOldProfileKey, LocalNewProfileKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to rename profile mapping key with error %d"), lResult));
        goto Exit;
    }


    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalNewProfileKey, 0, 0, 0,
                             KEY_WRITE, NULL, &hNewKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to open new profile mapping key with error %d"), lResult));
        goto Exit;
    }

    //
    // Get the sid of the logged on user
    //

    UserSid = GetUserSid(hToken);
    if (UserSid != NULL) {

        //
        // Store the user sid under the Sid key of the local profile
        //

        lResult = RegSetValueEx(hNewKey,
                    TEXT("Sid"),
                    0,
                    REG_BINARY,
                    (BYTE*)UserSid,
                    RtlLengthSid(UserSid));


        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred:  Failed to set 'sid' value of user in profile list, error = %d"), lResult));
        }

        //
        // We're finished with the user sid
        //

         DeleteUserSid(UserSid);
    }


    //
    // Set the guid->sid corresp.
    //

    if (!SetOldSidString(hToken, SidString, PROFILE_GUID_PATH)) {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: Couldn't set the old Sid in the GuidList")));
    }


    //
    // Make a call to msi lib to notify sid change of user, so that it can update installation information
    //

    hMsiLib = LoadLibrary(TEXT("msi.dll"));
    if (hMsiLib) {
        pfnMsiNotifySidChange = (PFNMSINOTIFYSIDCHANGE) GetProcAddress(hMsiLib,
#ifdef UNICODE
                                                                       "MsiNotifySidChangeW");
#else
                                                                       "MsiNotifySidChangeA");
#endif

        if (pfnMsiNotifySidChange) {
            (*pfnMsiNotifySidChange)(OldSidString, SidString);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: GetProcAddress returned failure. error %d"), GetLastError()));        
        }

        FreeLibrary(hMsiLib);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("PatchNewProfileIfRequred: LoadLibrary returned failure. error %d"), GetLastError()));
    }
        

    bRetVal = TRUE;

Exit:

    if (SidString)
        DeleteSidString(SidString);

    if (OldSidString)
        DeleteSidString(OldSidString);


    if (hNewKey)
        RegCloseKey(hNewKey);

    return bRetVal;
}

//*************************************************************
//
//  IncrementProfileRefCount()
//
//  Purpose:    Increments Profile Ref Count
//
//  Parameters: lpProfile   -   Profile Information
//              bInitilize  -   dwRef should be initialized
//
//  Return:     Ref Count
//
//  Comments:   This functions ref counts independent of ability
//              to load/unload the hive.
//
//  Caveat:
//              We have changed the machanism here to use ref counting
//              and not depend on unloadability of ntuser.dat. NT4
//              apps might have forgotten to unloaduserprofiles
//              and might still be working because the handle got
//              closed automatically when processes
//              exitted. This will be treated as an App Bug.
//
//
//  History:    Date        Author     Comment
//              1/12/99     ushaji     Created
//
//*************************************************************

DWORD IncrementProfileRefCount(LPPROFILE lpProfile, BOOL bInitialize)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp, dwRef=0;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to get sid string for user")));
        return 0;
    }


    //
    // Open the profile mapping
    //

    GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to open profile mapping key with error %d"), lResult));
        DeleteSidString(SidString);
        return 0;
    }

    //
    // Query for the profile ref count.
    //

    dwSize = sizeof(DWORD);

    if (!bInitialize) {
        lResult = RegQueryValueEx (hKey,
                                   PROFILE_REF_COUNT,
                                   0,
                                   &dwType,
                                   (LPBYTE) &dwRef,
                                   &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("IncrementProfileRefCount:  Failed to query profile reference count with error %d"), lResult));
        }
    }

    dwRef++;

    //
    // Set the profile Ref count
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwRef,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IncrementProfileRefCount:  Failed to save profile reference count with error %d"), lResult));
    }


    DeleteSidString(SidString);

    RegCloseKey (hKey);

    return dwRef;

}

//*************************************************************
//
//  DecrementProfileRefCount()
//
//  Purpose:    Deccrements Profile Ref Count
//
//  Parameters: lpProfile   -   Profile Information
//
//  Return:     Ref Count
//
//  Comments:   This functions ref counts independent of ability
//              to load/unload the hive.
//
//  History:    Date        Author     Comment
//              1/12/99     ushaji     Created
//
//*************************************************************

DWORD DecrementProfileRefCount(LPPROFILE lpProfile)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp, dwRef=0;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to get sid string for user")));
        return 0;
    }


    //
    // Open the profile mapping
    //

    GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to open profile mapping key with error %d"), lResult));
        DeleteSidString(SidString);
        return 0;
    }

    //
    // Query for the profile ref count.
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            &dwType,
                            (LPBYTE) &dwRef,
                            &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("DecrementProfileRefCount:  Failed to query profile reference count with error %d"), lResult));
    }


    if (dwRef) {
        dwRef--;
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DecrementRefCount: Ref Count is already zero !!!!!!")));
    }


    //
    // Set the profile Ref count
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_REF_COUNT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwRef,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DecrementProfileRefCount:  Failed to save profile reference count with error %d"), lResult));
    }


    DeleteSidString(SidString);

    RegCloseKey (hKey);

    return dwRef;

}

//*************************************************************
//
//  SaveProfileInfo()
//
//  Purpose:    Saves key parts of the lpProfile structure
//              in the registry for UnloadUserProfile to use.
//
//  Parameters: lpProfile   -   Profile information
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              12/4/95     ericflo    Created
//
//*************************************************************

BOOL SaveProfileInfo(LPPROFILE lpProfile)
{
    LPTSTR SidString, lpEnd;
    TCHAR LocalProfileKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwCount, dwDisp;
    LPTSTR szUserGuid = NULL;

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to get sid string for user")));
        return FALSE;
    }


    //
    // Open the profile mapping
    //

    GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to open profile mapping key with error %d"), lResult));
        SetLastError(lResult);
        DeleteSidString(SidString);
        return FALSE;
    }

    //
    // Save the flags
    //
    lResult = RegSetValueEx (hKey,
                            PROFILE_FLAGS,
                            0,
                            REG_DWORD,
                            (LPBYTE) &lpProfile->dwFlags,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save flags with error %d"), lResult));
    }


    //
    // Save the internal flags
    //

    lResult = RegSetValueEx (hKey,
                            PROFILE_STATE,
                            0,
                            REG_DWORD,
                            (LPBYTE) &lpProfile->dwInternalFlags,
                            sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save flags2 with error %d"), lResult));
    }


    //
    // Save the central profile path only if it is non-null. 
    // That way it will allow a roaming user/administrator to change roaming profile to local 
    // and then go back to roaming again.
    //

    //
    // lpProfilePath contains the actual roaming share name whereas lpRoamingProfile contains path
    // name wrt to mapped drive name. If lpProfilePath is NULL then use lpRoamingProfile which 
    // is a NULL string.
    //

    lResult = RegSetValueEx(hKey,
                            PROFILE_CENTRAL_PROFILE,
                            0,
                            REG_SZ,
                            (LPBYTE) (lpProfile->lpProfilePath ? 
                                      lpProfile->lpProfilePath : lpProfile->lpRoamingProfile),
                            (lstrlen((lpProfile->lpProfilePath ? 
                                      lpProfile->lpProfilePath : lpProfile->lpRoamingProfile)) + 1) * sizeof(TCHAR));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save central profile with error %d"), lResult));
    }


    //
    // local profile path, saved in CreateLocalProfileImage
    //

    //
    // Save the profile load time
    //

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {

        lResult = RegSetValueEx (hKey,
                                PROFILE_LOAD_TIME_LOW,
                                0,
                                REG_DWORD,
                                (LPBYTE) &lpProfile->ftProfileLoad.dwLowDateTime,
                                sizeof(DWORD));

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save low profile load time with error %d"), lResult));
        }


        lResult = RegSetValueEx (hKey,
                                PROFILE_LOAD_TIME_HIGH,
                                0,
                                REG_DWORD,
                                (LPBYTE) &lpProfile->ftProfileLoad.dwHighDateTime,
                                sizeof(DWORD));

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save high profile load time with error %d"), lResult));
        }
    }


    //
    // Set the user's GUID if this is a new profile
    //

    if (!(lpProfile->dwInternalFlags & PROFILE_TEMP_ASSIGNED) &&
        (lpProfile->dwInternalFlags & PROFILE_NEW_LOCAL)) {

        szUserGuid = GetUserGuid(lpProfile->hTokenUser);

        if (szUserGuid) {
            lResult = RegSetValueEx (hKey,
                                     PROFILE_GUID,
                                     0,
                                     REG_SZ,
                                     (LPBYTE) szUserGuid,
                                     (lstrlen(szUserGuid)+1)*sizeof(TCHAR));

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("SaveProfileInfo:  Failed to save user guid with error %d"), lResult));
            }

            LocalFree(szUserGuid);
        }

        //
        // Save the guid->sid corresp. for the next time
        //

        if (!SetOldSidString(lpProfile->hTokenUser, SidString, PROFILE_GUID_PATH)) {
            DebugMsg((DM_WARNING, TEXT("SaveProfileInfo: Couldn't set the old Sid in the GuidList")));
        }
    }

    DeleteSidString(SidString);

    RegCloseKey (hKey);


    return(TRUE);
}

//*************************************************************
//
//  LoadProfileInfo()
//
//  Purpose:    Loads key parts of the lpProfile structure
//              in the registry for UnloadUserProfile to use.
//
//  Parameters: hTokenClient      -   Caller's token.
//              hTokenUser        -   User's token
//              hKeyCurrentUser   -   User registry key handle
//
//  Return:     LPPROFILE if successful
//              NULL if not
//
//  Comments:   This function doesn't re-initialize all of the
//              fields in the PROFILE structure.
//
//  History:    Date        Author     Comment
//              12/5/95     ericflo    Created
//
//*************************************************************

LPPROFILE LoadProfileInfo (HANDLE hTokenClient, HANDLE hTokenUser, HKEY hKeyCurrentUser)
{
    LPPROFILE lpProfile;
    LPTSTR SidString = NULL, lpEnd;
    TCHAR szBuffer[MAX_PATH];
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwType, dwSize;
    UINT i;
    BOOL bSuccess = FALSE;
    DWORD dwErr = 0;
    HRESULT hr;

    dwErr = GetLastError();

    //
    // Allocate an internal Profile structure to work with.
    //

    lpProfile = (LPPROFILE) LocalAlloc (LPTR, sizeof(USERPROFILE));

    if (!lpProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo: Failed to allocate memory")));
        dwErr = GetLastError();
        goto Exit;
    }

    //
    //  Pre-set the user preference value to UNDEFINED
    //

    lpProfile->dwUserPreference = USERINFO_UNDEFINED;

    //
    // Save the data passed in.
    //

    lpProfile->hTokenClient = hTokenClient;
    lpProfile->hTokenUser = hTokenUser;
    lpProfile->hKeyCurrentUser = hKeyCurrentUser;


    //
    // Allocate memory for the various paths
    //

    lpProfile->lpLocalProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpLocalProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to alloc memory for local profile path.  Error = %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    lpProfile->lpRoamingProfile = (LPTSTR)LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

    if (!lpProfile->lpRoamingProfile) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to alloc memory for central profile path.  Error = %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Get the Sid string for the user
    //

    SidString = GetProfileSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to get sid string for user")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Open the profile mapping
    //

    GetProfileListKeyName(szBuffer, ARRAYSIZE(szBuffer), SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0,
                             KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to open profile mapping key with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the flags
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_FLAGS,
                               NULL,
                               &dwType,
                               (LPBYTE) &lpProfile->dwFlags,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query flags with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the internal flags
    //

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_STATE,
                               NULL,
                               &dwType,
                               (LPBYTE) &lpProfile->dwInternalFlags,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query internal flags with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }


    //
    // Query for the user preference value
    //

    HKEY hkeyPreference;

    if (RegOpenKeyEx(hKey, PREFERENCE_KEYNAME, 0, KEY_READ, &hkeyPreference) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        RegQueryValueEx (hkeyPreference,
                         USER_PREFERENCE,
                         NULL,
                         &dwType,
                         (LPBYTE) &lpProfile->dwUserPreference,
                         &dwSize);
        RegCloseKey(hkeyPreference);
    }


    //
    // Query for the central profile path
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_CENTRAL_PROFILE,
                               NULL,
                               &dwType,
                               (LPBYTE) lpProfile->lpRoamingProfile,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("LoadProfileInfo:  Failed to query central profile with error %d"), lResult));
        lpProfile->lpRoamingProfile[0] = TEXT('\0');
    }


    //
    // Query for the local profile path.  The local profile path
    // needs to be expanded so read it into the temporary buffer.
    //

    dwSize = sizeof(szBuffer);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_IMAGE_VALUE_NAME,
                               NULL,
                               &dwType,
                               (LPBYTE) szBuffer,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query local profile with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    //
    // Expand the local profile
    //

    hr = SafeExpandEnvironmentStrings(szBuffer, lpProfile->lpLocalProfile, MAX_PATH);
    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to expand env string, error %d"), dwErr));
        goto Exit;
    }

    //
    // Query for the profile load time
    //

    lpProfile->ftProfileLoad.dwLowDateTime = 0;
    lpProfile->ftProfileLoad.dwHighDateTime = 0;

    if (!(lpProfile->dwFlags & PI_LITELOAD)) {
        dwSize = sizeof(lpProfile->ftProfileLoad.dwLowDateTime);

        lResult = RegQueryValueEx (hKey,
            PROFILE_LOAD_TIME_LOW,
            NULL,
            &dwType,
            (LPBYTE) &lpProfile->ftProfileLoad.dwLowDateTime,
            &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query low profile load time with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }


        dwSize = sizeof(lpProfile->ftProfileLoad.dwHighDateTime);

        lResult = RegQueryValueEx (hKey,
            PROFILE_LOAD_TIME_HIGH,
            NULL,
            &dwType,
            (LPBYTE) &lpProfile->ftProfileLoad.dwHighDateTime,
            &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LoadProfileInfo:  Failed to query high profile load time with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }
    }

    //
    //  Sucess!
    //

    bSuccess = TRUE;


Exit:

    if (hKey) {
        RegCloseKey (hKey);
    }


    if (SidString) {
        DeleteSidString(SidString);
    }

    //
    // If the profile information was successfully loaded, return
    // lpProfile now.  Otherwise, free any memory and return NULL.
    //

    if (bSuccess) {
        SetLastError(dwErr);
        return lpProfile;
    }

    if (lpProfile) {

        if (lpProfile->lpRoamingProfile) {
            LocalFree (lpProfile->lpRoamingProfile);
        }

        if (lpProfile->lpLocalProfile) {
            LocalFree (lpProfile->lpLocalProfile);
        }

        LocalFree (lpProfile);
    }

    SetLastError(dwErr);

    return NULL;
}

//*************************************************************
//
//  CheckForSlowLink()
//
//  Purpose:    Checks if the network connection is slow.
//
//  Parameters: lpProfile   -   Profile Information
//              dwTime      -   Time delta
//              lpPath      -   UNC path to test
//              bDlgLogin   -   Type of Dialog
//
//  Return:     TRUE if profile should be downloaded
//              FALSE if not (use local)
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Created
//
//*************************************************************

BOOL CheckForSlowLink(LPPROFILE lpProfile, DWORD dwTime, LPTSTR lpPath, BOOL bDlgLogin)
{
    DWORD dwSlowTimeOut, dwSlowDlgTimeOut, dwSlowLinkDetectEnabled, dwSlowLinkUIEnabled;
    ULONG ulTransferRate;
    DWORD dwType, dwSize;
    BOOL bRetVal = TRUE;
    HKEY hKey;
    LONG lResult;
    BOOL bSlow = FALSE;
    BOOL bLegacyCheck = TRUE;
    LPTSTR lpPathTemp, lpTempSrc, lpTempDest;
    LPSTR lpPathTempA;
    struct hostent *hostp;
    ULONG inaddr, ulSpeed;
    DWORD dwResult;
    PWSOCK32_API pWSock32;
    LPTSTR szSidUser;
    handle_t  hIfProfileDialog;
    LPTSTR  lpRPCEndPoint = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    RPC_ASYNC_STATE  AsyncHnd;
    RPC_STATUS  status;

    //
    // If the User Preferences states to always use the local
    // profile then we can exit now with true.  The profile
    // won't actually be downloaded.  In RestoreUserProfile,
    // this will be filtered out, and only the local will be used.
    //

    if (lpProfile->dwUserPreference == USERINFO_LOCAL) {
        return TRUE;
    }


    //
    // Get the slow link detection flag, slow link timeout,
    // dialog box timeout values, and default profile to use.
    //

    dwSlowTimeOut = SLOW_LINK_TIMEOUT;
    dwSlowDlgTimeOut = PROFILE_DLG_TIMEOUT;
    dwSlowLinkDetectEnabled = 1;
    dwSlowLinkUIEnabled = 0;
    ulTransferRate = SLOW_LINK_TRANSFER_RATE;
    bRetVal = FALSE;


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkDetectEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkDetectEnabled,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileDlgTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowDlgTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkUIEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkUIEnabled,
                         &dwSize);

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkProfileDefault"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        dwSize = sizeof(ULONG);
        RegQueryValueEx (hKey,
                         TEXT("UserProfileMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkDetectEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkDetectEnabled,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileDlgTimeOut"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowDlgTimeOut,
                         &dwSize);

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkUIEnabled"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwSlowLinkUIEnabled,
                         &dwSize);

        dwSize = sizeof(BOOL);
        RegQueryValueEx (hKey,
                         TEXT("SlowLinkProfileDefault"),
                         NULL,
                         &dwType,
                         (LPBYTE) &bRetVal,
                         &dwSize);

        dwSize = sizeof(ULONG);
        RegQueryValueEx (hKey,
                         TEXT("UserProfileMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If slow link detection is disabled, then always download
    // the profile.
    //

    if (!dwSlowLinkDetectEnabled || !ulTransferRate) {
        return TRUE;
    }

    //
    // If slow link timeout is set to 0 then always consider the link as slow link
    //

    if (!dwSlowTimeOut) {
        bSlow = TRUE;
        bLegacyCheck = FALSE;
    }

    //
    // If lpPath is  UNC path and we yet not decided that link is slow, then try 
    // pinging the server
    //

    if (!bSlow && (*lpPath == TEXT('\\')) && (*(lpPath+1) == TEXT('\\'))) {

        lpPathTemp = (LPTSTR)LocalAlloc (LPTR, (lstrlen(lpPath)+1) * sizeof(TCHAR));

        if (lpPathTemp) {
            lpTempSrc = lpPath+2;
            lpTempDest = lpPathTemp;

            while ((*lpTempSrc != TEXT('\\')) && *lpTempSrc) {
                *lpTempDest = *lpTempSrc;
                lpTempDest++;
                lpTempSrc++;
            }
            *lpTempDest = TEXT('\0');

            lpPathTempA = ProduceAFromW(lpPathTemp);

            if (lpPathTempA) {

                pWSock32 = LoadWSock32();

                if ( pWSock32 ) {

                    hostp = pWSock32->pfngethostbyname(lpPathTempA);

                    if (hostp) {
                        inaddr = *(long *)hostp->h_addr;

                        dwResult = PingComputer (inaddr, &ulSpeed);

                        if (dwResult == ERROR_SUCCESS) {

                            if (ulSpeed) {

                                //
                                // If the delta time is greater that the timeout time, then this
                                // is a slow link.
                                //

                                if (ulSpeed < ulTransferRate) {
                                    bSlow = TRUE;
                                }
                            }

                            bLegacyCheck = FALSE;
                        }
                    }
                }

                FreeProducedString(lpPathTempA);
            }

            LocalFree (lpPathTemp);
        }
    }


    if (bLegacyCheck) {

        //
        // If the delta time is less that the timeout time, then it
        // is ok to download their profile (fast enough net connection).
        //

        if (dwTime < dwSlowTimeOut) {
            return TRUE;
        }

    } else {

        if (!bSlow) {
            return TRUE;
        }
    }

    //
    // Display the slow link dialog
    //
    // If someone sets the dialog box timeout to 0, then we
    // don't want to prompt the user.  Just do the default
    //


    if ((dwSlowLinkUIEnabled) && (dwSlowDlgTimeOut > 0) && (!(lpProfile->dwFlags & PI_NOUI))) {
 
        szSidUser = GetSidString(lpProfile->hTokenUser);
        if (szSidUser) {

            BYTE* pbCookie = NULL;
            DWORD cbCookie = 0;

            cUserProfileManager.GetRPCEndPointAndCookie(szSidUser, &lpRPCEndPoint, &pbCookie, &cbCookie);

            if (lpRPCEndPoint && GetInterface(&hIfProfileDialog, lpRPCEndPoint)) {
                DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: RPC End point %s"), lpRPCEndPoint));
                           
                status = RpcAsyncInitializeHandle(&AsyncHnd, sizeof(RPC_ASYNC_STATE));
                if (status != RPC_S_OK) {
                    dwErr = status;
                    DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: RpcAsyncInitializeHandle failed. err = %d"), dwErr));
                }
                else {
                    AsyncHnd.UserInfo = NULL;                                  // App specific info, not req
                    AsyncHnd.NotificationType = RpcNotificationTypeEvent;      // Init the notification event
                    AsyncHnd.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    
                    if (AsyncHnd.u.hEvent) {
                        RpcTryExcept {
                            cliSlowLinkDialog(&AsyncHnd, hIfProfileDialog, dwSlowDlgTimeOut, bRetVal, &bRetVal, bDlgLogin, pbCookie, cbCookie);
                        }
                        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
                            dwErr = RpcExceptionCode();
                            DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Calling SlowLinkDialog took exception. err = %d"), dwErr));
                        }
                        RpcEndExcept

                        if (dwErr == RPC_S_OK) {
                            DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: waiting on rpc async event")));
                            if (WaitForSingleObject(AsyncHnd.u.hEvent, (dwSlowDlgTimeOut + 10)*1000) == WAIT_OBJECT_0) {
                                status = RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                            }
                            else {
                                DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Timeout occurs. Client not responding")));
                                // Abortive cancle, should always succeed
                                status = RpcAsyncCancelCall(&AsyncHnd, TRUE);
                                DmAssert(status == RPC_S_OK); 
                                // Now wait for RPC to take notice of the force abort
                                if (WaitForSingleObject(AsyncHnd.u.hEvent, INFINITE) != WAIT_OBJECT_0) {
                                    DmAssert(FALSE && "WaitForSingleObject : Rpc async handle not signaled");
                                }

                                // Complete the Rpc aborted call.
                                status = RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                            }
                            DebugMsg((DM_VERBOSE, TEXT("RpcAsyncCompleteCall finished, status = %d"), status));
                        }
                        // Release the resource
                        CloseHandle(AsyncHnd.u.hEvent);
                    }
                    else {
                        dwErr = GetLastError();
                        DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: create event failed. error %d"), dwErr));
                    }
                } 
   
                if (dwErr != ERROR_SUCCESS) {
                    DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: fail to show message error %d"), GetLastError()));
                }
                ReleaseInterface(&hIfProfileDialog);
            }

            DeleteSidString(szSidUser);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("CheckForSlowLink: Unable to get SID string from token.")));
        }

        if (!lpRPCEndPoint) {
            SLOWLINKDLGINFO info;

            info.dwTimeout = dwSlowDlgTimeOut;
            info.bSyncDefault = bRetVal;
  
            DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink: Calling DialogBoxParam")));
            if (bDlgLogin) {
                bRetVal = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGIN_SLOW_LINK),
                                                NULL, LoginSlowLinkDlgProc, (LPARAM)&info);
            }
            else {
                bRetVal = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGOFF_SLOW_LINK),
                                                NULL, LogoffSlowLinkDlgProc, (LPARAM)&info);
            }
        }

    }

    if (!bRetVal) {
        lpProfile->dwInternalFlags |= PROFILE_SLOW_LINK;
        DebugMsg((DM_VERBOSE, TEXT("CheckForSlowLink:  The profile is across a slow link")));
    }

    return bRetVal;
}


//*************************************************************
//
//  LoginSlowLinkDlgProc()
//
//  Purpose:    Dialog box procedure for the slow link dialog
//              at login time
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY LoginSlowLinkDlgProc (HWND hDlg, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwSlowLinkTime;
    BOOL bDownloadDefault;

    switch (uMsg) {

        case WM_INITDIALOG:
           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);

           //
           // Set the default button and focus
           //

           if (((LPSLOWLINKDLGINFO)lParam)->bSyncDefault) {

                SetFocus (GetDlgItem(hDlg, IDC_DOWNLOAD));

           } else {
                HWND hwnd;
                LONG style;

                //
                // Set the default button to Local
                //

                hwnd = GetDlgItem (hDlg, IDC_DOWNLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_DEFPUSHBUTTON | BS_NOTIFY);
                style |= BS_PUSHBUTTON;
                SetWindowLong (hwnd, GWL_STYLE, style);

                hwnd = GetDlgItem (hDlg, IDC_LOCAL);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_PUSHBUTTON | BS_DEFPUSHBUTTON);
                style |= (BS_DEFPUSHBUTTON | BS_NOTIFY);
                SetWindowLong (hwnd, GWL_STYLE, style);

                SetFocus (GetDlgItem(hDlg, IDC_LOCAL));
           }

           SetWindowLongPtr (hDlg, DWLP_USER, ((LPSLOWLINKDLGINFO)lParam)->bSyncDefault);
           dwSlowLinkTime = ((LPSLOWLINKDLGINFO)lParam)->dwTimeout;
           StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwSlowLinkTime);
           SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
           SetTimer (hDlg, 1, 1000, NULL);
           return FALSE;

        case WM_TIMER:

           if (dwSlowLinkTime >= 1) {

               dwSlowLinkTime--;
               StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwSlowLinkTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Do the default action.
               //

               bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

               if (bDownloadDefault) {
                   PostMessage (hDlg, WM_COMMAND, IDC_DOWNLOAD, 0);

               } else {
                   PostMessage (hDlg, WM_COMMAND, IDC_LOCAL, 0);
               }
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDC_DOWNLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (bDownloadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because download button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDC_LOCAL:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (!bDownloadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                      break;
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because local button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, FALSE);
                  }
                  break;

              case IDCANCEL:
                  bDownloadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

                  //
                  // Nothing to do.  Save the state and return.
                  //

                  DebugMsg((DM_VERBOSE, TEXT("LoginSlowLinkDlgProc:: Killing DialogBox because local/cancel button was clicked")));
                  KillTimer (hDlg, 1);

                  //
                  // Return Whatever is the default in this case..
                  //

                  EndDialog(hDlg, bDownloadDefault);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}

//*************************************************************
//
//  LogoffSlowLinkDlgProc()
//
//  Purpose:    Dialog box procedure for the slow link dialog
//              at login time
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY LogoffSlowLinkDlgProc (HWND hDlg, UINT uMsg,
                                        WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwSlowLinkTime;
    BOOL bUploadDefault;

    switch (uMsg) {

        case WM_INITDIALOG:
           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);

           //
           // Set the default button and focus
           //

           if (((LPSLOWLINKDLGINFO)lParam)->bSyncDefault) {

                SetFocus (GetDlgItem(hDlg, IDC_UPLOAD));

           } else {
                HWND hwnd;
                LONG style;

                //
                // Set the default button to Local
                //

                hwnd = GetDlgItem (hDlg, IDC_UPLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_DEFPUSHBUTTON | BS_NOTIFY);
                style |= BS_PUSHBUTTON;
                SetWindowLong (hwnd, GWL_STYLE, style);

                hwnd = GetDlgItem (hDlg, IDC_NOUPLOAD);
                style = GetWindowLong (hwnd, GWL_STYLE);
                style &= ~(BS_PUSHBUTTON | BS_DEFPUSHBUTTON);
                style |= (BS_DEFPUSHBUTTON | BS_NOTIFY);
                SetWindowLong (hwnd, GWL_STYLE, style);

                SetFocus (GetDlgItem(hDlg, IDC_NOUPLOAD));
           }

           SetWindowLongPtr (hDlg, DWLP_USER, ((LPSLOWLINKDLGINFO)lParam)->bSyncDefault);
           dwSlowLinkTime = ((LPSLOWLINKDLGINFO)lParam)->dwTimeout;
           StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwSlowLinkTime);
           SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
           SetTimer (hDlg, 1, 1000, NULL);
           return FALSE;

        case WM_TIMER:

           if (dwSlowLinkTime >= 1) {

               dwSlowLinkTime--;
               StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwSlowLinkTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Do the default action.
               //

               bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

               if (bUploadDefault) {
                   PostMessage (hDlg, WM_COMMAND, IDC_UPLOAD, 0);

               } else {
                   PostMessage (hDlg, WM_COMMAND, IDC_NOUPLOAD, 0);
               }
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDC_UPLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (bUploadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because upload button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDC_NOUPLOAD:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);
                      if (!bUploadDefault) {
                          KillTimer (hDlg, 1);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                          ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);
                      }
                      break;
                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because Don't Upload button was clicked")));
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, FALSE);
                  }
                  break;

              case IDCANCEL:
                  bUploadDefault = (BOOL) GetWindowLongPtr (hDlg, DWLP_USER);

                  //
                  // Nothing to do.  Save the state and return.
                  //

                  DebugMsg((DM_VERBOSE, TEXT("LogoffSlowLinkDlgProc:: Killing DialogBox because cancel button was clicked")));
                  KillTimer (hDlg, 1);

                  //
                  // Return Whatever is the default in this case..
                  //

                  EndDialog(hDlg, bUploadDefault);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}

//*************************************************************
//
//  GetUserPreferenceValue()
//
//  Purpose:    Gets the User Preference flags
//
//  Parameters: hToken  -   User's token
//
//  Return:     Value
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/22/96     ericflo    Created
//
//*************************************************************

DWORD GetUserPreferenceValue(HANDLE hToken)
{
    TCHAR LocalProfileKey[MAX_PATH];
    DWORD RegErr, dwType, dwSize, dwTmpVal, dwRetVal = USERINFO_UNDEFINED;
    LPTSTR lpEnd;
    LPTSTR SidString;
    HKEY hkeyProfile, hkeyPolicy, hkeyPreference;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SYSTEM_POLICIES_KEY,
                     0, KEY_READ,
                     &hkeyPolicy) == ERROR_SUCCESS) {

        dwSize = sizeof(dwTmpVal);
        RegQueryValueEx(hkeyPolicy,
                        PROFILE_LOCALONLY,
                        NULL, &dwType,
                        (LPBYTE) &dwTmpVal,
                        &dwSize);

        RegCloseKey (hkeyPolicy);
        if (dwTmpVal == 1) {
            dwRetVal = USERINFO_LOCAL;
            return dwRetVal;
        }
    }    

    
    SidString = GetProfileSidString(hToken);
    if (SidString != NULL) {

        //
        // Query for the UserPreference value
        //

        GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);

        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);

        if (RegErr == ERROR_SUCCESS)
        {
            if (RegOpenKeyEx(hkeyProfile,
                             PREFERENCE_KEYNAME,
                             0,
                             KEY_READ,
                             &hkeyPreference) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwRetVal);
                RegQueryValueEx(hkeyPreference,
                                USER_PREFERENCE,
                                NULL,
                                &dwType,
                                (LPBYTE) &dwRetVal,
                                &dwSize);
                RegCloseKey(hkeyPreference);
            }
            RegCloseKey (hkeyProfile);
        }

        //
        // Then try the .bak
        //

        StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), c_szBAK);

        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);

        if (RegErr == ERROR_SUCCESS) {

            if (RegOpenKeyEx(hkeyProfile,
                             PREFERENCE_KEYNAME,
                             0,
                             KEY_READ,
                             &hkeyPreference) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwRetVal);
                RegQueryValueEx(hkeyPreference,
                                USER_PREFERENCE,
                                NULL,
                                &dwType,
                                (LPBYTE) &dwRetVal,
                                &dwSize);
                RegCloseKey(hkeyPreference);
            }
            RegCloseKey (hkeyProfile);
        }

        DeleteSidString(SidString);
    }

    return dwRetVal;
}


//*************************************************************
//
//  IsTempProfileAllowed()
//
//  Purpose:    Gets the temp profile policy
//
//  Parameters:
//
//  Return:     true if temp profile can be created, false otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/8/99      ushaji     Created
//
//*************************************************************

BOOL IsTempProfileAllowed()
{
    HKEY hKey;
    LONG lResult;
    DWORD dwSize, dwType;
    DWORD dwRetVal = PROFILEERRORACTION_TEMP;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(DWORD);
        RegQueryValueEx (hKey,
                         TEXT("ProfileErrorAction"),
                         NULL,
                         &dwType,
                         (LPBYTE) &dwRetVal,
                         &dwSize);

        RegCloseKey (hKey);
    }

    DebugMsg((DM_VERBOSE, TEXT("IsTempProfileAllowed:  Returning %d"), (dwRetVal == PROFILEERRORACTION_TEMP)));
    return (dwRetVal == PROFILEERRORACTION_TEMP);
}

//*************************************************************
//
//  MoveUserProfiles()
//
//  Purpose:    Moves all user profiles from source location
//              to the new profile location
//
//  Parameters: lpSrcDir   -   Source directory
//              lpDestDir  -   Destination directory
//
//  Notes:      The source directory should be given in the same
//              format as the pathnames appear in the ProfileList
//              registry key.  eg:  normally the profile paths
//              are in this form:  %SystemRoot%\Profiles.  The
//              path passed to this function should be in the unexpanded
//              format.
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL MoveUserProfiles (LPCTSTR lpSrcDir, LPCTSTR lpDestDir)
{
    BOOL bResult = TRUE;
    LONG lResult;
    DWORD dwIndex, dwType, dwSize, dwDisp;
    DWORD dwLength, dwLengthNeeded, dwStrLen;
    PSECURITY_DESCRIPTOR pSD;
    LPTSTR lpEnd, lpNewPathEnd, lpNameEnd;
    TCHAR szName[75];
    TCHAR szTemp[MAX_PATH + 1];
    TCHAR szOldProfilePath[MAX_PATH + 1];
    TCHAR szNewProfilePath[MAX_PATH + 1];
    TCHAR szExpOldProfilePath[MAX_PATH + 1] = {0};
    TCHAR szExpNewProfilePath[MAX_PATH + 1];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    INT iSrcDirLen;
    HKEY hKeyProfileList, hKeyProfile, hKeyFolders;
    FILETIME ftWrite;
    UINT cchEnd;
    HRESULT hr;


    //
    // Make sure we don't try to move on top of ourselves
    //

    if (lstrcmpi (lpSrcDir, lpDestDir) == 0) {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Old profiles directory and new profiles directory are the same.")));
        bResult = FALSE;
        goto Exit;
    }


    //
    // Open the profile list
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKeyProfileList);

    if (lResult != ERROR_SUCCESS) {
        if (lResult != ERROR_PATH_NOT_FOUND) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to open profile list registry key with %d"), lResult));
            bResult = FALSE;
        }
        goto DoDefaults;
    }


    //
    // Enumerate the profiles
    //

    StringCchCopy (szTemp, ARRAYSIZE(szTemp), PROFILE_LIST_PATH);
    lpEnd = CheckSlashEx (szTemp, ARRAYSIZE(szTemp), &cchEnd);
    iSrcDirLen = lstrlen (lpSrcDir);

    dwIndex = 0;
    dwSize = ARRAYSIZE(szName);

    while (RegEnumKeyEx (hKeyProfileList, dwIndex, szName, &dwSize, NULL, NULL,
                  NULL, &ftWrite) == ERROR_SUCCESS) {


        //
        // Check if this profile is in use
        //

        if (RegOpenKeyEx(HKEY_USERS, szName, 0, KEY_READ,
                         &hKeyProfile) == ERROR_SUCCESS) {

            DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Skipping <%s> because it is in use."), szName));
            RegCloseKey (hKeyProfile);
            goto LoopAgain;
        }


        //
        // Open the key for a specific profile
        //

        StringCchCopy (lpEnd, cchEnd, szName);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0,
                     KEY_READ | KEY_WRITE, &hKeyProfile) == ERROR_SUCCESS) {


            //
            // Query for the previous profile location
            //

            szOldProfilePath[0] = TEXT('\0');
            dwSize = ARRAYSIZE(szOldProfilePath) * sizeof(TCHAR);

            RegQueryValueEx (hKeyProfile, PROFILE_IMAGE_VALUE_NAME, NULL,
                             &dwType, (LPBYTE) szOldProfilePath, &dwSize);


            //
            // If the profile is located in the source directory,
            // move it to the new profiles directory.
            //

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               szOldProfilePath, iSrcDirLen,
                               lpSrcDir, iSrcDirLen) == CSTR_EQUAL) {

                //
                // Copy the user's name into a buffer we can change
                //

                StringCchCopy (szName, ARRAYSIZE(szName), (szOldProfilePath + iSrcDirLen + 1));


                //
                // If the user's name has a .000, .001, etc at the end,
                // remove that.
                //

                dwStrLen = lstrlen(szName);
                if (dwStrLen > 3) {
                    lpNameEnd = szName + dwStrLen - 4;

                    if (*lpNameEnd == TEXT('.')) {
                        *lpNameEnd = TEXT('\0');
                    }
                }


                //
                // Call ComputeLocalProfileName to get the new
                // profile directory (this also creates the directory)
                //

                StringCchCopy (szNewProfilePath, ARRAYSIZE(szNewProfilePath), lpDestDir);

                if (!ComputeLocalProfileName (NULL, szName,
                              szNewProfilePath, ARRAYSIZE(szNewProfilePath),
                              szExpNewProfilePath, ARRAYSIZE(szExpNewProfilePath),
                              NULL, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to generate unique directory name for <%s>"),
                              szName));
                    goto LoopAgain;
                }


                DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Moving <%s> to <%s>"),
                          szOldProfilePath, szNewProfilePath));

                if (FAILED(SafeExpandEnvironmentStrings (szOldProfilePath, szExpOldProfilePath, ARRAYSIZE(szExpOldProfilePath))))
                {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to expand env string for old profile path")));
                    goto LoopAgain;
                }


                //
                // Copy the ACLs from the old location to the new
                //

                dwLength = 1024;

                pSD = (PSECURITY_DESCRIPTOR)LocalAlloc (LPTR, dwLength);

                if (pSD) {

                    if (GetFileSecurity (szExpOldProfilePath,
                                         DACL_SECURITY_INFORMATION,
                                         pSD, dwLength, &dwLengthNeeded) &&
                        (dwLengthNeeded == 0)) {

                        SetFileSecurity (szExpNewProfilePath,
                                         DACL_SECURITY_INFORMATION, pSD);
                    } else {
                        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to allocate get security descriptor with %d.  dwLengthNeeded = %d"),
                                 GetLastError(), dwLengthNeeded));
                    }

                    LocalFree (pSD);

                } else {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to allocate memory for SD with %d."),
                             GetLastError()));
                }


                //
                // Copy the files from the old location to the new
                //

                if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                          CPD_COPYIFDIFFERENT)) {

                    DebugMsg((DM_VERBOSE, TEXT("MoveUserProfiles:  Profile copied successfully.")));


                    //
                    // Change the registry to point at the new profile
                    //

                    lResult = RegSetValueEx (hKeyProfile, PROFILE_IMAGE_VALUE_NAME, 0,
                                             REG_EXPAND_SZ, (LPBYTE) szNewProfilePath,
                                             ((lstrlen(szNewProfilePath) + 1) * sizeof(TCHAR)));

                    if (lResult == ERROR_SUCCESS) {

                        //
                        // Delete the old profile
                        //

                        Delnode (szExpOldProfilePath);

                    } else {
                        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to set new profile path in registry with %d."), lResult));
                    }


                } else {
                    DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  CopyProfileDirectory failed.")));
                }
            }

            RegCloseKey (hKeyProfile);
        }

LoopAgain:

        dwIndex++;
        dwSize = ARRAYSIZE(szName);
    }

    RegCloseKey (hKeyProfileList);


DoDefaults:


    StringCchCopy (szOldProfilePath, ARRAYSIZE(szOldProfilePath), lpSrcDir);
    hr = SafeExpandEnvironmentStrings (szOldProfilePath, szExpOldProfilePath, ARRAYSIZE(szExpOldProfilePath));
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to expand env string for old profile path.")));
        goto Exit;
    }

    lpEnd = CheckSlashEx(szExpOldProfilePath, ARRAYSIZE(szExpOldProfilePath), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to append slash for old profile path.")));
        goto Exit;
    }


    //
    // Now try to move the Default User profile
    //

    hr = StringCchCopy(lpEnd, cchEnd, DEFAULT_USER);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to append default user for old profile path.")));
        goto Exit;
    }        
    
    if (GetFileAttributesEx (szExpOldProfilePath, GetFileExInfoStandard, &fad)) {

        dwSize = ARRAYSIZE(szExpNewProfilePath);
        if (!GetDefaultUserProfileDirectoryEx(szExpNewProfilePath, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to query default user profile directory.")));
            goto Exit;
        }

        if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                  CPD_COPYIFDIFFERENT)) {
            Delnode (szExpOldProfilePath);
        }
    }


    //
    // Delnode the Network Default User profile if it exists
    //

    hr = StringCchCopy(lpEnd, cchEnd, DEFAULT_USER_NETWORK);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to append default user network for old profile path.")));
        goto Exit;
    }        

    Delnode (szExpOldProfilePath);


    //
    // Now try to move the All Users profile
    //

    hr = StringCchCopy(lpEnd, cchEnd, ALL_USERS);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to append all users for old profile path.")));
        goto Exit;
    }        


    if (GetFileAttributesEx (szExpOldProfilePath, GetFileExInfoStandard, &fad)) {

        dwSize = ARRAYSIZE(szExpNewProfilePath);
        if (!GetAllUsersProfileDirectoryEx(szExpNewProfilePath, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("MoveUserProfiles:  Failed to query all users profile directory.")));
            goto Exit;
        }

        if (CopyProfileDirectory (szExpOldProfilePath, szExpNewProfilePath,
                                  CPD_COPYIFDIFFERENT)) {
            Delnode (szExpOldProfilePath);
        }
    }


    //
    // If possible, remove the old profiles directory
    //

    if (SUCCEEDED(SafeExpandEnvironmentStrings (lpSrcDir, szExpOldProfilePath,
                              ARRAYSIZE(szExpOldProfilePath))))
    {
        RemoveDirectory (szExpOldProfilePath);
    }

Exit:

    return bResult;
}


//*************************************************************
//
//  PrepareProfileForUse()
//
//  Purpose:    Prepares the profile for use on this machine.
//
//  Parameters: lpProfile  -  Profile information
//              pEnv       -  Environment block in per user basis
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL PrepareProfileForUse (LPPROFILE lpProfile, LPVOID pEnv)
{
    TCHAR        szTemp[MAX_PATH];
    TCHAR        szExpTemp[MAX_PATH];
    HKEY         hKey;
    HKEY         hKeyShellFolders = NULL;
    DWORD        dwSize;
    DWORD        dwType;
    DWORD        dwDisp;
    DWORD        dwStrLen;
    DWORD        i;
    DWORD        dwErr;
    PSHELL32_API pShell32Api;

    //
    // Load Shell32.dll.  Give up if it fails.
    //

    if ( ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return TRUE;
    }


    //
    // Calculate the length of the user profile environment variable
    //

    dwStrLen = lstrlen (TEXT("%USERPROFILE%"));


    //
    // Open the Shell Folders key
    //

    RegCreateKeyEx(lpProfile->hKeyCurrentUser, SHELL_FOLDERS, 0, 0, 0,
                   KEY_WRITE, NULL, &hKeyShellFolders, &dwDisp);


    //
    // Open the User Shell Folders key
    //

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      USER_SHELL_FOLDERS, 0, KEY_READ,
                      &hKey) == ERROR_SUCCESS) {


        //
        // Enumerate the folders we know about
        //

        for (i=0; i < g_dwNumShellFolders; i++) {

            //
            // Query for the unexpanded path name
            //

            szTemp[0] = TEXT('\0');
            dwSize = sizeof(szTemp);
            if (RegQueryValueEx (hKey, c_ShellFolders[i].lpFolderName, NULL,
                                &dwType, (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {


                //
                // Expand the path name
                //

                DWORD cchExpPath = ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));

                if (cchExpPath == 0 || cchExpPath > ARRAYSIZE(szExpTemp))
                {
                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to expand <%s>."), szTemp));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, TEXT("PrepareProfileForUse:  User Shell Folder(%s) : <%s> expanded to <%s>."),
                             c_ShellFolders[i].lpFolderName, szTemp, szExpTemp));
                    //
                    // If this is a local directory, create it and set the
                    // hidden bit if appropriate
                    //

                    if (c_ShellFolders[i].bLocal) {

                        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                                           TEXT("%USERPROFILE%"), dwStrLen,
                                           szTemp, dwStrLen) == CSTR_EQUAL) {

                            if (CreateNestedDirectory (szExpTemp, NULL)) {

                                if (c_ShellFolders[i].iFolderResourceID != 0) {
                                    dwErr = pShell32Api->pfnShSetLocalizedName(
                                        szExpTemp,
                                        c_ShellFolders[i].lpFolderResourceDLL,
                                        c_ShellFolders[i].iFolderResourceID );
                                    if (dwErr != ERROR_SUCCESS) {
                                        DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                                                 szExpTemp, dwErr));
                                    }
                                }

                                if (c_ShellFolders[i].bHidden) {
                                    SetFileAttributes(szExpTemp, FILE_ATTRIBUTE_HIDDEN);
                                } else {
                                    SetFileAttributes(szExpTemp, FILE_ATTRIBUTE_NORMAL);
                                }

                            } else {
                                DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create directory <%s> with %d."),
                                         szExpTemp, GetLastError()));
                            }
                        }
                    }


                    //
                    // Set the expanded path in the Shell Folders key.
                    // This helps some apps that look at the Shell Folders
                    // key directly instead of using the shell api
                    //

                    if (hKeyShellFolders) {

                        RegSetValueEx (hKeyShellFolders, c_ShellFolders[i].lpFolderName, 0,
                                       REG_SZ, (LPBYTE) szExpTemp,
                                       ((lstrlen(szExpTemp) + 1) * sizeof(TCHAR)));
                    }
                }
            }
        }

        RegCloseKey (hKey);
    }


    //
    // Close the Shell Folders key
    //

    if (hKeyShellFolders) {
        RegCloseKey (hKeyShellFolders);
    }


    //
    // Now check that the temp directory exists.
    //

    if (RegOpenKeyEx (lpProfile->hKeyCurrentUser,
                      TEXT("Environment"), 0, KEY_READ,
                      &hKey) == ERROR_SUCCESS) {

        //
        // Check for TEMP
        //

        szTemp[0] = TEXT('\0');
        dwSize = sizeof(szTemp);
        if (RegQueryValueEx (hKey, TEXT("TEMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {

            if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                               TEXT("%USERPROFILE%"), dwStrLen,
                               szTemp, dwStrLen) == CSTR_EQUAL) {

                ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));
                if (!CreateNestedDirectory (szExpTemp, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create temp directory <%s> with %d."),
                             szExpTemp, GetLastError()));
                }
            }
        }


        //
        // Check for TMP
        //

        szTemp[0] = TEXT('\0');
        dwSize = sizeof(szTemp);
        if (RegQueryValueEx (hKey, TEXT("TMP"), NULL, &dwType,
                             (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {

            if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                               TEXT("%USERPROFILE%"), dwStrLen,
                               szTemp, dwStrLen) == CSTR_EQUAL) {

                ExpandUserEnvironmentStrings (pEnv, szTemp, szExpTemp, ARRAYSIZE(szExpTemp));
                if (!CreateNestedDirectory (szExpTemp, NULL)) {
                    DebugMsg((DM_WARNING, TEXT("PrepareProfileForUse:  Failed to create temp directory with %d."),
                             GetLastError()));
                }
            }
        }

        RegCloseKey (hKey);
    }

    return TRUE;
}



//*************************************************************
//
//  DeleteProfile()
//
//  Purpose:    Deletes the profile
//
//  Parameters:
//
//  Return:     true if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/99     ushaji     Created
//              6/27/00     santanuc   Bug Fix #100787
//
// TBD: Change some of the DeleteProfileEx calls to DeleteProfile
//
//*************************************************************

BOOL
DeleteProfile (LPCTSTR lpSidString, LPCTSTR lpProfilePath, LPCTSTR szComputerName)
{
    LPTSTR lpEnd;
    TCHAR  szBuffer[MAX_PATH], szProfilePath[MAX_PATH];
    LONG   lResult;
    HKEY   hKey = NULL;
    HKEY   hKeyCurrentVersion = NULL;
    HKEY   hKeyNetCache = NULL;
    DWORD  dwType, dwSize;
    BOOL   bSuccess = FALSE;
    DWORD  dwErr = 0;
    HKEY   hKeyLocalLM;
    BOOL   bRemoteReg = FALSE;
    BOOL   bEnvVarsSet = FALSE;
    TCHAR  szOrigSysRoot[MAX_PATH], szOrigSysDrive[MAX_PATH], tDrive;
    TCHAR  szShareName[MAX_PATH], szFileSystemName[MAX_PATH];
    DWORD  MaxCompLen, FileSysFlags;
    TCHAR  szSystemRoot[MAX_PATH], szSystemDrive[MAX_PATH];
    DWORD  dwBufferSize;
    TCHAR  szTemp[MAX_PATH];
    DWORD  dwInternalFlags=0, dwDeleteFlags=0, dwFlags=0;
    LPTSTR szNetComputerName = NULL;
    HMODULE hMsiLib = NULL;
    PFNMSIDELETEUSERDATA pfnMsiDeleteUserData;
    size_t  cchProfilePath = 0;
    size_t  cchComputerName = 0;
    UINT  cchNetComputerName;
    UINT  cchEnd;
    HRESULT hr;

    //
    //  Check parameters
    //
    
    if (!lpSidString) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpProfilePath)
    {
        hr = StringCchLength((LPTSTR)lpProfilePath, MAX_PATH, &cchProfilePath);
        if (FAILED(hr))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    
    if (szComputerName)
    {
        hr = StringCchLength((LPTSTR)szComputerName, MAX_PATH, &cchComputerName);
        if (FAILED(hr))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    
    if (cchProfilePath + cchComputerName + 3 > MAX_PATH) // Plus the '\\' prefix
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if (szComputerName) {

        if ( !IsUNCPath(szComputerName) ) {

            // Prefixed computer name with slashes if not present
            cchNetComputerName = lstrlen(TEXT("\\\\")) + lstrlen(szComputerName) + 1;
            szNetComputerName = (LPTSTR)LocalAlloc (LPTR, cchNetComputerName * sizeof(TCHAR));

            if (!szNetComputerName) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to allocate memory for computer name with %d"),dwErr));
                goto Exit;
            }

            StringCchCopy(szNetComputerName, cchNetComputerName, TEXT("\\\\"));
            StringCchCat (szNetComputerName, cchNetComputerName, szComputerName);
            szComputerName = szNetComputerName;
        }

        GetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot, MAX_PATH);
        GetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive, MAX_PATH);

        lResult = RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyLocalLM);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        bRemoteReg = TRUE;

        //
        // Get the value of %SystemRoot% and %SystemDrive% relative to the computer
        //

        lResult = RegOpenKeyEx(hKeyLocalLM,
                               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                               0,
                               KEY_READ,
                               &hKeyCurrentVersion);


        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry CurrentVersion %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        dwBufferSize = MAX_PATH * sizeof(TCHAR);

        lResult = RegQueryValueEx(hKeyCurrentVersion,
                                  TEXT("SystemRoot"),
                                  NULL,
                                  NULL,
                                  (BYTE *) szTemp,
                                  &dwBufferSize);

        RegCloseKey (hKeyCurrentVersion);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open remote registry SystemRoot %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        szTemp[1] = TEXT('$');

        //
        // These needs to be set if there are additional places below which uses envvars...
        //

        StringCchCopy(szSystemRoot, ARRAYSIZE(szSystemRoot), szComputerName);
        StringCchCat (szSystemRoot, ARRAYSIZE(szSystemRoot), TEXT("\\"));
        StringCchCat (szSystemRoot, ARRAYSIZE(szSystemRoot), szTemp);
        
        szTemp[2] = 0;

        StringCchCopy(szSystemDrive, ARRAYSIZE(szSystemDrive), szComputerName);
        StringCchCat (szSystemDrive, ARRAYSIZE(szSystemDrive), TEXT("\\"));
        StringCchCat (szSystemDrive, ARRAYSIZE(szSystemDrive), szTemp);

        SetEnvironmentVariable(TEXT("SystemRoot"), szSystemRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szSystemDrive);

        bEnvVarsSet = TRUE;

    }
    else {
        hKeyLocalLM = HKEY_LOCAL_MACHINE;
    }


    // 
    // If profile in use then do not delete it
    //

    if (IsProfileInUse(szComputerName, lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as it is still in use."), lpSidString));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    dwErr = GetLastError();

    //
    // Open the profile mapping
    //

    GetProfileListKeyName(szProfilePath, ARRAYSIZE(szProfilePath), (LPTSTR) lpSidString);

    lResult = RegOpenKeyEx(hKeyLocalLM, szProfilePath, 0,
                           KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to open profile mapping key with error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lResult = RegQueryValueEx (hKey, PROFILE_FLAGS, NULL, &dwType, (LPBYTE)&dwFlags, &dwSize);
    if (ERROR_SUCCESS == lResult && (dwFlags & PI_HIDEPROFILE)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Fail to delete profile with sid %s as PI_HIDEPROFILE flag is specifed."), lpSidString));
        dwErr = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
        

    if (!lpProfilePath) {

        TCHAR szImage[MAX_PATH];

        //
        // Get the profile path...
        //

        dwSize = sizeof(szImage);
        lResult = RegQueryValueEx (hKey,
                                   PROFILE_IMAGE_VALUE_NAME,
                                   NULL,
                                   &dwType,
                                   (LPBYTE) szImage,
                                   &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to query local profile path with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKey, PROFILE_STATE, NULL, &dwType, (LPBYTE)&dwInternalFlags, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to query local profile flags with error %d"), lResult));
            dwErr = lResult;
            goto Exit;
        }

        hr = SafeExpandEnvironmentStrings(szImage, szBuffer, MAX_PATH);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to expand %s, hr = %08X"), szImage, hr));
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

    }
    else {
        StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), lpProfilePath);
    }

    if (dwInternalFlags & PROFILE_THIS_IS_BAK)
        dwDeleteFlags |= DP_DELBACKUP;

    //
    // Do not fail if for some reason we could not delete the profiledir
    //

    bSuccess = DeleteProfileEx(lpSidString, szBuffer, dwDeleteFlags, hKeyLocalLM, szComputerName);

    if (!bSuccess) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete directory, %s with error %d"), szBuffer, dwErr));
    }

    //
    // Delete the user's trash..
    //

    if (szComputerName) {
        StringCchCopy (szShareName, ARRAYSIZE(szShareName), szComputerName);
        StringCchCat  (szShareName, ARRAYSIZE(szShareName), TEXT("\\"));
        lpEnd = szShareName+lstrlen(szShareName);
        StringCchCat  (szShareName, ARRAYSIZE(szShareName), TEXT("A$\\"));
    }
    else {
        StringCchCopy (szShareName, ARRAYSIZE(szShareName), TEXT("a:\\"));
        lpEnd = szShareName;
    }


    for (tDrive = TEXT('A'); tDrive <= TEXT('Z'); tDrive++) {
        *lpEnd = tDrive;

        if ((!szComputerName) && (GetDriveType(szShareName) == DRIVE_REMOTE)) {
            DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Ignoring Drive %s because it is not local"), szShareName));
            continue;
        }


        if (!GetVolumeInformation(szShareName, NULL, 0,
                                NULL, &MaxCompLen, &FileSysFlags,
                                szFileSystemName, MAX_PATH))
            continue;

        if ((szFileSystemName) && (lstrcmp(szFileSystemName, TEXT("NTFS")) == 0)) {
            TCHAR szRecycleBin[MAX_PATH];

            hr = StringCchCopy(szRecycleBin, ARRAYSIZE(szRecycleBin), szShareName);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat (szRecycleBin, ARRAYSIZE(szRecycleBin), TEXT("Recycler\\"));
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCat (szRecycleBin, ARRAYSIZE(szRecycleBin), lpSidString);
                }
            }

            if (SUCCEEDED(hr))
                Delnode(szRecycleBin);

            DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Deleting trash directory at %s"), szRecycleBin));
        }
    }

    //
    // Queue for csc cleanup..
    //

    if (RegOpenKeyEx(hKeyLocalLM, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache"), 0,
                     KEY_WRITE, &hKeyNetCache) == ERROR_SUCCESS) {

        HKEY hKeyNextLogOff;

        if (RegCreateKey(hKeyNetCache, TEXT("PurgeAtNextLogoff"), &hKeyNextLogOff) == ERROR_SUCCESS) {

          if (RegSetValueEx(hKeyNextLogOff, lpSidString, 0, REG_SZ, (BYTE *)TEXT(""), sizeof(TCHAR)) == ERROR_SUCCESS) {

                DebugMsg((DM_VERBOSE, TEXT("DeleteProfile: Queued for csc cleanup at next logoff")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not set the Sid Value under NextLogoff key")));
            }

            RegCloseKey(hKeyNextLogOff);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not create the PurgeAtNextLogoff key")));
        }

        RegCloseKey(hKeyNetCache);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: Could not open the NetCache key")));
    }

    //
    // Delete appmgmt specific stuff..
    //

    hr = SafeExpandEnvironmentStrings(APPMGMT_DIR_ROOT, szBuffer, MAX_PATH);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to expand %s, error %d"), APPMGMT_DIR_ROOT, GetLastError()));
    }
    else
    {
        lpEnd = CheckSlashEx(szBuffer, ARRAYSIZE(szBuffer), &cchEnd);
        if (!lpEnd)
        {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to append slash to APPMGMT DIR")));
        }
        else
        {
            hr = StringCchCopy(lpEnd, cchEnd, lpSidString);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to append sid string to APPMGMT DIR")));
            }
            else
            {
                if (!Delnode(szBuffer))
                {
                    DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete the appmgmt dir %s, error %d"), szBuffer, GetLastError()));
                }
            }
        }
    }

    //
    // Reset the environment variables so that api's down the line 
    // do not get confused
    //

    if (bEnvVarsSet) {
        SetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive);
        bEnvVarsSet = FALSE;
    }

    //
    // Delete msi registry values
    //

    hr = AppendName(szBuffer, ARRAYSIZE(szBuffer), APPMGMT_REG_MANAGED, lpSidString, NULL, NULL);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to append sid string to APPMGMT REG")));
    }
    else
    {
        if (RegDelnode (hKeyLocalLM, szBuffer) != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile:  Failed to delete the appmgmt key %s"), szBuffer));
        }
    }


    // 
    // Delete rsop data   
    //
  
    if (!RsopDeleteUserNameSpace((LPTSTR)szComputerName, (LPTSTR)lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: Failed to delete rsop data")));
    }
    
    //
    // Clean Darwin information
    //

    hMsiLib = LoadLibrary(TEXT("msi.dll"));
    if (hMsiLib) {
        pfnMsiDeleteUserData = (PFNMSIDELETEUSERDATA) GetProcAddress(hMsiLib,
#ifdef UNICODE
                                                                     "MsiDeleteUserDataW");
#else
                                                                     "MsiDeleteUserDataA");
#endif

        if (pfnMsiDeleteUserData) {
            (*pfnMsiDeleteUserData)(lpSidString, szComputerName, NULL);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("DeleteProfile: GetProcAddress returned failure. error %d"), GetLastError()));        
        }

        FreeLibrary(hMsiLib);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DeleteProfile: LoadLibrary returned failure. error %d"), GetLastError()));
    }


Exit:

    if (hKey)
        RegCloseKey(hKey);

    if (bRemoteReg) {
        RegCloseKey(hKeyLocalLM);
    }

    if ( szNetComputerName ) 
        LocalFree(szNetComputerName);

    if (bEnvVarsSet) {
        SetEnvironmentVariable(TEXT("SystemRoot"), szOrigSysRoot);
        SetEnvironmentVariable(TEXT("SystemDrive"), szOrigSysDrive);
    }

    SetLastError(dwErr);

    return bSuccess;
}


//*************************************************************
//
//  SetNtUserIniAttributes()
//
//  Purpose:    Sets system-bit on ntuser.ini
//
//  Parameters:
//
//  Return:     true if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/7/99     ushaji     Created
//
//*************************************************************

BOOL SetNtUserIniAttributes(LPTSTR szDir)
{

    TCHAR szBuffer[MAX_PATH];
    HANDLE hFileNtUser;
    DWORD dwWritten;
    HRESULT hr;

    hr = AppendName(szBuffer, ARRAYSIZE(szBuffer), szDir, c_szNTUserIni, NULL, NULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SetNtUserIniAttributes:  Failed to append ntuser.ini to szDir.")));
        return FALSE;
    }

    //
    // Mark the file with system bit
    //

    hFileNtUser = CreateFile(szBuffer, GENERIC_ALL, 0, NULL, CREATE_NEW,
                           FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);


    if (INVALID_HANDLE_VALUE == hFileNtUser)
        SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    else {

        //
        // The WritePrivateProfile* functions do not write in unicode
        // unless the file already exists in unicode format. Therefore,
        // Precreate a unicode file so that
        // the WritePrivateProfile* functions can preserve the
        // Make sure that the ini file is unicode by writing spaces into it.
        //

        WriteFile(hFileNtUser, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
        WriteFile(hFileNtUser, L"     \r\n", 7 * sizeof(WCHAR),
                          &dwWritten, NULL);
        CloseHandle(hFileNtUser);
    }

    return TRUE;
}


//*************************************************************
//
//  CUserProfile::HandleRegKeyLeak
//
//  Purpose:    If registry key leaked, save the hive and call
//              WatchHiveRefCount to get the hive unloaded later
//              when the keys are released.
//
//  Parameters:
//
//      lpSidString             User's sid in string form.
//      lpProfile               User's LPPROFILE structure.
//      bUnloadHiveSucceeded    Indicates that we should save the hive
//                              to a temp file.
//      dwWatchHiveFlags        (in, out) WHRC_ flags.
//      dwCopyTmpHive           (out) CPD_ flag to indicate to
//                              CopyProfileDirectory whether or not a temp
//                              hive file should be used.
//      tszTmpHiveFile          (out) The tmp hive file name.
//                              privilege.
//
//  Return:     Error code to indicate if the hive is successfully saved to
//              a temp file. If yes, return ERROR_SUCCESS. Otherwise, return
//              an error code that indicates why.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/31/00     weiruc     Created
//
//*************************************************************

DWORD CUserProfile::HandleRegKeyLeak(LPTSTR lpSidString,
                                     LPPROFILE lpProfile,
                                     BOOL bUnloadHiveSucceeded,
                                     DWORD* dwWatchHiveFlags,
                                     DWORD* dwCopyTmpHive,
                                     LPTSTR pTmpHiveFile,
                                     DWORD cchTmpHiveFile)
{
    HRESULT         hres;
    HKEY            hkCurrentUser = NULL;
    NTSTATUS        status;
    BOOLEAN         WasEnabled;
    DWORD           dwErr = ERROR_SUCCESS;
    TCHAR           szErr[MAX_PATH];
    BOOL            bAdjustPriv = FALSE;
    HANDLE          hToken = NULL;
    LPTSTR          lpUserName;

    if (!lpSidString)
        return ERROR_INVALID_PARAMETER;

    if(!bUnloadHiveSucceeded) {
        
        //
        // Reopen the user hive.
        //

        if((dwErr = RegOpenKeyEx(HKEY_USERS,
                                 lpSidString,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hkCurrentUser)) != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RegOpenKeyEx failed with %08x"), dwErr));

            if(dwErr == ERROR_FILE_NOT_FOUND) {

                //
                // If ERROR_FILE_NOT_FOUND, then the hive has been unloaded
                // between RegUnloadKey and here. Procceed without calling
                // WatchHiveRefCount.
                //

                DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: Hive is already unloaded")));
                *dwWatchHiveFlags &= ~WHRC_UNLOAD_HIVE;
                dwErr = ERROR_SUCCESS;
            }
            
            goto NOTIFY_REGISTRY;
        }

        //
        // Make the tmp hive file name: <user profile directory>\ntuser.tmp
        //

        if(lstrlen(lpProfile->lpLocalProfile) + lstrlen(c_szNTUserTmp) + 2 > MAX_PATH) {

            //
            // If the tmp hive file name exceeds MAX_PATH give up.
            //

            dwErr = ERROR_BAD_PATHNAME;
            goto NOTIFY_REGISTRY;
        }

        StringCchCopy(pTmpHiveFile, cchTmpHiveFile, lpProfile->lpLocalProfile);
        StringCchCat (pTmpHiveFile, cchTmpHiveFile, TEXT("\\"));
        StringCchCat (pTmpHiveFile, cchTmpHiveFile, c_szNTUserTmp);

        //
        // Delete existing tmp file if any.
        //

        DeleteFile(pTmpHiveFile);

        //
        // Flush the hive.
        //

        RegFlushKey(hkCurrentUser);

        //
        // Check to see if we are impersonating.
        //

        if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) || hToken == NULL) {
            bAdjustPriv = TRUE;
        }
        else {
            CloseHandle(hToken);
        }

        if(bAdjustPriv) {
            status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);
            if(!NT_SUCCESS(status)) {
                DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege failed with error %08x"), status));
                dwErr = ERROR_ACCESS_DENIED;
                goto NOTIFY_REGISTRY;
            }
            DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege succeeded!")));
        }

        //
        // Save the hive to the tmp file.
        //

        if((dwErr = RegSaveKey(hkCurrentUser, pTmpHiveFile, NULL)) != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: RegSaveKey failed with %08x"), dwErr));
            if (!(lpProfile->dwFlags & PI_LITELOAD)) {

                //
                // Only write event log when not in liteload mode.
                // there are known problems with liteLoad loading because
                // of which eventlog can get full during stress
                //

                ReportError(NULL, PI_NOUI, 1, EVENT_FAILED_HIVE_UNLOAD, GetErrString(dwErr, szErr));
            }
            DeleteFile(pTmpHiveFile);
            goto NOTIFY_REGISTRY;
        }
        
        // 
        // Set the hidden attribute on the temp hive file, so that when it get copied in the 
        // actual hive file it should not reset the hidden attribute
        //
       
        if (!SetFileAttributes(pTmpHiveFile, FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN)) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Failed to set the hidden attribute on temp hive file with error %d"), GetLastError()));
        }

        *dwCopyTmpHive = CPD_USETMPHIVEFILE;
        
        //
        // Log an event only if we schedule the hive for unloading.
        // If it is already scheduled for unloading (RegUnloadKey returns 
        // ERROR_WRITE_PROTECT in that case) then do not give this message.
        //

        if (*dwWatchHiveFlags & WHRC_UNLOAD_HIVE) {
            lpUserName = GetUserNameFromSid(lpSidString);
            ReportError(NULL, PI_NOUI | EVENT_WARNING_TYPE, 1, EVENT_HIVE_SAVED, lpUserName);
            if (lpUserName != lpSidString) {
                LocalFree(lpUserName);
            }
        }

        DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RegSaveKey succeeded!")));
    
        if(bAdjustPriv) {

            //
            // Restore the privilege.
            //

            status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
            if (!NT_SUCCESS(status)) {
                DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Failed to restore RESTORE privilege to previous enabled state %08x"), status));
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: RtlAdjustPrivilege succeeded!")));
            }
        }
    }
    
NOTIFY_REGISTRY:

    if(hkCurrentUser) {
        RegCloseKey(hkCurrentUser);
        DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: hkCurrentUser closed")));
    }

    if(*dwWatchHiveFlags) {

        //
        // Watch for the hive ref count.
        //

        if((hres = WatchHiveRefCount(lpSidString, *dwWatchHiveFlags)) != S_OK) {
            DebugMsg((DM_WARNING, TEXT("HandleRegKeyLeak: Calling WatchHiveRefCount failed. err = %08x"), hres));
        }
        else {
            DebugMsg((DM_VERBOSE, TEXT("HandleRegKeyLeak: Calling WatchHiveRefCount (%s) succeeded"), lpSidString));
        }
    }

    //
    // In UnloadUserProfile, Without this registry leak fix, the code
    // goes to Exit immediately
    // if unloading of the user's hive fails without doing any of the
    // stuff below. But with the fix, we'll fall through here and reconcile
    // the local and the central profiles. The code below also cleans up
    // local profiles, i.e., delete temp profiles, guest user profiles,
    // etc. We have 2 choices here:
    //  1.  We can let the cleaning up happen, in which case files that
    //      are not in use can be cleaned up. This would mean that the
    //      next time when the user logs in, his/her profile will no
    //      longer be loaded, even though his/her hive might still be
    //      loaded. In other words, in TestIfUserProfileLoaded instead
    //      of relying simply on testing whether or not the hive is still
    //      loaded, we have to actually look at the ref count to tell if
    //      a profile is still loaded. In this case the WHRC code will
    //      only need to clean up those files that can not be cleaned up
    //      here.
    //  2.  Do not clean up here. The scenario will remain basically the
    //      same. Next time when the user logs on, his/her profile will
    //      still be loaded, so no change to TestIfUserProfileLoaded. The
    //      WHRC code will handle the complete cleaning up.
    // We implemented choise #2 because it's easier in coding. In the
    // future consider using choice #1.
    //

    return dwErr;
}


//*************************************************************
//
//  AllocAndExpandProfilePath()
//
//  Purpose:    Gets a few predetermined env variables in the profile path
//              expanded
//
//  Parameters:
//              lpProfile
//
//  Return:     true if successful
//
//  Comments:
//
//  Tt gets the environment variables and keeps it locally.
//
//*************************************************************

LPTSTR AllocAndExpandProfilePath(
        LPPROFILEINFO    lpProfileInfo)
{
    TCHAR szUserName[MAX_PATH];
    DWORD dwPathLen=0, cFullPath=0;
    TCHAR szFullPath[MAX_PATH+1];
    LPTSTR pszFullPath=NULL;

    szUserName[0] = TEXT('\0');
    GetEnvironmentVariable (USERNAME_VARIABLE, szUserName, 100);
    SetEnvironmentVariable (USERNAME_VARIABLE, lpProfileInfo->lpUserName);

    //
    // Expand the profile path using current settings
    //

    cFullPath = ExpandEnvironmentStrings(lpProfileInfo->lpProfilePath, szFullPath, MAX_PATH);
    if (cFullPath > 0 && cFullPath <= MAX_PATH)
    {
        pszFullPath = (LPTSTR)LocalAlloc(LPTR, cFullPath * sizeof(TCHAR));
        if (pszFullPath)
        {
            StringCchCopy( pszFullPath, cFullPath, szFullPath);
        }
    }
    else
    {
        pszFullPath = NULL;
    }


    //
    // restore the env block
    //

    if (szUserName[0] != TEXT('\0'))
        SetEnvironmentVariableW (USERNAME_VARIABLE, szUserName);
    else
        SetEnvironmentVariableW (USERNAME_VARIABLE, NULL);

    return(pszFullPath);
}


//*************************************************************
//
//  MAP::MAP()
//
//      Constructor for class MAP.
//
//*************************************************************

MAP::MAP()
{
    for(DWORD i = 0; i < MAXIMUM_WAIT_OBJECTS; i++) {
        rghEvents[i] = NULL;
        rgSids[i] = NULL;
    }
    dwItems = 0;
    pNext = NULL;
}


//*************************************************************
//
//  MAP::Delete
//
//      Delete an work item from a map. Switch the last item into the now
//      empty spot. Caller has to hold the critical section csMap.
//
//  Parameters:
//
//      dwIndex         index into the work list
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void MAP::Delete(DWORD dwIndex)
{
    //
    // Switch the last work item into the newly finished work item position.
    //

    if(rghEvents[dwIndex]) {
        CloseHandle(rghEvents[dwIndex]);
        rghEvents[dwIndex] = NULL;
    }
    if(rgSids[dwIndex]) {
        LocalFree(rgSids[dwIndex]);
        rgSids[dwIndex] = NULL;
    }
    if(dwIndex < dwItems - 1) {
        rghEvents[dwIndex] = rghEvents[dwItems - 1];
        rgSids[dwIndex] = rgSids[dwItems - 1];
    }
    rgSids[dwItems - 1] = NULL;
    rghEvents[dwItems - 1] = NULL;
    dwItems--;
}


//*************************************************************
//
//  MAP::Insert
//
//      Insert an work item into a map. Caller must hold csMap.
//      the items need to be added before the count is changed
//      because WorkerThreadMain accesses the map without holding
//      a lock.
//
//  Parameters:
//
//      HANDLE          Event to be inserted.
//      LPTSTR          Sid string to be inserted.
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void MAP::Insert(HANDLE hEvent, LPTSTR ptszSid)
{
    rghEvents[dwItems] = hEvent;
    rgSids[dwItems] = ptszSid;
    dwItems++;
}


//*************************************************************
//
//  MAP::GetSid
//
//      Get a sid by the index; Caller has to hold csMap.
//
//  Parameters:
//
//      dwIndex         index
//
//  Return value:
//
//      The sid.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

LPTSTR MAP::GetSid(DWORD dwIndex)
{
    LPTSTR  ptszTmpSid = rgSids[dwIndex];

    rgSids[dwIndex] = NULL;

    return ptszTmpSid;
}


//*************************************************************
//
//  CHashTable::CHashTable
//
//      CHashTable class initializer.
//
//  Parameters:
//
//  Return value:
//
//      None.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void CHashTable::Initialize()
{
    for(DWORD i = 0; i < NUM_OF_BUCKETS; i++) {
        Table[i] = NULL;
    }
}


//*************************************************************
//
//  CHashTable::Hash
//
//      Hash a string.
//
//  Parameters:
//
//      pctszString     the string to be hashed
//
//  Return value:
//
//      Hash value.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

DWORD CHashTable::Hash(LPTSTR ptszString)
{
    DWORD       dwHashValue = 0;
    TCHAR*      ptch = ptszString;

    while(*ptch != TEXT('\0')) {
        dwHashValue += *ptch;
        ptch++;
    }

    return dwHashValue % NUM_OF_BUCKETS;
}


//*************************************************************
//
//  CHashTable::IsInTable
//
//      Check to see if a string is already in this hash table. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be checked.
//      ppCSEntry      buffer for the pointer to the CSEntry stored.
//
//  Return value:
//
//      TRUE/FALSE
//
//  History:
//
//      Created         weiruc          5/25/2000
//
//*************************************************************

BOOL CHashTable::IsInTable(LPTSTR ptszString, CSEntry** ppCSEntry)
{
    DWORD       dwHashValue = Hash(ptszString);
    PBUCKET     pbucket;
    PBUCKET     pTmp;

    //
    // Check to see if ptszString is already in the hash table.
    //

    for(pTmp = Table[dwHashValue]; pTmp != NULL; pTmp = pTmp->pNext) {
        if(lstrcmp(pTmp->ptszString, ptszString) == 0) {
            if (ppCSEntry) {
                *ppCSEntry = pTmp->pEntry;
            }
            return TRUE;
        }
    }

    return FALSE;
}
    
    
//*************************************************************
//
//  CHashTable::HashAdd
//
//      Add a string into the hash table. This function doesn't check to see
//      if the string is already in the table. The caller is responsible for
//      calling IsInTable before calling this function. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be added.
//      pCSEntry       the CS entry to be added
//
//  Return value:
//
//      TRUE/FALSE indicating success/failure. The function will fail if
//      the item is already in the hash table, or if we are out of memory.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

BOOL CHashTable::HashAdd(LPTSTR ptszString, CSEntry* pCSEntry)
{
    DWORD       dwHashValue = Hash(ptszString);
    PBUCKET     pbucket;
    PBUCKET     pTmp;


    pbucket = new BUCKET(ptszString, pCSEntry);
    if(pbucket == NULL) {
        DebugMsg((DM_WARNING, TEXT("Can't insert %s. Out of memory"), ptszString));
        return FALSE;
    }
    pbucket->pNext = Table[dwHashValue];
    Table[dwHashValue] = pbucket;

    DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashAdd: %s added in bucket %d"), ptszString, dwHashValue));
    return TRUE;
}


//*************************************************************
//
//  CHashTable::HashDelete
//
//      Delete a string from the hash table. This function
//      is not thread safe. Caller must ensure thread safety when calling this
//      function from multiple threads.
//
//  Parameters:
//
//      ptszString     the string to be deleted.
//
//  Return value:
//
//      none.
//
//  History:
//
//      Created         weiruc          3/2/2000
//
//*************************************************************

void CHashTable::HashDelete(LPTSTR ptszString)
{
    PBUCKET     pPrev, pCur;
    DWORD       dwHashValue = Hash(ptszString);

    if(Table[dwHashValue] == NULL) {
        return;
    }

    pCur = Table[dwHashValue];
    if(lstrcmp(pCur->ptszString, ptszString) == 0) {
        Table[dwHashValue] = Table[dwHashValue]->pNext;
        pCur->pNext = NULL;
        delete pCur;
        DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashDelete: %s deleted"), ptszString));
        return;
    }
    
    for(pPrev = Table[dwHashValue], pCur = pPrev->pNext; pCur != NULL; pPrev = pCur, pCur = pCur->pNext) {
        if(lstrcmp(pCur->ptszString, ptszString) == 0) {
            pPrev->pNext = pCur->pNext;
            pCur->pNext = NULL;
            DebugMsg((DM_VERBOSE, TEXT("CHashTable::HashDelete: %s deleted"), ptszString));
            delete pCur;
            return;
        }
    }
}


//*************************************************************
//
//  Called by and only by console winlogon process.
//
//*************************************************************

void WINAPI InitializeUserProfile()
{
    cUserProfileManager.Initialize();
}


//*************************************************************
//
//  Called by CreateThread
//
//*************************************************************

DWORD ThreadMain(PMAP pThreadMap)
{
    return cUserProfileManager.WorkerThreadMain(pThreadMap);
}

//*************************************************************
//
// CSyncManager::Initialize()
//
//      Initialize the critical section that protects the CS
//      entries list and the hash table.
//
// Parameters:
//
//      void
//
// Return value:
//
//      TRUE/FALSE to indicate if initialization succeeded or failed.
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::Initialize()
{
    BOOL    bRet = TRUE;


    cTable.Initialize();

    //
    // Initialize the critical section that protects the cs entry list.
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&cs, 0x80000000)) {
            DebugMsg((DM_WARNING, TEXT("CSyncManager::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), GetLastError()));
            bRet = FALSE;
        }
        
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::Initialize: critical section initialized")));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugMsg((DM_WARNING, TEXT("CSyncManager::Initialize: InitializeCriticalSection failed")));
        bRet = FALSE;
    }

    return bRet;
}


//*************************************************************
//
// CSyncManager::EnterLock()
//
//      Get a user's profile lock.
//
// Parameters:
//
//      pSid            - User's sid string
//
// Return value:
//
//      TRUE/FALSE. GetLastError to get error.
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::EnterLock(LPTSTR pSid, LPTSTR lpRPCEndPoint, BYTE* pbCookie, DWORD cbCookie)
{
    DWORD       dwError = ERROR_SUCCESS;
    CSEntry*    pEntry = NULL;

    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock <%s>"), pSid));

    EnterCriticalSection(&cs);

    //
    // Look up entry in the hash table.
    //

    if(cTable.IsInTable(pSid, &pEntry)) {
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: Found existing entry")));
    }
    else {

        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: No existing entry found")));

        pEntry = new CSEntry;
        if(!pEntry) {
            dwError = ERROR_OUTOFMEMORY;
            DebugMsg((DM_WARNING, TEXT("CSyncManager::EnterLock: Can't create new CSEntry %08x"), dwError));
            goto Exit;
        }

        if(!pEntry->Initialize(pSid)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CSyncManager::EnterLock: Can not initialize new entry %08x"), dwError));
            goto Exit;
        }
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::EnterLock: New entry created")));
    
        //
        // Insert the new entry in the list.
        //

        pEntry->pNext = pCSList;
        pCSList = pEntry;

        //
        // Add the new entry into the hash table.
        //

        cTable.HashAdd(pEntry->pSid, pEntry);
    }

    pEntry->IncrementRefCount();
    LeaveCriticalSection(&cs);
    pEntry->EnterCS();
    pEntry->SetRPCEndPoint(lpRPCEndPoint);
    pEntry->SetCookie(pbCookie, cbCookie);
    return TRUE;

Exit:

    LeaveCriticalSection(&cs);

    if(pEntry) {
        delete pEntry;
    }

    SetLastError(dwError);
    return FALSE;
}


//*************************************************************
//
// CSyncManager::LeaveLock()
//
//      Release a user's profile lock
//
// Parameters:
//
//      pSid    -   The user's sid string
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSyncManager::LeaveLock(LPTSTR pSid)
{
    BOOL        bRet = FALSE;
    DWORD       dwError = ERROR_SUCCESS;
    CSEntry*    pPrev;
    CSEntry*    pCur;
    CSEntry*    pToBeDeleted;


    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock <%s>"), pSid));
        
    EnterCriticalSection(&cs);

    //
    // Look up the critical section entry.
    //

    if(!cTable.IsInTable(pSid, &pCur)) {
        DebugMsg((DM_WARNING, TEXT("CSyncManager::LeaveLock: User not found!!!!")));
        dwError = ERROR_NOT_FOUND;
        goto Exit;
    }

    pCur->LeaveCS();
    bRet = TRUE;
    DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock: Lock released")));

    //
    // If there's more user waiting for this lock, return.
    //

    if(!pCur->NoMoreUser()) {
        goto Exit;
    }

    //
    // Nobody is waiting on this lock anymore, delete it from the hash table.
    //

    cTable.HashDelete(pSid);

    //
    // Delete from the cs list.
    //

    pToBeDeleted = pCur;
    if(pCur == pCSList) {

        //
        // Entry is the first one in the list.
        //

        pCSList = pCSList->pNext;
        pCur->Uninitialize();
        delete pCur;
        DebugMsg((DM_VERBOSE, TEXT("CSyncManager::LeaveLock: Lock deleted")));
    } else {
        for(pPrev = pCSList, pCur = pCSList->pNext; pCur; pPrev = pCur, pCur = pCur->pNext) {
            if(pCur == pToBeDeleted) {
                pPrev->pNext = pCur->pNext;
                pCur->Uninitialize();
                delete pCur;
                DebugMsg((DM_VERBOSE, TEXT("CSyncManager::DestroyCSEntry: Entry deleted")));
                goto Exit;
            }
        }
    }

Exit:

    LeaveCriticalSection(&cs);

    SetLastError(dwError);
    return bRet;
}

//*************************************************************
//
//  CSyncManager::GetRPCEndPointAndCookie()
//
//  Purpose:  returns the RPCEndPoint and security cookie registered by client     
//
//  Parameters:
//
//      pSid          -  User's sid string
//      lplpEndPoint  -  returned pointer of RPCEndPoint;
//      ppbCookie     -  returned security cookie
//      pcbCookie  -  returned length of security cookie
//
//  Return:
//
//      S_OK on successfully found the entry and returned value
//      S_FALSE on not found, all returned pointer will be NULL
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/25/2000  santanuc   Created
//              05/03/2002  mingzhu    Added security cookie
//
//*************************************************************

HRESULT CSyncManager::GetRPCEndPointAndCookie(LPTSTR pSid, LPTSTR* lplpEndPoint, BYTE** ppbCookie, DWORD* pcbCookie)
{
    HRESULT     hr;
    CSEntry*    pEntry = NULL;

    EnterCriticalSection(&cs);

    //
    // Look up entry in the hash table.
    //

    if(cTable.IsInTable(pSid, &pEntry)) {
       *lplpEndPoint = pEntry->GetRPCEndPoint();
       *ppbCookie = pEntry->GetCookie();
       *pcbCookie = pEntry->GetCookieLen();
       hr = S_OK;
    }
    else {
       *lplpEndPoint = NULL;
       *ppbCookie = NULL;
       *pcbCookie = 0;
       hr = S_FALSE;
    }

    LeaveCriticalSection(&cs);
    return hr;
}

//*************************************************************
//
// CSEntry::Initialize()
//
//      Initialize the user's critical section. This function can
//      only be called by the sync manager.
//
// Parameters:
//
//      pSid    -   The user's sid string
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSEntry::Initialize(LPTSTR pSidParam)
{
    BOOL    bRet = FALSE;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cchSid;

    cchSid = lstrlen(pSidParam) + 1;
    pSid = (LPTSTR)LocalAlloc(LPTR, cchSid * sizeof(TCHAR));
    if(!pSid) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: LocalAlloc failed with %08x"), dwError));
        goto Exit;
    }
    StringCchCopy(pSid, cchSid, pSidParam);

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&csUser, 0x80000000)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: InitializeCriticalSectionAndSpinCount failed with %08x"), dwError));
        }
        else {
            bRet = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = GetExceptionCode();
        DebugMsg((DM_WARNING, TEXT("CSEntry::Initialize: InitializeCriticalSectionAndSpinCount exception %08x"), dwError));
    }

Exit:

    SetLastError(dwError);
    return bRet;
}


//*************************************************************
//
// CSEntry::Uninitialize()
//
//      Delete the user's critical section. This function can
//      only be called by the sync manager.
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::Uninitialize()
{
    DeleteCriticalSection(&csUser);
    if (pSid) {
        LocalFree(pSid);
    }
}


//*************************************************************
//
// CSEntry::EnterCS()
//
//      Enter a user's critical section
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::EnterCS()
{
    EnterCriticalSection(&csUser);
}


//*************************************************************
//
// CSEntry::LeaveCS()
//
//      Leave a user's critical section
//
// Parameters:
//
//      void.
//
// Return value:
//
//      void
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

void CSEntry::LeaveCS()
{
    dwRef--;
    LeaveCriticalSection(&csUser);
}


//*************************************************************
//
// CSEntry::NoMoreUser()
//
//      Are there more users?
//
// Parameters:
//
//      void
//
// Return value:
//
//      TRUE/FALSE
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

BOOL CSEntry::NoMoreUser()
{
    return dwRef == 0;
}

//*************************************************************
//
// CSEntry::IncrementRefCount()
//
//      Increment the reference count.
//
// Parameters:
//
//      void
//
// Return value:
//
//      void
//
// History:
//
//      8/24/00     santanuc      Created
//
//*************************************************************

void CSEntry::IncrementRefCount()
{
    dwRef++;
}

//*************************************************************
//
// CSEntry::SetRPCEndPoint()
//
//      Store the RPCEndPoint. Memory freed by the ~CSEntry
//      
// Parameters:
//
//      lpRPCEndPoint
//
// Return value:
//
//      void
//
// History:
//
//      8/24/00     santanuc      Created
//
//*************************************************************

void CSEntry::SetRPCEndPoint(LPTSTR lpRPCEndPoint)
{
   if (lpRPCEndPoint) {
       DWORD cch = lstrlen(lpRPCEndPoint)+1;
       szRPCEndPoint = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
       if (szRPCEndPoint) {
           StringCchCopy(szRPCEndPoint, cch, lpRPCEndPoint);
       }
   }
}

//*************************************************************
//
// CSEntry::SetCookie()
//
//      Store the Dialog cookie. Memory freed by the ~CSEntry
//      
// Parameters:
//
//      pbCookieIn      -  Cookie, a byte array
//      cbCookieIn   -  size (in bytes) of the cookie
//
// Return value:
//
//      void
//
// History:
//
//      05/03/2002     mingzhu      Created
//
//*************************************************************

void CSEntry::SetCookie(BYTE* pbCookieIn, DWORD cbCookieIn)
{
    if (pbCookieIn && cbCookieIn) {
        pbCookie = (BYTE*)LocalAlloc(LPTR, cbCookieIn);
        if (pbCookie) {
            CopyMemory(pbCookie, pbCookieIn, cbCookieIn);
            cbCookie = cbCookieIn;
        }
    }
}

//*************************************************************
//
// EnterUserProfileLock()
//
//      Get the user profile lock for a user
//
// Parameters:
//
//      pSid        -   The user's sid string
//
// Return value:
//
//      HRESULT
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

DWORD WINAPI EnterUserProfileLock(LPTSTR pSid)
{
    CSEntry*       pEntry = NULL;
    DWORD          dwErr = ERROR_ACCESS_DENIED;
    handle_t       hIfUserProfile;
    BOOL           bBindInterface = FALSE;
    RPC_STATUS     rpc_status;
    
    if(cUserProfileManager.IsConsoleWinlogon()) {
        if(!cUserProfileManager.EnterUserProfileLockLocal(pSid)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: GetUserProfileMutex returned %d"), dwErr));
            goto Exit;
        }
    }
    else {
        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: GetInterface returned %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Register Client Authentication Info, required to do mutual authentication
        //

        rpc_status =  RegisterClientAuthInfo(hIfUserProfile);
        if (rpc_status != RPC_S_OK)
        {
            dwErr = (DWORD) rpc_status;
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: RegisterAuthInfo failed with error %d"), rpc_status));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliEnterUserProfileLockRemote(hIfUserProfile, pSid);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: EnterUserProfileLockRemote took exception error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: EnterUserProfileLockRemote returned error %d"), dwErr));
            goto Exit;
        }
    }
    
    dwErr = ERROR_SUCCESS;

Exit:

   if (bBindInterface) {
       if (!ReleaseInterface(&hIfUserProfile)) {
           DebugMsg((DM_WARNING, TEXT("EnterUserProfileLock: ReleaseInterface failed.")));
       }
    }

    //
    // Return.
    //

    SetLastError(dwErr);
    return dwErr;
}


//*************************************************************
//
// LeaveUserProfileLock()
//
//      Leave the user profile lock
//
// Parameters:
//
//      pSid        -   The user's sid string
//
// Return value:
//
//      HRESULT
//
// History:
//
//      6/16/00     weiruc      Created
//
//*************************************************************

DWORD WINAPI LeaveUserProfileLock(LPTSTR pSid)
{
    CSEntry*       pEntry = NULL;
    DWORD          dwErr = ERROR_ACCESS_DENIED;
    handle_t       hIfUserProfile;
    BOOL           bBindInterface = FALSE;
    RPC_STATUS     rpc_status;
    
    if(cUserProfileManager.IsConsoleWinlogon()) {
        cUserProfileManager.LeaveUserProfileLockLocal(pSid);
    }
    else {
        if (!GetInterface(&hIfUserProfile, cszRPCEndPoint)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: GetInterface returned %d"), dwErr));
            goto Exit;
        }
        bBindInterface = TRUE;

        //
        // Register Client Authentication Info, required to do mutual authentication
        //

        rpc_status =  RegisterClientAuthInfo(hIfUserProfile);
        if (rpc_status != RPC_S_OK)
        {
            dwErr = (DWORD) rpc_status;
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: RegisterAuthInfo failed with error %d"), rpc_status));
            goto Exit;
        }

        RpcTryExcept {
            dwErr = cliLeaveUserProfileLockRemote(hIfUserProfile, pSid);
        }
        RpcExcept(1) {
            dwErr = RpcExceptionCode();
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: LeaveUserProfileLockRemote took exception error %d"), dwErr));
        }
        RpcEndExcept

        if (dwErr != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: LeaveUserProfileLockRemote returned error %d"), dwErr));
            goto Exit;
        }

   }

   dwErr = ERROR_SUCCESS;

Exit:

    if (bBindInterface) {
        if (!ReleaseInterface(&hIfUserProfile)) {
            DebugMsg((DM_WARNING, TEXT("LeaveUserProfileLock: ReleaseInterface failed.")));
        }
    }

    //
    // Return.
    //

    SetLastError(dwErr);
    return dwErr;
}

//*************************************************************
//
//  IsProfileInUse()
//
//  Purpose:    Determines if the given profile is currently in use
//
//  Parameters: szComputer - Name of the machine
//              lpSid      - Sid (text) to test
//
//  Return:     TRUE if in use
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/28/00     santanuc   Created
//
//*************************************************************

BOOL IsProfileInUse (LPCTSTR szComputer, LPCTSTR lpSid)
{
    LONG lResult;    
    HKEY hKeyUsers, hKeyProfile;
    BOOL bRemoteReg = FALSE;
    BOOL bRetVal = FALSE;

    if (!lpSid)
        return FALSE;
        
    if (szComputer) {
        lResult = RegConnectRegistry(szComputer, HKEY_USERS, &hKeyUsers);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("IsProfileInUse:  Failed to open remote registry %d"), lResult));
            return TRUE;
        }

        bRemoteReg = TRUE;
    }
    else {
        hKeyUsers = HKEY_USERS;
    }

    if (RegOpenKeyEx (hKeyUsers, lpSid, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {
        RegCloseKey (hKeyProfile);
        bRetVal = TRUE;
    }
    else {
        LPTSTR lpSidClasses;
        DWORD cchSidClasses;

        cchSidClasses = lstrlen(lpSid)+lstrlen(TEXT("_Classes"))+1;
        lpSidClasses = (LPTSTR)LocalAlloc(LPTR, cchSidClasses * sizeof(TCHAR));
        if (lpSidClasses) {
            StringCchCopy(lpSidClasses, cchSidClasses, lpSid);
            StringCchCat (lpSidClasses, cchSidClasses, TEXT("_Classes"));
            if (RegOpenKeyEx (hKeyUsers, lpSidClasses, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {
                RegCloseKey (hKeyProfile);
                bRetVal = TRUE;
            }
            LocalFree(lpSidClasses);
        }
    }

    if (bRemoteReg) {
        RegCloseKey(hKeyUsers);
    }

    return bRetVal;
}

//*************************************************************
//
//  IsUIRequired()
//
//  Purpose:    Determines if the profile error message requires
//              If the ref count is > 1 then we do not required
//              error reporting. If ref count is 1 then we check
//              
//
//  Parameters: hToken - User's token
//
//  Return:     TRUE if error message req
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
BOOL IsUIRequired(HANDLE hToken)
{
    LPTSTR   lpSidString = GetSidString(hToken);
    BOOL     bRetVal = FALSE;
    TCHAR    szBuffer[MAX_PATH];
    LPTSTR   lpEnd;
    HKEY     hKeyProfile;
    DWORD    dwType, dwFlags, dwRef, dwSize;

    if (lpSidString) {

        GetProfileListKeyName(szBuffer, ARRAYSIZE(szBuffer), lpSidString);

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_REF_COUNT,
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwRef,
                                 &dwSize) == ERROR_SUCCESS) {
                if (dwRef == 1) {
                    
                    dwSize = sizeof(DWORD);
                    if (RegQueryValueEx (hKeyProfile,
                                         PROFILE_FLAGS,
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwFlags,
                                         &dwSize) == ERROR_SUCCESS) {
                        if (!(dwFlags & (PI_NOUI | PI_LITELOAD))) {
                            bRetVal = TRUE;
                        }
                    }
                    else {
                        DebugMsg((DM_WARNING, TEXT("IsUIRequired: Failed to query value for flags.")));
                    }
                }

            }
            else {
                DebugMsg((DM_WARNING, TEXT("IsUIRequired: Failed to query value for ref count.")));
            }

            RegCloseKey(hKeyProfile);
        }
        else {
            DebugMsg((DM_WARNING, TEXT("IsUIRequired:  Failed to open key %s"), szBuffer));
        }

        DeleteSidString(lpSidString);
    }

    return bRetVal;
}

//*************************************************************
//
//  CheckRUPShare()
//
//  Purpose:    Determines if the RUP share is CSCed, if it is 
//              then issue an event log warning.
//
//  Parameters: lpProfilePath - User's roaming profile path
//
//  Return:     None
//
//  Comments:
//
//*************************************************************
void CheckRUPShare(LPTSTR lpProfilePath)
{
    LPTSTR lpServer, lpShare, lpCopy;
    PSHARE_INFO_1005 pBufPtr1, pBufPtr2;
    BOOL bIssueWarning = FALSE;
    DWORD cchCopy, cchServer;
    
    if (!lpProfilePath || !IsUNCPath(lpProfilePath)) {
        return;
    }

    cchCopy = lstrlen(lpProfilePath)+1;
    lpCopy = (LPTSTR)LocalAlloc(LPTR, cchCopy * sizeof(TCHAR));
    if (!lpCopy) {
        DebugMsg((DM_WARNING, TEXT("CheckRUPShare: Failed to allocate memory")));
        return;
    }

    StringCchCopy(lpCopy, cchCopy, lpProfilePath);
    ConvertToShareName(lpCopy);
    lpServer = lpCopy;
    lpShare = lpCopy+2;  // Skip initial two slashes
    while (*lpShare != TCHAR('\\') && *lpShare != TCHAR('\0')) 
        lpShare++;

    if (*lpShare == TCHAR('\\')) {
        *lpShare = TCHAR('\0');
        lpShare++;
    
        if (NetShareGetInfo(lpServer, lpShare, 1005,
                            (LPBYTE *)&pBufPtr1) == ERROR_SUCCESS) {
            if ((pBufPtr1->shi1005_flags & CSC_MASK) == CSC_CACHE_NONE) {
                bIssueWarning = FALSE;
            }
            else if (pBufPtr1->shi1005_flags & SHI1005_FLAGS_DFS_ROOT) {

                //
                // If share is DFS root then we need to check the DfsLink to see 
                // whether csc is disabled on it
                //

                // Construct the dfs link 

                StringCchCopy(lpCopy, cchCopy, lpProfilePath);
                int iDfsLink = 0;
                lpServer = lpCopy;
                lpShare = lpCopy+2;  // Skip initial two slashes
                while ((iDfsLink < 3) && *lpShare != TCHAR('\0')) {
                    if (*lpShare == TCHAR('\\')) {
                        iDfsLink++;
                    }
                    lpShare++;
                }
                if (*lpShare != TCHAR('\0')) {
                    *(lpShare-1) = TCHAR('\0');
                }
                if (iDfsLink >= 2) {
                    PDFS_INFO_3 pDfsBuf;

                    // Query for the actual server and share

                    if (NetDfsGetInfo(lpServer, NULL, NULL, 3, 
                                      (LPBYTE *)&pDfsBuf) == NERR_Success) {
                        if (pDfsBuf->NumberOfStorages >= 1) {
                            cchServer = lstrlen(pDfsBuf->Storage->ServerName)+3;
                            lpServer = (LPTSTR)LocalAlloc(LPTR, cchServer * sizeof(WCHAR));
                            if (!lpServer) {
                                DebugMsg((DM_WARNING, TEXT("CheckRUPShare: Failed to allocate memory")));
                                goto Exit;
                            }
                            StringCchCopy(lpServer, cchServer, TEXT("\\\\"));
                            StringCchCat (lpServer, cchServer, pDfsBuf->Storage->ServerName);

                            // Get csc information from actual server and share 

                            if (NetShareGetInfo(lpServer, pDfsBuf->Storage->ShareName, 1005,
                                                (LPBYTE *)&pBufPtr2) == ERROR_SUCCESS) {
                                if ((pBufPtr2->shi1005_flags & CSC_MASK) == CSC_CACHE_NONE) {
                                    bIssueWarning = FALSE;
                                }
                                else {
                                    bIssueWarning = TRUE;
                                }
                                NetApiBufferFree(pBufPtr2);
                            }
                            LocalFree(lpServer);
                        }
                        NetApiBufferFree(pDfsBuf);
                    }
                }
            }
            else {
                bIssueWarning = TRUE;
            }
            NetApiBufferFree(pBufPtr1);

            if (bIssueWarning) {
                ReportError(NULL, PI_NOUI | EVENT_WARNING_TYPE, 0, EVENT_CSC_ON_PROFILE_SHARE);
            }
        }
    }

Exit:
    LocalFree(lpCopy);

}

//*************************************************************
//
//  IsPartialRoamingProfile()
//
//  Purpose:    determines if roaming profile contains a partial 
//              copy or not. This is indicated by setting a flag
//              in ntuser.ini.
//
//  Parameters: lpProfile - User's profile 
//
//  Return:     TRUE : If Roaming profile contains a Partial 
//                     profile due to LITE_LOAD unload.
//              FALSE: otherwise.
//
//  Comments:
//
//*************************************************************
BOOL IsPartialRoamingProfile(LPPROFILE lpProfile)
{
    TCHAR  szLastUploadState[20];
    LPTSTR szNTUserIni = NULL;
    LPTSTR lpEnd;
    BOOL   bRetVal = FALSE;
    HRESULT hr;

    // 
    // Allocate memory for Local variables to avoid stack overflow
    //

    szNTUserIni = (LPTSTR)LocalAlloc(LPTR, MAX_PATH*sizeof(TCHAR));
    if (!szNTUserIni) {
        DebugMsg((DM_WARNING, TEXT("IsPartialRoamingProfile: Out of memory")));
        goto Exit;
    }

    hr = AppendName(szNTUserIni, MAX_PATH, lpProfile->lpRoamingProfile, c_szNTUserIni, NULL, NULL);
    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("IsPartialRoamingProfile: failed to append ntuser.ini")));
        goto Exit;
    }
    

    GetPrivateProfileString (PROFILE_LOAD_TYPE,
                             PROFILE_LAST_UPLOAD_STATE,
                             COMPLETE_PROFILE, szLastUploadState,
                             ARRAYSIZE(szLastUploadState),
                             szNTUserIni);

    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szLastUploadState, -1, PARTIAL_PROFILE, -1) == CSTR_EQUAL) {
        bRetVal = TRUE;
    }

Exit:

    if (szNTUserIni) 
        LocalFree(szNTUserIni);

    return bRetVal;
}


//*************************************************************
//
//  TouchLocalHive()
//
//  Purpose:  Check whether in local machine user profile is 
//            switching from local to roaming for first time. If 
//            yes and we have a existing hive in RUP share then 
//            always overwrite the local hive with hive in RUP 
//            share. This is to avoid wrong hive usage due to 
//            cached login.
//
//
//  Parameters: lpProfile - User's profile 
//
//  Return:     None
//
//  Comments:
//
//*************************************************************
void TouchLocalHive(LPPROFILE lpProfile)
{
    LPTSTR   szBuffer = NULL, lpEnd;
    LPTSTR   SidString = NULL;
    HKEY     hKey = NULL;
    HANDLE   hFile = NULL;
    DWORD    dwSize, dwType;
    LONG     lResult;
    const LONGLONG datetime1980 = 0x01A8E79FE1D58000;  // 1/1/80, origin of DOS datetime
    union {
        FILETIME ft;
        LONGLONG datetime;
    };
    DWORD    cchBuffer;
    HRESULT hr;

    if ((lpProfile->dwInternalFlags & PROFILE_NEW_CENTRAL) ||
        (lpProfile->dwInternalFlags & PROFILE_MANDATORY)) {
        goto Exit;
    }

    //
    // Set the time to base
    //

    datetime = datetime1980;

    //
    // Allocate local buffer
    //
    cchBuffer = MAX_PATH;
    szBuffer = (LPTSTR) LocalAlloc(LPTR, cchBuffer*sizeof(TCHAR));
    if (!szBuffer) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Out of memory")));
        goto Exit;
    }

    //
    // Get the Sid string for the user
    //

    SidString = GetSidString(lpProfile->hTokenUser);
    if (!SidString) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Failed to get sid string for user")));
        goto Exit;
    }

    //
    // Open the profile mapping
    //

    GetProfileListKeyName(szBuffer, cchBuffer, SidString);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0,
                           KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Failed to open profile mapping key with error %d"), lResult));
        goto Exit;
    }

    //
    // Query for the central profile path
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hKey,
                               PROFILE_CENTRAL_PROFILE,
                               NULL,
                               &dwType,
                               (LPBYTE) szBuffer,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Failed to query central profile with error %d"), lResult));
        goto Exit;
    }

    if (szBuffer[0] == TEXT('\0')) {
 
        //
        // So we are switching from local to roaming profile for first time
        //
        
        //
        // Make sure we don't overrun our temporary buffer
        //

        if ((lstrlen(lpProfile->lpLocalProfile) + 1 + lstrlen(c_szNTUserDat) + 1) > MAX_PATH) {
            DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Failed because temporary buffer is too small.")));
            goto Exit;
        }


        //
        // Copy the local profile path to a temporary buffer
        // we can munge it.
        //
        //
        // Add the slash if appropriate and then tack on
        // ntuser.dat.
        //

        hr = AppendName(szBuffer, cchBuffer, lpProfile->lpLocalProfile, c_szNTUserDat, NULL, NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Failed to append ntuser.dat.")));
            goto Exit;
        }

        //
        // See if this file exists
        //

        DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Testing <%s>"), szBuffer));

        hFile = CreateFile(szBuffer, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


        if (hFile != INVALID_HANDLE_VALUE) {
            DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Found a user hive.")));

            //
            // Set the local hive time to base i.e 1/1/1980, so that RUP hive 
            // overwrites this hive during profile merge
            //

            if (SetFileTime(hFile, NULL, NULL, &ft)) {
                DebugMsg((DM_VERBOSE, TEXT("TouchLocalHive: Touched user hive.")));
            }
            else {
                DebugMsg((DM_WARNING, TEXT("TouchLocalHive: Fail to touch user hive.")));
            }
            CloseHandle(hFile);
        }
    }


Exit:

    if (szBuffer) {
        LocalFree(szBuffer);
    }

    if (SidString) {
        DeleteSidString(SidString);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }
}        
    


//*************************************************************
//
//  ErrorDialog()
//
//  Purpose:    ErrorDialog api of IProfileDialog interface
//              Display error message on client's desktop
//
//  Parameters: 
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
void ErrorDialog(IN PRPC_ASYNC_STATE pAsync, IN handle_t hBindHandle, IN DWORD dwTimeOut, IN LPTSTR lpErrMsg, IN BYTE* pbCookie, IN DWORD cbCookie)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    RPC_STATUS status;

    //
    //  Check if the security cookie match the one in this process
    //
    if (cbCookie == g_ProfileDialog.CookieLen() &&
        memcmp(pbCookie, g_ProfileDialog.GetCookie(), cbCookie) == 0)
    {
        ErrorDialogEx(dwTimeOut, lpErrMsg);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("ErrorDialog: Security cookie doesn't match!")));
    }

    status = RpcAsyncCompleteCall(pAsync, (PVOID)&dwRetVal);
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("ErrorDialog: RpcAsyncCompleteCall fails with error %ld"), status));
    }
}

//*************************************************************
//
//  SlowLinkDialog()
//
//  Purpose:    SlowLinkDialog api of IProfileDialog interface
//              Display SlowLink message on client's desktop
//
//  Parameters: 
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/2000  santanuc   Created
//              05/06/2002  mingzhu    Added security cookie
//
//*************************************************************
void SlowLinkDialog(IN PRPC_ASYNC_STATE pAsync, IN handle_t hBindHandle, IN DWORD dwTimeOut, IN BOOL bDefault, OUT BOOL *bpResponse, IN BOOL bDlgLogin, IN BYTE* pbCookie, IN DWORD cbCookie)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    RPC_STATUS status;

    //
    //  Check if the security cookie match the one in this process
    //
    if (cbCookie == g_ProfileDialog.CookieLen() &&
        memcmp(pbCookie, g_ProfileDialog.GetCookie(), cbCookie) == 0)
    {
        SLOWLINKDLGINFO info;
        info.dwTimeout = dwTimeOut;
        info.bSyncDefault = bDefault;
      
        DebugMsg((DM_VERBOSE, TEXT("SlowLinkDialog: Calling DialogBoxParam")));
        if (bDlgLogin) {
            *bpResponse = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGIN_SLOW_LINK),
                                                NULL, LoginSlowLinkDlgProc, (LPARAM)&info);
        }
        else {
            *bpResponse = (BOOL)DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_LOGOFF_SLOW_LINK),
                                                NULL, LogoffSlowLinkDlgProc, (LPARAM)&info);
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("SlowLinkDialog: Security cookie doesn't match!")));
    }


    status = RpcAsyncCompleteCall(pAsync, (PVOID)&dwRetVal);
    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("SlowLinkDialog: RpcAsyncCompleteCall fails with error %ld"), status));
    }
}

//*************************************************************
//
//  IsLRPC()
//
//  Purpose:    Check if a RPC call is through LRPC
//
//  Parameters: 
//
//  Return:     TRUE for LRPC, 
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/12/2002  mingzhu    Created
//
//*************************************************************
BOOL IsLRPC(handle_t hBinding)
{
    BOOL bLRPC = FALSE;
    LPTSTR pBinding = NULL;
    LPTSTR pProtSeq = NULL;

    if (RpcBindingToStringBinding(hBinding,&pBinding) == RPC_S_OK)
    {
        // We're only interested in the protocol sequence
        // so we can use NULL for all other parameters.

        if (RpcStringBindingParse(pBinding,
                                  NULL,
                                  &pProtSeq,
                                  NULL,
                                  NULL,
                                  NULL) == RPC_S_OK)
        {
            // Check that the client request was made using LRPC.
            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, (LPCTSTR)pProtSeq, -1, TEXT("ncalrpc"), -1) == CSTR_EQUAL)
                bLRPC = TRUE;

            RpcStringFree(&pProtSeq); 
        }

        RpcStringFree(&pBinding);
    }

    return bLRPC;
}

//*************************************************************
//
//  IProfileSecurityCallBack()
//
//  Purpose:    Security call back for IUserProfile interface
//
//  Parameters: 
//              hIF      - RPC interface handle
//              hBinding - RPC binding for the interface
//
//  Return:     RPC_S_OK for checked call, exception will be
//              raised if check fails.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/12/2002  mingzhu    Created
//
//*************************************************************

RPC_STATUS RPC_ENTRY IProfileSecurityCallBack(RPC_IF_HANDLE hIF, handle_t hBinding)
{
    // Only allow LRPC traffic 
    if (!IsLRPC(hBinding)) 
        RpcRaiseException(ERROR_PROTOCOL_UNREACHABLE);

    RPC_AUTHZ_HANDLE hPrivs;
    DWORD dwAuthn;

    RPC_STATUS status = RpcBindingInqAuthClient(
                            hBinding,
                            &hPrivs,
                            NULL,
                            &dwAuthn,
                            NULL,
                            NULL);

    if (status != RPC_S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("IProfileSecurityCallBack: RpcBindingInqAuthClient failed with %x"), status));
        RpcRaiseException(ERROR_ACCESS_DENIED);
    }

    // Now check the authentication level.
    // We require at least packet-level authentication.
    if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT)
    {
        DebugMsg((DM_WARNING, TEXT("IProfileSecurityCallBack: Attempt by client to use weak authentication.")));
        RpcRaiseException(ERROR_ACCESS_DENIED);
    }

    DebugMsg((DM_VERBOSE, TEXT("IProfileSecurityCallBack: client authenticated.")));

    return RPC_S_OK;
}

//*************************************************************
//
//  RegisterClientAuthInfo()
//
//  Purpose:    Register authentication information for the client
//              of IUserProfile interface. Require mutual authentication
//              for the binding.
//
//  Parameters: 
//              hBinding - RPC binding for the interface
//
//  Return:     RPC_S_OK for checked call, a RPC status will be
//              returned if check fails.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/12/2002  mingzhu    Created
//
//*************************************************************

RPC_STATUS  RegisterClientAuthInfo(handle_t hBinding)
{
    RPC_STATUS status;
    RPC_SECURITY_QOS qos;

    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH; // Important!!!
    qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC; // We need this since we have to impersonate the user
    qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE; 

    // Set Security settings 

    status = RpcBindingSetAuthInfoEx(hBinding,
                                     TEXT("NT AUTHORITY\\SYSTEM"), // the server should be running as local system
                                     RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                     RPC_C_AUTHN_WINNT, 
                                     0,
                                     0,
                                     &qos);
    return status;
}

//******************************************************************************
//
//  RPC routines
//
//******************************************************************************

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t count)
{
    DebugMsg((DM_VERBOSE, TEXT("MIDL_user_allocate enter")));
    return(malloc(count));
}

void __RPC_USER MIDL_user_free(void __RPC_FAR * p)
{
    DebugMsg((DM_VERBOSE, TEXT("MIDL_user_free enter")));
    free(p);
}

void __RPC_USER PCONTEXT_HANDLE_rundown (PCONTEXT_HANDLE phContext)
{
    DebugMsg((DM_VERBOSE, TEXT("PCONTEXT_HANDLE_rundown : Client died with open context")));
    ReleaseClientContext_s(&phContext);
}

//******************************************************************************
//
//  CheckRoamingShareOwnership()
//
//  Purpose:    Check the ownership of the roaming user's profile on the server.
//              If the owner is not the user or not an admin, this function will
//              fail, and an error message will be issued. Administrator can set
//              a policy "CompatibleRUPSecurity" to disable this check.
//
//  Parameters: 
//              lpDir      - profile directory on the server
//              hTokenUser - user's token
//
//  Return:     S_OK on success, else for failure
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/21/2002  mingzhu    Created
//
//******************************************************************************

HRESULT CheckRoamingShareOwnership(LPTSTR lpDir, HANDLE hTokenUser)
{
    HRESULT hr = E_FAIL;
    BOOL    bDisableCheck = FALSE;
    HKEY    hSubKey = NULL;
    DWORD   dwRegValue;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   cbSD;
    BOOL    bDefaultOwner;
    DWORD   dwErr;
    PSID    pSidAdmin = NULL;
    PSID    pSidUser = NULL;
    PSID    pSidOwner = NULL;
    
    PSECURITY_DESCRIPTOR        psd = NULL;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;

    //
    //  Output a debug message for entering the function.
    //
    
    DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: checking ownership for %s"), lpDir));

    //
    // Check for the policy to see if this check has been disabled
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwRegValue);
        if (RegQueryValueEx(hSubKey, TEXT("CompatibleRUPSecurity"), NULL, &dwType, (LPBYTE) &dwRegValue, &dwSize) == ERROR_SUCCESS)
        {
            bDisableCheck = (BOOL)(dwRegValue);   
        }
        RegCloseKey(hSubKey);
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwRegValue);
        if (RegQueryValueEx(hSubKey, TEXT("CompatibleRUPSecurity"), NULL, &dwType, (LPBYTE) &dwRegValue, &dwSize) == ERROR_SUCCESS)
        {
            bDisableCheck = (BOOL)(dwRegValue);   
        }
        RegCloseKey(hSubKey);
    }

    if (bDisableCheck)
    {
         DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: policy set to disable ownership check")));
         hr = S_OK;
         goto Exit;
    }

    //
    //  Get the security of the directory, should fail with  ERROR_INSUFFICIENT_BUFFER
    //
    
    GetFileSecurity(lpDir, OWNER_SECURITY_INFORMATION, NULL, 0, &cbSD);

    dwErr = GetLastError();
    if (dwErr != ERROR_INSUFFICIENT_BUFFER)
    {
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : GetFileSecurity failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Allocate memory for SD
    //
    psd = (PSECURITY_DESCRIPTOR) LocalAlloc (LPTR, cbSD);
    if (!psd)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : LocalAlloc failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Try it again
    //
    if (!GetFileSecurity(lpDir, OWNER_SECURITY_INFORMATION, psd, cbSD, &cbSD))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership : GetFileSecurity failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the owner in SD 
    //

    if (!GetSecurityDescriptorOwner(psd, &pSidOwner, &bDefaultOwner))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: Failed to get security descriptor owner.  Error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0, &pSidAdmin))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: Failed to initialize admin sid.  Error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Get the user sid
    //

    pSidUser = GetUserSid(hTokenUser);
    if (pSidUser == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: GetUserSid returned NULL")));
        hr = E_FAIL; 
        goto Exit;
    }

    //
    // Check the owner
    //
    if (EqualSid(pSidAdmin, pSidOwner))
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: owner is admin")));
        hr = S_OK;
    }
    else if (EqualSid(pSidUser, pSidOwner))
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckRoamingShareOwnership: owner is the right user")));
        hr = S_OK;
    }
    else
    {
        LPTSTR  lpSidOwner = NULL;
        if (ConvertSidToStringSid(pSidOwner, &lpSidOwner))
        {
            DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: owner is %s!"), lpSidOwner));
            LocalFree(lpSidOwner);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CheckRoamingShareOwnership: owner is someone else!")));
        }
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_OWNER);
    }
        
    
Exit:
    if (psd)
    {
        LocalFree(psd);
    }

    if (pSidAdmin)
    {
        FreeSid(pSidAdmin);
    }

    if (pSidUser)
    {
        DeleteUserSid(pSidUser);
    }

    return hr;
}

//******************************************************************************
//
//  CProfileDialog::Initialize()
//
//  Purpose:    Generate a random security cookie and end point name used for 
//              IProfileDialog interface, tt will internally use CryptGenRandom().
//              The call is protected by a critical section to ensure thread safety,
//              i.e., only one thread will do the initialization, and it is only 
//              done once per process.
//
//  Parameters: 
//
//  Return:     S_OK on success, else for failure.
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              05/03/2002  mingzhu    Created
//
//******************************************************************************

HRESULT CProfileDialog::Initialize()
{
    HRESULT      hr = E_FAIL;
    BYTE         pbEndPointData[m_dwEndPointLen];    
    HCRYPTPROV   hCryptProv = NULL;
    BOOL         bGenerated = FALSE;
    DWORD        cchEndPoint;
    TCHAR        szHex[3];
    RPC_STATUS   status = RPC_S_OK;

    EnterCriticalSection(&m_cs);
    
    if (m_bInit)
    {
        hr = S_OK;
        goto Exit;
    }

    if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
         hr = HRESULT_FROM_WIN32(GetLastError());
         goto Exit;
    }
        
    if(!CryptGenRandom(hCryptProv, m_dwLen, m_pbCookie)) 
    {
         hr = HRESULT_FROM_WIN32(GetLastError());
         goto Exit;
    }

    if(!CryptGenRandom(hCryptProv, m_dwEndPointLen, pbEndPointData)) 
    {
         hr = HRESULT_FROM_WIN32(GetLastError());
         goto Exit;
    }

    //
    //  Make the endpoint name
    //

    cchEndPoint = m_dwEndPointLen * 2 + 1 + lstrlen(TEXT("IProfileDialog_"));

    m_szEndPoint = (LPTSTR) LocalAlloc (LPTR, cchEndPoint * sizeof(TCHAR));

    if (!m_szEndPoint)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    hr = StringCchCopy(m_szEndPoint, cchEndPoint, TEXT("IProfileDialog_"));
    if (FAILED(hr))
    {
        goto Exit;
    }

    for (DWORD i=0; i<m_dwEndPointLen; i++)
    {
        hr = StringCchPrintf(szHex, ARRAYSIZE(szHex), TEXT("%02X"), pbEndPointData[i]);
        if (FAILED(hr))
        {
            goto Exit;
        }
        hr = StringCchCat(m_szEndPoint, cchEndPoint, szHex);
        if (FAILED(hr))
        {
            goto Exit;
        }
    }


    //
    // Register the RPC endpoint, specify to use the local rpc protocol sequence 
    //

    status = RpcServerUseProtseqEp(cszRPCProtocol,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,  
                                   m_szEndPoint,
                                   NULL);
                                   
    if (status != RPC_S_OK)
    {
        hr = status;
        goto Exit;
    }

    bGenerated = TRUE;
    m_bInit = TRUE;
    hr = S_OK;
    
Exit:

    if (hr != S_OK && m_szEndPoint)
    {
        LocalFree(m_szEndPoint);
        m_szEndPoint = NULL;
    }

    LeaveCriticalSection(&m_cs);

    if (hCryptProv)
    {
        CryptReleaseContext(hCryptProv,0);
    }        

    if (bGenerated && (dwDebugLevel & DL_VERBOSE))
    {
        TCHAR   lpStringCookie[m_dwLen * 2 + 1] = TEXT("");
        DWORD   cchStringCookie = m_dwLen * 2 + 1;
        for (DWORD i=0; i<m_dwLen; i++)
        {
            StringCchPrintf(szHex, ARRAYSIZE(szHex), TEXT("%02X"), m_pbCookie[i]);
            StringCchCat(lpStringCookie, cchStringCookie, szHex);
        }
        DebugMsg((DM_VERBOSE, TEXT("CProfileDialog::Initialize : Cookie generated <%s>"), lpStringCookie));
        DebugMsg((DM_VERBOSE, TEXT("CProfileDialog::Initialize : Endpoint generated <%s>"), m_szEndPoint));
    }
   
    return hr;
}

//******************************************************************************
//
//  CProfileDialog::RegisterInterface()
//
//  Purpose:    Register the RPC interface for profile dialog.
//              We internally keep a ref count for this interface to ensure
//              thread safety.
//
//  Parameters: lppEndPoint - returned value for the end point name
//
//  Return:     S_OK on success, else for failure.
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              05/13/2002  mingzhu    Created
//
//******************************************************************************

HRESULT CProfileDialog::RegisterInterface(LPTSTR* lppEndPoint)
{
    HRESULT     hr;
    RPC_STATUS  status = RPC_S_OK;

    //
    //  Set the default return pointer
    //
    *lppEndPoint = NULL;
    
    //
    //  Initialize the cookie / endpoint
    //
    hr = Initialize();
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CProfileDialog::RegisterInterface: initialize failed, hr = %08X"), hr));
        goto Exit;        
    }
    
    //
    // Register the IUserProfile interface
    //
    if (InterlockedIncrement(&m_lRefCount) == 1)
    {
        status = RpcServerRegisterIfEx(IProfileDialog_v1_0_s_ifspec,      // interface to register
                                       NULL,                              // MgrTypeUuid
                                       NULL,                              // MgrEpv; null means use default
                                       RPC_IF_AUTOLISTEN,                 // auto-listen interface
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,    // max concurrent calls
                                       CProfileDialog::SecurityCallBack); // security callback
        if (status != RPC_S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CProfileDialog::RegisterInterface: RpcServerRegisterIfEx fails with error %ld"), status));
            hr = status;
            goto Exit;
        }
    }

    hr = S_OK;
    *lppEndPoint = m_szEndPoint;

Exit:
    return hr;
}

//******************************************************************************
//
//  CProfileDialog::UnRegisterInterface()
//
//  Purpose:    Unregister the dialog interface
//
//  Parameters: 
//
//  Return:     S_OK on successfully generated cookie, else for failure.
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              05/13/2002  mingzhu    Created
//
//******************************************************************************

HRESULT CProfileDialog::UnRegisterInterface()
{
    HRESULT hr;
    RPC_STATUS status = RPC_S_OK;

    if (InterlockedDecrement(&m_lRefCount) == 0)
    {
        // unregister the server endpoint
        status = RpcServerUnregisterIf(IProfileDialog_v1_0_s_ifspec, NULL, TRUE);
        if (status != RPC_S_OK) {
            DebugMsg((DM_WARNING, TEXT("UnRegisterErrorDialogInterface: RpcServerUnregisterIf fails with error %ld"), status));
        }
    }

    hr = status;
    return hr;
}

//*************************************************************
//
//  CProfileDialog::SecurityCallBack()
//
//  Purpose:    Security call back for IProfileDialog interface,
//              verify that the call is through LPRC.
//
//  Parameters: 
//              hIF      - RPC interface handle
//              hBinding - RPC binding for the interface
//
//  Return:     RPC_S_OK for checked call, exception will be
//              raised if check fails.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              03/12/2002  mingzhu    Created
//
//*************************************************************

RPC_STATUS RPC_ENTRY CProfileDialog::SecurityCallBack(RPC_IF_HANDLE hIF, handle_t hBinding)
{
    // Only allow LRPC traffic 
    if (!IsLRPC(hBinding)) 
        RpcRaiseException(ERROR_PROTOCOL_UNREACHABLE);

    DebugMsg((DM_VERBOSE, TEXT("CProfileDialog::SecurityCallBack: client authenticated.")));

    return RPC_S_OK;
}

//******************************************************************************
//
//  CheckXForestLogon()
//
//  Purpose:    Check if the user is logged on to a different forest, if yes, we
//              should disable roaming user profile for the user because of 
//              protential security risks. Administrator can set a policy
//              "AllowX-ForestPolicy-and-RUP" to disable this check.
//
//  Parameters: 
//              hTokenUser - user's token
//
//  Return:     S_OK on not x-forest logon, S_FALSE on x-forest logon,
//              else for failure
//
//  Comments:
//
//  History:    Date        Author     Comment
//              05/08/2002  mingzhu    Created
//
//******************************************************************************

HRESULT WINAPI CheckXForestLogon(HANDLE hTokenUser)
{
    HRESULT hr = E_FAIL;
    BOOL    bDisableCheck = FALSE;
    HKEY    hSubKey = NULL;
    DWORD   dwRegValue;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwErr;
    BOOL    bInThisForest = FALSE;

    //
    //  Output a debug message for entering the function.
    //
    
    DebugMsg((DM_VERBOSE, TEXT("CheckXForestLogon: checking x-forest logon, user handle = %d"), hTokenUser));

    //
    // Check for the policy to see if this check has been disabled
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwRegValue);
        if (RegQueryValueEx(hSubKey, TEXT("AllowX-ForestPolicy-and-RUP"), NULL, &dwType, (LPBYTE) &dwRegValue, &dwSize) == ERROR_SUCCESS)
        {
            bDisableCheck = (BOOL)(dwRegValue);   
        }
        RegCloseKey(hSubKey);
    }

    if (bDisableCheck)
    {
         DebugMsg((DM_VERBOSE, TEXT("CheckXForestLogon: policy set to disable XForest check")));
         hr = S_OK;
         goto Exit;
    }

    //
    //  Call CheckUserInMachineForest to get the cross forest information
    //

    dwErr = CheckUserInMachineForest(hTokenUser, &bInThisForest);
    
    if (dwErr != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CheckXForestLogon : CheckUserInMachineForest failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    // Check the result
    //

    if (bInThisForest)
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckXForestLogon: not XForest logon.")));
        hr = S_OK;
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("CheckXForestLogon: XForest logon!")));
        hr = S_FALSE;
    }

Exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\prof_guid.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//*************************************************************

#define INITGUID

#include <ole2.h>

// {eb7428f5-ab1f-4322-a4cc-1f1a9b2c5e98}
DEFINE_GUID(CLSID_CUserProfile, 
0xeb7428f5, 0xab1f, 0x4322, 0xa4, 0xcc, 0x1f, 0x1a, 0x9b, 0x2c, 0x5e, 0x98);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\profile.h ===
//*************************************************************
//
//  Header file for Profile.cpp
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Internal flags
//

#define PROFILE_MANDATORY       0x00000001
#define PROFILE_USE_CACHE       0x00000002
#define PROFILE_NEW_LOCAL       0x00000004
#define PROFILE_NEW_CENTRAL     0x00000008
#define PROFILE_UPDATE_CENTRAL  0x00000010
#define PROFILE_DELETE_CACHE    0x00000020
// do not define bit 40 because NT4 has this defined as Run_SyncApps.
#define PROFILE_GUEST_USER      0x00000080
#define PROFILE_ADMIN_USER      0x00000100
#define DEFAULT_NET_READY       0x00000200
#define PROFILE_SLOW_LINK       0x00000400
#define PROFILE_TEMP_ASSIGNED   0x00000800
// do not define bit 1000, this was used briefly 2009, 2010 before
#define PROFILE_PARTLY_LOADED   0x00002000
#define PROFILE_BACKUP_EXISTS   0x00004000
#define PROFILE_THIS_IS_BAK     0x00008000
#define PROFILE_READONLY        0x00010000
#define PROFILE_LOCALMANDATORY  0x00020000

//
// Registry key names
//

#define USER_CLASSES_HIVE_SUFFIX   TEXT("_Classes")
#define USER_KEY_PREFIX            TEXT("\\Registry\\User\\")

//
// Local system name
//

#define LOCAL_SYSTEM_NAME          L"NT AUTHORITY\\SYSTEM"

//
// User Preference values
//

#define USERINFO_LOCAL                   0
#define USERINFO_FLOATING                1
#define USERINFO_MANDATORY               2
#define USERINFO_BACKUP                  3
#define USERINFO_TEMP                    4
#define USERINFO_UNDEFINED              99

#define PROFILEERRORACTION_TEMP          0
#define PROFILEERRORACTION_LOGOFF        1

typedef struct _PROFILE {
    DWORD       dwFlags;
    DWORD       dwInternalFlags;
    DWORD       dwUserPreference;
    HANDLE      hTokenUser;
    HANDLE      hTokenClient;
    LPTSTR      lpUserName;
    LPTSTR      lpProfilePath;
    LPTSTR      lpRoamingProfile;
    LPTSTR      lpDefaultProfile;
    LPTSTR      lpLocalProfile;
    LPTSTR      lpPolicyPath;
    LPTSTR      lpServerName;
    HKEY        hKeyCurrentUser;
    FILETIME    ftProfileLoad;
    FILETIME    ftProfileUnload;
    LPTSTR      lpExclusionList;
} USERPROFILE, *LPPROFILE;

typedef struct _SLOWLINKDLGINFO {
    DWORD       dwTimeout;
    BOOL        bSyncDefault;
} SLOWLINKDLGINFO, FAR *LPSLOWLINKDLGINFO;

static LPWSTR cszRPCProtocol = L"ncalrpc";
static LPWSTR cszRPCEndPoint = L"IUserProfile"; // Do not change this name, SENS will use it as an endpoint to winlogon
static DWORD  cdwMaxRpcCalls = 1000000;

// structure used to store client context
typedef struct _CLIENTINFO 
{
    HANDLE         hClientToken;
    LPPROFILEINFO  pProfileInfo;
}CLIENTINFO, *PCLIENTINFO;

#if defined(__cplusplus)
extern "C"{
#endif
LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile);
BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey);
BOOL SetupNewHive(LPPROFILE lpProfile, LPTSTR lpSidString, PSID pSid);
BOOL DeleteProfileEx (LPCTSTR lpSidString, LPTSTR lpLocalProfile, DWORD dwDeleteFlags, HKEY hKeyLM, LPCTSTR szComputerName);
BOOL ComputeLocalProfileName (LPPROFILE lpProfile, LPCTSTR lpUserName,
                              LPTSTR lpProfileImage, DWORD  cchMaxProfileImage,
                              LPTSTR lpExpProfileImage, DWORD  cchMaxExpProfileImage,
                              PSID pSid, BOOL bWin9xUpg);
BOOL SetDefaultUserHiveSecurity(LPPROFILE lpProfile, PSID pSid, HKEY RootKey);
LONG LoadUserClasses( LPPROFILE lpProfile, LPTSTR SidString, BOOL bNewlyIssued);
BOOL UnloadClasses(LPTSTR lpSidString);
BOOL CreateSecureDirectory (LPPROFILE lpProfile, LPTSTR lpDirectory, PSID pSid, BOOL fRestricted);
#if defined(__cplusplus)
}
#endif

#define DP_BACKUP       1
#define DP_BACKUPEXISTS 2
#define DP_DELBACKUP    4

BOOL MoveUserProfiles (LPCTSTR lpSrcDir, LPCTSTR lpDestDir);
LPTSTR GetProfileSidString(HANDLE hToken);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\userdiff.h ===
//*************************************************************
//
//   userdiff.h     -   Header file for userdiff.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define USERDIFF            TEXT("UserDiff")
#define USERDIFR_LOCATION   TEXT("%SystemRoot%\\system32\\config\\userdifr")
#define USERDIFF_LOCATION   TEXT("%SystemRoot%\\system32\\config\\userdiff")


//
// Hive processing key words
//

#define UD_ACTION              TEXT("Action")
#define UD_KEYNAME             TEXT("KeyName")
#define UD_VALUE               TEXT("Value")
#define UD_VALUENAME           TEXT("ValueName")
#define UD_VALUENAMES          TEXT("ValueNames")
#define UD_FLAGS               TEXT("Flags")
#define UD_ITEM                TEXT("Item")
#define UD_COMMANDLINE         TEXT("CommandLine")
#define UD_PRODUCTTYPE         TEXT("Product")



#define MAX_BUILD_NUMBER    30

typedef struct _UDNODE {
    TCHAR           szBuildNumber[MAX_BUILD_NUMBER];
    DWORD           dwBuildNumber;
    struct _UDNODE *pNext;
} UDNODE, * LPUDNODE;


#if defined(__cplusplus)
extern "C" {
#endif
BOOL ProcessUserDiff (LPPROFILE lpProfile, DWORD dwBuildNumber, LPVOID pEnv);
#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\setup.c ===
//*************************************************************
//
//  SETUP.C  -    API's used by setup to create groups/items
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <uenv.h>
#include <sddl.h>   // ConvertStringSecurityDescriptorToSecurityDescriptor
#include <aclapi.h>
#include "strsafe.h"


// See ConvertStringSecurityDescriptorToSecurityDescriptor documentation
// for a description of the string security descriptor format.
//
// These ACLs are setup to allow
//      System, Administrators, Creator-Owner: Full Control
//      Power  Users: Modify (RWXD)
//      Users: Read (RX)
//      Users: Write (folders only)
//
// The combination of "Users: Write (folders only)" and the Creator-Owner ACE
// means that restricted users can create subfolders and files, and have full
// control to files that they create, but they cannot modify or delete files
// created by someone else.

const TCHAR c_szCommonDocumentsACL[] = TEXT("D:P(A;CIOI;GA;;;SY)(A;CIOI;GA;;;BA)(A;CIOIIO;GA;;;CO)(A;CIOI;GRGWGXSD;;;PU)(A;CIOI;GRGX;;;BU)(A;CI;0x116;;;BU)");
const TCHAR c_szCommonAppDataACL[]   = TEXT("D:P(A;CIOI;GA;;;SY)(A;CIOI;GA;;;BA)(A;CIOIIO;GA;;;CO)(A;CIOI;GRGWGXSD;;;PU)(A;CIOI;GRGX;;;BU)(A;CI;0x116;;;BU)");

const TCHAR c_szProfileEnvName[] = TEXT("PROFILES");

BOOL PrependPath(LPCTSTR szFile, LPTSTR szResult, UINT cchResult);
BOOL CheckProfile (LPTSTR lpProfilesDir, LPTSTR lpProfileValue,
                   LPTSTR lpProfileName);
void HideSpecialProfiles(void);
void SetAclForSystemProfile(PSID pSidSystem, LPTSTR szExpandedProfilePath);

HRESULT ReaclProfileListEntries();
HRESULT CallFaxServiceAPI();
HRESULT PrepareEnvironmentVariables();
HRESULT SecureCommonProfiles();
HRESULT SecurePerUserProfiles();


//
//  Tell whether the setup is a clean install
//

static  BOOL    g_bCleanInstall;


//*************************************************************
//
//  CreateGroup()
//
//  Purpose:    Creates a program group (sub-directory)
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              3/29/00     AlexArm    Split into CreateGroup
//                                     and CreateGroupEx
//
//*************************************************************

BOOL WINAPI CreateGroup(LPCTSTR lpGroupName, BOOL bCommonGroup)
{
    //
    // Call CreateGroupEx with no name.
    //
    return CreateGroupEx( lpGroupName, bCommonGroup, NULL, 0 );
}

//*************************************************************
//
//  CreateGroupEx()
//
//  Purpose:    Creates a program group (sub-directory) and sets
//              the localized name for the program group
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//              lpResourceModuleName - Name of the resource module.
//              uResourceID     - Resource ID for the MUI display name.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              3/29/00     AlexArm    Split into CreateGroup
//                                     and CreateGroupEx
//
//*************************************************************

BOOL WINAPI CreateGroupEx(LPCWSTR lpGroupName, BOOL bCommonGroup,
                          LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    TCHAR        szDirectory[MAX_PATH];
    LPTSTR       lpEnd;
    LPTSTR       lpAdjustedGroupName;
    int          csidl;
    PSHELL32_API pShell32Api;
    DWORD        dwResult;
    UINT         cchEnd;
    HRESULT      hr;

    //
    // Validate parameters
    //

    if (!lpGroupName || !(*lpGroupName)) {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  Failing due to NULL group name.")));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Entering with <%s>."), lpGroupName));


    if ( ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Extract the CSIDL (if any) from lpGroupName
    //

    csidl = ExtractCSIDL(lpGroupName, &lpAdjustedGroupName);

    if (-1 != csidl)
    {
        //
        // Use this csidl
        // WARNING: if a CSIDL is provided, the bCommonGroup flag is meaningless
        //

        DebugMsg((DM_VERBOSE,
            TEXT("CreateGroupEx:  CSIDL = <0x%x> contained in lpGroupName replaces csidl."),
            csidl));
    }
    else
    {
        //
        // Default to CSIDL_..._PROGRAMS
        //
        csidl = bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS;
    }

    //
    // Get the programs directory
    //

    if (!GetSpecialFolderPath (csidl, szDirectory)) {
        return FALSE;
    }


    //
    // Now append the requested directory
    //

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  CheckSlashEx failed.")));
        return FALSE;
    }
    
    hr = StringCchCopy (lpEnd, cchEnd, lpAdjustedGroupName);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  StringCchCopy failed.")));
        return FALSE;
    }


    //
    // Create the group (directory)
    //
    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Calling CreatedNestedDirectory with <%s>"),
        szDirectory));

    if (!CreateNestedDirectory(szDirectory, NULL)) {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  CreatedNestedDirectory failed.")));
        return FALSE;
    }

    //
    // If the localized name is specified, set it.
    //
    if (lpResourceModuleName != NULL) {
        DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Calling SHSetLocalizedName.")));
        dwResult = pShell32Api->pfnShSetLocalizedName(szDirectory,
            lpResourceModuleName, uResourceID);
        if (dwResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  SHSetLocalizedName failed <0x%x>."),
                     dwResult));
            return FALSE;
        }
    }

    //
    // Success
    //

    pShell32Api->pfnShChangeNotify (SHCNE_MKDIR, SHCNF_PATH, szDirectory, NULL);

    DebugMsg((DM_VERBOSE, TEXT("CreateGroupEx:  Leaving successfully.")));

    return TRUE;
}


//*************************************************************
//
//  DeleteGroup()
//
//  Purpose:    Deletes a program group (sub-directory)
//
//  Parameters: lpGroupName     -   Name of group
//              bCommonGroup    -   Common or Personal group
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI DeleteGroup(LPCTSTR lpGroupName, BOOL bCommonGroup)
{
    TCHAR     szDirectory[MAX_PATH];
    LPTSTR    lpEnd;
    LPTSTR    lpAdjustedGroupName;
    int       csidl;
    PSHELL32_API pShell32Api;
    UINT      cchEnd;
    HRESULT   hr;

    //
    // Validate parameters
    //

    if (!lpGroupName || !(*lpGroupName)) {
        DebugMsg((DM_WARNING, TEXT("DeleteGroup:  Failing due to NULL group name.")));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Entering with <%s>."), lpGroupName));

    if (ERROR_SUCCESS !=  LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Extract the CSIDL (if any) from lpGroupName
    //

    csidl = ExtractCSIDL(lpGroupName, &lpAdjustedGroupName);

    if (-1 != csidl)
    {
        //
        // Use this csidl
        // WARNING: if a CSIDL is provided, the bCommonGroup flag is meaningless
        //

        DebugMsg((DM_VERBOSE,
            TEXT("DeleteGroup:  CSIDL = <0x%x> contained in lpGroupName replaces csidl."),
            csidl));
    }
    else
    {
        //
        // Default to CSIDL_..._PROGRAMS
        //

        csidl = bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS;
    }

    //
    // Get the programs directory
    //

    if (!GetSpecialFolderPath (csidl, szDirectory)) {
        return FALSE;
    }


    //
    // Now append the requested directory
    //

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  CheckSlashEx failed.")));
        return FALSE;
    }
    
    hr = StringCchCopy (lpEnd, cchEnd, lpAdjustedGroupName);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateGroupEx:  StringCchCopy failed.")));
        return FALSE;
    }


    //
    // Delete the group (directory)
    //

    if (!Delnode(szDirectory)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Delnode failed.")));
        return FALSE;
    }


    //
    // Success
    //
    pShell32Api->pfnShChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szDirectory, NULL);

    DebugMsg((DM_VERBOSE, TEXT("DeleteGroup:  Leaving successfully.")));

    return TRUE;
}

//*************************************************************
//
//  CreateLinkFile()
//
//  Purpose:    Creates a link file in the specified directory
//
//  Parameters: cidl            -   CSIDL_ of a special folder
//              lpSubDirectory  -   Subdirectory of special folder
//              lpFileName      -   File name of item
//              lpCommandLine   -   Command line (including args)
//              lpIconPath      -   Icon path (can be NULL)
//              iIconIndex      -   Index of icon in icon path
//              lpWorkingDir    -   Working directory
//              wHotKey         -   Hot key
//              iShowCmd        -   ShowWindow flag
//              lpDescription   -   Description of the item
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateLinkFile(INT     csidl,              LPCTSTR lpSubDirectory,
                           LPCTSTR lpFileName,         LPCTSTR lpCommandLine,
                           LPCTSTR lpIconPath,         int iIconIndex,
                           LPCTSTR lpWorkingDirectory, WORD wHotKey,
                           int     iShowCmd,           LPCTSTR lpDescription)
{
    return CreateLinkFileEx(csidl, lpSubDirectory, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory, wHotKey,
                            iShowCmd, lpDescription, NULL, 0);
}
//*************************************************************
//
//  CreateLinkFileEx()
//
//  Purpose:    Creates a link file in the specified directory
//
//  Parameters: cidl            -   CSIDL_ of a special folder
//              lpSubDirectory  -   Subdirectory of special folder
//              lpFileName      -   File name of item
//              lpCommandLine   -   Command line (including args)
//              lpIconPath      -   Icon path (can be NULL)
//              iIconIndex      -   Index of icon in icon path
//              lpWorkingDir    -   Working directory
//              wHotKey         -   Hot key
//              iShowCmd        -   ShowWindow flag
//              lpDescription   -   Description of the item
//              lpResourceModuleName - Name of the resource module.
//              uResourceID     - Resource ID for the MUI display name.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************


BOOL WINAPI CreateLinkFileEx(INT     csidl,                LPCTSTR lpSubDirectory,
                             LPCTSTR lpFileName,           LPCTSTR lpCommandLine,
                             LPCTSTR lpIconPath,           int iIconIndex,
                             LPCTSTR lpWorkingDirectory,   WORD wHotKey,
                             int     iShowCmd,             LPCTSTR lpDescription,
                             LPCWSTR lpResourceModuleName, UINT uResourceID)
{
    TCHAR                szItem[MAX_PATH];
    TCHAR                szArgs[MAX_PATH];
    TCHAR                szLinkName[MAX_PATH];
    TCHAR                szPath[MAX_PATH];
    LPTSTR               lpArgs, lpEnd;
    IShellLink          *psl;
    IPersistFile        *ppf;
    BOOL                 bRetVal = FALSE;
    HINSTANCE            hInstOLE32 = NULL;
    PFNCOCREATEINSTANCE  pfnCoCreateInstance;
    PFNCOINITIALIZE      pfnCoInitialize;
    PFNCOUNINITIALIZE    pfnCoUninitialize;
    LPTSTR               lpAdjustedSubDir = NULL;
    PSHELL32_API         pShell32Api;
    PSHLWAPI_API         pShlwapiApi;
    DWORD                dwResult;
    UINT                 cchEnd;
    HRESULT              hr;

    //
    // Verbose output
    //

#if DBG
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  csidl = <0x%x>."), csidl));
    if (lpSubDirectory && *lpSubDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpSubDirectory = <%s>."), lpSubDirectory));
    }
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpFileName = <%s>."), lpFileName));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpCommandLine = <%s>."), lpCommandLine));

    if (lpIconPath) {
       DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpIconPath = <%s>."), lpIconPath));
       DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  iIconIndex = <%d>."), iIconIndex));
    }

    if (lpWorkingDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpWorkingDirectory = <%s>."), lpWorkingDirectory));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Null working directory.  Setting to %%HOMEDRIVE%%%%HOMEPATH%%")));
    }

    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  wHotKey = <%d>."), wHotKey));
    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  iShowCmd = <%d>."), iShowCmd));

    if (lpDescription) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  lpDescription = <%s>."), lpDescription));
    } else {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Null description.")));
    }
#endif

    //
    // Load a few functions we need
    //

    hInstOLE32 = LoadLibrary (TEXT("ole32.dll"));

    if (!hInstOLE32) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to load ole32 with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }


    pfnCoCreateInstance = (PFNCOCREATEINSTANCE)GetProcAddress (hInstOLE32,
                                        "CoCreateInstance");

    if (!pfnCoCreateInstance) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoCreateInstance with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    pfnCoInitialize = (PFNCOINITIALIZE)GetProcAddress (hInstOLE32,
                                                       "CoInitialize");

    if (!pfnCoInitialize) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoInitialize with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    pfnCoUninitialize = (PFNCOUNINITIALIZE)GetProcAddress (hInstOLE32,
                                                          "CoUninitialize");

    if (!pfnCoUninitialize) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to find CoUninitialize with %d."),
                 GetLastError()));
        goto ExitNoFree;
    }

    if (ERROR_SUCCESS != LoadShell32Api( &pShell32Api ) ) {
        goto ExitNoFree;
    }


    pShlwapiApi = LoadShlwapiApi();

    if ( !pShlwapiApi ) {
        goto ExitNoFree;
    }

    //
    // Get the special folder directory
    // First check if there is a CSIDL in the subdirectory
    //

    if (lpSubDirectory && *lpSubDirectory) {

        int csidl2 = ExtractCSIDL(lpSubDirectory, &lpAdjustedSubDir);

        if (-1 != csidl2)
        {
            csidl = csidl2;
            DebugMsg((DM_VERBOSE,
                TEXT("CreateLinkFileEx:  CSIDL = <0x%x> contained in lpSubDirectory replaces csidl."),
                csidl));
        }
    }

    szLinkName[0] = TEXT('\0');
    if (csidl && !GetSpecialFolderPath (csidl, szLinkName)) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to get profiles directory.")));
        goto ExitNoFree;
    }


    if (lpAdjustedSubDir && *lpAdjustedSubDir) {

        if (szLinkName[0] != TEXT('\0')) {
            lpEnd = CheckSlashEx (szLinkName, ARRAYSIZE(szLinkName), &cchEnd);
            if (!lpEnd)
            {
                DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  CheckSlashEx failed")));
                goto ExitNoFree;
            }

        } else {
            lpEnd = szLinkName;
            cchEnd = ARRAYSIZE(szLinkName);
        }

        
        hr = StringCchCopy (lpEnd, cchEnd, lpAdjustedSubDir);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  StringCchCopy failed")));
            goto ExitNoFree;
        }
    }


    //
    // Create the target directory
    //

    if (!CreateNestedDirectory(szLinkName, NULL)) {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Failed to create subdirectory <%s> with %d"),
                 szLinkName, GetLastError()));
        goto ExitNoFree;
    }


    //
    // Now tack on the filename and extension.
    //

    lpEnd = CheckSlashEx (szLinkName, ARRAYSIZE(szLinkName), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  CheckSlashEx failed")));
        goto ExitNoFree;
    }

    hr = StringCchCopy (lpEnd, cchEnd, lpFileName);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  StringCchCopy failed")));
        goto ExitNoFree;
    }

    hr = StringCchCat (lpEnd, cchEnd, c_szLNK);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  StringCchCat failed")));
        goto ExitNoFree;
    }
    


    //
    // Split the command line into the executable name
    // and arguments.
    //

    StringCchCopy (szItem, ARRAYSIZE(szItem), lpCommandLine);

    lpArgs = pShlwapiApi->pfnPathGetArgs(szItem);

    if (*lpArgs) {
        StringCchCopy (szArgs, ARRAYSIZE(szArgs), lpArgs);

        lpArgs--;
        while (*lpArgs == TEXT(' ')) {
            lpArgs--;
        }
        lpArgs++;
        *lpArgs = TEXT('\0');
    } else {
        szArgs[0] = TEXT('\0');
    }

    pShlwapiApi->pfnPathUnquoteSpaces (szItem);


    //
    // Create an IShellLink object
    //

    pfnCoInitialize(NULL);

    if (FAILED(pfnCoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                              &IID_IShellLink, (LPVOID*)&psl)))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  Could not create instance of IShellLink .")));
        goto ExitNoFree;
    }


    //
    // Query for IPersistFile
    //

    if (FAILED(psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf)))
    {
        DebugMsg((DM_WARNING, TEXT("CreateLinkFileEx:  QueryInterface of IShellLink failed.")));
        goto ExitFreePSL;
    }

    //
    // Set the item information
    //

    if (lpDescription) {
        psl->lpVtbl->SetDescription(psl, lpDescription);
    }

    PrependPath(szItem, szPath, ARRAYSIZE(szPath));
    psl->lpVtbl->SetPath(psl, szPath);


    psl->lpVtbl->SetArguments(psl, szArgs);
    if (lpWorkingDirectory) {
        psl->lpVtbl->SetWorkingDirectory(psl, lpWorkingDirectory);
    } else {
        psl->lpVtbl->SetWorkingDirectory(psl, TEXT("%HOMEDRIVE%%HOMEPATH%"));
    }

    PrependPath(lpIconPath, szPath, ARRAYSIZE(szPath));
    psl->lpVtbl->SetIconLocation(psl, szPath, iIconIndex);

    psl->lpVtbl->SetHotkey(psl, wHotKey);
    psl->lpVtbl->SetShowCmd(psl, iShowCmd);


    //
    // If the localized name is specified, set it.
    //

    if (lpResourceModuleName != NULL) {
        DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Calling SHSetLocalizedName on link <%s>."), szLinkName));
        ppf->lpVtbl->Save(ppf, szLinkName, TRUE);
        dwResult = pShell32Api->pfnShSetLocalizedName(szLinkName,
                                                    lpResourceModuleName, uResourceID);
        if (dwResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  SHSetLocalizedName failed <0x%x>."),
                     dwResult));
            goto ExitFreePSL;
        }
    }

    //
    // Save the item to disk
    //

    bRetVal = SUCCEEDED(ppf->lpVtbl->Save(ppf, szLinkName, TRUE));

    if (bRetVal) {
        pShell32Api->pfnShChangeNotify (SHCNE_CREATE, SHCNF_PATH, szLinkName, NULL);
    }

    //
    // Release the IPersistFile object
    //

    ppf->lpVtbl->Release(ppf);


ExitFreePSL:

    //
    // Release the IShellLink object
    //

    psl->lpVtbl->Release(psl);

    pfnCoUninitialize();

ExitNoFree:

    if (hInstOLE32) {
        FreeLibrary (hInstOLE32);
    }

    //
    // Finished.
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateLinkFileEx:  Leaving with status of %d."), bRetVal));

    return bRetVal;
}


//*************************************************************
//
//  DeleteLinkFile()
//
//  Purpose:    Deletes the specified link file
//
//  Parameters: csidl               -   CSIDL of a special folder
//              lpSubDirectory      -   Subdirectory of special folder
//              lpFileName          -   File name of item
//              bDeleteSubDirectory -   Delete the subdirectory if possible
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/26/98     ericflo    Created
//
//*************************************************************

BOOL WINAPI DeleteLinkFile(INT csidl, LPCTSTR lpSubDirectory,
                           LPCTSTR lpFileName, BOOL bDeleteSubDirectory)
{
    TCHAR   szLinkName[MAX_PATH];
    LPTSTR  lpEnd;
    LPTSTR  lpAdjustedSubDir = NULL;
    PSHELL32_API pShell32Api;
    UINT    cchEnd;
    HRESULT hr;

    //
    // Verbose output
    //

#if DBG

    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  Entering.")));
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  csidl = 0x%x."), csidl));
    if (lpSubDirectory && *lpSubDirectory) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  lpSubDirectory = <%s>."), lpSubDirectory));
    }
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  lpFileName = <%s>."), lpFileName));
    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  bDeleteSubDirectory = %d."), bDeleteSubDirectory));

#endif

    if (ERROR_SUCCESS != LoadShell32Api( &pShell32Api ) ) {
        return FALSE;
    }

    //
    // Get the special folder directory
    // First check if there is a CSIDL in the subdirectory
    //

    if (lpSubDirectory && *lpSubDirectory) {

        int csidl2 = ExtractCSIDL(lpSubDirectory, &lpAdjustedSubDir);

        if (-1 != csidl2)
        {
            csidl = csidl2;
            DebugMsg((DM_VERBOSE,
                TEXT("CreateLinkFile:  CSIDL = <0x%x> contained in lpSubDirectory replaces csidl."),
                csidl));
        }
    }

    szLinkName[0] = TEXT('\0');
    if (csidl && !GetSpecialFolderPath (csidl, szLinkName)) {
        return FALSE;
    }

    if (lpAdjustedSubDir && *lpAdjustedSubDir) {

        if (szLinkName[0] != TEXT('\0')) {
            lpEnd = CheckSlashEx (szLinkName, ARRAYSIZE(szLinkName), &cchEnd);
            if (!lpEnd)
            {
                DebugMsg((DM_WARNING, TEXT("DeleteLinkFile:  CheckSlashEx failed")));
                return FALSE;
            }

        } else {
            lpEnd = szLinkName;
            cchEnd = ARRAYSIZE(szLinkName);
        }

        
        hr = StringCchCopy (lpEnd, cchEnd, lpAdjustedSubDir);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DeleteLinkFile:  StringCchCopy failed")));
            return FALSE;
        }
    }

    //
    // Now tack on the filename and extension.
    //

    lpEnd = CheckSlashEx (szLinkName, ARRAYSIZE(szLinkName), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("DeleteLinkFile:  CheckSlashEx failed")));
        return FALSE;
    }

    hr = StringCchCopy (lpEnd, cchEnd, lpFileName);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DeleteLinkFile:  StringCchCopy failed")));
        return FALSE;
    }

    hr = StringCchCat (lpEnd, cchEnd, c_szLNK);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DeleteLinkFile:  StringCchCat failed")));
        return FALSE;
    }
    
    //
    // Delete the file
    //

    if (!DeleteFile (szLinkName)) {
        DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile: Failed to delete <%s>.  Error = %d"),
                szLinkName, GetLastError()));
        return FALSE;
    }

    pShell32Api->pfnShChangeNotify (SHCNE_DELETE, SHCNF_PATH, szLinkName, NULL);

    //
    // Delete the subdirectory if appropriate (and possible).
    //

    if (bDeleteSubDirectory) {
        *(lpEnd-1) = TEXT('\0');
        if (RemoveDirectory(szLinkName)) {
            pShell32Api->pfnShChangeNotify (SHCNE_RMDIR, SHCNF_PATH, szLinkName, NULL);
        }
    }

    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("DeleteLinkFile:  Leaving successfully.")));

    return TRUE;
}

//*************************************************************
//
//  PrependPath()
//
//  Purpose:    Expands the given filename to have %systemroot%
//              if appropriate
//
//  Parameters: lpFile   -  File to check
//              lpResult -  Result buffer (MAX_PATH chars in size)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/11/95    ericflo    Created
//
//*************************************************************

BOOL PrependPath(LPCTSTR lpFile, LPTSTR lpResult, UINT cchResult)
{
    TCHAR szReturn [MAX_PATH];
    LPTSTR lpFileName;
    DWORD dwSysLen;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("PrependPath: Entering with <%s>"),
             lpFile ? lpFile : TEXT("NULL")));


    if (!lpFile || !*lpFile) {
        DebugMsg((DM_VERBOSE, TEXT("PrependPath: lpFile is NULL, setting lpResult to a null string")));
        *lpResult = TEXT('\0');
        return TRUE;
    }


    //
    // Call SearchPath to find the filename
    //

    if (!SearchPath (NULL, lpFile, TEXT(".exe"), MAX_PATH, szReturn, &lpFileName)) {
        DebugMsg((DM_VERBOSE, TEXT("PrependPath: SearchPath failed with error %d.  Using input string"), GetLastError()));
        StringCchCopy (lpResult, cchResult, lpFile);
        return TRUE;
    }


    UnExpandSysRoot(szReturn, lpResult, cchResult);

    DebugMsg((DM_VERBOSE, TEXT("PrependPath: Leaving with <%s>"), lpResult));

    return TRUE;
}


//*************************************************************
//
//  SetFilePermissions()
//
//  Purpose:    Sets the given permissions on a file or directory
//
//  Parameters: lpFile  -   File to set security on
//              pszSD   -   String security descriptor
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              01/25/2001  jeffreys   Created
//
//*************************************************************

BOOL SetFilePermissions(LPCTSTR lpFile, LPCTSTR pszSD)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL bRetVal = FALSE;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(pszSD, SDDL_REVISION, &pSD, NULL) && pSD)
    {
        //
        // Set the security
        //
        if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, pSD))
        {
            bRetVal = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("SetFilePermissions: SetFileSecurity failed.  Error = %d"), GetLastError()));
        }

        LocalFree(pSD);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("SetFilePermissions: ConvertStringSDToSD failed.  Error = %d"), GetLastError()));
    }

    return bRetVal;
}


//*************************************************************
//
//  ConvertCommonGroups()
//
//  Purpose:    Calls grpconv.exe to convert progman common groups
//              to Explorer common groups, and create floppy links.
//
//              NT 4 appended " (Common)" to the common groups.  For
//              NT 5, we are going to remove this tag.
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//  Comments:
//
//  History:    Date        Author     Comment
//              10/1/95     ericflo    Created
//              12/5/96     ericflo    Remove common tag
//
//*************************************************************

BOOL ConvertCommonGroups (void)
{
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Result;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    DWORD dwType, dwSize, dwConvert;
    BOOL bRunGrpConv = TRUE;
    LONG lResult;
    HKEY hKey;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    TCHAR szCommon[30] = {0};
    UINT cchCommon, cchFileName;
    LPTSTR lpTag, lpEnd, lpEnd2;
    UINT cchEnd, cchEnd2;
    HRESULT hr;


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Entering.")));


    //
    // Check if we have run grpconv before.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Program Groups"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwConvert);

        lResult = RegQueryValueEx (hKey,
                                   TEXT("ConvertedToLinks"),
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwConvert,
                                   &dwSize);

        if (lResult == ERROR_SUCCESS) {

            //
            // If dwConvert is 1, then grpconv has run before.
            // Don't run it again.
            //

            if (dwConvert) {
                bRunGrpConv = FALSE;
            }
        }

        //
        // Now set the value to prevent grpconv from running in the future
        //

        dwConvert = 1;
        RegSetValueEx (hKey,
                       TEXT("ConvertedToLinks"),
                       0,
                       REG_DWORD,
                       (LPBYTE) &dwConvert,
                       sizeof(dwConvert));


        RegCloseKey (hKey);
    }


    if (bRunGrpConv) {

        //
        // Initialize process startup info
        //

        si.cb = sizeof(STARTUPINFO);
        si.lpReserved = NULL;
        si.lpDesktop = NULL;
        si.lpTitle = NULL;
        si.dwFlags = 0;
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;


        //
        // Spawn grpconv
        //

        StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), TEXT("grpconv -n"));

        Result = CreateProcess(
                          NULL,
                          szBuffer,
                          NULL,
                          NULL,
                          FALSE,
                          NORMAL_PRIORITY_CLASS,
                          NULL,
                          NULL,
                          &si,
                          &ProcessInformation
                          );

        if (!Result) {
            DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  grpconv failed to start due to error %d."), GetLastError()));
            return FALSE;

        } else {

            //
            // Wait for up to 2 minutes
            //

            WaitForSingleObject(ProcessInformation.hProcess, 120000);

            //
            // Close our handles to the process and thread
            //

            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        }
    }


    //
    //  Loop through all the program groups in the All Users profile
    //  and remove the " (Common)" tag.
    //

    LoadString (g_hDllInstance, IDS_COMMON, szCommon, 30);
    cchCommon = lstrlen (szCommon);

    if (!GetSpecialFolderPath (CSIDL_COMMON_PROGRAMS, szBuffer2)) {
        return FALSE;
    }
    StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), szBuffer2);

    lpEnd = CheckSlashEx (szBuffer, ARRAYSIZE(szBuffer), &cchEnd);
    lpEnd2 = CheckSlashEx (szBuffer2, ARRAYSIZE(szBuffer2), &cchEnd2);
    if (!lpEnd || !lpEnd2)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  CheckSlashEx failed.")));
        return FALSE;
    }

    hr = StringCchCopy (lpEnd, cchEnd, c_szStarDotStar);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  StringCchCopy failed.")));
        return FALSE;
    }

    hFile = FindFirstFile (szBuffer, &fd);

    if (hFile != INVALID_HANDLE_VALUE) {

        do  {

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                cchFileName = lstrlen (fd.cFileName);

                if (cchFileName > cchCommon) {
                    lpTag = fd.cFileName + cchFileName - cchCommon;

                    if (!lstrcmpi(lpTag, szCommon)) {

                        hr = StringCchCopy (lpEnd, cchEnd, fd.cFileName);
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  StringCchCopy failed.")));
                            continue;
                        }
                        *lpTag = TEXT('\0');
                        hr = StringCchCopy (lpEnd2, cchEnd2, fd.cFileName);
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("ConvertCommonGroups:  StringCchCopy failed.")));
                            continue;
                        }

                        if (MoveFileEx (szBuffer, szBuffer2, MOVEFILE_REPLACE_EXISTING)) {

                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Successfully changed group name:")));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      Orginial:  %s"), szBuffer));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      New:       %s"), szBuffer2));

                        } else {
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Failed to change group name with error %d."), GetLastError()));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      Orginial:  %s"), szBuffer));
                            DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:      New:       %s"), szBuffer2));
                        }
                    }
                }
            }

        } while (FindNextFile(hFile, &fd));

        FindClose (hFile);
    }


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ConvertCommonGroups:  Leaving Successfully.")));

    return TRUE;
}

//*************************************************************
//
//  DetermineProfilesLocation()
//
//  Purpose:    Determines if the profiles directory
//              should be in the old NT4 location or
//              the new NT5 location
//
//  Parameters: none
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL WINAPI DetermineProfilesLocation (BOOL bCleanInstall)
{
    TCHAR szDirectory[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    PTSTR szCurDest;
    PCTSTR szLookAhead;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DWORD dwSize, dwDisp;
    HKEY hKey;
    LPTSTR lpEnd;
    UINT cchEnd;
    HRESULT hr;

    //
    //  Save the clean install flag
    //

    g_bCleanInstall = bCleanInstall;

    //
    //  First, try to delete the previous userenv logs
    //

    DeletePreviousLogFiles();

    //
    // Check for an unattended entry first
    //

    if (bCleanInstall) {

        if (FAILED(SafeExpandEnvironmentStrings (TEXT("%SystemRoot%\\System32\\$winnt$.inf"), szDirectory,
                                       ARRAYSIZE(szDirectory)))) {

            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  ExpandEnvironmentStrings failed with error %d"), GetLastError()));
            return FALSE;
        }

        szDest[0] = TEXT('\0');
        GetPrivateProfileString (TEXT("guiunattended"), TEXT("profilesdir"), TEXT(""),
                                 szDest, MAX_PATH, szDirectory);

        if (szDest[0] != TEXT('\0')) {

            //
            // Since $winnt$.inf is an INF, we must strip out %% pairs
            //

            szCurDest = szDest;
            szLookAhead = szDest;

#ifdef UNICODE
            while (*szLookAhead) {
                if (szLookAhead[0] == L'%' && szLookAhead[1] == L'%') {
                    szLookAhead++;                      // pair of %%; skip one char
                }

                *szCurDest++ = *szLookAhead++;
            }
#else
            //
            // This code path is not compiled so it has not been tested
            //

#error Code written but not tested!

            while (*szLookAhead) {

                if (IsDbcsLeadByte (*szLookAhead)) {

                    *szCurDest++ = *szLookAhead++;      // copy first half of byte pair

                } else if (*szLookAhead == '%') {

                    if (!IsDbcsLeadByte (szLookAhead[1]) && szLookAhead[1] == '%') {
                        szLookAhead++;                  // pair of %%; skip one char
                    }
                }

                *szCurDest++ = *szLookAhead++;
            }

#endif

            *szCurDest = 0;

            //
            // The unattend profile directory exists.  We need to set this
            // path in the registry
            //

            if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                                0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_WRITE, NULL, &hKey,
                                &dwDisp) == ERROR_SUCCESS) {

                if (RegSetValueEx (hKey, PROFILES_DIRECTORY,
                                   0, REG_EXPAND_SZ, (LPBYTE) szDest,
                                   ((lstrlen(szDest) + 1) * sizeof(TCHAR))) == ERROR_SUCCESS) {

                    DebugMsg((DM_VERBOSE, TEXT("DetermineProfilesLocation:  Using unattend location %s for user profiles"), szDest));
                }

                RegCloseKey (hKey);
            }
        }

    } else {

        //
        // By default, the OS will try to use the new location for
        // user profiles, but if we are doing an upgrade of a machine
        // with profiles in the NT4 location, we want to continue
        // to use that location.
        //
        // Build a test path to the old All Users directory on NT4
        // to determine which location to use.
        //

        if (FAILED(SafeExpandEnvironmentStrings (NT4_PROFILES_DIRECTORY, szDirectory,
                                       ARRAYSIZE(szDirectory)))) {

            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  ExpandEnvironmentStrings failed with error %d, setting the dir unexpanded"), GetLastError()));
            return FALSE;
        }

        lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
        if (!lpEnd)
        {
            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  CheckSlashEx failed")));
            return FALSE;
        }
        
        hr = StringCchCopy (lpEnd, cchEnd, ALL_USERS);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  StringCchCopy failed")));
            return FALSE;
        }

        if (GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

            //
            // An app was found that creates an "All Users" directory under NT4 profiles directory
            // Check for Default User as well.
            //

            hr = StringCchCopy (lpEnd, cchEnd, DEFAULT_USER);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  StringCchCopy failed")));
                return FALSE;
            }

            if (GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

                //
                // The old profiles directory exists.  We need to set this
                // path in the registry
                //

                if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                                    0, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE, NULL, &hKey,
                                    &dwDisp) == ERROR_SUCCESS) {

                    if (RegSetValueEx (hKey, PROFILES_DIRECTORY,
                                       0, REG_EXPAND_SZ, (LPBYTE) NT4_PROFILES_DIRECTORY,
                                       ((lstrlen(NT4_PROFILES_DIRECTORY) + 1) * sizeof(TCHAR))) == ERROR_SUCCESS) {

                        DebugMsg((DM_VERBOSE, TEXT("DetermineProfilesLocation:  Using NT4 location for user profiles")));
                    }

                    RegCloseKey (hKey);
                }
            }
        }
    }


    //
    // Check if the profiles directory exists.
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query profiles directory root.")));
        return FALSE;
    }

    if (!CreateSecureAdminDirectory(szDirectory, OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create profiles subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }


    //
    // Decide where the Default User profile should be
    //

    if (!CheckProfile (szDirectory, DEFAULT_USER_PROFILE, DEFAULT_USER)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to check default user profile  Error = %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Check if the profiles\Default User directory exists
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query default user profile directory.")));
        return FALSE;
    }

    if (!CreateSecureAdminDirectory (szDirectory, OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create Default User subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }

    SetFileAttributes (szDirectory, FILE_ATTRIBUTE_HIDDEN);


    //
    // Decide where the All Users profile should be
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query profiles directory root.")));
        return FALSE;
    }

    if (!CheckProfile (szDirectory, ALL_USERS_PROFILE, ALL_USERS)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to check all users profile  Error = %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Check if the profiles\All Users directory exists
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetAllUsersProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to query all users profile directory.")));
        return FALSE;
    }

    //
    // Give additional permissions for power users/everyone
    //

    if (!CreateSecureAdminDirectory (szDirectory, OTHERSIDS_POWERUSERS | OTHERSIDS_EVERYONE)) {
        DebugMsg((DM_WARNING, TEXT("DetermineProfilesLocation:  Failed to create All Users subdirectory <%s>.  Error = %d."),
                 szDirectory, GetLastError()));
        return FALSE;
    }

    //
    // Hide some special profiles like NetworkService etc.
    //

    if (!bCleanInstall) {
        HideSpecialProfiles();
    }


    return TRUE;
}

//*************************************************************
//
//  InitializeProfiles()
//
//  Purpose:    Confirms / Creates the profile, Default User,
//              and All Users directories, and converts any
//              existing common groups.
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   This should only be called by GUI mode setup!
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI InitializeProfiles (BOOL bGuiModeSetup)
{
    TCHAR               szDirectory[MAX_PATH];
    TCHAR               szSystemProfile[MAX_PATH];
    TCHAR               szTemp[MAX_PATH];
    TCHAR               szTemp2[MAX_PATH];
    DWORD               dwSize;
    DWORD               dwDisp;
    LPTSTR              lpEnd;
    DWORD               i;
    HKEY                hKey;
    BOOL                bRetVal = FALSE;
    DWORD               dwErr;
    PSHELL32_API        pShell32Api;
    HRESULT             hr;
    UINT                cchEnd;

    dwErr = GetLastError();

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  Entering.")));


    if (!bGuiModeSetup) {

        //
        // block loading user profile
        //

        if (g_hProfileSetup) {
            ResetEvent (g_hProfileSetup);
        }
    }


    dwErr = LoadShell32Api( &pShell32Api );

    if ( dwErr != ERROR_SUCCESS ) {
        goto Exit;
    }

    //
    // Set the USERPROFILE environment variable
    //

    hr = SafeExpandEnvironmentStrings(SYSTEM_PROFILE_LOCATION, szSystemProfile, MAX_PATH);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to enpand env string for system profile.")));
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    //
    // Requery for the default user profile directory (expanded version)
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query default user profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Set the USERPROFILE environment variable
    //

    if (!SetEnvironmentVariable (TEXT("USERPROFILE"), szDirectory))
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to set env var for user profile.")));
    }

    //
    // Create all the folders under Default User
    //

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to CheckSlashEx.")));
        dwErr = ERROR_BAD_PATHNAME;
        goto Exit;
    }


    //
    // Loop through the shell folders
    //

    for (i=0; i < g_dwNumShellFolders; i++) {

        hr = StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy shell folder %s."), c_ShellFolders[i].szFolderLocation));
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

        if (!CreateNestedDirectory(szDirectory, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to create the destination directory <%s>.  Error = %d"),
                     szDirectory, dwErr));
            goto Exit;
        }

        if (c_ShellFolders[i].iFolderResourceID != 0) {
            //  NOTE this returns an HRESULT
            dwErr = pShell32Api->pfnShSetLocalizedName( szDirectory,
                                        c_ShellFolders[i].lpFolderResourceDLL,
                                        c_ShellFolders[i].iFolderResourceID );
            if (FAILED(dwErr)) {
                DebugMsg((DM_WARNING, TEXT("InitializeProfiles: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                         szDirectory, dwErr));
                goto Exit;
            }
        }

        if (c_ShellFolders[i].bHidden) {
            SetFileAttributes(szDirectory, GetFileAttributes(szDirectory) | FILE_ATTRIBUTE_HIDDEN);
        }
    }


    //
    // Remove the %USERPROFILE%\Personal directory if it exists.
    // Windows NT 4.0 had a Personal folder in the root of the
    // user's profile.  NT 5.0 renames this folder to My Documents
    //

    if (LoadString (g_hDllInstance, IDS_SH_PERSONAL2, szTemp, ARRAYSIZE(szTemp))) {
        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy personal2.")));
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }
        RemoveDirectory(szDirectory);
    }


    //
    // Migrate the Template Directory if it exists. Copy it from %systemroot%\shellnew
    // to Templates directory under default user. Do the same for existing profiles.
    //

    if ((LoadString (g_hDllInstance, IDS_SH_TEMPLATES2, szTemp, ARRAYSIZE(szTemp))) &&
            (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2)))) &&
            (LoadString (g_hDllInstance, IDS_SH_TEMPLATES, szTemp, ARRAYSIZE(szTemp)))) {

        //
        // if all of the above succeeded
        //

        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy template.")));
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles: Copying <%s> to %s."), szTemp2, szDirectory));
            CopyProfileDirectory(szTemp2, szDirectory, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE);
        }
    }


    //
    // Remove %USERPROFILE%\Temp if it exists.  The Temp directory
    // will now be in the Local Settings folder
    //

    hr = StringCchCopy (lpEnd, cchEnd, TEXT("Temp"));
    if (SUCCEEDED(hr))
    {
        Delnode(szDirectory);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy temp.")));
    }

    //
    // Remove %USERPROFILE%\Temporary Internet Files if it exists.  The
    // Temporary Internet Files directory will now be in the Local Settings
    // folder
    //

    if (LoadString (g_hDllInstance, IDS_TEMPINTERNETFILES, szTemp, ARRAYSIZE(szTemp))) {
        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (SUCCEEDED(hr))
        {
            Delnode(szDirectory);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy temp internet files.")));
        }
    }


    //
    // Remove %USERPROFILE%\History if it exists.  The History
    // directory will now be in the Local Settings folder
    //

    if (LoadString (g_hDllInstance, IDS_HISTORY, szTemp, ARRAYSIZE(szTemp))) {
        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (SUCCEEDED(hr))
        {
            Delnode(szDirectory);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy history.")));
        }
    }


    //
    // Set the User Shell Folder paths in the registry
    //

    hr = AppendName(szTemp, ARRAYSIZE(szTemp), TEXT(".Default"), USER_SHELL_FOLDERS, NULL, NULL);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to append user shell folders to .default.")));
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }
   
    hr = StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%USERPROFILE%"));
    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);

    if (RegCreateKeyEx (HKEY_USERS, szTemp,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                hr = StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy shell folder %s."), c_ShellFolders[i].szFolderLocation));
                    dwErr = HRESULT_CODE(hr);
                    goto Exit;
                }

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }


    //
    // Set the Shell Folder paths in the registry
    //

    hr = AppendName(szTemp, ARRAYSIZE(szTemp), TEXT(".Default"), SHELL_FOLDERS, NULL, NULL);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to append user shell folders to .default.")));
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query default user profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  CheckSlashEx failed.")));
        dwErr = ERROR_BAD_PATHNAME;
        goto Exit;
    }

    if (RegCreateKeyEx (HKEY_USERS, szTemp,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {

                hr = StringCchCopy (lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to copy shell folder %s."), c_ShellFolders[i].szFolderLocation));
                    dwErr = HRESULT_CODE(hr);
                    goto Exit;
                }

                RegSetValueEx (hKey, c_ShellFolders[i].lpFolderName,
                             0, REG_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }

    //
    // Set the per user TEMP and TMP environment variables
    //

    if (LoadString (g_hDllInstance, IDS_SH_TEMP,
                    szTemp, ARRAYSIZE(szTemp))) {

        StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%USERPROFILE%"));
        lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);

        LoadString (g_hDllInstance, IDS_SH_LOCALSETTINGS,
                    lpEnd, cchEnd);

        lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
        if (lpEnd)
        {
            hr = StringCchCopy(lpEnd, cchEnd, szTemp);
            if (SUCCEEDED(hr))
            {
                if (RegCreateKeyEx (HKEY_USERS, TEXT(".Default\\Environment"),
                                    0, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE, NULL, &hKey,
                                    &dwDisp) == ERROR_SUCCESS) {

                    RegSetValueEx (hKey, TEXT("TEMP"),
                                   0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                                   ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

                    RegSetValueEx (hKey, TEXT("TMP"),
                                   0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                                   ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

                    RegCloseKey (hKey);
                }
            }
        }
    }


    //
    // Set the user preference exclusion list.  This will
    // prevent the Local Settings folder from roaming
    //

    if (LoadString (g_hDllInstance, IDS_EXCLUSIONLIST,
                    szDirectory, ARRAYSIZE(szDirectory))) {

        hr = AppendName(szTemp, ARRAYSIZE(szTemp), TEXT(".Default"), WINLOGON_KEY, NULL, NULL);

        if (RegCreateKeyEx (HKEY_USERS, szTemp,
                            0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hKey,
                            &dwDisp) == ERROR_SUCCESS) {

            RegSetValueEx (hKey, TEXT("ExcludeProfileDirs"),
                           0, REG_SZ, (LPBYTE) szDirectory,
                           ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));

            RegCloseKey (hKey);
        }
    }


    //
    // Requery for the all users profile directory (expanded version)
    //

    dwSize = ARRAYSIZE(szDirectory);
    if (!GetAllUsersProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  Failed to query all users profile directory.")));
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Set the ALLUSERSPROFILE environment variable
    //

    SetEnvironmentVariable (TEXT("ALLUSERSPROFILE"), szDirectory);


    //
    // Create all the folders under All Users
    //


    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles:  CheckSlashEx failed.")));
        dwErr = ERROR_BAD_PATHNAME;
        goto Exit;
    }


    //
    // Loop through the shell folders
    //

    for (i=0; i < g_dwNumCommonShellFolders; i++) {

        hr = StringCchCopy (lpEnd, cchEnd, c_CommonShellFolders[i].szFolderLocation);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to copy <%s>."),
                     c_CommonShellFolders[i].szFolderLocation));
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

        if (!CreateNestedDirectory(szDirectory, NULL)) {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to create the destination directory <%s>.  Error = %d"),
                     szDirectory, GetLastError()));
            dwErr = GetLastError();
            goto Exit;
        }

        if (c_CommonShellFolders[i].iFolderResourceID != 0) {
            //  NOTE this returns an HRESULT
            dwErr = pShell32Api->pfnShSetLocalizedName( szDirectory,
                                        c_CommonShellFolders[i].lpFolderResourceDLL,
                                        c_CommonShellFolders[i].iFolderResourceID );
            if (FAILED(dwErr)) {
                DebugMsg((DM_WARNING, TEXT("InitializeProfiles: SHSetLocalizedName failed for directory <%s>.  Error = %d"),
                         szDirectory, dwErr));
                goto Exit;
            }
        }

        if (c_CommonShellFolders[i].bHidden) {
            SetFileAttributes(szDirectory, GetFileAttributes(szDirectory) | FILE_ATTRIBUTE_HIDDEN);
        }
    }


    //
    // Unsecure the Documents and App Data folders in the All Users profile
    //

    if (LoadString (g_hDllInstance, IDS_SH_SHAREDDOCS, szTemp, ARRAYSIZE(szTemp))) {
        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (SUCCEEDED(hr))
        {
            SetFilePermissions(szDirectory, c_szCommonDocumentsACL);
        }
    }

    if (LoadString (g_hDllInstance, IDS_SH_APPDATA, szTemp, ARRAYSIZE(szTemp))) {
        hr = StringCchCopy (lpEnd, cchEnd, szTemp);
        if (SUCCEEDED(hr))
        {
            SetFilePermissions(szDirectory, c_szCommonAppDataACL);
        }
    }


    //
    // Set the User Shell Folder paths in the registry
    //

    StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), TEXT("%ALLUSERSPROFILE%"));
    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);

    if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, USER_SHELL_FOLDERS,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumCommonShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {

                hr = StringCchCopy (lpEnd, cchEnd, c_CommonShellFolders[i].szFolderLocation);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to copy <%s>."),
                             c_CommonShellFolders[i].szFolderLocation));
                    dwErr = HRESULT_CODE(hr);
                    goto Exit;
                }

                RegSetValueEx (hKey, c_CommonShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }

#if defined(_WIN64)
    //
    // On 64-bit NT, we need to create the user shell folders in
    // the 32-bit view of the registry so that 32-bit app calls
    // to SHGetFolderPath(...CSIDL_COMMON_APPDATA...) would succeed.
    //
    if (RegCreateKeyEx (HKEY_LOCAL_MACHINE, USER_SHELL_FOLDERS32,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumCommonShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                hr = StringCchCopy (lpEnd, cchEnd, c_CommonShellFolders[i].szFolderLocation);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("InitializeProfiles: Failed to copy <%s>."),
                             c_CommonShellFolders[i].szFolderLocation));
                    dwErr = HRESULT_CODE(hr);
                    goto Exit;
                }

                RegSetValueEx (hKey, c_CommonShellFolders[i].lpFolderName,
                             0, REG_EXPAND_SZ, (LPBYTE) szDirectory,
                             ((lstrlen(szDirectory) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKey);
    }
#endif

    //
    // Convert any Program Manager common groups
    //

    if (!ConvertCommonGroups()) {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles: ConvertCommonGroups failed.")));
    }

    //
    //  Reacl the ProfileList entries 
    //

    hr = ReaclProfileListEntries();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles: ReaclProfileListEntries failed, hr = %08X"), hr));
    }

    //
    //  Reacl the user profile folders in case of upgrade
    //

    if (!g_bCleanInstall)
    {
        SecureUserProfiles();
    }

    //
    //  Set the PROFILES env var, will used by the security template to skip
    //  applying the template on the profile directory
    //

    dwSize = ARRAYSIZE(szTemp);
    if (GetProfilesDirectoryEx(szTemp, &dwSize, TRUE))
    {
        if (SetEnvironmentVariable(c_szProfileEnvName, szTemp))
        {
            DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles: set env var <%s>=%s"), c_szProfileEnvName, szTemp));
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("InitializeProfiles: SetEnvironmentVariable failed, error = %d"), GetLastError()));
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("InitializeProfiles: GetProfilesDirectoryEx failed, error = %d"), GetLastError()));
    }

    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("InitializeProfiles:  Leaving successfully.")));

    bRetVal = TRUE;

Exit:

    if ((!bGuiModeSetup) && (g_hProfileSetup)) {
        SetEvent (g_hProfileSetup);
    }

    SetLastError(dwErr);
    return bRetVal;
}

//*************************************************************
//
//  CheckProfile()
//
//  Purpose:    Checks and creates a storage location for either
//              the Default User or All Users profile
//
//  Parameters: LPTSTR lpProfilesDir  - Root of the profiles
//              LPTSTR lpProfileValue - Profile registry value name
//              LPTSTR lpProfileName  - Default profile name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL CheckProfile (LPTSTR lpProfilesDir, LPTSTR lpProfileValue,
                   LPTSTR lpProfileName)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR szFormat[30];
    DWORD dwSize, dwDisp, dwType;
    LPTSTR lpEnd;
    LONG lResult;
    HKEY hKey;
    INT iStrLen;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    UINT cchEnd;
    HRESULT hr;


    //
    // Open the ProfileList key
    //

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                              0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CheckProfile:  Failed to open profile list key with %d."),
                 lResult));
        return FALSE;
    }


    //
    // Check the registry to see if this folder is defined already
    //

    dwSize = sizeof(szTemp);
    if (RegQueryValueEx (hKey, lpProfileValue, NULL, &dwType,
                         (LPBYTE) szTemp, &dwSize) == ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return TRUE;
    }


    //
    // Generate the default name
    //

    hr = AppendName(szTemp, ARRAYSIZE(szTemp), lpProfilesDir, lpProfileName, &lpEnd, &cchEnd);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CheckProfile:  Failed to append lpProfileName to lpProfilesDir.")))
        return FALSE;
    }

    StringCchCopy (szName, ARRAYSIZE(szName), lpProfileName);


    //
    //  Check if this directory exists
    //

    if (FAILED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2))))
    {
        DebugMsg((DM_WARNING, TEXT("CheckProfile:  Failed to expand env string.")))
        return FALSE;
    }

    if (GetFileAttributesEx (szTemp2, GetFileExInfoStandard, &fad)) {

        if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {


            //
            // Check if this directory is under the system root.
            // If so, this is ok, we don't need to generate a unique
            // name for this.
            //

            hr = SafeExpandEnvironmentStrings (TEXT("%SystemRoot%"), szTemp, ARRAYSIZE(szTemp));
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CheckProfile:  Failed to %SystemRoot%.")))
                return FALSE;
            }

            iStrLen = lstrlen (szTemp);

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                               szTemp, iStrLen, szTemp2, iStrLen) != CSTR_EQUAL) {


                //
                // The directory exists already.  Use a new name of
                // Profile Name (SystemDirectory)
                //
                // eg:  Default User (WINNT)
                //

                lpEnd = szTemp + lstrlen(szTemp) - 1;

                while ((lpEnd > szTemp) && ((*lpEnd) != TEXT('\\')))
                    lpEnd--;

                if (*lpEnd == TEXT('\\')) {
                    lpEnd++;
                }

                LoadString (g_hDllInstance, IDS_PROFILE_FORMAT, szFormat,
                            ARRAYSIZE(szFormat));
                StringCchPrintf (szName, ARRAYSIZE(szName), szFormat, lpProfileName, lpEnd);

                //
                // To prevent reusing the directories, delete it first..
                //

                AppendName(szTemp, ARRAYSIZE(szTemp), lpProfilesDir, szName, NULL, NULL);
                
                if (SUCCEEDED(SafeExpandEnvironmentStrings (szTemp, szTemp2, ARRAYSIZE(szTemp2)))) {
                    DebugMsg((DM_VERBOSE, TEXT("CheckProfile:  Delnoding directory.. %s"), szTemp2));
                    Delnode(szTemp2);
                }
            }
        }
    }


    //
    // Save the profile name in the registry
    //

    RegSetValueEx (hKey, lpProfileValue,
                 0, REG_SZ, (LPBYTE) szName,
                 ((lstrlen(szName) + 1) * sizeof(TCHAR)));

    RegCloseKey (hKey);


    DebugMsg((DM_VERBOSE, TEXT("CheckProfile:  The %s profile is mapped to %s"),
             lpProfileName, szName));

    return TRUE;
}


//*************************************************************
//
//  CreateUserProfile()
//
//  Purpose:    Creates a new user profile, but does not load
//              the hive.
//
//  Parameters: pSid         -   SID pointer
//              lpUserName   -   User name
//              lpUserHive   -   Optional user hive
//              lpProfileDir -   Receives the new profile directory
//              dwDirSize    -   Size of lpProfileDir
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If a user hive isn't specified the default user
//              hive will be used.
//
//  History:    Date        Author     Comment
//              9/12/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateUserProfile (PSID pSid, LPCTSTR lpUserName, LPCTSTR lpUserHive,
                                 LPTSTR lpProfileDir, DWORD dwDirSize)
{
    return CreateUserProfileEx(pSid, lpUserName, lpUserHive, lpProfileDir, dwDirSize, TRUE);
}

//*************************************************************
//
//  CreateUserProfileEx()
//
//  Purpose:    Creates a new user profile, but does not load
//              the hive.
//
//  Parameters: pSid         -   SID pointer
//              lpUserName   -   User name
//              lpUserHive   -   Optional user hive
//              lpProfileDir -   Receives the new profile directory
//              dwDirSize    -   Size of lpProfileDir
//              bWin9xUpg    -   Flag to say whether it is win9x upgrade
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If a user hive isn't specified the default user
//              hive will be used.
//
//  History:    Date        Author     Comment
//              9/12/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI CreateUserProfileEx (PSID pSid, LPCTSTR lpUserName, LPCTSTR lpUserHive,
                                 LPTSTR lpProfileDir, DWORD dwDirSize, BOOL bWin9xUpg)
{
    TCHAR szProfileDir[MAX_PATH];
    TCHAR szExpProfileDir[MAX_PATH] = {0};
    TCHAR szDirectory[MAX_PATH];
    TCHAR LocalProfileKey[MAX_PATH];
    UNICODE_STRING UnicodeString;
    LPTSTR lpSidString, lpEnd, lpSave;
    NTSTATUS NtStatus;
    LONG lResult;
    DWORD dwDisp;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;
    UINT cchEnd;
    HRESULT hr;



    //
    // Check parameters
    //

    if (!lpUserName || !lpUserName[0]) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Null username.")));
        return FALSE;
    }

    if (!pSid) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Null SID.")));
        return FALSE;
    }

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Entering with <%s>."), lpUserName));
    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Entering with user hive of <%s>."),
             lpUserHive ? lpUserHive : TEXT("NULL")));


    //
    // Convert the sid into text format
    //

    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString, pSid, (BOOLEAN)TRUE);

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("CreateUserProfile: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return FALSE;
    }

    lpSidString = UnicodeString.Buffer;


    //
    // Check if this user's profile exists already
    //

    GetProfileListKeyName(LocalProfileKey, ARRAYSIZE(LocalProfileKey), lpSidString);

    szProfileDir[0] = TEXT('\0');

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szProfileDir);
        RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                         &dwType, (LPBYTE) szProfileDir, &dwSize);

        RegCloseKey (hKey);
    }


    if (szProfileDir[0] == TEXT('\0')) {

        //
        // Make the user's directory
        //

        dwSize = ARRAYSIZE(szProfileDir);
        if (!GetProfilesDirectoryEx(szProfileDir, &dwSize, FALSE)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to get profile root directory.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }

        if (!ComputeLocalProfileName (NULL, lpUserName, szProfileDir, ARRAYSIZE(szProfileDir),
                                      szExpProfileDir, ARRAYSIZE(szExpProfileDir), pSid, bWin9xUpg)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to create directory.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }


        //
        // Copy the default user profile into this directory
        //

        dwSize = ARRAYSIZE(szDirectory);
        if (!GetDefaultUserProfileDirectoryEx(szDirectory, &dwSize, TRUE)) {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to get default user profile.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }


        if (lpUserHive) {

            //
            // Copy the default user profile without the hive.
            //

            if (!CopyProfileDirectory (szDirectory, szExpProfileDir, CPD_IGNORECOPYERRORS | CPD_IGNOREHIVE | CPD_IGNORELONGFILENAMES)) {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   CopyProfileDirectory failed with error %d."), GetLastError()));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }

            //
            // Now copy the hive
            //

            hr = AppendName(szDirectory, ARRAYSIZE(szDirectory), szExpProfileDir, c_szNTUserDat, NULL, NULL);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile: failed to append ntuser.dat.")));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }

            if (lstrcmpi (lpUserHive, szDirectory)) {

                if (!CopyFile (lpUserHive, szDirectory, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Failed to copy user hive with error %d."), GetLastError()));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Source:  %s."), lpUserHive));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Destination:  %s."), szDirectory));
                    RtlFreeUnicodeString(&UnicodeString);
                    return FALSE;
                }
            }

        } else {

            //
            // Copy the default user profile and the hive.
            //

            if (!CopyProfileDirectory (szDirectory, szExpProfileDir, CPD_IGNORECOPYERRORS | CPD_IGNORELONGFILENAMES)) {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   CopyProfileDirectory failed with error %d."), GetLastError()));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }
        }


        //
        // Save the user's profile in the registry.
        //

        lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, LocalProfileKey, 0, 0, 0,
                                KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed trying to create the local profile key <%s>, error = %d."), LocalProfileKey, lResult));
           RtlFreeUnicodeString(&UnicodeString);
           return FALSE;
        }

        //
        // Add the profile directory
        //

        lResult = RegSetValueEx(hKey, PROFILE_IMAGE_VALUE_NAME, 0,
                            REG_EXPAND_SZ,
                            (LPBYTE)szProfileDir,
                            sizeof(TCHAR)*(lstrlen(szProfileDir) + 1));


        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  First RegSetValueEx failed, error = %d."), lResult));
           RegCloseKey (hKey);
           RtlFreeUnicodeString(&UnicodeString);
           return FALSE;
        }


        //
        // Add the users's SID
        //

        lResult = RegSetValueEx(hKey, TEXT("Sid"), 0,
                            REG_BINARY, pSid, RtlLengthSid(pSid));


        if (lResult != ERROR_SUCCESS) {

           DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Second RegSetValueEx failed, error = %d."), lResult));
        }


        //
        // Close the registry key
        //

        RegCloseKey (hKey);

    } else {

        //
        // The user already has a profile, so just copy the hive if
        // appropriate.
        //

        hr = SafeExpandEnvironmentStrings (szProfileDir, szExpProfileDir,
                                  ARRAYSIZE(szExpProfileDir));
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CreateUserProfile: failed to expand env string.")));
            RtlFreeUnicodeString(&UnicodeString);
            return FALSE;
        }

        if (lpUserHive) {

            //
            // Copy the hive
            //

            hr = AppendName(szDirectory, ARRAYSIZE(szDirectory), szExpProfileDir, c_szNTUserDat, NULL, NULL);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CreateUserProfile: failed to append ntuser.dat.")));
                RtlFreeUnicodeString(&UnicodeString);
                return FALSE;
            }

            SetFileAttributes (szDirectory, FILE_ATTRIBUTE_NORMAL);

            if (lstrcmpi (lpUserHive, szDirectory)) {
                if (!CopyFile (lpUserHive, szDirectory, FALSE)) {
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Failed to copy user hive with error %d."), GetLastError()));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Source:  %s."), lpUserHive));
                    DebugMsg((DM_WARNING, TEXT("CreateUserProfile:   Destination:  %s."), szDirectory));
                    RtlFreeUnicodeString(&UnicodeString);
                    return FALSE;
                }
            }

        }
    }


    //
    // Now load the hive temporary so the security can be fixed
    //

    lpEnd = CheckSlashEx (szExpProfileDir, ARRAYSIZE(szExpProfileDir), &cchEnd);
    lpSave = lpEnd - 1;
    StringCchCopy (lpEnd, cchEnd, c_szNTUserDat);

    lResult = MyRegLoadKey(HKEY_USERS, lpSidString, szExpProfileDir);

    *lpSave = TEXT('\0');

    if (lResult != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  Failed to load hive, error = %d."), lResult));
        dwError = GetLastError();
        DeleteProfileEx (lpSidString, szExpProfileDir, FALSE, HKEY_LOCAL_MACHINE, NULL);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(dwError);
        return FALSE;
    }

    if (!SetupNewHive(NULL, lpSidString, pSid)) {

        DebugMsg((DM_WARNING, TEXT("CreateUserProfile:  SetupNewHive failed.")));
        dwError = GetLastError();
        MyRegUnLoadKey(HKEY_USERS, lpSidString);
        DeleteProfileEx (lpSidString, szExpProfileDir, FALSE, HKEY_LOCAL_MACHINE, NULL);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(dwError);
        return FALSE;

    }


    //
    // Unload the hive
    //

    MyRegUnLoadKey(HKEY_USERS, lpSidString);


    //
    // Free the sid string
    //

    RtlFreeUnicodeString(&UnicodeString);


    //
    // Save the profile path if appropriate
    //

    if (lpProfileDir) {

        if ((DWORD)lstrlen(szExpProfileDir) < dwDirSize) {
            StringCchCopy (lpProfileDir, dwDirSize, szExpProfileDir);
        }
    }


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateUserProfile:  Leaving successfully.")));

    return TRUE;

}


//*************************************************************************
//
// SecureUserProfiles()
//
// Description : This function secures user profiles during FAT->NTFS conversion.
//               It will also get called during upgrade in order to secure the
//               profile area where the user has converted the file system before
//               the upgrade.
//
// Arguments :   None.
//
// Return Value: None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//             09/25/2002  mingzhu    Added SecureCommonProfiles()
//
//*************************************************************************

void WINAPI SecureUserProfiles(void)
{
    HRESULT     hr = E_FAIL;

    //
    // Put all our work into the exception handler, so we don't corrupt setup
    // and convert.
    //
    __try
    {
        //
        //  Secure the per user profile areas
        //

        hr = SecurePerUserProfiles();

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: SecurePerUserProfiles failed, hr =%08X"), hr));
        }    
        
        //
        //  Secure the common profile areas.
        //
        
        hr = SecureCommonProfiles();

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: SecureCommonProfile failed, hr =%08X"), hr));
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Exception %d!!!"), GetExceptionCode()));
    }
}

//*************************************************************************
//
// SecurePerUserProfiles()
//
// Description : This function secure (reacl) the per-user profiles under
//               profiles directory, it will loop for each entry in the 
//               profile list entry and reacl every profile with the ACL
//               of Admin(F)System(F)ProfileOwner(F).
//
// Arguments   : None.
//
// Return Value: HRESULT.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//             09/25/2002  mingzhu    Seperated from SecureUserProfiles()
//
//*************************************************************************

HRESULT SecurePerUserProfiles()
{
    SECURITY_DESCRIPTOR DirSd, FileSd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pDirAcl = NULL, pFileAcl = NULL;
    PSID  pSidOwner=NULL, pSidAdmin = NULL, pSidSystem = NULL;
    DWORD cbAcl, aceIndex;
    HKEY hKeyProfilesList, hKeyProfile = NULL;
    TCHAR szSIDName[MAX_PATH], szProfilePath[MAX_PATH], szExpandedProfilePath[MAX_PATH];
    DWORD dwSIDNameSize, dwSize;
    DWORD dwIndex;
    LONG lResult;
    FILETIME ft;
    HRESULT hr;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize system sid.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize admin sid.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Open the ProfileList key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      PROFILE_LIST_PATH,
                      0, KEY_READ, &hKeyProfilesList) != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to open ProfileList key")));
        goto Exit;
    }


    //
    // Enumerate the profiles
    //

    dwIndex = 0;
    dwSIDNameSize = ARRAYSIZE(szSIDName);
    lResult = RegEnumKeyEx(hKeyProfilesList,
                           dwIndex,
                           szSIDName,
                           &dwSIDNameSize,
                           NULL, NULL, NULL, &ft);


    while (lResult == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyProfilesList,
                          szSIDName,
                          0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            dwSize = sizeof(szProfilePath);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_IMAGE_VALUE_NAME,
                                 NULL, NULL,
                                 (LPBYTE) szProfilePath,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            //
            // Expand the profile image filename
            //

            if (FAILED(SafeExpandEnvironmentStrings(szProfilePath, szExpandedProfilePath, MAX_PATH)))
            {
                goto IssueError;
            }

            //
            // Create the acl for the user profile dir
            //

            //
            // Get the owner sid
            //

            if (AllocateAndInitSidFromString(szSIDName, &pSidOwner) != STATUS_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to create owner sid."), GetLastError()));
                goto IssueError;
            }

            //
            // Allocate space for the Dir object ACL
            //

            cbAcl = (2 * GetLengthSid (pSidOwner)) +
                    (2 * GetLengthSid (pSidSystem)) +
                    (2 * GetLengthSid (pSidAdmin))  +
                    sizeof(ACL) +
                    (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


            pDirAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
            if (!pDirAcl) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeAcl(pDirAcl, cbAcl, ACL_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Allocate space for File object ACL
            //

            cbAcl = (GetLengthSid (pSidOwner)) +
                    (GetLengthSid (pSidSystem)) +
                    (GetLengthSid (pSidAdmin))  +
                    sizeof(ACL) +
                    (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


            pFileAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
            if (!pFileAcl) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeAcl(pFileAcl, cbAcl, ACL_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize acl.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Add Aces.  Non-inheritable ACEs first
            //

            aceIndex = 0;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }
            if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            //
            // Now the Inheritable Aces.
            //

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidOwner)) {
                 DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add owner ace.  Error = %d"), GetLastError()));
                 goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidSystem)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add system ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            aceIndex++;
            if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidAdmin)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            //
            // Put together the security descriptor
            //

            if (!InitializeSecurityDescriptor(&DirSd, SECURITY_DESCRIPTOR_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            if (!SetSecurityDescriptorDacl(&DirSd, TRUE, pDirAcl, FALSE)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            if (!InitializeSecurityDescriptor(&FileSd, SECURITY_DESCRIPTOR_REVISION)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
                goto IssueError;
            }


            if (!SetSecurityDescriptorDacl(&FileSd, TRUE, pFileAcl, FALSE)) {
                DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
                goto IssueError;
            }

            //
            // Pass the profile path to SecureProfile for securing
            // the profile dir and nested subdirs and files.
            //

            if (!SecureNestedDir (szExpandedProfilePath, &DirSd, &FileSd)) {
                goto IssueError;
            }

            goto NextProfile;

IssueError:
            DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to secure %s Profile directory"), szExpandedProfilePath));

        }

NextProfile:

        // Free the allocated stuffs

        if (hKeyProfile) {
            RegCloseKey(hKeyProfile);
            hKeyProfile = NULL;
        }

        if (pSidOwner) {
            LocalFree(pSidOwner);
            pSidOwner = NULL;
        }

        if (pDirAcl) {
            GlobalFree (pDirAcl);
            pDirAcl = NULL;
        }

        if (pFileAcl) {
            GlobalFree (pFileAcl);
            pFileAcl = NULL;
        }

        //
        // Reset for the next loop
        //

        dwIndex++;
        dwSIDNameSize = ARRAYSIZE(szSIDName);
        lResult = RegEnumKeyEx(hKeyProfilesList,
                               dwIndex,
                               szSIDName,
                               &dwSIDNameSize,
                               NULL, NULL, NULL, &ft);
    }

    RegCloseKey(hKeyProfilesList);
    
Exit:

    if (pSidSystem) {
        FreeSid(pSidSystem);
    }

    if (pSidAdmin) {
        FreeSid(pSidAdmin);
    }

    return S_OK;
}


//*************************************************************************
//
// HideSpecialProfiles()
//
// Routine Description :
//          This function secures special profiles for which PI_HIDEPROFILE
//          flag is specifed, e.g. LocalService, NetworkService etc. except
//          system account profile. This mark the profile dir as super hidden.
//
// Arguments :
//          None.
//
// Return Value :
//          None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//
//*************************************************************************

void HideSpecialProfiles(void)
{
    HKEY hKeyProfilesList, hKeyProfile = NULL;
    TCHAR szSIDName[MAX_PATH], szProfilePath[MAX_PATH], szExpandedProfilePath[MAX_PATH];
    DWORD dwSIDNameSize, dwSize;
    DWORD dwIndex, dwFlags;
    LONG lResult;
    FILETIME ft;
    HRESULT hr;


    //
    // Open the ProfileList key
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      PROFILE_LIST_PATH,
                      0, KEY_READ, &hKeyProfilesList) != ERROR_SUCCESS) {

        DebugMsg((DM_WARNING, TEXT("HideSpecialProfiles: Failed to open ProfileList key")));
        return;
    }


    //
    // Enumerate the profiles
    //

    dwIndex = 0;
    dwSIDNameSize = ARRAYSIZE(szSIDName);
    lResult = RegEnumKeyEx(hKeyProfilesList,
                           dwIndex,
                           szSIDName,
                           &dwSIDNameSize,
                           NULL, NULL, NULL, &ft);


    while (lResult == ERROR_SUCCESS) {

        if (RegOpenKeyEx (hKeyProfilesList,
                          szSIDName,
                          0, KEY_READ, &hKeyProfile) == ERROR_SUCCESS) {

            //
            // Process only if PI_HIDEPROFILE flag is set
            //

            dwSize = sizeof(DWORD);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_FLAGS,
                                 NULL, NULL,
                                 (LPBYTE) &dwFlags,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            if (!(dwFlags & PI_HIDEPROFILE)) {
                goto NextProfile;
            }

            dwSize = sizeof(szProfilePath);
            if (RegQueryValueEx (hKeyProfile,
                                 PROFILE_IMAGE_VALUE_NAME,
                                 NULL, NULL,
                                 (LPBYTE) szProfilePath,
                                 &dwSize) != ERROR_SUCCESS) {
                goto NextProfile;
            }

            // Ignore profile for system account

            if (lstrcmp(szProfilePath, SYSTEM_PROFILE_LOCATION) == 0) {
                goto NextProfile;
            }

            //
            // Expand the profile image filename
            //

            hr = SafeExpandEnvironmentStrings(szProfilePath, szExpandedProfilePath, MAX_PATH);
            if (FAILED(hr))
            {
                goto NextProfile;
            }

            // Mark the profile hidden
            SetFileAttributes(szExpandedProfilePath,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM |
                              GetFileAttributes(szExpandedProfilePath));

        }

NextProfile:

        // Free the allocated stuffs

        if (hKeyProfile) {
            RegCloseKey(hKeyProfile);
            hKeyProfile = NULL;
        }

        //
        // Reset for the next loop
        //

        dwIndex++;
        dwSIDNameSize = ARRAYSIZE(szSIDName);
        lResult = RegEnumKeyEx(hKeyProfilesList,
                               dwIndex,
                               szSIDName,
                               &dwSIDNameSize,
                               NULL, NULL, NULL, &ft);
    }

    RegCloseKey(hKeyProfilesList);

}


//*************************************************************
//
//  CopySystemProfile()
//
//  Purpose:    Create the system profile information under
//              ProfileList entry.
//              In case of upgrade copy system profile from older
//              location to new location and delete the old system
//              profile
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError()
//
//  Comments:   This should only be called by GUI mode setup!
//
//  History:    Date        Author     Comment
//              03/13/01    santanuc   Created
//
//*************************************************************

BOOL WINAPI CopySystemProfile(BOOL bCleanInstall)
{
    HANDLE  hToken = NULL;
    LPTSTR  SidString = NULL, lpEnd;
    TCHAR   szLocalProfileKey[MAX_PATH], szBuffer[MAX_PATH];
    TCHAR   szSrc[MAX_PATH], szDest[MAX_PATH];
    LONG    lResult;
    HKEY    hKey = NULL, hKeyShellFolders;
    DWORD   dwFlags, dwInternalFlags, dwRefCount;
    DWORD   dwDisp, dwSize, dwType, i;
    BOOL    bCopySystemProfile = TRUE, bCopyFromDefault = TRUE;
    PSID    pSystemSid = NULL;
    DWORD   dwErr = ERROR_SUCCESS;
    HRESULT hr;
    UINT    cchEnd;

    //
    // Set the Profile information for system account i.e sid s-1-5-18
    //

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE |
                          TOKEN_QUERY | TOKEN_DUPLICATE, &hToken)) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to open system token. Error %d"), dwErr));
        goto Exit;
    }

    //
    // Get the Sid string
    //

    SidString = GetSidString(hToken);
    if (!SidString) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get sid string for system account")));
        goto Exit;
    }

    pSystemSid = GetUserSid(hToken);
    if (!pSystemSid) {
        dwErr = ERROR_ACCESS_DENIED;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get sid for system account")));
        goto Exit;
    }


    //
    // Open the profile mapping
    //

    GetProfileListKeyName(szLocalProfileKey, ARRAYSIZE(szLocalProfileKey), SidString);

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szLocalProfileKey, 0, 0, 0,
                             KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to open profile mapping key. Error %d"), lResult));
        dwErr = lResult;
        goto Exit;
    }

    //
    // Save the flags
    //

    dwFlags = PI_LITELOAD | PI_HIDEPROFILE;
    lResult = RegSetValueEx (hKey,
                             PROFILE_FLAGS,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwFlags,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile flags. Error %d"), lResult));
    }

    //
    // Save the internal flags
    //

    dwInternalFlags = 0;
    lResult = RegSetValueEx (hKey,
                             PROFILE_STATE,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwInternalFlags,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save internal flags. Error %d"), lResult));
    }

    //
    // Save the ref count
    //

    dwRefCount = 1;
    lResult = RegSetValueEx (hKey,
                             PROFILE_REF_COUNT,
                             0,
                             REG_DWORD,
                             (LPBYTE) &dwRefCount,
                             sizeof(DWORD));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile ref count. Error %d"), lResult));
    }

    //
    // Save the sid
    //

    lResult = RegSetValueEx (hKey,
                             TEXT("Sid"),
                             0,
                             REG_BINARY,
                             (LPBYTE) pSystemSid,
                             RtlLengthSid(pSystemSid));

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile system sid. Error %d"), lResult));
    }


    //
    // Figure out whether any existing system profile exist or not
    // in upgrade scenario
    //

    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), SYSTEM_PROFILE_LOCATION);
    hr = SafeExpandEnvironmentStrings(szBuffer, szDest, MAX_PATH);
    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to expand env string. Error %d"), dwErr));
        goto Exit;
    }

    if (!bCleanInstall) {
        dwSize = ARRAYSIZE(szBuffer) * sizeof(TCHAR);
        lResult = RegQueryValueEx(hKey,
                                  PROFILE_IMAGE_VALUE_NAME,
                                  NULL,
                                  &dwType,
                                  (LPBYTE) szBuffer,
                                  &dwSize);
        if (ERROR_SUCCESS == lResult) {
            if (lstrcmp(szBuffer, SYSTEM_PROFILE_LOCATION) == 0) {
                bCopySystemProfile = FALSE;
            }
            else {
                hr = SafeExpandEnvironmentStrings(szBuffer, szSrc, MAX_PATH);
                if (FAILED(hr))
                {
                    dwErr = HRESULT_CODE(hr);
                    DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to expand env string. Error %d"), dwErr));
                    goto Exit;
                }
                bCopyFromDefault = FALSE;
            }
        }
    }

    if (bCopySystemProfile) {

        if (!CreateSecureDirectory(NULL, szDest, pSystemSid, FALSE)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Fail to create SystemProfile dir. Error %d"), dwErr));
            goto Exit;
        }


        if (bCopyFromDefault) {
            dwSize = ARRAYSIZE(szSrc);
            if (!GetDefaultUserProfileDirectoryEx(szSrc, &dwSize, TRUE)) {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to get default user profile. Error %d"), dwErr));
                goto Exit;
            }
        }

        //
        // Copy the existing or Default user profile in System profile location
        //

        if (!CopyProfileDirectoryEx(szSrc, szDest, CPD_IGNOREHIVE | CPD_FORCECOPY | CPD_IGNORECOPYERRORS,
                                    NULL, NULL)) {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to copy system profile. Error %d"), dwErr));
            goto Exit;
        }

        if (!bCopyFromDefault) {
            Delnode(szSrc);
        }
    }

    SetAclForSystemProfile(pSystemSid, szDest);

    //
    // Save local profile path
    //

    StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), SYSTEM_PROFILE_LOCATION);
    lResult = RegSetValueEx (hKey,
                             PROFILE_IMAGE_VALUE_NAME,
                             0,
                             REG_EXPAND_SZ,
                             (LPBYTE) szBuffer,
                             ((lstrlen(szBuffer) + 1) * sizeof(TCHAR)));

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: Failed to save profile image path with error %d"), lResult));
        goto Exit;
    }

    //
    // Set the Shell Folder paths in the registry for system account
    //

    hr = AppendName(szBuffer, ARRAYSIZE(szBuffer), TEXT(".Default"), SHELL_FOLDERS, NULL, NULL);

    lpEnd = CheckSlashEx (szDest, ARRAYSIZE(szDest), &cchEnd);
    if (!lpEnd)
    {
        dwErr = ERROR_BAD_PATHNAME;
        DebugMsg((DM_WARNING, TEXT("CopySystemProfile: CheckSlashEx failed.")));
        goto Exit;
    }

    if (RegCreateKeyEx (HKEY_USERS, szBuffer,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKeyShellFolders,
                        &dwDisp) == ERROR_SUCCESS) {

        for (i=0; i < g_dwNumShellFolders; i++) {

            if (c_ShellFolders[i].bAddCSIDL) {
                hr = StringCchCopy(lpEnd, cchEnd, c_ShellFolders[i].szFolderLocation);
                if (FAILED(hr))
                {
                    dwErr = HRESULT_CODE(hr);
                    DebugMsg((DM_WARNING, TEXT("CopySystemProfile: failed to copy %s."), c_ShellFolders[i].szFolderLocation));
                    goto Exit;
                }

                RegSetValueEx (hKeyShellFolders, c_ShellFolders[i].lpFolderName,
                             0, REG_SZ, (LPBYTE) szDest,
                             ((lstrlen(szDest) + 1) * sizeof(TCHAR)));
            }
        }

        RegCloseKey (hKeyShellFolders);
    }

Exit:

    if (hToken) {
        CloseHandle(hToken);
    }

    if (SidString) {
        DeleteSidString(SidString);
    }

    if (pSystemSid) {
        DeleteUserSid(pSystemSid);
    }

    if (hKey) {
        RegCloseKey (hKey);
    }

    SetLastError(dwErr);

    return(dwErr == ERROR_SUCCESS ? TRUE : FALSE);
}



//*************************************************************************
//
// SetAclForSystemProfile()
//
// Routine Description :
//          This function secures dir/files of system profile i.e.
//          %windir%\system32\config\systemprofile
//
// Arguments :
//          pSidSystem            - System sid
//          szExpandedProfilePath - Expanded system profile location
//
// Return Value :
//          None.
//
// History:    Date        Author     Comment
//             04/06/01    santanuc   Created
//
//*************************************************************************

void SetAclForSystemProfile(PSID pSidSystem, LPTSTR szExpandedProfilePath)
{
    SECURITY_DESCRIPTOR DirSd, FileSd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pDirAcl = NULL, pFileAcl = NULL;
    PSID  pSidAdmin = NULL;
    DWORD cbAcl, aceIndex;


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SecureUserProfiles: Failed to initialize admin sid.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Allocate space for the Dir object ACL
    //

    cbAcl = (2 * GetLengthSid (pSidSystem)) +
            (2 * GetLengthSid (pSidAdmin))  +
            sizeof(ACL) +
            (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pDirAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pDirAcl) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeAcl(pDirAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Allocate space for File object ACL
    //

    cbAcl = (GetLengthSid (pSidSystem)) +
            (GetLengthSid (pSidAdmin))  +
            sizeof(ACL) +
            (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pFileAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pFileAcl) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to allocate memory for acl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeAcl(pFileAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }
    if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pDirAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }
    if (!AddAccessAllowedAce(pFileAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Now the Inheritable Aces.
    //

    aceIndex++;
    if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidSystem)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add system ace.  Error = %d"), GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAceEx(pDirAcl, ACL_REVISION, OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE, GENERIC_ALL, pSidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to add builtin admin ace.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&DirSd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&DirSd, TRUE, pDirAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!InitializeSecurityDescriptor(&FileSd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&FileSd, TRUE, pFileAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Pass the profile path to SecureProfile for securing
    // the profile dir and nested subdirs and files.
    //

    if (!SecureNestedDir (szExpandedProfilePath, &DirSd, &FileSd)) {
        DebugMsg((DM_WARNING, TEXT("SetAclForSystemProfile: Failed to secure %s Profile directory"), szExpandedProfilePath));
    }

Exit:

    if (pDirAcl) {
        GlobalFree (pDirAcl);
        pDirAcl = NULL;
    }

    if (pFileAcl) {
        GlobalFree (pFileAcl);
        pFileAcl = NULL;
    }

    if (pSidAdmin) {
        FreeSid(pSidAdmin);
    }

}


//*************************************************************************
//
// ReaclProfileListEntries()
//
// Routine Description :
//
//          This function reset the entries in ProfileList key's security to
//          their parent, which is not writable for user, and add a new subkey
//          named "Reference" to save user reference. By doing this, we can 
//          prevent the user from changing their other profile related values.
//
// Arguments :
//
// Return Value : S_OK for success, else for failure
//
// History:    Date        Author     Comment
//             04/19/2002  mingzhu    Created
//
//*************************************************************************

HRESULT ReaclProfileListEntries()
{
    HRESULT hr = E_FAIL;
    LONG    lResult;
    DWORD   dwResult;

    HKEY                    hkeyProfileList = NULL;
    PSECURITY_DESCRIPTOR    psdProfileList = NULL;
    PACL                    paclProfileList = NULL;
    SECURITY_DESCRIPTOR     sdEntry;

    DWORD       dwIndex;
    FILETIME    ft;
    TCHAR       szEntryName[MAX_PATH];
    HKEY        hkeyEntry = NULL;
    DWORD       dwUserPreference;
    DWORD       dwSize;
    HKEY        hkeyPreference = NULL;
    TCHAR       szCentralProfile[MAX_PATH];
    DWORD       dwProfileState;

    DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : entering")));
    
    //
    //  Check clean install, we don't need to do this for clean installed OS
    //

    if (g_bCleanInstall)
    {
        hr = S_OK;
        goto Exit;
    }

    //
    //  Open ProfileList key
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PROFILE_LIST_PATH,
                           0,
                           KEY_READ,
                           &hkeyProfileList);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : failed to open ProfileList key, error = %d"), lResult));
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    //
    //  Get the DACL out of it
    //

    dwResult = GetSecurityInfo(hkeyProfileList,
                               SE_REGISTRY_KEY,
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               &paclProfileList,
                               NULL,
                               &psdProfileList);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : GetSecurityInfo failed, error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }

    //
    //  Initialize the SD for sub entries in Profile List, it will have the same DACL as their parent
    //

    if (!InitializeSecurityDescriptor(&sdEntry, SECURITY_DESCRIPTOR_REVISION))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : InitializeSecurityDescriptor failed, error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }

    //
    //  Set the Dacl with default to TRUE
    //
    
    if (!SetSecurityDescriptorDacl(&sdEntry, TRUE, paclProfileList, TRUE))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : SetSecurityDescriptorDacl failed, error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }
    

    //
    //  Enumerate each subkey entry, for each entry :
    //
    //  1. Set the DACLs
    //  2. For roaming users, create the "Preference" subkey, set Dacls on that to give user write permission
    //  3. Set the user preference value to the new location if it exists
    //

    for (dwIndex = 0; ;dwIndex++)
    {
        //
        //  Enumerate subkey
        //

        dwSize = ARRAYSIZE(szEntryName);
        
        lResult = RegEnumKeyEx(hkeyProfileList,
                               dwIndex,
                               szEntryName,
                               &dwSize,
                               NULL,
                               NULL,
                               NULL,
                               &ft);

        if (lResult != ERROR_SUCCESS)
            break;

        //
        //  Open it
        //

        lResult = RegOpenKeyEx(hkeyProfileList,
                               szEntryName,
                               0,
                               KEY_ALL_ACCESS,
                               &hkeyEntry);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : failed to open <%s>, error = %d"), szEntryName, lResult));
            goto Next;
        }

        //
        //  Set the SD to it, 
        //

        lResult = RegSetKeySecurity(hkeyEntry, DACL_SECURITY_INFORMATION, &sdEntry);
        
        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : RegSetKeySecurity failed for <%s>, error = %d"), szEntryName, lResult));
            goto Next;
        }

        //
        //  Read the "CentralProfile" value, if it is empty, this is a local user
        //

        szCentralProfile[0] = TEXT('\0');
        dwSize = sizeof(szCentralProfile);

        lResult = RegQueryValueEx(hkeyEntry,
                                  PROFILE_CENTRAL_PROFILE,
                                  NULL,
                                  NULL,
                                  (LPBYTE) szCentralProfile,
                                  &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : Cannot get central profile for <%s>, user is not roaming."), szEntryName));
            goto Next;
        }

        szCentralProfile[MAX_PATH - 1] = TEXT('\0');

        if (lstrlen(szCentralProfile) == 0)
        {
            DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : Central profile is empty for <%s>, user is not roaming."), szEntryName));
            goto Next;
        }

        //
        //  We got a central profile for the user, check if it belongs to a mandatory/readonly user
        //

        dwSize = sizeof(dwProfileState);
        
        lResult = RegQueryValueEx(hkeyEntry,
                                  PROFILE_STATE,
                                  NULL,
                                  NULL,
                                  (LPBYTE) &dwProfileState,
                                  &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : Cannot get profile state for <%s>, not setting the Preference key."), szEntryName));
            goto Next;
        }

        if (dwProfileState & PROFILE_MANDATORY)
        {
            DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : <%s>'s profile is mandatory or readonly, not setting the Preference key."), szEntryName));
            goto Next;
        }
        
        //
        //  We got a roaming user here, create the "Prefrence" key, set the ACL on it.
        //

        DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : Central profile is <%s>, state is <%08X>, user is roaming."), szCentralProfile, dwProfileState));

        hr = SetupPreferenceKey(szEntryName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : SetupPrefrenceKey failed for <%s>, error = %d"), szEntryName, lResult));
            goto Next;
        }

        //
        //  Try to see if we have user preference value already set in the entry
        //

        dwSize = sizeof(dwUserPreference);
        
        lResult = RegQueryValueEx(hkeyEntry,
                                  USER_PREFERENCE,
                                  NULL,
                                  NULL,
                                  (LPBYTE) &dwUserPreference,
                                  &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            goto Next;
        }

        //
        //  We found an existing user preference value, set it to the new location
        //

        lResult = RegOpenKeyEx(hkeyEntry,
                               PREFERENCE_KEYNAME,
                               0,
                               KEY_SET_VALUE,
                               &hkeyPreference);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : failed to open <%s> preference key, error = %d"), szEntryName, lResult));
            goto Next;
        }

        lResult = RegSetValueEx(hkeyPreference,
                                USER_PREFERENCE,
                                0,
                                REG_DWORD,
                                (CONST BYTE*) &dwUserPreference,
                                sizeof(dwUserPreference));

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("ReaclProfileListEntries : failed to set <%s> preference value, error = %d"), szEntryName, lResult));
            goto Next;
        }

    Next:

        if (hkeyPreference)
        {
            RegCloseKey(hkeyPreference);
            hkeyPreference = NULL;
        }

        if (hkeyEntry)
        {
            RegCloseKey(hkeyEntry);
            hkeyEntry = NULL;
        }
        
    }
    
Exit:

    if (hkeyProfileList)
        RegCloseKey(hkeyProfileList);

    if (psdProfileList)
        LocalFree(psdProfileList);

    DebugMsg((DM_VERBOSE, TEXT("ReaclProfileListEntries : done!")));
        
    return hr;
}

//*****************************************************************************
//
//  CallFaxServiceAPI()
//
//  Purpose:    Call the SecureFaxServiceDirectories() API in fxsocm.dll to set
//              the special DACLs on some folders under 
//              "All Users\Application Data" directory
//
//  Parameters: None
//
//  Return:     HRESULT
//
//  Comments:                 
//
//  History:    Date        Author     Comment
//              08/21/2002  mingzhu    Created
//
//*****************************************************************************

HRESULT CallFaxServiceAPI()
{
    HRESULT     hr = E_FAIL;
    TCHAR       szDir[MAX_PATH];
    HMODULE     hFxsocm = NULL;
    DWORD       dwErr;
    typedef     HRESULT (WINAPI *PFN_FAXAPI)(LPCTSTR);
    PFN_FAXAPI  pfnFaxAPI = NULL;
    TCHAR       szCommonAppData[MAX_PATH];
    DWORD       dwSize;
    LPTSTR      lpEnd = NULL;
    DWORD       cchEnd;
    TCHAR       szTemp[64];

    //
    //  Init the debugging
    //

    InitDebugSupport(0);
    
    //
    //  Get the all user profile path
    //

    dwSize = ARRAYSIZE(szCommonAppData);
    if (!GetAllUsersProfileDirectoryEx(szCommonAppData, &dwSize, TRUE))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI: GetAllUsersProfileDirectoryEx failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Append the application data to the path 
    //

    lpEnd = CheckSlashEx(szCommonAppData, ARRAYSIZE(szCommonAppData), &cchEnd);
    if (!lpEnd)
    {
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI : CheckSlashEx failed!")));
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }
   
    if (!LoadString (g_hDllInstance, IDS_SH_APPDATA, szTemp, ARRAYSIZE(szTemp)))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI : LoadString failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    hr = StringCchCopy (lpEnd, cchEnd, szTemp);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI : StringCchCopy failed, hr = %08X"), hr));
        goto Exit;
    }

    //
    //  Load the dll and call the API
    //
    
    hr = SafeExpandEnvironmentStrings(TEXT("%systemroot%\\system32\\setup\\fxsocm.dll"), szDir, ARRAYSIZE(szDir));
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI: SafeExpandEnvironmentStrings failed, hr = %08X"), hr));
        goto Exit;
    }

    hFxsocm = LoadLibrary(szDir);
    if (!hFxsocm)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI: LoadLibrary failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;        
    }

    pfnFaxAPI = (PFN_FAXAPI) GetProcAddress(hFxsocm, "SecureFaxServiceDirectories");
    if (!pfnFaxAPI)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CallFaxServiceAPI: GetProcAddress failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;        
    }

    hr = pfnFaxAPI(szCommonAppData);

Exit:

    if (hFxsocm)
        FreeLibrary(hFxsocm);

    return hr;
}

//*****************************************************************************
//
//  SecureCommonProfiles()
//
//  Purpose:    Set the DACLs for the all user's profile and default profile.
//              It will be executed after the FAT->NTFS conversion. We will
//              apply a security template to the all user's profile to ensure
//              a proper DACL for the Windows components, other apps that set
//              specific DACLs under All User's profile will remain everyone(F)
//              since we have no idea what DACL should we set to.
//
//  Parameters: None
//
//  Return:     HRESULT
//
//  Comments:                 
//
//  History:    Date        Author     Comment
//              09/18/2002  mingzhu    Created
//
//*****************************************************************************

//
//  Required typedefs for the API we need to call, SceConfigSystem.
//

#include "secedit.h"

typedef SCESTATUS (WINAPI *PFN_SceConfigureSystem)
(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
);


HRESULT SecureCommonProfiles()
{
    HRESULT                 hr = E_FAIL;
    HMODULE                 hSceCli = NULL;
    DWORD                   dwErr;
    SCESTATUS               status;
    TCHAR                   szWindows[64];
    TCHAR                   szInfFile[MAX_PATH];  //TEXT("%SystemRoot%\\Inf\\ProfSec.Inf");
    TCHAR                   szDatabase[MAX_PATH]; //TEXT("%SystemRoot%\\Security\\Database\\ProfSec.sdb");
    TCHAR                   szLogFile[MAX_PATH];  //TEXT("%SystemRoot%\\Security\\Log\\ProfSec.log");
    DWORD                   dwWarning;
    DWORD                   dwOptions;
    PFN_SceConfigureSystem  pfn_SceConfigureSystem = NULL;

    InitDebugSupport(0);

    DebugMsg((DM_VERBOSE, TEXT("SecureCommonProfile: Entering...")));

    //
    //  1. First set a series environment variables that used in the inf file
    //

    PrepareEnvironmentVariables();

    //
    //  2. Load the security library and get the function
    //

    hSceCli = LoadLibrary(TEXT("SceCli.dll"));
    if (!hSceCli)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: LoadLibrary failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;        
    }

    pfn_SceConfigureSystem = (PFN_SceConfigureSystem) GetProcAddress (hSceCli, "SceConfigureSystem");
    if (!pfn_SceConfigureSystem)
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: GetProcAddress failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;        
    }

    //
    //  3. Get the windows directory
    //

    if (!GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows)))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: GetWindowsDirectory failed, error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;        
    }
    
    //
    //  4. Get the path for our INF file
    //

    hr = StringCchPrintf(szInfFile, ARRAYSIZE(szInfFile), TEXT("%s\\Inf\\ProfSec.Inf"), szWindows);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: StringCchPrintf failed, hr = %08X"), hr));
        goto Exit;        
    }

    //
    //  5. Get the path for the data base 
    //

    hr = StringCchPrintf(szDatabase, ARRAYSIZE(szDatabase), TEXT("%s\\Security\\Database\\ProfSec.sdb"), szWindows);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: StringCchPrintf failed, hr = %08X"), hr));
        goto Exit;        
    }

    //
    //  6. Get the path for the log file
    //

    hr = StringCchPrintf(szLogFile, ARRAYSIZE(szLogFile), TEXT("%s\\Security\\Logs\\ProfSec.log"), szWindows);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: StringCchPrintf failed, hr = %08X"), hr));
        goto Exit;        
    }

    //
    //  7. Call the API
    //

    dwOptions = SCE_OVERWRITE_DB | SCE_VERBOSE_LOG;
    
    status = pfn_SceConfigureSystem(NULL,               // System Name
                                    szInfFile,          // InfFileName
                                    szDatabase,         // DatabaseName
                                    szLogFile,          // LogFileName
                                    dwOptions,          // Options 
                                    AREA_FILE_SECURITY, // Area information
                                    NULL,               // Area call back
                                    NULL,               // Call back window
                                    &dwWarning);        // Warning

    if (status != SCESTATUS_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("SecureCommonProfile: SceConfigureSystem failed, status = %d, warning = %d"), status, dwWarning));
        hr = E_FAIL;
        goto Exit;        
    }

    //
    //  Success!
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureCommonProfile: Success!")));
    hr = S_OK;
    
Exit:

    if (hSceCli)
        FreeLibrary(hSceCli);

    return hr;
}

//*****************************************************************************
//
//  SetEnvFromResource()
//
//  Purpose:    Get the localized strings for subfolders of all user's profile
//              and set it to the environment variable 
//
//  Parameters: 
//
//  Return:     HRESULT
//
//  Comments:                 
//
//  History:    Date        Author     Comment
//              09/18/2002  mingzhu    Created
//
//*****************************************************************************

HRESULT SetEnvFromResource(DWORD dwResID, LPCTSTR szEnvVar, LPTSTR lpEnd, size_t cchEnd, LPTSTR szBuffer)  
{
    HRESULT     hr = E_FAIL;
    DWORD       dwErr;
    DWORD       dwIndex;

    for (dwIndex = 0; dwIndex < g_dwNumCommonShellFolders; dwIndex++)
    {
        if (c_CommonShellFolders[dwIndex].iFolderID == dwResID)
        {
            hr = StringCchCopy (lpEnd, cchEnd, c_CommonShellFolders[dwIndex].szFolderLocation);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("SetEnvFromResource : StringCchCopy for %s failed, hr = %08X"), szEnvVar, hr));
                goto Exit;
            }

            if (!SetEnvironmentVariable(szEnvVar, szBuffer))
            {
                dwErr = GetLastError();
                DebugMsg((DM_WARNING, TEXT("SetEnvFromResource: SetEnvironmentVariable for %s failed, error = %d"), szEnvVar, dwErr));
                hr = HRESULT_FROM_WIN32(dwErr);
                goto Exit;
            }

            DebugMsg((DM_VERBOSE, TEXT("SetEnvFromResource: set %s = %s"), szEnvVar, szBuffer));

            hr = S_OK;
            goto Exit;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("SetEnvFromResource: can't find folder name for %s"), szEnvVar));
    hr = S_FALSE;

Exit:

    return hr;
}

//*****************************************************************************
//
//  PrepareEnvironmentVariables()
//
//  Purpose:    Prepare environment variables used by the profile security 
//              template file.
//
//  Parameters: None
//
//  Return:     HRESULT
//
//  Comments:                 
//
//  History:    Date        Author     Comment
//              09/18/2002  mingzhu    Created
//
//*****************************************************************************

HRESULT PrepareEnvironmentVariables()
{
    HRESULT     hr = E_FAIL;
    TCHAR       szBuffer[MAX_PATH];
    DWORD       dwSize;
    DWORD       dwErr;
    LPTSTR      lpEnd;
    UINT        cchEnd;
    TCHAR       szTemp[MAX_PATH];

    //
    //  Set the default user profile path
    //

    dwSize = ARRAYSIZE(szBuffer);
    if (!GetDefaultUserProfileDirectoryEx(szBuffer, &dwSize, TRUE))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PrepareEnvironmentVariables: GetDefaultUserProfileDirectoryEx failed, error = %d"), dwErr));
    }
    else
    {
        if (!SetEnvironmentVariable(TEXT("DEFAULTUSERPROFILE"), szBuffer))
        {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PrepareEnvironmentVariables: SetEnvironmentVariable for default user failed, error = %d"), dwErr));
        }
    }
    
    //
    //  Set the all users profile path
    //

    dwSize = ARRAYSIZE(szBuffer);
    if (!GetAllUsersProfileDirectoryEx(szBuffer, &dwSize, TRUE))
    {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PrepareEnvironmentVariables: GetAllUsersProfileDirectoryEx failed, error = %d"), dwErr));
    }
    else
    {
        if (!SetEnvironmentVariable(TEXT("ALLUSERSPROFILE"), szBuffer))
        {
            dwErr = GetLastError();
            DebugMsg((DM_WARNING, TEXT("PrepareEnvironmentVariables: SetEnvironmentVariable failed, error = %d"), dwErr));
        }
        else
        {
            //
            //  Set all the subfolders under all user's profile
            //
            lpEnd = CheckSlashEx(szBuffer, ARRAYSIZE(szBuffer), &cchEnd);
            if (!lpEnd)
            {
                DebugMsg((DM_WARNING, TEXT("PrepareEnvironmentVariables : CheckSlashEx failed!")));
            }
            else
            {
                SetEnvFromResource(IDS_SH_APPDATA,    TEXT("COMMON_APPDATA"),   lpEnd, cchEnd, szBuffer);
                SetEnvFromResource(IDS_SH_DESKTOP,    TEXT("COMMON_DESKTOP"),   lpEnd, cchEnd, szBuffer);
                SetEnvFromResource(IDS_SH_FAVORITES,  TEXT("COMMON_FAVORITES"), lpEnd, cchEnd, szBuffer);
                SetEnvFromResource(IDS_SH_STARTMENU,  TEXT("COMMON_STARTMENU"), lpEnd, cchEnd, szBuffer);
                SetEnvFromResource(IDS_SH_TEMPLATES,  TEXT("COMMON_TEMPLATES"), lpEnd, cchEnd, szBuffer);
                SetEnvFromResource(IDS_SH_SHAREDDOCS, TEXT("COMMON_DOCS"),      lpEnd, cchEnd, szBuffer);
            }
        }
    }

    //
    //  Success!
    //

    hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\userdiff.c ===
//*************************************************************
//
//  Userdiff.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "strsafe.h"

#define MAX_KEY_NAME    MAX_PATH

BOOL AddUDNode (LPUDNODE *lpList, LPTSTR lpBuildNumber);
BOOL FreeUDList (LPUDNODE lpList);
BOOL ProcessBuild(LPPROFILE lpProfile, LPUDNODE lpItem, LPVOID pEnv);
BOOL ProcessHive(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey);
BOOL ProcessFiles(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey);
BOOL ProcessPrograms(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey, LPVOID pEnv);
BOOL OkToProcessItem(DWORD dwProductType);

//*************************************************************
//
//  ProcessUserDiff()
//
//  Purpose:    Processes the userdiff hive
//
//  Parameters: lpProfile       -   Profile information
//              dwBuildNumber   -   profile build #
//              pEnv            -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/2/95     ericflo    Created
//
//*************************************************************

BOOL ProcessUserDiff (LPPROFILE lpProfile, DWORD dwBuildNumber, LPVOID pEnv)
{
    TCHAR szUserDiff[MAX_PATH] = {0};
    TCHAR szName[MAX_KEY_NAME];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LPUDNODE lpList = NULL, lpItem;
    LONG lResult;
    HKEY hKeyUserDiff;
    UINT Index = 0;
    DWORD dwSize;
    FILETIME ftWrite;
    DWORD cchNeeded;
    BOOL  bUserDifrExist = FALSE;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  Entering.")));


    //
    // Test if the hive exists, first look for USERDIFR
    //

    cchNeeded = ExpandUserEnvironmentStrings(pEnv, USERDIFR_LOCATION, szUserDiff, MAX_PATH);

    if (cchNeeded > 0 && cchNeeded <= MAX_PATH)
    {
        hFile = FindFirstFile (szUserDiff, &fd);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            bUserDifrExist = TRUE;
            FindClose(hFile);
        }
    }

    if (!bUserDifrExist)
    {
        BOOL bUserDiffExist = FALSE;
        
        DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  userdifr hive doesn't exist.  Trying userdiff.")));

        cchNeeded = ExpandUserEnvironmentStrings(pEnv, USERDIFF_LOCATION, szUserDiff, MAX_PATH);

        if (cchNeeded > 0 && cchNeeded <= MAX_PATH)
        {
            hFile = FindFirstFile (szUserDiff, &fd);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                bUserDiffExist = TRUE;
                FindClose(hFile);
            }
        }

        if (!bUserDiffExist)
        {
            DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  userdiff hive doesn't exist.  Leaving.")));
            return TRUE;
        }
    }

    //
    // Load the hive
    //

    if (MyRegLoadKey(HKEY_USERS, USERDIFF, szUserDiff) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  Failed to load userdiff.")));
        return FALSE;
    }

    //
    // Open the key
    //

    lResult = RegOpenKeyEx(HKEY_USERS, USERDIFF, 0, KEY_READ, &hKeyUserDiff);

    if (lResult != ERROR_SUCCESS) {
        MyRegUnLoadKey(HKEY_USERS, USERDIFF);
        DebugMsg((DM_WARNING, TEXT("ProcessUserDiff:  failed to open registry root (%d)"), lResult));
        return FALSE;
    }

    //
    // Enumerate the build numbers
    //

    dwSize = MAX_KEY_NAME;
    lResult = RegEnumKeyEx(hKeyUserDiff, Index, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            //
            // Add the node
            //

            if (!AddUDNode (&lpList, szName)) {
                break;
            }

            Index++;
            dwSize = MAX_KEY_NAME;

            lResult = RegEnumKeyEx(hKeyUserDiff, Index, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }


    //
    // Close the open key
    //

    RegCloseKey(hKeyUserDiff);


    //
    // Process the builds
    //

    lpItem = lpList;

    while (lpItem) {

        //
        // Only want to apply changes that occurred in
        // builds after the one the user is running.
        //

        if ( (lpItem->dwBuildNumber > dwBuildNumber) &&
              (lpItem->dwBuildNumber <= g_dwBuildNumber) )  {
            ProcessBuild(lpProfile, lpItem, pEnv);
        }

        lpItem = lpItem->pNext;
    }


    //
    // Free the link list
    //

    FreeUDList (lpList);


    //
    // Unload the hive
    //

    MyRegUnLoadKey(HKEY_USERS, USERDIFF);


    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessUserDiff:  Leaving successfully.")));

    return TRUE;

}

//*************************************************************
//
//  AddUDNode()
//
//  Purpose:    Adds a build node to the link listed
//              sorted by build number
//
//  Parameters: lpList         -   Link list of nodes
//              lpBuildNumber  -   New node name
//      
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL AddUDNode (LPUDNODE *lpList, LPTSTR lpBuildNumber)
{
    LPUDNODE lpNewItem;
    LPUDNODE lpHead, lpPrev;

    if (!lpBuildNumber || !*lpBuildNumber) {
        return TRUE;
    }


    //
    // Setup the new node
    //

    lpNewItem = (LPUDNODE) LocalAlloc(LPTR, sizeof(UDNODE));

    if (!lpNewItem) {
        return FALSE;
    }

    StringCchCopy (lpNewItem->szBuildNumber, MAX_BUILD_NUMBER, lpBuildNumber);
    lpNewItem->dwBuildNumber = StringToInt(lpBuildNumber);
    lpNewItem->pNext = NULL;


    //
    // Now add it to the list sorted
    //

    lpHead = *lpList;
    lpPrev = NULL;


    if (!lpHead) {

        //
        // First item in the list
        //

        *lpList = lpNewItem;

        return TRUE;
    }


    //
    // If we made it here, there is one or more items in the list
    //


    while (lpHead) {

        if (lpNewItem->dwBuildNumber <= lpHead->dwBuildNumber) {

            if (lpPrev) {

                //
                // Insert the item
                //

                lpPrev->pNext = lpNewItem;
                lpNewItem->pNext = lpHead;
                return TRUE;

            } else {

                //
                // Head of the list
                //

                lpNewItem->pNext = lpHead;
                *lpList = lpNewItem;
                return TRUE;

            }

        }

        lpPrev = lpHead;
        lpHead = lpHead->pNext;
    }


    //
    // Add node to the end of the list
    //

    lpPrev->pNext = lpNewItem;


    return TRUE;
}


//*************************************************************
//
//  FreeUDList()
//
//  Purpose:    Free's a UDNODE link list
//
//  Parameters: lpList  -   List to be freed
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL FreeUDList (LPUDNODE lpList)
{
    LPUDNODE lpNext;


    if (!lpList) {
        return TRUE;
    }


    lpNext = lpList->pNext;

    while (lpList) {
        LocalFree (lpList);
        lpList = lpNext;

        if (lpList) {
            lpNext = lpList->pNext;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  ProcessBuild()
//
//  Purpose:    Processes the changes for a specific build
//
//  Parameters: lpProfile   -   Profile information
//              lpItem  -   Build item to process
//              pEnv    -   Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessBuild(LPPROFILE lpProfile, LPUDNODE lpItem, LPVOID pEnv)
{
    TCHAR szSubKey[MAX_PATH];
    LONG lResult;
    HKEY hKey;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessBuild:  Entering with build <%s>."),
             lpItem->szBuildNumber));


    //
    // Open "Hive" subkey
    //
    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Hive"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessHive(lpProfile, lpItem, hKey);
        RegCloseKey (hKey);
    }


    //
    // Open "Files" subkey
    //

    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Files"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessFiles(lpProfile, lpItem, hKey);
        RegCloseKey (hKey);
    }


    //
    // Open "Execute" subkey
    //

    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Execute"), USERDIFF, lpItem->szBuildNumber);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {
        ProcessPrograms(lpProfile, lpItem, hKey, pEnv);
        RegCloseKey (hKey);
    }

    //
    // Success
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessBuild:  Leaving successfully.")));

    return TRUE;

}

//*************************************************************
//
//  ProcessHive()
//
//  Purpose:    Processes the Hive entry for a build
//
//  Parameters: lpProfile   -   Profile information
//              lpItem      -   Build item
//              hKey        -   Registry key to enumerate
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessHive(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szValueName[MAX_KEY_NAME];
    DWORD dwSize, dwType, dwAction, dwDisp, dwFlags, dwProductType;
    LPBYTE lpValueData;
    LONG lResult;
    UINT Index = 1;
    FILETIME ftWrite;
    HKEY hKeyEntry, hKeyTemp;
    LPTSTR lpName;


    DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Entering.")));

    //
    // Process the entry
    //

    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Hive\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  No hive entries.")));
        goto Exit;
    }


    do {

        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the action type
        //

        dwSize = sizeof(dwAction);
        lResult = RegQueryValueEx(hKeyEntry, UD_ACTION, NULL, &dwType,
                                  (LPBYTE)&dwAction, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            switch (dwAction) {

                DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Item %d has an action of %d."),
                         Index, dwAction));

                case 1: {
                    //
                    // Add New Key
                    //
                    // Get the key name
                    //

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult == ERROR_SUCCESS) {

                       lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                                 szSubKey, 0, NULL,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS, NULL,
                                                 &hKeyTemp, &dwDisp);

                       if (lResult == ERROR_SUCCESS) {

                           DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Created subkey <%s>."),
                                    szSubKey));

                           RegCloseKey(hKeyTemp);
                       } else {

                           DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create subkey <%s> with error %d."),
                                    szSubKey, lResult));
                       }
                   }

                   }
                   break;

                case 2: {
                    //
                    // Delete a key and all it's subkeys
                    //
                    // Get the key name
                    //

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult == ERROR_SUCCESS) {

                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Calling RegDelnode on <%s>."),
                                szSubKey));

                       RegDelnode (lpProfile->hKeyCurrentUser, szSubKey);
                   }

                   }
                   break;

                case 3: {
                    //
                    // Add a new value
                    //
                    // Get the key name
                    //

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Adding a new value.")));

                   dwSize = MAX_PATH * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to get UD_KEYNAME with error %d."), lResult));
                       goto LoopAgain;
                   }

                   lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                             szSubKey, 0, NULL,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS, NULL,
                                             &hKeyTemp, &dwDisp);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create UD_KEYNAME with error %d."), lResult));
                       goto LoopAgain;
                   }


                   //
                   // Query for the value name
                   //

                   dwSize = MAX_KEY_NAME * sizeof(TCHAR);
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAME, NULL, &dwType,
                                             (LPBYTE)szValueName, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query UD_VALUENAME with error %d."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data size
                   //

                   dwSize = 0;
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUE, NULL, &dwType,
                                             NULL, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query UD_VALUE with error %d."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Allocate space for the data
                   //

                   lpValueData = LocalAlloc (LPTR, dwSize);

                   if (!lpValueData) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  LocalAlloc failed (%d)."), GetLastError()));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data
                   //

                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUE, NULL, &dwType,
                                             lpValueData, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query value data with error %d."), lResult));
                       LocalFree (lpValueData);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Set the new value
                   //

                   RegSetValueEx(hKeyTemp, szValueName, 0, dwType,
                                 lpValueData, dwSize);


                   //
                   // Clean up
                   //

                   LocalFree (lpValueData);

                   RegCloseKey(hKeyTemp);

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Finished adding value <%s>."), szValueName));
                   }
                   break;

                case 4: {
                   //
                   // Delete value(s)
                   //
                   // Get the key name
                   //

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Entering delete a value.")));

                   dwSize = ARRAYSIZE(szSubKey);
                   lResult = RegQueryValueEx(hKeyEntry, UD_KEYNAME, NULL, &dwType,
                                             (LPBYTE)szSubKey, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value to delete (%d)."), lResult));
                       goto LoopAgain;
                   }

                   lResult = RegCreateKeyEx (lpProfile->hKeyCurrentUser,
                                             szSubKey, 0, NULL,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS, NULL,
                                             &hKeyTemp, &dwDisp);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to create key (%s) for value to delete (%d)."), szSubKey, lResult));
                       goto LoopAgain;
                   }


                   //
                   // Query for the flags
                   //

                   dwSize = sizeof(dwFlags);
                   lResult = RegQueryValueEx(hKeyEntry, UD_FLAGS, NULL, &dwType,
                                             (LPBYTE)&dwFlags, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       dwFlags = 0;
                   }


                   //
                   // Process the flags
                   //

                   if (dwFlags == 2) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Calling DeleteAllValues.")));
                       DeleteAllValues (hKeyTemp);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value names size
                   //

                   dwSize = 0;
                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAMES, NULL, &dwType,
                                             NULL, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value names to delete (%d)."), lResult));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Allocate space for the data
                   //

                   lpValueData = LocalAlloc (LPTR, dwSize);

                   if (!lpValueData) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  LocalAlloc failed (%d)."), GetLastError()));
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Query for the value data
                   //

                   lResult = RegQueryValueEx(hKeyEntry, UD_VALUENAMES, NULL, &dwType,
                                             lpValueData, &dwSize);

                   if (lResult != ERROR_SUCCESS) {
                       DebugMsg((DM_WARNING, TEXT("ProcessHive:  Failed to query for value data to delete (%d)."), lResult));
                       LocalFree (lpValueData);
                       RegCloseKey(hKeyTemp);
                       goto LoopAgain;
                   }


                   //
                   // Delete the values
                   //

                   lpName = (LPTSTR) lpValueData;

                   while (*lpName) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Deleting (%s)."), lpName));
                       RegDeleteValue (hKeyTemp, lpName);
                       lpName += lstrlen(lpName) + 1;
                   }


                   //
                   // Delete the no-name value if appropriate
                   //

                   if (dwFlags == 1) {
                       DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Deleting no name value.")));
                       RegDeleteValue (hKeyTemp, NULL);
                   }


                   //
                   // Clean up
                   //

                   LocalFree (lpValueData);
                   RegCloseKey(hKeyTemp);

                   DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Leaving deletion code.")));
                   }

                   break;
            }

        }

LoopAgain:

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Hive\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("ProcessHive:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  ProcessFiles()
//
//  Purpose:    Processes the Files entry for a build
//
//  Parameters: lpProfile - Profile information
//              lpItem    -   Build item
//              hKey      -   Registry key to enumerate
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

BOOL ProcessFiles(LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szItem[MAX_PATH];
    LPTSTR lpEnd, lpTemp;
    DWORD dwSize, dwType, dwAction, dwProductType;
    LONG lResult;
    UINT Index = 1;
    FILETIME ftWrite;
    HKEY hKeyEntry;
    HANDLE hOldToken;
    BOOL   bImpersonateUser = FALSE;
    DWORD  cchEnd;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Entering.")));


    //
    // Process the entry
    //

    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Files\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  No Files entries.")));
        goto Exit;
    }


    do {
        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the action type
        //

        dwSize = sizeof(dwAction);
        lResult = RegQueryValueEx(hKeyEntry, UD_ACTION, NULL, &dwType,
                                  (LPBYTE)&dwAction, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to query action type (%d)."), lResult));
            goto LoopAgain;
        }


        //
        // Query for the item
        //

        dwSize = ARRAYSIZE(szItem);
        lResult = RegQueryValueEx(hKeyEntry, UD_ITEM, NULL, &dwType,
                                  (LPBYTE)szItem, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to query UD_ITEM type (%d)."), lResult));
            goto LoopAgain;
        }

        DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Item %d has an action of %d."),
                 Index, dwAction));

        //
        // Impersonate the user
        //

        if (!ImpersonateUser(lpProfile->hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ProcessFiles: Failed to impersonate user")));
            RegCloseKey(hKeyEntry);
            goto Exit;
        }
        bImpersonateUser = TRUE;

        switch (dwAction) {

            case 1:

               //
               // Create new program group
               //

               if (GetSpecialFolderPath (CSIDL_PROGRAMS, szDest))
               {
                   lpEnd = CheckSlashEx(szDest, ARRAYSIZE(szDest), &cchEnd);
                   if (lpEnd)
                   {
                       StringCchCopy (lpEnd, cchEnd, szItem);

                       if (CreateNestedDirectory(szDest, NULL)) {
                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Created new group (%s)."), szDest));
                       } else {
                           DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to created new group (%s) with (%d)."),
                                    szDest, GetLastError()));
                       }
                   }
               }
               break;

            case 2:
               //
               // Delete a program group
               //

               if (GetSpecialFolderPath (CSIDL_PROGRAMS, szDest))
               {
                   lpEnd = CheckSlashEx(szDest, ARRAYSIZE(szDest), &cchEnd);
                   if (lpEnd)
                   {
                       StringCchCopy (lpEnd, cchEnd, szItem);

                       Delnode(szDest);
        
                       DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted group (%s)."), szDest));
                   }
               }
               break;

            case 3:
               {
                   TCHAR szStartMenu [MAX_FOLDER_SIZE];

                   //
                   // Add a new item
                   //

                   dwSize = ARRAYSIZE(szSrc);
                   if (!GetDefaultUserProfileDirectory(szSrc, &dwSize)) {
                       DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to get default user profile.")));
                       goto LoopAgain;
                   }

                   lpEnd = CheckSlashEx(szSrc, ARRAYSIZE(szSrc), &cchEnd);
                   if (lpEnd)
                   {
                       if (LoadString (g_hDllInstance, IDS_SH_PROGRAMS, szStartMenu,
                                   MAX_FOLDER_SIZE)) {

                           StringCchCopy (lpEnd, cchEnd, szStartMenu);
                           lpEnd = CheckSlashEx(szSrc, ARRAYSIZE(szSrc), &cchEnd);
                           if (lpEnd)
                           {
                               StringCchCopy (lpEnd, cchEnd, szItem);

                               if (GetSpecialFolderPath (CSIDL_PROGRAMS, szDest))
                               {
                                   lpEnd = CheckSlashEx(szDest, ARRAYSIZE(szDest), &cchEnd);
                                   if (lpEnd)
                                   {
                                       StringCchCopy (lpEnd, cchEnd, szItem);

                                       if (CopyFile (szSrc, szDest, FALSE)) {
                                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  <%s> ==> <%s>  [OK]."),
                                                    szSrc, szDest));
                                       } else {
                                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  <%s> ==> <%s>  [FAILED %d]."),
                                                    szSrc, szDest, GetLastError()));
                                       }
                                   }
                               }
                           }
                       }
                   }
               }
               break;

            case 4:
               //
               // Delete a program item
               //

               if (GetSpecialFolderPath (CSIDL_PROGRAMS, szDest))
               {
                   lpEnd = CheckSlashEx(szDest, ARRAYSIZE(szDest), &cchEnd);
                   if (lpEnd)
                   {
                       StringCchCopy (lpEnd, cchEnd, szItem);

                       if (DeleteFile(szDest)) {
                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted <%s>"), szDest));
                       } else {
                           DebugMsg((DM_WARNING, TEXT("ProcessFiles:  Failed to deleted <%s> with %d"), szDest, GetLastError()));
                       }

                       //
                       // Attempt to delete the directory
                       //

                       lpTemp = szDest + lstrlen(szDest) - 1;
                       lpEnd--;

                       while ((*lpTemp != TEXT('\\')) && lpTemp > lpEnd) {
                           lpTemp--;
                       }

                       if (lpTemp == lpEnd) {
                           break;
                       }

                       *lpTemp = TEXT('\0');

                       if (RemoveDirectory(szDest)) {
                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Deleted directory <%s>"), szDest));
                       } else {
                           DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Failed to delete directory <%s> with %d"), szDest, GetLastError()));
                       }
                   }
               }
               break;
        }


LoopAgain:

        if (bImpersonateUser) {
            //
            // Revert to being 'ourself'
            //

            if (!RevertToUser(&hOldToken)) {
                DebugMsg((DM_WARNING, TEXT("ProcessFiles: Failed to revert to self")));
            }
            bImpersonateUser = FALSE;
        }

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Files\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("ProcessFiles:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  ProcessPrograms()
//
//  Purpose:    Processes the Execute entry for a build
//
//  Parameters: lpProfile - Profile information
//              lpItem    - Build item
//              hKey      - Registry key to enumerate
//              pEnv      - Environment block
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/16/95    ericflo    Created
//
//*************************************************************

BOOL ProcessPrograms (LPPROFILE lpProfile, LPUDNODE lpItem, HKEY hKey, LPVOID pEnv)
{
    TCHAR szSubKey[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szFullPath[MAX_PATH];
    DWORD dwSize, dwType, dwProductType;
    LONG lResult;
    UINT Index = 1;
    HKEY hKeyEntry;
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    BOOL Result;
    DWORD  dwTokenSessionId;
    DWORD  dwProcessSessionId;
    HANDLE hPrimaryToken = NULL;
    BOOL   bTokenCreated = FALSE;
    DWORD  cchExpanded;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Entering.")));


    //
    // Process the entry
    //

    StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Execute\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
    lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  No execute entries.")));
        goto Exit;
    }

    //
    // Get the session id info for user token. In TS?FUS case we can't
    // create process across the session as it not yet received 
    // WL_NOTIFY_LOGON notification from winlogon
    //

    dwProcessSessionId = NtCurrentPeb()->SessionId;
    if (GetTokenInformation(lpProfile->hTokenUser,
                            TokenSessionId,
                            (LPVOID) &dwTokenSessionId,
                            sizeof(dwTokenSessionId),
                            &dwSize) &&
        dwTokenSessionId != dwProcessSessionId) {

        //
        // We are loading profile for a remote session
        // So first create a primary token and change 
        // the session id in it for CreateProcessAsUser 
        // to work
        //
 
        if (!DuplicateTokenEx(lpProfile->hTokenUser, 
                              TOKEN_ALL_ACCESS,
                              NULL, SecurityImpersonation, 
                              TokenPrimary,
                              &hPrimaryToken)) {
            DebugMsg((DM_WARNING, TEXT("ProcessPrograms: Failed to create primary token. Error %d"), GetLastError()));
            goto Exit;
        }
        bTokenCreated = TRUE;

        // Set the session id in new primary token
        if (!SetTokenInformation(hPrimaryToken,
                                 TokenSessionId,
                                 (LPVOID) &dwProcessSessionId,
                                 sizeof(dwProcessSessionId))) {
            DebugMsg((DM_WARNING, TEXT("ProcessPrograms: Failed to set session id in primary token. Error %d"), GetLastError()));
            goto Exit;
        }
    }
    else {
        hPrimaryToken = lpProfile->hTokenUser;
    }
         

    do {

        //
        // Query for the product type
        //

        dwSize = sizeof(dwProductType);
        lResult = RegQueryValueEx(hKeyEntry, UD_PRODUCTTYPE, NULL, &dwType,
                                  (LPBYTE)&dwProductType, &dwSize);


        //
        // It's ok to not have a product type listed in userdiff.ini.
        // In this case, we always apply the change regardless of the
        // platform.
        //

        if (lResult == ERROR_SUCCESS) {

            //
            // A specific product was listed.  Check if
            // we can process this entry.
            //

            if (!OkToProcessItem(dwProductType)) {
                DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Skipping Item %d due to product type mismatch."), Index));
                goto LoopAgain;
            }
        }


        //
        // Query for the command line
        //


        dwSize = MAX_PATH * sizeof(TCHAR);
        lResult = RegQueryValueEx(hKeyEntry, UD_COMMANDLINE, NULL, &dwType,
                                  (LPBYTE)szCmdLine, &dwSize);

        if (lResult != ERROR_SUCCESS) {
            goto LoopAgain;
        }


        //
        // If we have a NULL path, loop again.
        //

        if (szCmdLine[0] == TEXT('\0')) {
            goto LoopAgain;
        }

        /*
        //
        //  If the command line is not begin with %SystemRoot%, skip it.
        //
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, 
                          szCmdLine, lstrlen(TEXT("%SystemRoot%")), TEXT("%SystemRoot%"), -1) != CSTR_EQUAL) 
        {
            DebugMsg((DM_WARNING, TEXT("ProcessPrograms:  Skipping %s, since it is not from %SystemRoot%."), szCmdLine));
            goto LoopAgain;
        }
        */

        //
        // Expand the command line
        //

        cchExpanded = ExpandUserEnvironmentStrings(pEnv, szCmdLine, szFullPath, MAX_PATH);

        if (cchExpanded > 0 && cchExpanded < MAX_PATH)
        {
            //
            // Initialize process startup info
            //

            si.cb = sizeof(STARTUPINFO);
            si.lpReserved = NULL;
            si.lpTitle = NULL;
            si.lpDesktop = NULL;
            si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_SHOWNORMAL;
            si.lpReserved2 = NULL;
            si.cbReserved2 = 0;


            //
            // Start the app
            //

            Result = CreateProcessAsUser(hPrimaryToken, NULL, szFullPath,
                                         NULL, NULL, FALSE,
                                         NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT, 
                                         pEnv, NULL, &si, &ProcessInformation);

            if (Result) {

                DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Spawned <%s>.  Waiting for it to complete."),
                          szFullPath));

                //
 