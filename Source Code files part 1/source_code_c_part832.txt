le (TRUE);

    if (m_lState == IRTIR_TASK_SUSPENDED)
    {
        return E_PENDING;
    }

    if (m_lState == IRTIR_TASK_PENDING)
    {
        // it is being killed,
        // close the renderer down...
        m_pOleObject->Close(OLECLOSE_NOSAVE);
    }
    
    return S_OK;
}

HRESULT CHtmlThumb::Finish(HBITMAP * phBmp, const SIZE * prgSize, DWORD dwClrDepth)
{
    HRESULT hr = S_OK;
    RECTL rcLRect;
    HBITMAP hOldBmp = NULL;
    HBITMAP hHTMLBmp = NULL;
    BITMAPINFO * pBMI = NULL;
    LPVOID pBits;
    HPALETTE hpal = NULL;;
    
    // size is in pixels...
    SIZEL rgSize;
    rgSize.cx = m_dwXRenderSize;
    rgSize.cy = m_dwYRenderSize;
            
    //draw into temp DC
    HDC hDesktopDC = GetDC(NULL);
    HDC hdcHTML = CreateCompatibleDC(hDesktopDC);
    if (hdcHTML == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (dwClrDepth == 8)
    {
        // use the shell's palette as the default
        hpal = SHCreateShellPalette(hDesktopDC);
    }
    else if (dwClrDepth == 4)
    {
        // use the stock 16 colour palette...
        hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
    }
    
    if (SUCCEEDED(hr))
    {
        CreateSizedDIBSECTION(&rgSize, dwClrDepth, hpal, NULL, &hHTMLBmp, &pBMI, &pBits);
        if (hHTMLBmp == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        hOldBmp = (HBITMAP) SelectObject(hdcHTML, hHTMLBmp);
            
        BitBlt(hdcHTML, 0, 0, rgSize.cx, rgSize.cy, NULL, 0, 0, WHITENESS);

        /****************** RENDER HTML PAGE to MEMORY DC *******************
        
          We will now call IViewObject::Draw in MSHTML to render the loaded
          URL into the passed in hdcMem.  The extent of the rectangle to
          render in is in RectForViewObj.  This is the call that gives
          us the image to scroll, animate, or whatever!
            
        ********************************************************************/
        rcLRect.left = 0;
        rcLRect.right = rgSize.cx;
        rcLRect.top = 0;
        rcLRect.bottom = rgSize.cy;

        hr = m_pViewObject->Draw(DVASPECT_CONTENT,
                            NULL, NULL, NULL, NULL,
                            hdcHTML, &rcLRect,
                            NULL, NULL, NULL);         

        SelectObject(hdcHTML, hOldBmp);
    }

    if (SUCCEEDED(hr))
    {
        SIZEL rgCur;
        rgCur.cx = rcLRect.bottom;
        rgCur.cy = rcLRect.right;

        ASSERT(pBMI);
        ASSERT(pBits);
        hr = ConvertDIBSECTIONToThumbnail(pBMI, pBits, phBmp, prgSize, dwClrDepth, hpal, 50, FALSE);
    }

    if (hHTMLBmp)
    {
        DeleteObject(hHTMLBmp);
    }
    
    if (hDesktopDC)
    {
        ReleaseDC(NULL, hDesktopDC);
    }

    if (hdcHTML)
    {
        DeleteDC(hdcHTML);
    }

    if (pBMI)
    {
        LocalFree(pBMI);
    }
    if (hpal)
    {
        DeleteObject(hpal);
    }
    
    return hr;
}
        
HRESULT CHtmlThumb::CheckReadyState()
{
    VARIANT     varState;
    DISPPARAMS  dp;

    if (!m_pHTML)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }    
    
    VariantInit(&varState);

    if (SUCCEEDED(m_pHTML->Invoke(DISPID_READYSTATE, 
                          IID_NULL, 
                          GetUserDefaultLCID(), 
                          DISPATCH_PROPERTYGET, 
                          &dp, 
                          &varState, NULL, NULL)) &&
        V_VT(&varState)==VT_I4 && 
        V_I4(&varState)== READYSTATE_COMPLETE)
    {
        // signal the end ..
        SetEvent(m_hDone);
    }

    return S_OK;
}

HRESULT CHtmlThumb::Create_URL_Moniker(IMoniker ** ppMoniker)
{
    // we are dealing with a URL file
    WCHAR szURLData[8196];

    // URL files are actually ini files that
    // have a section [InternetShortcut]
    // and a Value URL=.....
    int iRet = SHGetIniStringW(L"InternetShortcut", L"URL",
            szURLData, ARRAYSIZE(szURLData), m_szPath);

    if (iRet == 0)
    {
        return E_FAIL;
    }

    return CreateURLMoniker(0, szURLData, ppMoniker);
}

STDMETHODIMP CHtmlThumb::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pszFileName)
    {
        hr = StringCchCopyW(m_szPath, ARRAYSIZE(m_szPath), pszFileName);
        if (SUCCEEDED(hr))
        {
            DWORD dwAttrs = GetFileAttributesWrapW(m_szPath);
            if ((dwAttrs != (DWORD) -1) && (dwAttrs & FILE_ATTRIBUTE_OFFLINE))
            {
                hr = E_FAIL;
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CHtmlThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

CTridentHost::CTridentHost()
{
    m_cRef = 1;
}

CTridentHost::~CTridentHost()
{
    // all refs should have been released...
    ASSERT(m_cRef == 1);
}

HRESULT CTridentHost::SetTrident(IOleObject * pTrident)
{
    ASSERT(pTrident);

    return pTrident->SetClientSite((IOleClientSite *) this);
}

STDMETHODIMP CTridentHost::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTridentHost, IOleClientSite),
        QITABENT(CTridentHost, IDispatch),
        QITABENT(CTridentHost, IDocHostUIHandler),
        // IThumbnailView is needed by Trident for some reason.  The cast to IOleClientSite is because that's what we used to do
        QITABENTMULTI(CTridentHost, IThumbnailView, IOleClientSite),
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CTridentHost::AddRef(void)
{
    m_cRef ++;
    return m_cRef;
}

STDMETHODIMP_(ULONG) CTridentHost::Release(void)
{
    m_cRef --;

    // because we are created with our parent, we do not do a delete here..
    ASSERT(m_cRef > 0);

    return m_cRef;
}

STDMETHODIMP CTridentHost::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                  DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(pvarResult->vt == VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            pvarResult->vt = VT_I4;
            pvarResult->lVal = DLCTL_DOWNLOAD_FLAGS;
            if (m_fOffline)
            {
                pvarResult->lVal |= DLCTL_OFFLINE;
            }
            return S_OK;
            
         case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = m_fOffline ? TRUE : FALSE;
            return S_OK;

        case DISPID_AMBIENT_SILENT:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = TRUE;
            return S_OK;
        }
    }

    return DISP_E_MEMBERNOTFOUND;
}


// IOleClientSite
STDMETHODIMP CTridentHost::SaveObject()
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ShowObject()
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// IPersistMoniker stuff
STDMETHODIMP CHtmlThumb::Load(BOOL fFullyAvailable, IMoniker *pimkName, LPBC pibc, DWORD grfMode)
{
    if (!pimkName)
    {
        return E_INVALIDARG;
    }
    if (pibc || grfMode != STGM_READ)
    {
        return E_NOTIMPL;
    }

    if (m_pMoniker)
    {
        m_pMoniker->Release();
    }

    m_pMoniker = pimkName;
    ASSERT(m_pMoniker);
    m_pMoniker->AddRef();

    return S_OK;
}

STDMETHODIMP CHtmlThumb::Save(IMoniker *pimkName, LPBC pbc, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::SaveCompleted(IMoniker *pimkName, LPBC pibc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::GetCurMoniker(IMoniker **ppimkName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    if (!pInfo)
    {
        return E_INVALIDARG;
    }

    DWORD   dwIE = URL_ENCODING_NONE;
    DWORD   dwOutLen = sizeof(DWORD);
    
    UrlMkGetSessionOption(URLMON_OPTION_URL_ENCODING, &dwIE, sizeof(DWORD), &dwOutLen, NULL);

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
    if (dwIE == URL_ENCODING_ENABLE_UTF8)
    {
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8;
    }
    else
    {
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8;
    }
    
    return S_OK;
}

STDMETHODIMP CTridentHost::ShowUI(DWORD dwID,
                                     IOleInPlaceActiveObject *pActiveObject,
                                     IOleCommandTarget *pCommandTarget,
                                     IOleInPlaceFrame *pFrame,
                                     IOleInPlaceUIWindow *pDoc)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::HideUI (void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::UpdateUI (void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::EnableModeless (BOOL fEnable)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnDocWindowActivate (BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnFrameWindowActivate (BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ResizeBorder (LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::TranslateAccelerator (LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetOptionKeyPath (LPOLESTR *pchKey, DWORD dw)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::GetDropTarget (IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetExternal (IDispatch **ppDispatch)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::TranslateUrl (DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::FilterDataObject (IDataObject *pDO, IDataObject **ppDORet)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::CaptureThumbnail(const SIZE * pMaxSize, IUnknown * pHTMLDoc2, HBITMAP * phbmThumbnail)
{
    HRESULT hr = E_INVALIDARG;

    if (pMaxSize != NULL &&
        pHTMLDoc2 != NULL &&
        phbmThumbnail != NULL)
    {
        IHTMLDocument2 *pDoc = NULL;

        hr = pHTMLDoc2->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pViewObject == NULL);

            hr = pDoc->QueryInterface(IID_PPV_ARG(IViewObject, &m_pViewObject));
            if (SUCCEEDED(hr))
            {
                SIZE sizeThumbnail;

                sizeThumbnail.cy = pMaxSize->cy;
                sizeThumbnail.cx = pMaxSize->cx;

                hr = m_pViewObject->QueryInterface(IID_PPV_ARG(IOleObject, &m_pOleObject));
                if (SUCCEEDED(hr))
                {
                    SIZEL rgSize = {0,0};

                    // get the size at which trident is currently rendering
                    hr = m_pOleObject->GetExtent(DVASPECT_CONTENT, &rgSize);
                    if (SUCCEEDED(hr))
                    {
                        HDC hdcDesktop = GetDC(NULL);
                        // get the actual size at which trident renders
                        if (hdcDesktop)
                        {
                            // (overwrite) convert from himetric
                            rgSize.cx = rgSize.cx * GetDeviceCaps(hdcDesktop, LOGPIXELSX) / 2540;
                            rgSize.cy = rgSize.cy * GetDeviceCaps(hdcDesktop, LOGPIXELSY) / 2540;

                            ReleaseDC(NULL, hdcDesktop);

                            m_dwXRenderSize = rgSize.cx;
                            m_dwYRenderSize = rgSize.cy;

                            DWORD dwColorDepth = SHGetCurColorRes();

                            hr = Finish(phbmThumbnail, &sizeThumbnail, dwColorDepth);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }

                    ASSERT(m_pOleObject != NULL);
                    m_pOleObject->Release();
                }

                ASSERT(m_pViewObject != NULL);
                m_pViewObject->Release();
            }

            ASSERT(pDoc != NULL);
            pDoc->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\gdithumb.h ===
#pragma once

#include <shimgdata.h>

// PRIORITIES
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define PRIORITY_M5         (PRIORITY_NORMAL - 5 * 0x1000)
#define PRIORITY_M4         (PRIORITY_NORMAL - 4 * 0x1000)
#define PRIORITY_M3         (PRIORITY_NORMAL - 3 * 0x1000)
#define PRIORITY_M2         (PRIORITY_NORMAL - 2 * 0x1000)
#define PRIORITY_M1         (PRIORITY_NORMAL - 1 * 0x1000)
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define PRIORITY_P1         (PRIORITY_NORMAL + 1 * 0x1000)
#define PRIORITY_P2         (PRIORITY_NORMAL + 2 * 0x1000)
#define PRIORITY_P3         (PRIORITY_NORMAL + 3 * 0x1000)
#define PRIORITY_P4         (PRIORITY_NORMAL + 4 * 0x1000)
#define PRIORITY_P5         (PRIORITY_NORMAL + 5 * 0x1000)

#define PRIORITY_EXTRACT_FAST       PRIORITY_P1
#define PRIORITY_EXTRACT_NORMAL     PRIORITY_NORMAL
#define PRIORITY_EXTRACT_SLOW       PRIORITY_M1

class CGdiPlusThumb : public IExtractImage,
                      public IPersistFile,
                      public CComObjectRoot,
                      public CComCoClass< CGdiPlusThumb, &CLSID_GdiThumbnailExtractor >
{
public:
    CGdiPlusThumb();
    ~CGdiPlusThumb();

    BEGIN_COM_MAP( CGdiPlusThumb )
        COM_INTERFACE_ENTRY( IExtractImage )
        COM_INTERFACE_ENTRY( IPersistFile )
    END_COM_MAP( )

    DECLARE_REGISTRY( CGdiPlusThumb,
                      _T("Shell.ThumbnailExtract.GdiPlus.1"),
                      _T("Shell.ThumbnailExtract.GdiPlus.1"),
                      IDS_GDITHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CGdiPlusThumb );

    // IExtractImage
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer, DWORD cch,
                            DWORD *pdwPriority, const SIZE *prgSize,
                            DWORD dwRecClrDepth, DWORD *pdwFlags);

    STDMETHOD (Extract)(HBITMAP *phBmpThumbnail);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID *pClassID);
    STDMETHOD (IsDirty)();
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR *ppszFileName);

protected:
    HRESULT CreateDibFromBitmapImage(HBITMAP *pbm);

    WCHAR   m_szPath[MAX_PATH];
    SIZE    m_rgSize;
    DWORD   m_dwRecClrDepth;
    BOOL    m_fOrigSize;
    BOOL    m_fFillBackground;
    BOOL    m_fHighQuality;

    IShellImageData * m_pImage;
    IShellImageDataFactory * m_pImageFactory;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\gdithumb.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "strsafe.h"

CGdiPlusThumb::CGdiPlusThumb()
{
    m_pImage = NULL;
    m_pImageFactory = NULL;
    m_szPath[0] = 0;
}

CGdiPlusThumb::~CGdiPlusThumb()
{
    if (m_pImage)
        m_pImage->Release();

    if (m_pImageFactory)
        m_pImageFactory->Release();
}

STDMETHODIMP CGdiPlusThumb::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                        DWORD * pdwPriority, const SIZE *prgSize,
                                        DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_szPath[0])
    {
        hr = StringCchCopyW(pszPathBuffer, cch, m_szPath);
        if (SUCCEEDED(hr))
        {
        

            if (*pdwFlags & IEIFLAG_ASYNC)
            {
                hr = E_PENDING;

                // higher than normal priority, this task is relatively fast
                *pdwPriority = PRIORITY_EXTRACT_FAST;
            }

            m_rgSize = *prgSize;
            m_dwRecClrDepth = dwRecClrDepth;
            // We only work in non-paletted modes.  Some of our extractors simply always use 24bbp, should we?
            if (m_dwRecClrDepth < 16)
                m_dwRecClrDepth = 16;

            m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);
            m_fHighQuality = BOOLIFY(*pdwFlags & IEIFLAG_QUALITY);

            *pdwFlags = IEIFLAG_CACHE;
        }
    }

    return hr;
}

STDMETHODIMP CGdiPlusThumb::Extract(HBITMAP *phBmpThumbnail)
{
    HRESULT hr = E_FAIL;

    // Do the GDI plus stuff here
    if (m_pImageFactory && m_pImage)
    {
        if (m_fHighQuality)
        {
            hr = m_pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
        }
        if (FAILED(hr))
        {
            hr = m_pImage->Decode(SHIMGDEC_THUMBNAIL, m_rgSize.cx, m_rgSize.cy);
        }

        if (SUCCEEDED(hr))
        {
            // Get the image's actual size, which might be less than the requested size since we asked for a thumbnail
            SIZE sizeImg;
            m_pImage->GetSize(&sizeImg);

            // we need to fill the background with the default color if we can't resize the bitmap
            // or if the image is transparent:
            m_fFillBackground = !m_fOrigSize || (m_pImage->IsTransparent() == S_OK);

            if (m_fOrigSize)
            {
                // if its too big, lets squish it, but try to
                // maintain the same aspect ratio.  This is the same
                // sort of thing we do for the !m_fOrigSize case, except
                // here we want to do it here because we want to return
                // a correctly sized bitmap.
                if (sizeImg.cx != 0 && sizeImg.cy != 0 &&
                    (sizeImg.cx > m_rgSize.cx || sizeImg.cy > m_rgSize.cy))
                {
                    if (m_rgSize.cx * sizeImg.cy > m_rgSize.cy * sizeImg.cx)
                    {
                        m_rgSize.cx = MulDiv(m_rgSize.cy,sizeImg.cx,sizeImg.cy);
                    }
                    else
                    {
                        m_rgSize.cy = MulDiv(m_rgSize.cx,sizeImg.cy,sizeImg.cx);
                    }
                }
                else
                {
                    // Use the size if it was small enough and they wanted original size
                    m_rgSize = sizeImg;
                }
            }

            hr = CreateDibFromBitmapImage( phBmpThumbnail );
        }
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

STDMETHODIMP CGdiPlusThumb::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_GdiThumbnailExtractor;
    return S_OK;
}

STDMETHODIMP CGdiPlusThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CGdiPlusThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT hr;

    hr = StringCchCopyW(m_szPath, ARRAYSIZE(m_szPath), pszFileName );
    if (SUCCEEDED(hr))
    {
        // Call ImageFactory->CreateFromFile here.  If Create from file failes then
        // return E_FAIL, otherwise return S_OK.
        ASSERT(NULL==m_pImageFactory);
        HRESULT hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &m_pImageFactory));
        if (SUCCEEDED(hr))
        {
            hr = m_pImageFactory->CreateImageFromFile(m_szPath, &m_pImage);
            ASSERT((SUCCEEDED(hr) && m_pImage) || (FAILED(hr) && !m_pImage));
        }
    }

    return hr;
}

STDMETHODIMP CGdiPlusThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGdiPlusThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGdiPlusThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

HRESULT CGdiPlusThumb::CreateDibFromBitmapImage(HBITMAP * pbm)
{
    HRESULT hr = E_FAIL;
    BITMAPINFO bmi = {0};
    void * pvBits;

    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = m_rgSize.cx;
    bmi.bmiHeader.biHeight = m_rgSize.cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = (USHORT)m_dwRecClrDepth;
    bmi.bmiHeader.biCompression = BI_RGB;
    DWORD dwBPL = (((bmi.bmiHeader.biWidth * m_dwRecClrDepth) + 31) >> 3) & ~3;
    bmi.bmiHeader.biSizeImage = dwBPL * bmi.bmiHeader.biHeight;

    HDC hdc = GetDC(NULL);
    HBITMAP hbmp = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    if (hbmp)
    {
        HDC hMemDC = CreateCompatibleDC(hdc);
        if (hMemDC)
        {
            HBITMAP hbmOld = (HBITMAP)SelectObject(hMemDC, hbmp);
            RECT rc = {0, 0, m_rgSize.cx, m_rgSize.cy};

            if (m_fFillBackground)
            {
                FillRect(hMemDC, &rc, GetSysColorBrush(COLOR_WINDOW));
            }
        
            // if the m_fOrigSize flag isn't set then we need to return a bitmap that is the
            // requested size.  In order to maintain aspect ratio that means we need to
            // center the thumbnail.

            if (!m_fOrigSize)
            {
                SIZE sizeImg;
                m_pImage->GetSize(&sizeImg);

                // if its too big, lets squish it, but try to
                // maintain the same aspect ratio.  This is the same
                // sort of thing we did for the m_fOrigSize case, except
                // here we want to do it before centering.
                if (sizeImg.cx != 0 && sizeImg.cy != 0 &&
                    (sizeImg.cx > m_rgSize.cx || sizeImg.cy > m_rgSize.cy))
                {
                    if (m_rgSize.cx * sizeImg.cy > m_rgSize.cy * sizeImg.cx)
                    {
                        sizeImg.cx = MulDiv(m_rgSize.cy,sizeImg.cx,sizeImg.cy);
                        sizeImg.cy = m_rgSize.cy;
                    }
                    else
                    {
                        sizeImg.cy = MulDiv(m_rgSize.cx,sizeImg.cy,sizeImg.cx);
                        sizeImg.cx = m_rgSize.cx;
                    }
                }

                rc.left = (m_rgSize.cx-sizeImg.cx)/2;
                rc.top = (m_rgSize.cy-sizeImg.cy)/2;
                rc.right = rc.left + sizeImg.cx;
                rc.bottom = rc.top + sizeImg.cy;
            }

            hr = m_pImage->Draw(hMemDC, &rc, NULL);

            SelectObject(hMemDC, hbmOld);
            DeleteDC(hMemDC);
        }
    }
    ReleaseDC(NULL, hdc);

    if (SUCCEEDED(hr))
    {
        *pbm = hbmp;
    }
    else if (hbmp)
    {
        DeleteObject(hbmp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\imagprop.h ===
#ifndef _IMAGPROP_H_
#define _IMAGPROP_H_

typedef void (*FNPROPCHANGE)(IShellImageData *, SHCOLUMNID*);

//
// CImagePropSet defines an IPropertyStorage
// implementation for image files. The properties are backed by GDI+ interfaces.
// 

class CImagePropSet : public IPropertyStorage
{
public:
    CImagePropSet(Image *pimg, IShellImageData *pData, IPropertyStorage *pps, REFFMTID fmtid, FNPROPCHANGE fnCallback=NULL);
    HRESULT SyncImagePropsToStorage();
    void SaveProps(Image *pImage, CDSA<SHCOLUMNID> *pdsaChanges);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPropertyStorage methods
    STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);
    STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst);
    STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP Enum(IEnumSTATPROPSTG** ppenm);
    STDMETHODIMP Stat(STATPROPSETSTG* pstatpsstg);
    STDMETHODIMP SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime);

private:
    ~CImagePropSet();
    void _PopulatePropStorage();
    HRESULT _PropVarToImgProp(PROPID pid, const PROPVARIANT *pvar, PropertyItem *pprop, BOOL bUnicode);
    HRESULT _PropImgToPropvar(PropertyItem *pi, PROPVARIANT *pvar, BOOL bUnicode);
    HRESULT _MapPropidToImgPropid(PROPID propid, PROPID *ppid, PROPID *pidUnicode);
    HRESULT _MapImgPropidToPropid(PROPID propid, PROPID *ppid, BOOL *pbUnicode);
    HRESULT _GetImageSummaryProps(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);


    LONG _cRef;
    Image *_pimg;
    IShellImageData *_pData; // addref this guy so our Image isn't deleted behind our back
    IPropertyStorage *_ppsImg;
    BOOL _fDirty;
    FMTID _fmtid;
    FNPROPCHANGE _fnPropChanged;
    BOOL _fEditable;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\makefile.inc ===
..\shimgvw.rc : $(PROJECT_ROOT)\lib\$(O)\shimgvw.tlb $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\imgdata.cpp ===
#include "precomp.h"
#include <runtask.h>
#include "imagprop.h"
#include "shutil.h"
#pragma hdrstop

#define TF_SUSPENDRESUME    0      // turn on to debug CDecodeStream::Suspend/Resume
#define PF_NOSUSPEND        0      // disable suspend and resume (for debugging purposes)

class CDecodeStream;

////////////////////////////////////////////////////////////////////////////

class CEncoderInfo
{
public:
    CEncoderInfo();
    virtual ~CEncoderInfo();
protected:
    HRESULT _GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt);
    HRESULT _GetEncoderList();
    HRESULT _GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder);

    UINT _cEncoders;                    // number of encoders discovered
    ImageCodecInfo *_pici;              // array of image encoder classes
};

class CImageFactory : public IShellImageDataFactory, private CEncoderInfo,
                      public NonATLObject
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellImageDataFactory
    STDMETHODIMP CreateIShellImageData(IShellImageData **ppshimg);
    STDMETHODIMP CreateImageFromFile(LPCWSTR pszPath, IShellImageData **ppshimg);
    STDMETHODIMP CreateImageFromStream(IStream *pStream, IShellImageData **ppshimg);
    STDMETHODIMP GetDataFormatFromPath(LPCWSTR pszPath, GUID *pDataFormat);

    CImageFactory();

private:
    ~CImageFactory();

    LONG _cRef;
    CGraphicsInit _cgi;
};

class CImageData : public IShellImageData, IPersistFile, IPersistStream, IPropertySetStorage, private CEncoderInfo,
                   public NonATLObject
{
public:
    CImageData(BOOL fPropertyOnly = FALSE);
    static BOOL CALLBACK QueryAbort(void *pvRef);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_ShellImageDataFactory; return S_OK; }

    // IPersistFile
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IPersistStream
    STDMETHOD(Load)(IStream *pstm);
    STDMETHOD(Save)(IStream *pstm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
        { return E_NOTIMPL; }

    // IPropertySetStorage methods
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IShellImageData
    STDMETHODIMP Decode(DWORD dwFlags, ULONG pcx, ULONG pcy);
    STDMETHODIMP Draw(HDC hdc, LPRECT prcDest, LPRECT prcSrc);

    STDMETHODIMP NextFrame();
    STDMETHODIMP NextPage();
    STDMETHODIMP PrevPage();

    STDMETHODIMP IsTransparent();
    STDMETHODIMP IsVector();

    STDMETHODIMP IsAnimated()
        { return _fAnimated ? S_OK : S_FALSE; }
    STDMETHODIMP IsMultipage()
        { return (!_fAnimated && _cImages > 1) ? S_OK : S_FALSE; }

    STDMETHODIMP IsDecoded();

    STDMETHODIMP IsPrintable()
        { return S_OK; }                            // all images are printable

    STDMETHODIMP IsEditable()
        { return _fEditable ? S_OK : S_FALSE; }

    STDMETHODIMP GetCurrentPage(ULONG *pnPage)
        { *pnPage = _iCurrent; return S_OK; }
    STDMETHODIMP GetPageCount(ULONG *pcPages)
        { HRESULT hr = _EnsureImage(); *pcPages = _cImages; return hr; }
    STDMETHODIMP SelectPage(ULONG iPage);
    STDMETHODIMP GetResolution(ULONG *puResolutionX, ULONG *puResolutionY);

    STDMETHODIMP GetRawDataFormat(GUID *pfmt);
    STDMETHODIMP GetPixelFormat(PixelFormat *pfmt);
    STDMETHODIMP GetSize(SIZE *pSize);
    STDMETHODIMP GetDelay(DWORD *pdwDelay);
    STDMETHODIMP DisplayName(LPWSTR wszName, UINT cch);
    STDMETHODIMP GetProperties(DWORD dwMode, IPropertySetStorage **ppPropSet);
    STDMETHODIMP Rotate(DWORD dwAngle);
    STDMETHODIMP Scale(ULONG cx, ULONG cy, InterpolationMode hints);
    STDMETHODIMP DiscardEdit();
    STDMETHODIMP SetEncoderParams(IPropertyBag *ppbEnc);
    STDMETHODIMP GetEncoderParams(GUID *pguidFmt, EncoderParameters **ppencParams);
    STDMETHODIMP RegisterAbort(IShellImageDataAbort *pAbort, IShellImageDataAbort **ppAbortPrev);
    STDMETHODIMP CloneFrame(Image **ppimg);
    STDMETHODIMP ReplaceFrame(Image *pimg);

private:
    CGraphicsInit _cgi;
    LONG _cRef;

    DWORD _dwMode;                      // open mode from IPersistFile::Load()
    CDecodeStream *_pstrm;              // stream that will produce our data

    BOOL _fLoaded;                      // true once PersistFile or PersistStream have been called
    BOOL _fDecoded;                     // true once Decode ahs been called

    DWORD _dwFlags;                     // flags and size passed to Decode method
    int _cxDesired;
    int _cyDesired;

    Image *_pImage;                     // source of the images (created from the filename)

    // REVIEW: do we need to make these be per-frame/page?
    // YES!
    Image *_pimgEdited;                 // edited image

    HDPA  _hdpaProps;                   // properties for each frame
    DWORD _dwRotation;
    BOOL _fDestructive;                 // not a lossless edit operation

    BOOL _fAnimated;                    // this is an animated stream (eg. not multi page picture)
    BOOL _fLoopForever;                 // loop the animated gif forever
    int  _cLoop;                        // loop count (0 forever, n = repeat count)

    BOOL _fEditable;                    // can be edited
    GUID _guidFmt;                      // format GUID (original stream is this)

    DWORD _cImages;                     // number of frames/pages in the image
    DWORD _iCurrent;                    // current frame/page we want to display
    PropertyItem *_piAnimDelay;         // array of the delay assocated with each frame
    BOOL _fPropertyOnly;
    BOOL _fPropertyChanged;
    // image encoder information (created on demand)
    IPropertyBag *_ppbEncoderParams;    // property bag with encoder parameters

    IShellImageDataAbort *_pAbort;      // optional abort callback
    CDSA<SHCOLUMNID> _dsaChangedProps; // which properties have changed
    

private:
    ~CImageData();
    HRESULT _EnsureImage();
    HRESULT _SuspendStream();
    HRESULT _SetDecodeStream(CDecodeStream *pds);

    HRESULT _CreateMemPropSetStorage(IPropertySetStorage **ppss);

    HRESULT _PropImgToVariant(PropertyItem *pi, VARIANT *pvar);
    HRESULT _GetProperty(PROPID id, VARIANT *pvar, VARTYPE vt);
    HRESULT _GetDisplayedImage();
    void _SetEditImage(Image *pimgEdit);
    HRESULT _SaveImages(IStream *pstrm, GUID * pguidFmt);
    HRESULT _ReplaceFile(LPCTSTR pszNewFile);
    HRESULT _MakeTempFile(LPWSTR pszFile);
    void _AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv);

    HRESULT _EnsureProperties(IPropertySetStorage **ppss);
    HRESULT _CreatePropStorage(IPropertyStorage **ppps, REFFMTID fmtid);
    static int _FreeProps(void *pProp, void *pData);
    //
    // since CImagePropSet objects come and go, we need to persist which properties need updating in the CImageData
    //
    void    _SaveFrameProperties(Image *pimg, LONG iFrame);
    static void _PropertyChanged(IShellImageData *pThis, SHCOLUMNID *pscid );
};

////////////////////////////////////////////////////////////////////////////
//
// CDecodeStream
//
//  Wraps a regular IStream, but is cancellable and can be
//  suspended/resumed to prevent the underlying file from being held
//  open unnecessarily.
//
////////////////////////////////////////////////////////////////////////////

class CDecodeStream : public IStream, public NonATLObject
{
public:
    CDecodeStream(CImageData *pid, IStream *pstrm);
    CDecodeStream(CImageData *pid, LPCTSTR pszFilename, DWORD dwMode);

    ~CDecodeStream()
    {
        ASSERT(!_pidOwner);
#ifdef DEBUG // Need #ifdef because we call a function
        if (IsFileStream())
        {
            TraceMsg(TF_SUSPENDRESUME, "ds.Release %s", PathFindFileName(_szFilename));
        }
#endif
        ATOMICRELEASE(_pstrmInner);
    }

    HRESULT Suspend();
    HRESULT Resume(BOOL fFullLoad = FALSE);
    void    Reload();
    //
    //  Before releasing, you must Detach to break the backreference.
    //  Otherwise, the next time somebody calls QueryCancel, we will fault.
    //
    void Detach()
    {
        _pidOwner = NULL;
    }

    BOOL IsFileStream() { return _szFilename[0]; }
    LPCTSTR GetFilename() { return _szFilename; }
    HRESULT DisplayName(LPWSTR wszName, UINT cch);

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IStream ***
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

private:
    void CommonConstruct(CImageData *pid) { _cRef = 1; _pidOwner = pid; _fSuspendable = !(g_dwPrototype & PF_NOSUSPEND);}
    HRESULT FilterAccess();

private:
    IStream *   _pstrmInner;
    CImageData *_pidOwner;      // NOT REFCOUNTED
    LONG        _cRef;
    LARGE_INTEGER _liPos;       // Where we were in the file when we suspended
    TCHAR _szFilename[MAX_PATH];    // file we are a stream for
    BOOL _fSuspendable;
};

CDecodeStream::CDecodeStream(CImageData *pid, IStream *pstrm)
{
    CommonConstruct(pid);
    IUnknown_Set((IUnknown**)&_pstrmInner, pstrm);
}

CDecodeStream::CDecodeStream(CImageData *pid, LPCTSTR pszFilename, DWORD dwMode)
{
    CommonConstruct(pid);
    lstrcpyn(_szFilename, pszFilename, ARRAYSIZE(_szFilename));
    // ignore the mode
}

//reload is only used for file streams
void CDecodeStream::Reload()
{
    if (IsFileStream())
    {
        ATOMICRELEASE(_pstrmInner);
        if (_fSuspendable) 
        {
            ZeroMemory(&_liPos, sizeof(_liPos));
        }
    }
}

HRESULT CDecodeStream::Suspend()
{
    HRESULT hr;

    if (IsFileStream() && _pstrmInner && _fSuspendable)
    {
        // Remember the file position so we can restore it when we resume
        const LARGE_INTEGER liZero = { 0, 0 };
        hr = _pstrmInner->Seek(liZero, FILE_CURRENT, (ULARGE_INTEGER*)&_liPos);
        if (SUCCEEDED(hr))
        {
#ifdef DEBUG // Need #ifdef because we call a function
            TraceMsg(TF_SUSPENDRESUME, "ds.Suspend %s, pos=0x%08x",
                     PathFindFileName(_szFilename), _liPos.LowPart);
#endif
            ATOMICRELEASE(_pstrmInner);
            hr = S_OK;
        }
    }
    else 
    {
        hr = S_FALSE;           // Not suspendable or already suspended
    }
    return hr;
}

HRESULT CDecodeStream::Resume(BOOL fLoadFull)
{
    HRESULT hr;

    if (_pstrmInner)
    {
        return S_OK;
    }
    if (fLoadFull)
    {
        _fSuspendable = FALSE;
    }
    if (IsFileStream())
    {
        if (PathIsURL(_szFilename))
        {
            // TODO: use URLMon to load the image, make sure we check for being allowed to go on-line
            hr = E_NOTIMPL;
        }
        else
        {
            if (!fLoadFull)
            {
                hr = SHCreateStreamOnFileEx(_szFilename, STGM_READ | STGM_SHARE_DENY_NONE, 0, FALSE, NULL, &_pstrmInner);
                if (SUCCEEDED(hr))
                {
                    hr = _pstrmInner->Seek(_liPos, FILE_BEGIN, NULL);
                    if (SUCCEEDED(hr))
                    {
                        #ifdef DEBUG // Need #ifdef because we call a function
                        TraceMsg(TF_SUSPENDRESUME, "ds.Resumed %s, pos=0x%08x",
                                 PathFindFileName(_szFilename), _liPos.LowPart);
                        #endif
                    }
                    else
                    {
                        ATOMICRELEASE(_pstrmInner);
                    }
                }
            }
            else 
            {
                hr = S_OK;
                HANDLE hFile = CreateFile(_szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    LARGE_INTEGER liSize = {0};
                    // we can't handle huge files
                    if (GetFileSizeEx(hFile, &liSize) && !liSize.HighPart)
                    {
                        DWORD dwToRead = liSize.LowPart;
                        HGLOBAL hGlobal = GlobalAlloc(GHND, dwToRead);
                        if (hGlobal)
                        {
                            void *pv = GlobalLock(hGlobal);
                            DWORD dwRead;
                            if (pv)
                            {
                                if (ReadFile(hFile, pv, dwToRead, &dwRead, NULL))                           
                                {
                                    ASSERT(dwRead == dwToRead);
                                    GlobalUnlock(hGlobal);
                                    hr = CreateStreamOnHGlobal(hGlobal, TRUE, &_pstrmInner);                    
                                }
                                else
                                {
                                    GlobalUnlock(hGlobal);
                                }
                            }
                            if (!_pstrmInner)
                            {
                                GlobalFree(hGlobal);
                            }
                        }
                    }
                    CloseHandle(hFile);
                }
            }
            if (SUCCEEDED(hr) && !_pstrmInner)
            {
                DWORD dw = GetLastError();
                hr = HRESULT_FROM_WIN32(dw);
            }
        }
        if (FAILED(hr))
        {
#ifdef DEBUG // Need #ifdef because we call a function
            TraceMsg(TF_SUSPENDRESUME, "ds.Resume %s failed: %08x",
                     PathFindFileName(_szFilename), hr);
#endif
        }
    }
    else
    {
        hr = E_FAIL;            // Can't resume without a filename
    }

    return hr;
}

//
//  This function is called at the top of each IStream method to make
//  sure that the stream has not been cancelled and resumes it if
//  necessary.
//
HRESULT CDecodeStream::FilterAccess()
{
    if (_pidOwner && _pidOwner->QueryAbort(_pidOwner))
    {
        return E_ABORT;
    }

    return Resume();
}

HRESULT CDecodeStream::DisplayName(LPWSTR wszName, UINT cch)
{
    HRESULT hr = E_FAIL;

    if (IsFileStream())
    {
        // from the filename generate the leaf name which we can
        // return the name to caller.

        LPTSTR pszFilename = PathFindFileName(_szFilename);
        if (pszFilename)
        {
            SHTCharToUnicode(pszFilename, wszName, cch);
            hr = S_OK;
        }
    }
    else if (_pstrmInner)
    {
        // this is a stream, so lets get the display name from the that stream
        // and return that into the buffer that the caller has given us.

        STATSTG stat;
        hr = _pstrmInner->Stat(&stat, 0x0);
        if (SUCCEEDED(hr))
        {
            if (stat.pwcsName)
            {
                StrCpyN(wszName, stat.pwcsName, cch);
                CoTaskMemFree(stat.pwcsName);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//
//  Now the boring part...
//

// *** IUnknown ***
HRESULT CDecodeStream::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CDecodeStream, IStream),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDecodeStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDecodeStream::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// *** IStream ***

#define WRAP_METHOD(fn, args, argl) \
HRESULT CDecodeStream::fn args      \
{                                   \
    HRESULT hr = FilterAccess();    \
    if (SUCCEEDED(hr))              \
    {                               \
        hr = _pstrmInner->fn argl;  \
    }                               \
    return hr;                      \
}

WRAP_METHOD(Read, (void *pv, ULONG cb, ULONG *pcbRead), (pv, cb, pcbRead))
WRAP_METHOD(Write, (void const *pv, ULONG cb, ULONG *pcbWritten), (pv, cb, pcbWritten))
WRAP_METHOD(Seek, (LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition),
                  (dlibMove, dwOrigin, plibNewPosition))
WRAP_METHOD(SetSize, (ULARGE_INTEGER libNewSize), (libNewSize))
WRAP_METHOD(CopyTo, (IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten),
                    (pstm, cb, pcbRead, pcbWritten))
WRAP_METHOD(Commit, (DWORD grfCommitFlags), (grfCommitFlags))
WRAP_METHOD(Revert, (), ())
WRAP_METHOD(LockRegion, (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType), (libOffset, cb, dwLockType))
WRAP_METHOD(UnlockRegion, (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType), (libOffset, cb, dwLockType))
WRAP_METHOD(Stat, (STATSTG *pstatstg, DWORD grfStatFlag), (pstatstg, grfStatFlag))
WRAP_METHOD(Clone, (IStream **ppstm), (ppstm))

#undef WRAP_METHOD


////////////////////////////////////////////////////////////////////////////

class CFmtEnum : public IEnumSTATPROPSETSTG, public NonATLObject
{
public:
    STDMETHODIMP Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumSTATPROPSETSTG **ppenum);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    CFmtEnum(IEnumSTATPROPSETSTG *pEnum);

private:
    ~CFmtEnum();
    IEnumSTATPROPSETSTG *_pEnum;
    ULONG _idx;
    LONG _cRef;
};

#define HR_FROM_STATUS(x) ((x) == Ok) ? S_OK : E_FAIL

// IUnknown

STDMETHODIMP CImageData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImageData, IShellImageData),
        QITABENT(CImageData, IPersistFile),
        QITABENT(CImageData, IPersistStream),
        QITABENT(CImageData, IPropertySetStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageData::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImageData::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CImageData::CImageData(BOOL fPropertyOnly) : _cRef(1), _cImages(1), _fPropertyOnly(fPropertyOnly), _fPropertyChanged(FALSE)
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_dwMode           == 0);
    ASSERT(_pstrm            == NULL);
    ASSERT(_fLoaded          == FALSE);
    ASSERT(_fDecoded         == FALSE);
    ASSERT(_dwFlags          == 0);
    ASSERT(_cxDesired        == 0);
    ASSERT(_cyDesired        == 0);
    ASSERT(_pImage           == NULL);
    ASSERT(_pimgEdited       == NULL);
    ASSERT(_hdpaProps        == NULL);
    ASSERT(_dwRotation       == 0);
    ASSERT(_fDestructive     == FALSE);
    ASSERT(_fAnimated        == FALSE);
    ASSERT(_fLoopForever     == FALSE);
    ASSERT(_cLoop            == 0);
    ASSERT(_fEditable        == FALSE);
    ASSERT(_iCurrent         == 0);
    ASSERT(_piAnimDelay      == NULL);
    ASSERT(_ppbEncoderParams == NULL);
    ASSERT(_pAbort           == NULL);
}

CImageData::~CImageData()
{
    if (_fPropertyOnly && _fPropertyChanged)
    {
        Save((LPCTSTR)NULL, FALSE);
    }

    if (_pstrm)
    {
        _pstrm->Detach();
        _pstrm->Release();
    }

    if (_pImage)
    {
        delete _pImage;                      // discard the pImage object we have been using
        _pImage = NULL;
    }

    if (_pimgEdited)
    {
        delete _pimgEdited;
        _pimgEdited = NULL;
    }

    if (_piAnimDelay)
        LocalFree(_piAnimDelay);        // do we have an array of image frame delays to destroy

    if (_hdpaProps)
        DPA_DestroyCallback(_hdpaProps, _FreeProps, NULL);

    if (_fLoaded)
    {
        _dsaChangedProps.Destroy();
    }
    ATOMICRELEASE(_pAbort);
}

// IPersistStream

HRESULT CImageData::_SetDecodeStream(CDecodeStream *pds)
{
    ASSERT(_pstrm == NULL);
    _pstrm = pds;

    if (_pstrm)
    {        
        _fLoaded = TRUE;
        _dsaChangedProps.Create(10);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

HRESULT CImageData::Load(IStream *pstrm)
{
    if (_fLoaded)
        return STG_E_INUSE;

    return _SetDecodeStream(new CDecodeStream(this, pstrm));
}

HRESULT CImageData::Save(IStream *pstrm, BOOL fClearDirty)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        hr = _SaveImages(pstrm, &_guidFmt);
        if (SUCCEEDED(hr))
        {
            _fPropertyChanged = FALSE;
            DiscardEdit();
        }
    }
    return hr;
}


// IPersistFile methods

HRESULT CImageData::IsDirty()
{
    return (_dwRotation || _pimgEdited) ? S_OK : S_FALSE;
}

HRESULT CImageData::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (_fLoaded)
        return STG_E_INUSE;

    if (!*pszFileName)
        return E_INVALIDARG;

    return _SetDecodeStream(new CDecodeStream(this, pszFileName, dwMode));
}


#define ATTRIBUTES_TEMPFILE (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_TEMPORARY)
// IPersistFile::Save() see SDK docs

HRESULT CImageData::Save(LPCOLESTR pszFile, BOOL fRemember)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // If this fires, then somebody managed to get _EnsureImage to
        // succeed without ever actually loading anything... (?)
        ASSERT(_pstrm);
        
        if (pszFile == NULL && !_pstrm->IsFileStream())
        {
            // Trying to "save with same name you loaded from"
            // when we weren't loaded from a file to begin with
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }
        else
        {
            // we default to saving in the original format that we were given
            // if the name is NULL (we will also attempt to replace the original file).
            TCHAR szTempFile[MAX_PATH];
            GUID guidFmt = _guidFmt;    // default to original format
            
            BOOL fReplaceOriginal = _pstrm->IsFileStream() &&
                ((NULL == pszFile) || (S_OK == IsSameFile(pszFile, _pstrm->GetFilename())));
            
            if (fReplaceOriginal)
            {
                // we are being told to save to the current file, but we have the current file locked open.
                // To get around this we save to a temporary file, close our handles on the current file,
                // and then replace the current file with the new file
                hr = _MakeTempFile(szTempFile);
                pszFile = szTempFile;                
            }
            else if (!_ppbEncoderParams)
            {
                // the caller did not tell us which encoder to use?
                // determine the encoder based on the target file name
                
                hr = _GetDataFormatFromPath(pszFile, &guidFmt);
            }
            
            if (SUCCEEDED(hr))
            {
                // the attributes are important as they need to match those of the
                // temp file we created else this call fails
                IStream *pstrm;
                hr = SHCreateStreamOnFileEx(pszFile, STGM_WRITE | STGM_CREATE, 
                    fReplaceOriginal ? ATTRIBUTES_TEMPFILE : 0, TRUE, NULL, &pstrm);
                if (SUCCEEDED(hr))
                {
                    hr = _SaveImages(pstrm, &guidFmt);
                    pstrm->Release();
                    
                    if (SUCCEEDED(hr) && fReplaceOriginal)
                    {
                        hr = _ReplaceFile(szTempFile);
                        if (SUCCEEDED(hr))
                        {
                            _fPropertyChanged = FALSE;
                            DiscardEdit(); // note we can't discard any edits until the original was overwritten                            
                            delete _pImage;
                            _pImage = NULL;
                            _fDecoded = FALSE;
                            _pstrm->Reload();
                            DWORD iCurrentPage = _iCurrent;
                            hr = Decode(_dwFlags, _cxDesired, _cyDesired);
                            if (iCurrentPage < _cImages)
                                _iCurrent = iCurrentPage;                           
                        }
                    }
                }

                if (FAILED(hr) && fReplaceOriginal)
                {
                    // make sure temp file is gone
                    DeleteFile(szTempFile);
                }
            }
        }
    }
    return hr;
}


HRESULT CImageData::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

HRESULT CImageData::GetCurFile(LPOLESTR *ppszFileName)
{
    if (_pstrm && _pstrm->IsFileStream())
        return SHStrDup(_pstrm->GetFilename(), ppszFileName);

    return E_FAIL;
}


// handle decoding the image this includes updating our cache of the images

HRESULT CImageData::_EnsureImage()
{
    if (_fDecoded && _pImage)
        return S_OK;
    return E_FAIL;
}

HRESULT CImageData::_SuspendStream()
{
    HRESULT hr = S_OK;
    if (_pstrm)
    {
        hr = _pstrm->Suspend();
    }
    return hr;
}

HRESULT CImageData::_GetDisplayedImage()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;

        hr = HR_FROM_STATUS(_pImage->SelectActiveFrame(pclsidFrameDim, _iCurrent));
    }
    return hr;
}


// IShellImageData method

HRESULT CImageData::Decode(DWORD dwFlags, ULONG cx, ULONG cy)
{
    if (!_fLoaded)
        return E_FAIL;

    if (_fDecoded)
        return S_FALSE;

    HRESULT hr = S_OK;

    _dwFlags = dwFlags;
    _cxDesired = cx;
    _cyDesired = cy;

    //
    //  Resume the stream now so GDI+ won't go nuts trying to detect the
    //  image type of a file that it can't read...
    //
    hr = _pstrm->Resume(dwFlags & SHIMGDEC_LOADFULL);

    // if that succeeded then we can create an image using the stream and decode
    // the images from that.  once we are done we will release the objects.

    if (SUCCEEDED(hr))
    {
        _pImage = new Image(_pstrm, TRUE);
        if (_pImage)
        {
            if (Ok != _pImage->GetLastStatus())
            {
                delete _pImage;
                _pImage = NULL;
                hr = E_FAIL;
            }
            else
            {
                _fEditable = TRUE;
                if (_dwFlags & SHIMGDEC_THUMBNAIL)
                {
                    // for thumbnails, _cxDesired and _cyDesired define a bounding rectangle but we
                    // should maintain the original aspect ratio.
                    int cxT = _pImage->GetWidth();
                    int cyT = _pImage->GetHeight();

                    if (cxT > _cxDesired || cyT > _cyDesired)
                    {
                        if (Int32x32To64(_cxDesired, cyT) > Int32x32To64(cxT, _cyDesired))
                        {
                            // constrained by height
                            cxT = MulDiv(cxT, _cyDesired, cyT);
                            if (cxT < 1) cxT = 1;
                            cyT = _cyDesired;
                        }
                        else
                        {
                            // constrained by width
                            cyT = MulDiv(cyT, _cxDesired, cxT);
                            if (cyT < 1) cyT = 1;
                            cxT = _cxDesired;
                        }
                    }

                    Image * pThumbnail;
                    pThumbnail = _pImage->GetThumbnailImage(cxT, cyT, QueryAbort, this);

                    //
                    //  GDI+ sometimes forgets to tell us it gave up due to an abort.
                    //
                    if (pThumbnail && !QueryAbort(this))
                    {
                        delete _pImage;
                        _pImage = pThumbnail;
                    }
                    else
                    {
                        delete pThumbnail; // "delete" ignores NULL pointers
                        hr = E_FAIL;
                    }
                }
                else
                {
                    _pImage->GetRawFormat(&_guidFmt);                // read the raw format of the file
                    if (_guidFmt == ImageFormatTIFF)
                    {
                        VARIANT var;
                        if (SUCCEEDED(_GetProperty(PropertyTagExifIFD, &var, VT_UI4)))
                        {
                            // TIFF images with an EXIF IFD aren't editable by GDI+
                            _fEditable = FALSE;
                            VariantClear(&var);
                        }
                    }

                    // is this an animated/multi page image?
                    _cImages = _pImage->GetFrameCount(&FrameDimensionPage);
                    if (_cImages <= 1)
                    {
                        _cImages = _pImage->GetFrameCount(&FrameDimensionTime);
                        if (_cImages > 1)
                        {
                            _fAnimated = TRUE;

                            // store the frame delays in PropertyItem *_piAnimDelay;
                            UINT cb = _pImage->GetPropertyItemSize(PropertyTagFrameDelay);
                            if (cb)
                            {
                                _piAnimDelay = (PropertyItem*)LocalAlloc(LPTR, cb);
                                if (_piAnimDelay)
                                {
                                    if (Ok != _pImage->GetPropertyItem(PropertyTagFrameDelay, cb, _piAnimDelay))
                                    {
                                        LocalFree(_piAnimDelay);
                                        _piAnimDelay = NULL;
                                    }
                                }
                            }
                        }
                    }

                    _pImage->GetLastStatus(); // 145081: clear the error from the first call to _pImage->GetFrameCount so that
                                              // the later call to _GetProperty won't immediately fail.
                                              // we wouldn't have to do this always if the gdi interface didn't maintain its own
                                              // error code and fail automatically based on it without allowing us to check it
                                              // without resetting it.

                    // some decoders will return zero as the frame count when they don't support that dimension
                    if (0 == _cImages)
                        _cImages = 1;

                    // is it a looping image?   this will only be if its animated
                    if (_fAnimated)
                    {
                        VARIANT var;
                        if (SUCCEEDED(_GetProperty(PropertyTagLoopCount, &var, VT_UI4)))
                        {
                            _cLoop = var.ulVal;
                            _fLoopForever = (_cLoop == 0);
                            VariantClear(&var);
                        }
                    }

                    PixelFormat pf = _pImage->GetPixelFormat();
                    // can we edit this image?  NOTE: The caller needs to ensure that the file is writeable
                    // all of that jazz, we only check if we have an encoder for this format.  Just cause we
                    // can edit a file doesn't mean the file can be written to the original source location.
                    // We can't edit images with > 8 bits per channel either
                    if (_fEditable)
                    {
                        _fEditable = !_fAnimated  && SUCCEEDED(_GetEncoderFromFormat(&_guidFmt, NULL)) && !IsExtendedPixelFormat(pf);
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;             // failed to allocate the image decoder
        }
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    _fDecoded = TRUE;

    return hr;
}


HRESULT CImageData::Draw(HDC hdc, LPRECT prcDest, LPRECT prcSrc)
{
    if (!prcDest)
        return E_INVALIDARG;            // not much chance without a destination to paint into

    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        Image *pimg = _pimgEdited ? _pimgEdited : _pImage;

        RECT rcSrc;
        if (prcSrc)
        {
            rcSrc.left  = prcSrc->left;
            rcSrc.top   = prcSrc->top;
            rcSrc.right = RECTWIDTH(*prcSrc);
            rcSrc.bottom= RECTHEIGHT(*prcSrc);
        }
        else
        {
            rcSrc.left  = 0;
            rcSrc.top   = 0;
            rcSrc.right = pimg->GetWidth();
            rcSrc.bottom= pimg->GetHeight();
        }

        Unit unit;
        RectF rectf;
        if (Ok==pimg->GetBounds(&rectf, &unit) && UnitPixel==unit)
        {
            rcSrc.left += (int)rectf.X;
            rcSrc.top  += (int)rectf.Y;
        }

        // we have a source rectangle so lets apply that when we render this image.
        Rect rc(prcDest->left, prcDest->top, RECTWIDTH(*prcDest), RECTHEIGHT(*prcDest));

        DWORD dwLayout = SetLayout(hdc, LAYOUT_BITMAPORIENTATIONPRESERVED);
        Graphics g(hdc);
        g.SetPageUnit(UnitPixel); // WARNING: If you remove this line (as has happened twice since Beta 1) you will break printing.
        if (_guidFmt == ImageFormatTIFF)
        {
            g.SetInterpolationMode(InterpolationModeHighQualityBilinear);
        }
        
        hr = HR_FROM_STATUS(g.DrawImage(pimg,
                                        rc,
                                        rcSrc.left,  rcSrc.top,
                                        rcSrc.right, rcSrc.bottom,
                                        UnitPixel, NULL, QueryAbort, this));
        //
        //  GDI+ sometimes forgets to tell us it gave up due to an abort.
        //
        if (SUCCEEDED(hr) && QueryAbort(this))
            hr = E_ABORT;

        if (GDI_ERROR != dwLayout)
            SetLayout(hdc, dwLayout);
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


HRESULT CImageData::SelectPage(ULONG iPage)
{
    if (iPage >= _cImages)
        return OLE_E_ENUM_NOMORE;

    if (_iCurrent != iPage)
    {
        // Since we are moving to a different page throw away any edits
        DiscardEdit();
    }

    _iCurrent = iPage;
    return _GetDisplayedImage();
}

HRESULT CImageData::NextFrame()
{
    if (!_fAnimated)
        return S_FALSE;             // not animated, so no next frame

    // if this is the last image, then lets look at the loop
    // counter and try and decide if we should cycle this image
    // around or not.

    if ((_iCurrent == _cImages-1) && !_fLoopForever)
    {
        if (_cLoop)
            _cLoop --;

        // if cLoop is zero then we're done looping
        if (_cLoop == 0)
            return S_FALSE;
    }

    // advance to the next image in the sequence

    _iCurrent = (_iCurrent+1) % _cImages;
    return _GetDisplayedImage();
}


HRESULT CImageData::NextPage()
{
    if (_iCurrent >= _cImages-1)
        return OLE_E_ENUM_NOMORE;

    // Since we are moving to the next page throw away any edits
    DiscardEdit();

    _iCurrent++;
    return _GetDisplayedImage();
}


HRESULT CImageData::PrevPage()
{
    if (_iCurrent == 0)
        return OLE_E_ENUM_NOMORE;

    // Since we are moving to the next page throw away any edits
    DiscardEdit();
    
    _iCurrent--;
    return _GetDisplayedImage();
}


STDMETHODIMP CImageData::IsTransparent()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
        hr = (_pImage->GetFlags() & ImageFlagsHasAlpha) ? S_OK : S_FALSE;
    return hr;
}


HRESULT CImageData::IsVector()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        hr = (_pImage->GetFlags() & ImageFlagsScalable) ? S_OK : S_FALSE;
    }
    return hr;
}


HRESULT CImageData::GetSize(SIZE *pSize)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        Image *pimg = _pimgEdited ? _pimgEdited : _pImage;
        pSize->cx = pimg->GetWidth();
        pSize->cy = pimg->GetHeight();
    }
    return hr;
}


HRESULT CImageData::GetRawDataFormat(GUID *pfmt)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        *pfmt = _guidFmt;
    }
    return hr;
}


HRESULT CImageData::GetPixelFormat(PixelFormat *pfmt)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        *pfmt = _pImage->GetPixelFormat();
    }
    return hr;
}


HRESULT CImageData::GetDelay(DWORD *pdwDelay)
{
    HRESULT hr = _EnsureImage();
    DWORD dwFrame = _iCurrent;
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (_piAnimDelay)
        {
            if (_piAnimDelay->length != (sizeof(DWORD) * _cImages))
            {
                dwFrame = 0; // if array is not the expected size, be safe and just grab the delay of the first image
            }

            CopyMemory(pdwDelay, (void *)((UINT_PTR)_piAnimDelay->value + dwFrame * sizeof(DWORD)), sizeof(DWORD));
            *pdwDelay = *pdwDelay * 10;

            if (*pdwDelay < 100)
            {
                *pdwDelay = 100; // hack: do the same thing as mshtml, see inetcore\mshtml\src\site\download\imggif.cxx!CImgTaskGif::ReadGIFMaster
            }

            hr = S_OK;
        }
    }
    return hr;
}


HRESULT CImageData::IsDecoded()
{
    return _pImage ? S_OK : S_FALSE;
}

HRESULT CImageData::DisplayName(LPWSTR wszName, UINT cch)
{
    HRESULT hr = E_FAIL;

    // always set the out parameter to something known
    *wszName = L'\0';


    if (_pstrm)
    {
        hr = _pstrm->DisplayName(wszName, cch);
    }

    // REVIEW: If the user has selected not to view file extentions for known types should we hide the extention?

    return hr;
}

// property handling code - decoding, conversion and other packing

HRESULT CImageData::_PropImgToVariant(PropertyItem *pi, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    switch (pi->type)
    {
    case PropertyTagTypeByte:
        pvar->vt = VT_UI1;
        // check for multi-valued property and convert to safearray if found
        if (pi->length > sizeof(UCHAR))
        {
            SAFEARRAYBOUND bound;
            bound.cElements = pi->length/sizeof(UCHAR);
            bound.lLbound = 0;
            pvar->vt |= VT_ARRAY;
            hr = E_OUTOFMEMORY;
            pvar->parray = SafeArrayCreate(VT_UI1, 1, &bound);
            if (pvar->parray)
            {
                void *pv;
                hr = SafeArrayAccessData (pvar->parray, &pv);
                if (SUCCEEDED(hr))
                {
                    CopyMemory(pv, pi->value, pi->length);
                    SafeArrayUnaccessData(pvar->parray);
                }
            }
        }
        else
        {
            pvar->bVal = *((UCHAR*)pi->value);
        }

        break;

    case PropertyTagTypeShort:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pi->value);
        break;

    case PropertyTagTypeLong:
        pvar->vt = VT_UI4;
        pvar->ulVal = *((ULONG*)pi->value);
        break;

    case PropertyTagTypeASCII:
        {
            WCHAR szValue[MAX_PATH];
            SHAnsiToUnicode(((LPSTR)pi->value), szValue, ARRAYSIZE(szValue));
            hr = InitVariantFromStr(pvar, szValue);
        }
        break;

    case PropertyTagTypeRational:
        {
            LONG *pl = (LONG*)pi->value;
            LONG num = pl[0];
            LONG den = pl[1];

            pvar->vt = VT_R8;
            if (0 == den)
                pvar->dblVal = 0;           // don't divide by zero
            else
                pvar->dblVal = ((double)num)/((double)den);
        }
        break;

    case PropertyTagTypeUndefined:
    case PropertyTagTypeSLONG:
    case PropertyTagTypeSRational:
    default:
        hr = E_UNEXPECTED;
        break;
    }
    return hr;
}

HRESULT CImageData::_GetProperty(PROPID id, VARIANT *pvar, VARTYPE vt)
{
    UINT cb = _pImage->GetPropertyItemSize(id);
    HRESULT hr = HR_FROM_STATUS(_pImage->GetLastStatus());
    if (cb && SUCCEEDED(hr))
    {
        PropertyItem *pi = (PropertyItem*)LocalAlloc(LPTR, cb);
        if (pi)
        {
            hr = HR_FROM_STATUS(_pImage->GetPropertyItem(id, cb, pi));
            if (SUCCEEDED(hr))
            {
                hr = _PropImgToVariant(pi, pvar);
            }
            LocalFree(pi);
        }
    }

    if (SUCCEEDED(hr) && (vt != 0) && (pvar->vt != vt))
        hr = VariantChangeType(pvar, pvar, 0, vt);

    return hr;
}

HRESULT CImageData::GetProperties(DWORD dwMode, IPropertySetStorage **ppss)
{
    HRESULT hr = _EnsureProperties(NULL);
    if (SUCCEEDED(hr))
    {
        hr = QueryInterface(IID_PPV_ARG(IPropertySetStorage, ppss));
    }
    return hr;
}

HRESULT CImageData::_CreateMemPropSetStorage(IPropertySetStorage **ppss)
{
    *ppss = NULL;

    ILockBytes *plb;
    HRESULT hr = CreateILockBytesOnHGlobal(NULL, TRUE, &plb);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = StgCreateDocfileOnILockBytes(plb,
            STGM_DIRECT|STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE, 0, &pstg);
        if (SUCCEEDED(hr))
        {
            hr = pstg->QueryInterface(IID_PPV_ARG(IPropertySetStorage, ppss));
            pstg->Release();
        }

        plb->Release();
    }
    return hr;
}

// _EnsureProperties returns an in-memory IPropertySetStorage for the current active frame
// For read-only files we may not be able to modify the property set, so handle access issues
// gracefully.
HRESULT CImageData::_EnsureProperties(IPropertySetStorage **ppss)
{
    if (ppss)
    {
        *ppss = NULL;
    }
    Decode(SHIMGDEC_DEFAULT, 0, 0);
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr) && !_hdpaProps)
    {
        _hdpaProps = DPA_Create(_cImages);
        if (!_hdpaProps)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        IPropertySetStorage *pss = (IPropertySetStorage*)DPA_GetPtr(_hdpaProps, _iCurrent);
        if (!pss)
        {
            hr = _CreateMemPropSetStorage(&pss);
            if (SUCCEEDED(hr))
            {
                // fill in the NTFS or memory-based FMTID_ImageProperties if it doesn't already exist
                IPropertyStorage *pps;
                // we use CImagePropset to fill in the propertystorage when it is first created
                if (SUCCEEDED(pss->Create(FMTID_ImageProperties, &CLSID_NULL, PROPSETFLAG_DEFAULT, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pps)))
                {
                    CImagePropSet *ppsImg = new CImagePropSet(_pImage, NULL, pps, FMTID_ImageProperties);
                    if (ppsImg)
                    {
                        ppsImg->SyncImagePropsToStorage();
                        ppsImg->Release();
                    }
                    pps->Release();
                }
                if (_guidFmt == ImageFormatJPEG || _guidFmt == ImageFormatTIFF)
                {
                    // for now ignore failures here it's not a catastrophic problem if they aren't written
                    if (SUCCEEDED(pss->Create(FMTID_SummaryInformation, &CLSID_NULL, PROPSETFLAG_DEFAULT, STGM_FAILIFTHERE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pps)))
                    {
                        CImagePropSet *ppsSummary = new CImagePropSet(_pImage, NULL, pps, FMTID_SummaryInformation);
                        if (ppsSummary)
                        {
                            ppsSummary->SyncImagePropsToStorage();
                            ppsSummary->Release();
                        }
                        pps->Release();
                    }
                }
                DPA_SetPtr(_hdpaProps, _iCurrent, pss);
            }
        }
        if (SUCCEEDED(hr) && ppss)
        {
            *ppss = pss;
        }
    }
    return hr;
}

// NOTE: ppps is an IN-OUT parameter
HRESULT CImageData::_CreatePropStorage(IPropertyStorage **ppps, REFFMTID fmtid)
{
    HRESULT hr = E_FAIL;

    if (_pImage)
    {
        CImagePropSet *ppsImg = new CImagePropSet(_pImage, this, *ppps, fmtid, _PropertyChanged);

        ATOMICRELEASE(*ppps);

        if (ppsImg)
        {
            hr = ppsImg->QueryInterface(IID_PPV_ARG(IPropertyStorage, ppps));
            ppsImg->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// IPropertySetStorage
//
// If the caller wants FMTID_ImageProperties use CImagePropSet
//
STDMETHODIMP CImageData::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags,
                                DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;

    IPropertySetStorage *pss;
    HRESULT hr= _EnsureProperties(&pss);
    if (SUCCEEDED(hr))
    {
        if ((S_OK != IsEditable()) && (grfMode & (STGM_READWRITE | STGM_WRITE)))
        {
            hr = STG_E_ACCESSDENIED;
        }
    }
    if (SUCCEEDED(hr))
    {
        IPropertyStorage *pps = NULL;
        hr = pss->Create(fmtid, pclsid, grfFlags, grfMode, &pps);
        if (SUCCEEDED(hr))
        {
            hr = _CreatePropStorage(&pps, fmtid);
        }
        *pppropstg = pps;
    }
    return hr;
}

STDMETHODIMP CImageData::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;

    IPropertySetStorage *pss;
    HRESULT hr = _EnsureProperties(&pss);
    
    if (SUCCEEDED(hr))
    {
        if ((S_OK != IsEditable()) && (grfMode & (STGM_READWRITE | STGM_WRITE)))
        {
            hr = STG_E_ACCESSDENIED;
        }
    }
    if (SUCCEEDED(hr))
    {
        IPropertyStorage *pps = NULL;
        // special case FMTID_ImageSummaryInformation...it is readonly and not backed up
        // by a real property stream.
        if (FMTID_ImageSummaryInformation != fmtid)
        {
            hr = pss->Open(fmtid, grfMode, &pps);
        }

        if (SUCCEEDED(hr))
        {
            hr = _CreatePropStorage(&pps, fmtid);
        }
        *pppropstg = pps;
    }
    return hr;
}

STDMETHODIMP CImageData::Delete(REFFMTID fmtid)
{
    IPropertySetStorage *pss;
    HRESULT hr = _EnsureProperties(&pss);
    if (SUCCEEDED(hr))
    {
        hr = pss->Delete(fmtid);
    }
    return hr;
}

STDMETHODIMP CImageData::Enum(IEnumSTATPROPSETSTG **ppenum)
{
    IPropertySetStorage *pss;
    HRESULT hr = E_INVALIDARG;
    if (ppenum)
    {
        hr = _EnsureProperties(&pss);
        *ppenum = NULL;
    }
    if (SUCCEEDED(hr))
    {
        IEnumSTATPROPSETSTG *pEnum;
        hr = pss->Enum(&pEnum);
        if (SUCCEEDED(hr))
        {
            CFmtEnum *pFmtEnum = new CFmtEnum(pEnum);
            if (pFmtEnum)
            {
                hr = pFmtEnum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
                pEnum->Release();
                pFmtEnum->Release();
            }
            else
            {
               *ppenum = pEnum;
            }
        }
    }
    return hr;
}


// editing support

void CImageData::_SetEditImage(Image *pimgEdit)
{
    if (_pimgEdited)
        delete _pimgEdited;

    _pimgEdited = pimgEdit;
}


// valid input is 0, 90, 180, or 270
HRESULT CImageData::Rotate(DWORD dwAngle)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // this has bad effects on animated images so don't do it
        if (_fAnimated)
            return E_NOTVALIDFORANIMATEDIMAGE;


        RotateFlipType rft;
        switch (dwAngle)
        {
        case 0:
            hr = S_FALSE;
            break;

        case 90:
            rft = Rotate90FlipNone;
            break;

        case 180:
            rft = Rotate180FlipNone;
            break;

        case 270:
            rft = Rotate270FlipNone;
            break;

        default:
            hr = E_INVALIDARG;
        }

        if (S_OK == hr)
        {
            // get the current image we have displayed, ready to edit it.
            Image * pimg = _pimgEdited ? _pimgEdited->Clone() : _pImage->Clone();
            if (pimg)
            {
                // In order to fix Windows bug #325413 GDIPlus needs to throw away any decoded frames 
                // in memory for the cloned image. Therefore, we can no longer rely on
                // RotateFlip to flip the decoded frame already in memory and must explicitly
                // select it into the cloned image before calling RotateFlip to fix Windows Bug #368498
                
                const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;
                hr = HR_FROM_STATUS(pimg->SelectActiveFrame(pclsidFrameDim, _iCurrent));
                
                if (SUCCEEDED(hr))
                {
                    hr = HR_FROM_STATUS(pimg->RotateFlip(rft));
                    if (SUCCEEDED(hr))
                    {
                        _dwRotation = (_dwRotation + dwAngle) % 360;
                        _SetEditImage(pimg);
                    }                    
                }
                if (FAILED(hr))
                {
                    delete pimg;   
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


HRESULT CImageData::Scale(ULONG cx, ULONG cy, InterpolationMode hints)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // this has bad effects on animated images
        if (_fAnimated)
            return E_NOTVALIDFORANIMATEDIMAGE;

        Image * pimg = _pimgEdited ? _pimgEdited : _pImage;

        // we have an image, lets determine the new size (preserving aspect ratio
        // and ensuring that we don't end up with a 0 sized image as a result.

        if (cy == 0)
            cy = MulDiv(pimg->GetHeight(), cx, pimg->GetWidth());
        else if (cx == 0)
            cx = MulDiv(pimg->GetWidth(), cy, pimg->GetHeight());

        cx = max(cx, 1);
        cy = max(cy, 1);

        // construct our new image and draw into it.

        Bitmap *pimgNew = new Bitmap(cx, cy);
        if (pimgNew)
        {
            Graphics g(pimgNew);
            g.SetInterpolationMode(hints);

            hr = HR_FROM_STATUS(g.DrawImage(pimg, Rect(0, 0, cx, cy),
                                            0, 0, pimg->GetWidth(), pimg->GetHeight(),
                                            UnitPixel, NULL, QueryAbort, this));
            //
            //  GDI+ sometimes forgets to tell us it gave up due to an abort.
            //
            if (SUCCEEDED(hr) && QueryAbort(this))
                hr = E_ABORT;

            if (SUCCEEDED(hr))
            {
                pimgNew->SetResolution(pimg->GetHorizontalResolution(), pimg->GetVerticalResolution());

                _SetEditImage(pimgNew);
                _fDestructive = TRUE;                // the edit was Destructive
            }
            else
            {
                delete pimgNew;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


HRESULT CImageData::DiscardEdit()
{
    // NB: The following code is not valid in all cases.  For example, if you rotated, then scaled, then rotated again
    // this code wouldn't work.  We currently don't allow that scenario, so we shouldn't hit this problem, but it
    // could be an issue for others using this object so we should figure out what to do about it.  This code works
    // if: 1.) your first edit is a scale, or 2.) you only do rotates.  Also note, this code will clear the "dirty" bit
    // so it would prevent the image from being saved, thus the failure of this code won't effect the data on disk.
    if (_pimgEdited)
    {
        delete _pimgEdited;
        _pimgEdited = NULL;
    }
    _dwRotation = 0;
    _fDestructive = FALSE;
    return S_OK;
}


// handle persisting images

HRESULT CImageData::SetEncoderParams(IPropertyBag *ppbEnc)
{
    IUnknown_Set((IUnknown**)&_ppbEncoderParams, ppbEnc);
    return S_OK;
}


// save images to the given stream that we have, using the format ID we have

void CImageData::_AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}

#define MAX_ENC_PARAMS 3
HRESULT CImageData::_SaveImages(IStream *pstrm, GUID * pguidFmt)
{
    HRESULT hr = S_OK;
    int iQuality = 0;           // == 0 is a special case

    // did the encoder specify a format for us to save in?
    ASSERTMSG(NULL != pguidFmt, "Invalid pguidFmt passed to internal function CImageData::_SaveImages");

    GUID guidFmt = *pguidFmt;
    if (_ppbEncoderParams)
    {
        VARIANT var = {0};

        // read the encoder format to be used
        if (SUCCEEDED(_ppbEncoderParams->Read(SHIMGKEY_RAWFORMAT, &var, NULL)))
        {
            VariantToGUID(&var, &guidFmt);
            VariantClear(&var);
        }

        // read the encoder quality to be used, this is set for the JPEG one only
        if (guidFmt == ImageFormatJPEG)
        {
            SHPropertyBag_ReadInt(_ppbEncoderParams, SHIMGKEY_QUALITY, &iQuality);
            iQuality = max(0, iQuality);
            iQuality = min(100, iQuality);
        }
    }

    // given the format GUID lets determine the encoder we intend to
    // use to save the image

    CLSID clsidEncoder;
    hr = _GetEncoderFromFormat(&guidFmt, &clsidEncoder);
    if (SUCCEEDED(hr))
    {
        // the way encoding works with GDI+ is a bit strange, you first need to call an image to
        // have it save into a particular stream/file.   if the image is multi-page then you
        // must set an encoder parameter which defines that this will be a multi-page save (and
        // that you will be calling the SaveAdd later).
        //
        // having performed the initial save, you must then attempt to add the subsequent pages
        // to the file by calling SaveAdd, you call that method on the first image you saved
        // specifying that you are adding another page (and possibly that this is the last image
        // in the series).
        BOOL bSaveCurrentOnly = FALSE;
        Image *pimgFirstSave = NULL;
        DWORD dwMaxPage = _cImages;
        DWORD dwMinPage = 0;
        // If viewing a multipage image and saving to a single page format, only save the current frame
        if (_cImages > 1 &&  !FmtSupportsMultiPage(this, &guidFmt))
        {
            bSaveCurrentOnly = TRUE;
            dwMaxPage = _iCurrent+1;
            dwMinPage = _iCurrent;
        }
        for (DWORD i = dwMinPage; SUCCEEDED(hr) && (i < dwMaxPage); i++)
        {
            EncoderParameters ep[MAX_ENC_PARAMS] = { 0 };
            ULONG ulCompression = 0; // in same scope as ep
            // we use _pImage as the source if unedited in order to preserve properties
            const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;
            _pImage->SelectActiveFrame(pclsidFrameDim, i);

            Image *pimg;
            if (_pimgEdited && i==_iCurrent)
            {
                pimg = _pimgEdited;
            }
            else
            {
                pimg = _pImage;
            }
            _SaveFrameProperties(pimg, i);
            
            if (guidFmt == ImageFormatTIFF)          
            {
                VARIANT var = {0};
                if (SUCCEEDED(_GetProperty(PropertyTagCompression, &var, VT_UI2)))
                {                   
                    // be sure to preserve TIFF compression
                   // these values are taken from the TIFF spec
                    switch (var.uiVal)
                    {
                        case 1:
                            ulCompression = EncoderValueCompressionNone;
                            break;
                        case 2:
                            ulCompression = EncoderValueCompressionCCITT3;
                            break;
                        case 3:
                            ulCompression = EncoderValueCompressionCCITT4;
                            break;
                        case 5:
                            ulCompression = EncoderValueCompressionLZW;
                            break;
                        case 32773:
                            ulCompression = EncoderValueCompressionRle;
                            break;
                        default:
                            // use the GDI+ default
                            break;
                    }       
                    VariantClear(&var);                 
                    if (ulCompression)
                    {
                        _AddEncParameter(ep, EncoderCompression, EncoderParameterValueTypeLong, &ulCompression);
                    }
                }
            }

            if (i == dwMinPage)
            {
                // we are writing the first page of the image, if this is a multi-page
                // image then we need to set the encoder parameters accordingly (eg. set to
                // multi-page).
                
                ULONG ulValue = 0; // This needs to be in scope when Save is called

                // We can only to lossless rotation when:
                // * The original image is a JPEG file
                // * The destination image is a JPEG file
                // * We are only rotating and not scaling
                // * The width and height of the JPEG are multiples of 8
                // * Quality is unchanged by the caller

                if (!_fDestructive && 
                    IsEqualIID(_guidFmt, ImageFormatJPEG) && 
                    IsEqualIID(guidFmt, ImageFormatJPEG) && 
                    (iQuality == 0))
                {
                    // this code assumes JPEG files are single page since it's inside the i==0 case
                    ASSERT(_cImages == 1);

                    // for JPEG when doing only a rotate we use a special encoder parameter on the original
                    // image rather than using the edit image.  This allows lossless rotation.
                    pimg = _pImage;

                    switch (_dwRotation)
                    {
                    case 90:
                        ulValue = EncoderValueTransformRotate90;
                        break;
                    case 180:
                        ulValue = EncoderValueTransformRotate180;
                        break;
                    case 270:
                        ulValue = EncoderValueTransformRotate270;
                        break;
                    }

                    _AddEncParameter(ep, EncoderTransformation, EncoderParameterValueTypeLong, &ulValue);
                }
                else if (_cImages > 1 && !bSaveCurrentOnly)
                {
                    ulValue = EncoderValueMultiFrame;
                    _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &ulValue);
                    pimgFirstSave = pimg;           // keep this image as we will us it for appending pages
                }

                // JPEG quality is only ever set for a single image, therefore don't
                // bother passing it for the multi page case.

                if (iQuality > 0)
                    _AddEncParameter(ep, EncoderQuality, EncoderParameterValueTypeLong, &iQuality);
                
                hr = HR_FROM_STATUS(pimg->Save(pstrm, &clsidEncoder, (ep->Count > 0) ? ep:NULL));
            }
            else
            {
                // writing the next image in the series, set the encoding parameter
                // to indicate that this is the next page.  if we are writing the last
                // image then set the last frame flag.

                ULONG flagValueDim = EncoderValueFrameDimensionPage;
                ULONG flagValueLastFrame = EncoderValueLastFrame;

                _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueDim);
                
                if (i == (dwMaxPage-1))
                    _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueLastFrame);

                hr = HR_FROM_STATUS(pimgFirstSave->SaveAdd(pimg, (ep->Count > 0) ? ep:NULL));
            }
        }
    }

   
    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


// returns the DPI of the image
STDMETHODIMP CImageData::GetResolution(ULONG *puResolutionX, ULONG *puResolutionY)
{
    if (!puResolutionX && !puResolutionY)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = _EnsureImage();
    if (puResolutionX)
    {
        *puResolutionX = 0;
    }
    if (puResolutionY)
    {
        *puResolutionY = 0;
    }
    if (SUCCEEDED(hr))
    {
        UINT uFlags = _pImage->GetFlags();
        //
        // We only return the DPI information from the image header for TIFFs whose
        // X and Y DPI differ, those images are likely faxes. 
        // We want our client applications (slideshow, image preview)
        // to deal with actual pixel sizes for the most part
        //  
        ULONG resX = (ULONG)_pImage->GetHorizontalResolution();
        ULONG resY = (ULONG)_pImage->GetVerticalResolution();
#ifndef USE_EMBEDDED_DPI_ALWAYS
        if (_guidFmt != ImageFormatTIFF || !(uFlags & ImageFlagsHasRealDPI) || resX == resY )
        {
            // if GetDC fails we have to rely on the numbers back from GDI+
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                resX = GetDeviceCaps(hdc, LOGPIXELSX);
                resY = GetDeviceCaps(hdc, LOGPIXELSY);
                ReleaseDC(NULL, hdc);
            }
        }
#endif
        if (puResolutionX)
        {
            
            *puResolutionX = resX;
        }
        if (puResolutionY)
        {
            *puResolutionY = resY;
        }

        if ((puResolutionX && !*puResolutionX) || (puResolutionY && !*puResolutionY))
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

// handle saving and replacing the original file
// in the case of replacing an existing file, we want the temp file to be in the same volume
// as the target

HRESULT CImageData::_MakeTempFile(LPWSTR pszFile)
{
    ASSERT(_pstrm);

    WCHAR szTempPath[MAX_PATH];
    HRESULT hr = S_OK;
    if (_pstrm->IsFileStream())
    {
        StrCpyN(szTempPath, _pstrm->GetFilename(), ARRAYSIZE(szTempPath));
        PathRemoveFileSpec(szTempPath);
    }
    else if (!GetTempPath(ARRAYSIZE(szTempPath), szTempPath))
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // SIV == "Shell Image Viewer"
        if (GetTempFileName(szTempPath, TEXT("SIV"), 0, pszFile))
        {
            SetFileAttributes(pszFile, ATTRIBUTES_TEMPFILE);
            // we need to suppress the change notfy from the GetTempFileName()
            // call as that causes defview to display this.
            // but for some reason it does not work
            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFile, NULL);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CImageData::_ReplaceFile(LPCTSTR pszNewFile)
{
    // first we get some info about the file we're replacing:
    LPCTSTR pszOldFile = _pstrm->GetFilename();
    STATSTG ss = {0};
    _pstrm->Stat(&ss, STATFLAG_NONAME);
   
    // This ensures that the source handle is closed
    _SuspendStream();

    HRESULT hr;
    // ReplaceFile doesn't save the modified time, so if we rotate an image twice in quick succession
    // we won't add a full 2 seconds to the modified time. So query the time before replacing the file.
    WIN32_FIND_DATA wfd ={0};
    GetFileAttributesEx(pszOldFile, GetFileExInfoStandard, &wfd);
    if (ReplaceFile(pszOldFile, pszNewFile, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL))
    {
        // The old file has been replaced with the new file, but now we need to ensure that the
        // filetime actually changed due to the 2 sec accuracy of FAT.
        // we do this on NTFS too, since XP pidls have 2 sec accuracy since they cast the filetime
        // down to a dos datetime.

        
        HANDLE hFile = CreateFile(pszOldFile, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            FILETIME *pft = (CompareFileTime(&wfd.ftLastWriteTime, &ss.mtime) < 0) ? &ss.mtime : &wfd.ftLastWriteTime;
            IncrementFILETIME(pft, 2 * FT_ONESECOND);
            SetFileTime(hFile, NULL, NULL, pft);
            CloseHandle(hFile);
        }
        
        // the replacefile call wont always keep the "replaced" file (pszOldFile) attributes, if it's
        // replacing across a win98 share for example.  no biggie, just set the attributes again, using
        // the attribs we know we got from the stat.
        SetFileAttributes(pszOldFile, ss.reserved);


        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH | SHCNF_FLUSHNOWAIT | SHCNF_FLUSH, pszOldFile, NULL);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

void SaveProperties(IPropertySetStorage *pss, Image *pimg, REFFMTID fmtid, CDSA<SHCOLUMNID> *pdsaChanges)
{
    IPropertyStorage *pps;
    if (SUCCEEDED(pss->Open(fmtid, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pps)))
    {
        CImagePropSet *pips = new CImagePropSet(pimg, NULL, pps, fmtid);
        if (pips)
        {
            pips->SaveProps(pimg, pdsaChanges);
            pips->Release();
        }
        pps->Release();
    }
}

void CImageData::_SaveFrameProperties(Image *pimg, LONG iFrame)
{
    // make sure _dsaChangedProps is non-NULL
    if (_hdpaProps && (HDSA)_dsaChangedProps)
    {
        IPropertySetStorage *pss = (IPropertySetStorage *)DPA_GetPtr(_hdpaProps, iFrame);
        if (pss)
        {
            // Start with FMTID_ImageProperties to make sure other FMTIDs take precedence (last one wins)
            
            SaveProperties(pss, pimg, FMTID_ImageProperties, &_dsaChangedProps);
 
            // enum all the property storages and create a CImagePropSet for each one
            // and have it save to the pimg
            IEnumSTATPROPSETSTG *penum;
            if (SUCCEEDED(pss->Enum(&penum)))
            {
                STATPROPSETSTG spss;

                while (S_OK == penum->Next(1, &spss, NULL))
                {
                    if (!IsEqualGUID(spss.fmtid, FMTID_ImageProperties))
                    {
                        SaveProperties(pss, pimg, spss.fmtid, &_dsaChangedProps);
                    }
                }
                penum->Release();
            }
        }
    }
}

void CImageData::_PropertyChanged(IShellImageData* pThis, SHCOLUMNID *pscid)
{
    ((CImageData*)pThis)->_fPropertyChanged = TRUE;
    if ((HDSA)(((CImageData*)pThis)->_dsaChangedProps))
    {
        ((CImageData*)pThis)->_dsaChangedProps.AppendItem(pscid);
    }
}

//
// This function determines the list of available encoder parameters given the file format
// Hopefully future versions of GDI+ will decouple this call from the Image() object
// Don't call this function until ready to save the loaded image
STDMETHODIMP CImageData::GetEncoderParams(GUID *pguidFmt, EncoderParameters **ppencParams)
{
    CLSID clsidEncoder;
    HRESULT hr = E_FAIL;
    if (_pImage && ppencParams)
    {
        hr = _GetEncoderFromFormat(pguidFmt, &clsidEncoder);
    }
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        UINT uSize = _pImage->GetEncoderParameterListSize(&clsidEncoder);
        if (uSize)
        {
            *ppencParams = (EncoderParameters *)CoTaskMemAlloc(uSize);
            if (*ppencParams)
            {
                hr = HR_FROM_STATUS(_pImage->GetEncoderParameterList(&clsidEncoder, uSize, *ppencParams));
                if (FAILED(hr))
                {
                    CoTaskMemFree(*ppencParams);
                    *ppencParams = NULL;
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CImageData::RegisterAbort(IShellImageDataAbort *pAbort, IShellImageDataAbort **ppAbortPrev)
{
    if (ppAbortPrev)
    {
        *ppAbortPrev = _pAbort; // Transfer ownership to caller
    }
    else if (_pAbort)
    {
        _pAbort->Release(); // Caller doesn't want it, so throw away
    }

    _pAbort = pAbort;           // Set the new abort callback

    if (_pAbort)
    {
        _pAbort->AddRef();
    }

    return S_OK;
}

BOOL CALLBACK CImageData::QueryAbort(void *pvRef)
{
    CImageData* pThis = reinterpret_cast<CImageData *>(pvRef);
    return pThis->_pAbort && pThis->_pAbort->QueryAbort() == S_FALSE;
}


HRESULT CImageData::CloneFrame(Image **ppimg)
{
    *ppimg = NULL;
    Image *pimg = _pimgEdited ? _pimgEdited : _pImage;
    if (pimg)
    {
        *ppimg = pimg->Clone();
    }
    return *ppimg ? S_OK : E_FAIL;
}

HRESULT CImageData::ReplaceFrame(Image *pimg)
{
    _SetEditImage(pimg);
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// CImageDataFactory
/////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI CImageDataFactory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CImageFactory *psid = new CImageFactory();
    if (!psid)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psid->Release();
    return hr;
}

CImageFactory::CImageFactory() : _cRef(1)
{
    _Module.Lock();
}

CImageFactory::~CImageFactory()
{
    _Module.Unlock();
}

STDMETHODIMP CImageFactory::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImageFactory, IShellImageDataFactory),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageFactory::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImageFactory::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CImageFactory::CreateIShellImageData(IShellImageData **ppshimg)
{
    CImageData *psid = new CImageData();
    if (!psid)
        return E_OUTOFMEMORY;

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));
    psid->Release();
    return hr;
}

HRESULT CImageFactory::CreateImageFromFile(LPCWSTR pszPath, IShellImageData **ppshimg)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageData *psid = new CImageData();
    if (psid)
    {
        IPersistFile *ppf;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(pszPath, STGM_READ);
            ppf->Release();
        }

        if (SUCCEEDED(hr))
            hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));

        psid->Release();
    }
    return hr;
}

HRESULT CImageFactory::CreateImageFromStream(IStream *pstrm, IShellImageData **ppshimg)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageData *psid = new CImageData();
    if (psid)
    {
        IPersistStream *ppstrm;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstrm));
        if (SUCCEEDED(hr))
        {
            hr = ppstrm->Load(pstrm);
            ppstrm->Release();
        }

        if (SUCCEEDED(hr))
            hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));

        psid->Release();
    }
    return hr;
}

HRESULT CImageFactory::GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    return _GetDataFormatFromPath(pszPath, pguidFmt);
}

HRESULT CEncoderInfo::_GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    *pguidFmt = GUID_NULL;

    HRESULT hr = _GetEncoderList();
    if (SUCCEEDED(hr))
    {
        UINT i = FindInDecoderList(_pici, _cEncoders, pszPath);
        if (-1 != i)
        {
            *pguidFmt = _pici[i].FormatID;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CEncoderInfo::_GetEncoderList()
{
    HRESULT hr = S_OK;
    if (!_pici)
    {
        // lets pick up the list of encoders, first we get the encoder size which
        // gives us the CB and the number of encoders that are installed on the
        // machine.

        UINT cb;
        hr = HR_FROM_STATUS(GetImageEncodersSize(&_cEncoders, &cb));
        if (SUCCEEDED(hr))
        {
            // allocate the buffer for the encoders and then fill it
            // with the encoder list.

            _pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
            if (_pici)
            {
                hr = HR_FROM_STATUS(GetImageEncoders(_cEncoders, cb, _pici));
                if (FAILED(hr))
                {
                    LocalFree(_pici);
                    _pici = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


HRESULT CEncoderInfo::_GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    HRESULT hr = _GetEncoderList();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        for (UINT i = 0; i != _cEncoders; i++)
        {
            if (_pici[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = _pici[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

CEncoderInfo::CEncoderInfo()
{
    _pici = NULL;
    _cEncoders = 0;
}

CEncoderInfo::~CEncoderInfo()
{
    if (_pici)
        LocalFree(_pici);               // do we have an encoder array to be destroyed
}

STDAPI CImageData_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
     CImageData *psid = new CImageData(*(poi->pclsid) == CLSID_ImagePropertyHandler);
     if (!psid)
     {
         *ppunk = NULL;          // incase of failure
         return E_OUTOFMEMORY;
     }
     HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
     psid->Release();
     return hr;
}

int CImageData::_FreeProps(void* pProp, void* pData)
{
    if (pProp)
    {
        ((IPropertySetStorage*)pProp)->Release();
    }
    return 1;
}

// Our CFmtEnum is a minimal enumerator to provide FMTID_SummaryInformation in our
// formats. It's optimized for 1-by-1 enumeration
STDMETHODIMP CFmtEnum::Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    if (!celt || !rgelt)
    {
        hr = E_INVALIDARG;
    }
    else if (0 == _idx)
    {
        ZeroMemory(rgelt, sizeof(*rgelt));
        rgelt->fmtid = FMTID_ImageSummaryInformation;
        rgelt->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
        if (pceltFetched)
        {
            *pceltFetched = 1;
        }
        _idx++;
        celt--;
        rgelt++;
    }
    if (SUCCEEDED(hr) && celt)
    {
        ULONG ul;
        hr = _pEnum->Next(celt, rgelt, &ul);
        if (SUCCEEDED(hr) && pceltFetched)
        {
            (*pceltFetched) += ul;
        }
    }
    return hr;
}

STDMETHODIMP CFmtEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    if (_idx == 0)
    {
        _idx++;
        celt--;
    }

    if (celt)
    {
        hr = _pEnum->Skip(celt);
    }
    return hr;
}

STDMETHODIMP CFmtEnum::Reset(void)
{
    _idx = 0;
    return _pEnum->Reset();
}

STDMETHODIMP CFmtEnum::Clone(IEnumSTATPROPSETSTG **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFmtEnum *pNew = new CFmtEnum(_pEnum);
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
        pNew->Release();
    }
    return hr;
}

STDMETHODIMP CFmtEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CFmtEnum, IEnumSTATPROPSETSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFmtEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFmtEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CFmtEnum::CFmtEnum(IEnumSTATPROPSETSTG *pEnum) : _cRef(1), _idx(0), _pEnum(pEnum)
{
    _pEnum->AddRef();
}

CFmtEnum::~CFmtEnum()
{
    _pEnum->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\imgprop.cpp ===
#include "precomp.h"
#include "imagprop.h"
#include "imgprop.h"
#include <Stdio.h>
#pragma hdrstop

static const STATPROPSTG g_cImageSummaryProps[] = 
{
    {NULL, PIDISI_CX, VT_UI4},
    {NULL, PIDISI_CY, VT_UI4},
    {NULL, PIDISI_RESOLUTIONX, VT_UI4},
    {NULL, PIDISI_RESOLUTIONY, VT_UI4},
    {NULL, PIDISI_BITDEPTH, VT_UI4},
    {NULL, PIDISI_FRAMECOUNT, VT_UI4},
    {NULL, PIDISI_DIMENSIONS, VT_LPWSTR},
};

HRESULT GetImageFrameCount(Image *pImage, PROPVARIANT *ppv);

// simple IEnumSTATPROPSTG for FMTID_ImageSummaryInformation

class CPropEnum : public IEnumSTATPROPSTG, public NonATLObject
{
public:
    CPropEnum(const STATPROPSTG *pStats, ULONG nStat);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSTATPROPSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumSTATPROPSTG **ppenum);
private:
    ~CPropEnum();

    LONG _cRef;
    ULONG _idx;
    const STATPROPSTG *_pStat;
    ULONG _nStat;
    FMTID _fmtid;
};

CImagePropSet::CImagePropSet(Image *pimg, IShellImageData *pData, 
                             IPropertyStorage *pps, REFFMTID fmtid, FNPROPCHANGE fnCallback) 
    : _pimg(pimg), 
      _pData(pData), 
      _ppsImg(pps), 
      _cRef(1), 
      _fDirty(FALSE),
      _fmtid(fmtid),
      _fnPropChanged(fnCallback),
      _fEditable(TRUE)
{
    if (_pData)
    {
        _pData->AddRef();
        _fEditable = (S_OK == _pData->IsEditable());
    }
    if (_ppsImg)
    {
        _ppsImg->AddRef();
    }
    _Module.Lock();
}

CImagePropSet::~CImagePropSet()
{
    ATOMICRELEASE(_ppsImg);
    ATOMICRELEASE(_pData);
    _Module.Unlock();
}

// IUnknown

STDMETHODIMP CImagePropSet::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CImagePropSet, IPropertyStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImagePropSet::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImagePropSet::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {    
        delete this;
    }
    return cRef;
}

// IPropertyStorage methods
STDMETHODIMP CImagePropSet::ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[])
{
    HRESULT hr = E_UNEXPECTED;
    if (FMTID_ImageSummaryInformation == _fmtid)
    {
        hr = _GetImageSummaryProps(cpspec, rgpspec, rgvar);
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->ReadMultiple(cpspec, rgpspec, rgvar);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst)
{
    HRESULT hr = E_UNEXPECTED;
    if (!_fEditable)
    {
        hr = STG_E_ACCESSDENIED;
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->WriteMultiple(cpspec, rgpspec, rgvar, propidNameFirst);
        if (SUCCEEDED(hr))
        {
            _fDirty = TRUE;
            if (_pData && _fnPropChanged)
            {
                SHCOLUMNID scid;
                scid.fmtid = _fmtid;
                for (ULONG i=0;i<cpspec;i++)
                {
                    scid.pid = rgpspec[i].propid;
                    (*_fnPropChanged)(_pData, &scid);
                }                
            }
        }
    }
    return hr;
}

STDMETHODIMP CImagePropSet::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CImagePropSet::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->ReadPropertyNames(cpropid, rgpropid, rglpwstrName);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->WritePropertyNames(cpropid, rgpropid, rglpwstrName);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->DeletePropertyNames(cpropid, rgpropid);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::SetClass(REFCLSID clsid)
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->SetClass(clsid);
    }
    return hr;
}
    
STDMETHODIMP CImagePropSet::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = S_FALSE;

    if (_fDirty && _pData)
    {
        IPersistFile *pFile;
        if (SUCCEEDED(_pData->QueryInterface(IID_PPV_ARG(IPersistFile, &pFile))))
        {
            hr = pFile->Save(NULL, FALSE);
            pFile->Release();
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

STDMETHODIMP CImagePropSet::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImagePropSet::Enum(IEnumSTATPROPSTG** ppenm)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (FMTID_ImageSummaryInformation == _fmtid)
    {
        CPropEnum *pEnum = new CPropEnum(g_cImageSummaryProps,
                                         ARRAYSIZE(g_cImageSummaryProps));
        if (pEnum)
        {
            hr = pEnum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenm));
            pEnum->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->Enum(ppenm);
    }
    return hr;
}
    
STDMETHODIMP CImagePropSet::Stat(STATPROPSETSTG* pstatpsstg)
{
    HRESULT hr = S_OK;
    if (_ppsImg)
    {
        hr = _ppsImg->Stat(pstatpsstg);             
    }
    else if (FMTID_ImageSummaryInformation == _fmtid)
    {
        ZeroMemory(pstatpsstg, sizeof(STATPROPSETSTG));
        pstatpsstg->fmtid = _fmtid;
        pstatpsstg->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
    }
    else 
    {
        hr = E_UNEXPECTED;
    }
    if (!_fEditable)
    {
        pstatpsstg->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
    }
    return hr;
}

STDMETHODIMP CImagePropSet::SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime)
{
    return E_NOTIMPL;
}

void CImagePropSet::SaveProps(Image *pImage, CDSA<SHCOLUMNID> *pdsaChanges)
{
    // enum the properties in our propertystorage and convert them to PropertyItem structs, and
    // save them to the given frame.
    
    if (_ppsImg)
    {
        for (int i=0;i<pdsaChanges->GetItemCount();i++)
        {
            SHCOLUMNID scid;
            if (pdsaChanges->GetItem(i,&scid))
            {
                if (scid.fmtid == _fmtid)
                {
                    PropertyItem pi;
                    PROPID idUnicode;
                    PROPID idStandard;
                    if (SUCCEEDED(_MapPropidToImgPropid(scid.pid, &idStandard, &idUnicode)))
                    {
                        PROPVARIANT pv = {0};
                        PROPSPEC ps = {PRSPEC_PROPID, scid.pid};
                        if (SUCCEEDED(_ppsImg->ReadMultiple(1, &ps, &pv)))
                        {
                            if (pv.vt == VT_NULL || pv.vt == VT_EMPTY)
                            {
                                if (idUnicode)
                                {
                                    pImage->RemovePropertyItem(idUnicode);
                                }
                                pImage->RemovePropertyItem(idStandard);
                            }
                            else if (SUCCEEDED(_PropVarToImgProp(idUnicode?idUnicode:idStandard, &pv, &pi, idUnicode?TRUE:FALSE)))
                            {
                                // if SetPropertyItem fails what should we do?
                                // for now just ignore it and move on
                                if (Ok == pImage->SetPropertyItem(&pi))
                                {
                                    if (idUnicode)
                                    {
                                        // remove the old ascii tag.
                                        pImage->RemovePropertyItem(idStandard);
                                    }
                                }
                                delete [] (BYTE*)pi.value;

                            }
                            PropVariantClear(&pv);
                        }
                    }
                }                
            }
        }
    }
    _fDirty = FALSE;
}

// Helper functions
HRESULT CImagePropSet::_PropVarToImgProp(PROPID pid, const PROPVARIANT *ppv, PropertyItem *pprop, BOOL bUnicode)
{
    HRESULT hr = S_OK;
    CHAR szValue[MAX_PATH*2];
    void *pBits = NULL;
    ULONG cbData = 0;
    szValue[0] = 0;
    SAFEARRAY *psa = NULL;
    switch (ppv->vt)
    {
    case VT_UI1:
        pprop->type = PropertyTagTypeByte;
        cbData = sizeof(ppv->bVal);
        pBits = (void *)&ppv->bVal;
        break;
    case VT_UI2:
        pprop->type = PropertyTagTypeShort;
        cbData = sizeof(ppv->uiVal);
        pBits = (void *)&ppv->uiVal;
        break;
    case VT_UI4:
        pprop->type = PropertyTagTypeLong;
        cbData = sizeof(ppv->ulVal);
        pBits = (void *)&ppv->ulVal;
        break;
    case VT_LPSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*(lstrlenA(ppv->pszVal)+1);
            pBits = ppv->pszVal ? ppv->pszVal : szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = SHAnsiToUnicode(ppv->pszVal, (LPWSTR)szValue, sizeof(szValue)/sizeof(WCHAR))*sizeof(WCHAR);
            pBits = szValue;
        }
        break;
    case VT_BSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*SHUnicodeToAnsi(ppv->bstrVal, szValue, ARRAYSIZE(szValue));
            pBits = szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = sizeof(WCHAR)*(1+lstrlenW(ppv->bstrVal));
            pBits = ppv->bstrVal;
        }
        break;            
    case VT_LPWSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*SHUnicodeToAnsi(ppv->pwszVal, szValue, ARRAYSIZE(szValue));
            pBits = szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = sizeof(WCHAR)*(1+lstrlenW(ppv->pwszVal));
            pBits = ppv->pwszVal;
        }
        break;
    case VT_UI1|VT_ARRAY:
        pprop->type = PropertyTagTypeByte;
        psa = ppv->parray;
        hr = SafeArrayAccessData(psa, &pBits);
        if (SUCCEEDED(hr))
        {
            SafeArrayGetUBound(psa, 1, (LONG*)&cbData);
        }
        break;
    case VT_UI4|VT_ARRAY:
        pprop->type = PropertyTagTypeLong;
        psa = ppv->parray;
        hr = SafeArrayAccessData(psa, &pBits);
        if (SUCCEEDED(hr))
        {
            SafeArrayGetUBound(psa, 1, (LONG*)&cbData);
        }
        break;
    // we ignore rational values because we can't convert back to numerator/denominator pairs
    case VT_R8:
    default:
        hr = E_INVALIDARG;
        break;
    }
    if (SUCCEEDED(hr))
    {
        pprop->id = pid;
        pprop->length = cbData;
        pprop->value = (void **)new BYTE[cbData];
        if (pprop->value)
        {
            CopyMemory(pprop->value, pBits, cbData);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (psa)
    {
        SafeArrayUnaccessData(psa);
    }
    return hr;
}


typedef HRESULT (CALLBACK* PROPPROC)(Image *pimg, PROPVARIANT *ppv);
const static struct 
{
    FMTID fmtid;
    PROPID pid;
    PROPPROC fnPropProc;
} c_aPropList [] =
{
    {PSGUID_SUMMARYINFORMATION, PIDSI_PAGECOUNT, GetImageFrameCount},
};


#define UNI_AUTHOR   0x001
#define UNI_COMMENT  0x002
#define UNI_TITLE    0x004
#define UNI_KEYWORD  0x008
#define UNI_SUBJECT  0x010


const static struct
{
    FMTID fmtid;
    PROPID propid;
    PROPID imgPropid;
    PROPID imgPropidUnicode;
    DWORD dwMask;
}
c_rgImagePropertyMap[] = 
{
    {PSGUID_SUMMARYINFORMATION, PIDSI_TITLE, PropertyTagImageDescription, PropertyTagUnicodeDescription, UNI_TITLE},
    {PSGUID_SUMMARYINFORMATION, PIDSI_COMMENT, 0, PropertyTagUnicodeComment, UNI_COMMENT},
    {PSGUID_SUMMARYINFORMATION, PIDSI_AUTHOR, PropertyTagArtist, PropertyTagUnicodeArtist, UNI_AUTHOR},
    {PSGUID_SUMMARYINFORMATION, PIDSI_APPNAME, PropertyTagSoftwareUsed,0},
    {PSGUID_SUMMARYINFORMATION, PIDSI_CREATE_DTM, PropertyTagDateTime,0},
    // some tags have no standard EXIF/TIFF equivalent
    {PSGUID_SUMMARYINFORMATION, PIDSI_KEYWORDS, 0, PropertyTagUnicodeKeywords, UNI_KEYWORD},
    {PSGUID_SUMMARYINFORMATION, PIDSI_SUBJECT, 0, PropertyTagUnicodeSubject, UNI_SUBJECT},    
};

BOOL IsAsciiPropertyPresent(PROPID pidUnicode, PROPID *aid, UINT cProperties)
{
    // first find the ASCII value
    UINT i;
    BOOL bRet = FALSE;
    PROPID pidAscii = 0;
    for (i=0;!pidAscii && i<ARRAYSIZE(c_rgImagePropertyMap);i++)
    {
        if (pidUnicode == c_rgImagePropertyMap[i].imgPropidUnicode)
        {
            pidAscii = c_rgImagePropertyMap[i].imgPropid;
        }
    }
    if (pidAscii)
    {
        for (i=0;i<cProperties;i++)
        {
            if (pidAscii == aid[i])
            {
                bRet = TRUE;
            }
        }
    }
    return bRet;
}

void _UpdateUnicodeMask(DWORD *pdwMask, PROPID pid)
{
    for (int i=0;i<ARRAYSIZE(c_rgImagePropertyMap);i++)
    {
        if (pid == c_rgImagePropertyMap[i].imgPropidUnicode)
        {
            *pdwMask |= c_rgImagePropertyMap[i].dwMask;
        }
    }
}
// sync all of the properties in the image file (regular header and EXIF header)
//  into the property storage that we have here
// for properties that we write UNICODE equivalents, we always defer to the ASCII version
// if present in the file. 


HRESULT CImagePropSet::SyncImagePropsToStorage()
{
    UINT cProperties = _pimg->GetPropertyCount();
    PROPSPEC pspec;
    pspec.ulKind = PRSPEC_PROPID;
    PROPVARIANT pvar = {0};
    // create a simple mask for determining which of the unicode properties are written
    // if they aren't written we will special case them and write empty strings with VT_LPWSTR type
    DWORD dwUnicodeWritten = 0;
    if (cProperties)
    {
        PROPID *aid = new PROPID[cProperties];
        if (aid)
        {
            if (Ok == _pimg->GetPropertyIdList(cProperties, aid))
            {
                BOOL bUnicode;
                for (UINT i = 0; i < cProperties; i++)
                {
                    if (SUCCEEDED(_MapImgPropidToPropid(aid[i], &pspec.propid, &bUnicode)))
                    {
                        if (!bUnicode || !IsAsciiPropertyPresent(aid[i], aid, cProperties))
                        {
                            UINT cbSize = _pimg->GetPropertyItemSize(aid[i]);
                            if (cbSize)
                            {
                                PropertyItem *ppi = (PropertyItem*)LocalAlloc(LPTR, cbSize);
                                if (ppi)
                                {
                                    if (Ok == _pimg->GetPropertyItem(aid[i], cbSize, ppi))
                                    {
                                        if (SUCCEEDED(_PropImgToPropvar(ppi, &pvar, bUnicode)))
                                        {
                                            _ppsImg->WriteMultiple(1, &pspec, &pvar,2);
                                            if (_fmtid == FMTID_SummaryInformation)
                                            {
                                                _UpdateUnicodeMask(&dwUnicodeWritten, aid[i]);
                                            }
                                            PropVariantClear(&pvar);
                                        }
                                    }
                                    LocalFree(ppi);
                                }
                            }
                        }
                    }
                }
            }
            delete [] aid;
        }
    }
    //
    // Some properties are derived from other means than EXIF or TIFF tags, cycle
    // through the property list and add properties from callback functions
    //
    for (int i=0;i<ARRAYSIZE(c_aPropList);i++)
    {
        pspec.propid = c_aPropList[i].pid;
        if (_fmtid == c_aPropList[i].fmtid && 
            SUCCEEDED(c_aPropList[i].fnPropProc(_pimg, &pvar)))
        {
            _ppsImg->WriteMultiple(1, &pspec, &pvar,2);
            PropVariantClear(&pvar);
        }
    }
    //
    // Write the empty unicode strings if needed
    //
    if (_fEditable && _fmtid == FMTID_SummaryInformation)
    {
        PropVariantInit(&pvar);
        pvar.vt = VT_LPWSTR;
        pvar.pwszVal = L"";
        if (pvar.pwszVal)
        {
            for (int i=0;i<ARRAYSIZE(c_rgImagePropertyMap);i++)
            {
                if (c_rgImagePropertyMap[i].dwMask && !(c_rgImagePropertyMap[i].dwMask & dwUnicodeWritten))
                {
                    pspec.propid = c_rgImagePropertyMap[i].propid;
                    _ppsImg->WriteMultiple(1, &pspec, &pvar, 2);
                }
            }
        }
        // don't clear the propvar since we didn't heap alloc the string
    }
    return S_OK;
}


HRESULT StrDupNW(LPCWSTR psz, WCHAR **ppwsz, DWORD cch)
{
    WCHAR *pwsz;
    DWORD cb = cch*sizeof(WCHAR);
    if (psz)
    {
        if (psz[cch-1] != L'\0')
        {
            cb+=sizeof(WCHAR); // need space for NULL
        }
        pwsz = (WCHAR *)CoTaskMemAlloc(cb); 
    }
    else
        pwsz = NULL;
    
    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        pwsz[(cb/sizeof(WCHAR))-1] = L'\0';
        memcpy(pwsz, psz, cch*sizeof(WCHAR));
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CImagePropSet::_PropImgToPropvar(PropertyItem *pi, PROPVARIANT *pvar, BOOL bUnicode)
{
    HRESULT hr = S_OK;
    if (!pi->length)
    {
        return E_FAIL;
    }
    switch (pi->type)
    {
    case PropertyTagTypeByte:
        pvar->vt = VT_UI1;
        // check for multi-valued property and convert to safearray or unicode string if found
        if (pi->length > sizeof(UCHAR))
        {
            if (!bUnicode)
            {
                SAFEARRAYBOUND bound;
                bound.cElements = pi->length/sizeof(UCHAR);
                bound.lLbound = 0;
                pvar->vt |= VT_ARRAY; 
                hr = E_OUTOFMEMORY;
                pvar->parray = SafeArrayCreate(VT_UI1, 1, &bound);                              
                if (pvar->parray)
                {
                    void *pv;
                    hr = SafeArrayAccessData(pvar->parray, &pv);
                    if (SUCCEEDED(hr))
                    {
                        CopyMemory(pv, pi->value, pi->length);
                        SafeArrayUnaccessData(pvar->parray);                        
                    }
                    else
                    {
                        SafeArrayDestroy(pvar->parray);
                    }
                }
            }
            else
            {
                pvar->vt = VT_LPWSTR;
                hr = StrDupNW((LPCWSTR)pi->value, &pvar->pwszVal, pi->length/sizeof(WCHAR));
            }
        }
        else
        {
            pvar->bVal = *((UCHAR*)pi->value);
        }
        
        break;
        
    case PropertyTagTypeShort:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pi->value);
        break;
        
    case PropertyTagTypeLong:
        pvar->vt = VT_UI4;
        if (pi->length > sizeof(ULONG))
        {
            SAFEARRAYBOUND bound;
            bound.cElements = pi->length/sizeof(ULONG);
            bound.lLbound = 0;
            pvar->vt |= VT_ARRAY; 
            hr = E_OUTOFMEMORY;
            pvar->parray = SafeArrayCreate(VT_UI4, 1, &bound);                              
            if (pvar->parray)
            {
                void *pv;
                hr = SafeArrayAccessData (pvar->parray, &pv);
                if (SUCCEEDED(hr))
                {
                    CopyMemory (pv, pi->value, pi->length);
                    SafeArrayUnaccessData(pvar->parray);                        
                }
                else
                {
                    SafeArrayDestroy(pvar->parray);
                }
            }
        }
        else
        {
            pvar->ulVal = *((ULONG*)pi->value);
        }
        break;
        
    case PropertyTagTypeASCII:
        // special case for date taken
        if (_fmtid == FMTID_ImageProperties && pi->id == PropertyTagExifDTOrig)
        {
            SYSTEMTIME st = {0};
            sscanf((LPSTR)pi->value, "%hd:%hd:%hd %hd:%hd:%hd",
                   &st.wYear, &st.wMonth,
                   &st.wDay, &st.wHour,
                   &st.wMinute, &st.wSecond);
            if (st.wYear) 
            {
                FILETIME ftUTC;
                FILETIME ftLocal;            
                // we expect cameras to return local times. Need to convert to UTC.
                SystemTimeToFileTime(&st, &ftLocal);
                LocalFileTimeToFileTime(&ftLocal, &ftUTC);
                FileTimeToSystemTime(&ftUTC, &st);
                SystemTimeToVariantTime(&st, &pvar->date);
                pvar->vt = VT_DATE;
            }
            else
            {
                pvar->vt = VT_EMPTY;
            }
        }
        else 
        {
            // GDI+ NULL terminates the ASCII string for us
            hr = SHStrDupA(pi->value ? (LPSTR)pi->value : "", &pvar->pwszVal);
            if (SUCCEEDED(hr))
            {
                pvar->vt = VT_LPWSTR;
            }
        }
        break;
        
    case PropertyTagTypeSRational:
    case PropertyTagTypeRational:
        {
            LONG *pl = (LONG*)pi->value;
            LONG num = pl[0];
            LONG den = pl[1];
            
            pvar->vt = VT_R8;            
            if (0 == den)
                pvar->dblVal = 0;           // don't divide by zero
            else
                pvar->dblVal = ((double)num)/((double)den);
            
            break;
        }
        
    case PropertyTagTypeUndefined:
    case PropertyTagTypeSLONG:
    default:
        hr = E_UNEXPECTED;
        break;
    }
    
    return hr;
}



HRESULT CImagePropSet::_MapPropidToImgPropid(PROPID propid, PROPID *ppid, PROPID *pidUnicode)
{
    HRESULT hr;
    *ppid = 0;
    *pidUnicode = 0;
    if (_fmtid == FMTID_ImageProperties)
    {
        *ppid = propid;     // these go into the EXIF header
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(c_rgImagePropertyMap); i++)
        {
            if (c_rgImagePropertyMap[i].fmtid == _fmtid && c_rgImagePropertyMap[i].propid == propid)
            {
                *ppid = c_rgImagePropertyMap[i].imgPropid;
                *pidUnicode = c_rgImagePropertyMap[i].imgPropidUnicode;
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

HRESULT CImagePropSet::_MapImgPropidToPropid(PROPID propid, PROPID *ppid, BOOL *pbUnicode)
{
    HRESULT hr;
    *pbUnicode = FALSE;
    if (_fmtid == FMTID_ImageProperties)
    {
        *ppid = propid;     // EXIF properties don't need to be mapped
        hr = S_OK;
    }
    else
    {
        *ppid = 0;
        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(c_rgImagePropertyMap); i++)
        {
            if (c_rgImagePropertyMap[i].fmtid == _fmtid && 
                (c_rgImagePropertyMap[i].imgPropid == propid ||
                 c_rgImagePropertyMap[i].imgPropidUnicode == propid))
            {
                *ppid = c_rgImagePropertyMap[i].propid;
                *pbUnicode = (c_rgImagePropertyMap[i].imgPropidUnicode == propid);
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

HRESULT GetImageFrameCount(Image *pImage, PROPVARIANT *ppv)
{
    HRESULT hr = S_FALSE;
    LONG lCount;
    lCount = 1; //Default to 1 image
    UINT uiDim = pImage->GetFrameDimensionsCount();
    ppv->vt = VT_EMPTY;
    if (uiDim)
    {
        GUID *pDim = new GUID[uiDim];
        if (pDim)
        {
            if (Ok == pImage->GetFrameDimensionsList(pDim, uiDim))
            {
                lCount = 0;
                ULONG uiN;
                for (ULONG i=0;i<uiDim;i++)
                {
                    uiN = pImage->GetFrameCount(&pDim[i]);
                    lCount += uiN;                                        
                }
                ppv->vt = VT_UI4;
                ppv->lVal = lCount;
                hr = S_OK;
            }
            delete [] pDim;
        }   
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CImagePropSet::_GetImageSummaryProps(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[])
{
    HRESULT hr = E_FAIL;
    if (_pimg)
    {
        hr = S_OK;
        for (ULONG i = 0; i < cpspec; i++)
        {
            PropVariantInit(&rgvar[i]);
            rgvar[i].vt = VT_UI4;
            switch (rgpspec[i].propid)
            {
            case PIDISI_CX:
                rgvar[i].ulVal = _pimg->GetWidth();
                break;
            case PIDISI_CY:
                rgvar[i].ulVal = _pimg->GetHeight();
                break;
            case PIDISI_RESOLUTIONX:
                rgvar[i].ulVal = (ULONG)_pimg->GetHorizontalResolution();
                break;
            case PIDISI_RESOLUTIONY:
                rgvar[i].ulVal = (ULONG)_pimg->GetVerticalResolution();
                break;
            case PIDISI_BITDEPTH:
                {
                    PixelFormat pf = _pimg->GetPixelFormat();
                    rgvar[i].ulVal = (pf >> 8) & 0xff;
                }
                break;
            case PIDISI_FRAMECOUNT:
                hr = GetImageFrameCount(_pimg, &rgvar[i]);
                break;

            case PIDISI_DIMENSIONS:
            {
                TCHAR szFmt[64];                
                if (LoadString(_Module.GetModuleInstance(), IDS_DIMENSIONS_FMT, szFmt, ARRAYSIZE(szFmt)))
                {
                    DWORD_PTR args[2];
                    args[0] = (DWORD_PTR)_pimg->GetWidth();
                    args[1] = (DWORD_PTR)_pimg->GetHeight();

                    TCHAR szBuffer[64];
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   szFmt, 0, 0, szBuffer, ARRAYSIZE(szBuffer), (va_list*)args);

                    hr = SHStrDup(szBuffer, &rgvar[i].pwszVal);
                    if (SUCCEEDED(hr))
                        rgvar[i].vt = VT_LPWSTR;
                    else
                        rgvar[i].vt = VT_EMPTY;
                }
                break;
            }

            default:
                rgvar[i].vt = VT_EMPTY;
                hr = S_FALSE;
                break;
            }
        }
    }
    return hr;
}


STDMETHODIMP CPropEnum::Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG uRet = 0;
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    for (;_idx < _nStat && uRet < celt;_idx++)
    {
        rgelt[uRet] = _pStat[_idx];
        uRet++;        
    }
    if (uRet < celt)
    {
        hr = S_FALSE;
    }
    if (pceltFetched)
    {
        *pceltFetched = uRet;
    }
    return hr;
}

STDMETHODIMP CPropEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    ULONG ul = min(_idx+celt, _nStat);
    if (ul - _idx < celt)
    {
        hr = S_FALSE;
    }
    _idx = ul;
    return hr;
}

STDMETHODIMP CPropEnum::Reset(void)
{
    _idx = 0;
    return S_OK;
}

STDMETHODIMP CPropEnum::Clone(IEnumSTATPROPSTG **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CPropEnum *pNew = new CPropEnum(_pStat, _nStat);
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenum));
        pNew->Release();
    }
    return hr;
}

STDMETHODIMP CPropEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CPropEnum, IEnumSTATPROPSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CPropEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CPropEnum::CPropEnum(const STATPROPSTG *pStats, ULONG nStats) : _idx(0), _cRef(1), _pStat(pStats), _nStat(nStats)
{
    _Module.Lock();
}

CPropEnum::~CPropEnum()
{
    _Module.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\photoverb.cpp ===
#include "precomp.h"
#include "shimgvw.h"
#include "cowsite.h"
#include "prevwnd.h"
#include "shutil.h"
#include "prwiziid.h"
#pragma hdrstop

// Context menu offset IDs
enum
{
    OFFSET_OPEN        = 0,
    OFFSET_PRINTTO,
    OFFSET_ROT90,
    OFFSET_ROT270,
    OFFSET_SETWALL,
    OFFSET_ZOOMIN,
    OFFSET_ZOOMOUT,
    OFFSET_ACTUALSIZE,
    OFFSET_BESTFIT,
    OFFSET_NEXTPAGE,
    OFFSET_PREVPAGE,
    OFFSET_MAX
};

#define PHOTOVERBS_THUMBNAIL    0x1
#define PHOTOVERBS_ICON         0x2
#define PHOTOVERBS_FILMSTRIP    0x3
#define PHOTOVERBS_SLIDESHOW    0x4
#define PHOTOVERBS_IMGPREVIEW   0x5


class CPhotoVerbs : public IContextMenu,
                    public IShellExtInit,
                    public IDropTarget,
                    public CObjectWithSite,
                    public NonATLObject
{
public:
    CPhotoVerbs();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, IDataObject *pdtobj, HKEY hKeyID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pCMI);
    STDMETHODIMP GetCommandString(UINT_PTR uID, UINT uFlags, UINT *res, LPSTR pName, UINT ccMax);

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CPhotoVerbs();
    void _RotatePictures(int iAngle, UINT idPrompt);
    void _OpenPictures();
    void _SetWallpaper();
//    HRESULT _InvokePrintToInPPW(LPCMINVOKECOMMANDINFO pCMI, IDataObject *pdtobj);
    BOOL _ImageOptionExists(IQueryAssociations *pqa, DWORD dwOption);
    HRESULT _QueryAssociations();
    DWORD _GetMode();
    BOOL _CheckForcePreview(IQueryAssociations *pqa);
    HRESULT _MapVerb(LPCMINVOKECOMMANDINFO pici, int *pidVerb);
    LONG _cRef;
    IDataObject *_pdtobj;
    BOOL  _fForcePreview;
    BOOL  _fAcceptPreview;
    BOOL  _fIncludeRotate;
    BOOL  _fIncludeSetWallpaper;
    IImgCmdTarget * _pict;              // if hosted in image preview, this allows us to delegate commands to it
    BOOL _fImgMode;                     // TRUE if we are hosted in defview and defview is in thumbnail or filmstip mode
    BOOL _fReadOnly;                    // TRUE if one or more items selected are SFGAO_READONLY

};

CPhotoVerbs::CPhotoVerbs() : _cRef(1)
{
    ASSERT(_pdtobj == NULL);
    ASSERT(_fForcePreview == FALSE);
    ASSERT(_fIncludeRotate == FALSE);
    ASSERT(_fIncludeSetWallpaper == FALSE);
}

CPhotoVerbs::~CPhotoVerbs()
{
    IUnknown_Set(&_punkSite, NULL);
    IUnknown_Set((IUnknown**)&_pdtobj, NULL);
    ATOMICRELEASE(_pict);
}

STDAPI CPhotoVerbs_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPhotoVerbs *psid = new CPhotoVerbs();
    if (!psid)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psid->Release();
    return hr;
}

STDMETHODIMP CPhotoVerbs::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPhotoVerbs, IShellExtInit),
        QITABENT(CPhotoVerbs, IContextMenu),
        QITABENT(CPhotoVerbs, IDropTarget),
        QITABENT(CPhotoVerbs, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPhotoVerbs::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPhotoVerbs::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// IShellExtInit

STDMETHODIMP CPhotoVerbs::Initialize(LPCITEMIDLIST pIDFolder, IDataObject *pdtobj, HKEY hKeyID)
{
    IUnknown_Set((IUnknown**)&_pdtobj, pdtobj);
    _fImgMode = FALSE;

    DWORD dwAttributes = 0;
    SHGetAttributesFromDataObject(pdtobj, SFGAO_READONLY, &dwAttributes, NULL);
    _fReadOnly  = BOOLIFY(dwAttributes);

    return S_OK;
}

BOOL CPhotoVerbs::_ImageOptionExists(IQueryAssociations *pqa, DWORD dwOption)
{
    BOOL fRetVal = FALSE;
    DWORD dwFlags = 0;
    DWORD cbFlags = sizeof(dwFlags);
    if (SUCCEEDED(pqa->GetData(0, ASSOCDATA_VALUE, TEXT("ImageOptionFlags"), &dwFlags, &cbFlags)))
    {
        fRetVal = (dwFlags & dwOption);
    }

    return fRetVal;
}

BOOL _VerbExists(IQueryAssociations *pqa, LPCTSTR pszVerb)
{
    DWORD cch;
    return SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, pszVerb, NULL, &cch)) && cch;
}

BOOL CPhotoVerbs::_CheckForcePreview(IQueryAssociations *pqa)
{
    //  we force if the app has no a preview and the user has not customized
    //  and we are not the current default (we install on open)
    BOOL fRet = FALSE;
    if (!_VerbExists(pqa, TEXT("preview")))
    {
        //  if nobody owns we always accept
        //  this is for when somebody does an InvokeCommand("preview");
        _fAcceptPreview = TRUE;
        if (S_FALSE == pqa->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL))
        {
            WCHAR sz[MAX_PATH];
            DWORD cch = ARRAYSIZE(sz);
            _fForcePreview = FAILED(pqa->GetString(0, ASSOCSTR_COMMAND, NULL, sz, &cch));
            if (!_fForcePreview)
            {
                //  there is a default handler
                //  if its us hide the preview verb
                //  because the static menu will do it for us
                if (StrStrIW(sz, L"shimgvw.dll"))
                {
                    _fAcceptPreview = FALSE;
                }
                else
                    _fForcePreview = TRUE;
            }
        }
    }

    return fRet;
}

HRESULT CPhotoVerbs::_QueryAssociations()
{
    IQueryAssociations *pqa;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_CtxQueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        //  dont do preview if the user has customized
         _CheckForcePreview(pqa);
        _fIncludeRotate       = _ImageOptionExists(pqa, IMAGEOPTION_CANROTATE);
        _fIncludeSetWallpaper = _ImageOptionExists(pqa, IMAGEOPTION_CANWALLPAPER);
        pqa->Release();
        return S_OK;
    }
    else
    {
        // we may have been invoked directly instead of via ShellExecute or right-click
        _fAcceptPreview = TRUE;
    }
    return S_FALSE;
}

DWORD CPhotoVerbs::_GetMode()
{
    DWORD dwMode, dw;
    if (_pict)
    {
        _pict->GetMode(&dw);
        switch (dw)
        {
        case SLIDESHOW_MODE:
            dwMode = PHOTOVERBS_SLIDESHOW;
            break;
        case WINDOW_MODE:
            dwMode = PHOTOVERBS_IMGPREVIEW;
            break;
        case CONTROL_MODE:
            dwMode = PHOTOVERBS_FILMSTRIP;
            break;
        default:
            dwMode = PHOTOVERBS_ICON;
            break;
        }
    }
    else
    {
        dwMode = (_fImgMode) ? PHOTOVERBS_THUMBNAIL : PHOTOVERBS_ICON;
    }

    return dwMode;
}

// IContextMenu
STDMETHODIMP CPhotoVerbs::QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags)
{
    TCHAR szBuffer[128];
    HRESULT hr = _QueryAssociations();

    DWORD dwMultiPage = MPCMD_HIDDEN;

    hr = IUnknown_QueryService(_punkSite, SID_SImageView, IID_PPV_ARG(IImgCmdTarget, &_pict));
    if (SUCCEEDED(hr))
    {
        _pict->GetPageFlags(&dwMultiPage);
    }

    IFolderView * pfv = NULL;
    hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        UINT uViewMode;
        hr = pfv->GetCurrentViewMode(&uViewMode);
        if (SUCCEEDED(hr) &&
           ((FVM_THUMBNAIL == uViewMode) || (FVM_THUMBSTRIP == uViewMode)))
        {
            _fImgMode = TRUE;
        }
        pfv->Release();
    }

    DWORD dwMode = _GetMode();
    // always load the Open verb if no static Open verb is registered
    if (_fAcceptPreview)
    {
        if (PHOTOVERBS_SLIDESHOW != dwMode && PHOTOVERBS_IMGPREVIEW != dwMode)
        {
            LoadString(_Module.GetModuleInstance(), IDS_PREVIEW_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_OPEN, szBuffer);

            //  only set to default if there isnt a preview already there
            if (_fForcePreview)
                SetMenuDefaultItem(hMenu, uIndex, MF_BYPOSITION);

            uIndex++;
        }
    }

    if (!(uFlags & CMF_DEFAULTONLY))
    {
        InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        if (_fIncludeRotate)
        {
            if (PHOTOVERBS_ICON != dwMode)
            {
                UINT uFlags = MF_BYPOSITION | MF_STRING;
                if (_fReadOnly && PHOTOVERBS_THUMBNAIL == dwMode)
                {
                    uFlags |= MF_GRAYED;
                }
                else
                {
                    uFlags |= MF_ENABLED; // in all modes by thumbnails, we allow temporary rotation of readonly images
                }

                LoadString(_Module.GetModuleInstance(), IDS_ROTATE90_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, uFlags, uIDFirst + OFFSET_ROT90, szBuffer);

                LoadString(_Module.GetModuleInstance(), IDS_ROTATE270_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, uFlags, uIDFirst + OFFSET_ROT270, szBuffer);
            }
        }

        if (PHOTOVERBS_IMGPREVIEW == dwMode)
        {
            LoadString(_Module.GetModuleInstance(), IDS_ZOOMIN_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_ZOOMIN, szBuffer);

            LoadString(_Module.GetModuleInstance(), IDS_ZOOMOUT_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_ZOOMOUT, szBuffer);

            if (dwMultiPage != MPCMD_HIDDEN && dwMultiPage != MPCMD_DISABLED)
            {
                if (MPCMD_LASTPAGE != dwMultiPage)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_NEXTPAGE_CTX, szBuffer, ARRAYSIZE(szBuffer));
                    InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_NEXTPAGE, szBuffer);
                }
                if (MPCMD_FIRSTPAGE != dwMultiPage)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_PREVPAGE_CTX, szBuffer, ARRAYSIZE(szBuffer));
                    InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_PREVPAGE, szBuffer);
                }
            }
        }
        InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

        if (_fIncludeSetWallpaper)
        {
            if (PHOTOVERBS_ICON != dwMode)
            {
                LoadString(_Module.GetModuleInstance(), IDS_WALLPAPER_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_SETWALL, szBuffer);
            }
        }

    }

    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, OFFSET_MAX);
}

// IDropTarget::DragEnter
HRESULT CPhotoVerbs::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CPhotoVerbs::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CPhotoVerbs::DragLeave(void)
{
    return S_OK;
}

// IDropTarget::DragDrop
HRESULT CPhotoVerbs::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    HRESULT hr = Initialize(NULL, pdtobj, NULL);
    if (SUCCEEDED(hr))
    {
        // we may need to get the verb.
        _OpenPictures();
    }
    return hr;
}

class VerbThreadProc : public NonATLObject
{
public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    BOOL CreateVerbThread();

    VerbThreadProc(IDataObject *pdo, IUnknown *punk, HRESULT *phr);

protected:
    virtual DWORD VerbWithThreadRefCB() PURE;
    virtual DWORD VerbWithThreadRef() PURE;
    virtual DWORD VerbWithoutThreadRefCB() PURE;
    virtual DWORD VerbWithoutThreadRef() PURE;

    virtual ~VerbThreadProc();

    IDataObject *_pdo;        // the un-marshalled versions...
    IFolderView *_pfv;

private:
    static DWORD s_WithThreadRef(void *pv);
    static DWORD s_WithThreadRefCB(void *pv);

    static DWORD s_WithoutThreadRef(void *pv);
    static DWORD s_WithoutThreadRefCB(void *pv);

    void Unmarshall();

    LONG _cRef;

    IStream *_pstmDataObj;    // the marshalled IDataObject stream
    IStream *_pstmFolderView; // the marshalled IFolderView stream
};

VerbThreadProc::VerbThreadProc(IDataObject* pdo, IUnknown *punk, HRESULT *phr)
{
    _cRef = 1;

    if (punk)
    {
        IFolderView *pfv = NULL;
        if (SUCCEEDED(IUnknown_QueryService(punk, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
        {
            CoMarshalInterThreadInterfaceInStream(IID_IFolderView, pfv, &_pstmFolderView);
            pfv->Release();
        }
    }

    if (pdo)
    {
        CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &_pstmDataObj);
    }

    *phr = (_pstmDataObj || _pstmFolderView) ? S_OK : E_OUTOFMEMORY;
}

VerbThreadProc::~VerbThreadProc()
{
    ATOMICRELEASE(_pstmDataObj);
    ATOMICRELEASE(_pstmFolderView);
    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pfv);
}

STDMETHODIMP_(ULONG) VerbThreadProc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) VerbThreadProc::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

DWORD VerbThreadProc::s_WithThreadRefCB(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    potd->AddRef();
    potd->Unmarshall();
    return potd->VerbWithThreadRefCB();
}

DWORD VerbThreadProc::s_WithThreadRef(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    DWORD dw = potd->VerbWithThreadRef();
    potd->Release();
    return dw;
}

DWORD VerbThreadProc::s_WithoutThreadRefCB(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    potd->AddRef();
    potd->Unmarshall();
    return potd->VerbWithoutThreadRefCB();
}

DWORD VerbThreadProc::s_WithoutThreadRef(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    DWORD dw =  potd->VerbWithoutThreadRef();
    potd->Release();
    return dw;
}

void VerbThreadProc::Unmarshall()
{
    if (_pstmDataObj)
    {
        CoGetInterfaceAndReleaseStream(_pstmDataObj, IID_PPV_ARG(IDataObject, &_pdo));
        _pstmDataObj = NULL;
    }

    if (_pstmFolderView)
    {
        CoGetInterfaceAndReleaseStream(_pstmFolderView, IID_PPV_ARG(IFolderView, &_pfv));
        _pstmFolderView = NULL;
    }
}

BOOL VerbThreadProc::CreateVerbThread()
{
    BOOL bRet;

    // The thread ref is the more efficient start-up method, but we need to
    // handle the case where the caller doesn't have one.
    bRet = SHCreateThread(s_WithThreadRef, this, CTF_COINIT | CTF_THREAD_REF, s_WithThreadRefCB);
    if (!bRet)
    {
        bRet = SHCreateThread(s_WithoutThreadRef, this, CTF_COINIT | CTF_WAIT_ALLOWCOM, s_WithoutThreadRefCB);
    }

    return bRet;
}

class OpenThreadProc : public VerbThreadProc
{
public:
    DWORD VerbWithThreadRefCB();
    DWORD VerbWithThreadRef();
    DWORD VerbWithoutThreadRefCB();
    DWORD VerbWithoutThreadRef();

    OpenThreadProc(IDataObject *pdo, IUnknown *punk, HRESULT *phr) : VerbThreadProc(pdo, punk, phr) {};

private:
    HRESULT Walk();
    void Preview();

    CPreviewWnd* _pPreview;
};

DWORD OpenThreadProc::VerbWithThreadRefCB()
{
    return 0;
}

DWORD OpenThreadProc::VerbWithThreadRef()
{
    HRESULT hr = Walk();
    SHReleaseThreadRef();
    if (S_OK == hr)
    {
        Preview();
    }
    return 0;
}

DWORD OpenThreadProc::VerbWithoutThreadRefCB()
{
    Walk();
    return 0;
}

DWORD OpenThreadProc::VerbWithoutThreadRef()
{
    Preview();
    return 0;
}

HRESULT OpenThreadProc::Walk()
{
    HRESULT hr = E_OUTOFMEMORY;

    if (_pdo)
    {
        _pPreview = new CPreviewWnd();
        if (_pPreview)
        {
            if (!_pPreview->TryWindowReuse(_pdo))
            {
                hr = _pPreview->Initialize(NULL, WINDOW_MODE, FALSE);
                if (SUCCEEDED(hr))
                {
                    // create the viewer window before doing the expensive namespace walk
                    // so if a second instance is created it will find the window                   
                    if (_pPreview->CreateViewerWindow())
                    {                       
                        hr = _pPreview->WalkItemsToPreview(_pfv ? (IUnknown *)_pfv: (IUnknown *)_pdo);
                        if (_pfv && FAILED(hr))
                        {
                            hr = _pPreview->WalkItemsToPreview((IUnknown *)_pdo);
                        }
                    }
                    else
                    {
                        DWORD dw = GetLastError();
                        hr = HRESULT_FROM_WIN32(dw);
                    }
                }               
            }
            else
            {
                hr = S_FALSE;
            }                       
        }
        // We're done with these
        ATOMICRELEASE(_pdo);
        ATOMICRELEASE(_pfv);
    }

    return hr;
}

void OpenThreadProc::Preview()
{
    if (_pPreview)
    {   
        // viewer window should have been created by now
        _pPreview->PreviewItems();
        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0) > 0)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
           
        delete _pPreview;
        _pPreview = NULL;
    }
}

void CPhotoVerbs::_OpenPictures()
{
    if (_pdtobj)
    {
        HRESULT hr;
        OpenThreadProc *potd = new OpenThreadProc(_pdtobj, _punkSite, &hr);
        if (potd)
        {
            if (SUCCEEDED(hr))
            {
                potd->CreateVerbThread();
            }
            potd->Release();
        }       
    }
}

// implement the rotate verb, this is a lengthy operation so put it onto a background
// thread if we can, marshall the IDataObject and let it do its thing...
class CRotateThreadProc : public VerbThreadProc
{
public:
    DWORD VerbWithThreadRefCB() { return 0; }
    DWORD VerbWithThreadRef() { return _Rotate(); }
    DWORD VerbWithoutThreadRefCB() { return _Rotate(); }
    DWORD VerbWithoutThreadRef() { return 0; }

    CRotateThreadProc(IDataObject* pdo, int iAngle, UINT idPrompt, HRESULT *phr);

private:
    DWORD _Rotate();

    int  _iAngle;
    UINT _idPrompt;
};

CRotateThreadProc::CRotateThreadProc(IDataObject* pdo, int iAngle, UINT idPrompt, HRESULT *phr) :
    VerbThreadProc(pdo, NULL, phr)
{
    _iAngle = iAngle;
    _idPrompt = idPrompt;
}

DWORD CRotateThreadProc::_Rotate()
{
    FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};

    if (_pdo)
    {
        HRESULT hr = _pdo->GetData(&fmt, &medium);
        if (SUCCEEDED(hr))
        {
            IProgressDialog *ppd;

            hr = CoCreateInstance(CLSID_ProgressDialog,  NULL, CLSCTX_INPROC, IID_PPV_ARG(IProgressDialog, &ppd));
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH];
                TCHAR szFile[MAX_PATH];
                HDROP hd = (HDROP)medium.hGlobal;
                UINT cItems = DragQueryFile(hd, (UINT)-1, NULL, 0);

                // prime the progress dialog

                if (cItems > 1)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);

                    LoadString(_Module.GetModuleInstance(), _idPrompt, szBuffer, ARRAYSIZE(szBuffer));
                    ppd->SetTitle(T2W(szBuffer));

                    ppd->SetAnimation(_Module.GetModuleInstance(), IDA_ROTATEAVI);
                    ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL);
                    ppd->SetProgress(1, cItems);
                }

                // lets get GDI+, the encoder array and start messing with the bits.   this is a
                // sync operation so check for the user cancelling the UI accordingly.

                IShellImageDataFactory *pif;
                hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellImageDataFactory, &pif));
                if (SUCCEEDED(hr))
                {
                    for (UINT i = 0; (i != cItems) && !((cItems > 1) ? ppd->HasUserCancelled() : FALSE); i++)
                    {
                        if (DragQueryFile(hd, i, szFile, ARRAYSIZE(szFile)))
                        {
                            if (cItems > 1)
                            {
                                ppd->SetLine(2, T2W(szFile), TRUE, NULL);
                                ppd->SetProgress(i+1, cItems);
                            }

                            // construct an image object from the file, rotate it and save it back

                            IShellImageData *pid;
                            hr = pif->CreateImageFromFile(szFile, &pid);
                            if (SUCCEEDED(hr))
                            {
                                hr = pid->Decode(SHIMGDEC_DEFAULT,0,0);
                                if (SUCCEEDED(hr))
                                {
                                    if (!((cItems > 1) ? ppd->HasUserCancelled() : FALSE))
                                    {
                                        GUID guidFormat;
                                        SIZE sz;
                                        if ( SUCCEEDED(pid->GetRawDataFormat(&guidFormat)) &&
                                             SUCCEEDED(pid->GetSize(&sz)))
                                        {
                                            if (S_OK == pid->IsEditable())
                                            {
                                                hr = S_OK;
                                                if (::IsEqualGUID(ImageFormatJPEG, guidFormat))
                                                {
                                                    if ((sz.cx % 16) || (sz.cy % 16))
                                                    {
                                                        if (cItems > 1)
                                                        {
                                                            LoadString(_Module.GetModuleInstance(), IDS_ROTATEDLGTITLE, szBuffer, ARRAYSIZE(szBuffer));
                                                            ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                                        }

                                                        TCHAR szTitle[MAX_PATH];
                                                        TCHAR szText[1024];

                                                        LoadString(_Module.GetModuleInstance(), IDS_ROTATE_LOSS, szText, ARRAYSIZE(szText));
                                                        LoadString(_Module.GetModuleInstance(), IDS_ROTATE_CAPTION, szTitle, ARRAYSIZE(szTitle));

                                                        // Set default to return IDOK so we know if the user selected something or
                                                        // if the "don't show me this again" bit was respected
                                                        int nResult = SHMessageBoxCheck(NULL, szText, szTitle,
                                                                                        MB_YESNO|MB_ICONWARNING, IDOK, REGSTR_LOSSYROTATE);
                                                        
                                                                                                                
                                                        CRegKey Key;
                                                        if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                                                        {
                                                            Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                                                        }

                                                        if (Key.m_hKey != NULL)
                                                        {
                                                            if (nResult == IDOK) // If hidden, then load last result from registry
                                                            {
                                                                DWORD dwResult = 0;
                                                                Key.QueryValue(dwResult, REGSTR_LOSSYROTATE);
                                                                nResult = (int)dwResult;
                                                            }
                                                            else // Otherwise, write this as last result to registry
                                                            {
                                                                DWORD dwResult = (DWORD)nResult;
                                                                Key.SetValue(dwResult, REGSTR_LOSSYROTATE);
                                                            }
                                                        }

                                                        if (nResult == IDNO)                
                                                            hr = S_FALSE; // User said No, Don't make any other noise.

                                                        if (cItems > 1)
                                                        {
                                                            LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                                                            ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                                        }
                                                    }
                                                }

                                                if (hr == S_OK)
                                                {
                                                    CAnnotationSet Annotations;
                                                    Annotations.SetImageData(pid);

                                                    INT_PTR nCount = Annotations.GetCount();
                                                    for (INT_PTR ix = 0; ix < nCount; ix++)
                                                    {
                                                        CAnnotation* pAnnotation = Annotations.GetAnnotation(ix);
                                                        pAnnotation->Rotate(sz.cy, sz.cx, (_iAngle == 90));
                                                    }
                                                    Annotations.CommitAnnotations(pid);

                                                    hr = pid->Rotate(_iAngle);
                                                    if (SUCCEEDED(hr))
                                                    {
                                                        IPersistFile *ppf;
                                                        hr = pid->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                                                        if (SUCCEEDED(hr))
                                                        {
                                                            hr = ppf->Save(NULL, TRUE);
                                                            ppf->Release();
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                // Animated GIFs are not editable even though
                                                // normal GIFs are.  This can cause a lot of
                                                // confusion, so provide some feedback if the
                                                // user tries to rotate an animated image.
                                                if (S_OK == pid->IsAnimated())
                                                {
                                                    // Make some noise.
                                                    ShellMessageBox(_Module.GetModuleInstance(), NULL, MAKEINTRESOURCE(IDS_ROTATE_MESSAGE), MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szFile);

                                                    // Don't make any other noise.
                                                    hr = S_FALSE;
                                                }// we can't safely rotate images with > 8 bits per channel either; we'd lose the extra bits
                                                else if (S_OK != pid->IsEditable())
                                                {
                                                    ShellMessageBox(_Module.GetModuleInstance(), NULL, MAKEINTRESOURCE(IDS_ROTATE_MESSAGE_EXT), MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szFile);

                                                    // Don't make any other noise.
                                                    hr = S_FALSE;
                                                }
                                            }
                                        }
                                    }
                                }

                                pid->Release();
                            }
                            if (FAILED(hr))
                            {
                                if (cItems > 1)
                                {
                                    LoadString(_Module.GetModuleInstance(), IDS_ROTATEDLGTITLE, szBuffer, ARRAYSIZE(szBuffer));
                                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                }

                                ShellMessageBox(_Module.GetModuleInstance(), NULL, MAKEINTRESOURCE(IDS_ROTATE_ERROR), MAKEINTRESOURCE(IDS_ROTATE_CAPTION), MB_OK|MB_ICONERROR);

                                if (cItems > 1)
                                {
                                    LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                }
                            }
                        }
                    }
                    pif->Release();
                }

                if (cItems > 1)
                {
                    ppd->StopProgressDialog();
                }
                // Since we always create it, we must always Release it.
                ppd->Release();
            }
            ReleaseStgMedium(&medium);
        }
    }

    return 0;
}

void CPhotoVerbs::_RotatePictures(int iAngle, UINT idPrompt)
{
    if (_pict)
    {
        _pict->Rotate(iAngle);
    }
    else if (_pdtobj)
    {
        HRESULT hr;
        CRotateThreadProc *potd = new CRotateThreadProc(_pdtobj, iAngle, idPrompt, &hr);
        if (potd)
        {
            if (SUCCEEDED(hr))
            {
                potd->CreateVerbThread();
            }
            potd->Release();
        }
    }
}


DWORD CALLBACK _WallpaperThreadProc(void *pv)
{
    IStream *pstm = (IStream*)pv;
    IDataObject *pdtobj;
    HRESULT hr = CoGetInterfaceAndReleaseStream(pstm, IID_PPV_ARG(IDataObject, &pdtobj));
    if (SUCCEEDED(hr))
    {
        FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};

        hr = pdtobj->GetData(&fmt, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            HDROP hd = (HDROP)medium.hGlobal;

            if (DragQueryFile(hd, 0, szPath, ARRAYSIZE(szPath))) // only set the first one selected as the background
            {
                SetWallpaperHelper(szPath);
            }

            ReleaseStgMedium(&medium);
        }
        pdtobj->Release();
    }
    return 0;
}

void CPhotoVerbs::_SetWallpaper()
{
    if (_pdtobj)
    {
        IStream *pstm;
        if (FAILED(CoMarshalInterThreadInterfaceInStream(IID_IDataObject, _pdtobj, &pstm)) ||
            !SHCreateThread(_WallpaperThreadProc, pstm, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(pstm);
        }
    }
}

HRESULT _InvokePrintToInPPW(LPCMINVOKECOMMANDINFO pCMI,IDataObject * pdtobj)
{
    HRESULT hr = E_FAIL;
    HMODULE hDll = LoadLibrary( TEXT("photowiz.dll") );
    if (hDll)
    {
        LPFNPPWPRINTTO pfnPrintTo = (LPFNPPWPRINTTO)GetProcAddress( hDll, PHOTO_PRINT_WIZARD_PRINTTO_ENTRY );
        if (pfnPrintTo)
        {
            hr = pfnPrintTo( pCMI, pdtobj );
        }

        FreeLibrary( hDll );
    }

    return hr;
}

const struct
{
    LPCSTR pszVerb;
    int idVerb;
}
c_szVerbs[] =
{
    { "preview", OFFSET_OPEN},
    { "printto", OFFSET_PRINTTO},
    { "rotate90", OFFSET_ROT90},
    { "rotate270", OFFSET_ROT270},
};

HRESULT CPhotoVerbs::_MapVerb(LPCMINVOKECOMMANDINFO pici, int *pidVerb)
{
    HRESULT hr = S_OK;
    if (IS_INTRESOURCE(pici->lpVerb))
    {
        *pidVerb = LOWORD(pici->lpVerb);
    }
    else
    {
        hr = E_INVALIDARG;
        for (int i = 0; i < ARRAYSIZE(c_szVerbs); i++)
        {
            if (0 == lstrcmpiA(pici->lpVerb, c_szVerbs[i].pszVerb))
            {
                hr = S_OK;
                *pidVerb = c_szVerbs[i].idVerb;
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPhotoVerbs::InvokeCommand(LPCMINVOKECOMMANDINFO pCMI)
{
    int idVerb;
    HRESULT hr = _MapVerb(pCMI, &idVerb);
    if (SUCCEEDED(hr))
    {
        switch (idVerb)
        {
        case OFFSET_OPEN:
            if (_fAcceptPreview)
                _OpenPictures();
            else
                hr = E_FAIL;
            break;

        case OFFSET_PRINTTO:
            hr = _InvokePrintToInPPW(pCMI,_pdtobj);
            break;

        case OFFSET_ROT90:
            _RotatePictures(90, IDS_ROTATE90);
            break;

        case OFFSET_ROT270:
            _RotatePictures(270, IDS_ROTATE270);
            break;

        case OFFSET_ZOOMIN:
            if (_pict)
            {
                _pict->ZoomIn();
            }
            break;

        case OFFSET_ZOOMOUT:
            if (_pict)
            {
                _pict->ZoomOut();
            }
            break;

        case OFFSET_ACTUALSIZE:
            if (_pict)
            {
                _pict->ActualSize();
            }
            break;

        case OFFSET_BESTFIT:
            if (_pict)
            {
                _pict->BestFit();
            }
            break;

        case OFFSET_NEXTPAGE:
            if (_pict)
            {
                _pict->NextPage();
            }
            break;

        case OFFSET_PREVPAGE:
            if (_pict)
            {
                _pict->PreviousPage();
            }
            break;

        case OFFSET_SETWALL:
            _SetWallpaper();
            break;

       default:
            hr = E_INVALIDARG;
            break;
        }
    }

    return hr;
}

STDMETHODIMP CPhotoVerbs::GetCommandString(UINT_PTR uID, UINT uFlags, UINT *res, LPSTR pName, UINT cchMax)
{
    HRESULT hr = S_OK;
    UINT idSel = (UINT)uID;

    switch (uFlags)
    {
    case GCS_VERBW:
    case GCS_VERBA:
        if (idSel < ARRAYSIZE(c_szVerbs))
        {
            if (uFlags == GCS_VERBW)
            {
                SHAnsiToUnicode(c_szVerbs[idSel].pszVerb, (LPWSTR)pName, cchMax);
            }
            else
            {
                StrCpyNA(pName, c_szVerbs[idSel].pszVerb, cchMax);
            }
        }
        break;

    case GCS_HELPTEXTW:
        LoadStringW(_Module.GetResourceInstance(), idSel+IDH_HELP_FIRST, (LPWSTR)pName, cchMax);
        break;

    case GCS_HELPTEXTA:
        LoadStringA(_Module.GetResourceInstance(), idSel+IDH_HELP_FIRST, (LPSTR)pName, cchMax);
        break;

    case GCS_VALIDATEA:
    case GCS_VALIDATEW:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


void WINAPI ImageView_Fullscreen(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = SHCoInitialize();  // suppress OLE1 DDE window
    if (SUCCEEDED(hr))
    {
        OleInitialize(NULL);    // needed to get drag and drop to work

        IDataObject *pdtobj;
        hr = GetUIObjectFromPath(pszCmdLine, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            // this scope is required to make sure cwndPreview gets destroyed before we call SHCoUninitialize  
            // the preview wnd will init GDI+ too
            CPreviewWnd cwndPreview;
            if (!cwndPreview.TryWindowReuse(pszCmdLine))
            {               
                if (SUCCEEDED(cwndPreview.Initialize(NULL, WINDOW_MODE, FALSE)) && cwndPreview.CreateViewerWindow())
                {
                    cwndPreview.PreviewItemsFromUnk(pdtobj);

                    MSG msg;
                    while (GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pdtobj->Release();
        }

        OleUninitialize();
    }

    SHCoUninitialize(hr);
}

void WINAPI ImageView_FullscreenA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH*2];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    ImageView_Fullscreen(hwnd, hAppInstance, szCmdLine, nCmdShow);
}

void WINAPI ImageView_FullscreenW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_Fullscreen(hwnd, hAppInstance, pszCmdLine, nCmdShow);
}

// To work around ACDSEE lower cases the shell command stuff causing us to need this
// export an all lowercase version of this function.  The short is, case matters for RunDLL32 exports.
void WINAPI imageview_fullscreenW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_FullscreenW(hwnd, hAppInstance, pszCmdLine, nCmdShow);
}

LPTSTR ParseCmdLine( LPTSTR pInput, LPTSTR pOutput, BOOL bStripQuotes )
{
    // copies the next token on the line to pOutput and returns
    // the first white space character after the processed token

    if (!pInput || (!*pInput) || !pOutput)
    {
        return pInput;
    }

    // first, skip any leading whitespace
    while (*pInput == TEXT(' '))
    {
        pInput++;
    }

    if (!(*pInput))
    {
        return pInput;
    }

    // next, start copying token

    // if the token starts with a
    // quote, note that and copy it
    BOOL bStartedWithQuote = FALSE;
    if (*pInput == TEXT('\"'))
    {
        bStartedWithQuote = TRUE;
        if (bStripQuotes)
        {
            pInput++;
        }
        else
        {
            *pOutput++ = *pInput++;
        }
    }

    // figure out what to stop on
    TCHAR cStopChar;
    if (bStartedWithQuote)
    {
        cStopChar = TEXT('\"');
    }
    else
    {
        cStopChar = TEXT(' ');
    }

    // copy up to the delimeter
    while( *pInput && (*pInput != cStopChar))
    {
        *pOutput++ = *pInput++;
    }

    // if the delimeter was a quote
    // we need to copy it into the output
    if (bStartedWithQuote && (*pInput == TEXT('\"')))
    {
        if (bStripQuotes)
        {
            pInput++;
        }
        else
        {
            *pOutput++ = *pInput++;
        }
    }

    *pOutput = 0;

    return pInput;

}


void WINAPI ImageView_PrintTo(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    // The command line comes to us like this (everything inside the <>):
    // </pt filename printer_name>

    TCHAR szFileName[ 1024 ];
    TCHAR szPrinterName[ 1024 ];

    LPTSTR psz = pszCmdLine;
    if (*psz == TEXT('/'))
    {
        // skip the "/pt"
        psz = ParseCmdLine( psz, szFileName, TRUE );
    }

    // Get the filename
    psz = ParseCmdLine( psz, szFileName, TRUE );

    // Get the printer name
    psz = ParseCmdLine( psz, szPrinterName, TRUE );


    // create a dataobject for the file in question, and then call
    // into photowiz to print it out...

    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        IDataObject *pdtobj;
        HRESULT hr = GetUIObjectFromPath(szFileName, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            // Create CMINVOKECAMMANDINFO to pass to photowiz
            CMINVOKECOMMANDINFOEX cmi = {0};
            cmi.cbSize = sizeof(cmi);
            cmi.fMask         = CMIC_MASK_UNICODE;
            cmi.lpVerbW       = L"printto";
            cmi.lpParametersW = szPrinterName;

            hr = _InvokePrintToInPPW((LPCMINVOKECOMMANDINFO )&cmi, pdtobj);
            pdtobj->Release();
        }
    }
    SHCoUninitialize(hrInit);
}

void WINAPI ImageView_PrintToA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[1024];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    ImageView_PrintTo(hwnd, hAppInstance, szCmdLine, nCmdShow);
}

void WINAPI ImageView_PrintToW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_PrintTo( hwnd, hAppInstance, pszCmdLine, nCmdShow );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\prevctrl.h ===
// PrevCtrl.h : Declaration of the CPreview

#ifndef __PREVCTRL_H_
#define __PREVCTRL_H_

#include "resource.h"       // main symbols
#include "PrevWnd.h"
#include "Events.h"

int IsVK_TABCycler(MSG *pMsg);

/////////////////////////////////////////////////////////////////////////////
// CPreview
class ATL_NO_VTABLE CPreview :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CPreview, &CLSID_Preview>,
        public CComControl<CPreview>,
        public CStockPropImpl<CPreview, IPreview2, &IID_IPreview2, &LIBID_PREVIEWLib>,
        public CStockPropImpl<CPreview, IPreview3, &IID_IPreview3, &LIBID_PREVIEWLib>,
        public IProvideClassInfo2Impl<&CLSID_Preview, NULL, &LIBID_PREVIEWLib>,
        public IPersistPropertyBagImpl<CPreview>,           // So we can read <PARAM>'s from our object tag
        public IPersistStorageImpl<CPreview>,               // required for Embeddable objects
        public IOleObjectImpl<CPreview>,                    // required for Embeddable objects
        public IDataObjectImpl<CPreview>,                   // required for Embeddable objects
        public IQuickActivateImpl<CPreview>,
        public IOleControlImpl<CPreview>,   // REVIEW: will IOleControl::GetControlInfo help with my keyboard problems?
        public IOleInPlaceActiveObjectImpl<CPreview>,       // handles resizing, active state, TranslateAccelerator
        public IViewObjectExImpl<CPreview>,                 // for flicker-free drawing support
        public IOleInPlaceObjectWindowlessImpl<CPreview>,   // allow for windowless operation (we don't use windowless, should we be using this interface?)
        public CPreviewEvents<CPreview>,                    // our event code for sending events to our container
        public IConnectionPointContainerImpl<CPreview>,     // Connection Point Container for our outgoing event hooks.
        public IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,// allows this control to be scripted
        public IPersistStreamInitImpl<CPreview>,
        public IObjectWithSiteImpl<CPreview>
{
private:

    DWORD _dwConnectionCookie;
    IFolderView *_pfv;

public:
    CPreviewWnd m_cwndPreview;

    CPreview()
    {
        // we want to be run in a window and never windowless
        m_bWindowOnly = TRUE;
        m_cwndPreview.Initialize(NULL, CONTROL_MODE, FALSE); // ISSUE: we don't handle failure of initialization in low-memory case
    }

    ~CPreview()
    {
        ATOMICRELEASE(_pfv);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PREVIEW)

DECLARE_WND_CLASS( TEXT("ShImgVw:CPreview") );

BEGIN_COM_MAP(CPreview)
    COM_INTERFACE_ENTRY(IPreview2)
    COM_INTERFACE_ENTRY(IPreview3)
    COM_INTERFACE_ENTRY_IID(IID_IDispatch, IPreview2)
    COM_INTERFACE_ENTRY_IID(IID_IPreview, IPreview2)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CPreview)
    CONNECTION_POINT_ENTRY(DIID_DPreviewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CPreview)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CPreview)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
END_MSG_MAP()

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    // IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)( LPMSG lpmsg );
    STDMETHOD(OnFrameWindowActivate)( BOOL fActive );

    // IPersistPropertyBag
    STDMETHOD(Load)(IPropertyBag * pPropBag, IErrorLog * pErrorLog);
    STDMETHOD(Save)(IPropertyBag * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) {return S_OK;}

    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwSupportedOptions, DWORD dwEnabledOptions);

    // IPersistStreamInit
    STDMETHOD(Load)(IStream * pStm);
    STDMETHOD(Save)(IStream * pStm, BOOL fClearDirty) {return S_OK;}

    // IOleObject
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // IDispatch
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, 
                        VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

public:
    // Control message handlers
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    // IPreview, IPreview3
    STDMETHOD(get_printable)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_printable)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_cxImage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_cyImage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(ShowFile)(BSTR bstrFileName, int iSelectCount);
    STDMETHOD(Show)(VARIANT var);

    // IPreview2, IPreview3
    STDMETHOD(Zoom)(/*[in]*/ int iSelectCount);
    STDMETHOD(BestFit)();
    STDMETHOD(ActualSize)();
    STDMETHOD(SlideShow)();

    // IPreview3
    STDMETHOD(Rotate)(/*[in]*/ DWORD dwAngle);
    STDMETHOD(SaveAs)(/*[in]*/BSTR bstrPath);
    STDMETHOD(SetWallpaper)(/*[in]*/BSTR bstrWallpaper);
    STDMETHOD(ShowFile)(BSTR bstrFileName);

private:
    BOOL IsHostLocalZone(DWORD dwFlags, HRESULT *phr);
    STDMETHOD(_ProcessSelection) (void);
};

#endif //__PREVCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\prevctrl.cpp ===
#include "precomp.h"
#include <shimgvw.h>
#include "PrevCtrl.h"
#include "autosecurity.h"
#include <dispex.h>
#pragma hdrstop

LRESULT CPreview::OnCreate(UINT , WPARAM , LPARAM , BOOL&)
{
    ATLTRACE(_T("CPreview::OnCreate\n"));

    // Create the preview window
    RECT rcWnd;
    GetClientRect(&rcWnd);
    if (m_cwndPreview.Create(m_hWnd, rcWnd, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0))
    {
        m_cwndPreview.SetNotify(this);

        HPALETTE hpal;
        if (SUCCEEDED(GetAmbientPalette(hpal)))
            m_cwndPreview.SetPalette(hpal);

        return 0;
    }

    return -1;
}

LRESULT CPreview::OnActivate(UINT , WPARAM , LPARAM , BOOL& bHandled)
{
    ATLTRACE(_T("CPreview::OnActivate\n"));
    m_cwndPreview.SetFocus();
    bHandled = false;
    return 0;
}

HRESULT CPreview::OnDrawAdvanced(ATL_DRAWINFO&)
{
    ATLTRACE(_T("CPreview::OnDrawAdvanced\n"));
    return S_OK;
}

LRESULT CPreview::OnEraseBkgnd(UINT , WPARAM , LPARAM , BOOL&)
{
    ATLTRACE(_T("CPreview::OnEraseBkgnd\n"));
    return TRUE;
}

LRESULT CPreview::OnSize(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    ATLTRACE(_T("CPreview::OnSize\n"));
    ::SetWindowPos(m_cwndPreview.m_hWnd, NULL, 0,0,
        LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE);
    return 0;
}

// IObjectSafety::GetInterfaceSafetyOptions
//
// This method never gets called.  We are safe for any and every thing.  There should
// be no possible way that this control could lose, destroy, or expose data.
STDMETHODIMP CPreview::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions,
                                                  DWORD *pdwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
    HRESULT hr;
    hr = IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>::GetInterfaceSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    if (SUCCEEDED(hr))
    {
        IsHostLocalZone(CAS_REG_VALIDATION, &hr);
    }
    return hr;
}

STDMETHODIMP CPreview::SetInterfaceSafetyOptions(REFIID riid, DWORD dwSupportedOptions,
                                                  DWORD dwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
    HRESULT hr;
    hr = IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>::SetInterfaceSafetyOptions(riid, dwSupportedOptions, dwEnabledOptions);
    if (SUCCEEDED(hr))
    {
        IsHostLocalZone(CAS_REG_VALIDATION, &hr);
    }
    return hr;
}

// IPersistPropertyBag::Load
//
// We have the following properties that we can load from the property bag:
//      Toolbar         false/zero = don't show the toolbar, otherwise show the toolbar
//      Full Screen     false/zero = don't show fullscreen button on toolbar, otherwise show the button
//      Context Menu    false/zero = don't show context menu, otherwise show the context menu when the user right clicks
//      Print Button    false/zero = don't show print button on toolbar, otherwise show the button
STDMETHODIMP CPreview::Load(IPropertyBag * pPropBag, IErrorLog * pErrorLog)
{
    HRESULT hr;
    VARIANT var;
    BOOL bDummy = TRUE;

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Toolbar", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_TOOLBAR,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Full Screen", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_FULLSCREENBTN,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Print Button", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_PRINTBTN,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Context Menu", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_CONTEXTMENU,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = FALSE;
    hr = pPropBag->Read(L"Allow Online", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_ALLOWGOONLINE,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = FALSE;
    hr = pPropBag->Read(L"Disable Edit", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_DISABLEEDIT,var.ulVal,bDummy);
    }

    return S_OK;
}

// If we are initialized via IStream, read a DWORD from the stream that is a mask
// for which toolbar buttons to show

STDMETHODIMP CPreview::Load(IStream *pStream)
{
    DWORD dwFlags = 0;
    ULONG ulRead = 0;
    BOOL bDummy = TRUE;
    if (SUCCEEDED(pStream->Read(&dwFlags, sizeof(dwFlags), &ulRead)) && ulRead == sizeof(dwFlags))
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_TOOLBAR,dwFlags & PVTB_TOOLBAR, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_FULLSCREENBTN,dwFlags & PVTB_HIDEFULLSCREEN, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_PRINTBTN,dwFlags & PVTB_HIDEPRINTBTN, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_CONTEXTMENU,dwFlags & PVTB_CONTEXTMENU, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_ALLOWGOONLINE,dwFlags & PVTB_ALLOWONLINE, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_DISABLEEDIT,dwFlags & PVTB_DISABLEEDIT, bDummy);
    }
    return S_OK;

}

// IPreview Methods:
STDMETHODIMP CPreview::ShowFile(BSTR bstrFileName)
{
    m_cwndPreview.ShowFile(bstrFileName, 1);
    return S_OK;
}

STDMETHODIMP CPreview::ShowFile(BSTR bstrFileName, int iSelectCount)
{
    m_cwndPreview.ShowFile(bstrFileName, iSelectCount);
    return S_OK;
}

STDMETHODIMP CPreview::Show(VARIANT var)
{
    HRESULT hr;
    switch (var.vt)
    {
    case VT_UNKNOWN:
    case VT_DISPATCH:
        // QI for Folder Item
        if (var.punkVal)
        {
            FolderItems *pfis;
            FolderItem *pfi;
            hr = var.punkVal->QueryInterface(IID_PPV_ARG(FolderItem, &pfi));
            if (SUCCEEDED(hr))
            {
                // If the item is a link we want to get the link's target:
                VARIANT_BOOL vbool;
                hr = pfi->get_IsLink(&vbool);
                if (SUCCEEDED(hr) && (VARIANT_FALSE != vbool))    // IsLink returns TRUE, not VARIANT_TRUE
                {
                    IDispatch *pdisp;
                    hr = pfi->get_GetLink(&pdisp);
                    if (SUCCEEDED(hr) && pdisp)
                    {
                        IShellLinkDual2 * psl2;
                        hr = pdisp->QueryInterface(IID_PPV_ARG(IShellLinkDual2, &psl2));
                        if (SUCCEEDED(hr) && psl2)
                        {
                            FolderItem * pfiTarg;
                            hr = psl2->get_Target(&pfiTarg);
                            if (SUCCEEDED(hr) && pfiTarg)
                            {
                                pfi->Release();
                                pfi = pfiTarg;
                            }
                            psl2->Release();
                        }
                        pdisp->Release();
                    }
                }

                // Now we need to know the path for this item.  We can only view items if
                // we can get a path or URL to the target so some namespaces aren't viewable.
                BSTR bstr;
                hr = pfi->get_Path(&bstr);
                if (SUCCEEDED(hr))
                {
                    m_cwndPreview.ShowFile(bstr, 1);
                    SysFreeString(bstr);
                    hr = S_OK;
                }
                else
                {
                    // we couldn't get the path so we will display the "No Preview" message
                    m_cwndPreview.ShowFile(NULL, 1);
                    hr = S_FALSE;
                }

                // now release the Folder Item pointer
                pfi->Release();

                return hr;
            }
            else if (SUCCEEDED(var.punkVal->QueryInterface(IID_PPV_ARG(FolderItems, &pfis))))
            {
                // currently in the multi-select case we just show the multi-select message.
                // eventually this should go to slideshow mode
                m_cwndPreview.ShowFile(NULL, 2);
                pfis->Release();
                return S_FALSE;
            }
        }
        // the unknown pointer isn't for an object type that we know about
        return E_INVALIDARG;

    case VT_BSTR:
        m_cwndPreview.ShowFile(var.bstrVal, 1);
        break;

    case VT_BOOL:
        // show(false) will hide the currently previewed item
        if (VARIANT_FALSE == var.boolVal)
        {
            m_cwndPreview.ShowFile(NULL, 0);
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }

    default:
        return E_INVALIDARG;
    }

    return S_OK;
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//  cloned from browseui/util.cpp
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

#if 0 // todo?
    return (GetAsyncKeyState(VK_SHIFT) < 0) ? -1 : 1;
#endif
    return 1;
}

//***
// NOTES
//  hard-coded 1/2/4 (vs. KEYMOD_*) is same thing atlctl.h does.  go figure...
DWORD GetGrfMods()
{
    DWORD dwMods;

    dwMods = 0;
    if (GetAsyncKeyState(VK_SHIFT) < 0)
        dwMods |= 1;    // KEYMOD_SHIFT
    if (GetAsyncKeyState(VK_CONTROL) < 0)
        dwMods |= 2;    // KEYMOD_CONTROL
    if (GetAsyncKeyState(VK_MENU) < 0)
        dwMods |= 4;    // KEYMOD_MENU
    return dwMods;
}

STDMETHODIMP CPreview::TranslateAccelerator(LPMSG lpmsg)
{
    ATLTRACE(_T("CPreview::TranslateAccelerator\n"));

    if (m_cwndPreview.TranslateAccelerator(lpmsg))
    {
        return S_OK;
    }

    if (IsVK_TABCycler(lpmsg))
    {
        // REVIEW: looks like newer versions of ATL might do this for us so
        // possibly we can replace w/ call to SUPER::TA when we upgrade.
        CComQIPtr <IOleControlSite, &IID_IOleControlSite> spOCS(m_spClientSite);
        if (spOCS) {
            return spOCS->TranslateAccelerator(lpmsg, GetGrfMods());
        }
    }

    return S_FALSE;
}

STDMETHODIMP CPreview::OnFrameWindowActivate(BOOL fActive)
{
    if (fActive)
    {
        m_cwndPreview.SetFocus();
    }
    return S_OK;
}

LRESULT CPreview::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ATLTRACE(_T("CPreview::OnSetFocus\n"));
 
    LRESULT ret = CComControl<CPreview>::OnSetFocus(uMsg,wParam,lParam, bHandled);
    m_cwndPreview.SetFocus();
    return ret;
}

STDMETHODIMP CPreview::get_printable(BOOL * pVal)
{
    // If we don't trust the host, we tell them it is always printable because we don't
    // want them to be able to see if the file exists on the disk.  Hackers can use
    // this to determine where the OS is installed and which apps are installed.
    *pVal = TRUE;

    if (IsHostLocalZone(CAS_REG_VALIDATION, NULL))
    {
        *pVal = m_cwndPreview.GetPrintable();
    }

    return S_OK;
}

STDMETHODIMP CPreview::put_printable(BOOL newVal)
{
    return S_FALSE;
}

STDMETHODIMP CPreview::get_cxImage(long * pVal)
{
    // REVIEW: Return an error and set output to zero if no image is currently displayed?
    *pVal = m_cwndPreview.m_ctlPreview.m_cxImage;

    return S_OK;
}

STDMETHODIMP CPreview::get_cyImage(long * pVal)
{
    // REVIEW: Return an error and set output to zero if no image is currently displayed?
    *pVal = m_cwndPreview.m_ctlPreview.m_cyImage;

    return S_OK;
}

STDMETHODIMP CPreview::Zoom(int iDirection)
{
    
    switch (iDirection)
    {
    case -1:
        m_cwndPreview.ZoomOut();
        break;

    case 0:
        return S_OK;

    case 1:
        m_cwndPreview.ZoomIn();
        break;

    default:
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CPreview::BestFit()
{
    m_cwndPreview.BestFit();
    return S_OK;
}

STDMETHODIMP CPreview::ActualSize()
{
    m_cwndPreview.ActualSize();
    return S_OK;
}

STDMETHODIMP CPreview::SlideShow()
{
    HRESULT hr = m_cwndPreview.StartSlideShow(NULL);
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CPreview::Rotate(DWORD dwAngle)
{
    HRESULT hr = m_cwndPreview.Rotate(dwAngle);
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CPreview::SetClientSite(IOleClientSite *pClientSite)
{
    IOleObjectImpl<CPreview>::SetClientSite(pClientSite);
    m_cwndPreview.SetSite(pClientSite);

    return S_OK;
}

STDMETHODIMP CPreview::SetSite(IUnknown* punkSite)
{
    IObjectWithSiteImpl<CPreview>::SetSite(punkSite);
    m_cwndPreview.SetSite(punkSite);

    if (punkSite)
    {
        if (!_pfv)
        {
            IShellView *psv;
            if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_PPV_ARG(IShellView, &psv))))
            {
                IDispatch *pdisp;
                if (SUCCEEDED(psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pdisp))))
                {
                    ConnectToConnectionPoint(SAFECAST(this, IPreview2 *), DIID_DShellFolderViewEvents, TRUE, pdisp, &_dwConnectionCookie, NULL);
                    _ProcessSelection();
                    pdisp->Release();
                }

                psv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));   // capture this

                psv->Release();
            }
        }
    }
    else
    {
        ATOMICRELEASE(_pfv);    // break ref cycle
    }
    
    return S_OK;
}

STDMETHODIMP CPreview::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, 
                        VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    HRESULT hr = S_OK;

    if (dispidMember == DISPID_FOCUSCHANGED)
    {
        hr = _ProcessSelection();
    }
    else
    {
        hr = CStockPropImpl<CPreview, IPreview2, &IID_IPreview2, &LIBID_PREVIEWLib>::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }

    return hr;
}

STDMETHODIMP CPreview::SetWallpaper(BSTR bstrPath)
{    
    return m_cwndPreview.SetWallpaper(bstrPath);
}

STDMETHODIMP CPreview::SaveAs(BSTR bstrPath)
{
    return m_cwndPreview.SaveAs(bstrPath);
}

BOOL CPreview::IsHostLocalZone(DWORD dwFlags, HRESULT * phr)
{
    HRESULT hr = E_ACCESSDENIED;
    CComPtr<IDefViewSafety> spDefViewSafety;
    if (SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_SFolderView,
            IID_PPV_ARG(IDefViewSafety, &spDefViewSafety))))
    {
        hr = spDefViewSafety->IsSafePage();
    }

    if (phr)
    {
        *phr = hr;
    }

    return (S_OK == hr) ? TRUE : FALSE;
}

STDMETHODIMP CPreview::_ProcessSelection(void)
{
    if (_pfv)
    {
        int iItem;
        if (S_OK == _pfv->GetFocusedItem(&iItem))
        {
            LPITEMIDLIST pidlFile;
            if (SUCCEEDED(_pfv->Item(iItem, &pidlFile)))
            {
                IShellFolder *psf;
                if (SUCCEEDED(_pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf))))
                {
                    TCHAR szPath[MAX_PATH];

                    if (SUCCEEDED(DisplayNameOf(psf, pidlFile, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
                    {
                        ShowFile(szPath, 1);
                    }

                    psf->Release();
                }

                ILFree(pidlFile);
            }
        }
        else
        {
            ShowFile(NULL, 0);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\prevwnd.h ===
#ifndef __PREVIEWWND_H_
#define __PREVIEWWND_H_

#include "resource.h"       // main symbols
#include "annotlib.h"
#include "tasks.h"
#include "ZoomWnd.h"
#include "SelTrack.h"
#include "Events.h"


// forward declaration
class CPreview;

#define NEWTOOLBAR_TOPMARGIN        8
#define NEWTOOLBAR_BOTTOMMARGIN     8
#define NEWTOOLBAR_BOTTOMMARGIN_CTRLMODE    12

#define TIMER_ANIMATION        42
#define TIMER_SLIDESHOW        43
#define TIMER_TOOLBAR          44
#define TIMER_DATAOBJECT       45
#define TIMER_BUSYCURSOR       46
#define TIMER_RESETSCREENSAVER 47

#define DEFAULT_SHIMGVW_TIMEOUT  5000 // five seconds


// IV_SCROLL message parameters
#define IVS_LEFT        (SB_LEFT)
#define IVS_RIGHT       (SB_RIGHT)
#define IVS_LINELEFT    (SB_LINELEFT)
#define IVS_LINERIGHT   (SB_LINERIGHT)
#define IVS_PAGELEFT    (SB_PAGELEFT)
#define IVS_PAGERIGHT   (SB_PAGERIGHT)
#define IVS_UP          (SB_LEFT<<16)
#define IVS_DOWN        (SB_RIGHT<<16)
#define IVS_LINEUP      (SB_LINELEFT<<16)
#define IVS_LINEDOWN    (SB_LINERIGHT<<16)
#define IVS_PAGEUP      (SB_PAGELEFT<<16)
#define IVS_PAGEDOWN    (SB_PAGERIGHT<<16)

// IV_ZOOM messages
#define IVZ_CENTER  0
#define IVZ_POINT   1
#define IVZ_RECT    2
#define IVZ_ZOOMIN  0x00000000
#define IVZ_ZOOMOUT 0x00010000

// IV_SETOPTIONS and IV_GETOPTIONS messages
#define IVO_TOOLBAR         0
#define IVO_PRINTBTN        1
#define IVO_FULLSCREENBTN   2
#define IVO_CONTEXTMENU     3
#define IVO_PRINTABLE       4
#define IVO_ALLOWGOONLINE   5
#define IVO_DISABLEEDIT     6

// three modes of preview control
#define CONTROL_MODE        0       // embedded in an activeX control
#define WINDOW_MODE         1       // regular window app window
#define SLIDESHOW_MODE      2       // full screen, no menu/title/hides tray

// priority levels for the various tasks
#define PRIORITY_PRIMARYDECODE  0x40000000
#define PRIORITY_FRAMECACHE     0x30000000
#define PRIORITY_LOOKAHEADCACHE 0x20000000
#define PRIORITY_SLIDESHOWENUM  0x10000000

// these values determine which buttons are hidden, enabled, or disabled based on multi-page state
#define MPCMD_HIDDEN        0
#define MPCMD_FIRSTPAGE     1
#define MPCMD_MIDDLEPAGE    2
#define MPCMD_LASTPAGE      3
#define MPCMD_DISABLED      4

#define GTIDFM_DECODE       0
#define GTIDFM_DRAW         1

void GetTaskIDFromMode(DWORD dwTask, DWORD dwMode, TASKOWNERID *ptoid);

enum EViewerToolbarButtons;

class CPreviewWnd : public INamespaceWalkCB, public IDropTarget, public CWindowImpl<CPreviewWnd>,
                    public IServiceProvider, public IImgCmdTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IImgCmdTarget
    STDMETHODIMP GetMode(DWORD * pdw);
    STDMETHODIMP GetPageFlags(DWORD * pdw);
    STDMETHODIMP ZoomIn();
    STDMETHODIMP ZoomOut();
    STDMETHODIMP ActualSize();
    STDMETHODIMP BestFit();
    STDMETHODIMP Rotate(DWORD dwAngle);
    STDMETHODIMP NextPage();
    STDMETHODIMP PreviousPage();

    
    CGraphicsInit    m_cgi;  // we call gdi+ directly -- make sure GDI+ is ready for us 
    CContainedWindow m_ctlToolbar;
    CZoomWnd         m_ctlPreview;
    CContainedWindow m_ctlEdit;

    CPreviewWnd *m_pcwndSlideShow;

    CPreviewWnd();
    ~CPreviewWnd();

    HRESULT Initialize(CPreviewWnd* pother, DWORD dwMode, BOOL bExitApp);

    BOOL TryWindowReuse(IDataObject *pdtobj);
    BOOL TryWindowReuse(LPCTSTR pszFilename);

    void OpenFile(HWND hwnd, LPCTSTR pszFile);
    void OpenFileList(HWND hwnd, IDataObject *pdtobj);

    LRESULT ShowFile(LPCTSTR pszFile, UINT cItems, BOOL fReshow = false);
    HRESULT WalkItemsToPreview(IUnknown* punk);
    void PreviewItems();
    HRESULT PreviewItemsFromUnk(IUnknown *punk);

    BOOL CreateViewerWindow();
    BOOL CreateSlideshowWindow(UINT cWalkDepth);
    void SetNotify(CEvents * pEvents);
    void SetPalette(HPALETTE hpal);
    BOOL GetPrintable();
    int  TranslateAccelerator(LPMSG lpmsg);
    HRESULT SetSite(IUnknown *punk);
    HRESULT SaveAs(BSTR bstrPath);
    IUnknown *GetSite() {return m_punkSite;};
    HRESULT SetWallpaper(BSTR bstrPath);
    HRESULT StartSlideShow(IUnknown *punk);
    void StatusUpdate(int iStatus);   // used to set m_ctlPreview.m_iStrID to display correct status message
    void SetCaptionInfo(LPCTSTR szPath);

    // The following functions are called from the ZoomWnd
    BOOL OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnSetColor(HDC hdc);
    BOOL GetColor(COLORREF * pref);
    void OnDraw(HDC hdc); // called after the Zoomwnd has painted but before calling EndPaint
    void OnDrawComplete();

    DECLARE_WND_CLASS(TEXT("ShImgVw:CPreviewWnd"));

        
BEGIN_MSG_MAP(CPreviewWnd)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_APPCOMMAND, OnAppCommand)
    MESSAGE_HANDLER(WM_MEASUREITEM, OnMenuMessage);
    MESSAGE_HANDLER(WM_DRAWITEM, OnMenuMessage);
    MESSAGE_HANDLER(WM_INITMENUPOPUP, OnMenuMessage);
    COMMAND_RANGE_HANDLER(ID_FIRSTTOOLBARCMD, ID_LASTTOOLBARCMD, OnToolbarCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTEDITCMD, ID_LASTEDITCMD, OnEditCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTPOSITIONCMD, ID_LASTPOSITIONCMD, OnPositionCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTSLIDESHOWCMD, ID_LASTSLIDESHOWCMD, OnSlideshowCommand)
    NOTIFY_CODE_HANDLER(TTN_NEEDTEXT, OnNeedText)
    NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnDropDown)
    MESSAGE_HANDLER(WM_MOUSEWHEEL, OnWheelTurn)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(IV_SETIMAGEDATA, IV_OnSetImageData)
    MESSAGE_HANDLER(IV_SCROLL, IV_OnIVScroll)
    MESSAGE_HANDLER(IV_SETOPTIONS, IV_OnSetOptions)
    MESSAGE_HANDLER(WM_COPYDATA, OnCopyData)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyEvent)
    MESSAGE_HANDLER(WM_CHAR, OnKeyEvent)
    MESSAGE_HANDLER(WM_ENTERMENULOOP, OnKeyEvent)
    MESSAGE_HANDLER(WM_PRINTCLIENT, OnPrintClient)
    MESSAGE_HANDLER(IV_ONCHANGENOTIFY, OnChangeNotify)
    MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
    MESSAGE_HANDLER(IV_ISAVAILABLE, OnIsAvailable)
ALT_MSG_MAP(1)
    // messages for the toolbar
    MESSAGE_HANDLER(WM_KEYDOWN, OnTBKeyEvent)
    MESSAGE_HANDLER(WM_KEYUP, OnTBKeyEvent)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnTBMouseMove)
    MESSAGE_HANDLER(WM_MOUSELEAVE, OnTBMouseLeave)
ALT_MSG_MAP(2)
    MESSAGE_HANDLER(WM_KEYDOWN, OnEditKeyEvent)
END_MSG_MAP()

    LRESULT IV_OnSetOptions(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNeedText(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDropDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnToolbarCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnEditCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPositionCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSlideshowCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMenuMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCopyData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnChangeNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnIsAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL OnNonSlideShowTab();

    // Image generation message handlers and functions
    LRESULT IV_OnSetImageData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnShowFileMsg(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT IV_OnIVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Toolbar message handlers (both toolbars)
    LRESULT OnPrintClient(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Edit control message handlers
    LRESULT OnEditKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // DropDown handlers for the various dropdown buttons
    VOID _DropDownPageList(LPNMTOOLBAR pnmTB);

    BOOL         CreateToolbar();
    BOOL         _CreateViewerToolbar();
    void        _InitializeViewerToolbarButtons(HWND hwndToolbar, const TBBUTTON c_tbbuttons[], size_t c_nButtons, TBBUTTON tbbuttons[], size_t nButtons);
    inline UINT _IndexOfViewerToolbarButton(EViewerToolbarButtons eButton);
    BOOL        _CreateSlideshowToolbar();
    void        _InitializeToolbar(HWND hwndTB, int idLow, int idLowHot, int idHigh, int idHighHot);
    void        _UpdatePageNumber();
    void        _SetMultipageCommands();
    void        _SetMultiImagesCommands();
    void        _SetEditCommands();
    void        _ResetScreensaver();

    HRESULT _SaveAsCmd();
    void _PropertiesCmd();
    void _OpenCmd();
    BOOL _ReShowingSameFile(LPCTSTR pszFile);
    BOOL _VerbExists(LPCTSTR pszVerb);
    HRESULT _InvokeVerb(LPCTSTR pszVerb, LPCTSTR pszParameters=NULL);
    void _InvokePrintWizard();
//    void _InvokeVerbOnPidlArray(LPCSTR pszVerb);
    // Shared functions for Annotation and Cropping
    void _RefreshSelection(BOOL fDeselect = false);
    void _UpdateButtons(WORD wID);

    // Annotation Functions
    BOOL _CanAnnotate(CDecodeTask * pImageData);
    void _SetAnnotatingCommands(BOOL fEnableAnnotations);
    void _SetupAnnotatingTracker(CSelectionTracker& tracker, BOOL bEditing=FALSE);
    void _UpdateAnnotatingSelection(BOOL fDeselect = false);
    void _RemoveAnnotatingSelection();
    BOOL _OnMouseDownForAnnotating(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnMouseDownForAnnotatingHelper(CPoint ptMouse, CRect rectImage);
    void _CreateAnnotation(CRect rect);
    void _CreateFreeHandAnnotation(CPoint ptMouse);
    void _StartEditing(BOOL bUpdateText = TRUE);
    void _HideEditing();
    void _StopEditing();
    static BOOL_PTR CALLBACK _AnnoPropsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    //Cropping Functions
    BOOL _CanCrop(CDecodeTask * pImageData);
    void _SetCroppingCommands(BOOL fEnableCropping);
    void _SetupCroppingTracker(CSelectionTracker& tracker);
    void _UpdateCroppingSelection();
    BOOL _OnMouseDownForCropping(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Other functions
    void _SetNewImage(CDecodeTask * pImageData);
    void _UpdateImage();

    // Private methods to create the webviewer
    DWORD   _GetFilterStringForSave(LPTSTR szFilter, size_t cbFilter, LPTSTR szExt);
    HRESULT _SaveIfDirty(BOOL fCanCancel = false);
    HRESULT _PreviewFromStream(IStream * pSteam, UINT iItem, BOOL fUpdateCaption);
    HRESULT _PreviewFromFile(LPCTSTR pszFilename, UINT iItem, BOOL fUpdateCaption);
    void    FlushBitmapMessages();
    HRESULT _ShowNextSlide(BOOL bGoBack);
    HRESULT _StartDecode(UINT iIndex, BOOL fUpdateCaption);
    HRESULT _PreLoadItem(UINT iIndex);
    HRESULT _PreviewItem(UINT iIndex);
    BOOL    _TrySetImage();
    void    _RemoveFromArray(UINT iItem);
    HRESULT _DeleteCurrentSlide();
    BOOL    _CloseSlideshowWindow();

    void SetCursorState(DWORD dwType);
    void ShowSSToolbar(BOOL bShow, BOOL bForce = FALSE);
    void TogglePlayState();
    void _ClearDPA();
    HRESULT _GetItem(UINT iItem, LPITEMIDLIST *ppidl);
    HRESULT GetCurrentIDList(LPITEMIDLIST *ppidl); // gets the dynamically generated title for this window
    HRESULT PathFromImageData(LPTSTR pszFile, UINT cch);
    HRESULT ImageDataSave(LPCTSTR pszFile, BOOL bShowUI);
    void MenuPoint(LPARAM lParam, int *px, int *py);
    BOOL _IsImageFile(LPCTSTR pszFileName);
    BOOL _BuildDecoderList();
    HRESULT _PrevNextPage(BOOL fForward);
    Image *_BurnAnnotations(IShellImageData *pSID);
    void _RegisterForChangeNotify(BOOL fRegister);
    BOOL _ShouldDisplayAnimations();

    BOOL m_fHidePrintBtn;
    BOOL m_fAllowContextMenu;
    BOOL m_fDisableEdit;        // if true, editing is disabled, defaults to FALSE.
    BOOL m_fCanSave;
    BOOL m_fShowToolbar;
    BOOL m_fWarnQuietSave;
    BOOL m_fWarnNoSave;

    BOOL m_fCanAnnotate;        // if true, allows annotation, defaults to FALSE.
    BOOL m_fAnnotating;         // if true, we are in annotating mode, default to false
    HDPA m_hdpaSelectedAnnotations;
    BOOL m_fDirty;
    WORD m_wNewAnnotation;
    HFONT m_hFont;
    BOOL m_fEditingAnnotation;

    BOOL m_fCanCrop;
    BOOL m_fCropping;
    CRect m_rectCropping;       // Cropping Rectangle in Image Coordinates.

    BOOL    m_fBusy;            // we are displaying the hourglass-and-pointer cursor
    HCURSOR m_hCurOld;
    HCURSOR m_hCurrent;
    BOOL    m_fClosed;

    BOOL            m_fPrintable;
    BOOL            m_fExitApp;
    DWORD           m_dwMode;           // three modes: CONTROL_MODE, WINDOW_MODE, SLIDESHOW_MODE
    BOOL            m_fIgnoreUITimers;  // should we ignore timer messages (used when context menu is up, don't hide toolbar)
    HACCEL          m_haccel;

    CEvents *       m_pEvents;          // pointer to our parent control event object.  NULL if we aren't running as a control.

    LPITEMIDLIST*   m_ppidls;           // pidls of already shown items
    UINT            m_cItems;           // # of items in m_ppidls
    UINT            m_iCurSlide;        // index into m_ppidls

    CDecodeTask* m_pImageData;          // The image data for the decoded image to be viewed
    HDPA        m_hdpaItems;            // pidls of already shown items
    BOOL        m_fPaused;              // slide show paused
    BOOL        m_fToolbarHidden;       // toolbar hidden in slide show mode
    BOOL        m_fGoBack;              // direction of the slide show
    BOOL        m_fTBTrack;             // true if we're tracking mouse for toolbar
    BOOL        m_fWasEdited;           // true if we edited the image
    UINT        m_uTimeout;
    int         m_iSSToolbarSelect;     // selection in toolbar (used for keyboard support in Whistler)
    IUnknown*   m_punkSite;

    HPALETTE    m_hpal;                 // the palette to use if in palette mode.

    IShellImageDataFactory * m_pImageFactory;  // for decoding images

    DWORD       m_dwMultiPageMode;      // for remembering the state of the prev/next page commands

    EXECUTION_STATE m_esFlags;          // execution flags, stored to restore after we re-enable monitor's power saving mode
    HWND _hWndPageList;

    IContextMenu3 *_pcm3;

    IShellTaskScheduler * m_pTaskScheduler;     // for managing a worker thread
    CDecodeTask *         m_pNextImageData;
    UINT                  m_iDecodingNextImage;

    ImageCodecInfo *m_pici;
    UINT m_cDecoders;

    IDataObject *_pdtobj; // reused data object for passing data from oncopydata to ontimer
    BOOL m_fPromptingUser;

    BOOL m_fFirstTime;
    BOOL m_fFirstItem;

    DWORD m_dwEffect;
    BOOL  m_fIgnoreNextNotify;
    ULONG m_uRegister;
    BOOL  m_fNoRestore;
    BOOL  m_fIgnoreAllNotifies;

private:
    BOOL m_bRTLMirrored;    // true if m_hWnd is RTL mirrored
    UINT m_cWalkDepth;
};


#define REGSTR_SHIMGVW      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellImageView")
#define REGSTR_MAXIMIZED    TEXT("Maximize")
#define REGSTR_BOUNDS       TEXT("Bounds")
#define REGSTR_FONT         TEXT("Font")
#define REGSTR_BACKCOLOR    TEXT("BackColor")
#define REGSTR_LINECOLOR    TEXT("LineColor")
#define REGSTR_TEXTCOLOR    TEXT("TextColor")
#define REGSTR_LINEWIDTH    TEXT("LineWidth")
#define REGSTR_TIMEOUT      TEXT("Timeout")

#define REGSTR_DONTSHOWME   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain")
#define REGSTR_SAVELESS     TEXT("ShellImageViewWarnOnSavelessRotate")
#define REGSTR_LOSSYROTATE  TEXT("ShellImageViewWarnOnLossyRotate")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\resource.h ===
// Used by shimgvw.rc
//
#define IDI_FULLSCREEN                  1
#define IDI_BITMAPFILE                  2
#define IDI_GIFFILE                     3
#define IDI_JPEGFILE                    4
#define IDI_TIFFILE                     5
#define IDI_MAIL                        7

#define IDR_VIEWERHTML                  10
#define IDR_VIEWERHTML_NET              11

#define IDA_PREVWND_SINGLEPAGE          50
#define IDA_PREVWND_MULTIPAGE           51
#define IDR_PREVIEW                     52
#define IDR_PHOTOVERBS                  53
#define IDR_MKSLIDE                     54
#define IDA_FILECOPY                    55
#define IDR_SHIMGDATAFACTORY            56
#define IDR_RECOMPRESS                  57

#define IDB_TOOLBAR                     104
#define IDB_TOOLBARHIGH                 105
#define IDB_TOOLBAR_HOT                 106
#define IDB_TOOLBARHIGH_HOT             107

#define IDB_SLIDESHOWTOOLBAR            108
#define IDB_SLIDESHOWTOOLBARHIGH        109
#define IDB_SLIDESHOWTOOLBAR_HOT        110
#define IDB_SLIDESHOWTOOLBARHIGH_HOT    111

#define IDA_ROTATEAVI                   112

#define IDS_PROJNAME                    200
#define IDS_NOPREVIEW                   201
#define IDS_LOADFAILED                  202
#define IDS_MULTISELECT                 203
#define IDS_LOADING                     204
#define IDS_SETUPFAILED                 205
#define IDS_ROTATE90                    209
#define IDS_ROTATE270                   210
#define IDS_ROTATETITLE                 211
#define IDS_ROTATEDLGTITLE              212

#define IDS_SAVEWARNING_MSGBOX          216
#define IDS_NAMETOOLONG_MSGBOX          217
#define IDS_SAVEFAILED_MSGBOX           218
#define IDS_WIDTHBAD_MSGBOX             219
#define IDS_NEW_FILENAME                221
#define IDS_SAVEAS_TITLE                222
#define IDS_DRAWFAILED                  223
#define IDS_DRAWING                     224
#define IDS_SAVE_WARN_TIFF              225

#define IDS_UNKNOWNIMAGE                300
#define IDS_EMFIMAGE                    301
#define IDS_GIFIMAGE                    302
#define IDS_JPEGIMAGE                   303
#define IDS_BITMAPIMAGE                 304
#define IDS_PNGIMAGE                    305
#define IDS_TIFIMAGE                    306
#define IDS_WMFIMAGE                    307

#define IDS_DIMENSIONS_FMT              308

#define IDS_SUMMARY                     311

#define IDC_OPENHAND                    300
#define IDC_CLOSEDHAND                  301
#define IDC_ZOOMOUT                     302
#define IDC_ZOOMIN                      303

#define IDC_DONTASKAGAIN                320

#define IDD_COMPSETTINGS                353
#define IDD_ANNOPROPS                   354

#define IDC_WIDTHTEXT                   384
#define IDC_WIDTH                       385
#define IDC_SPIN                        386
#define IDC_TRANSPARENT                 387
#define IDC_FONT                        388
#define IDC_COLOR                       389

// Toolbar Commands
#define NOBUTTON                          0
#define ID_FIRSTTOOLBARCMD              400
#define ID_ZOOMINCMD                    400
#define ID_ZOOMOUTCMD                   401
#define ID_SELECTCMD                    402
#define ID_BESTFITCMD                   403
#define ID_ACTUALSIZECMD                404
#define ID_PREVPAGECMD                  406
#define ID_NEXTPAGECMD                  407
#define ID_SLIDESHOWCMD                 408
#define ID_FREEHANDCMD                  409
#define ID_HIGHLIGHTCMD                 410
#define ID_LINECMD                      411
#define ID_FRAMECMD                     412
#define ID_RECTCMD                      413
#define ID_TEXTCMD                      414
#define ID_NOTECMD                      415
#define ID_NEXTIMGCMD                   416
#define ID_PREVIMGCMD                   417
#define ID_PRINTCMD                     418
#define ID_PROPERTIESCMD                419
#define ID_SAVEASCMD                    420
#define ID_EDITCMD                      421
#define ID_CROPCMD                      422
#define ID_HELPCMD                      423
#define ID_DELETECMD                    424
#define ID_OPENCMD                      425
#define ID_LASTTOOLBARCMD               425

                                        
#define ID_PAGELIST                     421

#define IDS_PRINTCMD                    490 // alternate string for IDI_PRINTCMD
#define IDS_ROTATE90CMD                 491 // alternate string for IDI_ROTATE90CMD
#define IDS_ROTATE270CMD                492 // alternate string for IDI_ROTATE270CMD
#define IDS_DELETECMD                   493 // alternate string for ID_DELETECMD on context menu
#define IDS_PROPERTIESCMD               494 // alternate string for ID_PROPERTIESCMD on context menu

// Commands that cause Auto Save
#define ID_FIRSTEDITCMD                 500
#define ID_ROTATE90CMD                  500
#define ID_ROTATE270CMD                 501
#define ID_FLIPXCMD                     502
#define ID_FLIPYCMD                     503
#define ID_LASTEDITCMD                  503

#define ID_FIRSTPOSITIONCMD             550
#define ID_MOVELEFTCMD                  550
#define ID_MOVERIGHTCMD                 551
#define ID_MOVEUPCMD                    552
#define ID_MOVEDOWNCMD                  553
#define ID_NUDGELEFTCMD                 554
#define ID_NUDGERIGHTCMD                555
#define ID_NUDGEUPCMD                   556
#define ID_NUDGEDOWNCMD                 557
#define ID_LASTPOSITIONCMD              557

// Context Menu Verbs 
#define IDS_PREVIEW_CTX                 550
#define IDS_ZOOMIN_CTX                  551
#define IDS_ZOOMOUT_CTX                 552
#define IDS_ACTUALSIZE_CTX              553
#define IDS_BESTFIT_CTX                 554
#define IDS_NEXTPAGE_CTX                555
#define IDS_PREVPAGE_CTX                556
#define IDS_ROTATE90_CTX                557
#define IDS_ROTATE270_CTX               558
#define IDS_PRINT_CTX                   559
#define IDS_WALLPAPER_CTX               560


// Slideshow Mode Commands              
#define ID_FIRSTSLIDESHOWCMD            600
#define ID_PLAYCMD                      600
#define ID_PAUSECMD                     601
#define ID_PREVCMD                      602
#define ID_NEXTCMD                      603
#define ID_CLOSECMD                     604
#define ID_LASTSLIDESHOWCMD             605

#define IDS_THUMBNAIL_MSGBOX            650
#define IDS_THUMBNAIL_MSGBOXTITLE       651
#define IDS_THUMBNAIL_PROGRESSTEXT      652
#define IDS_COPYIMAGES_MSGBOX           653
#define IDS_COPYIMAGES_MSGBOXTITLE      654
#define IDS_COPYIMAGES_PROGRESSTEXT     655
#define IDS_THUMBNAIL_SUFFIX            656
#define IDS_RECOMPRESS_CAPTION          657

// These seperators get an ID so they can be hidden
#define ID_PAGECMDSEP                   700
#define ID_SLIDESHOWSEP                 701
#define ID_ANNOTATESEP                  702
#define ID_VIEWCMDSEP                   703
#define ID_ROTATESEP                    704

#define IDS_CHOOSE_DIR                  802

#define IDS_GDITHUMBEXTRACT_DESC        892
#define IDS_DOCTHUMBEXTRACT_DESC        893
#define IDS_HTMLTHUMBEXTRACT_DESC       894

#define IDC_PICSMALL                    920
#define IDC_PICMEDIUM                   921
#define IDC_PICLARGE                    922
#define IDC_QUALITYGOOD                 923
#define IDC_QUALITYMEDIUM               924
#define IDC_QUALITYLOW                  925
#define IDC_SAVE                        926

#define IDS_ROTATE_CAPTION              1000
#define IDS_ROTATE_LOSS                 1003
#define IDS_ROTATE_ERROR                1004
#define IDS_ROTATE_CANTSAVE             1005
#define IDS_RESET_MSGBOX                1006
#define IDS_ROTATE_MESSAGE              1007
#define IDS_ROTATE_MESSAGE_EXT          1008
#define IDC_STATIC                      -1

// help IDs must have the same offset from IDH_HELP_FIRST as the menu offsets in photoverb.cpp
#define IDH_HELP_FIRST                  1500
#define IDH_HELP_OPEN                   IDH_HELP_FIRST+0
#define IDH_HELP_PRINTTO                IDH_HELP_FIRST+1
#define IDH_HELP_ROT90                  IDH_HELP_FIRST+2
#define IDH_HELP_ROT270                 IDH_HELP_FIRST+3
#define IDH_HELP_SETWALL                IDH_HELP_FIRST+4
#define IDH_HELP_ZOOMIN                 IDH_HELP_FIRST+5
#define IDH_HELP_ZOOMOUT                IDH_HELP_FIRST+6
#define IDH_HELP_ACTUALSIZE             IDH_HELP_FIRST+7
#define IDH_HELP_BESTFIT                IDH_HELP_FIRST+8
#define IDH_HELP_NEXTPAGE               IDH_HELP_FIRST+9
#define IDH_HELP_PREVPAGE               IDH_HELP_FIRST+10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once
#define STRICT

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_UUIDOF
#define _ATL_NO_DEBUG_CRT

// we have to provide ATLASSERT(x) with no debug crt
// we don't use it, so make it do nothing
#define ATLASSERT(x)

#pragma warning(disable : 4100 4310)

#include <windows.h>
#include <shellapi.h>
#include <port32.h>
#include <commctrl.h>
#include <wininet.h>
#include <shlobj.h>
#include <hlink.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlguidp.h>
#include <shdispid.h>
#include <ieguidp.h>
#include <ccstock.h>
#include "cfdefs.h"
#include <comctrlp.h>
#include <dpa.h>
#include "resource.h"
#include <gdiplus.h>
using namespace Gdiplus;

#include "shimgdata.h"
#include <shfusion.h>   // needs to be before ATL.

#include <varutil.h>
#include <shdguid.h>
#include <debug.h>
#include <atlbase.h>

// needs to be defined before including atlcom.
extern CComModule _Module;
#include <atlcom.h>

#include <atlctl.h>
#include <atlwin.h>
#define _ATL_TMP_NO_CSTRING
#include <atltmp.h>
#include "guids.h"

#include <gdithumb.h>
#include <docfile.h>
#include <mshtmhst.h>
#include <html.h>
#include <extmsg.h>

#include <runtask.h>

#pragma warning(default : 4100 4310)

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

#define MIN(x,y)        ((x<y)?x:y)
#define MAX(x,y)        ((x>y)?x:y)

#define SWAPLONG(a, b)  { LONG t; t = a; a = b; b = t; }

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

STDAPI CImageData_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CImageDataFactory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CPhotoVerbs_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CAutoplayForSlideShow_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CImgRecompress_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CGraphicsInit
{    
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        _token = 0;        
        GdiplusStartupInput gsi;            
        GdiplusStartup(&_token, &gsi, NULL);        
    };
    ~CGraphicsInit()
    {
        if (_token != 0)
        {
            GdiplusShutdown(_token);
        }           
    };
};

// All non-ATL COM objects must derive from this class so the
// DLL object reference count stays correct -- this ensures that
// DllCanUnloadNow returns the correct value.

class NonATLObject
{
public:
    NonATLObject() { _Module.Lock(); }
    ~NonATLObject() { _Module.Unlock(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\recompress.cpp ===
#include "precomp.h"
#include "prevwnd.h"
#pragma hdrstop
#include "strsafe.h"


// class which implements IRecompress

class CImgRecompress : public IImageRecompress, public NonATLObject
{
public:
    CImgRecompress();
    ~CImgRecompress();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IImageRecompress
    STDMETHODIMP RecompressImage(IShellItem *psi, int cx, int cy, int iQuality, IStorage *pstg, IStream **ppstrmOut);
       
protected:
    LONG _cRef;                             // object lifetime

    IShellItem *_psi;                       // current shell item
    IShellImageDataFactory *_psidf;  

    HRESULT _FindEncoder(IShellItem *psi, IShellImageData *psid, IStorage *pstg, IStream **ppstrmOut, BOOL *pfChangeFmt, GUID *pDataFormat);
    HRESULT _InitRecompress(IShellItem *psi, IStream **ppstrm, STATSTG *pstatIn);
    HRESULT _SaveImage(IShellImageData *psid, int cx, int cy, int iQuality, GUID *pRawDataFmt, IStream *pstrm);
};


// Recompress interface
CImgRecompress::CImgRecompress() :
    _cRef(1), _psidf(NULL)
{
    _Module.Lock();
}

CImgRecompress::~CImgRecompress()
{
    ATOMICRELEASE(_psidf);
    _Module.Unlock();
}

STDMETHODIMP CImgRecompress::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImgRecompress, IImageRecompress),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImgRecompress::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImgRecompress::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CImgRecompress::_InitRecompress(IShellItem *psi, IStream **ppstrm, STATSTG *pstatIn)
{
    HRESULT hr = S_OK;

    if (!_psidf)
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &_psidf));

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(STGM_READ | STGM_SHARE_DENY_NONE, &pbc);
        if (SUCCEEDED(hr))
        {
            IStream *pstrm;
            hr = psi->BindToHandler(pbc, BHID_Stream, IID_PPV_ARG(IStream, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = pstrm->Stat(pstatIn, STATFLAG_NONAME);
                if (SUCCEEDED(hr))
                {
                    hr = pstrm->QueryInterface(IID_PPV_ARG(IStream, ppstrm));
                }
                pstrm->Release();
            }
            pbc->Release();
        }
    }

    return hr;
}


HRESULT CImgRecompress::RecompressImage(IShellItem *psi, int cx, int cy, int iQuality, IStorage *pstg, IStream **ppstrmOut)
{
    STATSTG statIn;
    IStream *pstrm;

    HRESULT hr = S_FALSE;
    if (SUCCEEDED(_InitRecompress(psi, &pstrm, &statIn)))
    {
        IShellImageData * psid;
        if (SUCCEEDED(_psidf->CreateImageFromStream(pstrm, &psid)))
        {
            // we need to decode the image before we can read its header - unfortunately
            if (SUCCEEDED(psid->Decode(SHIMGDEC_DEFAULT, 0, 0)))
            {
                BOOL fRecompress = FALSE;
                GUID guidDataFormat;
                if (S_OK == _FindEncoder(psi, psid, pstg, ppstrmOut, &fRecompress, &guidDataFormat))
                {
                    int cxOut = 0, cyOut = 0;

                    // lets compute to see if we need to recompress the image, we do this by
                    // looking at its size compared ot the size the caller has given us,
                    // we also compare based on the larger axis to ensure we keep aspect ratio.

                    SIZE szImage;
                    if (SUCCEEDED(psid->GetSize(&szImage)))
                    {
                        // If the image is too big scale it down to screen size (use large axis for threshold check)
                        if (szImage.cx > szImage.cy)
                        {
                            cxOut = min(szImage.cx, cx);
                            fRecompress |= szImage.cx > cx;
                        }
                        else
                        {
                            cyOut = min(szImage.cy, cy);
                            fRecompress |= szImage.cy > cy;
                        }
                    }

                    // if fRecompress then we generate the new stream, if the new stream is not 
                    // smaller than the current image that we started with then lets
                    // ignore it (always better to send the smaller of the two).
                    //

                    if (fRecompress)
                    {
                        hr = _SaveImage(psid, cxOut, cyOut, iQuality, &guidDataFormat, *ppstrmOut);
                    }

                    if (hr == S_OK)
                    {
                        (*ppstrmOut)->Commit(0);        // commit our changes to the stream

                        LARGE_INTEGER li0 = {0};        // seek to the head of the file so reading gives us bits
                        (*ppstrmOut)->Seek(li0, 0, NULL);
                    }
                    else if (*ppstrmOut)
                    {
                        (*ppstrmOut)->Release();
                        *ppstrmOut = NULL;
                    }
                }
            }
            psid->Release();
        }
        pstrm->Release();
    }
    return hr;
}


HRESULT CImgRecompress::_SaveImage(IShellImageData *psid, int cx, int cy, int iQuality, GUID *pRawDataFmt, IStream *pstrm)
{
    HRESULT hr = S_OK;

    // Scale the image
    if (cx || cy)
    {
        hr = psid->Scale(cx, cy, InterpolationModeHighQuality);
    }

    // Make a property bag containing the encoder parameters and set it (if we are changing format)
    if (SUCCEEDED(hr) && pRawDataFmt)
    {
        IPropertyBag *pbagEnc;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbagEnc));
        if (SUCCEEDED(hr))
        {
            // write the encoder CLSID into the property bag
            VARIANT var;
            hr = InitVariantFromGUID(&var, *pRawDataFmt);
            if (SUCCEEDED(hr))
            {
                hr = pbagEnc->Write(SHIMGKEY_RAWFORMAT, &var);
                VariantClear(&var);
            }

            // write the quality value for the recompression into the property bag
            if (SUCCEEDED(hr))
                hr = SHPropertyBag_WriteInt(pbagEnc, SHIMGKEY_QUALITY, iQuality);

            // pass the parameters over to the encoder
            if (SUCCEEDED(hr))
                hr = psid->SetEncoderParams(pbagEnc);

            pbagEnc->Release();
        }
    }

    // Now persist the file away
    if (SUCCEEDED(hr))
    {
        IPersistStream *ppsImg;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistStream, &ppsImg));
        if (SUCCEEDED(hr))
        {
            hr = ppsImg->Save(pstrm, TRUE);
            ppsImg->Release();
        }
    }

    return hr;
}


HRESULT CImgRecompress::_FindEncoder(IShellItem *psi, IShellImageData *psid, IStorage *pstg, IStream **ppstrmOut, BOOL *pfChangeFmt, GUID *pDataFormat)
{
    GUID guidDataFormat;
    BOOL fChangeExt = FALSE;

    // read the relative name from the stream so that we can create a temporary one which maps
    LPWSTR pwszName;
    HRESULT hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &pwszName);
    if (SUCCEEDED(hr))
    {
        // get the data format from the image we are decompressing
        hr = psid->GetRawDataFormat(&guidDataFormat);
        if (SUCCEEDED(hr))
        {
            if (!IsEqualGUID(guidDataFormat, ImageFormatJPEG))
            {
                // ask the image about it's properties
                if ((S_FALSE == psid->IsMultipage()) &&
                    (S_FALSE == psid->IsVector()) &&
                    (S_FALSE == psid->IsTransparent()) &&
                    (S_FALSE == psid->IsAnimated()))
                {
                    guidDataFormat = ImageFormatJPEG;
                    fChangeExt = TRUE;
                }
                else
                {
                    hr = S_FALSE;                       // can't be translated
                }
            }

            // update the name accordingly before making a stream
            WCHAR szOutName[MAX_PATH];
            hr = StringCchCopyW(szOutName, ARRAYSIZE(szOutName), pwszName);
            if (SUCCEEDED(hr))
            {
                if (fChangeExt)
                {
                    PathRenameExtension(szOutName, TEXT(".jpg"));
                }

    // TODO: need to get FILE_FLAG_DELETE_ON_CLOSE to happen on CreateFile
                hr = StgMakeUniqueName(pstg, szOutName, IID_PPV_ARG(IStream, ppstrmOut));
            }
        }

        CoTaskMemFree(pwszName);
    }

    if (pfChangeFmt) 
        *pfChangeFmt = fChangeExt;

    *pDataFormat = guidDataFormat;

    return hr;
}


STDAPI CImgRecompress_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CImgRecompress *pr = new CImgRecompress();
    if (!pr)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pr->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pr->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\prevwnd.cpp ===
#include "precomp.h"
#include "PrevWnd.h"
#include "PrevCtrl.h"
#include "resource.h"
#include <shimgdata.h>
#include "shutil.h"
#include "tasks.h"
#include <shellp.h>
#include <ccstock2.h>
#include <htmlhelp.h>

#include "prwiziid.h"
#pragma hdrstop

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#define COPYDATATYPE_DATAOBJECT       1
#define COPYDATATYPE_FILENAME         2

int g_x = 0, g_y = 0; // mouse coordinates
BOOL g_bMirroredOS = FALSE;


#define HTMLHELP_FILENAME   TEXT("ImgPrev.chm")

static COLORREF g_crCustomColors[] = {
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255)
};

static void _RotateRect(CRect &rect, CAnnotation* pAnnotation)
{
    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    CTextAnnotation* pTextAnnotation = (CTextAnnotation*)pAnnotation;

    int nOrientation = pTextAnnotation->GetOrientation();
    if (nOrientation == 900 || nOrientation == 2700)
    {
        int nWidth = rect.Width();
        int nHeight = rect.Height();
        rect.right = rect.left + nHeight;
        rect.bottom = rect.top + nWidth;
    }
}

CPreviewWnd::CPreviewWnd() : m_ctlToolbar(NULL, this, 1), m_ctlPreview(this), m_ctlEdit(NULL, this, 2)
{
    // we are often created on the stack, so we can't be sure that we're zero initialized

    m_fCanCrop = FALSE;
    m_fCropping = FALSE;
    m_rectCropping.SetRectEmpty();

    m_fBusy = FALSE;
    m_hCurOld = NULL;
    m_hCurrent = NULL;
    m_fWarnQuietSave = TRUE;
    m_fWarnNoSave = TRUE;
    m_fPromptingUser = FALSE;
    m_fCanAnnotate = FALSE;
    m_fAnnotating = FALSE;
    m_fEditingAnnotation = FALSE;
    m_fDirty = FALSE;
    m_pEvents = 0;
    m_fPaused = FALSE;
    m_fGoBack = FALSE;
    m_fHidePrintBtn = FALSE;
    m_fPrintable = FALSE;
    m_fDisableEdit = FALSE;
    m_fCanSave = TRUE;
    m_fExitApp = FALSE;

    m_fAllowContextMenu = TRUE;     // full screen window always has a context menu
    m_iCurSlide = -1;

    m_iDecodingNextImage = -1;
    m_pNextImageData = NULL;

    m_fToolbarHidden = TRUE;
    m_dwMultiPageMode = MPCMD_HIDDEN;
    m_fIgnoreUITimers = FALSE;

    DWORD cbSize = sizeof(m_uTimeout);
    UINT uDefault = DEFAULT_SHIMGVW_TIMEOUT;
    SHRegGetUSValue(REGSTR_SHIMGVW, REGSTR_TIMEOUT, NULL, (void *)&m_uTimeout, &cbSize, FALSE, (void *)&uDefault, sizeof(uDefault));

    InitSelectionTracking();

    g_bMirroredOS = IS_MIRRORING_ENABLED(); // global????

    m_hdpaSelectedAnnotations = NULL;
    m_haccel = NULL;
    m_hpal = NULL;
    m_dwMode = 0;
    m_fShowToolbar = TRUE;
    m_punkSite = NULL;
    m_pImageFactory = NULL;
    m_pcwndSlideShow = NULL;
    m_hFont = NULL;
    m_pImageData = NULL;
    m_ppidls = NULL;
    m_cItems = 0;
    _pcm3 = NULL;

    m_pTaskScheduler = NULL;
    m_pici = NULL;

    _pdtobj = NULL;

    m_fFirstTime = TRUE;
    m_fFirstItem = FALSE;
    m_dwEffect = DROPEFFECT_NONE;
    m_fIgnoreNextNotify = FALSE;
    m_uRegister = 0;
    m_fNoRestore = FALSE;
    m_bRTLMirrored = FALSE;
    m_cWalkDepth = 0;
    m_fIgnoreAllNotifies = FALSE;
}

HRESULT CPreviewWnd::Initialize(CPreviewWnd* pother, DWORD dwMode, BOOL bExitApp)
{
    HRESULT hr = E_OUTOFMEMORY;

    m_hdpaSelectedAnnotations = DPA_Create(16);
    if (m_hdpaSelectedAnnotations)
    {
        hr = S_OK;
        m_dwMode = dwMode;
        m_fExitApp = bExitApp;

        // Set some defaults based on the mode
        if (CONTROL_MODE == m_dwMode)
        {
            m_fHidePrintBtn = TRUE;
        }

        if (pother)
        {
            m_fHidePrintBtn =       pother->m_fHidePrintBtn;
            m_fPrintable =          pother->m_fPrintable;
            m_fDisableEdit =        pother->m_fDisableEdit;
            m_fCanSave =            pother->m_fCanSave;
            m_haccel =              pother->m_haccel;
            m_dwMultiPageMode =     pother->m_dwMultiPageMode;
            m_hpal =                pother->m_hpal;
            m_iCurSlide =           pother->m_iCurSlide;

            m_uTimeout = pother->m_uTimeout;

            SetSite(pother->m_punkSite);

            // we grab a reference to the controlling objects m_pImageFactory
            // becaue it would be odd to create new ones.
            m_pImageFactory = pother->m_pImageFactory;
            if (m_pImageFactory)
            {
                m_pImageFactory->AddRef();
            }

            m_pTaskScheduler = pother->m_pTaskScheduler;
            if (m_pTaskScheduler)
            {
                m_pTaskScheduler->AddRef();
            }

            // lets copy the DPA of items also, and the current index
            if (pother->m_ppidls)
            {
                m_ppidls = (LPITEMIDLIST*)CoTaskMemAlloc(sizeof(LPITEMIDLIST)*pother->m_cItems);
                if (m_ppidls)
                {
                    for (int iItem = 0; iItem != pother->m_cItems; iItem++)
                    {
                        if (SUCCEEDED(pother->_GetItem(iItem, &m_ppidls[m_cItems])))
                        {
                            m_cItems++;
                        }
                    }
                }
            }
        }
    }
    return hr;
}

int ClearCB(void *p, void *pData);

CPreviewWnd::~CPreviewWnd()
{
    CleanupSelectionTracking();

    if (m_hdpaSelectedAnnotations != NULL)
        DPA_Destroy(m_hdpaSelectedAnnotations);

    ::DeleteObject(m_hFont);

    ATOMICRELEASE(m_pImageData);
    ATOMICRELEASE(m_pNextImageData);
    ATOMICRELEASE(m_pImageFactory);
    SetSite(NULL);
    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(m_pTaskScheduler);


    _ClearDPA();

    if (m_pcwndSlideShow)
    {
        if (m_pcwndSlideShow->m_hWnd)
        {
            m_pcwndSlideShow->DestroyWindow();
        }
        delete m_pcwndSlideShow;
    }

    if (m_pici)
    {
        LocalFree(m_pici);
        m_pici = NULL;
    }
}

BOOL CPreviewWnd::CreateSlideshowWindow(UINT cWalkDepth)
{
    RECT rc = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

    if (!Create(NULL, rc, NULL, WS_VISIBLE | WS_POPUP | WS_CLIPCHILDREN))
        return FALSE;

    WINDOWPLACEMENT wp = {0};

    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);
    wp.showCmd = SW_MAXIMIZE;
    SetWindowPlacement(&wp);
    SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);

    //  when we get called from autoplay to do a slideshow, 
    //  we need to walk deeply to find everything 
    //  that the autoplay code may have found

    m_cWalkDepth = cWalkDepth;
    return TRUE;
}

BOOL CPreviewWnd::_CloseSlideshowWindow()
{
    if (m_fExitApp)
        PostQuitMessage(0);
    else
        PostMessage(WM_CLOSE, 0, 0);
    return TRUE;
}

BOOL CPreviewWnd::CreateViewerWindow()
{
    // create the window hidden, that way any sizing etc we perform doesn't reflect
    // until its actually visible.

    RECT rc = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
    BOOL bRet = (NULL != Create(NULL, rc, NULL, WS_OVERLAPPEDWINDOW));
    m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_SINGLEPAGE));
    if (bRet)
    {
        // restore the window size based on the information we store in the registry.
        HKEY hk;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_SHIMGVW, &hk))
        {
            DWORD cbSize, dwType;

            // set the window placement, passing the restore rectangle for the window.

            WINDOWPLACEMENT wp = { 0 };
            wp.length = sizeof(wp);
            
            GetWindowPlacement(&wp);

            cbSize = sizeof(wp.rcNormalPosition);
            RegQueryValueEx(hk, REGSTR_BOUNDS, NULL, &dwType, (BYTE*)&wp.rcNormalPosition, &cbSize);

            BOOL fMaximize = TRUE;
            cbSize = sizeof(fMaximize);
            RegQueryValueEx(hk, REGSTR_MAXIMIZED, NULL, &dwType, (BYTE*)&fMaximize, &cbSize);
            if (fMaximize)
                wp.showCmd = SW_MAXIMIZE;

            SetWindowPlacement(&wp);
            RegCloseKey(hk);
        }        
        // now show the window having set its placement etc.
        SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
    }
    return bRet;
}


void ReplaceWindowIcon(HWND hwnd, int id, HICON hicon)
{
    HICON hiconOld = (HICON)SendMessage(hwnd, WM_SETICON, id, (LPARAM)hicon);
    if (hiconOld)
        DestroyIcon(hiconOld);
}

LRESULT CPreviewWnd::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    HRESULT hr = S_OK;

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        SHSetWindowBits(m_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, WS_EX_LAYOUTRTL);
        m_bRTLMirrored = TRUE;
    }
    if (!m_pImageFactory)
    {
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC,
                              IID_PPV_ARG(IShellImageDataFactory, &m_pImageFactory));
        if (FAILED(hr))
            return -1;
    }

    if (!m_pTaskScheduler)
    {
        hr = IUnknown_QueryService(m_punkSite, SID_ShellTaskScheduler, IID_PPV_ARG(IShellTaskScheduler, &m_pTaskScheduler));
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                                  IID_PPV_ARG(IShellTaskScheduler, &m_pTaskScheduler));

            if (FAILED(hr))
                return -1;
        }
    }

    // figure out where to place the zoom window
    RECT rcWnd;
    GetClientRect(&rcWnd);

    if (m_fShowToolbar)
    {
        // Create a toolbar control and then subclass it
        if (!CreateToolbar())
            return -1;

        m_iSSToolbarSelect = 0;
    }

    HICON hicon = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_FULLSCREEN));

    ReplaceWindowIcon(m_hWnd, ICON_SMALL, hicon);
    ReplaceWindowIcon(m_hWnd, ICON_BIG, hicon);    

    // Create the preview window
    DWORD dwExStyle = 0; // (WINDOW_MODE == m_dwMode) ? WS_EX_CLIENTEDGE : 0 ;
    if (m_ctlPreview.Create(m_hWnd, rcWnd, NULL, WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS, dwExStyle))
    {
        // When the window is created its default mode should be NOACTION.  This call is needed
        // because the object might have a longer life cycle than the window.  If a new window
        // is created for the same object we want to reset the state.
        m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
        m_ctlPreview.SetScheduler(m_pTaskScheduler);
    }

    RegisterDragDrop(m_hWnd, SAFECAST(this, IDropTarget *));

    return 0;
}

HRESULT CPreviewWnd::_SaveIfDirty(BOOL fCanCancel)
{
    // Callers assume that _SaveIfDirty will either return S_OK or S_FALSE
    // since this function is designed to sit in a loop until the user gives
    // up saving (cancels) or save successfully.
    HRESULT hr = S_OK;
    if (m_fDirty)
    {
        CComBSTR bstrMsg, bstrTitle;

        if (bstrMsg.LoadString(IDS_SAVEWARNING_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
        {
            hr = E_FAIL;
            while (FAILED(hr))
            {
                UINT uFlags;
                if (fCanCancel)
                    uFlags = MB_YESNOCANCEL;
                else
                    uFlags = MB_YESNO;

                uFlags |= MB_ICONQUESTION | MB_DEFBUTTON1 | MB_APPLMODAL;
                
                m_fPromptingUser = TRUE;
                int iResult = MessageBox(bstrMsg, bstrTitle, uFlags);
                m_fPromptingUser = FALSE;
                
                if (iResult == IDYES)
                {
                    // if this fails we keep looping.
                    // if this returns S_OK we succeed
                    // if this returns S_FALSE we cancel
                    hr = _SaveAsCmd();
                }
                else if (iResult == IDCANCEL)
                {
                    hr = S_FALSE;
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        if (S_OK == hr)
            m_fDirty = FALSE;
    }
    return hr;
}

LRESULT CPreviewWnd::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // hack alert- if CONTROL is held down while pressing the close button, do the registry stuff.
    // make sure the E accelerator isn't being used (edit verb)!
    if (m_fPromptingUser)
    {
        SetForegroundWindow(m_hWnd);
        fHandled = TRUE;
        return 0;
    }
    if (!m_fNoRestore && GetKeyState(VK_CONTROL) & 0x8000)
    {
        CRegKey Key;
        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
        {
            Key.DeleteValue(REGSTR_LOSSYROTATE);
        }

        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_DONTSHOWME))
        {
            Key.DeleteValue(REGSTR_SAVELESS);
            Key.DeleteValue(REGSTR_LOSSYROTATE);
        }

        CComBSTR bstrMsg, bstrTitle;

        if (bstrMsg.LoadString(IDS_RESET_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
        {
            m_fPromptingUser = TRUE;
            MessageBox(bstrMsg, bstrTitle, MB_OK | MB_APPLMODAL);
            m_fPromptingUser = FALSE;
        }
    }

    fHandled = FALSE; // let it close
    HRESULT hr = _SaveIfDirty(TRUE);
    if (hr == S_FALSE) // _SaveIfDirty can only return S_OK and S_FALSE
    {
        m_fNoRestore = FALSE;
        fHandled = TRUE;
    }
    if (!fHandled)
    {
        m_fClosed = TRUE;
    }
    return 0;
}

// we only have to erase the portion not covered by the zoomwnd
// change this code if the toolbar is put back at the top of the window
LRESULT CPreviewWnd::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    RECT rc;
    RECT rcZoomwnd;
    m_ctlPreview.GetClientRect(&rcZoomwnd);
    GetClientRect(&rc);
    rc.top = RECTHEIGHT(rcZoomwnd);
    SetBkColor((HDC)wParam, m_ctlPreview.GetBackgroundColor());
    ExtTextOut((HDC)wParam, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    fHandled = TRUE;
    return TRUE;
}

LRESULT CPreviewWnd::OnSize(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    int x =0, y =0, cx =0, cy =0;

    if (lParam == 0)
    {
        RECT rcClient;
        GetClientRect(&rcClient);
        cx = RECTWIDTH(rcClient);
        cy = RECTHEIGHT(rcClient);
    }
    else
    {
        cx = GET_X_LPARAM(lParam);
        cy = GET_Y_LPARAM(lParam);
    }

    if (m_fShowToolbar)
    {
        SIZE sizeToolbar;
        m_ctlToolbar.SendMessage(TB_GETMAXSIZE, 0, (LPARAM)&sizeToolbar);
        if (sizeToolbar.cx > cx)
            sizeToolbar.cx = cx;

        if (SLIDESHOW_MODE != m_dwMode)
        {
            // Center the toolbar horizontally
            LONG cyBottomMargin = (CONTROL_MODE == m_dwMode) ? NEWTOOLBAR_BOTTOMMARGIN_CTRLMODE : NEWTOOLBAR_BOTTOMMARGIN;
            LONG xNewToolbar = ( cx - sizeToolbar.cx ) / 2;
            LONG yNewToolbar = cy - ( cyBottomMargin + sizeToolbar.cy );

            ::SetWindowPos(m_ctlToolbar.m_hWnd, NULL, xNewToolbar, yNewToolbar, sizeToolbar.cx, sizeToolbar.cy, SWP_NOZORDER);

            // make the preview window shorter so the toolbar is below it
            cy -= ( NEWTOOLBAR_TOPMARGIN + sizeToolbar.cy + cyBottomMargin);
        }
        else
        {
            // Pin the toolbar to the upper right corner
            UINT uFlags = 0;
            if (m_fToolbarHidden)
                uFlags |= SWP_HIDEWINDOW;
            else
                uFlags |= SWP_SHOWWINDOW;

            ::SetWindowPos(m_ctlToolbar.m_hWnd, HWND_TOP, cx-sizeToolbar.cx, 0, sizeToolbar.cx, sizeToolbar.cy, uFlags);
        }
    }

    ::SetWindowPos(m_ctlPreview.m_hWnd, NULL, x, y, cx, cy, SWP_NOZORDER);
    return 0;
}


BOOL CPreviewWnd::_VerbExists(LPCTSTR pszVerb)
{
    // TODO: Create the context menu for the item and check it for the verb

    return TRUE;
}

// given a verb lets invoke it for the current file
HRESULT CPreviewWnd::_InvokeVerb(LPCTSTR pszVerb, LPCTSTR szParameters)
{
    SHELLEXECUTEINFO sei = {0};

    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_INVOKEIDLIST | SEE_MASK_HMONITOR;
    sei.hwnd = m_hWnd;
    sei.lpVerb = pszVerb;
    sei.nShow = SW_SHOW;
    sei.lpParameters = szParameters;
    sei.hMonitor = MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);
    LPITEMIDLIST pidl = NULL;
    TCHAR szPath[MAX_PATH];
    HRESULT hr = GetCurrentIDList(&pidl);
    if (SUCCEEDED(hr))
    {
        sei.lpIDList = pidl;
    }
    else if (SUCCEEDED(hr = PathFromImageData(szPath, ARRAYSIZE(szPath))))
    {
        sei.lpFile = szPath;
    }
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        if (!ShellExecuteEx(&sei))
            hr = E_FAIL;
    }
    ILFree(pidl);

    return hr;
}

// show the window and activate it
// if the window is minimized, restore it

void RestoreAndActivate(HWND hwnd)
{
    if (IsIconic(hwnd))
    {
        ShowWindow(hwnd, SW_RESTORE);
    }
    SetForegroundWindow(hwnd);
}

// Handles WM_COMMAND messages sent from the toolbar control

LRESULT CPreviewWnd::OnToolbarCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    // don't use early returns in this function
    m_fIgnoreAllNotifies = TRUE;
    switch (wID)
    {
    case ID_ZOOMINCMD:
        ZoomIn();
        break;

    case ID_ZOOMOUTCMD:
        ZoomOut();
        break;

    case ID_SELECTCMD:
        if (m_fCanAnnotate)
        {
            _UpdateButtons(wID);
        }
        break;

    case ID_CROPCMD:
        if (m_fCanCrop)
        {
            m_rectCropping.SetRectEmpty();
            _UpdateButtons(wID);
        }
        break;

    case ID_ACTUALSIZECMD:
        ActualSize();
        break;

    case ID_BESTFITCMD:
        BestFit();
        break;

    case ID_PRINTCMD:
        _RefreshSelection(FALSE);
        _InvokePrintWizard();
        break;

    case ID_PREVPAGECMD:
    case ID_NEXTPAGECMD:
        _PrevNextPage(ID_NEXTPAGECMD==wID);
        break;

    case ID_NEXTIMGCMD:
    case ID_PREVIMGCMD:
        _RefreshSelection(FALSE);
        if (WINDOW_MODE == m_dwMode)
        {
            HRESULT hr = _SaveIfDirty(TRUE);
            if (hr != S_FALSE)
            {
                _ShowNextSlide(ID_PREVIMGCMD == wID);
            }
        }
        else if (m_punkSite)
        {
            IFolderView* pfv;
            if (SUCCEEDED(IUnknown_QueryService(m_punkSite, SID_DefView, IID_PPV_ARG(IFolderView, &pfv))))
            {
                int iCurrent, cItems;
                if (SUCCEEDED(pfv->ItemCount(SVGIO_ALLVIEW, &cItems)) && (cItems > 1) &&
                    SUCCEEDED(pfv->GetFocusedItem(&iCurrent)))
                {
                    int iToSelect = iCurrent + ((ID_PREVIMGCMD == wID) ? -1 : 1);
                    if (iToSelect < 0)
                    {
                        iToSelect = cItems-1;
                    }
                    else if (iToSelect >= cItems)
                    {
                        iToSelect = 0;
                    }

                    pfv->SelectItem(iToSelect, SVSI_SELECTIONMARK | SVSI_SELECT
                            | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED);
                }
                pfv->Release();
            }
        }
        break;

    case ID_FREEHANDCMD:
    case ID_HIGHLIGHTCMD:
    case ID_LINECMD:
    case ID_FRAMECMD:
    case ID_RECTCMD:
    case ID_TEXTCMD:
    case ID_NOTECMD:
        if (m_fCanAnnotate)
        {
            _UpdateButtons(wID);
        }
        break;

    case ID_PROPERTIESCMD:
        _UpdateButtons(wID);
        _PropertiesCmd();
        break;

    case ID_SAVEASCMD:
        _UpdateButtons(wID);
        _SaveAsCmd();
        break;

    case ID_EDITCMD:
        _UpdateButtons(wID);
        if (m_fCanAnnotate && m_fAnnotating)
        {
            _StartEditing();
        }
        break;

    case ID_HELPCMD:
        _UpdateButtons(wID);
        HtmlHelp(::GetDesktopWindow(), HTMLHELP_FILENAME, HH_DISPLAY_TOPIC, NULL);
        break;

    case ID_OPENCMD:
        _UpdateButtons(wID);
        _OpenCmd();
        break;

    case ID_DELETECMD:
        _UpdateButtons(wID);
        if (m_fCanAnnotate && m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
        {
            _RemoveAnnotatingSelection();
        }
        else
        {
            _DeleteCurrentSlide();
        }
        break;
    case ID_SLIDESHOWCMD:
        if (!m_fFirstTime) // don't try to do this while the namespace walk is ongoing
        {
            StartSlideShow(NULL);
        }
        break;
    }
    m_fIgnoreAllNotifies = FALSE;
    return 0;
}


// OnEditCommand
//
// Handles picture editting(rotate/flip/save etc) WM_COMMAND messages

LRESULT CPreviewWnd::OnEditCommand(WORD , WORD wID, HWND , BOOL& )
{
    m_fIgnoreAllNotifies = TRUE;
    switch (wID)
    {
    case ID_ROTATE90CMD:
        Rotate(90);
        break;

    case ID_ROTATE270CMD:
        Rotate(270);
        break;
    }
    m_fIgnoreAllNotifies = FALSE;
    return 0;
}

LRESULT CPreviewWnd::OnPositionCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        switch (wID)
        {
        case ID_NUDGELEFTCMD:
            OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
            break;
        case ID_NUDGERIGHTCMD:
            OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
            break;
        default:
            break;
        }
    }
    else
    {
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0)
        {
            BOOL bDummy;
            switch (wID)
            {
            case ID_MOVELEFTCMD:
                m_ctlPreview.OnScroll(WM_HSCROLL, SB_PAGEUP, 0, fHandled);
                break;
            case ID_MOVERIGHTCMD:
                m_ctlPreview.OnScroll(WM_HSCROLL, SB_PAGEDOWN, 0, fHandled);
                break;
            case ID_MOVEUPCMD:
                m_ctlPreview.OnScroll(WM_VSCROLL, SB_PAGEUP, 0, fHandled);
                break;
            case ID_MOVEDOWNCMD:
                m_ctlPreview.OnScroll(WM_VSCROLL, SB_PAGEDOWN, 0, fHandled);
                break;
            case ID_NUDGELEFTCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_HSCROLL, SB_LINEUP, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_PREVIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGERIGHTCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_HSCROLL, SB_LINEDOWN, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_NEXTIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGEUPCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_VSCROLL, SB_LINEUP, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_PREVIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGEDOWNCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_VSCROLL, SB_LINEDOWN, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_NEXTIMGCMD, m_hWnd, bDummy);
                }
                break;
            default:
                break;
            }
        }
        else
        {
            CRect rectImage;
            m_ctlPreview.GetVisibleImageWindowRect(rectImage);
            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
            rectImage.DeflateRect(5, 5);

            CSize size(0,0);

            switch (wID)
            {
            case ID_MOVELEFTCMD:
                size.cx = -25;
                break;
            case ID_MOVERIGHTCMD:
                size.cx = 25;
                break;
            case ID_MOVEUPCMD:
                size.cy = -25;
                break;
            case ID_MOVEDOWNCMD:
                size.cy = 25;
                break;
            case ID_NUDGELEFTCMD:
                size.cx = -1;
                break;
            case ID_NUDGERIGHTCMD:
                size.cx = 1;
                break;
            case ID_NUDGEUPCMD:
                size.cy = -1;
                break;
            case ID_NUDGEDOWNCMD:
                size.cy = 1;
                break;
            default:
                break;
            }

            if (size.cx == 0 && size.cy == 0)
                return 0;

            _UpdateAnnotatingSelection();

            CRect rect;
            CRect rectNewPos;
            BOOL bValidMove = TRUE;
            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
                pAnnotation->GetRect(rect);
                rect.NormalizeRect();
                rect.OffsetRect(size);

                if (!rectNewPos.IntersectRect(rectImage, rect))
                    bValidMove = FALSE;
            }

            if (!bValidMove)
                return 0;

            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
                pAnnotation->Move(size);
            }

            m_fDirty = TRUE;
            _UpdateAnnotatingSelection();
        }
    }
    return 0;
}


// call SetNewImage when the entire image has changed, call UpdateImage if it's the same image
// but it needs to be updated

void CPreviewWnd::_SetNewImage(CDecodeTask * pData)
{
    // store the new pointer
    if (m_pImageData)
    {
        _SaveIfDirty();
        // m_pImageData might be NULL after _SaveAsCmd
        ATOMICRELEASE(m_pImageData);
    }

    m_pImageData = pData;

    m_fWarnQuietSave = TRUE; // Reset for each image
    m_fWarnNoSave = TRUE;

    if (!m_pImageData)
    {
        StatusUpdate(IDS_LOADFAILED);
        return;
    }

    m_pImageData->AddRef();

    // Even if m_hpal is NULL it is still correct, so we always go ahead and set it.
    m_ctlPreview.SetPalette(m_hpal);

    if (SLIDESHOW_MODE != m_dwMode)
    {
        // update toolbar state
        _SetMultipageCommands();
        _SetMultiImagesCommands();

        BOOL fCanAnnotate = _CanAnnotate(m_pImageData);
        _SetAnnotatingCommands(fCanAnnotate);

        BOOL fCanCrop = _CanCrop(m_pImageData);
        _SetCroppingCommands(fCanCrop);

        _RefreshSelection(TRUE);

        _SetEditCommands();

        m_fPrintable = _VerbExists(TEXT("print"));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PRINTCMD, MAKELONG(m_fPrintable, 0));
        // we need to watch non-TIFFs for changes so we can reload.
        // TIFFs are problematic because we allow annotations, and reloading during annotation
        // would suck
        if (CONTROL_MODE != m_dwMode)
        {
            _RegisterForChangeNotify(TRUE);
        }
    }

    // notify our child
    m_ctlPreview.SetImageData(m_pImageData, TRUE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(FALSE, 0));

    // update our toolbar
    BOOL fHandled;
    OnSize(0x0, 0, 0, fHandled);
}

// for refreshing the current m_pImageData because it has changed in some
// way, i.e. it has advanced to the next frame, the next page, or was edited.

void CPreviewWnd::_UpdateImage()
{
    _RefreshSelection(TRUE);
    m_ctlPreview.SetImageData(m_pImageData, FALSE);    
}

// Handles slidwshow (pause/resume, next/previous etc) WM_COMMAND messages

void CPreviewWnd::TogglePlayState()
{
    if (!m_fPaused)
    {
        KillTimer(TIMER_SLIDESHOW);
    }
    else
    {
        SetTimer(TIMER_SLIDESHOW, m_uTimeout);
    }
    m_fPaused = !m_fPaused;

    WPARAM wpCheck, wpUncheck;
    if (m_fPaused)
    {
        wpCheck = ID_PAUSECMD;
        wpUncheck = ID_PLAYCMD;
    }
    else
    {
        wpCheck = ID_PLAYCMD;
        wpUncheck = ID_PAUSECMD;
    }
    m_ctlToolbar.SendMessage(TB_SETSTATE, wpCheck, TBSTATE_ENABLED | TBSTATE_CHECKED);
    m_ctlToolbar.SendMessage(TB_SETSTATE, wpUncheck, TBSTATE_ENABLED);
}

LRESULT CPreviewWnd::OnMenuMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (_pcm3)
        _pcm3->HandleMenuMsg(uMsg, wParam, lParam);
    return 0;
}

LRESULT CPreviewWnd::OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    UINT cmd = GET_APPCOMMAND_LPARAM(lParam);
    DWORD dwKeys = GET_KEYSTATE_LPARAM(lParam);

    switch (cmd)
    {
    case APPCOMMAND_BROWSER_FORWARD:
        if (SLIDESHOW_MODE == m_dwMode)
            OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
        else
        {
            if ((dwKeys & MK_CONTROL) || (m_pImageData && !m_pImageData->IsMultipage()))
                OnToolbarCommand(0, ID_NEXTIMGCMD, NULL, fHandled);
            else
                NextPage();
        }
        break;

    case APPCOMMAND_BROWSER_BACKWARD:
        if (SLIDESHOW_MODE == m_dwMode)
            OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
        else
        {
            if ((dwKeys & MK_CONTROL) || (m_pImageData && !m_pImageData->IsMultipage()))
                OnToolbarCommand(0, ID_PREVIMGCMD, NULL, fHandled);
            else
                PreviousPage();
        }
        break;

    default:
        fHandled = FALSE;
    }
    return 0;
}

LRESULT CPreviewWnd::OnSlideshowCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    switch (wID)
    {
    case ID_PLAYCMD:
        m_iSSToolbarSelect = 0;
        if (m_fPaused)
        {
            m_fGoBack = FALSE;
            TogglePlayState();
            _ShowNextSlide(m_fGoBack);
        }
        fHandled = TRUE;
        break;

    case ID_PAUSECMD:
        m_iSSToolbarSelect = 1;
        if (!m_fPaused)
        {
            TogglePlayState();
        }
        fHandled = TRUE;
        break;

    case ID_NEXTCMD:
    case ID_PREVCMD:
        if (wID == ID_PREVCMD)
        {
            m_iSSToolbarSelect = 3;
            m_fGoBack = TRUE;
        }
        else
        {
            m_iSSToolbarSelect = 4;
            m_fGoBack = FALSE;
        }
        _ShowNextSlide(m_fGoBack);
        fHandled = TRUE;
        break;

    case ID_CLOSECMD:
        m_iSSToolbarSelect = 6;
        _CloseSlideshowWindow();
        break;
    }
    return 0;
}


BOOL CPreviewWnd::CreateToolbar()
{
    // ensure that the common controls are initialized
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_BAR_CLASSES;
    InitCommonControlsEx(&icc);

    return (SLIDESHOW_MODE == m_dwMode) ? _CreateSlideshowToolbar() : _CreateViewerToolbar();
}

static const TBBUTTON    c_tbSlideShow[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0, ID_PLAYCMD,        TBSTATE_ENABLED  | TBSTATE_CHECKED,  TBSTYLE_CHECKGROUP, {0,0}, 0, 0},
    { 1, ID_PAUSECMD,       TBSTATE_ENABLED,                     TBSTYLE_CHECKGROUP, {0,0}, 0, 0},
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 2, ID_PREVCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
    { 3, ID_NEXTCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
#if 0
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 5, ID_DELETECMD,      TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
#endif
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 4, ID_CLOSECMD,       TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
};

BOOL CPreviewWnd::_CreateSlideshowToolbar()
{
    DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                    CCS_NODIVIDER | CCS_NORESIZE |
                    TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS;

    HWND hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 0, 0,
                                 m_hWnd, NULL, _Module.GetModuleInstance(), NULL);

    _InitializeToolbar(hwndTB, IDB_SLIDESHOWTOOLBAR, IDB_SLIDESHOWTOOLBAR_HOT, IDB_SLIDESHOWTOOLBARHIGH, IDB_SLIDESHOWTOOLBARHIGH_HOT);

    TBBUTTON tbSlideShow[ARRAYSIZE(c_tbSlideShow)];
    memcpy(tbSlideShow, c_tbSlideShow, sizeof(c_tbSlideShow));

    // Add the buttons, and then set the minimum and maximum button widths.
    ::SendMessage(hwndTB, TB_ADDBUTTONS, (UINT)ARRAYSIZE(c_tbSlideShow), (LPARAM)tbSlideShow);

    LRESULT dwSize = ::SendMessage(hwndTB, TB_GETBUTTONSIZE, 0, 0);
    SIZE size = {0, HIWORD(dwSize)};
    ::SendMessage(hwndTB, TB_GETIDEALSIZE, 0, (LPARAM)&size);

    RECT rcClient;
    RECT rcToolbar = {0, 0, size.cx, size.cy};

    GetClientRect(&rcClient);
    AdjustWindowRectEx(&rcToolbar, dwStyle, FALSE, WS_EX_TOOLWINDOW);
    ::SetWindowPos(hwndTB, HWND_TOP, RECTWIDTH(rcClient)-RECTWIDTH(rcToolbar), 0,
                                     RECTWIDTH(rcToolbar), RECTHEIGHT(rcToolbar), 0);

//> REVIEW This is a feature that CyraR would like to get into Whistler, but it doesn't seem to work. I will investigate more after Beta1
//  LONG lStyle = ::GetWindowLong(hwndTB, GWL_EXSTYLE);
//  ::SetWindowLong(hwndTB, GWL_EXSTYLE, lStyle | WS_EX_LAYERED);
//  if (::SetLayeredWindowAttributes(hwndTB, 0, 0, 0) == 0)
//  {
//      void *lpMsgBuf;
//      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
//                      NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);
//
//      MessageBox((LPCTSTR)lpMsgBuf, L"Error", MB_OK | MB_ICONINFORMATION);
//      ::LocalFree(lpMsgBuf);
//  }

    m_ctlToolbar.SubclassWindow(hwndTB);
    ShowSSToolbar(FALSE, TRUE);

    return (NULL != hwndTB);
}

enum EViewerToolbarButtons
{
    PREVIMGPOS = 0,
    NEXTIMGPOS,
    VIEWSEPPOS,         // seperator

    BESTFITPOS,
    ACTUALSIZEPOS,
    SLIDESHOWPOS,
    IMAGECMDSEPPOS,     // seperator

    ZOOMINPOS,
    ZOOMEOUTPOS,
    SELECTPOS,
    CROPPOS,

    ROTATESEPPOS,       // seperator
    ROTATE90POS,
    ROTATE270POS,

// these are all TIFF related
    PAGESEPPOS,
    PREVPAGEPOS,
    PAGELISTPOS,
    NEXTPAGEPOS,
    ANNOTATEPOS,
    FREEHANDPOS,
    HIGLIGHTPOS,
    LINEPOS,
    FRAMEPOS,
    RECTPOS,
    TEXTPOS,
    NOTEPOS,

    PRINTSEPPOS,
    DELETEPOS,
    PRINTPOS,
    PROPERTIESPOS,
    SAVEASPOS,
    OPENPOS,

    HELPSEPPOS,
    HELPPOS,

    MAXPOS,
};

static const TBBUTTON c_tbViewer[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0,    ID_PREVIMGCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 1,    ID_NEXTIMGCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_VIEWCMDSEP,      TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 5,    ID_BESTFITCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 6,    ID_ACTUALSIZECMD,   TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 8,    ID_SLIDESHOWCMD,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 2,    ID_ZOOMINCMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 3,    ID_ZOOMOUTCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 4,    ID_SELECTCMD,       TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 23,   ID_CROPCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_ROTATESEP,       TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 12,   ID_ROTATE90CMD,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 11,   ID_ROTATE270CMD,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_PAGECMDSEP,      TBSTATE_HIDDEN,     TBSTYLE_SEP,    {0,0}, 0, -1},   //tiff
    { 9,    ID_PREVPAGECMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { I_IMAGENONE, ID_PAGELIST, TBSTATE_HIDDEN,     BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT | BTNS_AUTOSIZE, {0,0}, 0, -1},//tiff
    { 10,   ID_NEXTPAGECMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 0,    ID_ANNOTATESEP,     TBSTATE_HIDDEN,     TBSTYLE_SEP,    {0,0}, 0, -1},   //tiff
    { 13,   ID_FREEHANDCMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 14,   ID_HIGHLIGHTCMD,    TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 15,   ID_LINECMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 16,   ID_FRAMECMD,        TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 17,   ID_RECTCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 18,   ID_TEXTCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 19,   ID_NOTECMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 25,   ID_DELETECMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 20,   ID_PRINTCMD,        TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 21,   ID_PROPERTIESCMD,   TBSTATE_HIDDEN,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 22,   ID_SAVEASCMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 26,   ID_OPENCMD,         TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 24,   ID_HELPCMD,         TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
};

void CPreviewWnd::_InitializeViewerToolbarButtons(HWND hwndToolbar, const TBBUTTON c_tbbuttons[], size_t c_nButtons, TBBUTTON tbbuttons[], size_t nButtons)
{
    ASSERT(c_nButtons == nButtons); // Sanity check.
    ASSERT(c_nButtons <= 100);      // Sanity check.

    // Determine if running RTL mirrored and initialize toolbar accordingly.
    if (!m_bRTLMirrored)
    {
        //
        // Init LTR.
        //

        memcpy(tbbuttons, c_tbbuttons, c_nButtons * sizeof(TBBUTTON));
    }
    else
    {
        //
        // Init RTL.
        //

        // Toolbar window inherits RTL style from parent hwnd, but we don't
        // want full-blown RTL.  We do want the icons to have their positions
        // reversed in the toolbar, but we don't want the button bitmaps to
        // get blitted backwards.  So we turn of RTL for the toolbar hwnd
        // and do a manual reorder of the buttons in RTL fashion.

        // Remove RTL style from toolbar hwnd.
        DWORD dwStyle = ::GetWindowLong(hwndToolbar, GWL_EXSTYLE);
        DWORD dwNewStyle = (dwStyle & ~WS_EX_LAYOUTRTL);
        ASSERT(dwStyle != dwNewStyle);  // Sanity check.
        ::SetWindowLong(hwndToolbar, GWL_EXSTYLE, dwNewStyle);

        // Reverse toolbar button order.
        size_t iFrom = nButtons - 1;
        size_t iTo = 0;
        while (iTo < iFrom)
        {
            memcpy(&tbbuttons[iTo], &c_tbbuttons[iFrom], sizeof(TBBUTTON));
            memcpy(&tbbuttons[iFrom], &c_tbbuttons[iTo], sizeof(TBBUTTON));
            iFrom--;
            iTo++;
        }
        if (iTo == iFrom)
        {
            memcpy(&tbbuttons[iTo], &c_tbbuttons[iFrom], sizeof(TBBUTTON));
        }
    }
}

inline UINT CPreviewWnd::_IndexOfViewerToolbarButton(EViewerToolbarButtons eButton)
{
    ASSERT(eButton > 0);

    if (!m_bRTLMirrored)
    {
        return eButton;
    }
    else
    {
        return MAXPOS - eButton - 1;
    }
}

BOOL CPreviewWnd::_CreateViewerToolbar()
{
    DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                    CCS_NODIVIDER | CCS_NORESIZE |
                    TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS;

    HWND hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 0, 0,
                                 m_hWnd, NULL, _Module.GetModuleInstance(), NULL);

    _InitializeToolbar(hwndTB, IDB_TOOLBAR, IDB_TOOLBAR_HOT, IDB_TOOLBARHIGH, IDB_TOOLBARHIGH_HOT);

    TBBUTTON tbbuttons[ARRAYSIZE(c_tbViewer)];
    _InitializeViewerToolbarButtons(hwndTB, c_tbViewer, ARRAYSIZE(c_tbViewer), tbbuttons, ARRAYSIZE(tbbuttons));

    if (CONTROL_MODE == m_dwMode)
    {
        ASSERT(ID_BESTFITCMD==tbbuttons[_IndexOfViewerToolbarButton(BESTFITPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(BESTFITPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ACTUALSIZECMD==tbbuttons[_IndexOfViewerToolbarButton(ACTUALSIZEPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ACTUALSIZEPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_SLIDESHOWCMD==tbbuttons[_IndexOfViewerToolbarButton(SLIDESHOWPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(SLIDESHOWPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ZOOMINCMD==tbbuttons[_IndexOfViewerToolbarButton(ZOOMINPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ZOOMINPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ZOOMOUTCMD==tbbuttons[_IndexOfViewerToolbarButton(ZOOMEOUTPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ZOOMEOUTPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_SAVEASCMD==tbbuttons[_IndexOfViewerToolbarButton(SAVEASPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(SAVEASPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_DELETECMD==tbbuttons[_IndexOfViewerToolbarButton(DELETEPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(DELETEPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_OPENCMD==tbbuttons[_IndexOfViewerToolbarButton(OPENPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(OPENPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_HELPCMD==tbbuttons[_IndexOfViewerToolbarButton(HELPPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(HELPPOS)].fsState = TBSTATE_HIDDEN;

        // remove a few seperators too:
        tbbuttons[_IndexOfViewerToolbarButton(VIEWSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(IMAGECMDSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(PRINTSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(HELPSEPPOS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_fHidePrintBtn)
    {
        ASSERT(ID_PRINTCMD==tbbuttons[_IndexOfViewerToolbarButton(PRINTPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(PRINTPOS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_fDisableEdit)
    {
        ASSERT(ID_ROTATESEP == tbbuttons[_IndexOfViewerToolbarButton(ROTATESEPPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATESEPPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ROTATE90CMD == tbbuttons[_IndexOfViewerToolbarButton(ROTATE90POS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATE90POS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ROTATE270CMD == tbbuttons[_IndexOfViewerToolbarButton(ROTATE270POS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATE270POS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_bRTLMirrored)
    {
        UINT uTmp = tbbuttons[_IndexOfViewerToolbarButton(PREVIMGPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(PREVIMGPOS)].iBitmap = tbbuttons[_IndexOfViewerToolbarButton(NEXTIMGPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(NEXTIMGPOS)].iBitmap = uTmp;

        uTmp = tbbuttons[_IndexOfViewerToolbarButton(PREVPAGEPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(PREVPAGEPOS)].iBitmap = tbbuttons[_IndexOfViewerToolbarButton(NEXTPAGEPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(NEXTPAGEPOS)].iBitmap = uTmp;
    }

    // Add the buttons, and then set the minimum and maximum button widths.
    ::SendMessage(hwndTB, TB_ADDBUTTONS, ARRAYSIZE(tbbuttons), (LPARAM)tbbuttons);

    // we just created the toolbar so we are now in the hidden state of the multipage buttons.
    m_dwMultiPageMode = MPCMD_HIDDEN;
    m_fCanAnnotate = FALSE;
    m_fCanCrop = FALSE;

    m_ctlToolbar.SubclassWindow(hwndTB);

    return (NULL != hwndTB);
}


void CPreviewWnd::_InitializeToolbar(HWND hwndTB, int idLow, int idLowHot, int idHigh, int idHighHot)
{
    int cxBitmap = 16, cyBitmap = 16;

    ::SendMessage(hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);
    ::SendMessage (hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_HIDECLIPPEDBUTTONS | TBSTYLE_EX_MIXEDBUTTONS | TBSTYLE_EX_DOUBLEBUFFER);

    // Sets the size of the TBBUTTON structure.
    ::SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    // Set the maximum number of text rows and bitmap size.
    ::SendMessage(hwndTB, TB_SETMAXTEXTROWS, 1, 0);

    int nDepth = SHGetCurColorRes();
    HIMAGELIST himl = ImageList_LoadImage(_Module.GetModuleInstance(), 
                                          (nDepth > 8) ? MAKEINTRESOURCE(idHigh) : MAKEINTRESOURCE(idLow), 
                                          cxBitmap, 0, RGB(0, 255, 0), IMAGE_BITMAP, 
                                          (nDepth > 8) ? LR_CREATEDIBSECTION : LR_DEFAULTCOLOR);
    ::SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

    HIMAGELIST himlHot = ImageList_LoadImage(_Module.GetModuleInstance(), 
                                             (nDepth > 8) ? MAKEINTRESOURCE(idHighHot) : MAKEINTRESOURCE(idLowHot), 
                                              cxBitmap, 0, RGB(0, 255, 0), IMAGE_BITMAP, 
                                             (nDepth > 8) ? LR_CREATEDIBSECTION : LR_DEFAULTCOLOR);
    ::SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);

}

LRESULT CPreviewWnd::OnPrintClient(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    COLORREF bgClr = m_ctlPreview.GetBackgroundColor();

    RECT rcFill;
    GetClientRect(&rcFill);
    SHFillRectClr((HDC)wParam, &rcFill, bgClr);

    return TRUE;
}

LRESULT CPreviewWnd::OnNeedText(int , LPNMHDR pnmh, BOOL&)
{
    TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pnmh;

    // tooltip text messages have the same string ID as the control ID
    pTTT->lpszText = MAKEINTRESOURCE(pTTT->hdr.idFrom);
    pTTT->hinst = _Module.GetModuleInstance();

    // Except in Control Mode due to a DUI Web View bug that's too hard to fix for Whistler...
    if (CONTROL_MODE == m_dwMode)
    {
        // keyboard accelerators are broken, so swap IDs around for the few that display them
        static const struct {
            UINT idCommand;
            UINT idsNewName;
        } map[] = {
            { ID_PRINTCMD, IDS_PRINTCMD },
            { ID_ROTATE90CMD, IDS_ROTATE90CMD },
            { ID_ROTATE270CMD, IDS_ROTATE270CMD }};

        for (int i = 0 ; i < ARRAYSIZE(map) ; i++)
        {
            if (map[i].idCommand == pTTT->hdr.idFrom)
            {
                pTTT->lpszText = MAKEINTRESOURCE(map[i].idsNewName);
                break;
            }
        }
    }

    return TRUE;
}

LRESULT CPreviewWnd::OnDropDown(int id, LPNMHDR pnmh, BOOL&)
{
    LPNMTOOLBAR pnmTB = (LPNMTOOLBAR)pnmh;
    switch (pnmTB->iItem)
    {
        case ID_PAGELIST:
            _DropDownPageList (pnmTB);
            break;

        default:
            return TRUE;
    }
    return FALSE;

}

void CPreviewWnd::_DropDownPageList(LPNMTOOLBAR pnmTB)
{
    HMENU hmenuPopup = CreatePopupMenu();
    if (hmenuPopup)
    {
        for (DWORD i = 1; i <= m_pImageData->_cImages; i++)
        {
            TCHAR szBuffer[10];
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), i);

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.wID = i;
            mii.dwTypeData = szBuffer;

            InsertMenuItem (hmenuPopup, i-1, TRUE, &mii);
        }

        RECT rc;
        ::SendMessage(pnmTB->hdr.hwndFrom, TB_GETRECT, (WPARAM)pnmTB->iItem, (LPARAM)&rc);
        ::MapWindowPoints(pnmTB->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&rc, 2);

        TPMPARAMS tpm = { 0};
        tpm.cbSize = sizeof(TPMPARAMS);
        tpm.rcExclude = rc;

        BOOL bRet = ::TrackPopupMenuEx(hmenuPopup,
                                       TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL | TPM_NONOTIFY,
                                       rc.left, rc.bottom,
                                       m_hWnd, &tpm);
        if (bRet)
        {
            if (m_fDirty)
            {
                m_ctlPreview.CommitAnnotations();
            }
            m_pImageData->SelectPage((LONG)bRet-1);
            _UpdateImage();

            _SetMultipageCommands();
        }

        DestroyMenu(hmenuPopup);
    }
}

void CPreviewWnd::SetNotify(CEvents * pEvents)
{
    m_pEvents = pEvents;
}

void CPreviewWnd::SetPalette(HPALETTE hpal)
{
    m_hpal = hpal;
}

BOOL CPreviewWnd::GetPrintable()
{
    return m_fPrintable;
}

LRESULT CPreviewWnd::OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // REVIEW: Shouldn't this just be translated into a command?

    // this message is ALWAYS forwarded to the zoom window
    m_ctlPreview.SendMessage(uMsg, wParam, lParam);

    // Since we know that the mouse wheel will either ZoomIn or ZoomOut lets update the buttons if we are in Window Mode.
    if (WINDOW_MODE == m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(!m_ctlPreview.IsBestFit(), 0));
    }

    return 0;
}

BOOL CPreviewWnd::OnNonSlideShowTab()
{
    BOOL fHandled = FALSE;

    if ((SLIDESHOW_MODE != m_dwMode) && m_fShowToolbar)
    {
        if (GetFocus() != m_ctlToolbar.m_hWnd)
        {
            m_ctlToolbar.SetFocus();
            m_ctlToolbar.SetActiveWindow();
            m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
            m_iSSToolbarSelect = 0;
            fHandled = TRUE;
        }
    }

    return fHandled;
}

// Forwards WM_KEYUP and WM_KEYDOWN events to the zoom window but only if they are keys
// that the zoom window cares about.
// Activates the slideshow toolbar if needed
LRESULT CPreviewWnd::OnKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    MSG msg;
    msg.hwnd = m_hWnd;
    msg.message = uMsg;
    msg.wParam = wParam;
    msg.lParam = lParam;
    GetCursorPos (&msg.pt);
    fHandled = FALSE;
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (WM_KEYDOWN == uMsg)
        {
            switch (wParam)
            {
                case VK_TAB:
                    OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                    ShowSSToolbar(TRUE);
                    KillTimer(TIMER_TOOLBAR);
                    m_ctlToolbar.SetFocus();
                    m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
                    m_iSSToolbarSelect = 0;
                    fHandled = TRUE;
                    break;
                case VK_SPACE:
                    ShowSSToolbar(!m_fPaused); // if we are unpausing, hide the toolbar if it's shown.  if we are pausing, show the toolbar
                    OnSlideshowCommand(0, m_fPaused ? ID_PLAYCMD : ID_PAUSECMD, NULL, fHandled);
                    break;
                case VK_PRIOR: // PAGEUP
                case VK_UP:
                case VK_LEFT:
                case VK_BACK: // BACKSPACE
                    OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
                    break;
                case VK_NEXT: // PAGEDOWN
                case VK_RIGHT:
                case VK_DOWN:
                case VK_RETURN: // ENTER
                    OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
                    break;
                case VK_DELETE:
                    _DeleteCurrentSlide();
                    fHandled = TRUE;
                    break;
                case 'K':
                    if (0x8000 & GetKeyState(VK_CONTROL))
                    {
                        OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                        Rotate(90);
                        fHandled = TRUE;
                    }
                    break;
                case 'L':
                    if (0x8000 & GetKeyState(VK_CONTROL))
                    {
                        OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                        Rotate(270);
                        fHandled = TRUE;
                    }
                    break;
                case VK_ESCAPE:
                    PostMessage(m_fExitApp ? WM_QUIT : WM_CLOSE, 0, 0);
                    fHandled = TRUE;
                    break;
            }
        }
    }
    else if (!TranslateAccelerator(&msg))   // Only translate accelerators in the non-slideshow case
                                            // Slideshow keys are handled explicitly above
    {
        switch (wParam)
        {
            case VK_SHIFT:
            case VK_CONTROL:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            // these are forwarded to the zoom window
                m_ctlPreview.SendMessage(uMsg, wParam, lParam);
                break;

            case VK_TAB:
                fHandled = OnNonSlideShowTab();
                break;

            case VK_ESCAPE:
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                _UpdateButtons(NOBUTTON);
                fHandled = TRUE;
                break;
        }
    }
    return 0;
}

// OnTBKeyEvent
//

LRESULT CPreviewWnd::OnTBKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    fHandled = FALSE;

    if (SLIDESHOW_MODE == m_dwMode && m_fToolbarHidden)
    {
        ShowSSToolbar(TRUE);
        m_ctlToolbar.SetFocus();
        m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
        m_iSSToolbarSelect = 0;
        fHandled = TRUE;
    }
    else
    {
        switch (wParam)
        {
        case VK_ESCAPE:
            if (WM_KEYDOWN == uMsg)
            {
                if (SLIDESHOW_MODE == m_dwMode)
                {
                    PostMessage(m_fExitApp ? WM_QUIT : WM_CLOSE, 0, 0);
                }
                else
                {
                    m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                    _UpdateButtons(NOBUTTON);
                    SetFocus();
                    SetActiveWindow();
                }
            }
            break;

        case VK_SHIFT:
        case VK_CONTROL:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
            // these are forwarded to the zoom window
            m_ctlPreview.SendMessage(uMsg, wParam, lParam);
            break;

        case VK_LEFT:
        case VK_RIGHT:
            if (WM_KEYDOWN == uMsg)
            {
                int iSel = (int)m_ctlToolbar.SendMessage(TB_GETHOTITEM, 0, 0);
                int iSize = (int)m_ctlToolbar.SendMessage(TB_BUTTONCOUNT, 0, 0);
                int iStepSize = (wParam == VK_RIGHT) ? 1 : iSize - 1; // ((pos + (size - 1))  % size) == left by 1
                if (iSel != -1)
                {
                    m_iSSToolbarSelect = iSel;
                }
                TBBUTTON tb = {0};
                do
                {
                    m_iSSToolbarSelect = (m_iSSToolbarSelect + iStepSize) % iSize;
                    m_ctlToolbar.SendMessage(TB_GETBUTTON, m_iSSToolbarSelect, (LPARAM)&tb);
                }
                while ((tb.fsStyle & TBSTYLE_SEP) || (tb.fsState & TBSTATE_HIDDEN) || !(tb.fsState & TBSTATE_ENABLED)); // don't stop on the separators
                m_ctlToolbar.SendMessage(TB_SETHOTITEM, m_iSSToolbarSelect, 0);
                fHandled = TRUE;
            }
            break;

        case VK_RETURN:
        case VK_SPACE:
            if ((WM_KEYDOWN == uMsg) && (SLIDESHOW_MODE == m_dwMode))
            {
                // to "press" the button, get its command id and sendmessage on it
                // TB_PRESSBUTTON doesn't work here, don't know why.
                // m_ctlToolbar.SendMessage(TB_PRESSBUTTON, m_iSSToolbarSelect, MAKELONG(TRUE, 0));
                TBBUTTON tbbutton;
                if (m_ctlToolbar.SendMessage(TB_GETBUTTON, m_iSSToolbarSelect, (LPARAM)&tbbutton))
                {
                    OnSlideshowCommand(0, (WORD)tbbutton.idCommand, NULL, fHandled);
                }
                fHandled = TRUE;
            }
            break;

        case VK_TAB:
            if ((WM_KEYDOWN == uMsg) && (CONTROL_MODE != m_dwMode))
            {
                // move focus back to the previewwnd
                SetFocus();
                fHandled = TRUE;
                ShowSSToolbar(FALSE);
                SetTimer(TIMER_TOOLBAR, m_uTimeout);
            }
            break;

        default:
            break;
        }
    }

    return 0;
}

LRESULT CPreviewWnd::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    fHandled = FALSE;
    
    if ((SLIDESHOW_MODE == m_dwMode) &&
        ((SC_MONITORPOWER == wParam) || (SC_SCREENSAVE == wParam)))
    {
        fHandled = TRUE;
    }

    return 0;
}

HRESULT CPreviewWnd::_PreviewFromStream(IStream *pStream, UINT iItem, BOOL fUpdateCaption)
{
    IRunnableTask * pTask;

    if (fUpdateCaption)
    {
        // set the caption here in case decode fails
        STATSTG stat;
        if (SUCCEEDED(pStream->Stat(&stat, 0)))
        {
            SetCaptionInfo(stat.pwcsName);
            CoTaskMemFree(stat.pwcsName);
        }
        else
        {
            SetCaptionInfo(NULL);
        }
    }

    HRESULT hr = CDecodeTask::Create(pStream, NULL, iItem, m_pImageFactory, m_hWnd, &pTask);
    if (SUCCEEDED(hr))
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
        hr = m_pTaskScheduler->AddTask(pTask, toid, 0, ITSAT_DEFAULT_PRIORITY);
        pTask->Release();
    }
    return hr;
}

HRESULT CPreviewWnd::_PreviewFromFile(LPCTSTR pszFile, UINT iItem, BOOL fUpdateCaption)
{
    IRunnableTask * pTask;

    if (fUpdateCaption)
    {
        // set the caption here in case decode fails
        SetCaptionInfo(pszFile);
    }

    HRESULT hr = CDecodeTask::Create(NULL, pszFile, iItem, m_pImageFactory, m_hWnd, &pTask);
    if (SUCCEEDED(hr))
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
        hr = m_pTaskScheduler->AddTask(pTask, toid, 0, ITSAT_DEFAULT_PRIORITY);
        pTask->Release();
    }

    return hr;
}

#define SLIDESHOW_CURSOR_NOTBUSY    0x0
#define SLIDESHOW_CURSOR_BUSY       0x1
#define SLIDESHOW_CURSOR_HIDDEN     0x2
#define SLIDESHOW_CURSOR_NORMAL     0x3
#define SLIDESHOW_CURSOR_CURRENT    0x4

void CPreviewWnd::SetCursorState(DWORD dwType)
{
    switch (dwType)
    {
    case SLIDESHOW_CURSOR_NOTBUSY:
        KillTimer(TIMER_BUSYCURSOR);
        if (m_fBusy) // ignore multiple NOTBUSY, which we receive for the precaching
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
            m_fBusy = FALSE;
        }
        break;
    case SLIDESHOW_CURSOR_BUSY:
        if (!m_fBusy)
        {
            m_hCurrent = LoadCursor(NULL, IDC_APPSTARTING);
            m_hCurOld = SetCursor(m_hCurrent);
            m_fBusy = TRUE;
        }
        break;
    case SLIDESHOW_CURSOR_HIDDEN:
        m_hCurOld = NULL;
        if (!m_fBusy)
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
        }
        break;
    case SLIDESHOW_CURSOR_NORMAL:
        m_hCurOld = LoadCursor(NULL, IDC_ARROW);
        if (!m_fBusy)
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
        }
        break;
    case SLIDESHOW_CURSOR_CURRENT:
        SetCursor(m_hCurrent);
        break;
    }
}

LRESULT CPreviewWnd::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (TIMER_ANIMATION == wParam)
    {
        KillTimer(TIMER_ANIMATION);
        if (m_pImageData && m_pImageData->IsAnimated() && _ShouldDisplayAnimations()) // might have switched pages between timer calls
        {
            if (m_pImageData->NextFrame())
            {
                SetTimer(TIMER_ANIMATION, m_pImageData->GetDelay());

                // paint the new image
                _UpdateImage();
            }
        }
    }
    else if (TIMER_DATAOBJECT == wParam)
    {
        KillTimer(TIMER_DATAOBJECT);    // on shot timer
        if (_pdtobj)
        {
            PreviewItemsFromUnk(_pdtobj);
            ATOMICRELEASE(_pdtobj);
        }
    }
    else if (TIMER_BUSYCURSOR == wParam)
    {
        SetCursorState(SLIDESHOW_CURSOR_BUSY);
    }
    else if (SLIDESHOW_MODE == m_dwMode)
    {
        if (TIMER_SLIDESHOW == wParam)
        {
            _ShowNextSlide(FALSE);  // always go forward?
        }
        else if (TIMER_TOOLBAR == wParam && !m_fIgnoreUITimers)
        {
            KillTimer(TIMER_TOOLBAR);
            ShowSSToolbar(FALSE);
        }
    }

    return 0;
}

void CPreviewWnd::ShowSSToolbar(BOOL bShow, BOOL fForce /*=FALSE*/)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (fForce)
        {
            POINT pt;
            RECT  rc;

            GetCursorPos(&pt);
            GetWindowRect(&rc);
            if (PtInRect(&rc, pt))
            {
                g_x = pt.x;
                g_y = pt.y;
            }
        }

        if (!bShow)
        {
            if (!m_fToolbarHidden || fForce)
            {
                //AnimateWindow(m_ctlToolbar.m_hWnd, 200, AW_VER_NEGATIVE | AW_SLIDE | AW_HIDE);
                m_ctlToolbar.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
                m_fToolbarHidden = TRUE;
                m_ctlToolbar.SendMessage(TB_SETHOTITEM, -1, 0);
                SetCursorState(SLIDESHOW_CURSOR_HIDDEN);
            }
        }
        else
        {
            KillTimer(TIMER_TOOLBAR);
            if (m_fToolbarHidden || fForce)
            {
                //AnimateWindow(m_ctlToolbar.m_hWnd, 200, AW_VER_POSITIVE | AW_SLIDE | AW_ACTIVATE);
                m_ctlToolbar.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
                m_fToolbarHidden = FALSE;
                SetCursorState(SLIDESHOW_CURSOR_NORMAL);
            }
            SetTimer(TIMER_TOOLBAR, m_uTimeout);
        }
    }
}

void CPreviewWnd::OnDraw(HDC hdc)
{
    if (m_fCropping)
    {
        CSelectionTracker tracker;
        _SetupCroppingTracker(tracker);

        CRect rectImage(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);
        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rectImage, 2);

        CRect rectCrop = m_rectCropping;
        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rectCrop, 2);

        HRGN hrgn = ::CreateRectRgn(0, 0, 0, 0);
        if (hrgn != NULL)
        {
            HRGN hrgnImage = ::CreateRectRgnIndirect(rectImage);
            if (hrgnImage != NULL)
            {
                HRGN hrgnCrop = ::CreateRectRgnIndirect(rectCrop);
                if (hrgnCrop != NULL)
                {
                    if (ERROR != ::CombineRgn(hrgn, hrgnImage, hrgnCrop, RGN_DIFF))
                    {
                        ::InvertRgn(hdc, hrgn);
                    }
                    ::DeleteObject(hrgnCrop);
                }
                ::DeleteObject(hrgnImage);
            }
            ::DeleteObject(hrgn);
        }

        tracker.Draw(hdc);
    }
    else
    {
        if (m_fAnnotating)
        {
            if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
            {
                CSelectionTracker tracker;
                _SetupAnnotatingTracker(tracker);

                tracker.Draw(hdc);
            }
        }
    }
}

void CPreviewWnd::OnDrawComplete()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (!m_fPaused)
            SetTimer(TIMER_SLIDESHOW, m_uTimeout);

        SetCursorState(SLIDESHOW_CURSOR_NOTBUSY);
    }
}

BOOL CPreviewWnd::OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (uMsg == WM_LBUTTONDOWN)
        {
            _ShowNextSlide(FALSE); // advance the slide (param is "go back?")

            return TRUE;
        }
    }
    else
    {
        if (m_fCropping)
            return _OnMouseDownForCropping(uMsg, wParam, lParam);
        else
            return _OnMouseDownForAnnotating(uMsg, wParam, lParam);
    }
    return FALSE;
}

BOOL CPreviewWnd::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        int xPos = GET_X_LPARAM(lParam);
        int yPos = GET_Y_LPARAM(lParam);
        int dx = xPos > g_x ? xPos - g_x : g_x - xPos;
        int dy = yPos > g_y ? yPos - g_y : g_y - yPos;

        if (dx > 10 || dy > 10)
        {
            ShowSSToolbar(TRUE);
        }

        g_x = xPos;
        g_y = yPos;
    }
    return TRUE;
}

LRESULT CPreviewWnd::OnTBMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_fTBTrack = FALSE;
        ShowSSToolbar(TRUE);
    }
    fHandled = FALSE;
    return 0;
}

LRESULT CPreviewWnd::OnTBMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (!m_fTBTrack)
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = m_ctlToolbar.m_hWnd;
            TrackMouseEvent(&tme);

            ShowSSToolbar(TRUE);
            KillTimer(TIMER_TOOLBAR); // we keep the toolbar down for as long as mouse is over it
            m_fTBTrack = TRUE;
        }
    }
    fHandled = FALSE;
    return 0;
}

BOOL CPreviewWnd::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (m_fToolbarHidden)
        {
            SetCursorState(SLIDESHOW_CURSOR_HIDDEN);
        }
        else
        {
            SetCursorState(SLIDESHOW_CURSOR_NORMAL);
        }
        return TRUE;
    }
    else if (m_fAnnotating)
    {
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
        {
            CSelectionTracker tracker;
            _SetupAnnotatingTracker(tracker);

            if (tracker.SetCursor(m_ctlPreview.m_hWnd, lParam))
                return TRUE;
        }
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return TRUE;
    }
    else if (m_fCropping)
    {
        CSelectionTracker tracker;
        _SetupCroppingTracker(tracker);

        if (tracker.SetCursor(m_ctlPreview.m_hWnd, lParam))
            return TRUE;

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return TRUE;
    }
    return FALSE;
}

BOOL CPreviewWnd::GetColor(COLORREF * pref)
{
    *pref = 0; // black
    if (SLIDESHOW_MODE == m_dwMode)
    {
        return TRUE;
    }
    return FALSE;
}

BOOL CPreviewWnd::OnSetColor(HDC hdc)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        SetBkColor(hdc, 0); // black
        SetTextColor(hdc, 0xffffff); // white
        return TRUE;
    }
    return FALSE;
}

// IObjectWithSite
HRESULT CPreviewWnd::SetSite(IUnknown *punk)
{
    IUnknown_Set(&m_punkSite, punk);
    if (m_pcwndSlideShow)
    {
        m_pcwndSlideShow->SetSite(punk);
    }
    return S_OK;
}

// This function take the name of the file being previewed and converts it into a
// title for the Full Screen Preview window.  In converting the title it take into
// account user preference settings for how to display the filename.
void CPreviewWnd::SetCaptionInfo(LPCTSTR pszPath)
{
    TCHAR szTitle[MAX_PATH] = TEXT("");
    TCHAR szDisplayName[MAX_PATH] = TEXT("");
    SHFILEINFO sfi = {0};
    //
    // Default to pszPath for the caption
    // pszPath is non-null before the decode is attempted
    if (pszPath)
    {
        if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES))
        {
            StrCpyN(szTitle, sfi.szDisplayName, ARRAYSIZE(szTitle));
            StrCatBuff(szTitle, TEXT(" - "), ARRAYSIZE(szTitle));
        }
    }

    TCHAR szApp[64];
    szApp[0] = 0;
    LoadString(_Module.GetModuleInstance(), IDS_PROJNAME, szApp, ARRAYSIZE(szApp));
    StrCatBuff(szTitle, szApp, ARRAYSIZE(szTitle));

    SetWindowText(szTitle);
}

LRESULT CPreviewWnd::OnDestroy(UINT , WPARAM , LPARAM , BOOL& fHandled)
{
    RevokeDragDrop(m_hWnd);
    _RegisterForChangeNotify(FALSE);
    FlushBitmapMessages();
    fHandled = FALSE;

    // Make sure we don't leak icons
    ReplaceWindowIcon(m_hWnd, ICON_SMALL, NULL);
    ReplaceWindowIcon(m_hWnd, ICON_BIG, NULL);

    // release the image lists used by the toolbar.
    HWND hwndTB = m_ctlToolbar.m_hWnd;
    HIMAGELIST himl = (HIMAGELIST)::SendMessage(hwndTB, TB_GETHOTIMAGELIST, 0, 0);
    ::SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, NULL);
    ImageList_Destroy(himl);

    himl = (HIMAGELIST)::SendMessage(hwndTB, TB_GETIMAGELIST, 0, 0);
    ::SendMessage(hwndTB, TB_SETIMAGELIST, 0, NULL);
    ImageList_Destroy(himl);

    if (WINDOW_MODE == m_dwMode)
    {
        WINDOWPLACEMENT wp;
        wp.length = sizeof(wp);

        if (GetWindowPlacement(&wp))
        {
            HKEY hk;
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_SHIMGVW, 0, NULL,
                                                 REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                                 NULL, &hk, NULL))
            {
                RegSetValueEx(hk, REGSTR_BOUNDS, NULL, REG_BINARY,
                                (BYTE*)&wp.rcNormalPosition, sizeof(wp.rcNormalPosition));

                BOOL fIsMaximized = (wp.showCmd == SW_SHOWMAXIMIZED);
                RegSetValueEx(hk, REGSTR_MAXIMIZED,  NULL, REG_BINARY,
                                (BYTE*)&fIsMaximized, sizeof(fIsMaximized));

                RegCloseKey(hk);
            }
        }

        PostQuitMessage(0);
    }

    return 0;
}

HRESULT CPreviewWnd::GetCurrentIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = _GetItem(m_iCurSlide, ppidl);
    if (FAILED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = PathFromImageData(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(szPath, ppidl, NULL);
        }
    }
    return hr;
}

void CPreviewWnd::MenuPoint(LPARAM lParam, int *px, int *py)
{
    if (-1 == lParam)
    {
        // message is from the keyboard, figure out where to place the window
        RECT rc;
        ::GetWindowRect(m_hWnd, &rc);
        *px = ((rc.left + rc.right) / 2);
        *py = ((rc.top + rc.bottom) / 2);
    }
    else
    {
        *px = GET_X_LPARAM(lParam);
        *py = GET_Y_LPARAM(lParam);
    }
}

#define ID_FIRST            1               // Context Menu ID's
#define ID_LAST             0x7fff

LRESULT CPreviewWnd::OnContextMenu(UINT , WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (!m_fAllowContextMenu)
        return 0;

    if (m_fCanAnnotate && m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        HMENU hpopup = CreatePopupMenu();
        if (hpopup)
        {
            CComBSTR bstrDelete;
            CComBSTR bstrProperties;
            if (bstrDelete.LoadString(IDS_DELETECMD) &&
                bstrProperties.LoadString(IDS_PROPERTIESCMD))
            {
                if (AppendMenu(hpopup, MF_STRING, ID_DELETECMD, bstrDelete) &&
                    AppendMenu(hpopup, MF_STRING, ID_PROPERTIESCMD, bstrProperties))
                {
                    int x, y;
                    MenuPoint(lParam, &x, &y);
                    TrackPopupMenu(hpopup, TPM_RIGHTBUTTON | TPM_LEFTALIGN, x, y, 0, m_hWnd, NULL);
                }
            }
            DestroyMenu(hpopup);
        }
        return 0;
    }

    LPITEMIDLIST pidl;
    HRESULT hr = GetCurrentIDList(&pidl); // gets the dynamically generated title for this window
    if (SUCCEEDED(hr))
    {
        IContextMenu *pcm;
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            HMENU hpopup = CreatePopupMenu();
            if (hpopup)
            {
                // SetSite required if you want in place navigation
                IUnknown_SetSite(pcm, SAFECAST(this, IServiceProvider *));
                hr = pcm->QueryContextMenu(hpopup, 0, ID_FIRST, ID_LAST, CMF_NORMAL);
                if (SUCCEEDED(hr))
                {
                    int x, y;
                    MenuPoint(lParam, &x, &y);
                    ASSERT(_pcm3 == NULL);
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3));
                    // if there's a separator after "copy", remove it
                    UINT uCopy = GetMenuIndexForCanonicalVerb(hpopup, pcm,ID_FIRST, L"copy");
                    if (uCopy != -1)
                    {
                        UINT uState = GetMenuState(hpopup, uCopy+1, MF_BYPOSITION);
                        if (-1 != uState && (uState & MF_SEPARATOR))
                        {
                            RemoveMenu(hpopup, uCopy+1, MF_BYPOSITION);
                        }
                    }
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"link");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"cut");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"copy");
                                        // the shell may have added a static Preview verb
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"open");



                    if (!m_fPaused)
                    {
                        TogglePlayState();
                    }

                    if (SLIDESHOW_MODE == m_dwMode)
                    {
                        m_fIgnoreUITimers = TRUE;
                    }

                    int idCmd = TrackPopupMenu(hpopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                           x, y, 0, m_hWnd, NULL);

                    ATOMICRELEASE(_pcm3);

                    if (idCmd > 0)
                    {
                        CMINVOKECOMMANDINFO cmdInfo =
                        {
                            sizeof(cmdInfo),
                            0,
                            m_hWnd,
                            (LPSTR)MAKEINTRESOURCE(idCmd - ID_FIRST),
                            NULL,
                            NULL,
                            SW_NORMAL
                        };
                        TCHAR szCommandString[40] = TEXT("");

                        ContextMenu_GetCommandStringVerb(pcm, idCmd - ID_FIRST, szCommandString, ARRAYSIZE(szCommandString));
                            
                        if (lstrcmpi(szCommandString, TEXT("edit")) == 0)
                        {
                            hr = _SaveIfDirty(TRUE);
                            if (S_OK != hr)
                            {
                                hr = E_ABORT;
                            }                           
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lstrcmpi(szCommandString, TEXT("print")) == 0)
                            {
                                _RefreshSelection(FALSE);
                                _InvokePrintWizard();
                            }
                            else
                            {
                                hr = pcm->InvokeCommand(&cmdInfo);
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lstrcmpi(szCommandString, TEXT("delete")) == 0)
                            {
                                _RemoveFromArray(m_iCurSlide);
                                _ShowNextSlide(FALSE);
                            }
                            else if (lstrcmpi(szCommandString, TEXT("edit")) == 0)
                            {
                                m_fDirty = FALSE;
                                m_fNoRestore = TRUE;

                                // RAID 414238: Image Preview Control
                                //  Context menu "&Edit" causes image preview window
                                //  to close, wrecking Explorer when in 'control mode'.
                                if (m_dwMode != CONTROL_MODE)
                                {
                                    PostMessage(WM_CLOSE, 0, 0);
                                }
                            }                           
                        }
                    }

                    if (SLIDESHOW_MODE == m_dwMode)
                    {
                        SetTimer(TIMER_TOOLBAR, m_uTimeout);
                        m_fIgnoreUITimers = FALSE;
                    }
                }
                IUnknown_SetSite(pcm, NULL);
                DestroyMenu(hpopup);
            }
            pcm->Release();
        }
        ILFree(pidl);
    }
    return 0;
}

int ClearCB(void *p, void *pData)
{
    SHFree(p);
    return 1;
}

void CPreviewWnd::_ClearDPA()
{
    if (m_ppidls)
    {
        for (UINT i = 0; i < m_cItems; i++)
            ILFree(m_ppidls[i]);

        CoTaskMemFree(m_ppidls);
        m_ppidls = NULL;
    }
    m_cItems = 0;
    m_iCurSlide = 0;
}

HRESULT CPreviewWnd::SetWallpaper(BSTR pszPath)
{
    return SUCCEEDED(SetWallpaperHelper(pszPath)) ? S_OK : S_FALSE;
}


HRESULT CPreviewWnd::StartSlideShow(IUnknown *punkToView)
{
    HRESULT hr = E_FAIL;

    if (NULL == punkToView)
        punkToView = m_punkSite;

    if (SLIDESHOW_MODE == m_dwMode)
    {
        // these are required for slideshow
        KillTimer(TIMER_SLIDESHOW);
        SetCursorState(SLIDESHOW_CURSOR_HIDDEN);

        m_fGoBack = FALSE;
        // if slide show was reopened cancel any previous tracking
        TRACKMOUSEEVENT tme = {0};
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_CANCEL | TME_LEAVE;
        tme.hwndTrack = m_ctlToolbar.m_hWnd;
        TrackMouseEvent(&tme);

        m_fTBTrack = FALSE;

        if (punkToView)
            hr = PreviewItemsFromUnk(punkToView);
        else
            hr = _PreviewItem(m_iCurSlide);

        if (SUCCEEDED(hr))
            m_fPaused = FALSE;
    }
    else
    {
        //create the slide show window

        // Full Screen
        if (m_pcwndSlideShow && m_pcwndSlideShow->m_hWnd)
        {
            RestoreAndActivate(m_pcwndSlideShow->m_hWnd);
        }
        else
        {
            // create the window
            if (!m_pcwndSlideShow)
            {
                m_pcwndSlideShow = new CPreviewWnd();
                if (!m_pcwndSlideShow)
                {
                    // out of memory
                    return E_OUTOFMEMORY;
                }
                else
                {
                    if (FAILED(m_pcwndSlideShow->Initialize(this, SLIDESHOW_MODE, FALSE)))
                    {
                        return E_OUTOFMEMORY;
                    }
                }
            }

            m_pcwndSlideShow->m_iCurSlide = m_iCurSlide;     // so the slide show stays in sync

            RECT rc = { 0,0,GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)};
            m_pcwndSlideShow->Create(NULL, rc, NULL, WS_VISIBLE | WS_POPUP);
        }

        hr = m_pcwndSlideShow->StartSlideShow(NULL);
    }
    return hr;
}

HRESULT CPreviewWnd::_GetItem(UINT iItem, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (iItem < m_cItems)
    {
        hr = SHILClone(m_ppidls[iItem], ppidl);
    }
    return hr;
}

void CPreviewWnd::_RemoveFromArray(UINT iItem)
{
    if (iItem < m_cItems)
    {
        ILFree(m_ppidls[iItem]);  // this one is now gone

        // slide all other pidls down in the array
        for (UINT i = iItem + 1; i < m_cItems; i++)
        {
            m_ppidls[i - 1] = m_ppidls[i];
        }
        m_cItems--;
        m_ppidls[m_cItems] = NULL;    // make sure stale ptr is now NULL

        // if we deleted an item before m_iCurSlide then we must adjust m_iCurSlide
        if (iItem < m_iCurSlide)
        {
            m_iCurSlide--;
        }
        else if (m_iCurSlide == m_cItems)
        {
            m_iCurSlide = 0;
        }
        // Now prepare for "ShowNextSlide"
        if (!m_iCurSlide)
        {
            m_iCurSlide = m_cItems ? m_cItems-1 : 0;
        }
        else
        {
            m_iCurSlide--;
        }
        // make sure the prefetch task has the right index
        if (m_pNextImageData)
        {
            if (!(m_pNextImageData->_iItem) && iItem && m_cItems)
            {
                m_pNextImageData->_iItem = m_cItems-1;
            }
            else if (m_pNextImageData->_iItem > iItem)
            {
                m_pNextImageData->_iItem--;
            }
            else
            {
                FlushBitmapMessages();
                ATOMICRELEASE(m_pNextImageData);            
            }                
        }
    }
}

HRESULT CPreviewWnd::_DeleteCurrentSlide()
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetItem(m_iCurSlide, &pidl);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH + 1] = {0}; // +1 and zero init for dbl NULL terminate extra terminator
        DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_STREAM;
        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath)-1, &dwAttribs);
        if (SUCCEEDED(hr))
        {
            BOOL fSuccess = TRUE;
            if (dwAttribs & SFGAO_FILESYSTEM)
            {
                SHFILEOPSTRUCT fo = {0};
                fo.hwnd = m_hWnd;
                fo.wFunc = FO_DELETE;
                fo.pFrom = szPath;
                fo.fFlags = FOF_ALLOWUNDO;
                fo.fAnyOperationsAborted = FALSE;
                if (SHFileOperation(&fo) == ERROR_SUCCESS)
                {
                    if (fo.fAnyOperationsAborted == TRUE)
                        fSuccess = FALSE;
                }
            }
            else
            {
                _InvokeVerb(TEXT("delete"));
                // We have to assume success since there is no way to know if the user
                // cancelled the confirmation dialog without hitting the camera again.
            }

            if (fSuccess)
            {
                m_fDirty = FALSE;
                _RemoveFromArray(m_iCurSlide);
                _ShowNextSlide(FALSE);
            }
        }

        ILFree(pidl);
    }
    return hr;
}

// index can be either current or next slide so that user can click multiple times on next/prev button
HRESULT CPreviewWnd::_ShowNextSlide(BOOL bGoBack)
{
    HRESULT hr = E_FAIL;

    if (m_cItems)
    {
        if (bGoBack)
        {
            if (m_iCurSlide)
                m_iCurSlide--;
            else
                m_iCurSlide = m_cItems - 1;
        }
        else
        {
            m_iCurSlide++;
            if (m_iCurSlide >= m_cItems)
                m_iCurSlide = 0;
        }
    

        if (!m_fPaused)
        {
            SetTimer(TIMER_SLIDESHOW, m_uTimeout);
        }
        SetTimer(TIMER_BUSYCURSOR, 500);

        LPITEMIDLIST pidl;
        // set the caption in case the load fails
        if (SUCCEEDED(_GetItem(m_iCurSlide, &pidl)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szPath, ARRAYSIZE(szPath)-1, NULL)))
            {
                SetCaptionInfo(szPath);
            }
            else
            {
                SetCaptionInfo(NULL);
            }
            ILFree(pidl);
        }
        hr = _PreviewItem(m_iCurSlide);

        if (SUCCEEDED(hr))
        {
            _PreLoadItem((m_iCurSlide + 1) % m_cItems);
        }
    }

    return hr;
}


HRESULT CPreviewWnd::_StartDecode(UINT iItem, BOOL fUpdateCaption)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetItem(iItem, &pidl);
    
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_STREAM;
        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttribs);
        if (SUCCEEDED(hr) && (dwAttribs & SFGAO_FILESYSTEM))
        {
            hr = _PreviewFromFile(szPath, iItem, fUpdateCaption);
        }
        else if (dwAttribs & SFGAO_STREAM)
        {
            // this might not be a file system object, try to bind to it via IStream
            IStream *pstrm;

            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IStream, pidl, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = _PreviewFromStream(pstrm, iItem, fUpdateCaption);
                pstrm->Release();
            }
        }
        else
        {
            // funky attributes?
            hr = S_FALSE;
        }
        ILFree(pidl);
    }
    return hr;
}

HRESULT CPreviewWnd::_PreLoadItem(UINT iItem)
{
    HRESULT hr = _StartDecode(iItem, FALSE);
    if (SUCCEEDED(hr))
    {
        m_iDecodingNextImage = iItem;
    }
    return hr;
}

HRESULT CPreviewWnd::_PreviewItem(UINT iItem)
{
    HRESULT hr = S_OK;

    if ((SLIDESHOW_MODE == m_dwMode) && (0 == m_cItems)) // if no more items, user just deleted the last one, so quit the slideshow
    {
        _CloseSlideshowWindow();
    }
    else
    {
        if (!_TrySetImage())
        {
            // If we are not currently already decoding this item, let's get cranking!
            if (m_iDecodingNextImage != iItem)
            {
                hr = _StartDecode(iItem, TRUE);
            }

            StatusUpdate((S_OK == hr) ? IDS_LOADING : IDS_LOADFAILED);
        }
    }

    return hr;
}

int CPreviewWnd::TranslateAccelerator(MSG *pmsg)
{
    if (IsVK_TABCycler(pmsg))
    {
        if (OnNonSlideShowTab())
        {
            return TRUE;
        }
    }
    else if (m_haccel)
    {
        ASSERT(m_hWnd);
        return ::TranslateAccelerator(m_hWnd, m_haccel, pmsg);
    }
    return FALSE;
}

// Sent when the image generation status has changed, once when the image is first
// being created and again if there is an error of any kind.  This should invalidate
// and free any left over bitmap and the cached copy of the previous m_ImgCtx
void CPreviewWnd::StatusUpdate(int iStatus)
{
    if (m_pImageData)
    {
        m_pImageData->Release();
        m_pImageData = NULL;
    }
    
    //
    // the caption is set at the first attempt to load an image
    m_ctlPreview.StatusUpdate(iStatus);

    _SetMultipageCommands();
    _SetMultiImagesCommands();
    _SetAnnotatingCommands(FALSE);
    _SetEditCommands();

    m_fPrintable = FALSE;
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PRINTCMD, MAKELONG(m_fPrintable, 0));

    // update our toolbar
    BOOL fHandled;
    OnSize(0x0, 0, 0, fHandled);
}

// Return:
//  S_OK    walk succeeded, image files found to preview:  display new images in preview
//  S_FALSE walk cancelled (by user):  display existing image in preview (no change)
//  E_XXXX  walk failed:  display no image in preview
//
HRESULT CPreviewWnd::WalkItemsToPreview(IUnknown* punk)
{
    HRESULT hr = _SaveIfDirty(TRUE);
    if (FAILED(hr) || hr == S_FALSE)
        return hr;

    
    m_fFirstItem = TRUE;
    
    
    _ClearDPA(); // clean up old stuff

    INamespaceWalk *pnsw;
    hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        // in control mode we only dislay one item at a time. lets setup our
        // state so this can work just like the other modes
        DWORD dwFlags = (CONTROL_MODE == m_dwMode) ? 0 : NSWF_ONE_IMPLIES_ALL | NSWF_NONE_IMPLIES_ALL;      
        m_fClosed = FALSE;
        hr = pnsw->Walk(punk, dwFlags, m_cWalkDepth, SAFECAST(this, INamespaceWalkCB *));
        // the window might have been closed during the namespace walk
        if (WINDOW_MODE == m_dwMode && m_fClosed)
        {
            hr = E_FAIL;
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pnsw->GetIDArrayResult(&m_cItems, &m_ppidls);
            if (SUCCEEDED(hr) && (m_dwMode == WINDOW_MODE) && m_cItems && m_fFirstTime)
            {
                m_fFirstTime = FALSE;
                SHAddToRecentDocs(SHARD_PIDL, m_ppidls[0]);
            }
        }
        pnsw->Release();
    }
    

    // Clarification of INamespaceWalk return values:
    //  S_OK    walk has succeeded, and image files found to preview
    //  S_FALSE walk has succeeded, but no image files found to preview
    //          **** convert to E_FAIL to keep in line with return of function
    //  E_XXXX  walk has failed
    //
    return hr == S_FALSE ? E_FAIL : hr;
}

void CPreviewWnd::PreviewItems()
{
    if (WINDOW_MODE == m_dwMode)
    {
        RestoreAndActivate(m_hWnd);
    }
    _PreviewItem(0);
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (m_cItems > 1)
        {
            _PreLoadItem(1);
        }
    }
}

// build the _ppidl and m_cItems members and preview the first one
HRESULT CPreviewWnd::PreviewItemsFromUnk(IUnknown *punk)
{
    HRESULT hr = WalkItemsToPreview(punk);
    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
            PreviewItems();
    }
    else
    {
        StatusUpdate(IDS_LOADFAILED);
    }

    return hr;
}

// If the "new" image is the same as the old image, and the old image was recently edited then we assume that
// the reason we are getting a new ShowFile request is due to an FSChangeNotify on the file.  We also assume
// that we are the cause of this change notify.  Further we assume that we already have the correctly decoded
// image still ready.  These are assumptions which might not be TRUE 100%, in which case we will do really
// strange things, but they should be TRUE 99.9% of the time which is considered "good enough".  The reason we
// make these dangerous assumptions is to prevent decoding the image again and thus flickering between the
// old image, the "generating preview..." message, and the new (identical) image.

BOOL CPreviewWnd::_ReShowingSameFile(LPCTSTR pszNewFile)
{
    BOOL bIsSameFile = FALSE;
    if (m_pImageData)
    {
        if (pszNewFile && m_fWasEdited)
        {
            m_fWasEdited = FALSE;

            TCHAR szOldPath[MAX_PATH];
            if ((S_OK == PathFromImageData(szOldPath, ARRAYSIZE(szOldPath))) &&
                (0 == StrCmpI(szOldPath, pszNewFile)))
            {
                if (m_pEvents)
                    m_pEvents->OnPreviewReady();

                bIsSameFile = TRUE;
            }
        }

        if (!bIsSameFile)
        {
            m_pImageData->Release();    // need to start clean
            m_pImageData = NULL;
        }
    }
    return bIsSameFile;
}

// pszFile may be NULL. cItems expresses how many are selected so we can
// display "multiple items selected" and not display anything.

LRESULT CPreviewWnd::ShowFile(LPCTSTR pszFile, UINT cItems, BOOL fReshow)
{
    if (!m_hWnd)
        return S_FALSE;

    HRESULT hr = S_FALSE;

    TCHAR szLongName[MAX_PATH]; // short file names are UGLY
    if (GetLongPathName(pszFile, szLongName, ARRAYSIZE(szLongName)))
    {
        pszFile = szLongName;
    }

    if (!fReshow && _ReShowingSameFile(pszFile))
        return S_FALSE;

    // It is possible that there is already a bitmap message in our queue from the previous rendering.
    // If this is the case we should remove that message and release its bitmap before we continue.
    // If we do not then that message will get processed and will send the OnPreviewReady event to the
    // obejct container but this event might no longer be valid.
    FlushBitmapMessages();

    if (pszFile && *pszFile)
    {
        IDataObject *pdtobj;
        hr = GetUIObjectFromPath(pszFile, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            hr = PreviewItemsFromUnk(pdtobj);
            m_fPaused = TRUE;
            pdtobj->Release();
        }
    }
    else
    {
        int iRetCode = (cItems > 1) ? IDS_MULTISELECT : IDS_NOPREVIEW;

        // Set the Return Code into all owned zoom windows.  This instructs these windows to disregard
        // their previous images and display the status message instead.
        StatusUpdate(iRetCode);
    }

    return hr;
}

LRESULT CPreviewWnd::IV_OnIVScroll(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    DWORD nHCode = LOWORD(lParam);
    DWORD nVCode = HIWORD(lParam);
    if (nHCode)
    {
        m_ctlPreview.SendMessage(WM_HSCROLL, nHCode, NULL);
    }
    if (nVCode)
    {
        m_ctlPreview.SendMessage(WM_VSCROLL, nVCode, NULL);
    }
    return 0;
}


// IV_OnSetOptions
//
// This message is sent to turn on or off all the optional features of the image preview control.
// NOTE: When used as a control this function is called BEFORE the window is created.  Don't do
// anything in this function that will fail without a window unless you check for this condition.
LRESULT CPreviewWnd::IV_OnSetOptions(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    BOOL bResult = TRUE;

    // Boolify lParam just to be safe.
    lParam = lParam ? 1:0;

    switch (wParam)
    {
    case IVO_TOOLBAR:
        if ((BOOL)lParam != m_fShowToolbar)
        {
            m_fShowToolbar = (BOOL)lParam;
            if (m_hWnd)
            {
                if (m_fShowToolbar)
                {
                    if (!m_ctlToolbar)
                    {
                        bResult = CreateToolbar();
                        if (!bResult)
                        {
                            m_fShowToolbar = FALSE;
                            break;
                        }
                    }
                }
                else
                {
                    if (m_ctlToolbar)
                    {
                        m_ctlToolbar.DestroyWindow();
                    }
                }
            }
        }
        break;

    case IVO_PRINTBTN:
        if ((BOOL)lParam != m_fHidePrintBtn)
        {
            m_fHidePrintBtn = (BOOL)lParam;
            if (m_hWnd && m_ctlToolbar)
            {
                m_ctlToolbar.SendMessage(TB_HIDEBUTTON,ID_PRINTCMD,lParam);
            }
        }
        break;

    case IVO_CONTEXTMENU:
        m_fAllowContextMenu = (BOOL)lParam;
        break;

    case IVO_PRINTABLE:
        TraceMsg(TF_WARNING, "Obsolete IVO_PRINTABLE option received.");
        break;

    case IVO_DISABLEEDIT:
        m_fDisableEdit = (BOOL)lParam;
        break;

    default:
        break;
    }

    return bResult;
}

void CPreviewWnd::_SetEditCommands()
{
    if (CONTROL_MODE != m_dwMode)
    {
        // We can save if we have a file; the save dialog will show available encoders
        BOOL fCanSave = m_pImageData ? TRUE : FALSE;

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_SAVEASCMD, MAKELONG(!fCanSave, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_SAVEASCMD, MAKELONG(fCanSave, 0));
    }

    BOOL fCanRotate = m_pImageData != NULL;
    if (CONTROL_MODE != m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATESEP, MAKELONG(!fCanRotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATE90CMD, MAKELONG(!fCanRotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATE270CMD, MAKELONG(!fCanRotate, 0));
    }
    else
    {
        // we don't rotate multi-page images in control mode 
        fCanRotate = fCanRotate && !m_pImageData->IsMultipage();
    }

    // No matter where we are GDIPlus can't rotate WMF or EMF files. Curiously,
    // we will let you rotate ICO files, but because we don't have an encoder
    // we won't save them :)
    if (fCanRotate)
    {
        fCanRotate = !(IsEqualGUID(ImageFormatWMF, m_pImageData->_guidFormat) ||
                       IsEqualGUID(ImageFormatEMF, m_pImageData->_guidFormat) ||
                       m_pImageData->IsAnimated());
    }

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATESEP, MAKELONG(fCanRotate, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(fCanRotate, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(fCanRotate, 0));
    TCHAR szFile[MAX_PATH];
    BOOL fCanOpen = SUCCEEDED(PathFromImageData(szFile, ARRAYSIZE(szFile)));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_OPENCMD, MAKELONG(fCanOpen, 0));

}

void CPreviewWnd::_UpdatePageNumber()
{
    TCHAR szText[20];
    wnsprintf(szText, ARRAYSIZE(szText), TEXT("%d"), m_pImageData->_iCurrent+1);

    TBBUTTONINFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.dwMask = TBIF_TEXT | TBIF_STATE;
    bi.fsState = TBSTATE_ENABLED;
    bi.pszText = szText;
    m_ctlToolbar.SendMessage(TB_SETBUTTONINFO, ID_PAGELIST, (LPARAM)&bi);
}

void CPreviewWnd::_SetMultipageCommands()
{
    DWORD dwMode;

    // this code relies on the fact that TIFFs are the only multipage format we view
    if (!m_pImageData || m_pImageData->_guidFormat != ImageFormatTIFF )
    {
        dwMode = MPCMD_HIDDEN;
    }
    else if (!m_pImageData->IsMultipage())
    {
        dwMode = MPCMD_DISABLED;
    }
    else if (m_pImageData->IsFirstPage())
    {
        dwMode = MPCMD_FIRSTPAGE;
    }
    else if (m_pImageData->IsLastPage())
    {
        dwMode = MPCMD_LASTPAGE;
    }
    else
    {
        dwMode = MPCMD_MIDDLEPAGE;
    }

    // remember which buttons are enabled/hidden so we can quickly create our context menu
    if (dwMode != m_dwMultiPageMode)
    {
        m_dwMultiPageMode = dwMode;

        if (CONTROL_MODE != m_dwMode)
        {
            // Switch accelerator tables so that Page Up and Page Down work
            if (dwMode == MPCMD_HIDDEN || dwMode == MPCMD_DISABLED)
            {
                m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_SINGLEPAGE));
            }
            else
            {
                m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_MULTIPAGE));
            }

            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PAGECMDSEP,  MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PREVPAGECMD, MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PAGELIST,    MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NEXTPAGECMD, MAKELONG((MPCMD_HIDDEN==dwMode),0));

            if (MPCMD_HIDDEN != dwMode)
            {
                _UpdatePageNumber();

                m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PREVPAGECMD, MAKELONG((MPCMD_FIRSTPAGE!=dwMode && MPCMD_DISABLED!=dwMode),0));
                m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NEXTPAGECMD, MAKELONG((MPCMD_LASTPAGE !=dwMode && MPCMD_DISABLED!=dwMode),0));
            }
        }
    }
    else
    {
        if (CONTROL_MODE != m_dwMode)
        {
            if (dwMode == MPCMD_MIDDLEPAGE)
            {
                _UpdatePageNumber();
            }
        }
    }
}

void CPreviewWnd::_SetMultiImagesCommands()
{
    BOOL bHasFiles = m_cItems;
    if (CONTROL_MODE != m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PREVIMGCMD, MAKELONG(!bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NEXTIMGCMD, MAKELONG(!bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_VIEWCMDSEP, MAKELONG(!bHasFiles, 0));

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PREVIMGCMD, MAKELONG(bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NEXTIMGCMD, MAKELONG(bHasFiles, 0));
    }
}

HRESULT CPreviewWnd::PathFromImageData(LPTSTR pszFile, UINT cch)
{
    *pszFile = 0;

    IShellImageData *pSID;
    HRESULT hr = m_pImageData ? m_pImageData->Lock(&pSID) : E_FAIL;
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;
        hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            WCHAR *psz;
            hr = ppf->GetCurFile(&psz);
            if (SUCCEEDED(hr))
            {
                lstrcpyn(pszFile, psz, cch);
                CoTaskMemFree(psz);
            }
            ppf->Release();
        }
        m_pImageData->Unlock();
    }
    return hr;
}

HRESULT CPreviewWnd::ImageDataSave(LPCTSTR pszFile, BOOL bShowUI)
{
    IShellImageData * pSID = NULL;
    HRESULT hr = m_pImageData ? m_pImageData->Lock(&pSID) : E_FAIL;
    Image *pimgRestore = NULL;
    if (SUCCEEDED(hr))
    {
        GUID guidFmt = GUID_NULL;
        BOOL bSave = TRUE;
        BOOL bWarnBurn = FALSE;
        BOOL bRestoreParams = FALSE;
        pSID->GetRawDataFormat(&guidFmt);
        // if saving to a jpeg, set the image quality to high
        // if pszFile is NULL, we're saving the same file, so don't promote the image quality
        if (pszFile)
        {
            m_pImageFactory->GetDataFormatFromPath(pszFile, &guidFmt);
            if (guidFmt == ImageFormatJPEG )
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHCreatePropertyBagOnMemory(STGM_READWRITE,
                                                          IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    // write the quality value for the recompression into the property bag
                    // we have to write the format too...CImageData relies on "all or nothing"
                    // from the encoder params property bag
                     VARIANT var;
                     hr = InitVariantFromGUID(&var, ImageFormatJPEG);
                     if (SUCCEEDED(hr))
                     {
                         ppb->Write(SHIMGKEY_RAWFORMAT, &var);
                         VariantClear(&var);
                     }
                     SHPropertyBag_WriteInt(ppb, SHIMGKEY_QUALITY, 100);
                     pSID->SetEncoderParams(ppb);
                     ppb->Release();
                     bRestoreParams = TRUE;
                 }
            }
        }
        if (bShowUI && pszFile)
        {
            // warn the user if saving from TIFF to something that will lose annotations

            BOOL bDestTiff = ImageFormatTIFF == guidFmt;
            BOOL bAnnot = m_ctlPreview.GetAnnotations()->GetCount() > 0;
            bWarnBurn = bAnnot && !bDestTiff;

            #if 0
            if (!bWarnBurn && S_OK == m_pImageData->IsMultipage() && !bDestTiff)
            {
                GUID guidFmt;
                bWarnBurn = TRUE;
                if (SUCCEEDED(m_pImageFactory->GetDataFormatFromPath(pszFile, &guidFmt)))
                {
                    bWarn = !FmtSupportsMultiPage(pSID, &guidFmt);
                }
            }
            #endif // 0 Put the multipage warning back in if needed, and change the wording of IDS_SAVE_WARN_TIFF
        }

        if (bWarnBurn)
        {
            m_fPromptingUser = TRUE;
            bSave = (IDYES == ShellMessageBox(_Module.GetModuleInstance(), m_hWnd,
                                                 MAKEINTRESOURCE(IDS_SAVE_WARN_TIFF),
                                                 MAKEINTRESOURCE(IDS_PROJNAME),
                                                 MB_YESNO | MB_ICONINFORMATION));
            m_fPromptingUser = FALSE;
            
            if (bSave)
            {
                // Save the current image frame to restore after the save to a different file is complete
                pimgRestore = _BurnAnnotations(pSID);
            }
        }
        if (bSave)
        {
            IPersistFile *ppf;
            hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                // if saving to the same file name, make sure
                // the changenotify code ignores the notify this will generate
                //
                if (!pszFile)
                {
                    m_fIgnoreNextNotify = TRUE;
                }
                hr = ppf->Save(pszFile, FALSE);
                if (SUCCEEDED(hr))
                {
                    m_fWasEdited = TRUE;
                }
                else if (!pszFile)
                {
                    m_fIgnoreNextNotify = FALSE;
                }
            }
            ppf->Release();
            if (pimgRestore)
            {
                pSID->ReplaceFrame(pimgRestore);
            }
        }
        else
        {
            hr = S_FALSE; // we did nothing
        }
        if (bRestoreParams)
        {
            pSID->SetEncoderParams(NULL);
        }
        m_pImageData->Unlock();
    }
    return hr;
}

HRESULT CPreviewWnd::_SaveAsCmd()
{
    if (m_pImageData == NULL)
        return S_OK;


    OPENFILENAME ofn = {0};
    TCHAR szOrgFile[MAX_PATH];
    TCHAR szExt[MAX_PATH]={0};
    PathFromImageData(szOrgFile, ARRAYSIZE(szOrgFile));
    LPTSTR psz = PathFindExtension(szOrgFile);
    StrCpyN(szExt, psz, ARRAYSIZE(szExt));

    TCHAR szFile[MAX_PATH];
    if (!m_fDisableEdit && m_fCanSave && m_pImageData->IsEditable())
    {
        // If we haven't explicitly been told not to and the file is writeable then
        // suggest saving on top of the current image
        PathFromImageData(szFile, ARRAYSIZE(szFile));
    }
    else
    {
        // Otherwise suggest New Image.jpg
        LoadString(_Module.GetModuleInstance(), IDS_NEW_FILENAME, szFile, ARRAYSIZE(szFile));
    }

    CComBSTR bstrTitle;
    bstrTitle.LoadString(IDS_SAVEAS_TITLE);

    ofn.lStructSize = sizeof(ofn);
    PathRemoveExtension(szFile);
    TCHAR szFilter[MAX_PATH] = TEXT("\0");
    ofn.nFilterIndex = _GetFilterStringForSave(szFilter, ARRAYSIZE(szFilter), szExt);
    ofn.lpstrFilter = szFilter;
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFile = szFile;
    ofn.lpstrTitle = bstrTitle;
    ofn.nMaxFile = MAX_PATH - lstrlen(szExt);
    ofn.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_ENABLESIZING;
    ofn.lpstrDefExt = *szExt == TEXT('.') ? szExt + 1: szExt;

    m_fPromptingUser = TRUE;
    BOOL bResult = ::GetSaveFileName(&ofn);
    m_fPromptingUser = FALSE;

    if (bResult != 0)
    {
        m_ctlPreview.CommitAnnotations();
        HRESULT hr = ImageDataSave(szFile, TRUE);
        if (S_OK == hr)
        {
           if (lstrcmpi(szFile, szOrgFile) == 0)
           {
                _UpdateImage();
                ShowFile(szFile, 1);
                m_fDirty = FALSE;
           }
        }
        else if (FAILED(hr))
        {
            // If we failed to save then we are corrupt and need to be reloaded
            // If we were just copying then only show the message
            if (lstrcmpi(szFile, szOrgFile) == 0)
            {
                _UpdateImage();
                ShowFile(szOrgFile, 1, TRUE);
                m_fDirty = FALSE;
            }
            else
            {
                // delete the failed copy
                DeleteFile(szFile);
            }

            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_SAVEFAILED_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
                return E_FAIL;
            }
        }
    }
    else
    {
        DWORD dwResult = CommDlgExtendedError();
        if (dwResult == FNERR_BUFFERTOOSMALL)
        {
            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_NAMETOOLONG_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
            }
        }
        return S_FALSE; // User probably cancelled
    }
    return S_OK;
}

void CPreviewWnd::_PropertiesCmd()
{
    if (m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

        if (!pAnnotation->HasWidth() && !pAnnotation->HasTransparent() && !pAnnotation->HasColor() && pAnnotation->HasFont())
        {
            CHOOSEFONT cf = {0};

            LOGFONT lfFont;
            pAnnotation->GetFont(lfFont);
            COLORREF crFont = pAnnotation->GetFontColor();

            cf.lStructSize = sizeof(cf);
            cf.hwndOwner = m_hWnd;
            cf.lpLogFont = &lfFont;
            cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
            cf.rgbColors = crFont;

            m_fPromptingUser = TRUE;
            BOOL bResult = ::ChooseFont(&cf);
            m_fPromptingUser = FALSE;
            
            if (bResult)
            {
                crFont = cf.rgbColors;
                lfFont.lfHeight = (lfFont.lfHeight > 0) ? lfFont.lfHeight : -lfFont.lfHeight;
                pAnnotation->SetFont(lfFont);
                pAnnotation->SetFontColor(crFont);
                m_fDirty = TRUE;

                CRegKey Key;
                if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                {
                    Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                }

                if (Key.m_hKey != NULL)
                {
                    Key.SetValue(crFont, REGSTR_TEXTCOLOR);
                    ::RegSetValueEx(Key, REGSTR_FONT, 0, REG_BINARY, (LPBYTE)&lfFont, sizeof(lfFont));
                }
                _RefreshSelection();
            }
        }
        else
        {
            m_fPromptingUser = TRUE;
            INT_PTR iResult = DialogBoxParam(_Module.GetModuleInstance(),
                                            MAKEINTRESOURCE(IDD_ANNOPROPS),
                                            m_hWnd, _AnnoPropsDlgProc, (LPARAM)this);
            m_fPromptingUser = FALSE;
        }
    }
    else
    {
        // Under these condition the has pressed Ctrl-I to get File Properties
        // So serve them up.
        CComBSTR bstrSummary;
        bstrSummary.LoadString(IDS_SUMMARY);
        _InvokeVerb(TEXT("properties"), bstrSummary);
    }
}

HRESULT _VerbMatches(LPCWSTR pszFile, LPCWSTR pszVerb, LPCTSTR pszOurs)
{
    TCHAR szTemp[MAX_PATH];
    DWORD cch = ARRAYSIZE(szTemp);
    HRESULT hr = AssocQueryString(ASSOCF_VERIFY, ASSOCSTR_COMMAND, pszFile, pszVerb, szTemp, &cch);
    if (SUCCEEDED(hr))
    {
        hr = (StrStrI(szTemp, pszOurs)) ? S_OK : S_FALSE;
    }
    return hr;
}

void CPreviewWnd::_OpenCmd()
{
    HRESULT hr = _SaveIfDirty(TRUE);
    LPCTSTR pszVerb;
    if (S_OK == hr)
    {
        TCHAR szFile[MAX_PATH];
        hr = PathFromImageData(szFile, ARRAYSIZE(szFile));
        if (SUCCEEDED(hr))
        {
            HRESULT hrOpen = _VerbMatches(szFile, L"open", TEXT("shimgvw.dll"));
            HRESULT hrEdit = _VerbMatches(szFile, L"edit", TEXT("mspaint.exe"));
            // if edit is empty, or if edit is mspaint and open is not shimgvw, use the open verb instead
            if (SUCCEEDED(hrEdit))
            {
                if (S_OK == hrEdit && hrOpen == S_FALSE)
                {
                    pszVerb = TEXT("open");
                }
                else
                {
                    pszVerb = TEXT("edit");
                }
            }
            else if (hrOpen == S_FALSE)
            {
                pszVerb = TEXT("open");
            }
            else
            {
                pszVerb = TEXT("openas");
            }
            hr = _InvokeVerb(pszVerb);
        }
        if (FAILED(hr))
            return;

        // set m_fNoRestore to avoid the rotation confirmation restoration popup-ation
        m_fNoRestore = TRUE;
        // The user had a chance to save but may have said no. Pretend we're not dirty
        m_fDirty = FALSE;
        PostMessage(WM_CLOSE, 0, 0);
    }
}

BOOL CPreviewWnd::_CanAnnotate(CDecodeTask * pImageData)
{
    // If we have an image and its encoder and we haven't been explicitly told not to allow editing
    // and the image is writeable
    if (m_pImageData && m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // then if its a TIFF we can annotate it
        return IsEqualGUID(ImageFormatTIFF, pImageData->_guidFormat);
    }
    return FALSE;
}

BOOL CPreviewWnd::_CanCrop(CDecodeTask * pImageData)
{
    if (m_pImageData != NULL)
    {
// REVIEW I added this for CyraR as a proof of concept. If we decide to support it
// we still need to catch all the places where we should save the croppped image and
// call GDIplus to accomplish the crop.
#ifdef SUPPORT_CROPPING
        if (S_OK != m_pImageData->IsEditable())
            return FALSE;

        LONG cPages;
        if (S_OK == m_pImageData->GetPageCount(&cPages))
        {
            if (cPages > 1)
                return FALSE;
        }
        return TRUE;
#endif
    }
    return FALSE;
}

// Called whenever the image changes to hide or show the annotation buttons.
void CPreviewWnd::_SetAnnotatingCommands(BOOL fEnableAnnotations)
{
    if (CONTROL_MODE != m_dwMode)
    {
        if (fEnableAnnotations)
        {
            m_fCanAnnotate = TRUE;
            m_fAnnotating = FALSE;
        }
        else
        {
            if (m_fAnnotating)
            {
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            }

            m_fCanAnnotate = FALSE;
            m_fAnnotating = FALSE;
        }

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_SELECTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ANNOTATESEP, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_FREEHANDCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_HIGHLIGHTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_LINECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_FRAMECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_RECTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_TEXTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NOTECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PROPERTIESCMD, MAKELONG(!m_fCanAnnotate, 0));

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_SELECTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ANNOTATESEP, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_FREEHANDCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_HIGHLIGHTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_LINECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_FRAMECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_RECTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_TEXTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NOTECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(FALSE, 0));
    }
}

void CPreviewWnd::_SetCroppingCommands(BOOL fEnableCropping)
{
    if (CONTROL_MODE != m_dwMode)
    {
        if (fEnableCropping)
        {
            m_fCanCrop = TRUE;
            m_fCropping = FALSE;
        }
        else
        {
            if (m_fCropping)
            {
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            }

            m_fCanCrop = FALSE;
            m_fCropping = FALSE;
        }

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_CROPCMD, MAKELONG(!m_fCanCrop, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_CROPCMD, MAKELONG(m_fCanCrop, 0));
    }
}

// Called on Toolbar command to fix the state of the other buttons.
void CPreviewWnd::_UpdateButtons(WORD wID)
{
    if (CONTROL_MODE != m_dwMode)
    {
        switch (wID)
        {
        case NOBUTTON:
        case ID_ZOOMINCMD:
        case ID_ZOOMOUTCMD:
        case ID_SELECTCMD:
        case ID_CROPCMD:
            m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
            if (m_fCanAnnotate)
            {
                m_wNewAnnotation = 0;
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
                m_fAnnotating = (wID == ID_SELECTCMD);
            }
            if (m_fCanCrop)
            {
                m_fCropping = (wID == ID_CROPCMD);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_CROPCMD, TBSTATE_ENABLED);
            }

            _RefreshSelection(!m_fAnnotating);
            m_ctlToolbar.SendMessage(TB_SETSTATE, wID, TBSTATE_ENABLED|TBSTATE_CHECKED);
            break;
        case ID_FREEHANDCMD:
        case ID_LINECMD:
        case ID_FRAMECMD:
        case ID_RECTCMD:
        case ID_TEXTCMD:
        case ID_NOTECMD:
        case ID_HIGHLIGHTCMD:
            if (m_fCanAnnotate)
            {
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED|TBSTATE_CHECKED);
                m_fAnnotating = TRUE;
                _RefreshSelection(TRUE);
                m_ctlToolbar.SendMessage(TB_SETSTATE, wID, TBSTATE_ENABLED|TBSTATE_CHECKED);
                m_wNewAnnotation = wID;
            }
            break;
        default:
            if (m_fCanAnnotate)
            {
                m_wNewAnnotation = 0;
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
            }
            break;
        }
    }
}

void CPreviewWnd::_RefreshSelection(BOOL fDeselect)
{
    if (m_fCropping)
        _UpdateCroppingSelection();
    _UpdateAnnotatingSelection(fDeselect);
}

BOOL CPreviewWnd::_ShouldDisplayAnimations()
{
    return !::GetSystemMetrics(SM_REMOTESESSION);
}

void CPreviewWnd::_UpdateAnnotatingSelection(BOOL fDeselect)
{
    BOOL bEditing = FALSE;
    if (m_ctlEdit.m_hWnd != NULL)
    {
        if (m_ctlEdit.IsWindowVisible())
        {
            _HideEditing();
            bEditing = TRUE;
        }
    }

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        CRect rectUpdate;
        CSelectionTracker tracker;
        _SetupAnnotatingTracker(tracker, bEditing);

        tracker.GetTrueRect(rectUpdate);

        // If we were editing or this was a straight line, we
        // need to get the bounding rect as well
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
        {
            CRect rect;
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

            pAnnotation->GetRect(rect);
            m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);

            rectUpdate.UnionRect(rectUpdate, rect);
        }
        m_ctlPreview.InvalidateRect(&rectUpdate);

        if (m_fAnnotating && !fDeselect)
        {
            if (bEditing)
                _StartEditing(FALSE);
        }
        else
        {
            _StopEditing();
            DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        }
    }

    // Disable the properties button if there are 0 or 2 or more annotations selected
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1, 0));
}

void CPreviewWnd::_UpdateCroppingSelection()
{
    if (m_fCropping)
    {
        m_ctlPreview.InvalidateRect(NULL);
    }
}

void CPreviewWnd::_RemoveAnnotatingSelection()
{
    // Invalidate current selection and remove annotations
    _UpdateAnnotatingSelection();

    CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();

    for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
        pAnnotations->RemoveAnnotation(pAnnotation);
        delete pAnnotation;
        m_fDirty = TRUE;
    }
    
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(FALSE, 0));
    DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
}

void CPreviewWnd::_SetupAnnotatingTracker(CSelectionTracker& tracker, BOOL bEditing)
{
    CRect rect;
    rect.SetRectEmpty();

    if (!bEditing)
    {
        if (m_ctlEdit.m_hWnd != NULL)
            bEditing = m_ctlEdit.IsWindowVisible();
    }

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        CAnnotation* pAnnotation;

        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
        {
            pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

            // If this is a straight-line annotation then we need to get
            // to the actual points rather than the bounding rect
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
            {
                CLineMark* pLine = (CLineMark*)pAnnotation;
                pLine->GetPointsRect(rect);
            }
            else
            {
                pAnnotation->GetRect(rect);
            }

            if (bEditing)
                _RotateRect(rect, pAnnotation);
        }
        else
        {
            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
               CRect rectAnnotation;
                pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);

                pAnnotation->GetRect(rectAnnotation);
                rectAnnotation.NormalizeRect();
                rect.UnionRect(rect, rectAnnotation);
            }
        }

        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    }
    tracker.m_rect = rect;

    UINT uStyle = 0;

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 1)
    {
        uStyle = CSelectionTracker::hatchedBorder;
    }
    else if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

        if (pAnnotation->CanResize())
        {
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
                uStyle = CSelectionTracker::resizeOutside | CSelectionTracker::lineSelection;
            else
                uStyle = CSelectionTracker::solidLine | CSelectionTracker::resizeOutside;
        }
        else
        {
            uStyle = CSelectionTracker::hatchedBorder;
        }
    }

    tracker.m_uStyle = uStyle;
}

void CPreviewWnd::_SetupCroppingTracker(CSelectionTracker& tracker)
{
    if (m_fCropping)
    {
        CRect rect(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);
        if (m_rectCropping.IsRectEmpty())
            m_rectCropping = rect;

        rect = m_rectCropping;

        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);

        tracker.m_rect = rect;
        tracker.m_uStyle = CSelectionTracker::solidLine | CSelectionTracker::resizeOutside;
    }
}

BOOL CPreviewWnd::_OnMouseDownForCropping(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!m_fCropping)
        return FALSE;

    if (uMsg != WM_LBUTTONDOWN)
        return TRUE;

    CSelectionTracker tracker;
    CPoint point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    _SetupCroppingTracker(tracker);
    _RefreshSelection();

    if (tracker.HitTest(point) == CSelectionTracker::hitNothing)
        return TRUE;

    if (tracker.Track(m_ctlPreview.m_hWnd, point))
    {
        CRect rectNewPos;
        tracker.GetTrueRect(rectNewPos);

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectNewPos, 2);

        CRect rectImage(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);

        if (rectNewPos.left < rectImage.left)
            m_rectCropping.left = rectImage.left;
        else
            m_rectCropping.left = rectNewPos.left;

        if (rectNewPos.top < rectImage.top)
            m_rectCropping.top = rectImage.top;
        else
            m_rectCropping.top = rectNewPos.top;

        if (rectNewPos.right > rectImage.right)
            m_rectCropping.right = rectImage.right;
        else
            m_rectCropping.right = rectNewPos.right;

        if (rectNewPos.bottom > rectImage.bottom)
            m_rectCropping.bottom = rectImage.bottom;
        else
            m_rectCropping.bottom = rectNewPos.bottom;

        m_fDirty = TRUE;
    }

    _RefreshSelection();

    return TRUE;
}

BOOL CPreviewWnd::_OnMouseDownForAnnotating(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!m_fAnnotating)
        return FALSE;

    if (uMsg != WM_LBUTTONDOWN)
        return TRUE;

    CRect rect;
    CRect rectImage;
    CPoint point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    CSelectionTracker tracker;

    m_ctlPreview.GetVisibleImageWindowRect(rectImage);

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0)
    {
        _OnMouseDownForAnnotatingHelper(point, rectImage);
        return TRUE;
    }

    _SetupAnnotatingTracker(tracker);
    tracker.GetTrueRect(rect);

    if (tracker.HitTest(point) == CSelectionTracker::hitNothing)
    {
        _RefreshSelection(TRUE);
        _OnMouseDownForAnnotatingHelper(point, rectImage);
        return TRUE;
    }

    if (!tracker.Track(m_ctlPreview.m_hWnd, point))
    {
        _StartEditing();
        return TRUE;
    }

    CRect rectNewPos;
    tracker.GetTrueRect(rectNewPos);

    rect.BottomRight() = rectNewPos.TopLeft();
    m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

    CSize size = rect.BottomRight() - rect.TopLeft();

    _RefreshSelection();

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 1)
    {
        if (size.cx == 0 && size.cy == 0)
            return TRUE;

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
        rectImage.DeflateRect(5, 5);

        BOOL bValidMove = TRUE;
        for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
        {
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);

            pAnnotation->GetRect(rect);
            rect.NormalizeRect();
            rect.OffsetRect(size);

            if (!rectNewPos.IntersectRect(rectImage, rect))
                bValidMove = FALSE;
        }

        if (!bValidMove)
            return TRUE;

        for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
        {
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
            pAnnotation->Move(size);
        }
    }
    else
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);
        if (pAnnotation->CanResize())
        {
            CRect rectTest;

            rect = tracker.m_rect;
            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

            rectTest = rect;

            // If the annotation being manipulated is a straight line then the rectangle
            // returned from the tracker could be empty (ie left=right or top=bottom)
            // In this case the IntersectRect test below would fail because windows
            // assumes empty rectangle don't intersect anything.
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
            {
                if (rectTest.left == rectTest.right)
                    rectTest.right++;
                if (rectTest.top == rectTest.bottom)
                    rectTest.bottom++;
            }
            rectTest.NormalizeRect();

            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
            rectImage.DeflateRect(5, 5);

            if (!rectTest.IntersectRect(rectImage, rectTest))
                return TRUE;

            if (m_ctlEdit.m_hWnd != NULL)
            {
                if (m_ctlEdit.IsWindowVisible())
                {
                    _RotateRect(rect, pAnnotation);
                }
            }

            // If this is a line then the rect is assumed to be
            // a non-normalized array of points.
            pAnnotation->Resize(rect);

        }
        else
        {
            if (size.cx == 0 && size.cy == 0)
                return TRUE;

            pAnnotation->Move(size);
        }
    }
    m_fDirty = TRUE;
    _RefreshSelection();
    return TRUE;
}

void CPreviewWnd::_OnMouseDownForAnnotatingHelper(CPoint ptMouse, CRect rectImage)
{
    CRect rect;
    CSelectionTracker tracker;
    _SetupAnnotatingTracker(tracker);

    if (m_wNewAnnotation == ID_FREEHANDCMD)
    {
        _CreateFreeHandAnnotation(ptMouse);
        return;
    }

    // If we are creating a line then make sure the tracker has the lineSelection
    // style so we get the appropriate visual feedback.
    if (m_wNewAnnotation == ID_LINECMD)
    {
        tracker.m_uStyle = CSelectionTracker::resizeOutside | CSelectionTracker::lineSelection;
    }

    if (tracker.TrackRubberBand(m_ctlPreview.m_hWnd, ptMouse, TRUE))
    {
        rect = tracker.m_rect;
        rect.NormalizeRect();

        if ((rect.Width() > 10) || (rect.Height() > 10))
        {
            if (m_wNewAnnotation != 0)
            {
                _CreateAnnotation(tracker.m_rect);
            }
            else
            {
                CRect rectTest;
                CRect rectAnnotation;
                CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();

                m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

                INT_PTR nCount = pAnnotations->GetCount();
                for (INT_PTR i = 0; i < nCount; i++)
                {
                    CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);

                    pAnnotation->GetRect(rectAnnotation);
                    rectAnnotation.NormalizeRect();
                    rectTest.UnionRect(rect, rectAnnotation);

                    if (rectTest == rect)
                    {
                        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);
                    }
                }
                _RefreshSelection(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0);
            }
        }
    }
    else
    {
        if (m_wNewAnnotation == 0)
        {
            if (PtInRect(rectImage, ptMouse))
            {
                m_ctlPreview.GetImageFromWindow(&ptMouse, 1);

                CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
                INT_PTR nCount = pAnnotations->GetCount();

                // if the user is clicking a single point then
                // we need to search the annotations in zorder 
                // from top to bottom
                for (INT_PTR i = nCount - 1; i >= 0; i--)
                {
                    CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);

                    pAnnotation->GetRect(rect);
                    rect.NormalizeRect();

                    if (PtInRect(rect, ptMouse))
                    {
                        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);
                        _RefreshSelection();
                        return;
                    }
                }
                _RefreshSelection(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0);
            }
        }
        else
        {
            _UpdateButtons(ID_SELECTCMD);
        }
    }
}

void CPreviewWnd::_CreateAnnotation(CRect rect)
{
    if (m_wNewAnnotation == 0 || m_wNewAnnotation == ID_FREEHANDCMD)
        return;

    ULONG xDPI;
    ULONG yDPI;
    if (!(m_pImageData->GetResolution(&xDPI, &yDPI)))
        return;

    CAnnotation* pAnnotation = NULL;
    switch(m_wNewAnnotation)
    {
    case ID_LINECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_STRAIGHTLINE, yDPI);
        break;
    case ID_FRAMECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_HOLLOWRECT, yDPI);
        break;
    case ID_RECTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_FILLRECT, yDPI);
        break;
    case ID_TEXTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_TYPEDTEXT, yDPI);
        break;
    case ID_NOTECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_ATTACHANOTE, yDPI);
        break;
    case ID_HIGHLIGHTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_FILLRECT, yDPI);
        if (pAnnotation != NULL)
            pAnnotation->SetTransparent(TRUE);
        break;
    }

    if (pAnnotation != NULL)
    {
        COLORREF crBackColor = RGB(255,255,0);
        COLORREF crLineColor = RGB(255,0,0);
        COLORREF crTextColor = RGB(0,0,0);
        LOGFONT lfFont = {12, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, TEXT("Arial") };

        DWORD dwWidth = 1;

        CRegKey Key;
        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
        {
            Key.QueryValue(dwWidth, REGSTR_LINEWIDTH);
            Key.QueryValue(crBackColor, REGSTR_BACKCOLOR);
            Key.QueryValue(crLineColor, REGSTR_LINECOLOR);
            Key.QueryValue(crTextColor, REGSTR_TEXTCOLOR);

            DWORD dwType, cbSize;
            cbSize = sizeof(lfFont);
            ::RegQueryValueEx(Key, REGSTR_FONT, NULL, &dwType, (LPBYTE)&lfFont, &cbSize);
        }

        if (m_wNewAnnotation != ID_LINECMD)
            rect.NormalizeRect();

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);
        pAnnotation->Resize(rect);

        if (pAnnotation->HasWidth())
            pAnnotation->SetWidth(dwWidth);

        if (pAnnotation->HasColor())
        {
            if (m_wNewAnnotation == ID_LINECMD || m_wNewAnnotation == ID_FRAMECMD)
                pAnnotation->SetColor(crLineColor);
            else
                pAnnotation->SetColor(crBackColor);
        }

        if (pAnnotation->HasFont())
        {
            pAnnotation->SetFont(lfFont);
            pAnnotation->SetFontColor(crTextColor);
        }

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->AddAnnotation(pAnnotation);

        m_fDirty = TRUE;
    }
    _UpdateButtons(ID_SELECTCMD);
}

void CPreviewWnd::_CreateFreeHandAnnotation(CPoint ptMouse)
{
    if (m_wNewAnnotation != ID_FREEHANDCMD)
        return;

    // don't handle if capture already set
    if (::GetCapture() != NULL)
        return;

    // set capture to the window which received this message
    ::SetCapture(m_ctlPreview.m_hWnd);
    ASSERT(m_ctlPreview.m_hWnd == ::GetCapture());

    ::UpdateWindow(m_ctlPreview.m_hWnd);

    ULONG xDPI;
    ULONG yDPI;
    if (!(m_pImageData->GetResolution(&xDPI, &yDPI)))
        return;

    CLineMark* pAnnotation = (CLineMark*)CAnnotation::CreateAnnotation(MT_FREEHANDLINE, yDPI);
    if (pAnnotation == NULL)
        return;

    CDSA<POINT> Points;
    Points.Create(256);

    CPoint ptLast = ptMouse;
    m_ctlPreview.GetImageFromWindow(&ptMouse, 1);

    Points.AppendItem(&ptMouse);

    // get DC for drawing
    HDC hdcDraw;

    // otherwise, just use normal DC
    hdcDraw = ::GetDC(m_ctlPreview.m_hWnd);
    ASSERT(hdcDraw != NULL);

    COLORREF crLineColor = RGB(255,0,0);
    DWORD dwWidth = 1;

    CRegKey Key;
    if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
    {
        Key.QueryValue(dwWidth, REGSTR_LINEWIDTH);
        Key.QueryValue(crLineColor, REGSTR_LINECOLOR);
    }

    CRect rect(0,0,0,dwWidth);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    DWORD dwRenderWidth = rect.Height();

    HPEN hpen = ::CreatePen(PS_SOLID, dwRenderWidth, crLineColor);
    HPEN hOld =(HPEN)::SelectObject(hdcDraw, hpen);

    BOOL bCancel=FALSE;

    // get messages until capture lost or cancelled/accepted
    for (;;)
    {
        MSG msg;
        if (!::GetMessage(&msg, NULL, 0, 0))
        {
            ASSERT(FALSE);
        }

        if (m_ctlPreview.m_hWnd != ::GetCapture())
        {
            bCancel = TRUE;
            goto ExitLoop;
        }

        ptMouse.x = GET_X_LPARAM(msg.lParam);
        ptMouse.y = GET_Y_LPARAM(msg.lParam);

        switch (msg.message)
        {
        // handle movement/accept messages
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
            ::MoveToEx(hdcDraw, ptLast.x, ptLast.y, NULL);
            ::LineTo(hdcDraw, ptMouse.x, ptMouse.y);
            ptLast = ptMouse;

            m_ctlPreview.GetImageFromWindow(&ptMouse, 1);
            Points.AppendItem(&ptMouse);

            if (msg.message == WM_LBUTTONUP)
                goto ExitLoop;
            break;
        // handle cancel messages
        case WM_KEYDOWN:
            if (msg.wParam != VK_ESCAPE)
                break;
        //  else fall through
        case WM_RBUTTONDOWN:
            bCancel = TRUE;
            goto ExitLoop;
        default:
            ::DispatchMessage(&msg);
            break;
        }
    }
ExitLoop:

    ::SelectObject(hdcDraw, hOld);
    ::DeleteObject(hpen);
    ::ReleaseDC(m_ctlPreview.m_hWnd, hdcDraw);
    ::ReleaseCapture();

    if (!bCancel)
    {
        int nAnnoPoints = Points.GetItemCount();
        POINT* AnnoPoints  = new POINT[nAnnoPoints];
        if (AnnoPoints == NULL)
        {
            delete pAnnotation;
            Points.Destroy();
            _UpdateButtons(ID_SELECTCMD);
            return;
        }

        for (int i = 0; i < nAnnoPoints; i++)
        {
            CPoint pt;
            Points.GetItem(i, &pt);
            AnnoPoints[i].x = pt.x;
            AnnoPoints[i].y = pt.y;
        }

        Points.Destroy();

        pAnnotation->SetPoints(AnnoPoints, nAnnoPoints);
        pAnnotation->SetWidth(dwWidth);
        pAnnotation->SetColor(crLineColor);

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->AddAnnotation(pAnnotation);
        m_fDirty = TRUE;
    }
    _UpdateButtons(ID_SELECTCMD);
}

void CPreviewWnd::_StartEditing(BOOL bUpdateText)
{
    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) != 1)
        return;

    CTextAnnotation* pAnnotation = (CTextAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);
    if (!pAnnotation)
    {
        return;
    }

    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    if (m_ctlEdit.m_hWnd == NULL)
    {
        HWND hwndEdit = ::CreateWindow(TEXT("EDIT"), NULL, ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL |
                                    ES_WANTRETURN | WS_CHILD, 1, 1, 10, 10,
                                    m_ctlPreview.m_hWnd, (HMENU)1496, NULL, NULL);
        if (hwndEdit == NULL)
            return;

        m_ctlEdit.SubclassWindow(hwndEdit);
    }

    if (bUpdateText)
    {
        CComBSTR bstrText;
        bstrText.Attach(pAnnotation->GetText());
        if (bstrText.m_str != NULL)
            m_ctlEdit.SetWindowText(bstrText);
        else
            m_ctlEdit.SetWindowText(TEXT(""));
    }

    m_ctlEdit.EnableWindow(TRUE);

    LOGFONT lfFont;
    pAnnotation->GetFont(lfFont);

    HDC hdc = ::GetDC(NULL);
    LONG lHeight = pAnnotation->GetFontHeight(hdc);
    ::ReleaseDC(NULL, hdc);

    CRect rect(0,0,0,lHeight);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    lfFont.lfHeight = -rect.Height();

    HFONT hNewFont = ::CreateFontIndirect(&lfFont);
    if (hNewFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = hNewFont;
        m_ctlEdit.SendMessage(WM_SETFONT, (WPARAM)m_hFont, MAKELPARAM(TRUE,0));
    }

    pAnnotation->GetRect(rect);
    _RotateRect(rect, pAnnotation);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    m_ctlEdit.SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER);

    CSelectionTracker tracker;
    _SetupAnnotatingTracker(tracker, FALSE);

    CRect rectUpdate;
    tracker.GetTrueRect(rectUpdate);
    m_ctlPreview.InvalidateRect(rectUpdate);

    _SetupAnnotatingTracker(tracker, TRUE);
    tracker.GetTrueRect(rectUpdate);
    m_ctlPreview.InvalidateRect(rectUpdate);

    m_ctlEdit.ShowWindow(SW_SHOW);
    m_ctlEdit.SetFocus();

    m_fEditingAnnotation = TRUE;
}

void CPreviewWnd::_HideEditing()
{
    if (m_ctlEdit.m_hWnd == NULL)
        return;

    if (!m_ctlEdit.IsWindowVisible())
        return;

    SetFocus();
    m_ctlEdit.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
    m_ctlEdit.EnableWindow(FALSE);
}

void CPreviewWnd::_StopEditing()
{
    if (m_ctlEdit.m_hWnd == NULL)
        return;

    _HideEditing();

    if (!m_fEditingAnnotation)
        return;

    m_fEditingAnnotation = FALSE;

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) != 1)
        return;

    CTextAnnotation* pAnnotation = (CTextAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);
    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    // if the length greater than zero we save it
    // otherwise be blow away the annotation.
    int nLen = m_ctlEdit.GetWindowTextLength();
    if (nLen > 0)
    {
        CComBSTR bstrText(nLen+1);
        m_ctlEdit.GetWindowText(bstrText, nLen+1);
        pAnnotation->SetText(bstrText);
        m_fDirty = TRUE;
    }
    else
    {
        CSelectionTracker tracker;

        _SetupAnnotatingTracker(tracker, TRUE);

        CRect rectUpdate;
        tracker.GetTrueRect(rectUpdate);

        CRect rect;
        pAnnotation->GetRect(rect);
        rectUpdate.UnionRect(rectUpdate, rect);

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->RemoveAnnotation(pAnnotation);
        delete pAnnotation;

        m_ctlPreview.InvalidateRect(rectUpdate);
        m_fDirty = TRUE;
    }
}

LRESULT CPreviewWnd::OnEditKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    switch (wParam)
    {
    case VK_ESCAPE:
        {
            CSelectionTracker tracker;
            _SetupAnnotatingTracker(tracker);
            CRect rectUpdate;
            tracker.GetTrueRect(rectUpdate);

            _HideEditing();

            m_ctlPreview.InvalidateRect(rectUpdate);
            _RefreshSelection();

            fHandled = TRUE;
        }
        break;

    default:
        fHandled = FALSE;
        break;
    }
    return 0;
}

BOOL_PTR CALLBACK CPreviewWnd::_AnnoPropsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static LOGFONT lfFont;
    static COLORREF crFont;
    static COLORREF crColor;
    CPreviewWnd* pThis;

    switch (msg)
    {
        case WM_INITDIALOG:
            {
                HWND hwndCtl = NULL;
                ::SetWindowLongPtr(hwnd, DWLP_USER, lParam);
                pThis = (CPreviewWnd*)lParam;

                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(pThis->m_hdpaSelectedAnnotations, 0);

                hwndCtl = ::GetDlgItem(hwnd, IDC_WIDTHTEXT);
                if (!pAnnotation->HasWidth())
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                hwndCtl = ::GetDlgItem(hwnd, IDC_WIDTH);
                if (pAnnotation->HasWidth())
                {
                    UINT i = pAnnotation->GetWidth();
                    ::SetDlgItemInt(hwnd, IDC_WIDTH, i, FALSE);

                    hwndCtl = ::GetDlgItem(hwnd, IDC_SPIN);
                    ::SendMessage(hwndCtl, UDM_SETRANGE32, (WPARAM)1, (LPARAM)50);
                    ::SendMessage(hwndCtl, UDM_SETPOS32, 0, (LPARAM)i);
                }
                else
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                    hwndCtl = ::GetDlgItem(hwnd, IDC_SPIN);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                hwndCtl = ::GetDlgItem(hwnd, IDC_TRANSPARENT);
                if (pAnnotation->HasTransparent())
                {
                    BOOL bTransparent = pAnnotation->GetTransparent();
                    ::SendMessage(hwndCtl, BM_SETCHECK, (WPARAM)(bTransparent ? BST_CHECKED : BST_UNCHECKED), 0);
                }
                else
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                if (pAnnotation->HasFont())
                {
                    pAnnotation->GetFont(lfFont);
                    crFont = pAnnotation->GetFontColor();
                }
                else
                {
                    hwndCtl = ::GetDlgItem(hwnd, IDC_FONT);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }


                if (pAnnotation->HasColor())
                {
                    crColor = pAnnotation->GetColor();
                }
                else
                {
                    hwndCtl = ::GetDlgItem(hwnd, IDC_COLOR);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }
            }
            break;

        case WM_COMMAND:
            pThis = (CPreviewWnd*)::GetWindowLongPtr(hwnd, DWLP_USER);

            switch (wParam)
            {
                case IDOK:
                    pThis->_RefreshSelection();
                    {
                        HWND hwndCtl = NULL;
                        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(pThis->m_hdpaSelectedAnnotations, 0);

                        CRegKey Key;
                        if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                        {
                            Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                        }

                        if (pAnnotation->HasWidth())
                        {
                            UINT uWidth = ::GetDlgItemInt(hwnd, IDC_WIDTH, NULL, FALSE);

                            if (uWidth > 50 || uWidth < 1)
                            {
                                CComBSTR bstrMsg, bstrTitle;

                                if (bstrMsg.LoadString(IDS_WIDTHBAD_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
                                {
                                    ::MessageBox(hwnd, bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                                }

                                ::SetDlgItemInt(hwnd, IDC_WIDTH, 50, FALSE);
                                return FALSE;
                            }

                            pAnnotation->SetWidth(uWidth);
                            if (Key.m_hKey != NULL)
                            {
                                Key.SetValue(uWidth, REGSTR_LINEWIDTH);
                            }
                        }

                        if (pAnnotation->HasTransparent())
                        {
                            hwndCtl = ::GetDlgItem(hwnd, IDC_TRANSPARENT);
                            BOOL bTransparent = FALSE;
                            if (::SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED)
                                bTransparent = TRUE;

                            pAnnotation->SetTransparent(bTransparent);
                        }

                        if (pAnnotation->HasFont())
                        {
                            lfFont.lfHeight = (lfFont.lfHeight > 0) ? lfFont.lfHeight : -lfFont.lfHeight;
                            pAnnotation->SetFont(lfFont);
                            pAnnotation->SetFontColor(crFont);
                            if (Key.m_hKey != NULL)
                            {
                                Key.SetValue(crFont, REGSTR_TEXTCOLOR);
                                ::RegSetValueEx(Key, REGSTR_FONT, 0, REG_BINARY, (LPBYTE)&lfFont, sizeof(lfFont));
                            }
                        }

                        if (pAnnotation->HasColor())
                        {
                            pAnnotation->SetColor(crColor);
                            UINT uType = pAnnotation->GetType();
                            if (Key.m_hKey != NULL)
                            {
                                if (uType == MT_STRAIGHTLINE || uType == MT_FREEHANDLINE || uType == MT_HOLLOWRECT)
                                    Key.SetValue(crColor, REGSTR_LINECOLOR);
                                else
                                    Key.SetValue(crColor, REGSTR_BACKCOLOR);
                            }
                        }

                    }
                    pThis->m_fDirty = TRUE;
                    pThis->_RefreshSelection();
                    EndDialog(hwnd, wParam);
                    return FALSE;
                case IDCANCEL:
                    EndDialog(hwnd, wParam);
                    return FALSE;
                case IDC_FONT:
                    {
                        CHOOSEFONT cf = {0};
                        LOGFONT lf;

                        lf = lfFont;

                        cf.lStructSize = sizeof(cf);
                        cf.hwndOwner = hwnd;
                        cf.lpLogFont = &lf;
                        cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
                        cf.rgbColors = crFont;

                        if (::ChooseFont(&cf))
                        {
                            CopyMemory (&lfFont, &lf, sizeof(lfFont));
                            crFont = cf.rgbColors;
                        }
                    }
                    return FALSE;
                case IDC_COLOR:
                    {
                        CHOOSECOLOR cc = {0};

                        cc.lStructSize = sizeof(cc);
                        cc.hwndOwner = hwnd;
                        cc.rgbResult = crColor;
                        cc.lpCustColors = g_crCustomColors;
                        cc.Flags = CC_RGBINIT | CC_SOLIDCOLOR;

                        if (::ChooseColor(&cc))
                        {
                            crColor = cc.rgbResult;
                        }
                    }
                    return FALSE;
                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL CPreviewWnd::_TrySetImage()
{
    BOOL fRet = FALSE;
    if (m_pNextImageData && m_pNextImageData->_iItem == m_iCurSlide)
    {
        if (SUCCEEDED(m_pNextImageData->_hr))
        {
            m_fCanSave = !m_pNextImageData->_fIsReadOnly;

            // update the toolbar state, our child windows, and our sibling windows
            _SetNewImage(m_pNextImageData);
            ATOMICRELEASE(m_pNextImageData);

            if (m_pImageData->IsAnimated() && _ShouldDisplayAnimations())
            {
                // start the animation timer
                SetTimer(TIMER_ANIMATION, m_pImageData->GetDelay());
            }

            // Notify anyone listening to our events that a preview has been completed
            // we only fire this upon success
            if (m_pEvents)
            {
                m_pEvents->OnPreviewReady();
            }
            fRet = TRUE;
        }
        else
        {
            // update the status to display an error message.  This will also update the toolbar state.
            StatusUpdate(IDS_LOADFAILED);

            //
            // We can't remove the item from the array because the user might try to delete it while
            // the "load failed" string is still visible for it.


            // even though the item failed to decode we must wait on the "Load Failed" state when we are in
            // windowed mode, otherwise "open with..." is broken when you open a corrupted image or non-image.
            // In slideshow mode we could simply skip to the next image.

            if (m_pEvents)
                m_pEvents->OnError();
        }
    }

    return fRet;
}

LRESULT CPreviewWnd::IV_OnSetImageData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    CDecodeTask * pData = (CDecodeTask *)wParam;

    ATOMICRELEASE(m_pNextImageData);

    m_pNextImageData = pData;

    if (m_pNextImageData && m_iDecodingNextImage == m_pNextImageData->_iItem)
    {
        // We have finished decoding now, let's remember this.
        m_iDecodingNextImage = -1;

        // Let 's prepare the drawing now. This draws in the back buffer. Don't start this if we want to see
        // the image now, as it would delay things.
        if (SUCCEEDED(m_pNextImageData->_hr) && m_pNextImageData->_iItem != m_iCurSlide)
        {
            m_ctlPreview.PrepareImageData(m_pNextImageData);
        }
    }

    _TrySetImage();
    return TRUE;
}


// Creation of the image data is asynchronous.  When our worker thread is done decoding
// an image it posts a IV_SETIMAGEDATA message with the image data object.  As a result,
// we must flush these messages when the window is destroyed to prevent leaking any handles.

void CPreviewWnd::FlushBitmapMessages()
{
    // Pass TRUE to wait for task to be removed before peeking out its messages
    // Otherwise, if the task is in the middle of running, our PeekMessage won't
    // see anything and we will return.  Then the task will finish, post its message,
    // and leak the data since we're not around to receive it.
    TASKOWNERID toid;
    GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
    if (m_pTaskScheduler)
    {
        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
    }

    // if we were waiting for another image frame to be generated then cut it out, we don't care about that anymore
    // if we have an animation timer running then kill it and remove any WM_TIMER messages
    KillTimer(TIMER_ANIMATION);
    KillTimer(TIMER_SLIDESHOW);

    MSG msg;
    while (PeekMessage(&msg, m_hWnd, WM_TIMER, WM_TIMER, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already
        // Posted a quit message then PeekMessage will return a WM_QUIT message
        // regardless of the filter min and max and subsequent calls to
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }
    }

    // make sure any posted messages get flushed and we free the associated data
    while (PeekMessage(&msg, m_hWnd, IV_SETIMAGEDATA, IV_SETIMAGEDATA, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already
        // Posted a quit message then PeekMessage will return a WM_QUIT message
        // regardless of the filter min and max and subsequent calls to
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }

        CDecodeTask * pData = (CDecodeTask *)msg.wParam;
        ATOMICRELEASE(pData);
    }
}

LRESULT CPreviewWnd::OnCopyData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // We can get into a situation where we are still trying to preview
    // the previous oncopydata because the previous window to that was a
    // tiff that was being annotated and is prompting you to save. In this
    // case throw away any future data

    if (_pdtobj != NULL || m_fPromptingUser)
        return TRUE;

    COPYDATASTRUCT *pcds = (COPYDATASTRUCT*)lParam;
    if (pcds)
    {
        HRESULT hr = E_FAIL;
        switch (pcds->dwData)
        {
        case COPYDATATYPE_DATAOBJECT:
            {
                IStream *pstm;
                if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pstm)))
                {
                    const LARGE_INTEGER li = {0, 0};

                    pstm->Write(pcds->lpData, pcds->cbData, NULL);
                    pstm->Seek(li, STREAM_SEEK_SET, NULL);

                    // unfortunaly we can not program the data object here as we are in a
                    // SendMessage() and any calls made on the data object will fail because
                    // of this. instead we grab a ref to the data object and set a timer
                    // so we can handle this once we have unwound from the send.

                    hr = CoUnmarshalInterface(pstm, IID_PPV_ARG(IDataObject, &_pdtobj));
                    pstm->Release();
                }
            }
            break;
        case COPYDATATYPE_FILENAME:
            {
                hr = GetUIObjectFromPath((LPCTSTR)pcds->lpData, IID_PPV_ARG(IDataObject, &_pdtobj));
            }
            break;
        }
        // unfortunaly we can not program the data object here as we are in a
        // SendMessage() and any calls made on the data object will fail because
        // of this. instead we grab a ref to the data object and set a timer
        // so we can handle this once we have unwound from the send.

        if (SUCCEEDED(hr))
        {
            SetTimer(TIMER_DATAOBJECT, 100);    // do the real work here
        }
    }
    return TRUE;
}

DWORD MakeFilterFromCodecs(LPTSTR szFilter, size_t cbFilter, UINT nCodecs, ImageCodecInfo *pCodecs, LPTSTR szExt, BOOL fExcludeTiff)
{
    size_t nOffset = 0;
    DWORD dwRet = 1;
    for (UINT i = 0; i < nCodecs && nOffset < cbFilter - 1; i++)
    {
        if (fExcludeTiff && StrStrI(pCodecs->FilenameExtension, L"*.tif"))
        {
            continue;
        }
        // make sure there's space for nulls between strings and 2 at the end
        if (4+lstrlen(pCodecs->FormatDescription) + lstrlen(pCodecs->FilenameExtension) + nOffset < cbFilter)
        {
            StrCpyN(szFilter+nOffset,pCodecs->FormatDescription, cbFilter -(nOffset + 1));
            nOffset+=lstrlen(pCodecs->FormatDescription)+1;
            StrCpyN(szFilter+nOffset,pCodecs->FilenameExtension, cbFilter -(nOffset + 1));
            nOffset+=lstrlen(pCodecs->FilenameExtension)+1;
            if (StrStrI(pCodecs->FilenameExtension, szExt))
            {
                dwRet = i + 1;
            }
            pCodecs++;
        }
    }
    szFilter[nOffset] = 0;
    return dwRet;
}

DWORD CPreviewWnd::_GetFilterStringForSave(LPTSTR szFilter, size_t cbFilter, LPTSTR szExt)
{
    UINT nCodecs = 0;
    UINT cbCodecs = 0;
    BYTE *pData;
    GetImageEncodersSize (&nCodecs, &cbCodecs);
    DWORD dwRet = 1; // ofn.nFilterIndex is 1-based
    if (cbCodecs)
    {
        pData = new BYTE[cbCodecs];
        if (pData)
        {
            ImageCodecInfo *pCodecs = reinterpret_cast<ImageCodecInfo*>(pData);
            if (Ok == GetImageEncoders (nCodecs, cbCodecs, pCodecs))
            {
                dwRet = MakeFilterFromCodecs(szFilter, cbFilter, nCodecs, pCodecs, szExt, m_pImageData->IsExtendedPixelFmt());
            }
            delete [] pData;
        }
    }
    return dwRet;
}

HRESULT CPreviewWnd::SaveAs(BSTR bstrPath)
{
    HRESULT hr = E_FAIL;

    if (m_pImageData && m_pImageFactory)
    {
        IShellImageData * pSID;
        hr = m_pImageData->Lock(&pSID);
        if (SUCCEEDED(hr))
        {
            GUID guidFmt;
            if (SUCCEEDED(m_pImageFactory->GetDataFormatFromPath(bstrPath, &guidFmt)))
            {
                IPropertyBag *pbagEnc;
                hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbagEnc));
                if (SUCCEEDED(hr))
                {
                    VARIANT var;
                    hr = InitVariantFromGUID(&var, guidFmt);
                    if (SUCCEEDED(hr))
                    {
                        hr = pbagEnc->Write(SHIMGKEY_RAWFORMAT, &var);
                        if (SUCCEEDED(hr))
                        {
                            hr = pSID->SetEncoderParams(pbagEnc);
                        }
                        VariantClear(&var);
                    }
                    pbagEnc->Release();
                }
            }

            IPersistFile *ppf;
            hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Save(bstrPath, TRUE);
                ppf->Release();
            }
            m_pImageData->Unlock();
        }
    }

    return hr;
}

BOOL CPreviewWnd::_IsImageFile(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    if (m_pici || _BuildDecoderList())
    {
        bRet = (-1 != FindInDecoderList(m_pici, m_cDecoders, pszFile));
    }
    return bRet;
}

BOOL CPreviewWnd::_BuildDecoderList()
{
    UINT cb;
    BOOL bRet = FALSE;
    if (Ok == GetImageDecodersSize(&m_cDecoders, &cb))
    {
        m_pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
        if (m_pici)
        {
            if (Ok != GetImageDecoders(m_cDecoders, cb, m_pici))
            {
                LocalFree(m_pici);
                m_pici = NULL;
            }
            else
            {
                bRet = TRUE;
            }
        }
    }
    return bRet;
}

void CPreviewWnd::OpenFileList(HWND hwnd, IDataObject *pdtobj)
{
    if (NULL == hwnd)
        hwnd = m_hWnd;

    IStream *pstm;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = CoMarshalInterface(pstm, IID_IDataObject, pdtobj, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_NORMAL);
        if (SUCCEEDED(hr))
        {
            HGLOBAL hGlobal;
            hr = GetHGlobalFromStream(pstm, &hGlobal);
            if (SUCCEEDED(hr))
            {
                COPYDATASTRUCT cds = {0};
                cds.dwData = COPYDATATYPE_DATAOBJECT;
                cds.cbData = (DWORD)GlobalSize(hGlobal);
                cds.lpData = GlobalLock(hGlobal);
                SendMessage(hwnd, WM_COPYDATA, NULL, (LPARAM)&cds);
                SetForegroundWindow(hwnd);

                GlobalUnlock(hGlobal);
            }
        }
        pstm->Release();
    }
}

void CPreviewWnd::OpenFile(HWND hwnd, LPCTSTR pszFile)
{
    if (NULL == hwnd)
        hwnd = m_hWnd;

    COPYDATASTRUCT cds = {0};
    cds.dwData = COPYDATATYPE_FILENAME;
    cds.cbData = (lstrlen(pszFile)+1)*sizeof(TCHAR);
    cds.lpData = (void*)pszFile;
    SendMessage(hwnd, WM_COPYDATA, NULL, (LPARAM)&cds);
    SetForegroundWindow(hwnd);
}

// returns:
//      TRUE    window was re-used

BOOL CPreviewWnd::TryWindowReuse(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    HWND hwnd = FindWindow(TEXT("ShImgVw:CPreviewWnd"), NULL);
    if (hwnd)
    {
        // window reuse can't always work because shortcuts are launched on a thread that 
        // is too short lived to support the marshalled IDataObject given to us via WM_COPYDATA
        // For now we'll try to close an existing window and open a new one.
        ::PostMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return bRet;
}

// returns:
//      TRUE    window was re-used

BOOL CPreviewWnd::TryWindowReuse(LPCTSTR pszFileName)
{
    BOOL bRet = FALSE;
    HWND hwnd = FindWindow(TEXT("ShImgVw:CPreviewWnd"), NULL);
    if (hwnd)
    {
        DWORD_PTR dwResult = FALSE;
        SendMessageTimeout(hwnd, IV_ISAVAILABLE, 0, 0, SMTO_ABORTIFHUNG | SMTO_BLOCK, 1000, &dwResult);
        if (dwResult)
        {
            OpenFile(hwnd, pszFileName);            
            bRet = TRUE;
        }
    }
    return bRet;
}

STDMETHODIMP CPreviewWnd::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPreviewWnd, IDropTarget),
        QITABENT(CPreviewWnd, INamespaceWalkCB),
        QITABENT(CPreviewWnd, IServiceProvider),
        QITABENT(CPreviewWnd, IImgCmdTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPreviewWnd::AddRef()
{
    return 3;
}

STDMETHODIMP_(ULONG) CPreviewWnd::Release()
{
    return 2;
}

// INamespaceWalkCB
STDMETHODIMP CPreviewWnd::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;

    if (m_fFirstItem && (WINDOW_MODE == m_dwMode))
    {
        // REVIEW: Do this in other modes too?
        StatusUpdate(IDS_LOADING);
        m_fFirstItem = FALSE;
        hr = S_OK;
    }
    else
    {
        TCHAR szName[MAX_PATH];
        DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (_IsImageFile(szName))
        {
            hr = S_OK;
        }       
    
    }
    if (WINDOW_MODE == m_dwMode)
    {
        MSG msg;
        while (PeekMessage(&msg, m_hWnd, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);          
        }
    }
    return hr;
}

STDMETHODIMP CPreviewWnd::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CPreviewWnd::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

// IDropTarget
STDMETHODIMP CPreviewWnd::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    m_dwEffect = DROPEFFECT_NONE;
    //
    // We only support CFSTR_SHELLIDLIST and CF_HDROP
    //
    static CLIPFORMAT cfidlist = 0;
    if (!cfidlist)
    {
        cfidlist = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->QueryGetData(&fmt)))
    {
        m_dwEffect = DROPEFFECT_COPY;
    }
    else
    {
        fmt.cfFormat = cfidlist;
        if (SUCCEEDED(pdtobj->QueryGetData(&fmt)))
        {
            m_dwEffect = DROPEFFECT_COPY;
        }
    }
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::DragLeave()
{
    m_dwEffect = DROPEFFECT_NONE;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (m_dwEffect != DROPEFFECT_NONE)
    {
        PreviewItemsFromUnk(pdtobj);
    }
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IServiceProvider
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPreviewWnd::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (SID_SImageView == guidService)
    {
        return QueryInterface(riid, ppv);
    }
    else if (m_punkSite)
    {
        return IUnknown_QueryService(m_punkSite, guidService, riid, ppv);
    }
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IImgCmdTarget
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPreviewWnd::GetMode(DWORD * pdw)
{
    *pdw = m_dwMode;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::GetPageFlags(DWORD * pdw)
{
    *pdw = m_dwMultiPageMode;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ZoomIn()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_ctlPreview.ZoomIn();
    }
    else
    {
        m_ctlPreview.SetMode(CZoomWnd::MODE_ZOOMIN);
        m_ctlPreview.ZoomIn();

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(TRUE, 0));

        _UpdateButtons(ID_ZOOMINCMD);
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ZoomOut()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_ctlPreview.ZoomOut();
    }
    else
    {
        m_ctlPreview.SetMode(CZoomWnd::MODE_ZOOMOUT);
        m_ctlPreview.ZoomOut();

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(!m_ctlPreview.IsBestFit(), 0));

        _UpdateButtons(ID_ZOOMOUTCMD);
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ActualSize()
{
    _RefreshSelection(FALSE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(TRUE, 0));

    m_ctlPreview.ActualSize();
    if (m_pEvents)
    {
        m_pEvents->OnActualSizePress();
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::BestFit()
{
    _RefreshSelection(FALSE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(FALSE, 0));

    m_ctlPreview.BestFit();
    if (m_pEvents)
    {
        m_pEvents->OnBestFitPress();
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::Rotate(DWORD dwAngle)
{
    WORD wRotate;
    switch (dwAngle)
    {
    case 90:
        wRotate = ID_ROTATE90CMD;
        break;

    case 270:
        wRotate = ID_ROTATE270CMD;
        break;

    default:
        return E_INVALIDARG;
    }

    // If we don't have an image yet, there is nothing for us to do.
    // Note:  The keyboard accelerator will hit this path if no image is selected
    if (!m_pImageData)
        return E_FAIL;

    // We quietly (the button is disabled but just in case you hit the
    // accelerator key) don't rotate WMF or EMF.
    if (IsEqualGUID(ImageFormatWMF, m_pImageData->_guidFormat) || IsEqualGUID(ImageFormatEMF, m_pImageData->_guidFormat))
        return E_FAIL;


    // Animated GIFs are not editable even though normal GIFs are.  This can
    // cause a lot of confusion, so provide some feedback if the user tries
    // to rotate an animated image.
    if (m_pImageData->IsAnimated())
    {
        TCHAR szPath[MAX_PATH];
        PathFromImageData(szPath, ARRAYSIZE(szPath));
        m_fPromptingUser = TRUE;
        ShellMessageBox(_Module.GetModuleInstance(), m_hWnd, MAKEINTRESOURCE(IDS_ROTATE_MESSAGE), MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szPath);
        m_fPromptingUser = FALSE;
        return E_FAIL;
    }


    // From here on out you need to goto ErrorCleanup rather than return
    _UpdateButtons(wRotate);
    SetCursorState(SLIDESHOW_CURSOR_BUSY);

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.UpdateWindow();

    if (m_pTaskScheduler)
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DRAW, m_dwMode, &toid);
        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
    }

    HRESULT hr = E_FAIL;
    SIZE sz;
    m_pImageData->GetSize(&sz);

    // if we're thinking we can quietly save
    if (m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // And the rotation might be lossy
        if (::IsEqualGUID(ImageFormatJPEG, m_pImageData->_guidFormat) && ((sz.cx % 16 != 0) || (sz.cy % 16 != 0)))
        {
            int nResult = IDOK;

            if (m_fWarnQuietSave)
            {
                CComBSTR bstrMsg, bstrTitle;
                if (bstrMsg.LoadString(IDS_ROTATE_LOSS) && bstrTitle.LoadString(IDS_PROJNAME))
                {
                    // Set default to return IDOK so we know if the user selected something or
                    // if the "don't show me this again" bit was respected
                    m_fPromptingUser = TRUE;
                    nResult = SHMessageBoxCheck(m_hWnd, bstrMsg, bstrTitle, MB_YESNO|MB_ICONWARNING, IDOK, REGSTR_LOSSYROTATE);
                    m_fPromptingUser = FALSE;
                }

                if (nResult != IDNO)
                    m_fWarnQuietSave = FALSE;
            }

            CRegKey Key;
            if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
            {
                Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
            }

            if (Key.m_hKey != NULL)
            {
                if (nResult == IDOK) // If hidden, then load last result from registry
                {
                    DWORD dwResult = 0;
                    Key.QueryValue(dwResult, REGSTR_LOSSYROTATE);
                    nResult = (int)dwResult;
                }
                else // Otherwise, write this as last result to registry
                {
                    DWORD dwResult = (DWORD)nResult;
                    Key.SetValue(dwResult, REGSTR_LOSSYROTATE);
                }
            }

            if (nResult == IDNO)
                goto ErrorCleanup;
        }
    }

    CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
    INT_PTR nCount = pAnnotations->GetCount();
    for (INT_PTR i = 0; i < nCount; i++)
    {
        CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);
        pAnnotation->Rotate(m_ctlPreview.m_cyImage, m_ctlPreview.m_cxImage, (ID_ROTATE90CMD == wRotate));
    }

    m_ctlPreview.CommitAnnotations();

    hr = m_pImageData->Rotate(dwAngle);
    if (FAILED(hr))
        goto ErrorCleanup;

    // Only if we have an encoder and we haven't been explicitly told not to edit and the source is writeable
    if (m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // on successful edit we immediately save the result.  If we want to do multiple edits
        // before saving then you would simply need to wait and call Save later.

        // NB:  We currently only allow editing of items loaded from file system paths, no path means
        // no edit.  This is stupid, but that's how it is for now.
        hr = ImageDataSave(NULL, FALSE);
        if (SUCCEEDED(hr))
            m_fDirty = FALSE;
        else
        {
            // if we failed to save then go into can't save mode
            if (WINDOW_MODE == m_dwMode)
                m_fCanSave = FALSE;
        }
    }

    _UpdateImage();

    if ((!m_pImageData->IsEditable() || !m_fCanSave) && WINDOW_MODE == m_dwMode)
    {
        if (m_fWarnNoSave)
        {
            m_fWarnNoSave = FALSE;

            CComBSTR bstrMsg, bstrTitle;
            if (bstrMsg.LoadString(IDS_ROTATE_CANTSAVE) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                SHMessageBoxCheck(m_hWnd, bstrMsg, bstrTitle, MB_OK|MB_ICONWARNING, IDOK, REGSTR_SAVELESS);
                m_fPromptingUser = FALSE;
            }
        }
    }

ErrorCleanup:

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(TRUE, 0));

    SetCursorState(SLIDESHOW_CURSOR_NOTBUSY);
    

    return hr;
}

STDMETHODIMP CPreviewWnd::NextPage()
{
    return _PrevNextPage(TRUE);
}

STDMETHODIMP CPreviewWnd::PreviousPage()
{
    return _PrevNextPage(FALSE);
}

HRESULT CPreviewWnd::_PrevNextPage(BOOL fForward)
{
    _RefreshSelection(FALSE);
    if (m_pImageData && m_pImageData->IsMultipage())
    {
        if (m_fDirty)
        {
            m_ctlPreview.CommitAnnotations();
        }
        if (fForward)
        {
            m_pImageData->NextPage();
        }
        else
        {
            m_pImageData->PrevPage();
        }
        _UpdateImage();
        _SetMultipageCommands();
    }
    return S_OK;
}


//
// When the user saves to a format other than TIFF and the current
// TIFF has annotations, we need to burn annotations
// into the current image frame before saving.
// If we ever support other multi-page format encoding besides TIFF, this
// code will get more complicated
// assumes the pSID is already locked
// note that the resulting image is always a color image. Eventually we should make
// the annotation rendering code respect the bit depth and palette of the
// current image.

Image *CPreviewWnd::_BurnAnnotations(IShellImageData *pSID)
{
    Image *pimg = NULL;

    if (SUCCEEDED(pSID->CloneFrame(&pimg)))
    {
        HDC hdc = ::GetDC(NULL);
        if (hdc)
        {
            LPVOID pBits;
            BITMAPINFO bi = {0};

            bi.bmiHeader.biBitCount = 24;
            bi.bmiHeader.biHeight = pimg->GetHeight();
            bi.bmiHeader.biWidth = pimg->GetWidth();
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biCompression = BI_RGB;
            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);

            HBITMAP hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0);
            if (hbm)
            {
                //
                // For ROP codes to work we need to use pure GDI, then convert the new
                // DIBSection back to an Image object
                //
                HDC hdcMem = ::CreateCompatibleDC(hdc);
                Status s = GenericError;
                if (hdcMem)
                {
                    HBITMAP hbmOld = (HBITMAP)::SelectObject(hdcMem, hbm);
                    Graphics *g = Graphics::FromHDC(hdcMem);
                    if (g)
                    {
                        s = g->DrawImage(pimg, 0L, 0L, pimg->GetWidth(), pimg->GetHeight());
                        g->ReleaseHDC(hdcMem);
                        delete g;
                        // now draw the annotations
                        m_ctlPreview.GetAnnotations()->RenderAllMarks(hdcMem);
                    }
                    ::SelectObject(hdcMem, hbmOld);
                    ::DeleteDC(hdcMem);
                }
                if (Ok == s)
                {
                    //
                    // Now create a new Bitmap from our DIBSection
                    Bitmap *pbmNew = Bitmap::FromHBITMAP(hbm, NULL);
                    if (pbmNew)
                    {
                        pSID->ReplaceFrame(pbmNew);
                    }
                }
                DeleteObject(hbm);
            }
            ::ReleaseDC(NULL, hdc);
        }
    }
    return pimg;
}

void CPreviewWnd::_InvokePrintWizard()
{
    if (m_fPrintable)
    {
        HRESULT hr = S_OK;
        if (m_fDirty)
        {
            m_ctlPreview.CommitAnnotations();
            hr = ImageDataSave(NULL, FALSE);
        }
        if (SUCCEEDED(hr))
        {
            m_fPromptingUser = TRUE;
            m_fDirty = FALSE;
            
            IPrintPhotosWizardSetInfo *pwiz;
            HRESULT hr = CoCreateInstance(CLSID_PrintPhotosWizard,
                                          NULL, CLSCTX_INPROC_SERVER,
                                          IID_PPV_ARG(IPrintPhotosWizardSetInfo, &pwiz));
            if (SUCCEEDED(hr))
            {
                if (m_pImageData != NULL && m_pImageData->_guidFormat == ImageFormatTIFF && m_pImageData->IsMultipage())
                    hr = pwiz->SetFileListArray(&(m_ppidls[m_iCurSlide]), 1, 0);
                else
                    hr = pwiz->SetFileListArray(m_ppidls, m_cItems, m_iCurSlide);
                
                if (SUCCEEDED(hr))
                {
                    hr = pwiz->RunWizard();
                }
                pwiz->Release();
            }
            // fall back to the shell if the wizard fails
            if (FAILED(hr))
            {
                _InvokeVerb(TEXT("print"));
            }
            m_fPromptingUser = FALSE;
        }
        else
        {
            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_SAVEFAILED_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
            }
        }
    }
}

void GetTaskIDFromMode(DWORD dwTask, DWORD dwMode, TASKOWNERID *ptoid)
{
    switch (dwTask)
    {
    case GTIDFM_DECODE:
        *ptoid = (SLIDESHOW_MODE == dwMode) ? TOID_SlideshowDecode : TOID_PrimaryDecode;
        break;

    case GTIDFM_DRAW:
        *ptoid = (SLIDESHOW_MODE == dwMode) ? TOID_DrawSlideshowFrame : TOID_DrawFrame;
        break;

    default:
        ASSERTMSG(FALSE, "someone passed bad task to GetTaskIDFromMode");
        break;
    }
}


// Watch for changes in the file we are currently viewing. This ignores changes
// in the file being pre-fetched, but we'll live with that for now.
//
void CPreviewWnd::_RegisterForChangeNotify(BOOL fRegister)
{
    // always deregister the current pidl first
    if (m_uRegister)
    {
        SHChangeNotifyDeregister(m_uRegister);
        m_uRegister = 0;
    }
    if (fRegister)
    {
        SHChangeNotifyEntry cne = {0};
        if (SUCCEEDED(_GetItem(m_iCurSlide, (LPITEMIDLIST*)&cne.pidl)))
        {
            m_uRegister = SHChangeNotifyRegister(m_hWnd,
                                                 SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_NewDelivery,
                                                 SHCNE_DISKEVENTS,
                                                 IV_ONCHANGENOTIFY,
                                                 1, &cne);
            ILFree((LPITEMIDLIST)cne.pidl);
        }
    }
}

LRESULT CPreviewWnd::OnChangeNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // We can assume this notify is for the currently viewed PIDL and the event
    // is one that would force us to reload
    //
    
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, NULL, &lEvent);
    if (pshcnl)
    {
        // we can't render or manipulate deleted files so don't try
        if (!m_fDirty || lEvent == SHCNE_DELETE || lEvent == SHCNE_RENAMEITEM)   
        {
            if (!m_fIgnoreNextNotify)
            {
                if (!m_fIgnoreAllNotifies)
                {
                    m_fDirty = FALSE;
                    _PreviewItem(m_iCurSlide);
                }
            }
            else
            {
                m_fIgnoreNextNotify = FALSE;
            }
            bHandled = TRUE;
        }

        SHChangeNotification_Unlock(pshcnl);
    }
    return 0;
}

LRESULT CPreviewWnd::OnIsAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = TRUE;
    return !m_fPromptingUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\seltrack.cpp ===
#include "precomp.h"
#include "seltrack.h"

#ifndef _countof
#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

#define CX_BORDER   1
#define CY_BORDER   1

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker global state

// various GDI objects we need to draw

class Statics
{
public:
    HCURSOR hCursors[10];
    HBRUSH hHatchBrush;
    HBRUSH hHalftoneBrush;
    HPEN hBlackDottedPen;
    int nHandleSize;
    int nRefCount;

    Statics()
    {
        hCursors[0] = 0;
        hCursors[1] = 0;
        hCursors[2] = 0;
        hCursors[3] = 0;
        hCursors[4] = 0;
        hCursors[5] = 0;
        hCursors[6] = 0;
        hCursors[7] = 0;
        hCursors[8] = 0;
        hCursors[9] = 0;
        hHatchBrush = 0;
        hHalftoneBrush = 0;
        hBlackDottedPen = 0;
        nHandleSize = 0;
        nRefCount=0;
    }

    ~Statics()
    {
        if (hHatchBrush != 0)
            ::DeleteObject(hHatchBrush);
        if (hHalftoneBrush != 0)
            ::DeleteObject(hHalftoneBrush);
        if (hBlackDottedPen != 0)
            ::DeleteObject(hBlackDottedPen);
    };
};

static Statics* s_pStatics = NULL;

// the struct below is used to determine the qualities of a particular handle
struct HANDLEINFO
{
    size_t nOffsetX;    // offset within RECT for X coordinate
    size_t nOffsetY;    // offset within RECT for Y coordinate
    int nCenterX;       // adjust X by Width()/2 * this number
    int nCenterY;       // adjust Y by Height()/2 * this number
    int nHandleX;       // adjust X by handle size * this number
    int nHandleY;       // adjust Y by handle size * this number
    int nInvertX;       // handle converts to this when X inverted
    int nInvertY;       // handle converts to this when Y inverted
};

// this array describes all 8 handles (clock-wise)
static const HANDLEINFO c_HandleInfo[] =
{
    // corner handles (top-left, top-right, bottom-right, bottom-left
    { offsetof(RECT, left), offsetof(RECT, top),        0, 0,  0,  0, 1, 3 },
    { offsetof(RECT, right), offsetof(RECT, top),       0, 0, -1,  0, 0, 2 },
    { offsetof(RECT, right), offsetof(RECT, bottom),    0, 0, -1, -1, 3, 1 },
    { offsetof(RECT, left), offsetof(RECT, bottom),     0, 0,  0, -1, 2, 0 },

    // side handles (top, right, bottom, left)
    { offsetof(RECT, left), offsetof(RECT, top),        1, 0,  0,  0, 4, 6 },
    { offsetof(RECT, right), offsetof(RECT, top),       0, 1, -1,  0, 7, 5 },
    { offsetof(RECT, left), offsetof(RECT, bottom),     1, 0,  0, -1, 6, 4 },
    { offsetof(RECT, left), offsetof(RECT, top),        0, 1,  0,  0, 5, 7 }
};

// the struct below gives us information on the layout of a RECT struct and
//  the relationship between its members
struct RECTINFO
{
    size_t nOffsetAcross;   // offset of opposite point (ie. left->right)
    int nSignAcross;        // sign relative to that point (ie. add/subtract)
};

// this array is indexed by the offset of the RECT member / sizeof(int)
static const RECTINFO c_RectInfo[] =
{
    { offsetof(RECT, right), +1 },
    { offsetof(RECT, bottom), +1 },
    { offsetof(RECT, left), -1 },
    { offsetof(RECT, top), -1 },
};

/////////////////////////////////////////////////////////////////////////////
// SelectionTracking intitialization / cleanup

BOOL InitSelectionTracking()
{
    // Only call this once.
    // Synchronization is the responsibility of the caller.
    if (s_pStatics != NULL)
    {
        s_pStatics->nRefCount++;
        return true;
    }

    s_pStatics = new Statics;

    // sanity checks for assumptions we make in the code
    ASSERT(sizeof(((RECT*)NULL)->left) == sizeof(int));
    ASSERT(offsetof(RECT, top) > offsetof(RECT, left));
    ASSERT(offsetof(RECT, right) > offsetof(RECT, top));
    ASSERT(offsetof(RECT, bottom) > offsetof(RECT, right));

    // create the hatch pattern + bitmap
    WORD hatchPattern[8];
    WORD wPattern = 0x1111;
    for (int i = 0; i < 4; i++)
    {
        hatchPattern[i] = wPattern;
        hatchPattern[i+4] = wPattern;
        wPattern <<= 1;
    }

    HBITMAP hatchBitmap = ::CreateBitmap(8, 8, 1, 1, hatchPattern);
    if (hatchBitmap == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // create black hatched brush
    s_pStatics->hHatchBrush = ::CreatePatternBrush(hatchBitmap);
    DeleteObject(hatchBitmap);

    if (s_pStatics->hHatchBrush == NULL)
    {
        delete s_pStatics;
        return false;
    }

    WORD grayPattern[8];
    for (int i = 0; i < 8; i++)
        grayPattern[i] = (WORD)(0x5555 << (i & 1));

    HBITMAP grayBitmap = ::CreateBitmap(8, 8, 1, 1, grayPattern);
    if (grayBitmap == NULL)
    {
        delete s_pStatics;
        return false;
    }

    s_pStatics->hHalftoneBrush = ::CreatePatternBrush(grayBitmap);
    DeleteObject(grayBitmap);
    if (s_pStatics->hHalftoneBrush == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // create black dotted pen
    s_pStatics->hBlackDottedPen = ::CreatePen(PS_DOT, 0, RGB(0, 0, 0));
    if (s_pStatics->hBlackDottedPen == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // initialize the cursor array
    s_pStatics->hCursors[0] = ::LoadCursor(NULL, IDC_SIZENWSE);
    s_pStatics->hCursors[1] = ::LoadCursor(NULL, IDC_SIZENESW);
    s_pStatics->hCursors[2] = s_pStatics->hCursors[0];
    s_pStatics->hCursors[3] = s_pStatics->hCursors[1];
    s_pStatics->hCursors[4] = ::LoadCursor(NULL, IDC_SIZENS);
    s_pStatics->hCursors[5] = ::LoadCursor(NULL, IDC_SIZEWE);
    s_pStatics->hCursors[6] = s_pStatics->hCursors[4];
    s_pStatics->hCursors[7] = s_pStatics->hCursors[5];
    s_pStatics->hCursors[8] = ::LoadCursor(NULL, IDC_SIZEALL);
    s_pStatics->hCursors[9] = s_pStatics->hCursors[8];

    s_pStatics->nHandleSize = 6;

    s_pStatics->nRefCount = 1;
    return true;
}

void CleanupSelectionTracking()
{
    // Only call this once.
    // Synchronization is the responsibility of the caller.
    if (s_pStatics != NULL)
    {
        s_pStatics->nRefCount--;
        if (s_pStatics->nRefCount == 0)
        {
            delete s_pStatics;
            s_pStatics = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker intitialization

CSelectionTracker::CSelectionTracker()
{
    ASSERT(s_pStatics != NULL);

    m_uStyle = 0;
    m_nHandleSize = s_pStatics->nHandleSize;
    m_sizeMin.cy = m_sizeMin.cx = m_nHandleSize*2;

    m_rect.SetRectEmpty();

    _rectLast.SetRectEmpty();
    _sizeLast.cx = _sizeLast.cy = 0;
    _bErase = false;
    _bFinalErase =  false;
    _bAllowInvert = true;
}


CSelectionTracker::~CSelectionTracker()
{
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker operations

void CSelectionTracker::Draw(HDC hdc) const
{
    ASSERT(s_pStatics != NULL);

    // set initial DC state
    if (::SaveDC(hdc) == 0)
    {
        ASSERT(false);
    }

    ::SetMapMode(hdc, MM_TEXT);
    ::SetViewportOrgEx(hdc, 0, 0, NULL);
    ::SetWindowOrgEx(hdc, 0, 0, NULL);

    // get normalized rectangle
    CRect rect = m_rect;
    rect.NormalizeRect();

    HPEN hOldPen = NULL;
    HBRUSH hOldBrush = NULL;
    HGDIOBJ hTemp;
    int nOldROP;

    // draw lines
    if ((m_uStyle & (dottedLine|solidLine)) != 0)
    {
        if (m_uStyle & dottedLine)
        {
            hOldPen = (HPEN)::SelectObject(hdc, s_pStatics->hBlackDottedPen);
        }
        else
        {
            hOldPen = (HPEN)::SelectObject(hdc, GetStockObject(BLACK_PEN));
        }

        hOldBrush = (HBRUSH)::SelectObject(hdc, GetStockObject(NULL_BRUSH));

        nOldROP = ::SetROP2(hdc, R2_COPYPEN);
        rect.InflateRect(+1, +1); // borders are one pixel outside

        ::Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom);
        ::SetROP2(hdc, nOldROP);
    }

    // if hatchBrush is going to be used, need to unrealize it
    if ((m_uStyle & (hatchInside|hatchedBorder)) != 0)
        ::UnrealizeObject(s_pStatics->hHatchBrush);

    // hatch inside
    if ((m_uStyle & hatchInside) != 0)
    {
        hTemp = ::SelectObject(hdc, GetStockObject(NULL_PEN));
        if (hOldPen == NULL)
            hOldPen = (HPEN)hTemp;
        hTemp = ::SelectObject(hdc, s_pStatics->hHatchBrush);
        if (hOldBrush == NULL)
            hOldBrush = (HBRUSH)hTemp;

        ::SetBkMode(hdc, TRANSPARENT);
        nOldROP = ::SetROP2(hdc, R2_MASKNOTPEN);

        ::Rectangle(hdc, rect.left+1, rect.top+1, rect.right, rect.bottom);
        ::SetROP2(hdc, nOldROP);
    }

    // draw hatched border
    if ((m_uStyle & hatchedBorder) != 0)
    {
        hTemp = ::SelectObject(hdc, s_pStatics->hHatchBrush);
        if (hOldBrush == NULL)
            hOldBrush = (HBRUSH)hTemp;
        ::SetBkMode(hdc, OPAQUE);
        CRect rectTrue;
        GetTrueRect(&rectTrue);

        ::PatBlt(hdc, rectTrue.left, rectTrue.top, rectTrue.Width(), rect.top-rectTrue.top, 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rectTrue.left, rect.bottom, rectTrue.Width(), rectTrue.bottom-rect.bottom, 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rectTrue.left, rect.top, rect.left-rectTrue.left, rect.Height(), 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rect.right, rect.top, rectTrue.right-rect.right, rect.Height(), 0x000F0001 /* Pn */);
    }

    // draw resize handles
    if ((m_uStyle & (resizeInside|resizeOutside)) != 0)
    {
        UINT mask = _GetHandleMask();
        for (int i = 0; i < 8; ++i)
        {
            if (mask & (1<<i))
            {
                _GetHandleRect((TrackerHit)i, &rect);
                ::SetBkColor(hdc, RGB(0, 0, 0));
                ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
            }
        }
    }

    // cleanup pDC state
    if (hOldPen != NULL)
        ::SelectObject(hdc, hOldPen);
    if (hOldBrush != NULL)
        ::SelectObject(hdc, hOldBrush);

    if (::RestoreDC(hdc, -1) == 0)
    {
        ASSERT(false);
    }
}

BOOL CSelectionTracker::SetCursor(HWND hwnd, LPARAM lParam) const
{
    ASSERT(s_pStatics != NULL);

    UINT uHitTest = (short)LOWORD(lParam);

    // trackers should only be in client area
    if (uHitTest != HTCLIENT)
        return FALSE;

    // convert cursor position to client co-ordinates
    CPoint point;
    ::GetCursorPos(&point);
    ::ScreenToClient(hwnd, &point);

    // do hittest and normalize hit
    int nHandle = _HitTestHandles(point);
    if (nHandle < 0)
        return FALSE;

    // need to normalize the hittest such that we get proper cursors
    nHandle = NormalizeHit(nHandle);

    // handle special case of hitting area between handles
    //  (logically the same -- handled as a move -- but different cursor)
    if (nHandle == hitMiddle && !m_rect.PtInRect(point))
    {
        // only for trackers with hatchedBorder (ie. in-place resizing)
        if (m_uStyle & hatchedBorder)
            nHandle = (TrackerHit)9;
    }

    ASSERT(nHandle < _countof(s_pStatics->hCursors));
    ::SetCursor(s_pStatics->hCursors[nHandle]);
    return TRUE;
}

int CSelectionTracker::HitTest(CPoint point) const
{
    ASSERT(s_pStatics != NULL);

    TrackerHit hitResult = hitNothing;

    CRect rectTrue;
    GetTrueRect(&rectTrue);
    ASSERT(rectTrue.left <= rectTrue.right);
    ASSERT(rectTrue.top <= rectTrue.bottom);
    if (rectTrue.PtInRect(point))
    {
        if ((m_uStyle & (resizeInside|resizeOutside)) != 0)
            hitResult = (TrackerHit)_HitTestHandles(point);
        else
            hitResult = hitMiddle;
    }
    return hitResult;
}

int CSelectionTracker::NormalizeHit(int nHandle) const
{
    ASSERT(s_pStatics != NULL);

    ASSERT(nHandle <= 8 && nHandle >= -1);
    if (nHandle == hitMiddle || nHandle == hitNothing)
        return nHandle;
    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    if (m_rect.Width() < 0)
    {
        nHandle = (TrackerHit)pHandleInfo->nInvertX;
        pHandleInfo = &c_HandleInfo[nHandle];
    }
    if (m_rect.Height() < 0)
        nHandle = (TrackerHit)pHandleInfo->nInvertY;
    return nHandle;
}

BOOL CSelectionTracker::Track(HWND hwnd, CPoint point, BOOL bAllowInvert, HWND hwndClipTo)
{
    ASSERT(s_pStatics != NULL);

    // perform hit testing on the handles
    int nHandle = _HitTestHandles(point);
    if (nHandle < 0)
    {
        // didn't hit a handle, so just return FALSE
        return FALSE;
    }

    if (m_uStyle & lineSelection)
    {
        bAllowInvert = true;
        _sizeMin = CSize(0, 0);
    }
    else
    {
        _sizeMin = m_sizeMin;
    }

    // otherwise, call helper function to do the tracking
    _bAllowInvert = bAllowInvert;
    return _TrackHandle(nHandle, hwnd, point, hwndClipTo);
}

BOOL CSelectionTracker::TrackRubberBand(HWND hwnd, CPoint point, BOOL bAllowInvert)
{
    ASSERT(s_pStatics != NULL);

    // simply call helper function to track from bottom right handle

    if (m_uStyle & lineSelection)
    {
        bAllowInvert = true;
        _sizeMin = CSize(0, 0);
    }
    else
    {
        _sizeMin = m_sizeMin;
    }
    _bAllowInvert = bAllowInvert;
    m_rect.SetRect(point.x, point.y, point.x, point.y);
    return _TrackHandle(hitBottomRight, hwnd, point, NULL);
}

void CSelectionTracker::_DrawTrackerRect(LPCRECT lpRect, HWND hwndClipTo, HDC hdc, HWND hwnd)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(lpRect != NULL);

    // first, normalize the rectangle for drawing
    CRect rect(0,0,0,0);
    if (lpRect)
        rect = *lpRect;

    if (!(m_uStyle & lineSelection))
    {
        rect.NormalizeRect();
    }

    // convert to client coordinates
    if (hwndClipTo != NULL)
    {
        ::ClientToScreen(hwnd, (LPPOINT)(LPRECT)&rect);
        ::ClientToScreen(hwnd, ((LPPOINT)(LPRECT)&rect)+1);
        if (IS_WINDOW_RTL_MIRRORED(hwnd))
        {
            LONG temp = rect.left;
            rect.left = rect.right;
            rect.right = temp;
        }

        ::ScreenToClient(hwndClipTo, (LPPOINT)(LPRECT)&rect);
        ::ScreenToClient(hwndClipTo, ((LPPOINT)(LPRECT)&rect)+1);
        if (IS_WINDOW_RTL_MIRRORED(hwndClipTo))
        {
            LONG temp = rect.left;
            rect.left = rect.right;
            rect.right = temp;
        }
    }

    CSize size(0, 0);
    if (!_bFinalErase)
    {
        // otherwise, size depends on the style
        if (m_uStyle & hatchedBorder)
        {
            size.cx = size.cy = max(1, _GetHandleSize(rect)-1);
            rect.InflateRect(size);
        }
        else
        {
            size.cx = CX_BORDER;
            size.cy = CY_BORDER;
        }
    }

    // and draw it
    if ((_bFinalErase || !_bErase) && hdc)
        _DrawDragRect(hdc, rect, size, _rectLast, _sizeLast);

    // remember last rectangles
    _rectLast = rect;
    _sizeLast = size;
}

void CSelectionTracker::_AdjustRect(int nHandle, LPRECT)
{
    ASSERT(s_pStatics != NULL);

    if (nHandle == hitMiddle)
        return;

    // convert the handle into locations within m_rect
    int *px, *py;
    _GetModifyPointers(nHandle, &px, &py, NULL, NULL);

    // enforce minimum width
    int nNewWidth = m_rect.Width();
    int nAbsWidth = _bAllowInvert ? abs(nNewWidth) : nNewWidth;
    if (px != NULL && nAbsWidth < _sizeMin.cx)
    {
        nNewWidth = nAbsWidth != 0 ? nNewWidth / nAbsWidth : 1;
        ASSERT((int*)px - (int*)&m_rect < _countof(c_RectInfo));
        const RECTINFO* pRectInfo = &c_RectInfo[(int*)px - (int*)&m_rect];
        *px = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
            nNewWidth * _sizeMin.cx * -pRectInfo->nSignAcross;
    }

    // enforce minimum height
    int nNewHeight = m_rect.Height();
    int nAbsHeight = _bAllowInvert ? abs(nNewHeight) : nNewHeight;
    if (py != NULL && nAbsHeight < _sizeMin.cy)
    {
        nNewHeight = nAbsHeight != 0 ? nNewHeight / nAbsHeight : 1;
        ASSERT((int*)py - (int*)&m_rect < _countof(c_RectInfo));
        const RECTINFO* pRectInfo = &c_RectInfo[(int*)py - (int*)&m_rect];
        *py = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
            nNewHeight * _sizeMin.cy * -pRectInfo->nSignAcross;
    }
}

void CSelectionTracker::GetTrueRect(LPRECT lpTrueRect) const
{
    ASSERT(s_pStatics != NULL);

    CRect rect = m_rect;
    rect.NormalizeRect();
    int nInflateBy = 0;
    if ((m_uStyle & (resizeOutside|hatchedBorder)) != 0)
        nInflateBy += _GetHandleSize() - 1;
    if ((m_uStyle & (solidLine|dottedLine)) != 0)
        ++nInflateBy;
    rect.InflateRect(nInflateBy, nInflateBy);
    *lpTrueRect = rect;
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker implementation helpers

void CSelectionTracker::_GetHandleRect(int nHandle, CRect* pHandleRect) const
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle < 8);

    // get normalized rectangle of the tracker
    CRect rectT = m_rect;
    rectT.NormalizeRect();
    if ((m_uStyle & (solidLine|dottedLine)) != 0)
        rectT.InflateRect(+1, +1);

    // since the rectangle itself was normalized, we also have to invert the
    //  resize handles.
    nHandle = NormalizeHit(nHandle);

    // handle case of resize handles outside the tracker
    int size = _GetHandleSize();
    if (m_uStyle & resizeOutside)
        rectT.InflateRect(size-1, size-1);

    // calculate position of the resize handle
    int nWidth = rectT.Width();
    int nHeight = rectT.Height();
    CRect rect;
    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    rect.left = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetX);
    rect.top = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetY);
    rect.left += size * pHandleInfo->nHandleX;
    rect.top += size * pHandleInfo->nHandleY;
    rect.left += pHandleInfo->nCenterX * (nWidth - size) / 2;
    rect.top += pHandleInfo->nCenterY * (nHeight - size) / 2;
    rect.right = rect.left + size;
    rect.bottom = rect.top + size;

    *pHandleRect = rect;
}

int CSelectionTracker::_GetHandleSize(LPCRECT lpRect) const
{
    ASSERT(s_pStatics != NULL);

    if (lpRect == NULL)
        lpRect = &m_rect;

    int size = m_nHandleSize;
    if (!(m_uStyle & resizeOutside))
    {
        // make sure size is small enough for the size of the rect
        int sizeMax = min(abs(lpRect->right - lpRect->left),
            abs(lpRect->bottom - lpRect->top));
        if (size * 2 > sizeMax)
            size = sizeMax / 2;
    }
    return size;
}

int CSelectionTracker::_HitTestHandles(CPoint point) const
{
    ASSERT(s_pStatics != NULL);

    CRect rect;
    UINT mask = _GetHandleMask();

    // see if hit anywhere inside the tracker
    GetTrueRect(&rect);
    if (!rect.PtInRect(point))
        return hitNothing;  // totally missed

    // see if we hit a handle
    for (int i = 0; i < 8; ++i)
    {
        if (mask & (1<<i))
        {
            _GetHandleRect((TrackerHit)i, &rect);
            if (rect.PtInRect(point))
                return (TrackerHit)i;
        }
    }

    // last of all, check for non-hit outside of object, between resize handles
    if ((m_uStyle & hatchedBorder) == 0)
    {
        CRect rect = m_rect;
        rect.NormalizeRect();
        if ((m_uStyle & dottedLine|solidLine) != 0)
            rect.InflateRect(+1, +1);
        if (!rect.PtInRect(point))
            return hitNothing;  // must have been between resize handles
    }
    return hitMiddle;   // no handle hit, but hit object (or object border)
}

BOOL CSelectionTracker::_TrackHandle(int nHandle, HWND hwnd, CPoint point, HWND hwndClipTo)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle >= 0 && nHandle <= 8);   // handle 8 is inside the rect

    // don't handle if capture already set
    if (::GetCapture() != NULL)
        return FALSE;

    ASSERT(!_bFinalErase);

    // save original width & height in pixels
    int nWidth = m_rect.Width();
    int nHeight = m_rect.Height();

    // set capture to the window which received this message
    ::SetCapture(hwnd);
    ASSERT(hwnd == ::GetCapture());

    UpdateWindow(hwnd);

    if (hwndClipTo != NULL)
        UpdateWindow(hwndClipTo);

    CRect rectSave = m_rect;

    // find out what x/y coords we are supposed to modify
    int *px, *py;
    int xDiff, yDiff;
    _GetModifyPointers(nHandle, &px, &py, &xDiff, &yDiff);
    xDiff = point.x - xDiff;
    yDiff = point.y - yDiff;

    // get DC for drawing
    HDC hdcDraw;
    if (hwndClipTo != NULL)
    {
        // clip to arbitrary window by using adjusted Window DC
        hdcDraw = ::GetDCEx(hwndClipTo, NULL, DCX_CACHE);
    }
    else
    {
        // otherwise, just use normal DC
        hdcDraw = ::GetDC(hwnd);
    }
    ASSERT(hdcDraw != NULL);

    CRect rectOld;
    BOOL bMoved = FALSE;

    // get messages until capture lost or cancelled/accepted
    for (;;)
    {
        MSG msg;
        if (!::GetMessage(&msg, NULL, 0, 0))
        {
            ASSERT(false);
        }

        if (hwnd != ::GetCapture())
            break;

        switch (msg.message)
        {
        // handle movement/accept messages
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
            rectOld = m_rect;
            // handle resize cases (and part of move)
            if (px != NULL)
                *px = (int)(short)LOWORD(msg.lParam) - xDiff;
            if (py != NULL)
                *py = (int)(short)HIWORD(msg.lParam) - yDiff;

            // handle move case
            if (nHandle == hitMiddle)
            {
                m_rect.right = m_rect.left + nWidth;
                m_rect.bottom = m_rect.top + nHeight;
            }
            // allow caller to adjust the rectangle if necessary
            _AdjustRect(nHandle, &m_rect);

            // only redraw and callback if the rect actually changed!
            _bFinalErase = (msg.message == WM_LBUTTONUP);
            if (!rectOld.EqualRect(&m_rect) || _bFinalErase)
            {
                if (bMoved)
                {
                    _bErase = TRUE;
                    _DrawTrackerRect(&rectOld, hwndClipTo, hdcDraw, hwnd);
                }
                if (msg.message != WM_LBUTTONUP)
                    bMoved = TRUE;
            }
            if (_bFinalErase)
                goto ExitLoop;

            if (!rectOld.EqualRect(&m_rect))
            {
                _bErase = FALSE;
                _DrawTrackerRect(&m_rect, hwndClipTo, hdcDraw, hwnd);
            }
            break;

        // handle cancel messages
        case WM_KEYDOWN:
            if (msg.wParam != VK_ESCAPE)
                break;
        case WM_RBUTTONDOWN:
            if (bMoved)
            {
                _bErase = _bFinalErase = TRUE;
                _DrawTrackerRect(&m_rect, hwndClipTo, hdcDraw, hwnd);
            }
            m_rect = rectSave;
            goto ExitLoop;

        // just dispatch rest of the messages
        default:
            ::DispatchMessage(&msg);
            break;
        }
    }

ExitLoop:
    if (hdcDraw != NULL)
    {
        if (hwndClipTo != NULL)
            ::ReleaseDC(hwndClipTo, hdcDraw);
        else
            ::ReleaseDC(hwnd, hdcDraw);
    }

    ::ReleaseCapture();

    // restore rect in case bMoved is still FALSE
    if (!bMoved)
        m_rect = rectSave;
    _bFinalErase = FALSE;
    _bErase = FALSE;

    // return TRUE only if rect has changed
    return !rectSave.EqualRect(&m_rect);
}

void CSelectionTracker::_GetModifyPointers(int nHandle, int** ppx, int** ppy, int* px, int* py)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle >= 0 && nHandle <= 8);

    if (nHandle == hitMiddle)
        nHandle = hitTopLeft;   // same as hitting top-left

    *ppx = NULL;
    *ppy = NULL;

    // fill in the part of the rect that this handle modifies
    //  (Note: handles that map to themselves along a given axis when that
    //   axis is inverted don't modify the value on that axis)

    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    if (pHandleInfo->nInvertX != nHandle)
    {
        *ppx = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetX);
        if (px != NULL)
            *px = **ppx;
    }
    else
    {
        // middle handle on X axis
        if (px != NULL)
            *px = m_rect.left + abs(m_rect.Width()) / 2;
    }
    if (pHandleInfo->nInvertY != nHandle)
    {
        *ppy = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetY);
        if (py != NULL)
            *py = **ppy;
    }
    else
    {
        // middle handle on Y axis
        if (py != NULL)
            *py = m_rect.top + abs(m_rect.Height()) / 2;
    }
}

UINT CSelectionTracker::_GetHandleMask() const
{
    ASSERT(s_pStatics != NULL);
    UINT mask;

    if (m_uStyle & lineSelection)
    {
        mask = 0x05;
    }
    else
    {
        mask = 0x0F;   // always have 4 corner handles

        int size = m_nHandleSize*3;
        if (abs(m_rect.Width()) - size > 4)
            mask |= 0x50;
        if (abs(m_rect.Height()) - size > 4)
            mask |= 0xA0;
    }
    return mask;
}

void CSelectionTracker::_DrawDragRect(HDC hdc, LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast)
{
    if (m_uStyle & lineSelection)
    {
        int nOldROP = ::SetROP2(hdc, R2_NOTXORPEN);
        HPEN hOldPen =(HPEN)::SelectObject(hdc, (HPEN)s_pStatics->hBlackDottedPen);

        if (lpRectLast != NULL)
        {
            CRect rectLast = *lpRectLast;

            ::MoveToEx(hdc, rectLast.left, rectLast.top, NULL);
            ::LineTo(hdc, rectLast.right, rectLast.bottom);
        }
        
        CRect rect = *lpRect;

        ::MoveToEx(hdc, rect.left, rect.top, NULL);
        ::LineTo(hdc, rect.right, rect.bottom);

        ::SelectObject(hdc, hOldPen);
        ::SetROP2(hdc, nOldROP);
    }
    else
    {
        // first, determine the update region and select it
        HRGN hrgnOutside = ::CreateRectRgnIndirect(lpRect);

        CRect rect = *lpRect;
        rect.InflateRect(-size.cx, -size.cy);
        rect.IntersectRect(rect, lpRect);

        HRGN hrgnInside = ::CreateRectRgnIndirect(&rect);
        HRGN hrgnNew = ::CreateRectRgn(0, 0, 0, 0);
        ::CombineRgn(hrgnNew, hrgnOutside, hrgnInside, RGN_XOR);

        HRGN hrgnLast = NULL;
        HRGN hrgnUpdate = NULL;

        if (lpRectLast != NULL)
        {
            // find difference between new region and old region
            hrgnLast = ::CreateRectRgn(0, 0, 0, 0);
            ::SetRectRgn(hrgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
            rect = *lpRectLast;
            rect.InflateRect(-sizeLast.cx, -sizeLast.cy);
            rect.IntersectRect(rect, lpRectLast);
            ::SetRectRgn(hrgnInside, rect.left, rect.top, rect.right, rect.bottom);
            ::CombineRgn(hrgnLast, hrgnOutside, hrgnInside, RGN_XOR);
            hrgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
            ::CombineRgn(hrgnUpdate, hrgnLast, hrgnNew, RGN_XOR);
        }

        // draw into the update/new region
        if (hrgnUpdate != NULL)
            ::SelectClipRgn(hdc, hrgnUpdate);
        else
            ::SelectClipRgn(hdc, hrgnNew);

        ::GetClipBox(hdc, &rect);

        HBRUSH hBrushOld = (HBRUSH)::SelectObject(hdc, s_pStatics->hHalftoneBrush);
        ::PatBlt(hdc, rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
        ::SelectObject(hdc, hBrushOld);

        ::SelectClipRgn(hdc, NULL);

        if (hrgnOutside != NULL)
            ::DeleteObject(hrgnOutside);
        if (hrgnInside != NULL)
            ::DeleteObject(hrgnInside);
        if (hrgnNew != NULL)
            ::DeleteObject(hrgnNew);
        if (hrgnLast != NULL)
            ::DeleteObject(hrgnLast);
        if (hrgnUpdate != NULL)
            ::DeleteObject(hrgnUpdate);
    }
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\shutil.h ===
#include <objbase.h>
#include <assert.h>
#include <shlwapi.h>
#include <stdio.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <ccstock.h>
#include <shlwapip.h>
#include "tasks.h"

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile);
HRESULT GetUIObjectFromPath(LPCTSTR pszFile, REFIID riid, void **ppv);
BOOL FmtSupportsMultiPage(IShellImageData *pData, GUID *pguidFmt);

// S_OK -> YES, S_FALSE -> NO, FAILED(hr) otherwise
STDAPI IsSameFile(LPCTSTR pszFile1, LPCTSTR pszFile2);

HRESULT SetWallpaperHelper(LPCWSTR szPath);

// Image options
#define IMAGEOPTION_CANROTATE    0x00000001
#define IMAGEOPTION_CANWALLPAPER 0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\tasks.cpp ===
#include "precomp.h"
#include "tasks.h"
#include "prevwnd.h"

void DeleteBuffer(Buffer * pBuf)
{
    if (pBuf)
    {
        if (pBuf->hbmOld)
            SelectObject(pBuf->hdc, pBuf->hbmOld);
        if (pBuf->hPalOld)
            SelectPalette(pBuf->hdc, pBuf->hPalOld, FALSE);
        if (pBuf->hbm)
            DeleteObject(pBuf->hbm);
        if (pBuf->hPal)
            DeleteObject(pBuf->hPal);   
        if (pBuf->hdc)
            DeleteDC(pBuf->hdc);    
        delete pBuf;
    }
}


////////////////////////////////////////////////////////////////////////////
//
// CDecodeTask
//
////////////////////////////////////////////////////////////////////////////

CDecodeTask::CDecodeTask() : CRunnableTask(RTF_DEFAULT)
{
    InitializeCriticalSection(&_cs);
};

CDecodeTask::~CDecodeTask()
{
    ATOMICRELEASE(_pstrm);
    ATOMICRELEASE(_pfactory);
    if (_pszFilename)
        LocalFree(_pszFilename);
    ATOMICRELEASE(_pSID);
    DeleteCriticalSection(&_cs);
    if (_ppi)
        delete [] _ppi;
}

HRESULT CDecodeTask::Create(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd, IRunnableTask ** ppTask)
{
    *ppTask = NULL;
    CDecodeTask * pTask = new CDecodeTask();
    if (!pTask)
        return E_OUTOFMEMORY;

    HRESULT hr = pTask->_Initialize(pstrm, pszFilename, iItem, pFactory, hwnd);
    if (SUCCEEDED(hr))
    {
        *ppTask = (IRunnableTask*)pTask;
    }
    else
    {
        pTask->Release();
    }
    return hr;
}

HRESULT CDecodeTask::_Initialize(IStream *pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory *pFactory, HWND hwnd)
{
    if (pstrm)
    {
        STATSTG stat;
        if (SUCCEEDED(pstrm->Stat(&stat, 0)))
        {
            _pszFilename = StrDup(stat.pwcsName);
            _fIsReadOnly = !(stat.grfMode & STGM_WRITE);
            CoTaskMemFree(stat.pwcsName);
        }
        _pstrm = pstrm;
        _pstrm->AddRef();
    }
    else
    {
        _pszFilename = StrDup(pszFilename);
        if (!_pszFilename)
            return E_OUTOFMEMORY;
    }
    if (!_pstrm && _pszFilename)
    {
        SHGetFileInfo(_pszFilename, 0, &_sfi, sizeof(_sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    }
    else
    {
        ZeroMemory(&_sfi, sizeof(_sfi));
    }
    _pfactory = pFactory;
    _pfactory->AddRef();

    _hwndNotify = hwnd;
    _iItem = iItem;

    return S_OK;
}

HRESULT CDecodeTask::RunInitRT()
{
    HRESULT hr;

    EnterCriticalSection(&_cs);
    if (_pstrm)
    {
        hr = _pfactory->CreateImageFromStream(_pstrm, &_pSID);
    }
    else
    {
        hr = _pfactory->CreateImageFromFile(_pszFilename, &_pSID);
        _fIsReadOnly = (GetFileAttributes(_pszFilename) & FILE_ATTRIBUTE_READONLY);
    }

    if (SUCCEEDED(hr))
    {
        hr = _pSID->Decode(SHIMGDEC_LOADFULL,0,0);
        if (SUCCEEDED(hr))
        {
            _pSID->GetPageCount(&_cImages);
            _ppi = new PageInfo[_cImages];

            if (_ppi)
            {
                _iCurrent = 0;
                _fAnimated = (S_OK == _pSID->IsAnimated());
                _fEditable = (S_OK == _pSID->IsEditable());
                PixelFormat pf;
                _pSID->GetPixelFormat(&pf);
                _fExtendedPF = IsExtendedPixelFormat(pf);

                _pSID->GetRawDataFormat(&_guidFormat);
                for (ULONG i = 0; i < _cImages; i++)
                {
                    _pSID->SelectPage(i);   // this works for animated and multipage
                    _pSID->GetSize(&_ppi[i].szImage);
                    _pSID->GetResolution(&_ppi[i].xDPI, &_ppi[i].yDPI);
                    if (_fAnimated)
                        _pSID->GetDelay(&_ppi[i].dwDelay);
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(_pSID);
        }
    }
    LeaveCriticalSection(&_cs);

    AddRef();
    _hr = hr;
    if (!PostMessage(_hwndNotify, IV_SETIMAGEDATA, (WPARAM)this, NULL))
    {
        Release();
    }

    return S_OK;
}

BOOL CDecodeTask::GetSize(SIZE * psz)
{
    if (!_ppi)
        return FALSE;
    *psz = _ppi[_iCurrent].szImage;
    return TRUE;
 }

BOOL CDecodeTask::GetResolution(ULONG * px, ULONG * py)
{
    if (!_ppi)
        return FALSE;
    *px = _ppi[_iCurrent].xDPI;
    *py = _ppi[_iCurrent].yDPI;
    return TRUE;
}

DWORD CDecodeTask::GetDelay()
{
    if (!_ppi)
        return 0;
    return _ppi[_iCurrent].dwDelay;
}

BOOL CDecodeTask::NextPage()
{
    if (_iCurrent >= _cImages-1)
        return FALSE;

    _iCurrent++;
    return TRUE;
}


BOOL CDecodeTask::PrevPage()
{
    if (_iCurrent == 0)
        return FALSE;

    _iCurrent--;
    return TRUE;
}

BOOL CDecodeTask::NextFrame()
{
    EnterCriticalSection(&_cs);
    HRESULT hr = _pSID->NextFrame();
    LeaveCriticalSection(&_cs);

    if (S_OK==hr)
    {
        _iCurrent = (_iCurrent+1) % _cImages;
    }
    return (S_OK == hr);
}

BOOL CDecodeTask::SelectPage(ULONG nPage)
{
    if (nPage >= _cImages)
        return FALSE;

    _iCurrent = nPage;
    return TRUE;
}

BOOL CDecodeTask::ChangePage(CAnnotationSet& Annotations)
{
    BOOL bResult = FALSE;
    EnterCriticalSection(&_cs);
    HRESULT hr = _pSID->SelectPage(_iCurrent);
    if (SUCCEEDED(hr))
    {
        // If we are moving onto a page that was previously rotated
        // but not saved then our cached size and resolution will be wrong
        _pSID->GetSize(&_ppi[_iCurrent].szImage);
        _pSID->GetResolution(&_ppi[_iCurrent].xDPI, &_ppi[_iCurrent].yDPI);
        
        Annotations.SetImageData(_pSID);
        bResult = TRUE;
    }
    LeaveCriticalSection(&_cs);

    return bResult;
}

HRESULT CDecodeTask::Rotate(DWORD dwAngle)
{
    HRESULT hr;
    EnterCriticalSection(&_cs);
    hr = _pSID->Rotate(dwAngle);
    if (SUCCEEDED(hr))
    {
        ULONG dwTmp = _ppi[_iCurrent].szImage.cx;
        _ppi[_iCurrent].szImage.cx = _ppi[_iCurrent].szImage.cy;
        _ppi[_iCurrent].szImage.cy = dwTmp;
        if (dwAngle == 90 || dwAngle == 270)
        {
            dwTmp = _ppi[_iCurrent].xDPI;
            _ppi[_iCurrent].xDPI =_ppi[_iCurrent].yDPI;
            _ppi[_iCurrent].yDPI = dwTmp;
        }
        
    }
    LeaveCriticalSection(&_cs);
    return hr;
}

HRESULT CDecodeTask::Lock(IShellImageData ** ppSID)
{
    if (_pSID)
    {
        EnterCriticalSection(&_cs);
        *ppSID = _pSID;
        return S_OK;
    }

    *ppSID = NULL;
    return E_FAIL;
}

HRESULT CDecodeTask::Unlock()
{
    LeaveCriticalSection(&_cs);
    return S_OK;
}

BOOL CDecodeTask::DisplayName(LPTSTR psz, UINT cch)
{
    // TODO:  Just call the _pSID->DisplayName
    if (_sfi.szDisplayName[0])
    {   
        StrCpyN(psz, _sfi.szDisplayName, cch);
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
// CDrawTask
//
////////////////////////////////////////////////////////////////////////////

CDrawTask::CDrawTask() : CRunnableTask(RTF_SUPPORTKILLSUSPEND)
{
}

CDrawTask::~CDrawTask()
{
    if (_pImgData)
        _pImgData->Release();

    // DeleteBuffer is going to check for NULL anyway
    DeleteBuffer(_pBuf);
}

HRESULT CDrawTask::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (riid == IID_IShellImageDataAbort)
    {
        *ppvObj = static_cast<IShellImageDataAbort*>(this);
        AddRef();
        return S_OK;
    }

    return CRunnableTask::QueryInterface(riid, ppvObj);
}


HRESULT CDrawTask::Create(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg, IRunnableTask ** ppTask)
{
    *ppTask = NULL;

    CDrawTask * pTask = new CDrawTask();
    if (!pTask)
        return E_OUTOFMEMORY;

    HRESULT hr = pTask->_Initialize(pImageData, clr, rcSrc, rcDest, hwnd, uMsg);
    if (SUCCEEDED(hr))
    {
        *ppTask = (IRunnableTask*)pTask;
    }
    else
    {
        pTask->Release();
    }
    return hr;
}

HRESULT CDrawTask::_Initialize(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg)
{
    _pImgData = pImageData;
    _pImgData->AddRef();
    _dwPage = _pImgData->_iCurrent;
    _clrBkgnd = clr;
    _rcSrc = rcSrc;
    _hwndNotify = hwnd;
    _uMsgNotify = uMsg;
    _pBuf = new Buffer;
    if (!_pBuf)
        return E_OUTOFMEMORY;

    _pBuf->rc = rcDest;
    _pBuf->hPal = NULL;
    return S_OK;
}

typedef RGBQUAD RGBQUAD8[256];

HBITMAP _CreateBitmap(HDC hdcWnd, Buffer *pBuf, SIZE *pSize)
{
    int bpp = GetDeviceCaps(hdcWnd, BITSPIXEL);
    HBITMAP hbm = NULL;
    if (8==bpp)
    {
        PVOID pvBits = NULL;
        struct 
        {
            BITMAPINFOHEADER bmih;
            RGBQUAD8 rgbquad8;
        } bmi;
        bmi.bmih.biSize = sizeof(bmi.bmih);
        bmi.bmih.biWidth = (int)pSize->cx;
        bmi.bmih.biHeight = (int)pSize->cy;
        bmi.bmih.biPlanes = 1;
        bmi.bmih.biBitCount = 8;
        bmi.bmih.biCompression = BI_RGB;
        bmi.bmih.biSizeImage = 0;
        bmi.bmih.biXPelsPerMeter = 0;
        bmi.bmih.biYPelsPerMeter = 0;
        bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
        bmi.bmih.biClrImportant = 0;
        //
        // Use the halftone palette
        //
        pBuf->hPal = DllExports::GdipCreateHalftonePalette();
        pBuf->hPalOld = SelectPalette(pBuf->hdc, pBuf->hPal, FALSE);
        
        BYTE aj[sizeof(PALETTEENTRY) * 256];
        LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
        RGBQUAD *prgb = (RGBQUAD *) &bmi.rgbquad8;
        
        if (GetPaletteEntries(pBuf->hPal, 0, 256, lppe))
        {
            UINT i;

            for (i = 0; i < 256; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }
        }
        hbm = CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdcWnd,pSize->cx, pSize->cy);
    }
    return hbm;
}

HRESULT CDrawTask::InternalResumeRT()
{
    HRESULT hr = E_FAIL;

    HDC hdcScreen = GetDC(NULL);
    if (!_pBuf->hdc)
    {
        _pBuf->hdc = CreateCompatibleDC(hdcScreen);
    }
    if (_pBuf->hdc)
    {
        SIZE sz = {RECTWIDTH(_pBuf->rc), RECTHEIGHT(_pBuf->rc)};

        // If we were suspended and resumed, we will already have
        // a GDI bitmap from last time so don't make another one.
        if (!_pBuf->hbm)
        {
            BITMAP bm = {0};
            _pBuf->hbm = _CreateBitmap(hdcScreen, _pBuf, &sz);
            _pBuf->hbmOld = (HBITMAP)SelectObject(_pBuf->hdc, _pBuf->hbm);            
        }

        if (_pBuf->hbm)
        {
            RECT rc = {0,0,sz.cx, sz.cy};
            
            SetBkColor(_pBuf->hdc, _clrBkgnd);
            ExtTextOut(_pBuf->hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);           
            IShellImageData * pSID;
            if (SUCCEEDED(_pImgData->Lock(&pSID)))
            {
                pSID->SelectPage(_dwPage);
                IShellImageDataAbort *pAbortPrev = NULL;
                pSID->RegisterAbort(this, &pAbortPrev);
                hr = pSID->Draw(_pBuf->hdc, &rc, &_rcSrc);              
                pSID->RegisterAbort(pAbortPrev, NULL);
                _pImgData->Unlock();
            }
        }
    }
    if (hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    if (QueryAbort() == S_FALSE)
    {
        // We were cancelled or suspended, so don't notify our parent
        // because we have nothing to show for our efforts.
        hr = (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
    }
    else
    {
        // Ran to completion - clean up and notify main thread
        UINT iIndex = _pImgData->_iItem;
        ATOMICRELEASE(_pImgData);
        if (FAILED(hr))
        {
            DeleteBuffer(_pBuf);
            _pBuf = NULL;
        }
        if (PostMessage(_hwndNotify, _uMsgNotify, (WPARAM)_pBuf, (LPARAM)IntToPtr(iIndex)))
        {
            _pBuf = NULL;
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CDrawTask::QueryAbort()
{
    // BUGBUG not rady for prime tome - need to return E_PENDING
    // if state is SUSPENDED
    if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
    {
        return S_FALSE; // Abort
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\shimgvw.cpp ===
// shimgvw.cpp : Implementation of DLL Exports.

#include "precomp.h"
#include "resource.h"
#include "cfdefs.h"
#include "advpub.h"

#include "initguid.h"
#include "shimgvw.h"
#include "guids.h"
#include "shutil.h"
#include <gdiplusImaging.h>

#define  DECLARE_DEBUG
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "Shell Image View"
#define  SZ_MODULE          "SHIMGVW"
#include <debug.h>

#define DECL_CRTFREE
#include <crtfree.h>

#include "prevCtrl.h"           // for CPreview

#define IIDSTR_IExtractImage        "{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}"
#define REGSTR_APPROVED             "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"

LPCSTR const c_rgszDocFileExts[] =
{
    ".doc",
    ".dot",
    ".xls",
    ".xlt",
    ".obd",
    ".obt",
    ".ppt",
    ".pot",
    ".mic",
    ".mix",
    ".fpx",
    ".mpp"
};

LPCSTR const c_rgszHtmlExts[] =
{
    ".html",
    ".htm",
    ".url",
    ".mhtml",
    ".mht",
    ".xml",
    ".nws",
    ".eml"
};

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Preview, CPreview)
    OBJECT_ENTRY(CLSID_GdiThumbnailExtractor, CGdiPlusThumb)
    OBJECT_ENTRY(CLSID_DocfileThumbnailHandler, CDocFileThumb)
    OBJECT_ENTRY(CLSID_HtmlThumbnailExtractor, CHtmlThumb)
END_OBJECT_MAP()

CF_TABLE_BEGIN(g_ObjectInfo)
    CF_TABLE_ENTRY(&CLSID_ShellImageDataFactory, CImageDataFactory_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_PhotoVerbs, CPhotoVerbs_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_AutoplayForSlideShow, CAutoplayForSlideShow_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_ImagePropertyHandler, CImageData_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_ImageRecompress, CImgRecompress_CreateInstance, COCREATEONLY),
CF_TABLE_END(g_ObjectInfo)


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hInstance);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//  some types can only wallpaper on win32
#ifdef _WIN64
#define IMAGEOPTION_CANWALLPAPER_WIN32  0
#else
#define IMAGEOPTION_CANWALLPAPER_WIN32  IMAGEOPTION_CANWALLPAPER
#endif

#define IMGOPT_ALL      (IMAGEOPTION_CANWALLPAPER | IMAGEOPTION_CANROTATE)
#define IMGOPT_ALLW32   (IMAGEOPTION_CANWALLPAPER_WIN32 | IMAGEOPTION_CANROTATE)
#define IMGOPT_NONE     0
/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

typedef struct { LPTSTR szExt; LPTSTR pszContentType; LPTSTR szProgId; LPTSTR szProgram; DWORD dwOpts;} FILETYPEINFO;
//  { ".EXT",       "progid",                   old program,            IMGOPT
FILETYPEINFO g_rgExtentions[] = {
    { TEXT(".bmp"), TEXT("image/bmp"),      TEXT("Paint.Picture"),      TEXT("mspaint.exe"),    IMGOPT_ALL,     },
    { TEXT(".dib"), TEXT("image/bmp"),      TEXT("Paint.Picture"),      TEXT("mspaint.exe"),    IMGOPT_ALL,     },
    { TEXT(".emf"), NULL,                   TEXT("emffile"),            TEXT(""),               IMGOPT_NONE,    },
    { TEXT(".gif"), TEXT("image/gif"),      TEXT("giffile"),            TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jfif"),TEXT("image/jpeg"),     TEXT("pjpegfile"),          TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpg"), TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpe"), TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpeg"),TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".png"), TEXT("image/png"),      TEXT("pngfile"),            TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".tif"), TEXT("image/tiff"),     TEXT("TIFImage.Document"),  TEXT("KodakPrv.exe"),   IMGOPT_NONE,    },
    { TEXT(".tiff"),TEXT("image/tiff"),     TEXT("TIFImage.Document"),  TEXT("KodakPrv.exe"),   IMGOPT_NONE,    },
    { TEXT(".wmf"), NULL,                   TEXT("wmffile"),            TEXT(""),               IMGOPT_NONE,    },
};

const TCHAR c_szBitmapIcon[] =  TEXT("shimgvw.dll,1");
const TCHAR c_szDefaultIcon[] = TEXT("shimgvw.dll,2");
const TCHAR c_szJPegIcon[] =    TEXT("shimgvw.dll,3");
const TCHAR c_szTifIcon[] =     TEXT("shimgvw.dll,4");

// we might have to create a missing Prog ID so we need to know its default info.
typedef struct { LPCTSTR szProgID; int iResId; LPCTSTR szIcon; BOOL fDone; } PROGIDINFO;
//  { "ProgID"                  "Description"   "DefaultIcon"       done?   }
PROGIDINFO g_rgProgIDs[] = {
    { TEXT("emffile"),          IDS_EMFIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("giffile"),          IDS_GIFIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("jpegfile"),         IDS_JPEGIMAGE,   c_szJPegIcon,      FALSE   },
    { TEXT("Paint.Picture"),    IDS_BITMAPIMAGE, c_szBitmapIcon,    FALSE   },
    { TEXT("pjpegfile"),        IDS_JPEGIMAGE,   c_szJPegIcon,      FALSE   },
    { TEXT("pngfile"),          IDS_PNGIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("TIFImage.Document"),IDS_TIFIMAGE,    c_szTifIcon,       FALSE   },
    { TEXT("wmffile"),          IDS_WMFIMAGE,    c_szDefaultIcon,   FALSE   },
};

BOOL _ShouldSlamVerb(HKEY hkProgid, BOOL fForce, PCWSTR pszKey, PCWSTR pszApp, PCWSTR pszModule)
{
    if (!fForce)
    {
        TCHAR szOld[MAX_PATH*2];
        DWORD cbOld = sizeof(szOld);
        if (ERROR_SUCCESS == SHGetValue(hkProgid, pszKey, NULL, NULL, szOld, &cbOld) && *szOld)
        {
            // if we know about this app, then blow it away
            if ((*pszApp && StrStrI(szOld, pszApp))
            || StrStrI(szOld, pszModule)
            || StrStrI(szOld, TEXT("wangimg.exe"))) // NT4 app
            {
                fForce = TRUE;
            }
        }
        else
        {
            fForce = TRUE;
        }
    }

    return fForce;
}

BOOL _ExtIsProgid(PCTSTR pszExt, PCTSTR pszProgid, DWORD dwOpts)
{
    //  default to take-over
    BOOL fRet = TRUE;
    TCHAR sz[MAX_PATH];
    //  make sure this is in the openwith list
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("%s\\OpenWithProgids"), pszExt);
    SHSetValue(HKEY_CLASSES_ROOT, sz, pszProgid, REG_NONE, NULL, NULL);
    // make sure the flags are set for our verbs to show up
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SystemFileAssociations\\%s"), pszExt);
    SHSetValue(HKEY_CLASSES_ROOT, sz, TEXT("ImageOptionFlags"), REG_DWORD, &dwOpts, sizeof(dwOpts));

    SHSetValue(HKEY_CLASSES_ROOT, pszExt, TEXT("PerceivedType"), REG_SZ, TEXT("image"), sizeof(TEXT("image")));
    
    DWORD cb = sizeof(sz);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, sz, &cb))
    {
        //  empty or match is good
        fRet = (!*sz || 0 == StrCmpI(sz, pszProgid));
    }

    // always remove bogus Trident IExtractImage entries
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("%s\\shellex\\{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}"), pszExt);
    SHDeleteKey(HKEY_CLASSES_ROOT, sz);
    PathRemoveFileSpec(sz);
    SHDeleteEmptyKey(HKEY_CLASSES_ROOT, sz);
    
    return fRet;
}

PROGIDINFO *_ShouldSetupProgid(FILETYPEINFO *pfti, BOOL fForce)
{
    PROGIDINFO *ppi = NULL;
    if (_ExtIsProgid(pfti->szExt, pfti->szProgId, pfti->dwOpts) || fForce)
    {
        //  take it over
        SHSetValue(HKEY_CLASSES_ROOT, pfti->szExt, NULL, REG_SZ, pfti->szProgId, CbFromCch(lstrlen(pfti->szProgId)+1));
        if (pfti->pszContentType)
        {
            SHSetValue(HKEY_CLASSES_ROOT, pfti->szExt, TEXT("Content Type"), REG_SZ, pfti->pszContentType, CbFromCch(lstrlen(pfti->pszContentType)+1));
        }
        
        // we now know that szProgID is the ProgID for this extention.
        // look up the index into the ProgID table to see if we did this one already.
        int iProgIdIndex;
        for (iProgIdIndex=0; iProgIdIndex<ARRAYSIZE(g_rgProgIDs); iProgIdIndex++)
        {
            if (0 == StrCmpI(g_rgProgIDs[iProgIdIndex].szProgID, pfti->szProgId))
            {
                if (!g_rgProgIDs[iProgIdIndex].fDone)
                    ppi = &g_rgProgIDs[iProgIdIndex];
                break;
            }
        }
    }
    return ppi;
}


void RegisterFileType(FILETYPEINFO *pfti, BOOL fForce)
{
    PROGIDINFO *ppi = _ShouldSetupProgid(pfti, fForce);
    if (ppi)
    {
        // this ProgID is in our table 
        HKEY hkeyProgId;
        LRESULT lres = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                pfti->szProgId,
                                0, NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ|KEY_WRITE, NULL,
                                &hkeyProgId, NULL);

        if (ERROR_SUCCESS == lres)
        {
            LPCTSTR pszIcon = ppi->szIcon;
            TCHAR szModPath[MAX_PATH];
            GetModuleFileName(_Module.GetModuleInstance(), szModPath, ARRAYSIZE(szModPath));
            PCWSTR pszModule = PathFindFileName(szModPath);
            TCHAR szCmd[MAX_PATH * 2];
            // should we slam the default value?
            //  to progid = "EXT file"
            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\open\\command", pfti->szProgram, pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\open"));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("rundll32.exe %s,ImageView_Fullscreen %%1"), szModPath);
                SHRegSetPath(hkeyProgId, TEXT("shell\\open\\command"), NULL, szCmd, 0);
                SHStringFromGUID(CLSID_PhotoVerbs, szCmd, ARRAYSIZE(szCmd));
                SHSetValue(hkeyProgId, TEXT("shell\\open\\DropTarget"), TEXT("Clsid"), REG_SZ, szCmd, CbFromCch(lstrlen(szCmd)+1));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("@%s,%d"), pszModule, -IDS_PREVIEW_CTX);
                SHSetValue(hkeyProgId, TEXT("shell\\open"), TEXT("MuiVerb"), REG_SZ, szCmd, CbFromCch(lstrlen(szCmd)+1));
                SHRegSetPath(hkeyProgId, TEXT("DefaultIcon"), NULL, pszIcon, 0);
            }

            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\printto\\command", TEXT("mspaint.exe"), pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\printto"));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("rundll32.exe %s,ImageView_PrintTo /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\""), szModPath);
                SHRegSetPath(hkeyProgId, TEXT("shell\\printto\\command"), NULL, szCmd, 0);
            }

            //  this will delete print verb
            //  print is added in selfreg under HKCR\SystemFileAssociations\image\Print
            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\print\\command", TEXT("mspaint.exe"), pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\print"));
            }

            // Modify the EditFlags: it's okay to run these without prompting...
            DWORD dwEditFlags = 0;
            DWORD cbEditFlags = sizeof(dwEditFlags);
            SHGetValue(hkeyProgId, NULL, TEXT("EditFlags"), NULL, &dwEditFlags, &cbEditFlags);
            dwEditFlags |= 0x00010000; // turn on the "okay to run without prompt" flag
            SHSetValue(hkeyProgId, NULL, TEXT("EditFlags"), REG_DWORD, &dwEditFlags, sizeof(dwEditFlags));
            
            RegCloseKey(hkeyProgId);
        }
        ppi->fDone = TRUE;
    }
}

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(_Module.GetModuleInstance(), szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

void _FixupProgid(PCSTR pszExt, PCSTR pszProgid)
{
    HKEY hk;
    DWORD dwRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hk);
    if (dwRet == ERROR_SUCCESS)
    {
        //  if its empty, then we need to fix it up.
        CHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValueA(hk, NULL, NULL, NULL, sz, &cb) && !*sz)
        {
            SHSetValueA(hk, NULL, NULL, REG_SZ, pszProgid, CbFromCchA(lstrlenA(pszProgid)+1));
        }
    }
}

HRESULT RegisterHandler(const LPCSTR *ppszExts, UINT cExts, LPCSTR pszIID, LPCSTR pszCLSID)
{
    for (UINT cKey = 0; cKey < cExts; cKey ++)
    {
        CHAR szKey[MAX_PATH];
        wnsprintfA(szKey, ARRAYSIZE(szKey), "SystemFileAssociations\\%s\\shellex\\%s", *ppszExts, pszIID);
        SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
        SHSetValueA(HKEY_CLASSES_ROOT, szKey, NULL, REG_SZ, pszCLSID, CbFromCch(lstrlenA(pszCLSID)+1));
        ppszExts++;
    }
    return S_OK;
}

HRESULT UnregisterHandler(const LPCSTR *ppszExts, UINT cExts, LPCSTR pszIID, LPCSTR pszCLSID)
{
    for (UINT cKey = 0; cKey < cExts; cKey ++)
    {
        CHAR szKey[MAX_PATH];
        CHAR szCLSID[256];
        DWORD dwSize = sizeof(szCLSID);
        wnsprintfA(szKey, ARRAYSIZE(szKey), "SystemFileAssociations\\%s\\shellex\\%s", *ppszExts, pszIID);
        if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, szKey, NULL, NULL, &szCLSID, &dwSize))
        {
            if (!StrCmpIA(szCLSID, pszCLSID))
            {
                SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
            }
        }
        dwSize = sizeof(szCLSID);
        wnsprintfA(szKey, ARRAYSIZE(szKey), "%s\\shellex\\%s", *ppszExts, pszIID);
        if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, szKey, NULL, NULL, &szCLSID, &dwSize))
        {
            if (!StrCmpIA(szCLSID, pszCLSID))
            {
                SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
            }
        }
        ppszExts++;
    }
    return S_OK;
}

STDAPI DllRegisterServer(void)
{
    // REVIEW: should this be done only in DLLInstall?
    for (int i=0; i<ARRAYSIZE(g_rgExtentions); i++)
    {
        RegisterFileType(g_rgExtentions+i, FALSE);
    }

    RegisterHandler(c_rgszDocFileExts, ARRAYSIZE(c_rgszDocFileExts), IIDSTR_IExtractImage, CLSIDSTR_DocfileThumbnailHandler);
    UnregisterHandler(c_rgszHtmlExts, ARRAYSIZE(c_rgszHtmlExts), IIDSTR_IExtractImage, CLSIDSTR_HtmlThumbnailExtractor);

    _CallRegInstall("RegDll", TRUE);

    //  powerpoint gets freaked by empty extension keys.
    _FixupProgid(".ppt", "Powerpoint.Show.7");
    _FixupProgid(".pot", "Powerpoint.Template");

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    UnregisterHandler(c_rgszDocFileExts, ARRAYSIZE(c_rgszDocFileExts), IIDSTR_IExtractImage, CLSIDSTR_DocfileThumbnailHandler);
    UnregisterHandler(c_rgszHtmlExts, ARRAYSIZE(c_rgszHtmlExts), IIDSTR_IExtractImage, CLSIDSTR_HtmlThumbnailExtractor);

    _CallRegInstall("UnRegDll", TRUE);

    return S_OK;
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    if (bInstall)
    {
        BOOL fForce = StrStrIW(pszCmdLine, L"/FORCE") != 0;
        for (int i=0; i<ARRAYSIZE(g_rgExtentions); i++)
        {
            RegisterFileType(g_rgExtentions+i, fForce);
        }
    }
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}

// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        _Module.Lock();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    _Module.Lock();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    _Module.Unlock();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        _Module.Lock();
    else
        _Module.Unlock();

    return S_OK;
}


// Object constructor 

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // handle non-ATL objects first
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                _Module.Lock();
                return S_OK;
            }
        }
    }

    // Try the ATL way....
    return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\shutil.cpp ===
#include "precomp.h"
#include "shutil.h"


HRESULT GetFileInfoByHandle(LPCTSTR pszFile, BY_HANDLE_FILE_INFORMATION *pInfo)
{
    HRESULT hr;
    HANDLE hFile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (GetFileInformationByHandle(hFile, pInfo))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

// S_OK -> YES, S_FALSE -> NO, FAILED(hr) otherwise

STDAPI IsSameFile(LPCTSTR pszFile1, LPCTSTR pszFile2)
{
    HRESULT hr;
    // use CRT str cmp semantics as localized strcmp should not be used for the file system
    if (0 == StrCmpIC(pszFile1, pszFile2))
    {
        hr = S_OK;  // test the names
    }
    else
    {
        // very clever here... we can test for alias names that map to the same
        // file. for example the short name vs long name of the same file
        // the UNC name vs drive letter version of the name
        BY_HANDLE_FILE_INFORMATION hfi1;
        hr = GetFileInfoByHandle(pszFile1, &hfi1);
        if (SUCCEEDED(hr))
        {
            BY_HANDLE_FILE_INFORMATION hfi2;
            hr = GetFileInfoByHandle(pszFile2, &hfi2);
            if (SUCCEEDED(hr))
            {
                if (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber && 
                    hfi1.nFileIndexHigh == hfi2.nFileIndexHigh && 
                    hfi1.nFileIndexLow == hfi2.nFileIndexLow)
                {
                    hr = S_OK;  // same!
                }
                else
                {
                    hr = S_FALSE;   // different
                }
            }
        }
    }
    return hr;
}

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);    // speed up PathMatchSpec calls
        
    // look at the list of decoders to see if this format is there
    for (UINT i = 0; i < cDecoders; i++)
    {
        if (PathMatchSpec(pszExt, pici[i].FilenameExtension))
            return i;
    }
    return (UINT)-1;    // not found!
}


HRESULT GetUIObjectFromPath(LPCTSTR pszFile, REFIID riid, void **ppv)
{
    *ppv = NULL;
    LPITEMIDLIST pidl;
    HRESULT hr = SHILCreateFromPath(pszFile, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
        ILFree(pidl);
    }
    return hr;
}

BOOL FmtSupportsMultiPage(IShellImageData *pData, GUID *pguidFmt)
{
    BOOL bRet = FALSE;

    EncoderParameters *pencParams;
    if (SUCCEEDED(pData->GetEncoderParams(pguidFmt, &pencParams)))
    {
        for (UINT i=0;!bRet && i<pencParams->Count;i++)
        {
            if (EncoderSaveFlag == pencParams->Parameter[i].Guid)
            {
                if (EncoderValueMultiFrame == *((ULONG*)pencParams->Parameter[i].Value))
                {
                    bRet = TRUE;
                }
            }
        }
        CoTaskMemFree(pencParams);
    }
    return bRet;
}

HRESULT SetWallpaperHelper(LPCWSTR pszPath)
{
    IActiveDesktop* pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        IShellImageDataFactory* pidf;
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellImageDataFactory, &pidf));
        if (SUCCEEDED(hr))
        {
            IShellImageData* pid;
            hr = pidf->CreateImageFromFile(pszPath, &pid);
            if (SUCCEEDED(hr))
            {
                hr = pid->Decode(SHIMGDEC_DEFAULT, 0,0);
                if (SUCCEEDED(hr))
                {
                    // we are basing this on a best fit to the primary screen
                    ULONG cxScreen = GetSystemMetrics(SM_CXSCREEN);
                    ULONG cyScreen = GetSystemMetrics(SM_CYSCREEN);

                    SIZE szImg;
                    pid->GetSize(&szImg);

                    hr = pad->SetWallpaper(pszPath, 0);
                    if (SUCCEEDED(hr))
                    {
                        WALLPAPEROPT wpo;
                        wpo.dwSize = sizeof(wpo);
                        wpo.dwStyle = WPSTYLE_CENTER;

                        // if the image is small on either axis then tile
                        if (((ULONG)szImg.cx*2 < cxScreen) || ((ULONG)szImg.cy*2 < cyScreen))
                        {
                            wpo.dwStyle = WPSTYLE_TILE;
                        }
                        // if the image is larger than the screen then stretch
                        else if ((ULONG)szImg.cx > cxScreen && (ULONG)szImg.cy > cyScreen)
                        {
                            wpo.dwStyle = WPSTYLE_STRETCH;
                        }
                        else
                        {
                            // If the aspect ratio matches the screen then stretch.
                            // I'm checking is the aspect ratios are *close* to matching.
                            // Here's the logic behind this:
                            //
                            // a / b == c / d
                            // a * d == c * b
                            // (a * d) / (c * b) == 1
                            // 0.75 <= (a * d) / (c * b) < 1.25     <-- our *close* factor
                            // 3 <= 4 * (a * d) / (c * b) < 5
                            //
                            // We do an integer division which will floor the result meaning
                            // that if the result is 3 or 4 we are inside the rang we want.

                            DWORD dwRes = (4 * (ULONG)szImg.cx * cyScreen) / (cxScreen * (ULONG)szImg.cy);
                            if (dwRes == 4 || dwRes == 3)
                                wpo.dwStyle = WPSTYLE_STRETCH;
                        }
                
                        hr = pad->SetWallpaperOptions(&wpo, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pad->ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
                        }
                    }
                }
                pid->Release();
            }
            pidf->Release();
        }
        pad->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\seltrack.h ===
#ifndef _SELTRACK_H_
#define _SELTRACK_H_

// This file defines the class used to handle the selection rectangle
// complete with resize handles

BOOL InitSelectionTracking();
void CleanupSelectionTracking();

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker - simple rectangular tracking rectangle w/resize handles

class CSelectionTracker
{
public:
// Constructor / Destructor
	CSelectionTracker();
	virtual ~CSelectionTracker();

	BOOL Init(); // You must call Init after construction

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
		lineSelection = 64
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_uStyle;      // current state
	CRect m_rect;        // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(HDC hdc) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(HWND hwnd,  LPARAM lParam) const;
	BOOL Track(HWND hwnd, CPoint point, BOOL bAllowInvert = FALSE,
		HWND hwndClipTo = NULL);
	BOOL TrackRubberBand(HWND hwnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

private:

	BOOL _bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect _rectLast;
	CSize _sizeLast;
	CSize _sizeMin;
	BOOL _bErase;          // TRUE if _DrawTrackerRect is called for erasing
	BOOL _bFinalErase;     // TRUE if _DragTrackerRect called for final erase

	// implementation helpers
	void _DrawTrackerRect(LPCRECT lpRect, HWND hwndClipTo, HDC hdc, HWND hwnd);
	void _AdjustRect(int nHandle, LPRECT lpRect);
	void _OnChangedRect(const CRect& rectOld);
	UINT _GetHandleMask() const;
	int _HitTestHandles(CPoint point) const;
	void _GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void _GetModifyPointers(int nHandle, int** ppx, int** ppy, int* px, int*py);
	int _GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL _TrackHandle(int nHandle, HWND hwnd, CPoint point, HWND hwndClipTo);
	void _DrawDragRect(HDC hdc, LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME=shimgvw
TARGETPATH=obj
TARGETTYPE=DYNLINK

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h

DLLENTRY=DllMain
DLLDEF=..\shimgvw.def

SELFREGNAME= $(O)\shimgvw_selfreg.inf
MISCFILES= $(MISCFILES) $(O)\shimgvw_selfreg.inf

NTTARGETFILE0   = $(SELFREGNAME)

EXPECTED_WINVER=4.0
NOT_LEAN_AND_MEAN=1
USE_MSVCRT=0

USE_STATIC_ATL=1

MSC_WARNING_LEVEL=/WX /W3

GDIPLUS_LIB_PATH=$(SDK_LIB_PATH)

C_DEFINES =$(C_DEFINES) -DDCR_USE_NEW_105760 -DDCR_USE_NEW_127084 -DDCR_USE_NEW_135429 -DDCR_USE_NEW_140782 -DDCR_USE_NEW_140855 -DDCR_USE_NEW_140857 -DDCR_USE_NEW_140861 -DDCR_USE_NEW_145135 -DDCR_USE_NEW_145138 -DDCR_USE_NEW_145139 -DDCR_USE_NEW_145804 -DDCR_USE_NEW_146933 -DDCR_USE_NEW_152154

INCLUDES = \
    ..; \
    $(SDK_INC_PATH)\atl21; \
    $(CCSHELL_DIR)\inc; \
    $(CCSHELL_DIR)\lib\$(O); \
    $(CCSHELL_DIR)\shell32; \
    $(SDK_INC_PATH)\gdiplus; \
    $(PRINTSCAN_INC_PATH);\
    $(O)

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)

SOURCES= \
    ..\Atl.cpp         \
    ..\autoplay.cpp    \
    ..\docfile.cpp     \
    ..\Events.cpp      \
    ..\extmsg.mc       \
    ..\gdithumb.cpp    \
    ..\html.cpp        \
    ..\imgdata.cpp     \
    ..\photoverb.cpp   \
    ..\PrevCtrl.cpp    \
    ..\PrevWnd.cpp     \
    ..\recompress.cpp  \
    ..\shimgvw.cpp     \
    ..\shimgvw.rc      \
    ..\shutil.cpp      \
    ..\tasks.cpp       \
    ..\thumbutil.cpp   \
    ..\ZoomWnd.cpp     \
    ..\SelTrack.cpp    \
    ..\imgprop.cpp

DELAYLOAD = urlmon.dll
DLOAD_ERROR_HANDLER = kernel32

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217


TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib        \
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\gdi32.lib           \
    $(SDK_LIB_PATH)\winspool.lib        \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SHELL_LIB_PATH)\shlwapip.lib      \
    $(SDK_LIB_PATH)\shell32.lib         \
    $(SDK_LIB_PATH)\htmlhelp.lib        \
    $(SDK_LIB_PATH)\ole32.lib           \
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(CCSHELL_DIR)\lib\$O\shguid.lib    \
    $(CCSHELL_DIR)\lib\$O\shguidp.lib   \
    $(CCSHELL_DIR)\lib\$O\ieguidp.lib   \
    $(SDK_LIB_PATH)\uuid.lib            \
    $(SHELL_LIB_PATH)\shfusion.lib      \
    $(SDK_LIB_PATH)\urlmon.lib          \
    $(SHELL_LIB_PATH)\shell32p.lib      \
    $(SHELL_LIB_PATH)\uxthemep.lib      \
    $(GDIPLUS_LIB_PATH)\gdiplus.lib     \
    $(CCSHELL_DIR)\lib\$O\stock4.lib    \
    $(PRINTSCAN_LIB_PATH)\annotlib.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\tasks.h ===
#pragma once

// forward declaration to make things easy
class CAnnotationSet;

typedef struct
{
    SIZE  szImage;
    ULONG xDPI;
    ULONG yDPI;
    DWORD dwDelay;
} PageInfo;

typedef struct
{
    DWORD   dwID;
    RECT    rc;
    HBITMAP hbm;
    HPALETTE hPal;
    HDC hdc;
    HPALETTE hPalOld;
    HBITMAP hbmOld;
} Buffer;

void DeleteBuffer(Buffer * pBuf);

class CDecodeTask : public CRunnableTask
{
public:
    static HRESULT Create(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd, IRunnableTask ** pTask);
    STDMETHOD(RunInitRT)();

    inline BOOL IsEditable()  { return (_fEditable); }
    inline BOOL IsMultipage() { return (!_fAnimated && (_cImages > 1)); }
    inline BOOL IsFirstPage() { return (0==_iCurrent); }
    inline BOOL IsLastPage()  { return (_iCurrent == _cImages-1); }
    inline BOOL IsAnimated()  { return (_fAnimated); }
    inline BOOL IsExtendedPixelFmt () { return _fExtendedPF; }

    LPCWSTR GetName() { return _pszFilename; }
    BOOL GetSize(SIZE * psz);
    BOOL GetResolution(ULONG * px, ULONG * py);
    DWORD GetDelay();
    BOOL PrevPage();
    BOOL NextPage();
    BOOL NextFrame();
    BOOL SelectPage(ULONG nPage);
    BOOL ChangePage(CAnnotationSet& pAnnotations);
    HRESULT Print(BOOL fShowUI, LPWSTR szPrinterName, HWND hwndOwner);
    HRESULT Rotate(DWORD dwAngle);
    
    HRESULT Lock(IShellImageData ** ppSID);
    HRESULT Unlock();
    BOOL DisplayName(LPTSTR psz, UINT cch);

    // general image data
    ULONG _cImages;
    ULONG _iCurrent;
    BOOL  _fAnimated;
    BOOL  _fEditable;
    GUID  _guidFormat;
    UINT  _iItem;
    BOOL  _fIsReadOnly;
    HRESULT _hr;

    // properties of page _iCurrent
    PageInfo * _ppi;

private:
    CDecodeTask();
    ~CDecodeTask();
    HRESULT _Initialize(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd);

    // initialization info
    IStream *_pstrm;
    LPWSTR _pszFilename;
    IShellImageDataFactory * _pfactory;
    HWND _hwndNotify;

    // protected data
    CRITICAL_SECTION _cs;
    IShellImageData *_pSID;
    SHFILEINFO       _sfi;
    BOOL             _fExtendedPF;
};

class CDrawTask : public CRunnableTask, public IShellImageDataAbort
{
public:
    // CRunnableTask
    static HRESULT Create(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg, IRunnableTask ** ppTask);
    STDMETHOD(RunInitRT)() { return S_OK; }
    STDMETHOD(InternalResumeRT)();

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CRunnableTask::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return CRunnableTask::Release(); }

    // *** IShellImageDataAbort ***
    STDMETHOD(QueryAbort)();

private:
    CDrawTask();
    ~CDrawTask();
    HRESULT _Initialize(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg);
    static BOOL _Abort(void *pvRef);

    CDecodeTask * _pImgData;
    DWORD _dwPage;
    COLORREF _clrBkgnd;
    RECT _rcSrc;
    Buffer * _pBuf;
    HWND _hwndNotify;
    ULONG _uMsgNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\thumbutil.cpp ===
#include "precomp.h"
#include "ocmm.h"
#include "thumbutil.h"

typedef UCHAR BGR3[3];

class CThumbnailMaker
{
public:
    CThumbnailMaker();
    ~CThumbnailMaker();

    void Scale(BGR3 *pDst, UINT uiDstWidth, int iDstStep, const BGR3 *pSrc, UINT uiSrcWidth, int iSrcStep);
    HRESULT Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight);
    HRESULT AddScanline(UCHAR *pucSrc, UINT uiY);
    HRESULT AddDIB(BITMAPINFO *pBMI);
    HRESULT AddDIBSECTION(BITMAPINFO *pBMI, void *pBits);
    HRESULT GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize);
    HRESULT GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize);

private:
    UINT _uiDstWidth, _uiDstHeight;
    UINT _uiSrcWidth, _uiSrcHeight;
    BGR3 *_pImH;
};

CThumbnailMaker::CThumbnailMaker()
{
    _pImH = NULL;
}

CThumbnailMaker::~CThumbnailMaker()
{
    if (_pImH)
        delete[] _pImH;
}

HRESULT CThumbnailMaker::Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight)
{
    _uiDstWidth = uiDstWidth;
    _uiDstHeight = uiDstHeight;
    _uiSrcWidth = uiSrcWidth;
    _uiSrcHeight = uiSrcHeight;

    if (_uiDstWidth < 1 || _uiDstHeight < 1 ||
        _uiSrcWidth < 1 || _uiSrcHeight < 1)
        return E_INVALIDARG;

    if (_pImH)
        delete[] _pImH;

    _pImH = new BGR3[_uiDstWidth * _uiSrcHeight];
    if (_pImH == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

void CThumbnailMaker::Scale(      BGR3 *pDst, UINT dxDst, int iDstBytStep, 
                            const BGR3 *pSrc, UINT dxSrc, int iSrcBytStep)
{
    int mnum = dxSrc;
    int mden = dxDst;

    // Scaling up, use a triangle filter.
    if (mden >= mnum)
    {
        int frac = 0;

        // Adjust the slope so that we calculate the fraction of the
        // "next" pixel to use (i.e. should be 0 for the first and
        // last dst pixel).
        --mnum;
        if (--mden == 0)
            mden = 0; // avoid div by 0

        BGR3 *pSrc1 = (BGR3 *)(((UCHAR *)pSrc) + iSrcBytStep);

        for (UINT x = 0; x < dxDst; x++)
        {
            if (frac == 0)
            {
                (*pDst)[0] = (*pSrc)[0];
                (*pDst)[1] = (*pSrc)[1];
                (*pDst)[2] = (*pSrc)[2];
            }
            else
            {
                (*pDst)[0] = ((mden - frac) * (*pSrc)[0] + frac * (*pSrc1)[0]) / mden;
                (*pDst)[1] = ((mden - frac) * (*pSrc)[1] + frac * (*pSrc1)[1]) / mden;
                (*pDst)[2] = ((mden - frac) * (*pSrc)[2] + frac * (*pSrc1)[2]) / mden;
            }

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);

            frac += mnum;
            if (frac >= mden)
            {
                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
                pSrc1 = (BGR3 *)((UCHAR *)pSrc1 + iSrcBytStep);
            }
        }
    }
    // Scaling down, use a box filter.
    else
    {
        int frac = 0;

        for (UINT x = 0; x < dxDst; x++)
        {
            UINT uiSum[3] = {0, 0, 0};
            UINT uiCnt = 0;

            frac += mnum;
            while (frac >= mden)
            {
                uiSum[0] += (*pSrc)[0];
                uiSum[1] += (*pSrc)[1];
                uiSum[2] += (*pSrc)[2];
                uiCnt++;

                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
            }

            (*pDst)[0] = uiSum[0] / uiCnt;
            (*pDst)[1] = uiSum[1] / uiCnt;
            (*pDst)[2] = uiSum[2] / uiCnt;

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);
        }
    }
}

//
// For AddScanline, we scale the input horizontally into our temporary
// image buffer.
//
HRESULT CThumbnailMaker::AddScanline(UCHAR *pSrc, UINT uiY)
{
    if (pSrc == NULL || uiY >= _uiSrcHeight)
        return E_INVALIDARG;

    Scale(_pImH + uiY * _uiDstWidth, _uiDstWidth, sizeof(BGR3), (BGR3 *)pSrc, _uiSrcWidth, sizeof(BGR3));

    return S_OK;
}

// For GetBITMAPINFO, we complete the scaling vertically and return the
// result as a DIB.
HRESULT CThumbnailMaker::GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
    *ppBMInfo = NULL;

    DWORD dwBPL = (((_uiDstWidth * 24) + 31) >> 3) & ~3;
    DWORD dwTotSize = sizeof(BITMAPINFOHEADER) + dwBPL * _uiDstHeight;

    BITMAPINFO *pBMI = (BITMAPINFO *)CoTaskMemAlloc(dwTotSize);
    if (pBMI == NULL)
        return E_OUTOFMEMORY;

    BITMAPINFOHEADER *pBMIH = &pBMI->bmiHeader;
    pBMIH->biSize = sizeof(*pBMIH);
    pBMIH->biWidth = _uiDstWidth;
    pBMIH->biHeight = _uiDstHeight;
    pBMIH->biPlanes = 1;
    pBMIH->biBitCount = 24;
    pBMIH->biCompression = BI_RGB;
    pBMIH->biXPelsPerMeter = 0;
    pBMIH->biYPelsPerMeter = 0;
    pBMIH->biSizeImage = dwBPL * _uiDstHeight;
    pBMIH->biClrUsed = 0;
    pBMIH->biClrImportant = 0;

    UCHAR *pDst = (UCHAR *)pBMIH + pBMIH->biSize + (_uiDstHeight - 1) * dwBPL;

    for (UINT x = 0; x < _uiDstWidth; x++)
    {
        Scale((BGR3 *)pDst + x, _uiDstHeight, -(int)dwBPL,
              _pImH + x, _uiSrcHeight, _uiDstWidth * sizeof(BGR3));
    }

    *ppBMInfo = pBMI;
    *pdwSize = dwTotSize;

    return S_OK;
}

HRESULT CThumbnailMaker::GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
#define SCALE 10000

    if (uiSharpPct > 100)
        return E_INVALIDARG;

    // Get the unsharpened bitmap.
    DWORD dwSize;
    HRESULT hr = GetBITMAPINFO(ppBMInfo, &dwSize);
    if (FAILED(hr))
        return hr;

    *pdwSize = dwSize;

    // Create a duplicate to serve as the original.
    BITMAPINFO *pBMISrc = (BITMAPINFO *)new UCHAR[dwSize];
    if (pBMISrc == NULL)
    {
        delete *ppBMInfo;
        return E_OUTOFMEMORY;
    }
    memcpy(pBMISrc, *ppBMInfo, dwSize);

    int bpl = (pBMISrc->bmiHeader.biWidth * 3 + 3) & ~3;

    //
    // Sharpen inside a 1 pixel border
    //
    UCHAR *pucDst = (UCHAR *)*ppBMInfo + sizeof(BITMAPINFOHEADER);
    UCHAR *pucSrc[3];
    pucSrc[0] = (UCHAR *)pBMISrc + sizeof(BITMAPINFOHEADER);
    pucSrc[1] = pucSrc[0] + bpl;
    pucSrc[2] = pucSrc[1] + bpl;

    int wdiag = (10355 * uiSharpPct) / 100;
    int wadj = (14645 * uiSharpPct) / 100;
    int wcent = 4 * (wdiag + wadj);

    for (int y = 1; y < pBMISrc->bmiHeader.biHeight-1; ++y)
    {
        for (int x = 3*(pBMISrc->bmiHeader.biWidth-2); x >= 3; --x)
        {
            int v = pucDst[x] +
                (pucSrc[1][x] * wcent -
                 ((pucSrc[0][x - 3] +
                   pucSrc[0][x + 3] +
                   pucSrc[2][x - 3] +
                   pucSrc[2][x + 3]) * wdiag +
                  (pucSrc[0][x] +
                   pucSrc[1][x - 3] +
                   pucSrc[1][x + 3] +
                   pucSrc[2][x]) * wadj)) / SCALE;

            pucDst[x] = v < 0 ? 0 : v > 255 ? 255 : v;
        }

        pucDst += bpl;
        pucSrc[0] = pucSrc[1];
        pucSrc[1] = pucSrc[2];
        pucSrc[2] += bpl;
    }

    delete[] pBMISrc;

    return S_OK;
#undef SCALE
}

HRESULT ThumbnailMaker_Create(CThumbnailMaker **ppThumbMaker)
{
    *ppThumbMaker  = new CThumbnailMaker;
    return *ppThumbMaker ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnailMaker::AddDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }

    UCHAR *pBits = (UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD);

    return AddDIBSECTION(pBMI, (void *) pBits);
}

HRESULT CThumbnailMaker::AddDIBSECTION(BITMAPINFO *pBMI, void *pBits)
{
    RGBQUAD *pRGBQ, *pQ;
    UCHAR *pucBits0, *pucBits, *pB, *pucBits240, *pucBits24, *pB24;
    int bpl;
    int x, y, ncolors;
    ULONG rmask, gmask, bmask;
    int rshift, gshift, bshift;
    HRESULT hr;

    //
    // Make sure that thumbnail maker has been properly initialized.
    //
    if (pBMI == NULL)
        return E_INVALIDARG;

    if (pBMI->bmiHeader.biWidth != (LONG)_uiSrcWidth ||
        pBMI->bmiHeader.biHeight != (LONG)_uiSrcHeight)
        return E_INVALIDARG;

    //
    // Don't handle RLE.
    //
    if (pBMI->bmiHeader.biCompression != BI_RGB &&
        pBMI->bmiHeader.biCompression != BI_BITFIELDS)
        return E_INVALIDARG;

    pRGBQ = (RGBQUAD *)&pBMI->bmiColors[0];

    ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;

    //
    // Decode 16/32bpp with masks.
    //
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            rmask = ((ULONG *)pRGBQ)[0];
            gmask = ((ULONG *)pRGBQ)[1];
            bmask = ((ULONG *)pRGBQ)[2];
            ncolors = 3;
        }
        else if (pBMI->bmiHeader.biBitCount == 16)
        {
            rmask = 0x7c00;
            gmask = 0x03e0;
            bmask = 0x001f;
        }
        else /* 32 */
        {
            rmask = 0xff0000;
            gmask = 0x00ff00;
            bmask = 0x0000ff;
        }

        for (rshift = 0; (rmask & 1) == 0; rmask >>= 1, ++rshift);
        if (rmask == 0)
            rmask = 1;
        for (gshift = 0; (gmask & 1) == 0; gmask >>= 1, ++gshift);
        if (gmask == 0)
            gmask = 1;
        for (bshift = 0; (bmask & 1) == 0; bmask >>= 1, ++bshift);
        if (bmask == 0)
            bmask = 1;
    }

    bpl = ((pBMI->bmiHeader.biBitCount * _uiSrcWidth + 31) >> 3) & ~3;

    pucBits0 = (UCHAR *) pBits;
    pucBits = pucBits0;

    if (pBMI->bmiHeader.biBitCount == 24)
        pucBits240 = pucBits;
    else
    {
        int bpl24 = (_uiSrcWidth * 3 + 3) & ~3;

        pucBits240 = new UCHAR[bpl24];
        if (pucBits240 == NULL)
            return E_OUTOFMEMORY;
    }
    pucBits24 = pucBits240;

    hr = S_OK;

    for (y = 0; y < (int)_uiSrcHeight; ++y)
    {
        pB = pucBits;
        pB24 = pucBits24;

        switch (pBMI->bmiHeader.biBitCount)
        {
        case 1:
            for (x = _uiSrcWidth; x >= 8; x -= 8)
            {
                pQ = &pRGBQ[(*pB >> 7) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 6) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 5) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 4) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 3) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 2) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 1) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB++) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                int shf = 8;

                do
                {
                    pQ = &pRGBQ[(*pB >> --shf) & 1];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
                while (--x);
            }

            break;

        case 4:
            for (x = _uiSrcWidth; x >= 2; x -= 2)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[*pB++ & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                if (x > 1)
                {
                    pQ = &pRGBQ[*pB & 0xf];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
            }

            break;

        case 8:
            for (x = _uiSrcWidth; x--;)
            {
                pQ = &pRGBQ[*pB++];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            break;

        case 16:
        {
            USHORT *pW = (USHORT *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG w = *pW++;

                *pB24++ = (UCHAR)
                     ((((w >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((w >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((w >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        case 24:
            pucBits24 = pucBits;
            break;

        case 32:
        {
            ULONG *pD;

            pD = (ULONG *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG d = *pD++;

                *pB24++ = (UCHAR)
                     ((((d >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((d >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((d >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        default:
            delete[] pucBits24;
            return E_INVALIDARG;
        }

        hr = AddScanline(pucBits24, (_uiSrcHeight-1) - y);
        if (FAILED(hr))
            break;

        pucBits += bpl;
    }

    if (pucBits240 != pucBits0)
        delete[] pucBits240;

    return hr;
}

UINT CalcImageSize(const SIZE *prgSize, DWORD dwClrDepth)
{
    UINT uSize = prgSize->cx * dwClrDepth;
    
    uSize *= (prgSize->cy < 0) ? (- prgSize->cy) : prgSize->cy;
    // divide by 8
    UINT uRetVal = uSize >> 3;

    if (uSize & 7)
    {
        uRetVal++;
    }

    return uRetVal;
}

// exported as helper for thumbnail implementations (used to come from thumbvw.dll)
//
// this code also currently lives in shell32. that should be converted to
// import these APIs (or expose via COM object)

STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwRecClrDepth, HPALETTE hpal, 
                                           UINT uiSharpPct, BOOL fOrigSize)
{
    BITMAPINFO *pbiScaled = pbi, *pbiUsed = pbi;
    BITMAPINFOHEADER *pbih = (BITMAPINFOHEADER *)pbi;
    BOOL bRetVal = FALSE, bInverted = FALSE;
    RECT rect;
    HRESULT hr;
    void *pScaledBits = pBits;

    // the scaling code doesn't handle inverted bitmaps, so we treat
    // them as if they were normal, by inverting the height here and
    // then setting it back before doing a paint.
    if (pbi->bmiHeader.biHeight < 0)
    {
        pbi->bmiHeader.biHeight *= -1;
        bInverted = TRUE;
    }

    rect.left = 0;
    rect.top = 0;
    rect.right = pbih->biWidth;
    rect.bottom = pbih->biHeight;
    
    CalculateAspectRatio(prgSize, &rect);

    // only bother with the scaling and sharpening if we are messing with the size...
    if ((rect.right - rect.left != pbih->biWidth) || (rect.bottom - rect.top != pbih->biHeight))
    {
        CThumbnailMaker *pThumbMaker;
        hr = ThumbnailMaker_Create(&pThumbMaker);
        if (SUCCEEDED(hr))
        {
            // initialize thumbnail maker. 
            hr = pThumbMaker->Init(rect.right - rect.left, rect.bottom - rect.top, 
                                    pbi->bmiHeader.biWidth, abs(pbi->bmiHeader.biHeight));
            if (SUCCEEDED(hr))
            {
                // scale image.
                hr = pThumbMaker->AddDIBSECTION(pbiUsed, pBits);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSize;
                    hr = pThumbMaker->GetSharpenedBITMAPINFO(uiSharpPct, &pbiScaled, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        pScaledBits = (LPBYTE)pbiScaled + sizeof(BITMAPINFOHEADER);
                    }
                }
            }
            delete pThumbMaker;
        }

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    // set the height back to negative if that's the way it was before.
    if (bInverted == TRUE)
        pbiScaled->bmiHeader.biHeight *= -1;

    // now if they have asked for origsize rather than the boxed one, and the colour depth is OK, then 
    // return it...
    if (fOrigSize && pbiScaled->bmiHeader.biBitCount <= dwRecClrDepth)
    {
        SIZE rgCreateSize = { pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight };
        void *pNewBits;
        
        // turn the PbiScaled DIB into a HBITMAP...., note we pass the old biInfo so that it can get the palette form
        // it if need be.
        bRetVal = CreateSizedDIBSECTION(&rgCreateSize, pbiScaled->bmiHeader.biBitCount, NULL, pbiScaled, phBmpThumbnail, NULL, &pNewBits);

        if (bRetVal)
        {
            // copy the image data accross...
            CopyMemory(pNewBits, pScaledBits, CalcImageSize(&rgCreateSize, pbiScaled->bmiHeader.biBitCount)); 
        }
        
        return bRetVal;
    }
    
    bRetVal = FactorAspectRatio(pbiScaled, pScaledBits, prgSize, rect,
                                 dwRecClrDepth, hpal, fOrigSize, GetSysColor(COLOR_WINDOW), phBmpThumbnail);

    if (pbiScaled != pbi)
    {
        // free the allocated image...
        CoTaskMemFree(pbiScaled);
    }

    return bRetVal;
}

// This function makes no assumption about whether the thumbnail is square, so 
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
//
// WINDOWS RAID 135065 (toddb): Use of MulDiv should simplify this code
//
void CalcAspectScaledRect(const SIZE *prgSize, RECT *pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = (iWidth * 1000) / prgSize->cx;
    int iYRatio = (iHeight * 1000) / prgSize->cy;

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;
        
        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = ((iHeight * 1000) / iXRatio); 
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }
        
        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = ((iWidth * 1000) / iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;
        
        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}
    
void CalculateAspectRatio(const SIZE *prgSize, RECT *pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

LPBYTE g_pbCMAP = NULL;

STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits, 
                                const SIZE *prgSize, RECT rect, DWORD dwClrDepth, 
                                HPALETTE hpal, BOOL fOrigSize, COLORREF clrBk, HBITMAP *phBmpThumbnail)
{
    HDC                 hdc = CreateCompatibleDC(NULL);
    BITMAPINFOHEADER    *pbih = (BITMAPINFOHEADER *)pbiScaled;
    BOOL                bRetVal = FALSE;
    int                 iRetVal = GDI_ERROR;
    BITMAPINFO *        pDitheredInfo = NULL;
    void *              pDitheredBits = NULL;
    HBITMAP             hbmpDithered = NULL;
    
    if (hdc)
    {
        if (dwClrDepth == 8)
        {
            RGBQUAD *pSrcColors = NULL;
            LONG nSrcPitch = pbiScaled->bmiHeader.biWidth;
            
            // we are going to 8 bits per pixel, we had better dither everything 
            // to the same palette.
            GUID guidType = CLSID_NULL;
            switch(pbiScaled->bmiHeader.biBitCount)
            {
            case 32:
                guidType = BFID_RGB_32;
                nSrcPitch *= sizeof(DWORD);
                break;
                
            case 24:
                guidType = BFID_RGB_24;
                nSrcPitch *= 3;
                break;
                
            case 16:
                // default is 555
                guidType = BFID_RGB_555;
                
                // 5-6-5 bitfields has the second DWORD (the green component) as 0x7e00
                if (pbiScaled->bmiHeader.biCompression == BI_BITFIELDS && 
                    pbiScaled->bmiColors[1].rgbGreen == 0x7E)
                {
                    guidType = BFID_RGB_565;
                }
                nSrcPitch *= sizeof(WORD);
                break;
                
            case 8:
                guidType = BFID_RGB_8;
                pSrcColors = pbiScaled->bmiColors;
                
                // nSrcPitch is already in bytes...
                break;
            };
            
            if (nSrcPitch % 4)
            {
                // round up to the nearest DWORD...
                nSrcPitch = nSrcPitch + 4 - (nSrcPitch %4);
            }
            
            // we are going to 8bpp
            LONG nDestPitch = pbiScaled->bmiHeader.biWidth;
            if (nDestPitch % 4)
            {
                // round up to the nearest DWORD...
                nDestPitch = nDestPitch + 4 - (nDestPitch % 4);
            }
            
            if (guidType != CLSID_NULL)
            {
                if (g_pbCMAP == NULL)
                {
                    // we are always going to the shell halftone palette right now, otherwise
                    // computing this inverse colour map consumes a lot of time (approx 2 seconds on
                    // a p200)
                    if (FAILED(SHGetInverseCMAP((BYTE *)&g_pbCMAP, sizeof(g_pbCMAP))))
                    {
                        return FALSE;
                    }
                }   
                
                SIZE rgDithered = {pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight};
                if (rgDithered.cy < 0)
                {
                    // invert it
                    rgDithered.cy = -rgDithered.cy;
                }
                
                if (CreateSizedDIBSECTION(&rgDithered, dwClrDepth, hpal, NULL, &hbmpDithered, &pDitheredInfo, &pDitheredBits))
                {
                    ASSERT(pDitheredInfo && pDitheredBits);
                    
                    // dither....
                    IIntDitherer *pDither;
                    HRESULT hr = CoCreateInstance(CLSID_IntDitherer, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IIntDitherer, &pDither));
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = pDither->DitherTo8bpp((LPBYTE) pDitheredBits, nDestPitch, 
                            (LPBYTE) pScaledBits, nSrcPitch, guidType, 
                            pDitheredInfo->bmiColors, pSrcColors,
                            g_pbCMAP, 0, 0, rgDithered.cx, rgDithered.cy,
                            -1, -1);
                        
                        pDither->Release();
                    }
                    if (SUCCEEDED(hr))
                    {
                        // if the height was inverted, then invert it in the destination bitmap
                        if (rgDithered.cy != pbiScaled->bmiHeader.biHeight)
                        {
                            pDitheredInfo->bmiHeader.biHeight = - rgDithered.cy;
                        }
                        
                        // switch to the new image .....
                        pbiScaled = pDitheredInfo;
                        pScaledBits = pDitheredBits;
                    }
                }
            }
        }
        
        // create thumbnail bitmap and copy image into it.
        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, phBmpThumbnail, NULL, NULL))
        {
            HBITMAP hBmpOld = (HBITMAP) SelectObject(hdc, *phBmpThumbnail);
            
            SetStretchBltMode(hdc, COLORONCOLOR);
            
            HGDIOBJ hBrush = CreateSolidBrush(clrBk);
            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
            
            HGDIOBJ hOldBrush = SelectObject(hdc, hBrush);
            HGDIOBJ hOldPen = SelectObject(hdc, hPen);
            
            HPALETTE hpalOld;
            if (hpal)
            {
                hpalOld = SelectPalette(hdc, hpal, TRUE);
                RealizePalette(hdc);
            }
            
            SetMapMode(hdc, MM_TEXT);
            
            Rectangle(hdc, 0, 0, prgSize->cx, prgSize->cy);
            
            int iDstHt = rect.bottom - rect.top;
            int iDstTop = rect.top, iSrcTop = 0;
            if (pbih->biHeight < 0)
            {
                iDstHt *= -1;
                iDstTop = rect.bottom;
                iSrcTop = abs(pbih->biHeight);
            }
            
            iRetVal = StretchDIBits(hdc, rect.left, iDstTop, rect.right - rect.left, iDstHt, 
                0, iSrcTop, pbih->biWidth, pbih->biHeight, 
                pScaledBits, pbiScaled, DIB_RGB_COLORS,  SRCCOPY);
            
            SelectObject(hdc, hOldBrush);
            DeleteObject(hBrush);
            SelectObject(hdc, hOldPen);
            if (hpal)
            {
                SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }
            
            SelectObject(hdc, hBmpOld);
        }
        
        DeleteDC(hdc);
    }
    
    if (hbmpDithered)
    {
        DeleteObject(hbmpDithered);
    }
    if (pDitheredInfo)
    {
        LocalFree(pDitheredInfo);
    }
    
    return (iRetVal != GDI_ERROR);
}


STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal, 
                                    const BITMAPINFO *pCurInfo, HBITMAP *phBmp, BITMAPINFO **ppBMI, void **ppBits)
{
    *phBmp = NULL;
    
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(dib.bi);
            dib.bi.biWidth           = prgSize->cx;
            dib.bi.biHeight          = prgSize->cy;
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) dwClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = CalcImageSize(prgSize, dwClrDepth);
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (dwClrDepth <= 8) ? (1 << dwClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpalOld = NULL;
            BOOL bDIB = TRUE;
        
            if (dwClrDepth <= 8)
            {
                // if they passed us the old structure with colour info, and we are the same bit depth, then copy it...
                if (pCurInfo && pCurInfo->bmiHeader.biBitCount == dwClrDepth)
                {
                    // use the passed in colour info to generate the DIBSECTION
                    int iColours = pCurInfo->bmiHeader.biClrUsed;

                    if (!iColours)
                    {
                        iColours = dib.bi.biClrUsed;
                    }

                    // copy the data accross...
                    if (iColours <= 256)
                    {
                        CopyMemory(dib.ct, pCurInfo->bmiColors, sizeof(RGBQUAD) * iColours);
                    }
                    else
                    {
                        bDIB = FALSE;
                    }
                }
                else
                {
                    // need to get the right palette....
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    RealizePalette(hdcBmp);
            
                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);

                    // now convert the PALETTEENTRY to RGBQUAD
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                    {
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                    }
                }
            }

            if (bDIB)
            {
                void *pbits;
                *phBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &pbits, NULL, 0);
                if (*phBmp)
                {
                    if (ppBMI)
                    {
                        *ppBMI = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(dib));
                        if (*ppBMI)
                        {
                            CopyMemory(*ppBMI, &dib, sizeof(dib));
                        }
                    }
                    if (ppBits)
                    {
                        *ppBits = pbits;
                    }
                }
            }
            DeleteDC(hdcBmp);
        }
        ReleaseDC(NULL, hdc);
    }
    return (*phBmp != NULL);
}

STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }
    return (void *)((UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\thumbutil.h ===
STDAPI_(void) CalculateAspectRatio(const SIZE *prgSize, RECT *pRect);
STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits,
                                const SIZE *prgSize, RECT rect,
                                DWORD dwClrDepth, HPALETTE hPal, BOOL fOrigSize,
                                COLORREF clrBk, HBITMAP *phBmpThumbnail);
STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigImage);
STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal,
                                    const BITMAPINFO *pCurInfo, HBITMAP *phbmp, BITMAPINFO **pBMI, void **ppBits);
STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\zoomwnd.h ===
#ifndef __ZOOMWND_H_
#define __ZOOMWND_H_

#define ZW_DRAWCOMPLETE         (WM_USER+99)    // PRIVATE
#define ZW_BACKDRAWCOMPLETE     (WM_USER+100)    // PRIVATE
// messages for the Preview Window
#define IV_SETIMAGEDATA     (WM_USER+101)
#define IV_SCROLL           (WM_USER+102)
#define IV_SETOPTIONS       (WM_USER+104)
#define IV_ONCHANGENOTIFY   (WM_USER+106)
#define IV_ISAVAILABLE      (WM_USER+107)
typedef struct
{
    LONG    x;
    LONG    y;
    LONG    cx;
    LONG    cy;
} PTSZ;

class CPreviewWnd;

class CZoomWnd : public CWindowImpl<CZoomWnd>
{
public:
    enum MODE { MODE_PAN, MODE_ZOOMIN, MODE_ZOOMOUT, MODE_NOACTION };

    // public accessor functions
    void ZoomIn();          // Does a zoom in, handles contraints
    void ZoomOut();         // does a zoom out, handles boundry conditions and constraints
    void ActualSize();      // show image at full size (crop if needed)
    void BestFit();         // show full image in window (scale down if needed)
    BOOL IsBestFit() { return m_fBestFit; }

    void SetImageData(CDecodeTask * pImageData, BOOL bUpdate=TRUE);   // used to set an image for display
    HRESULT PrepareImageData(CDecodeTask * pImageData);    // Draw an image in the back buffer
    void SetPalette( HPALETTE hpal );   // If in palette mode, set this to the palette to use
    void StatusUpdate( int iStatus );   // used to set m_iStrID to display correct status message
    void Zoom( WPARAM wParam, LPARAM lParam );
    BOOL SetMode( MODE modeNew );
    BOOL ScrollBarsPresent();
    BOOL SetScheduler(IShellTaskScheduler * pTaskScheduler);
    int  QueryStatus() { return m_iStrID; }

    // Annotation Functions
    void GetVisibleImageWindowRect(LPRECT prectImage);
    void GetImageFromWindow(LPPOINT ppoint, int cSize);
    void GetWindowFromImage(LPPOINT ppoint, int cSize);
    CAnnotationSet* GetAnnotations() { return &m_Annotations; }
    void CommitAnnotations();

    DWORD GetBackgroundColor();
    
    CZoomWnd(CPreviewWnd *pPreview);
    ~CZoomWnd();

    DECLARE_WND_CLASS( TEXT("ShImgVw:CZoomWnd") );

protected:
BEGIN_MSG_MAP(CZoomWnd)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnMouseDown)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_MBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
    MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
    MESSAGE_HANDLER(WM_MOUSEWHEEL, OnWheelTurn)
    MESSAGE_HANDLER(ZW_DRAWCOMPLETE, OnDrawComplete)
    MESSAGE_HANDLER(ZW_BACKDRAWCOMPLETE, OnBackDrawComplete)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
END_MSG_MAP()

    // message handlers
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBackDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    // This is lazy.  These are used by CPreview so I made them public when they probably shouldn't be.
    LRESULT OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    int m_cxImage;      // width of bitmap referenced by m_pImageData
    int m_cyImage;      // height of bitmap referenced by m_pImageData
    float m_cxImgPhys;    // actual width of the image in inches
    float m_cyImgPhys;    // actual height of the image in inches
    int   m_cxImgPix;     // width of the image in screen pixels
    int   m_cyImgPix;     // height of the image in screen pixels
    float m_imgDPIx;
    float m_imgDPIy;
    float m_winDPIx;
    float m_winDPIy;
    

protected:
    BOOL m_fBestFit;    // True if we are in Bets Fit mode
    CDecodeTask * m_pImageData;// Handle to a IShellImageData object with render info

    int m_cxCenter;     // point to center on relative to image
    int m_cyCenter;     // point to center on relative to image

    int m_cxVScroll;    // width of a scroll bar
    int m_cyHScroll;    // height of a scroll bar
    int m_cxWindow;     // width of our client area + scroll width if scroll bar is visible
    int m_cyWindow;     // height of our client area + scroll height if scroll bar is visible
    float m_cxWinPhys;    // actual width of the client area in inches
    float m_cyWinPhys;    // actual height of the client in inches
    int m_xPosMouse;    // used to track mouse movement when dragging the LMB
    int m_yPosMouse;    // used to track mouse movement when dragging the LMB

    MODE m_modeDefault; // The zoom or pan mode when the shift key isn't pressed
    PTSZ m_ptszDest;    // the point and size of the destination rectangle (window coordinates)
    RECT m_rcCut;       // the rectangle of the part of the image that will be visible (image coordinates)
    RECT m_rcBleed;     // the rectangle adjusted for pixelation effects (window coordinates)
    BOOL m_fPanning;    // true when we are panning (implies left mouse button is down)
    BOOL m_fCtrlDown;   // a mode modifier ( zoom <=> pan ), true if Ctrl Key is down
    BOOL m_fShiftDown;  // a mode modifier ( zoom in <=> zoom out), true if Shift Key is down
    
    
    BOOL m_fTimerReady; // reset each time SetImageData is called, unset when timer is reset after OnDrawComplete

    int m_iStrID;       // string to display when no bitmap available

    BOOL  m_fFoundBackgroundColor;
    DWORD m_dwBackgroundColor;

    HPALETTE m_hpal;

    CPreviewWnd *m_pPreview; //  do not delete this

    CAnnotationSet m_Annotations;

    Buffer * m_pFront;
    Buffer * m_pBack;
    UINT     m_iIndex; // Index corresponding to the back buffer.

    IShellTaskScheduler * m_pTaskScheduler;

    // protected methods
    void AdjustRectPlacement(); // applies constraints for centering, ensureinging maximum visibility, etc
    void CalcCut();             // calculates the cut region that will be visible after a zoom
    void CalcCut(PTSZ ptszDest, int cxImage, int cyImage, RECT &rcCut, RECT &rcBleed);
    void GetPTSZForBestFit(int cxImgPix, int cyImgPix, float cxImgPhys, float cyImgPhys, PTSZ &ptszDest);
    void SetScrollBars();       // ensures scroll bar state is correct.  Used after window resize or zoom.
    HRESULT PrepareDraw();      // draw the image in the background thread
    void FlushDrawMessages();   // remove any pending draw tasks and messages
    BOOL SwitchBuffers(UINT iIndex);
    void _UpdatePhysicalSize();
};

#include "prevwnd.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shscrap"
#define SZ_MODULE           "SHSCRAP"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\ids.h ===
// icon resource ids
#define IDI_ICON		100
#define IDI_TEMPLATE		101
#define IDI_SCRAP		102

// dialog box resource IDs
#define IDD_VIEW		100

// control IDs
#define IDI_SCRAPVIEW		100

// string resource ids
#define IDS_TITLE			0x100
#define IDS_TITLE_ERR			0x101
#define IDS_FILETYPE                    0x102

#define IDS_ERR_DOVERB			0x110
#define IDS_ERR_DOVERB_F 		0x111
#define IDS_ERR_COMMIT			0x112
#define IDS_ERR_COMMIT_F 		0x113
#define IDS_ERR_SCRAPSAVE		0x114
#define IDS_ERR_SCRAPSAVE_F 		0x115
#define IDS_ERR_CREATESTORAGE		0x116
#define IDS_ERR_CREATESTORAGE_F 	0x117
#define IDS_ERR_CREATEDOCFILE		0x118
#define IDS_ERR_CREATEDOCFILE_F 	0x119

#define IDS_BOOKMARK_S		0x200
#define IDS_BOOKMARK_L		0x201
#define IDS_FINDINVALIDFILENAME 0x202
#define IDS_NEWLINK             0x202
#define IDS_SCRAP_S		0x203
#define IDS_SCRAP_L		0x204
#define IDS_TEMPSCRAP		0x205
#define IDS_TEMPLINK		0x206

#define IDS_WOULDYOUSAVEAS	0x210
#define IDS_MOVEFAILED		0x211
#define IDS_SCRAPFILTER         0x212
#define IDS_SECURITY_WARNING_TEXT   0x213
#define IDS_SECURITY_WARNING_TITLE  0x214
#define IDS_HRES_MIN			0x400
#define IDS_HRES_MAX			0x800
#define IDS_HRES_INVALID_SCRAPFILE	0x400

#define IDR_FANCYERR		0x100

// reserved up to 0x1fff
#define IDS_FANCYERR		0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\zoomwnd.cpp ===
#include "precomp.h"
#include <uxtheme.h>
#include <shstyle.h>

#include "prevwnd.h"
#include "guids.h"
#include "resource.h"

#define COLOR_PREVIEWBKGND COLOR_WINDOW

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

/////////////////////////////////////////////////////////////////////////////
// CZoomWnd

CZoomWnd::CZoomWnd(CPreviewWnd *pPreview)
{
    m_modeDefault = MODE_NOACTION;
    m_fPanning = FALSE;
    m_fCtrlDown = FALSE;
    m_fShiftDown = FALSE;
    
    m_fBestFit = TRUE;

    m_cxImage = 1;
    m_cyImage = 1;
    m_cxCenter = 1;
    m_cyCenter = 1;
    m_pImageData = NULL;

    m_cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
    m_cxVScroll = GetSystemMetrics(SM_CXVSCROLL);

    m_iStrID = IDS_NOPREVIEW;

    m_hpal = NULL;
    m_pPreview = pPreview;

    m_pFront = NULL;
    m_pBack = NULL;

    m_pTaskScheduler = NULL;

    m_fTimerReady = FALSE;

    m_fFoundBackgroundColor = FALSE;
    m_iIndex = -1;
}

CZoomWnd::~CZoomWnd()
{
    if (m_pImageData)
        m_pImageData->Release();

    if (m_pTaskScheduler)
    {
        // wait for any pending draw tasks since we're about to delete the buffers
        DWORD dwMode;
        m_pPreview->GetMode(&dwMode);

        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
        m_pTaskScheduler->Release();
    }

    if (m_pBack)
    {
        DeleteBuffer(m_pBack);
        m_pBack = NULL;
    }

    // DeleteBuffer is going to check for NULL anyway
    DeleteBuffer(m_pFront);
}


LRESULT CZoomWnd::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // turn off The RTL layout extended style in GWL_EXSTYLE
    SHSetWindowBits(m_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, 0);
    HDC hdc = GetDC();
    m_winDPIx = (float)(GetDeviceCaps(hdc,LOGPIXELSX));
    m_winDPIy = (float)(GetDeviceCaps(hdc,LOGPIXELSY));
    ReleaseDC(hdc);
    return 0;
}


DWORD CZoomWnd::GetBackgroundColor()
{
    if (!m_fFoundBackgroundColor)
    {
        // First try the theme file
        HINSTANCE hinstTheme = SHGetShellStyleHInstance();

        if (hinstTheme)
        {
            WCHAR sz[20];
            if (LoadString(hinstTheme, IDS_PREVIEW_BACKGROUND_COLOR, sz, ARRAYSIZE(sz)))
            {
                int nColor;
                if (StrToIntEx(sz, STIF_SUPPORT_HEX, &nColor))
                {
                    m_dwBackgroundColor = (DWORD)nColor;
                    m_fFoundBackgroundColor = TRUE;
                }
            }
            FreeLibrary(hinstTheme);
        }


        if (!m_fFoundBackgroundColor)
        {
            m_dwBackgroundColor = GetSysColor(COLOR_PREVIEWBKGND);
            m_fFoundBackgroundColor = TRUE;
        }
    }

    return m_dwBackgroundColor;
}

LRESULT CZoomWnd::OnEraseBkgnd(UINT , WPARAM wParam, LPARAM , BOOL&)
{
    RECT rcFill;                            // rect to fill with background color
    HDC hdc = (HDC)wParam;

    if (!m_pPreview->OnSetColor(hdc))
        SetBkColor(hdc, GetBackgroundColor());

    // There are four possible regions that might need to be erased:
    //      +-----------------------+
    //      |       Erase Top       |
    //      +-------+-------+-------+
    //      |       |       |       |
    //      | Erase | Image | Erase |
    //      | Left  |       | Right |
    //      +-------+-------+-------+
    //      |     Erase Bottom      |
    //      +-----------------------+

    if (m_pFront && m_pFront->hdc)
    {
        RECT rcImage = m_pFront->rc;
        HPALETTE hPalOld = NULL;
        if (m_pFront->hPal)
        {
            hPalOld = SelectPalette(hdc, m_pFront->hPal, FALSE);
            RealizePalette(hdc);
        }
        BitBlt(hdc, rcImage.left, rcImage.top, RECTWIDTH(rcImage), RECTHEIGHT(rcImage),
                   m_pFront->hdc, 0,0, SRCCOPY);
        
        
        // erase the left region

        rcFill.left = 0;
        rcFill.top = rcImage.top;
        rcFill.right = rcImage.left;
        rcFill.bottom = rcImage.bottom;
        if (rcFill.right > rcFill.left)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        // erase the right region
        rcFill.left = rcImage.right;
        rcFill.right = m_cxWindow;
        if (rcFill.right > rcFill.left)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);        
        }

        // erase the top region
        rcFill.left = 0;
        rcFill.top = 0;
        rcFill.right = m_cxWindow;
        rcFill.bottom = rcImage.top;
        if (rcFill.bottom > rcFill.top)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        // erase the bottom region
        rcFill.top = rcImage.bottom;
        rcFill.bottom = m_cyWindow;
        if (rcFill.bottom > rcFill.top)
        {
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
        }

        HBRUSH hbr = GetSysColorBrush(COLOR_WINDOWTEXT);
        FrameRect(hdc, &rcImage, hbr);
        if (hPalOld)
        {
            SelectPalette(hdc, hPalOld, FALSE);
        }
    }

    return TRUE;
}


void CZoomWnd::FlushDrawMessages()
{
    // first, remove any pending draw tasks
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);

    TASKOWNERID toid;
    GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

    m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);

    // make sure any posted messages get flushed and we free the associated data
    MSG msg;
    while (PeekMessage(&msg, m_hWnd, ZW_DRAWCOMPLETE, ZW_DRAWCOMPLETE, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already 
        // Posted a quit message then PeekMessage will return a WM_QUIT message 
        // regardless of the filter min and max and subsequent calls to 
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more 
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }
        
        Buffer * pBuf = (Buffer *)msg.wParam;
        DeleteBuffer(pBuf);
    }
}

HRESULT CZoomWnd::PrepareDraw()
{
    // first, remove any pending draw tasks
    FlushDrawMessages();

    // we are now waiting for the "next task", even if we don't create a task with this ID.
    HRESULT hr = S_OK;
    BOOL bInvalidate = FALSE;
    if (m_pImageData)
    {
        if (m_pImageData->_iItem == m_iIndex)
        {
            SwitchBuffers(m_iIndex);
            bInvalidate = TRUE;
        }
        else
        {
            COLORREF clr;
            if (!m_pPreview->GetColor(&clr))
                clr = GetBackgroundColor();

            m_iStrID = IDS_DRAWFAILED;
            IRunnableTask * pTask;
            hr = CDrawTask::Create(m_pImageData, clr, m_rcCut, m_rcBleed, m_hWnd, ZW_DRAWCOMPLETE, &pTask);
            if (SUCCEEDED(hr))
            {
                DWORD dwMode;
                m_pPreview->GetMode(&dwMode);

                TASKOWNERID toid;
                GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

                hr = m_pTaskScheduler->AddTask(pTask, toid, ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);
                if (SUCCEEDED(hr))
                {
                    m_iStrID = IDS_DRAWING;
                }
                pTask->Release();
            }
            else
            {
                bInvalidate = TRUE;
            }
        }
    }
    else
    {
        bInvalidate = TRUE;
    }
    
    if (m_hWnd && bInvalidate)
        InvalidateRect(NULL);

    return hr;
}

HRESULT CZoomWnd::PrepareImageData(CDecodeTask *pImageData)
{
    HRESULT hr = E_FAIL;
    if (pImageData)
    {
        SIZE sz;
        ULONG dpiX, dpiY;
        int cxImgPix, cyImgPix;
        float cxImgPhys, cyImgPhys;
        PTSZ ptszDest;

        pImageData->GetSize(&sz);
        pImageData->GetResolution(&dpiX, &dpiY);
        cxImgPhys = sz.cx/(float)dpiX;
        cyImgPhys = sz.cy/(float)dpiY;
        cxImgPix = (int)(cxImgPhys*m_winDPIx);
        cyImgPix = (int)(cyImgPhys*m_winDPIy);

        GetPTSZForBestFit(cxImgPix, cyImgPix, cxImgPhys, cyImgPhys, ptszDest);

        RECT rcCut, rcBleed;
        CalcCut(ptszDest, sz.cx, sz.cy, rcCut, rcBleed);

        COLORREF clr;
        if (!m_pPreview->GetColor(&clr))
            clr = GetBackgroundColor();

        IRunnableTask * pTask;
        hr = CDrawTask::Create(pImageData, clr, rcCut, rcBleed, m_hWnd, ZW_BACKDRAWCOMPLETE, &pTask);
        if (SUCCEEDED(hr))
        {
            DWORD dwMode;
            m_pPreview->GetMode(&dwMode);

            TASKOWNERID toid;
            GetTaskIDFromMode(GTIDFM_DRAW, dwMode, &toid);

            hr = m_pTaskScheduler->AddTask(pTask, toid, ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();
        }
    }

    return hr;
}


BOOL CZoomWnd::SwitchBuffers(UINT iIndex)
{
    BOOL fRet = FALSE;
    if (m_pBack && m_iIndex == iIndex)
    {
        // DeleteBuffer is going to check for NULL anyway
        DeleteBuffer(m_pFront);

        m_pFront = m_pBack;
        m_pBack = NULL;
        m_iIndex = -1;
        
        InvalidateRect(NULL);
        UpdateWindow();

        if (m_fTimerReady)
        {
            m_pPreview->OnDrawComplete();
            m_fTimerReady = FALSE;
        }

        fRet = TRUE;
    }

    return fRet;
}

LRESULT CZoomWnd::OnBackDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Buffer * pBuf = (Buffer *)wParam;

    if (m_pBack)
    {
        DeleteBuffer(m_pBack);
        m_pBack = NULL;
    }

    if (pBuf)
    {
        m_pBack = pBuf;
    }
    m_iIndex = PtrToInt((void *)lParam);

    return 0;
}


LRESULT CZoomWnd::OnDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Buffer * pBuf = (Buffer *)wParam;

    if (m_pFront)
    {
        DeleteBuffer(m_pFront);
        m_pFront = NULL;
    }

    if (pBuf)
    {
        m_pFront = pBuf;
    }
    else
    {
        m_iStrID = IDS_DRAWFAILED;
    }

    InvalidateRect(NULL);
    UpdateWindow();

    if (m_fTimerReady)
    {
        m_pPreview->OnDrawComplete();
        m_fTimerReady = FALSE;
    }

    return 0;
}

// OnPaint
//
// Handles WM_PAINT messages sent to the window

LRESULT CZoomWnd::OnPaint(UINT , WPARAM , LPARAM , BOOL&)
{
    PAINTSTRUCT ps;
    HDC hdcDraw = BeginPaint(&ps);

    // setup the destination DC:
    SetMapMode(hdcDraw, MM_TEXT);
    SetStretchBltMode(hdcDraw, COLORONCOLOR);

    if (m_hpal)
    {
        SelectPalette(hdcDraw, m_hpal, TRUE);
        RealizePalette(hdcDraw);
    }

    if (m_pFront)
    {
        if (m_Annotations.GetCount() > 0)
        {
            CPoint ptDeviceOrigin;

            ptDeviceOrigin.x = m_rcBleed.left - MulDiv(m_rcCut.left, RECTWIDTH(m_rcBleed), RECTWIDTH(m_rcCut));
            ptDeviceOrigin.y = m_rcBleed.top - MulDiv(m_rcCut.top, RECTHEIGHT(m_rcBleed), RECTHEIGHT(m_rcCut));

            SetMapMode(hdcDraw, MM_ANISOTROPIC);
            SetWindowOrgEx(hdcDraw, 0, 0, NULL);
            SetWindowExtEx(hdcDraw, RECTWIDTH(m_rcCut), RECTHEIGHT(m_rcCut), NULL);
            SetViewportOrgEx(hdcDraw, ptDeviceOrigin.x, ptDeviceOrigin.y, NULL);
            SetViewportExtEx(hdcDraw, RECTWIDTH(m_rcBleed), RECTHEIGHT(m_rcBleed), NULL);

            HRGN hrgn = CreateRectRgnIndirect(&m_rcBleed);
            if (hrgn != NULL)
                SelectClipRgn(hdcDraw, hrgn);

            m_Annotations.RenderAllMarks(hdcDraw);

            SelectClipRgn(hdcDraw, NULL);

            if (hrgn != NULL)
                DeleteObject(hrgn);

            SetMapMode(hdcDraw, MM_TEXT);
            SetViewportOrgEx(hdcDraw, 0, 0, NULL);
            SetWindowOrgEx(hdcDraw, 0, 0, NULL);
        }

        m_pPreview->OnDraw(hdcDraw);
    }
    else 
    {
        TCHAR szBuf[80];
        LoadString(_Module.GetModuleInstance(), m_iStrID, szBuf, ARRAYSIZE(szBuf) );

        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0);
        HFONT hFont = CreateFontIndirect(&lf);
        HFONT hFontOld;

        if (hFont)
            hFontOld = (HFONT)SelectObject(hdcDraw, hFont);

        if (!m_pPreview->OnSetColor(hdcDraw))
        {
            SetTextColor(hdcDraw, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hdcDraw, GetBackgroundColor());
        }

        RECT rc = { 0,0,m_cxWindow,m_cyWindow };
        ExtTextOut(hdcDraw, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
        DrawText(hdcDraw, szBuf, -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        if (hFont)
        {
            SelectObject(hdcDraw, hFontOld);
            DeleteObject(hFont);
        }
    }

    EndPaint(&ps);
    return 0;
}


// OnSetCursor
//
// Handles WM_SETCURSOR messages sent to the window.
//
// This function is a total HackMaster job.  I have overloaded its functionality to the point
// of absurdity.  Here's what the parameters mean:
//
// uMsg == WM_SETCURSOR
//      wParam  Standard value sent during a WM_SETCURSOR messge.
//      lParam  Standard value sent during a WM_SETCURSOR messge.
//
// uMsg == 0
//      wParam  0
//      lParam  If this value is non-zero then it is a packed x,y cursor location.
//              If it's zero then we need to query the cursor location

LRESULT CZoomWnd::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    // if this is a legitimate message but isn't intended for the client area, we ignore it.
    // we also ignore set cursor when we have no valid bitmap
    
    if (((WM_SETCURSOR == uMsg) && (HTCLIENT != LOWORD(lParam))) || (m_iStrID != IDS_LOADING && !m_pImageData))
    {
        bHandled = FALSE;
        return 0;
    }
    else if (0 == uMsg)
    {
        // Since this is one of our fake messages we need to do our own check to test for HTCLIENT.
        // we need to find the cursor location
        POINT pt;
        GetCursorPos(&pt);
        lParam = MAKELONG(pt.x, pt.y);
        if (HTCLIENT != SendMessage(WM_NCHITTEST, 0, lParam))
        {
            bHandled = FALSE;
            return 0;
        }
    }

    if (m_pPreview->OnSetCursor(uMsg, wParam, lParam))
    {
        bHandled = TRUE;
        return TRUE;
    }
    
    
    HINSTANCE hinst = _Module.GetModuleInstance();
    LPTSTR idCur;
    if (m_iStrID == IDS_LOADING && !m_pImageData)
    {
        idCur = IDC_WAIT;
        hinst = NULL;
    }
    else if (m_fPanning)
    {
        idCur = MAKEINTRESOURCE(IDC_CLOSEDHAND);
    }
    else if (m_fCtrlDown)
    {
        idCur = MAKEINTRESOURCE(IDC_OPENHAND);
    }
    else if (m_modeDefault == MODE_NOACTION)
    {
        hinst = NULL;
        idCur = IDC_ARROW;
    }
    else if ((m_modeDefault == MODE_ZOOMIN && m_fShiftDown == FALSE) || (m_modeDefault == MODE_ZOOMOUT && m_fShiftDown == TRUE))
    {
        idCur = MAKEINTRESOURCE(IDC_ZOOMIN);
    }
    else
    {
        idCur = MAKEINTRESOURCE(IDC_ZOOMOUT);
    }

    SetCursor(LoadCursor(hinst, idCur));
    return TRUE;
}

// OnKeyUp
//
// Handles WM_KEYUP messages sent to the window
LRESULT CZoomWnd::OnKeyUp(UINT , WPARAM wParam, LPARAM , BOOL& bHandled)
{
    if (VK_CONTROL == wParam)
    {
        m_fCtrlDown = FALSE;
        OnSetCursor(0,0,0, bHandled);
    }
    else if (VK_SHIFT == wParam)
    {
        m_fShiftDown = FALSE;
        OnSetCursor(0,0,0, bHandled);
    }
    
    bHandled = FALSE;
    return 0;
}
  
// OnKeyDown
//
// Handles WM_KEYDOWN messages sent to the window
LRESULT CZoomWnd::OnKeyDown(UINT , WPARAM wParam, LPARAM , BOOL& bHandled)
{
    // when we return, we want to call the DefWindowProc
    bHandled = FALSE;

    switch (wParam)
    {
    case VK_PRIOR:
        OnScroll(WM_VSCROLL, m_fCtrlDown?SB_TOP:SB_PAGEUP, 0, bHandled);
        break;

    case VK_NEXT:
        OnScroll(WM_VSCROLL, m_fCtrlDown?SB_BOTTOM:SB_PAGEDOWN, 0, bHandled);
        break;

    case VK_END:
        OnScroll(WM_HSCROLL, m_fCtrlDown?SB_BOTTOM:SB_PAGEDOWN, 0, bHandled);
        break;

    case VK_HOME:
        OnScroll(WM_HSCROLL, m_fCtrlDown?SB_TOP:SB_PAGEUP, 0, bHandled);
        break;

    case VK_CONTROL:
    case VK_SHIFT:
        // if m_fPanning is TRUE then we are already in the middle of an operation so we
        // should maintain the cursor for that operation
        if (!m_fPanning)
        {
            if (VK_CONTROL == wParam)
            {
                m_fCtrlDown = TRUE;
            }
            if (VK_SHIFT == wParam)
            {
                m_fShiftDown = TRUE;
            }

            // Update the cursor based on the key states set above only if we are over our window
            OnSetCursor(0,0,0, bHandled);
        }
        break;

    default:
        // if in run screen preview mode any key other than Shift and Control will dismiss the window
        if (NULL == GetParent())
        {
            DestroyWindow();
        }
        return 1;   // return non-zero to indicate unprocessed message
    }

    return 0;
}


// OnMouseUp
//
// Handles WM_LBUTTONUP messages sent to the window

LRESULT CZoomWnd::OnMouseUp(UINT , WPARAM , LPARAM , BOOL& bHandled)
{
    if (m_fPanning)
        ReleaseCapture();
    m_fPanning = FALSE;
    bHandled = FALSE;
    return 0;
}

// OnMouseDown
//
// Handles WM_LBUTTONDOWN and WM_MBUTTONDOWN messages sent to the window
LRESULT CZoomWnd::OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_pPreview->OnMouseDown(uMsg, wParam, lParam))
        return 0;

    // This stuff should be avoided if m_pImage is NULL.
    if (!m_pImageData)
        return 0;

    m_xPosMouse = GET_X_LPARAM(lParam);
    m_yPosMouse = GET_Y_LPARAM(lParam);

    ASSERT(m_fPanning == FALSE);

    // Holding the CTRL key makes a pan into a zoom and vise-versa.
    // The middle mouse button always pans regardless of default mode and key state.
    if ((wParam & MK_CONTROL) || (uMsg == WM_MBUTTONDOWN))
    {
        // REVIEW: check for pan being valid here?  Should be more efficient than all the checks
        // I have to do in OnMouseMove.
        m_fPanning = TRUE;

        OnSetCursor(0,0,0,bHandled);
        SetCapture();
    }
    else if (m_modeDefault != MODE_NOACTION)
    {
        // Holding down the shift key turns a zoomin into a zoomout and vise-versa.
        // The "default" zoom mode is zoom in (if mode = pan and ctrl key is down we zoom in).
        BOOL bZoomIn = (m_modeDefault != MODE_ZOOMOUT) ^ ((wParam & MK_SHIFT)?1:0);

        // Find the point we want to stay centered on:
        m_cxCenter = MulDiv(m_xPosMouse-m_ptszDest.x, m_cxImgPix, m_ptszDest.cx);
        m_cyCenter = MulDiv(m_yPosMouse-m_ptszDest.y, m_cyImgPix, m_ptszDest.cy);

        bZoomIn?ZoomIn():ZoomOut();
    }
    bHandled = FALSE;
    return 0;
}

void CZoomWnd::Zoom(WPARAM wParam, LPARAM lParam)
{
    switch (wParam&0xFF)
    {
    case IVZ_CENTER:
        break;
    case IVZ_POINT:
        {
            int x = GET_X_LPARAM(lParam);
            int y = GET_Y_LPARAM(lParam);

            if (x<0) x=0;
            else if (x>=m_cxImgPix) x = m_cxImgPix-1;
            if (y<0) y=0;
            else if (y>=m_cyImgPix) y = m_cyImgPix-1;

            m_cxCenter = x;
            m_cyCenter = y;
        }
        break;
    case IVZ_RECT:
        {
            LPRECT prc = (LPRECT)lParam;
            int x = (prc->left+prc->right)/2;
            int y = (prc->top+prc->bottom)/2;

            if (x<0) x=0;
            else if (x>=m_cxImgPix) x = m_cxImgPix-1;
            if (y<0) y=0;
            else if (y>=m_cyImgPix) y = m_cyImgPix-1;

            m_cxCenter = x;
            m_cyCenter = y;
            // TODO: This should really completely adjust the dest rect but I have to
            // check for any assumptions about aspect ratio before I allow this absolute
            // aspect ignoring zoom mode.
        }
        break;
    }
    if (wParam&IVZ_ZOOMOUT)
    {
        ZoomOut();
        SetMode(MODE_ZOOMOUT);
    }
    else
    {
        ZoomIn();
        SetMode(MODE_ZOOMIN);
    }
}

void CZoomWnd::ZoomIn()
{
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);
    if (m_pImageData && (SLIDESHOW_MODE != dwMode))
    {
        m_fBestFit = FALSE;

        // first, the height is adjusted by the amount the mouse cursor moved.
        m_ptszDest.cy = (LONG)/*ceil*/(m_ptszDest.cy*1.200);  // ceil is required in order to zoom in
                                                                // on 4px high or less image

        // FEATURE: allow zooming beyond 16x the full size of the image
        // The use of the Cut and Bleed rectangles should eliminate the need for this
        // arbitrary zoom limit.  The limit was originally added because GDI on win9x isn't ver good and
        // can't handle large images.  Even on NT you would eventually zoom to the point where
        // it would take many seconds to blt the bitmap.  Now we only blt the minimum required
        // area.
        if (m_ptszDest.cy >= m_cyImgPix*16)
        {
            m_ptszDest.cy = m_cyImgPix*16;
        }

        // next, a new width is calculated based on the original image dimensions and the new height
        m_ptszDest.cx = (LONG)(m_ptszDest.cy* (m_cxImgPhys*m_winDPIx)/(m_cyImgPhys*m_winDPIy));
        AdjustRectPlacement();
    }
}

void CZoomWnd::ZoomOut()
{
    DWORD dwMode;
    m_pPreview->GetMode(&dwMode);
    if (m_pImageData && (SLIDESHOW_MODE != dwMode))
    {
        // if the destination rect already fits within the window, don't allow a zoom out.
        // This check is to prevent a redraw that would occur otherwise 
        if ((m_ptszDest.cx <= MIN(m_cxWindow,m_cxImgPix)) &&
            (m_ptszDest.cy <= MIN(m_cyWindow,m_cyImgPix)))
        {
            m_fBestFit = TRUE;
            return;
        }

        // first, the height is adjusted by the amount the mouse cursor moved.
        m_ptszDest.cy = (LONG)/*floor*/(m_ptszDest.cy*0.833); // floor is default behavior
        // next, a new width is calculated based on the original image dimensions and the new height
        m_ptszDest.cx = (LONG)(m_ptszDest.cy* (m_cxImgPhys*m_winDPIx)/(m_cyImgPhys*m_winDPIy));
        AdjustRectPlacement();
    }
}

// OnMouseMove
//
// Handles WM_MOUSEMOVE messages sent to the control

LRESULT CZoomWnd::OnMouseMove(UINT , WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // This is something of a hack since I never recieve the keyboard focus
    m_fCtrlDown = (BOOL)(wParam & MK_CONTROL);
    m_fShiftDown = (BOOL)(wParam & MK_SHIFT); 
    
    // we only care about mouse move when the middle or left button is down
    // and we have a valid bitmap handle and we are panning
    if (!(wParam & (MK_LBUTTON|MK_MBUTTON)) || !m_fPanning || !m_pImageData)
    {
        m_pPreview->OnMouseMove(WM_MOUSEMOVE, wParam, lParam);
        bHandled = FALSE;
        return TRUE;
    }

    // we know we are panning when we reach this point
    ASSERT(m_fPanning);

    POINTS pt = MAKEPOINTS(lParam);
    PTSZ ptszDest;

    ptszDest.cx = m_ptszDest.cx;
    ptszDest.cy = m_ptszDest.cy;

    // only allow side-to-side panning if it's needed
    if (m_ptszDest.cx > m_cxWindow)
    {
        ptszDest.x = m_ptszDest.x + pt.x - m_xPosMouse;
    }
    else
    {
        ptszDest.x = m_ptszDest.x;
    }

    // only allow up-and-down panning if it's needed
    if (m_ptszDest.cy > m_cyWindow)
    {
        ptszDest.y = m_ptszDest.y + pt.y - m_yPosMouse;
    }
    else
    {
        ptszDest.y = m_ptszDest.y;
    }

    // if the image is now smaller than the window, center it
    // if the image is now panned when it shouldn't be, adjust the possition
    if (ptszDest.cx < m_cxWindow)
        ptszDest.x = (m_cxWindow-ptszDest.cx)/2;
    else
    {
        if (ptszDest.x < (m_cxWindow - ptszDest.cx))
            ptszDest.x = m_cxWindow - ptszDest.cx;
        if (ptszDest.x > 0)
            ptszDest.x = 0;
    }
    if (ptszDest.cy < m_cyWindow)
        ptszDest.y = (m_cyWindow-ptszDest.cy)/2;
    else
    {
        if (ptszDest.y < (m_cyWindow - ptszDest.cy))
            ptszDest.y = m_cyWindow - ptszDest.cy;
        if (ptszDest.y > 0)
            ptszDest.y = 0;
    }

    m_xPosMouse = pt.x;
    m_yPosMouse = pt.y;

    // ensure the scroll bars are correct
    SetScrollBars();

    // if anything has changed, we must invalidate the window to force a repaint
    if ((ptszDest.x != m_ptszDest.x) || (ptszDest.y != m_ptszDest.y) ||
         (ptszDest.cx != m_ptszDest.cx) || (ptszDest.y != m_ptszDest.y))
    {
        m_ptszDest = ptszDest;
        CalcCut();
        PrepareDraw();
    }

    // Update m_cxCenter and m_cyCenter so that a zoom after a pan will zoom in
    // on the correct area.  This is majorly annoying otherwise.  We want the
    // new center to be whatever is in the center of the window after we pan.
    m_cxCenter = MulDiv(m_cxWindow/2-m_ptszDest.x, m_cxImgPix, m_ptszDest.cx);
    m_cyCenter = MulDiv(m_cyWindow/2-m_ptszDest.y, m_cyImgPix, m_ptszDest.cy);

    return TRUE;
}

// OnSize
//
// Handles WM_SIZE messages set to the window

LRESULT CZoomWnd::OnSize(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    m_cxWindow = GET_X_LPARAM(lParam);
    m_cyWindow = GET_Y_LPARAM(lParam);
    _UpdatePhysicalSize();
    if (m_fBestFit)
    {
        BestFit();
    }
    else
    {
        // The size of the rect doesn't change in this case, so just reposition
        AdjustRectPlacement();
    }

    return TRUE;
}

BOOL CZoomWnd::SetScheduler(IShellTaskScheduler * pTaskScheduler)
{
    if (!m_pTaskScheduler)
    {
        m_pTaskScheduler = pTaskScheduler;
        m_pTaskScheduler->AddRef();
        return TRUE;
    }
    return FALSE;
}

// SetMode
//
// Sets the current mouse mode to one of the values specified in the MODE enumeration.
// Currently there are two important modes, pan and zoom.  The mode effects the default mouse
// cursor when moving over the zoom window and the behavior of a click-and-drag with the
// left mouse button.  Holding the shift key effects the result of a click-and-drag but
// does not effect m_mode, which is the default when the shift key isn't down.

BOOL CZoomWnd::SetMode(MODE modeNew)
{
    if (m_modeDefault == modeNew)
        return FALSE;
    m_modeDefault = modeNew;
    BOOL bDummy;
    OnSetCursor(0,0,0, bDummy);
    return TRUE;
}

// ActualSize
//
// Displays image zoomed to its full size
void CZoomWnd::ActualSize()
{
    m_fBestFit = FALSE;

    if (m_pImageData)
    {
        // actual size means same size as the image
        m_ptszDest.cx = (LONG)(m_cxImgPix);
        m_ptszDest.cy = (LONG)(m_cyImgPix);

        // we center the image in the window
        m_ptszDest.x = (LONG)((m_cxWinPhys-m_cxImgPhys)*m_winDPIx/2.0);
        m_ptszDest.y = (LONG)((m_cyWinPhys-m_cyImgPhys)*m_winDPIy/2.0);

        CalcCut();

        // Setting actual size is a zoom operation.  Whenever we zoom we update our centerpoint.
        m_cxCenter = m_cxImgPix/2;
        m_cyCenter = m_cyImgPix/2;

        // turn scoll bars on/off as needed
        SetScrollBars();

        PrepareDraw();
    }
}


void CZoomWnd::GetPTSZForBestFit(int cxImgPix, int cyImgPix, float cxImgPhys, float cyImgPhys, PTSZ &ptszDest)
{
    // Determine the limiting axis, if any.
    if (cxImgPhys <= m_cxWinPhys && cyImgPhys <= m_cyWinPhys)
    {
        // item fits centered within window
        ptszDest.x = (LONG)((m_cxWinPhys-cxImgPhys)*m_winDPIx/2.0);
        ptszDest.y = (LONG)((m_cyWinPhys-cyImgPhys)*m_winDPIy/2.0);
        ptszDest.cx = (LONG)(cxImgPix);
        ptszDest.cy = (LONG)(cyImgPix);
    }
    else if (cxImgPhys * m_cyWinPhys < m_cxWinPhys * cyImgPhys)
    {
        // height is the limiting factor
        int iNewWidth = (int)((m_cyWinPhys*cxImgPhys/cyImgPhys) * m_winDPIx);
        ptszDest.x = (m_cxWindow-iNewWidth)/2;
        ptszDest.y = 0;
        ptszDest.cx = iNewWidth;
        ptszDest.cy = m_cyWindow;
    }
    else
    {
        // width is the limiting factor
        int iNewHeight = (int)((m_cxWinPhys*cyImgPhys/cxImgPhys) * m_winDPIy);
        ptszDest.x = 0;
        ptszDest.y = (m_cyWindow-iNewHeight)/2;
        ptszDest.cx = m_cxWindow;
        ptszDest.cy = iNewHeight;
    }
}

// BestFit
//
// Computes the default location for the destination rectangle.  This rectangle is a
// best fit while maintaining aspect ratio within a window of the given width and height.
// If the window is larger than the image, the image is centered, otherwise it is scaled
// to fit within the window.  The destination rectange is computed in the client coordinates
// of the window whose width and height are passed as arguments (ie we assume the point 0,0
// is the upper left corner of the window).
//
void CZoomWnd::BestFit()
{
    m_fBestFit = TRUE;

    if (m_pImageData)
    {
        // if scroll bars are on, adjust the client size to what it will be once they are off
        DWORD dwStyle = GetWindowLong(GWL_STYLE);
        if (dwStyle & (WS_VSCROLL|WS_HSCROLL))
        {
            m_cxWindow += (dwStyle&WS_VSCROLL)?m_cxVScroll:0;
            m_cyWindow += (dwStyle&WS_HSCROLL)?m_cyHScroll:0;
            _UpdatePhysicalSize();
        }

        GetPTSZForBestFit(m_cxImgPix, m_cyImgPix, m_cxImgPhys, m_cyImgPhys, m_ptszDest);

        // this should turn off the scroll bars if they are on
        if (dwStyle & (WS_VSCROLL|WS_HSCROLL))
        {
            SetScrollBars();
        }

        CalcCut();

        // ensure the scroll bars are now off
        ASSERT(0 == (GetWindowLong(GWL_STYLE)&(WS_VSCROLL|WS_HSCROLL)));

        PrepareDraw();
    }
}

// AdjustRectPlacement
//
// This function determines the optimal placement of the destination rectangle.  This may
// include resizing the destination rectangle if it is smaller than the "best fit" rectangle
// but it is primarily intended for repositioning the rectange due to a change in the window
// size or destination rectangle size.  The window is repositioned so that the centered point
// remains in the center of the window.
//
void CZoomWnd::AdjustRectPlacement()
{
    // if we have scroll bars ...
    DWORD dwStyle = GetWindowLong(GWL_STYLE);
    if (dwStyle&(WS_VSCROLL|WS_HSCROLL))
    {
        // .. and if removing scroll bars would allow the image to fit ...
        if ((m_ptszDest.cx < (m_cxWindow + ((dwStyle&WS_VSCROLL)?m_cxVScroll:0))) &&
             (m_ptszDest.cy < (m_cyWindow + ((dwStyle&WS_HSCROLL)?m_cyHScroll:0))))
        {
            // ... remove the scroll bars
            m_cxWindow += (dwStyle&WS_VSCROLL)?m_cxVScroll:0;
            m_cyWindow += (dwStyle&WS_HSCROLL)?m_cyHScroll:0;
            SetScrollBars();
            _UpdatePhysicalSize();
        }
    }

    // If the dest rect is smaller than the window ...
    if ((m_ptszDest.cx < m_cxWindow) && (m_ptszDest.cy < m_cyWindow))
    {
        // ... then it must be larger than the image.  Otherwise we switch
        // to "best fit" mode.
        if ((m_ptszDest.cx < (LONG)m_cxImgPix) && (m_ptszDest.cy < (LONG)m_cyImgPix))
        {
            BestFit();
            return;
        }
    }

    // given the window size, client area size, and dest rect size calculate the 
    // dest rect position.  This position is then restrained by the limits below.
    m_ptszDest.x = (m_cxWindow/2) - MulDiv(m_cxCenter, m_ptszDest.cx, m_cxImgPix);
    m_ptszDest.y = (m_cyWindow/2) - MulDiv(m_cyCenter, m_ptszDest.cy, m_cyImgPix);

    // if the image is now narrower than the window ...
    if (m_ptszDest.cx < m_cxWindow)
    {
        // ... center the image
        m_ptszDest.x = (m_cxWindow-m_ptszDest.cx)/2;
    }
    else
    {
        // if the image is now panned when it shouldn't be, adjust the position
        if (m_ptszDest.x < (m_cxWindow - m_ptszDest.cx))
            m_ptszDest.x = m_cxWindow - m_ptszDest.cx;
        if (m_ptszDest.x > 0)
            m_ptszDest.x = 0;
    }
    // if the image is now shorter than the window ...
    if (m_ptszDest.cy < m_cyWindow)
    {
        // ... center the image
        m_ptszDest.y = (m_cyWindow-m_ptszDest.cy)/2;
    }
    else
    {
        // if the image is now panned when it shouldn't be, adjust the position
        if (m_ptszDest.y < (m_cyWindow - m_ptszDest.cy))
            m_ptszDest.y = m_cyWindow - m_ptszDest.cy;
        if (m_ptszDest.y > 0)
            m_ptszDest.y = 0;
    }

    CalcCut();

    SetScrollBars();
    PrepareDraw();
}

// CalcCut
//
// This function should be called anytime the Destination rectangle changes.
// Based on the destination rectangle it determines what part of the image
// will be visible, ptszCut, and where on the window to place the stretched 
// cut rectangle, ptszBleed.
// 
void CZoomWnd::CalcCut()
{
    if (m_pImageData)
    {
        CalcCut(m_ptszDest, m_cxImage, m_cyImage, m_rcCut, m_rcBleed);
    }
}

void CZoomWnd::CalcCut(PTSZ ptszDest, int cxImage, int cyImage, RECT &rcCut, RECT &rcBleed)
{
    // If the expanded image doesn't occupy the entire window ...
    if ((ptszDest.cy <= m_cyWindow) || (ptszDest.cx <= m_cxWindow))
    {
        // draw the entire destination rectangle
        rcBleed.left   = ptszDest.x;
        rcBleed.top    = ptszDest.y;
        rcBleed.right  = ptszDest.x + ptszDest.cx;
        rcBleed.bottom = ptszDest.y + ptszDest.cy;

        // cut the entire image
        rcCut.left   = 0;
        rcCut.top    = 0;
        rcCut.right  = cxImage;
        rcCut.bottom = cyImage;
    }
    else
    {
        // NOTE: These calculations are written to retain as much
        // precision as possible. Loss of precision will result in
        // undesirable drawing artifacts in the destination window.
        // MulDiv is not used because it rounds the result when we
        // really want the result to be floored. 

        // Given destination rectangle calculate the rectangle 
        // of the original image that will be visible.

        // To do this we need to convert 2 points from window coordinates to image
        // coordinates, those two points are (0,0) and (cxWindow, cyWindow).  The
        // (0,0) point needs to be floored and the (cxWindow, cyWindow) point needs
        // to be ceilinged to handle partially visible pixels.  Since we don't have
        // a good way to do ceiling we just always add one.
        rcCut.left   = LONG(Int32x32To64(-ptszDest.x, cxImage) / ptszDest.cx);
        rcCut.top    = LONG(Int32x32To64(-ptszDest.y, cyImage) / ptszDest.cy);
        rcCut.right  = LONG(Int32x32To64(m_cxWindow-ptszDest.x, cxImage) / ptszDest.cx) + 1;
        rcCut.bottom = LONG(Int32x32To64(m_cyWindow-ptszDest.y, cyImage) / ptszDest.cy) + 1;

        // Make sure the +1 does extend past the image border or GDI+ will choke.
        // If we were doing a TRUE "ceiling" this wouldn't be needed.
        if (rcCut.right  > cxImage) rcCut.right  = cxImage;
        if (rcCut.bottom > cyImage) rcCut.bottom = cyImage;

        // Calculate where on the window to place the cut rectangle.
        // Only a fraction of a zoomed pixel may be visible, hence the bleed factor.
        // Basically we converted from window coordinates to image coordinates to find
        // the Cut rectangle (what we need to draw), now we convert that Cut rectangle
        // back to window coordinates so that we know exactly where we need to draw it.
        rcBleed.left   = ptszDest.x + LONG(Int32x32To64(rcCut.left,   ptszDest.cx) / cxImage);
        rcBleed.top    = ptszDest.y + LONG(Int32x32To64(rcCut.top,    ptszDest.cy) / cyImage);
        rcBleed.right  = ptszDest.x + LONG(Int32x32To64(rcCut.right,  ptszDest.cx) / cxImage);
        rcBleed.bottom = ptszDest.y + LONG(Int32x32To64(rcCut.bottom, ptszDest.cy) / cyImage);
    }
}

void CZoomWnd::GetVisibleImageWindowRect(LPRECT prectImage)
{ 
    CopyRect(prectImage, &m_rcBleed); 
}

void  CZoomWnd::GetImageFromWindow(LPPOINT ppoint, int cSize)
{
    for(int i=0;i<cSize;i++)
    {
        ppoint[i].x -= m_ptszDest.x;
        ppoint[i].y -= m_ptszDest.y;
        ppoint[i].x = MulDiv(ppoint[i].x, m_cxImage, m_ptszDest.cx);
        ppoint[i].y = MulDiv(ppoint[i].y, m_cyImage, m_ptszDest.cy);
    }
}

void CZoomWnd::GetWindowFromImage(LPPOINT ppoint, int cSize)
{
    for(int i=0;i<cSize;i++)
    {
        ppoint[i].x = MulDiv(ppoint[i].x, m_ptszDest.cx, m_cxImage);
        ppoint[i].y = MulDiv(ppoint[i].y, m_ptszDest.cy, m_cyImage);
        ppoint[i].x += m_ptszDest.x;
        ppoint[i].y += m_ptszDest.y;
    }
}

// StatusUpdate
//
// Sent when the image generation status has changed, once when the image is first
// being created and again if there is an error of any kind.
void CZoomWnd::StatusUpdate(int iStatus)
{
    if (m_pImageData)
    {
        m_pImageData->Release();
        m_pImageData = 0;
    }

    if (m_pFront)
    {
        DWORD dwMode;
        m_pPreview->GetMode(&dwMode);
        if (SLIDESHOW_MODE != dwMode)
        {
            DeleteBuffer(m_pFront);
            m_pFront = NULL;
        }
    }
    
    m_iStrID = iStatus;

    // m_cxImage and m_cyImage should be reset to their initial values so that we don't
    // accidentally draw scroll bars or something like that
    m_cxImage = 1;
    m_cyImage = 1;

    // The dest rect should be reset too so that we don't allow some zoom
    // or pan that isn't actually valid.
    m_ptszDest.y = 0;
    m_ptszDest.x = 0;
    m_ptszDest.cx = m_cxWindow;
    m_ptszDest.cy = m_cyWindow;

    SetScrollBars();

    if (m_hWnd)
    {
        PrepareDraw();
    }
}

// SetImageData
//
// Called to pass in the pointer to the IShellImageData we draw.  We hold a reference to this
// object so that we can use it to paint.
//
void CZoomWnd::SetImageData(CDecodeTask * pImageData, BOOL bUpdate)
{
    if (bUpdate)
    {
        m_fTimerReady = TRUE;

        if (m_pFront)
        {
            DWORD dwMode;
            m_pPreview->GetMode(&dwMode);

            if (SLIDESHOW_MODE != dwMode)
            {
                DeleteBuffer(m_pFront);
                m_pFront = NULL;
            }
        }
    }

    if (m_pImageData)
    {
        m_pImageData->Release();
    }

    m_pImageData = pImageData;

    if (m_pImageData)
    {
        m_pImageData->AddRef();

        m_pImageData->ChangePage(m_Annotations);

        SIZE sz;
        ULONG dpiX;
        ULONG dpiY;
        pImageData->GetSize(&sz);
        pImageData->GetResolution(&dpiX, &dpiY);
        if (m_cxImage != sz.cx || m_cyImage != sz.cy || dpiX != m_imgDPIx || dpiY != m_imgDPIy)
        {
            bUpdate = TRUE;
        }

        if (bUpdate)
        {
            // cache the image dimensions to avoid checking m_pImageData against NULL all over the place
            m_cxImage = sz.cx;
            m_cyImage = sz.cy;
            m_imgDPIx = (float)dpiX;
            m_imgDPIy = (float)dpiY;
            m_cxImgPhys = m_cxImage/m_imgDPIx;
            m_cyImgPhys = m_cyImage/m_imgDPIy;
            m_cxImgPix = (int)(m_cxImgPhys*m_winDPIx);
            m_cyImgPix = (int)(m_cyImgPhys*m_winDPIy);
            m_cxCenter = m_cxImgPix/2;
            m_cyCenter = m_cyImgPix/2;             
        }

        if (m_hWnd)
        {
            // REVIEW: should we keep the previous Actual Size/Best Fit setting? 
            if (bUpdate)
            {
                BestFit();
            }
            else
            {
                PrepareDraw();
            }
        }

        return;
    }

    m_iStrID = IDS_LOADFAILED;
}

void CZoomWnd::SetPalette(HPALETTE hpal)
{
    m_hpal = hpal;
}

void CZoomWnd::SetScrollBars()
{
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nMin = 0;
    si.nMax = m_ptszDest.cx;
    si.nPage = m_cxWindow+1;
    si.nPos = 0-m_ptszDest.x;
    si.nTrackPos = 0;

    SetScrollInfo(SB_HORZ, &si, TRUE);

    si.nMax = m_ptszDest.cy;
    si.nPage = m_cyWindow+1;
    si.nPos = 0-m_ptszDest.y;

    SetScrollInfo(SB_VERT, &si, TRUE);
}

LRESULT CZoomWnd::OnScroll(UINT uMsg, WPARAM wParam, LPARAM , BOOL&)
{
    int iScrollBar;
    int iWindow;     // width or height of the window
    LONG * piTL;     // pointer to top or left point
    LONG   iWH;      // the width or height of the dest rect

    if (!m_pImageData)
        return 0;

    // handle both which direction we're scrolling
    if (WM_HSCROLL==uMsg)
    {
        iScrollBar = SB_HORZ;
        iWindow = m_cxWindow;
        piTL = &m_ptszDest.x;
        iWH = m_ptszDest.cx;
    }
    else
    {
        iScrollBar = SB_VERT;
        iWindow = m_cyWindow;
        piTL = &m_ptszDest.y;
        iWH = m_ptszDest.cy;
    }

    // Using the keyboard we can get scroll messages when we don't have scroll bars.
    // Ignore these messages.
    if (iWindow >= iWH)
    {
        // window is larger than the image, don't allow scrolling
        return 0;
    }

    // handle all possible scroll cases
    switch (LOWORD(wParam))
    {
    case SB_TOP:
        *piTL = 0;
        break;
    case SB_PAGEUP:
        *piTL += iWindow;
        break;
    case SB_LINEUP:
        (*piTL)++;
        break;
    case SB_LINEDOWN:
        (*piTL)--;
        break;
    case SB_PAGEDOWN:
        *piTL -= iWindow;
        break;
    case SB_BOTTOM:
        *piTL = iWindow-iWH;
        break;
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        *piTL = -HIWORD(wParam);
        break;
    case SB_ENDSCROLL:
        return 0;
    }

    // apply limits
    if (0 < *piTL)
        *piTL = 0;
    else if ((iWindow-iWH) > *piTL)
        *piTL = iWindow-iWH;

    CalcCut();

    // adjust scrollbars 
    SetScrollPos(iScrollBar, -(*piTL), TRUE);

    // calculate new center point relative to image
    if (WM_HSCROLL==uMsg)
    {
        m_cxCenter = MulDiv((m_cxWindow/2)-m_ptszDest.x, m_cxImage, m_ptszDest.cx);
    }
    else
    {
        m_cyCenter = MulDiv((m_cyWindow/2)-m_ptszDest.y, m_cyImage, m_ptszDest.cy);
    }

    PrepareDraw();
    return 0;
}

// OnWheelTurn
//
// Respondes to WM_MOUSEWHEEL messages sent to the parent window (then redirected here)

LRESULT CZoomWnd::OnWheelTurn(UINT , WPARAM wParam, LPARAM , BOOL&)
{
    BOOL bZoomIn = ((short)HIWORD(wParam) > 0);

    bZoomIn?ZoomIn():ZoomOut();

    return TRUE;
}

LRESULT CZoomWnd::OnSetFocus(UINT , WPARAM , LPARAM , BOOL&)
{
    HWND hwndParent = GetParent();
    ::SetFocus(hwndParent);
    return 0;
}

void CZoomWnd::CommitAnnotations()
{ 
    if (m_pImageData)
    {
        IShellImageData * pSID;
        if (SUCCEEDED(m_pImageData->Lock(&pSID)))
        {
            m_Annotations.CommitAnnotations(pSID);
            m_pImageData->Unlock();
        }
    }
}

BOOL CZoomWnd::ScrollBarsPresent()
{
    SCROLLINFO si = {0};
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    if ((GetScrollInfo(SB_HORZ, &si) && si.nPos) || (GetScrollInfo(SB_VERT, &si) && si.nPos) )
    {
        return TRUE;
    }
    return FALSE;
}

void CZoomWnd::_UpdatePhysicalSize()
{
    m_cxWinPhys = (float)(m_cxWindow)/m_winDPIx;
    m_cyWinPhys = (float)(m_cyWindow)/m_winDPIy;
}

LRESULT CZoomWnd::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    FlushDrawMessages();
    
    if (m_pFront)
    {
        DeleteBuffer(m_pFront);
        m_pFront = NULL;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\sccreate.cpp ===
#include "shole.h"
#include "ids.h"

#include <strsafe.h>

#ifdef SAVE_OBJECTDESCRIPTOR
extern "C" const WCHAR c_wszDescriptor[] = WSTR_SCRAPITEM L"ODS";

HRESULT Scrap_SaveODToStream(IStorage *pstgDoc, OBJECTDESCRIPTOR * pods)
{
    //
    // According to Anthony Kitowicz, we must clear this flag.
    //
    pods->dwStatus &= ~OLEMISC_CANLINKBYOLE1;

    IStream *pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszDescriptor, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if (SUCCEEDED(hres))
    {
        ULONG cbWritten;
        hres = pstm->Write(pods, pods->cbSize, &cbWritten);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD descriptor written (%x, %d, %d)"),
                 hres, pods->cbSize, cbWritten);
        pstm->Release();

        if (FAILED(hres) || cbWritten<pods->cbSize) {
            pstgDoc->DestroyElement(c_wszDescriptor);
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD pstg->CreateStream failed (%x)"), hres);
    }

    return hres;
}

HRESULT Scrap_SaveObjectDescriptor(IStorage *pstgDoc, IDataObject *pdtobj, IPersistStorage *pps, BOOL fLink)
{
    STGMEDIUM medium;
    FORMATETC fmte = {fLink ? CF_LINKSRCDESCRIPTOR : CF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_SOD found CF_OBJECTDESCRIPTOR (%x)"), medium.hGlobal);
        LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
        if (pods)
        {
            hres = Scrap_SaveODToStream(pstgDoc, pods);
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }

    return hres;
}
#else
#define Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, fLink) (0)
#endif // SAVE_OBJECTDESCRIPTOR

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szCLSID[] = TEXT("CLSID");

//
//  This function opens the HKEY for the specified CLSID or its sub-key.
//
// Parameters:
//  rclsid    -- Specifies the CLSID
//  pszSubKey -- Specifies the subkey name, may be NULL
//
// Returns:
//  non-NULL, if succeeded; the caller must RegCloseKey it.
//  NULL, if failed.
//
HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey)
{
    WCHAR szCLSID[256];
    if (StringFromGUID2(rclsid, szCLSID, ARRAYSIZE(szCLSID)))
    {
        HRESULT hr = S_OK;
        TCHAR szKey[256];
        if (pszSubKey) 
        {
            hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%s\\%s"), c_szCLSID, szCLSID, pszSubKey);
        }
        else 
        {
            hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%s"), c_szCLSID, szCLSID);
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - _OpelCLSIDKey RegOpenKey(%s)"), szKey);

        if (SUCCEEDED(hr))
        {
            HKEY hkey;
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey))
            {
                return hkey;
            }
        }
    }
    return NULL;
}

extern "C" const WCHAR c_wszFormatNames[] = WSTR_SCRAPITEM L"FMT";
#define CCH_FORMATNAMES (ARRAYSIZE(c_wszFormatNames)-1)

//
//  This function generates the stream name (UNICODE) for the spcified
// clipboard format.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  wszStreamName -- Specifies the UNICODE buffer.
//  cchmax -- Specifies the size of buffer.
//
HRESULT _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax)
{
    CopyMemory(wszStreamName, c_wszFormatNames, min(cchMax * sizeof(WCHAR), sizeof(c_wszFormatNames)));
    return StringCchCopy(wszStreamName + CCH_FORMATNAMES, max(cchMax - CCH_FORMATNAMES, 0), pszFormat);
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR _GetCacheStreamName returning %s"), wszStreamName);
#endif
}

HRESULT Scrap_CacheOnePictureFormat(LPCTSTR pszFormat, FORMATETC * pfmte, STGMEDIUM * pmedium, REFCLSID rclsid, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    LPPERSISTSTORAGE ppstg;
    HRESULT hres = OleCreateDefaultHandler(rclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
    DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
    if (SUCCEEDED(hres))
    {
        //
        // Generate the stream name based on the clipboard format name.
        //
        WCHAR wszStorageName[256];
        hres = _GetCacheStreamName(pszFormat, wszStorageName, ARRAYSIZE(wszStorageName));

        if (SUCCEEDED(hres))
        {
            LPSTORAGE pstgPicture;
            hres = pstgDoc->CreateStorage(wszStorageName, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                        0, 0, &pstgPicture);
            if (SUCCEEDED(hres))
            {
                ppstg->InitNew(pstgPicture);

                LPOLECACHE pcache;
                hres = ppstg->QueryInterface(IID_IOleCache, (LPVOID*)&pcache);
                DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF QI returned %x"), hres);
                if (SUCCEEDED(hres))
                {
                    hres = pcache->Cache(pfmte, ADVF_PRIMEFIRST, NULL);
                    DebugMsg(DM_TRACE, TEXT("sc TR pcache->Cache returned %x"), hres);
                    hres = pcache->SetData(pfmte, pmedium, FALSE);
                    DebugMsg(DM_TRACE, TEXT("sc TR pcache->SetData returned %x"), hres);
                    pcache->Release();

                    if (SUCCEEDED(hres))
                    {
                        hres = OleSave(ppstg, pstgPicture, TRUE);
                        DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat OleSave returned (%x)"), hres);
                        ppstg->HandsOffStorage();

                        if (SUCCEEDED(hres))
                        {
                            hres = pstgPicture->Commit(STGC_OVERWRITE);
                            DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOnePictureFormat Commit() returned (%x)"), hres);
                        }
                    }
                }

                pstgPicture->Release();

                if (FAILED(hres))
                {
                    pstgDoc->DestroyElement(wszStorageName);
                }
            }
        }

        ppstg->Release();
    }

    return hres;
}

//
//  This function stores the specified format of clipboard data.
//
// Parameters:
//  pszFormat -- Specifies the clipboard format ("#0"-"#15" for predefined ones)
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj -- Sepcified the data object we should get the data from.
//
HRESULT Scrap_CacheOneFormat(LPCTSTR pszFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj)
{
    UINT cf = RegisterClipboardFormat(pszFormat);
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    const CLSID * pclsid = NULL;
    switch(cf)
    {
    case CF_METAFILEPICT:
        pclsid = &CLSID_Picture_Metafile;
        fmte.tymed = TYMED_MFPICT;
        break;

    case CF_ENHMETAFILE:
        pclsid = &CLSID_Picture_EnhMetafile;
        fmte.tymed = TYMED_ENHMF;
        break;

    case CF_PALETTE:
    case CF_BITMAP:
        pclsid = &CLSID_Picture_Dib;
        fmte.tymed = TYMED_GDI;
        break;
    }

    //
    // Get the specified format of data (TYMED_GLOBAL only)
    //
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        if (medium.tymed != TYMED_HGLOBAL)
        {
            hres = Scrap_CacheOnePictureFormat(pszFormat, &fmte, &medium, *pclsid, pstgDoc, pdtobj);
        }
        else
        {
            //
            // Global lock the data.
            //
            UINT cbData = (UINT)GlobalSize(medium.hGlobal);
            const BYTE * pbData = (const BYTE*)GlobalLock(medium.hGlobal);
            if (pbData)
            {
                //
                // Generate the stream name based on the clipboard format name.
                //
                WCHAR wszStreamName[256];
                hres = _GetCacheStreamName(pszFormat, wszStreamName, ARRAYSIZE(wszStreamName));
                if (SUCCEEDED(hres))
                {
                    //
                    // Create the stream.
                    //
                    LPSTREAM pstm;
                    hres = pstgDoc->CreateStream(wszStreamName, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
                    if (SUCCEEDED(hres))
                    {
                        //
                        // Save the size of data.
                        //
                        ULONG cbWritten;
                        hres = pstm->Write(&cbData, SIZEOF(cbData), &cbWritten);
                        if (SUCCEEDED(hres) && cbWritten==SIZEOF(cbData))
                        {
                            //
                            // Save the data itself.
                            //
                            hres = pstm->Write(pbData, cbData, &cbWritten);
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_Save %s written (%x, %d, %d)"),
                                pszFormat, hres, cbData, cbWritten);
                        }
                        pstm->Release();

                        //
                        // If anything goes wrong, destroy the stream.
                        //
                        if (FAILED(hres) || cbWritten<cbData)
                        {
                            pstgDoc->DestroyElement(wszStreamName);
                            hres = E_FAIL;
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
            else
            {
                hres = E_FAIL;
            }
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheOneFormat IDO::GetData(cf=%x,tm=%x) failed (%x)"),
                 fmte.cfFormat, fmte.tymed, hres);
    }

    return hres;
}

//
//  This function caches the specified format of data if the data object
// support that format.
//
// Parameters:
//  szFormat -- Specifies the format to be cahced
//  pstgDoc  -- Specifies the top level IStorage
//  pdtobj   -- Specifies the data object from where we get data
//  pstm     -- Specifies the stream we should write cached format name.
//
// Returns:
//  TRUE if the data object support it.
//
BOOL Scrap_MayCacheOneFormat(LPCTSTR szFormat, LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPSTREAM pstm)
{
    //
    // Try to cache the format.
    //
    HRESULT hres = Scrap_CacheOneFormat(szFormat, pstgDoc, pdtobj);
    if (SUCCEEDED(hres))
    {
        //
        //  Store the name of format only if we actually
        // succeeded to cache the data.
        //
        CHAR szAnsiFormat[128];
        WideCharToMultiByte(CP_ACP, 0,
                            szFormat, -1,
                            szAnsiFormat, ARRAYSIZE(szAnsiFormat),
                            NULL, NULL );
        USHORT cb = (USHORT)lstrlenA(szAnsiFormat);
        pstm->Write(&cb, SIZEOF(cb), NULL);
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_MayCacheOneFormat writing %s, %d"), szFormat, cb);
        pstm->Write(szAnsiFormat, cb, NULL);

        return TRUE;
    }

    return FALSE;
}

//
// Returns:
//  TRUE, if the specified format is already cached (from Global list).
//
BOOL Scrap_IsAlreadyCached(UINT acf[], UINT ccf, LPCTSTR szFormat)
{
    if (ccf)
    {
        UINT cf = RegisterClipboardFormat(szFormat);
        for (UINT icf=0; icf<ccf; icf++) {
            if (acf[icf]==cf) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

extern "C" const TCHAR c_szCacheFMT[] = TEXT("DataFormats\\PriorityCacheFormats");
#define REGSTR_PATH_SCRAP TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellScrap")
extern "C" const TCHAR c_szGlobalCachedFormats[] = REGSTR_PATH_SCRAP TEXT("\\PriorityCacheFormats");

//
//  This function enumerate the list of to-be-cached clipboard data and
// calls Scrap_CacheOneFormat for each of them.
//
// Parameters:
//  pstgDoc -- Specifies the top level IStorage.
//  pdtobj  -- Specifies the data object we'll get the data from.
//  pps     -- Specifies the "embedded object" (to get CLSID from)
//
void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps)
{
    //
    //  Create the stream where we'll store the list of actually
    // cached formats, which might be just a subset of to-be-cached
    // format specified in the registry.
    //
    LPSTREAM pstm;
    HRESULT hres = pstgDoc->CreateStream(c_wszFormatNames, STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);

    DebugMsg(DM_TRACE, TEXT("sc TR S_CCD CreateStream returned %x"), hres);

    if (SUCCEEDED(hres))
    {
        USHORT cb;
        HKEY hkey;
        TCHAR szFormatName[128];
        DWORD cchValueName;
        DWORD dwType;
        UINT  acf[CCF_CACHE_GLOBAL];
        UINT  ccf = 0;

        //
        // First, try the formats in the global list.
        //
        if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szGlobalCachedFormats, &hkey) == ERROR_SUCCESS)
        {
            //
            // For each global to-be-cached format...
            //
            for(int iValue=0; iValue<CCF_CACHE_GLOBAL ;iValue++)
            {
                //
                //  Get the value name of the iValue'th value. The value
                // name specifies the clipboard format.
                // ("#0"-"#15" for predefined formats).
                //
                cchValueName = ARRAYSIZE(szFormatName);
                if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                 &dwType, NULL, NULL)==ERROR_SUCCESS)
                {
                    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (Global)"), szFormatName, dwType);
                    if (Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm))
                    {
                        acf[ccf++] = RegisterClipboardFormat(szFormatName);
                    }
                }
                else
                {
                    break;
                }
            }

            RegCloseKey(hkey);
        }

        //
        // Then, try the CLSID specific formats.
        //
        // Get the CLSID of the "embedded object" (the body of scrap)
        //
        CLSID clsid;
        hres = pps->GetClassID(&clsid);
        if (SUCCEEDED(hres))
        {
            //
            // Open the key for the list of to-be-cached formats.
            //
            hkey = _OpenCLSIDKey(clsid, c_szCacheFMT);
            if (hkey)
            {
                //
                // For each class specific to-be-cached format...
                //
                for(int iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    //
                    //  Get the value name of the iValue'th value. The value
                    // name specifies the clipboard format.
                    // ("#0"-"#15" for predefined formats).
                    //
                    cchValueName = ARRAYSIZE(szFormatName);

                    if (RegEnumValue(hkey, iValue, szFormatName, &cchValueName, NULL,
                                     &dwType, NULL, NULL)==ERROR_SUCCESS)
                    {
                        if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                            Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                        }
                        else
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                //
                // HACK: NT 3.5's RegEdit does not support named values...
                //
                for(iValue=0; iValue<CCF_CACHE_CLSID ;iValue++)
                {
                    TCHAR szKeyName[128];
                    if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                    {
                        LONG cbValue = ARRAYSIZE(szFormatName);
                        if ((RegQueryValue(hkey, szKeyName, szFormatName, &cbValue)==ERROR_SUCCESS) && cbValue)
                        {
                            if (!Scrap_IsAlreadyCached(acf, ccf, szFormatName))
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData found with %s, %x (CLSID specific)"), szFormatName, dwType);
                                Scrap_MayCacheOneFormat(szFormatName, pstgDoc, pdtobj, pstm);
                            }
                            else
                            {
                                DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CacheClipboardData skipping %s (already cached)"), szFormatName);
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                RegCloseKey(hkey);
            }
        }

        //
        // Put the terminator.
        //
        cb = 0;
        pstm->Write(&cb, SIZEOF(cb), NULL);
        pstm->Release();

    }

}
#endif // FIX_ROUNDTRIP

// out:
//      pszName - short name for object type ("Worksheet", "Word Document", etc)
//
// returns:
//

HRESULT Scrap_Save(IStorage *pstg, IStorage *pstgDoc, IDataObject *pdtobj, BOOL fLink, LPTSTR pszName)
{
    IPersistStorage *pps;
    HRESULT hres;

    if (fLink)
    {
        FORMATETC fmte = {CF_METAFILEPICT, NULL, DVASPECT_ICON, -1, TYMED_MFPICT};
        hres = OleCreateLinkFromData(pdtobj, IID_IPersistStorage, OLERENDER_FORMAT,
                                     &fmte, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateLinkFromData(FMT) returned (%x)"), hres);
    }
    else
    {
        hres = OleCreateFromData(pdtobj, IID_IPersistStorage, OLERENDER_DRAW,
                                 NULL, NULL, pstg, (LPVOID*)&pps);
        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleCreateFromData(FMT) returned (%x)"), hres);
    }

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);        // fSameStorage=TRUE

        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save OleSave returned (%x)"), hres);

        if (SUCCEEDED(hres) && pszName)
        {
            LPOLEOBJECT pole;
            if (SUCCEEDED(pps->QueryInterface(IID_IOleObject, (LPVOID*)&pole)))
            {
                IMalloc *pmem;
                if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &pmem)))
                {
                    LPWSTR pwsz;
                    if (SUCCEEDED(pole->GetUserType(USERCLASSTYPE_SHORT, &pwsz)))
                    {
                        hres = StringCchCopy(pszName, 64, pwsz);    // What is 64?

                        DebugMsg(DM_TRACE, TEXT("sc Scrap_Save short name (%s)"), pszName);

                        // Assert(lstrlen(pszName) < 15); // USERCLASSTYPE_SHORT docs say so
                        pmem->Free(pwsz);
                    }
                    pmem->Release();
                }
                pole->Release();
            }
        }

        // This is no-op if SAVE_OBJECTDESCRIPTOR is not defined.
        Scrap_SaveObjectDescriptor(pstgDoc, pdtobj, pps, fLink);

#ifdef FIX_ROUNDTRIP
        if (!fLink)
        {
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
        }
#endif // FIX_ROUNDTRIP

        hres = pps->HandsOffStorage();

        pps->Release();
    }

    return hres;

}

//
//  We have ANSI text but no UNICODE Text.  Look for RTF in order to
//  see if we can find a language id so that we can use the correct
//  code page for the Ansi to Unicode translation.
//
UINT Scrap_SniffCodePage(IDataObject *pdtobj)
{
    UINT CodePage = CP_ACP;
    FORMATETC fmte = { CF_RTF, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL | TYMED_ISTREAM };
    STGMEDIUM medium;

    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        CHAR szBuf[MAX_PATH * 8] = { 0 };
        LPSTR pszRTF = NULL;

        if (medium.tymed == TYMED_ISTREAM)
        {
            // Read one less byte to ensure proper null termination
            if (SUCCEEDED(medium.pstm->Read((LPVOID)szBuf, sizeof(szBuf) - 1, NULL)))
            {
                pszRTF = szBuf;
            }
        }
        else
        {
            pszRTF = (LPSTR)GlobalLock(medium.hGlobal);
        }

        if (pszRTF)
        {
            LPSTR pTmp;

            //
            //  Find the language id used for this text.
            //
            //  Ugly way to search, but can't use c-runtimes in the
            //  shell.
            //
            CHAR szLang[5];
            UINT LangID = 0;

            pTmp = pszRTF;
            while (*pTmp)
            {
                if ((*pTmp == '\\') &&
                    *(pTmp + 1)    && (*(pTmp + 1) == 'l') &&
                    *(pTmp + 2)    && (*(pTmp + 2) == 'a') &&
                    *(pTmp + 3)    && (*(pTmp + 3) == 'n') &&
                    *(pTmp + 4)    && (*(pTmp + 4) == 'g'))
                {
                    //
                    //  Get number following the \lang identifier.
                    //
                    int ctr;

                    pTmp += 5;
                    for (ctr = 0;
                         (ctr < 4) && (*(pTmp + ctr)) &&
                         ((*(pTmp + ctr)) >= '0') && ((*(pTmp + ctr)) <= '9');
                         ctr++)
                    {
                        szLang[ctr] = *(pTmp + ctr);
                    }
                    szLang[ctr] = 0;

                    for (pTmp = szLang; *pTmp; pTmp++)
                    {
                        LangID *= 10;
                        LangID += (*pTmp - '0');
                    }

                    break;
                }
                pTmp++;
            }
            if (LangID)
            {
                if (!GetLocaleInfo( LangID,
                                    LOCALE_IDEFAULTANSICODEPAGE |
                                      LOCALE_RETURN_NUMBER,
                                    (LPTSTR)&CodePage,
                                    sizeof(UINT) / sizeof(TCHAR) ))
                {
                    CodePage = CP_ACP;
                }
            }

            if (medium.tymed == TYMED_HGLOBAL)
            {
                GlobalUnlock(medium.hGlobal);
            }
        }
        ReleaseStgMedium(&medium);
    }

    return CodePage;
}

// get some text from the data object
//
// out:
//      pszOut  filled in with text
//

HRESULT Scrap_GetText(IDataObject *pdtobj, LPTSTR pszOut, UINT cchMax)
{
    ASSERT(cchMax > 1);

    UINT cbMac = (cchMax-1)*SIZEOF(pszOut[0]);
    ZeroMemory(pszOut, cchMax * SIZEOF(pszOut[0]));

    STGMEDIUM medium;
    HRESULT hres;
    FORMATETC fmte = { CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|TYMED_HGLOBAL };
    hres = pdtobj->QueryGetData( &fmte );
    if (hres != S_OK)           // S_FALSE means no.
    {
        fmte.cfFormat = CF_TEXT;
    }
    hres = pdtobj->GetData(&fmte, &medium);

    if (SUCCEEDED(hres))
    {
        DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in %d"), medium.tymed);
        if (medium.tymed == TYMED_ISTREAM)
        {
            if (fmte.cfFormat == CF_TEXT)
            {
                // Stream is ansi but we are unicode - yuck
                LPSTR pAnsi = (LPSTR)LocalAlloc(LPTR, cchMax * sizeof(CHAR));
                if (pAnsi)
                {
                    // Read one short so we are guaranteed a null terminator
                    hres = medium.pstm->Read(pAnsi, cchMax - 1, NULL);
                    if (SUCCEEDED(hres)) {
                        SHAnsiToUnicodeCP(Scrap_SniffCodePage(pdtobj), pAnsi, pszOut, cchMax);
                    }
                    LocalFree(pAnsi);
                }
                else
                    hres = E_OUTOFMEMORY;
            }
            else
                hres = medium.pstm->Read(pszOut, cbMac, NULL);
        }
        else if (medium.tymed == TYMED_HGLOBAL)
        {
            DebugMsg(DM_TRACE, TEXT("sh TR - Scrap_GetText found CF_TEXT/CF_UNICODETEXT in global"));
            LPTSTR pszSrc = (LPTSTR)GlobalLock(medium.hGlobal);
            if (pszSrc)
            {
                if ( fmte.cfFormat == CF_TEXT )
                {
                    SHAnsiToUnicodeCP(Scrap_SniffCodePage(pdtobj), (LPSTR)pszSrc, pszOut, cchMax);
                }
                else
                {
                    hres = StringCchCopy(pszOut, cchMax, pszSrc);
                }
                GlobalUnlock(medium.hGlobal);
            }
        }
        ReleaseStgMedium(&medium);
    }

    return hres;
}


// Avoid linking lots of CRuntime stuff.
#undef isdigit
#undef isalpha
#define isdigit(ch) (ch>=TEXT('0') && ch<=TEXT('9'))
#define isalpha(ch) ((ch&0xdf)>=TEXT('A') && (ch&0xdf)<=TEXT('Z'))

#define CCH_MAXLEADINGSPACE     256
#define CCH_COPY                16

//
// create a fancy name for a scrap/doc shortcut given the data object to get some
// text from
//
// out:
//      pszNewName      - assumed to be 64 chars at least
//

BOOL Scrap_GetFancyName(IDataObject *pdtobj, UINT idTemplate, LPCTSTR pszPath, LPCTSTR pszTypeName, LPTSTR pszNewName, int cchNewName)
{
    TCHAR szText[CCH_MAXLEADINGSPACE + CCH_COPY + 1];
    HRESULT hres = Scrap_GetText(pdtobj, szText, ARRAYSIZE(szText));

    if (SUCCEEDED(hres))
    {
#ifdef UNICODE
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_UNICODETEXT has (%s)"), szText);
#else
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName CF_TEXT has (%s)"), szText);
#endif
        LPTSTR pszStart;
        //
        // skip leading space/non-printing characters
        //
        for (pszStart = szText; (TBYTE)*pszStart <= TEXT(' '); pszStart++)
        {
            if (*pszStart == TEXT('\0'))
                return FALSE;   // empty string

            if (pszStart - szText >= CCH_MAXLEADINGSPACE)
                return FALSE;   // too many leading space
        }
        DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName pszStart (%s)"), pszStart);

        //
        // Chacter conversion
        //  (1) non-printing characters -> ' '
        //  (2) invalid characters -> '_'
        //
        for (LPTSTR pszT = pszStart; *pszT && ((pszT-pszStart) < CCH_COPY); pszT = CharNext(pszT))
        {
            TBYTE ch = (TBYTE)*pszT;
            if (ch <= TEXT(' '))
            {
                *pszT = TEXT(' ');
            }
            else if (ch < 127 && !isdigit(ch) && !isalpha(ch))
            {
                switch(ch)
                {
                case TEXT('$'):
                case TEXT('%'):
                case TEXT('\''):
                case TEXT('-'):
                case TEXT('_'):
                case TEXT('@'):
                case TEXT('~'):
                case TEXT('`'):
                case TEXT('!'):
                case TEXT('('):
                case TEXT(')'):
                case TEXT('{'):
                case TEXT('}'):
                case TEXT('^'):
                case TEXT('#'):
                case TEXT('&'):
                    break;

                default:
                    *pszT = TEXT('_');
                    break;
                }
            }
        }
        *pszT = 0;

        TCHAR szTemplate[MAX_PATH];
        TCHAR szName[MAX_PATH];

        LoadString(HINST_THISDLL, idTemplate, szTemplate, ARRAYSIZE(szTemplate));
        hres = StringCchPrintf(szName, ARRAYSIZE(szName), szTemplate, pszTypeName, pszStart);

        if (SUCCEEDED(hres) && PathYetAnotherMakeUniqueName(szName, pszPath, szName, szName))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_GetFancyName (%s)"), szName);
            hres = StringCchCopy(pszNewName, cchNewName, szName);
            return SUCCEEDED(hres);
        }
    }
    return FALSE;
}

// *** WARNING ***
//
// Scrap_CreateFromDataObject is a TCHAR export from SHSCRAP.DLL that is used by SHELL32.DLL. If you
// change its calling convention, you must modify shell32's wrapper as well as well.
//
// *** WARNING ***
HRESULT WINAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, IDataObject *pdtobj, BOOL fLink, LPTSTR pszNewFile)
{
    HRESULT hres;
    TCHAR szTemplateS[32];
    TCHAR szTemplateL[128];
    TCHAR szTypeName[64];
    IStorage *pstg;
    UINT idErr = 0;

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject called at %s"), pszPath);

    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_S : IDS_SCRAP_S, szTemplateS, ARRAYSIZE(szTemplateS));
    LoadString(HINST_THISDLL, fLink ? IDS_BOOKMARK_L : IDS_SCRAP_L, szTemplateL, ARRAYSIZE(szTemplateL));

    PathYetAnotherMakeUniqueName(pszNewFile, pszPath, szTemplateS, szTemplateL);

    DebugMsg(DM_TRACE, TEXT("sc TR - Scrap_CreateFromDataObject creating %s"), pszNewFile);

    hres = StgCreateDocfile(pszNewFile,
                    STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, &pstg);

    if (SUCCEEDED(hres))
    {
        IStorage *pstgContents;

        hres = pstg->CreateStorage(c_wszContents, STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                    0, 0, &pstgContents);

        if (SUCCEEDED(hres))
        {
            hres = Scrap_Save(pstgContents, pstg, pdtobj, fLink, szTypeName);
            if (SUCCEEDED(hres))
            {
                hres = pstgContents->Commit(STGC_OVERWRITE);
                if (FAILED(hres))
                    idErr = IDS_ERR_COMMIT;
            }
            else
            {
                idErr = IDS_ERR_SCRAPSAVE;
            }
            pstgContents->Release();
        }
        else
        {
            idErr = IDS_ERR_CREATESTORAGE;
        }

        //
        // We need to delete the file, if failed to save/commit.
        //
        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            if (FAILED(hres))
                idErr = IDS_ERR_COMMIT;
        }

        pstg->Release();

        if (FAILED(hres))
            DeleteFile(pszNewFile);
    }
    else
    {
        idErr = IDS_ERR_CREATEDOCFILE;
    }

    if (SUCCEEDED(hres))
    {
        if (IsLFNDrive(pszPath))
        {
            TCHAR szFancyName[MAX_PATH];

            if (Scrap_GetFancyName(pdtobj, fLink ? IDS_TEMPLINK : IDS_TEMPSCRAP, pszPath, szTypeName, szFancyName, ARRAYSIZE(szFancyName)))
            {
                if (MoveFile(pszNewFile, szFancyName))
                {
                    hres = StringCchCopy(pszNewFile, MAX_PATH, szFancyName);
                }
            }
        }
    }
    else
    {
        DisplayError((HWND)NULL, hres, idErr, pszNewFile);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\sccls.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"
#define DECL_CRTFREE
#include <crtfree.h>

LONG g_cRefThisDll = 0;         // per-instance

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

class CMyClassFactory : public IClassFactory
{
public:
    CMyClassFactory(REFCLSID rclsid);
    ~CMyClassFactory() { DllRelease(); }

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG __stdcall AddRef(void);
    virtual ULONG __stdcall Release(void);

    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(
            IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual HRESULT __stdcall LockServer(BOOL fLock);

protected:
    UINT   _cRef;
    CLSID  _clsid;
};

CMyClassFactory::CMyClassFactory(REFCLSID rclsid) : _cRef(1), _clsid(rclsid)
{
    DllAddRef();
}

HRESULT CMyClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IClassFactory) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPCLASSFACTORY)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }

    return hres;
}

ULONG CMyClassFactory::AddRef(void)
{
    return ++_cRef;
}

ULONG CMyClassFactory::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}

HRESULT CMyClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    LPUNKNOWN punk;
    HRESULT hres;
    if (IsEqualGUID(_clsid, CLSID_CScrapData))
    {
        hres = CScrapData_CreateInstance(&punk);
    }
#ifdef FEATURE_SHELLEXTENSION
    else if (IsEqualGUID(_clsid, CLSID_CTemplateFolder))
    {
	hres = CTemplateFolder_CreateInstance(&punk);
    }
    else if (IsEqualGUID(_clsid, CLSID_CScrapExt))
    {
	hres = CScrapExt_CreateInstance(&punk);
    }
#endif
    else
    {
        return E_UNEXPECTED;
    }

    if (SUCCEEDED(hres))
    {
        hres = punk->QueryInterface(riid, ppvObject);
        punk->Release();
    }
    return hres;
}

HRESULT CMyClassFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualGUID(rclsid,CLSID_CScrapData)
#ifdef FEATURE_SHELLEXTENSION
	|| IsEqualGUID(rclsid,CLSID_CTemplateFolder)
	|| IsEqualGUID(rclsid,CLSID_CScrapExt)
#endif
	)
    {
        CMyClassFactory *pmycls = new CMyClassFactory(rclsid);
        if (pmycls)
        {
            HRESULT hres = pmycls->QueryInterface(riid, ppvOut);
            pmycls->Release();
            return hres;
        }
        return E_OUTOFMEMORY;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_cRefThisDll)
    {
        return S_FALSE;
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - DllCanUnloadNow returning S_OK (bye, bye...)"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\scguid.h ===
// for .reg file 56117100-C0CD-101B-81E2-00AA004AE837
DEFINE_GUID(CLSID_CScrapData, 0x56117100L, 0xC0CD, 0x101B, 0x81, 0xE2, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#ifdef FEATURE_SHELLEXTENSION

// for C6EDCDC0-8F67-11CE-A9BA-00AA004AE837
DEFINE_GUID(CLSID_CTemplateFolder, 0xC6EDCDC0L, 0x8F67, 0x11CE, 0xA9, 0xBA, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// for 6FF4A4E0-DBC4-11CE-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CScrapExt, 0x6FF4A4E0L, 0xDBC4, 0x11CE, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

#endif

// 54BC7DC0-DC95-11CE-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CShClientSite, 0x54BC7DC0L, 0xDC95, 0x11CE, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\shole.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

#include <strsafe.h>

#define CLONE_IT_IF_READONLY

class CShClientSite : public IOleClientSite, public IAdviseSink2
{
public:
    CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine);
    LPCTSTR  ParseCmdLine(LPCTSTR pszCmdLine);
    HRESULT Load();
    HRESULT DoVerb(LONG iVerb);
    void    CloseOleObject();
    void    ReleaseOleObject();
    void    ReleaseStorage(void);
    void    MaySaveAs(void);
    void    Draw(HWND hwnd, HDC hdc);
    HRESULT GetFileName(LPTSTR szFile, UINT cchMax);
    void    Quit(void) { _hwndOwner = NULL ; _fQuit = TRUE; }
    BOOL    FContinue(void) { return !_fQuit; }

    // IUnKnown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID,void **);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // IOleClientSite
    virtual HRESULT STDMETHODCALLTYPE SaveObject(void);
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, IMoniker **);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(IOleContainer **);
    virtual HRESULT STDMETHODCALLTYPE ShowObject(void);
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout(void);

    // IAdviseSink2
    virtual void STDMETHODCALLTYPE OnDataChange(FORMATETC *,STGMEDIUM *);
    virtual void STDMETHODCALLTYPE OnViewChange(DWORD dwAspect,LONG lindex);
    virtual void STDMETHODCALLTYPE OnRename(IMoniker *pmk);
    virtual void STDMETHODCALLTYPE OnSave(void);
    virtual void STDMETHODCALLTYPE OnClose(void);
    virtual void STDMETHODCALLTYPE OnLinkSrcChange(IMoniker *pmk);

protected:
    ~CShClientSite();

    UINT                _cRef;
    HWND                _hwndOwner;
    LPSTORAGE           _pstgDoc;       // document
    LPSTORAGE           _pstg;          // the embedding (only one)
    LPPERSISTSTORAGE    _ppstg;
    LPOLEOBJECT         _pole;
    BOOL                _fDirty:1;
    BOOL                _fNeedToSave:1;
    BOOL                _fReadOnly:1;
    BOOL                _fCloned:1;
    BOOL                _fQuit:1;
    BOOL                _fCloseImmediately:1;
    DWORD               _dwConnection;  // non-zero, if valid
    WCHAR               _wszFileName[MAX_PATH];
};
typedef CShClientSite * LPSHCLIENTSITE;

const TCHAR c_szAppName[] = TEXT("ShellOleViewer");
LRESULT CALLBACK ShWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);

HINSTANCE g_hinst = NULL;

extern "C"
BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hinst = (HINSTANCE)hDll;
        DisableThreadLibraryCalls(g_hinst);
        break;

    default:
        break;
    }

    return TRUE;
}

void WINAPI
OpenScrap_RunDLL_Common(HWND hwndStub, HINSTANCE hInstApp, LPTSTR pszCmdLine, int nCmdShow)
{

    CShClientSite_RegisterClass();

    HWND hwndClientSite = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_OVERLAPPEDWINDOW,
                                   c_szAppName,
#ifdef DEBUG
                                   TEXT("(Debug only) SHOLE.EXE"),
                                   WS_VISIBLE | WS_OVERLAPPEDWINDOW,
#else
                                   TEXT(""),
                                   WS_OVERLAPPEDWINDOW,
#endif
                                   CW_USEDEFAULT, CW_USEDEFAULT,
                                   128, 128, NULL, NULL, g_hinst, NULL);
    if (hwndClientSite)
    {
        HRESULT hres;

        hres = OleInitialize(NULL);
        if (SUCCEEDED(hres))
        {
            DWORD dwTick;
            LPSHCLIENTSITE pscs= new CShClientSite(hwndClientSite, pszCmdLine);

            if (pscs)
            {
                UINT cRef;

        hres = pscs->Load();
        if (SUCCEEDED(hres)) {
            hres = pscs->DoVerb(OLEIVERB_OPEN);
        }

                if (hres == S_OK)
                {
                    MSG msg;
                    while (pscs->FContinue() && GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
                else
                {
                    // DoVerb failed.

                    if (FAILED(hres) || (hres>=IDS_HRES_MIN && hres<IDS_HRES_MAX))
                    {
                        TCHAR szFile[MAX_PATH];
                        HRESULT hrInner = pscs->GetFileName(szFile, ARRAYSIZE(szFile));
                        if (SUCCEEDED(hrInner))
                        {
                            DisplayError(hwndClientSite, hres, IDS_ERR_DOVERB, szFile);
                        }
                    }
                    DestroyWindow(hwndClientSite);
                }

                //
                //  We call them just in case, the following Release
                // does not release the object.
                //
                pscs->ReleaseOleObject();
                pscs->ReleaseStorage();
                pscs->MaySaveAs();

                cRef = pscs->Release();
                Assert(cRef==0);
            }

            DebugMsg(DM_TRACE, TEXT("so TR - WinMain About to call OleUninitialize"));
            dwTick = GetCurrentTime();
            OleUninitialize();
            DebugMsg(DM_TRACE, TEXT("so TR - WinMain OleUninitialize took %d ticks"), GetCurrentTime()-dwTick);
        }

        if (IsWindow(hwndClientSite)) {
            DebugMsg(DM_WARNING, TEXT("so WA - WinMain IsWindow(hwndClientSite) is still TRUE"));
            DestroyWindow(hwndClientSite);
        }
    }
}

extern "C" void WINAPI
OpenScrap_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR  lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*sizeof(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        OpenScrap_RunDLL_Common( hwndStub,
                                 hAppInstance,
                                 lpwszCmdLine,
                                 nCmdShow );
        LocalFree(lpwszCmdLine);
    }
}

extern "C" void WINAPI
OpenScrap_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
    OpenScrap_RunDLL_Common( hwndStub,
                             hAppInstance,
                             lpwszCmdLine,
                             nCmdShow );
}
#ifdef DEBUG
//
// Type checking
//
static RUNDLLPROCA lpfnRunDLLA=OpenScrap_RunDLL;
static RUNDLLPROCW lpfnRunDLLW=OpenScrap_RunDLLW;
#endif

void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR pszFileName)
{
    TCHAR szErrMsg[MAX_PATH*2];
    TCHAR szFancyErr[MAX_PATH*2];
    HRSRC hrsrc;

    if (HIWORD(hres))
    {
        BOOL fSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  NULL,
                  hres,
                  0,
                  szErrMsg,
                  ARRAYSIZE(szErrMsg),
                  (va_list *)&pszFileName);
        if (!fSuccess) {
            idsMsg++;   // map IDS_ERR_DOVERB to IDS_ERR_DOVERB_F
        }
    } else {
        LoadString(g_hinst, LOWORD(hres), szErrMsg, ARRAYSIZE(szErrMsg));
    }

    szFancyErr[0] = TEXT('\0');
    hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(IDR_FANCYERR), RT_RCDATA);
    if (hrsrc)
    {
        HGLOBAL hmem = LoadResource(g_hinst, hrsrc);
        if (hmem)
        {
            HRESULT* phres = (HRESULT*)LockResource(hmem);
            if (phres)
            {
                UINT i;
                LPTSTR pszLoad = szFancyErr;
                int cchLeft = ARRAYSIZE(szFancyErr);
                for (i=0; phres[i] && cchLeft>0; i++) {
                    if (phres[i] == hres)
                    {
                        int cchRead;
                        cchRead = LoadString(g_hinst, IDS_FANCYERR+i, pszLoad, cchLeft);
                        pszLoad += cchRead;
                        cchLeft -= cchRead;
                    }
                }

                //
                // If we have a fancy error message, hide ugly message
                // from FormatMessage.
                //
                if (szFancyErr[0]) {
                    szErrMsg[0] = TEXT('\0');
                }
            }
        }
    }

    ShellMessageBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(idsMsg),
                    MAKEINTRESOURCE(IDS_TITLE_ERR),
                    MB_OK | MB_ICONWARNING | MB_SETFOREGROUND,
                    pszFileName,
                    szErrMsg,
                    szFancyErr,
                    hres);
}


void CShClientSite::CloseOleObject()
{
    if (_pole)
        _pole->Close(OLECLOSE_NOSAVE);
}

void CShClientSite::ReleaseOleObject()
{
    UINT cRef;
    if (_pole)
    {
        if (_dwConnection) {
            _pole->Unadvise(_dwConnection);
            _dwConnection = 0;
        }
        _pole->SetClientSite(NULL);
        cRef = _pole->Release();
        DebugMsg(DM_TRACE, TEXT("so - TR SCS::ReleaseOleObject IOleObj::Rel returned (%d)"), cRef);
        _pole=NULL;
    }

    if (_ppstg)
    {
        cRef=_ppstg->Release();
        _ppstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseOleObject IPSTG::Release returned (%x)"), cRef);
    }
}

void CShClientSite::ReleaseStorage(void)
{
    UINT cRef;

    if (_pstg)
    {
        cRef=_pstg->Release();
        _pstg=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstg->Release returned (%x)"), cRef);
    }

    if (_pstgDoc)
    {
        cRef=_pstgDoc->Release();
        _pstgDoc=NULL;
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::ReleaseStorage _pstgDoc->Release returned (%x)"), cRef);
    }
}

void CShClientSite::MaySaveAs()
{
    DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs called (%d,%d)"), _fCloned, _fNeedToSave);
    if (_fCloned)
    {
        TCHAR szTempFile[MAX_PATH];
        HRESULT hr = StringCchCopy(szTempFile, ARRAYSIZE(szTempFile), _wszFileName);
        if (SUCCEEDED(hr))
        {
            UINT id = IDNO;
            if (_fNeedToSave)
            {
                id= ShellMessageBox(g_hinst,
                            _hwndOwner,
                            MAKEINTRESOURCE(IDS_WOULDYOUSAVEAS),
                            MAKEINTRESOURCE(IDS_TITLE),
                            MB_YESNO | MB_ICONQUESTION | MB_SETFOREGROUND,
                            NULL);
            }

            DebugMsg(DM_TRACE, TEXT("so TR - SCS::MaySaveAs id==%d"), id);

            if (id==IDYES)
            {
                TCHAR szDesktop[MAX_PATH];
                SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_DESKTOP, FALSE);

                BOOL fContinue;
                do
                {
                    fContinue = FALSE;

                    TCHAR szFile[MAX_PATH];
                    TCHAR szFilter[64];
                    szFile[0] = TEXT('\0');
                    LoadString(g_hinst, IDS_SCRAPFILTER, szFilter, ARRAYSIZE(szFilter));

                    OPENFILENAME of = {
                        SIZEOF(OPENFILENAME), // DWORD        lStructSize;
                        _hwndOwner,               // HWND         hwndOwner;
                        NULL,                     // HINSTANCE    hInstance;
                        szFilter,         // LPCSTR       lpstrFilter;
                        NULL,                     // LPSTR        lpstrCustomFilter;
                        0,                // DWORD        nMaxCustFilter;
                        1,                // DWORD        nFilterIndex;
                        szFile,           // LPSTR        lpstrFile;
                        ARRAYSIZE(szFile),    // DWORD        nMaxFile;
                        NULL,                     // LPSTR        lpstrFileTitle;
                        0,                // DWORD        nMaxFileTitle;
                        szDesktop,        // LPCSTR       lpstrInitialDir;
                        NULL,                     // LPCSTR       lpstrTitle;
                        OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT
                        | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST,
                                            // DWORD        Flags;
                        0,                // WORD         nFileOffset;
                        0,                // WORD         nFileExtension;
                        TEXT("shs"),                      // LPCSTR       lpstrDefExt;
                        NULL,                     // LPARAM       lCustData;
                        NULL,                     // LPOFNHOOKPROC lpfnHook;
                        NULL,                     // LPCSTR       lpTemplateName;
                    };

                    if (GetSaveFileName(&of))
                    {
                        DeleteFile(szFile);
                        BOOL fRet = MoveFile(szTempFile, szFile);
                        if (fRet)
                        {
                            // Indicated that the temp file is moved
                            szTempFile[0] = TEXT('\0');
                        }
                        else
                        {
                            id = ShellMessageBox(g_hinst,
                                    _hwndOwner,
                                    MAKEINTRESOURCE(IDS_MOVEFAILED),
                                    MAKEINTRESOURCE(IDS_TITLE),
                                    MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND);
                            if (id==IDYES)
                            {
                                fContinue = TRUE;
                            }
                        }
                    }
                } while (fContinue);
            }

            // If the temp file is not moved, delete it.
            if (szTempFile[0])
            {
                DeleteFile(szTempFile);
            }
        }
    }
}

void CShClientSite::Draw(HWND hwnd, HDC hdc)
{
    if (_ppstg)
    {
        HRESULT hres;
        RECT rc;

        GetClientRect(hwnd, &rc);

        hres = OleDraw(_ppstg, DVASPECT_ICON, hdc, &rc);
        DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_ICON) returned %x"), hres);

        if (FAILED(hres))
        {
            LPVIEWOBJECT2 pview;
            hres = _ppstg->QueryInterface(IID_IViewObject2, (LPVOID*)&pview);
            if (SUCCEEDED(hres))
            {
                SIZE size;
                hres = pview->GetExtent(DVASPECT_CONTENT, (DWORD)-1,
                                        (DVTARGETDEVICE*)NULL, &size);
                DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw IVO2::GetExtent returned %x"), hres);
                if (SUCCEEDED(hres))
                {
                    int mmOld = SetMapMode(hdc, MM_HIMETRIC);
                    LPtoDP(hdc, (LPPOINT)&size, 1);
                    rc.right = size.cx;
                    rc.bottom = -size.cy;
                    SetMapMode(hdc, mmOld);
                }
                pview->Release();
            }
            hres = OleDraw(_ppstg, DVASPECT_CONTENT, hdc, &rc);
            DebugMsg(DM_TRACE, TEXT("so TR - SCS::Draw OleDraw(DVASPECT_CONTENT,%d,%d) returned %x"),
                        hres, rc.right, rc.bottom);
        }

        LPOLELINK plink;
        if (SUCCEEDED(hres = _ppstg->QueryInterface(IID_IOleLink, (LPVOID *)&plink)))
        {
            LPOLESTR pwsz;
            hres = plink->GetSourceDisplayName(&pwsz);
            if (SUCCEEDED(hres))
            {
                TextOut(hdc, 0, 0, pwsz, lstrlen(pwsz));
                CoTaskMemFree(pwsz);
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IMK:GetSDN failed %x"), hres);
            }
            plink->Release();
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so TR SCS:Draw IPSTG:QI failed %x"), hres);
        }
    }
}

STDMETHODIMP CShClientSite::QueryInterface(REFIID riid,
        void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_CShClientSite)) {
        _cRef++;
        *ppvObject = this;
        hres = NOERROR;
    }
    else if (IsEqualGUID(riid, IID_IOleClientSite) || IsEqualGUID(riid, IID_IUnknown)) {
        _cRef++;
        *ppvObject = (LPOLECLIENTSITE)this;
        hres = NOERROR;
    }
    else if (IsEqualGUID(riid, IID_IAdviseSink) || IsEqualGUID(riid, IID_IAdviseSink2)) {
        _cRef++;
        *ppvObject = (LPADVISESINK2)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

STDMETHODIMP_(ULONG) CShClientSite::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CShClientSite::Release(void)
{
    if (--_cRef>0) {
        return _cRef;
    }

    delete this;
    return 0;
}


void Scrap_UpdateCachedData(LPSTORAGE pstgDoc, LPOLEOBJECT pole, LPPERSIST pps)
{
    extern void Scrap_CacheClipboardData(LPSTORAGE pstgDoc, LPDATAOBJECT pdtobj, LPPERSIST pps);
    DebugMsg(DM_TRACE, TEXT("so TR - S_UCD called"));
    if (pstgDoc && pole && pps)
    {
        IDataObject *pdtobj = NULL;
        HRESULT hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
        if (SUCCEEDED(hres)) {
            DebugMsg(DM_TRACE, TEXT("so TR - S_UCD QI succeeded"));
            Scrap_CacheClipboardData(pstgDoc, pdtobj, pps);
            pdtobj->Release();
        }
    }
}

STDMETHODIMP CShClientSite::SaveObject(void)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CSCS::SaveObject called"));
    //
    // NOTES: We need to update the cache here.
    //  Doing so on ::OnSave does not work (async)
    //  Doing so on ::OnClose is too late.
    //
    Scrap_UpdateCachedData(_pstgDoc, _pole, _ppstg);

    HRESULT hres;
    if (_pstg && _ppstg)
    {
        hres = OleSave(_ppstg, _pstg, TRUE);
        if (SUCCEEDED(hres))
        {
            hres = _ppstg->SaveCompleted(NULL);
        }
    }
    else
    {
        hres = ResultFromScode(E_FAIL);
    }
    return hres;
}

STDMETHODIMP CShClientSite::GetMoniker(DWORD dwAssign,
    DWORD dwWhichMoniker,
    IMoniker **ppmk)
{
    HRESULT hres;

    *ppmk = NULL;

    switch(dwWhichMoniker)
    {
    case OLEWHICHMK_CONTAINER:
        hres = CreateFileMoniker(_wszFileName, ppmk);
        break;

    case OLEWHICHMK_OBJREL:
        hres = CreateItemMoniker(L"\\", L"Object", ppmk);
        break;

    case OLEWHICHMK_OBJFULL:
        {
            LPMONIKER pmkItem;
            hres = CreateItemMoniker(L"\\", L"Object", &pmkItem);
            if (SUCCEEDED(hres))
            {
                LPMONIKER pmkDoc;
                hres = CreateFileMoniker(_wszFileName, &pmkDoc);
                if (SUCCEEDED(hres))
                {
                    hres = CreateGenericComposite(pmkDoc, pmkItem, ppmk);
                    pmkDoc->Release();
                }
                pmkItem->Release();
            }
        }
        break;

    default:
        hres = ResultFromScode(E_INVALIDARG);
    }

    return hres;
}

STDMETHODIMP CShClientSite::GetContainer(
    IOleContainer **ppContainer)
{
    *ppContainer = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CShClientSite::ShowObject(void)
{
    return NOERROR;
}

STDMETHODIMP CShClientSite::OnShowWindow(BOOL fShow)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnShowWindow called with %d"), fShow);
    return NOERROR;
}

STDMETHODIMP CShClientSite::RequestNewObjectLayout(void)
{
    return ResultFromScode(E_NOTIMPL);
}

//
// _cRef <- 2 because _hwndOwner has a reference count as well.
//
CShClientSite::CShClientSite(HWND hwndOwner, LPCTSTR pszCmdLine)
                : _cRef(2), _hwndOwner(hwndOwner),
                  _pstgDoc(NULL), _pstg(NULL), _ppstg(NULL), _pole(NULL),
                  _fDirty(FALSE), _fNeedToSave(FALSE),
                  _fReadOnly(FALSE), _fCloned(FALSE), _fCloseImmediately(FALSE),
                  _fQuit(FALSE)
{
    LPCTSTR pszFileName = ParseCmdLine(pszCmdLine);

//
// We'd better deal with quoted LFN name.
//
#ifdef NASHVILLE
    //
    // Strip out quotes if exists.
    //
    TCHAR szT[MAX_PATH];
    if (*pszFileName==TEXT('"'))
    {
        StringCchCopy(szT, ARRAYSIZE(szT), pszFileName+1);
        LPTSTR pszT = CharPrev(szT, szT+lstrlen(szT));
        if (*pszT==TEXT('"')) {
            *pszT=TEXT('\0');
        }
        pszFileName = szT;
    }
#endif // NASHVILLE

    StringCchCopy(_wszFileName, ARRAYSIZE(_wszFileName), pszFileName);

    Assert(_hwndOwner)
    SetWindowLongPtr(_hwndOwner, GWLP_USERDATA, (LPARAM)this);
}

CShClientSite::~CShClientSite()
{
    ReleaseOleObject();
    ReleaseStorage();
    DebugMsg(DM_TRACE, TEXT("sc - CShClientSite is being deleted"));
}

LPCTSTR _SkipSpace(LPCTSTR psz)
{
    while(*psz==TEXT(' '))
        psz++;
    return psz;
}

LPCTSTR CShClientSite::ParseCmdLine(LPCTSTR pszCmdLine)
{
    for (LPCTSTR psz = _SkipSpace(pszCmdLine);
         (*psz == TEXT('/') || *psz == TEXT('-')) && *++psz;
         psz = _SkipSpace(psz))
    {
        switch(*psz++)
        {
        case TEXT('r'):
        case TEXT('R'):
            _fReadOnly = TRUE;
            break;

        case TEXT('x'):
        case TEXT('X'):
            _fCloseImmediately = TRUE;
            break;
        }
    }

    return psz;
}

HRESULT CShClientSite::GetFileName(LPTSTR szFile, UINT cchMax)
{
    return StringCchCopy(szFile, cchMax, _wszFileName);
}
const WCHAR c_wszContents[] = WSTR_SCRAPITEM;

//
// Returns:
//      S_OK, succeeded. Start the message loop.
//      S_FALSE, succeeded. Release the object.
//      Others, failed.
//
HRESULT CShClientSite::Load()
{
    HRESULT hres;
    DWORD wStgm;

    // Must be called only once.
    if (_pstgDoc) {
        return ResultFromScode(E_UNEXPECTED);
    }

    wStgm = _fReadOnly ?
                (STGM_READ | STGM_SHARE_DENY_WRITE) :
                (STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
    hres = StgIsStorageFile(_wszFileName);
    if (hres != S_OK)
    {
        if (hres==S_FALSE) {
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
        return hres;
    }

    hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);

#ifndef CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        _fReadOnly = TRUE;
        wStgm = (STGM_READ | STGM_SHARE_DENY_WRITE);
        hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
    }
#else // CLONE_IT_IF_READONLY
    //
    //  If we are opening without read-only flag and StgOpenStorage failed
    // with STG_E_ACCESSDENIED, retry it with read-only mode.
    //
    if ((hres==STG_E_ACCESSDENIED) && !_fReadOnly)
    {
        LPSTORAGE pstgRead;
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb first StgOpenStorage failed, retrying it in read-only mode"));
        hres = StgOpenStorage(_wszFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &pstgRead);
        if (SUCCEEDED(hres))
        {
            TCHAR szDesktop[MAX_PATH];
            TCHAR szTempFile[MAX_PATH];
            SHGetSpecialFolderPath(_hwndOwner, szDesktop, CSIDL_DESKTOP, FALSE);
            GetTempFileName(szDesktop, TEXT("Sh"), 0, szTempFile);
            hres = StringCchCopy(_wszFileName, ARRAYSIZE(_wszFileName), szTempFile);
            if (SUCCEEDED(hres))
            {
                hres = StgCreateDocfile(_wszFileName,
                                STGM_DIRECT | STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &_pstgDoc);
                if (SUCCEEDED(hres))
                {
                    hres = pstgRead->CopyTo(0, NULL, NULL, _pstgDoc);
                    _pstgDoc->Release();
                    _pstgDoc = NULL;

                    if (SUCCEEDED(hres))
                    {
                        hres = StgOpenStorage(_wszFileName, NULL, wStgm, NULL, 0, &_pstgDoc);
                        if (SUCCEEDED(hres))
                        {
                            _fCloned = TRUE;
                        }
                    }
                    else
                    {
                        DeleteFile(szTempFile);
                    }
                }
            }
            pstgRead->Release();
        }
    }
#endif // CLONE_IT_IF_READONLY

    if (SUCCEEDED(hres))
    {
        if (_fReadOnly) {
            wStgm = STGM_READ|STGM_SHARE_EXCLUSIVE;
        }
        hres = _pstgDoc->OpenStorage(c_wszContents, NULL, wStgm, NULL, 0, &_pstg);
        if (SUCCEEDED(hres))
        {
            hres = OleLoad(_pstg, IID_IPersistStorage, this, (LPVOID *)&_ppstg);
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb _pstgDoc->OpenStorage failed %x"), hres);

            //
            // Notes: If we just return this hres as is, the user will see
            //  "Can't open file, FOO.SHS", which is bogus. We need to
            //  translate it into a much informative message.
            //
            hres = IDS_HRES_INVALID_SCRAPFILE;
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb StgOpenStg failed %x"), hres);
    }

    return hres;
}



HRESULT CShClientSite::DoVerb(LONG iVerb)
{
    HRESULT hres;
    hres = _ppstg->QueryInterface(IID_IOleObject, (LPVOID *)&_pole);

    if (SUCCEEDED(hres))
    {
        hres = _pole->Advise(this, &_dwConnection);
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::Advise returned %x"), hres);
        if (SUCCEEDED(hres))
        {
            TCHAR szTitle[MAX_PATH];
            WCHAR wszTitle[MAX_PATH];
            LoadString(g_hinst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));
            hres = StringCchCopy(wszTitle, ARRAYSIZE(wszTitle), szTitle);
            if (SUCCEEDED(hres))
            {
                hres = GetFileName(szTitle, ARRAYSIZE(szTitle));
                if (SUCCEEDED(hres))
                {
                    LPCWSTR pwszDisplayName = _wszFileName;
                    SHFILEINFO info;
                    DWORD_PTR result = SHGetFileInfo(szTitle, 0, &info, SIZEOF(info), SHGFI_DISPLAYNAME);

                    if(result && *info.szDisplayName)
                    {
                        pwszDisplayName = info.szDisplayName;
                    }

                    _pole->SetHostNames(wszTitle, pwszDisplayName);

                    //
                    // OLEBUG? Unless _hwndOwner has the input focus, 16-bit
                    //  server won't get the input focus.
                    //
                    SetFocus(_hwndOwner);

                    hres = _pole->DoVerb(iVerb, NULL, this, 0, _hwndOwner, NULL);
                    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::DoVerb IOleObject::DoVerb returned %x"), hres);
                    if (SUCCEEDED(hres) && _fCloseImmediately) 
                    {
                        hres = S_FALSE;
                    }
                }
            }
        }
    }
    else
    {
    DebugMsg(DM_TRACE, TEXT("so ER - CSCS::DoVerb IPSTG::QI failed %x"), hres);
    }
    return hres;
}

STDMETHODIMP_(void) CShClientSite::OnDataChange(FORMATETC *pFormatetc, STGMEDIUM *pStgmed)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnDataChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnViewChange called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnRename(IMoniker *pmk)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnRename called"));
    _fDirty = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnSave(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnSave called"));
    _fNeedToSave = TRUE;
}

STDMETHODIMP_(void) CShClientSite::OnClose(void)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnClose called"));
    if (_fNeedToSave /* && _fDirty */)
    {
        HRESULT hres;
        hres=OleSave(_ppstg, _pstg, TRUE);      // fSameStorage=TRUE
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose OleSave returned (%x)"), hres);
        hres=_ppstg->HandsOffStorage();
        DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose IPS:HandsOffStorage returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psg->Commit returned (%x)"), hres);
            hres = _pstgDoc->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - CSCS:OnClose _psgDoc->Commit returned (%x)"), hres);
        }
    }

    //
    // WARNING:
    //
    //  OLE1 server pukes if we release object here. However, we need to
    // call IOleObject::UnAdvice and IOleObject::SetClientSite(NULL) here
    // to avoid memory leak (RPC keeps 3 reference counts to IOleClientSite
    // if we delay it as well).
    //
    // ReleaseOleObject();
    //
    if (_dwConnection) {
        _pole->Unadvise(_dwConnection);
        _dwConnection = 0;
    }
    _pole->SetClientSite(NULL);

    PostMessage(_hwndOwner, WM_USER, 0, 0);
}

STDMETHODIMP_(void) CShClientSite::OnLinkSrcChange
(
    IMoniker *pmk
)
{
    DebugMsg(DM_TRACE, TEXT("so TR - CSCS::OnLinkSrcChange called"));
    _fDirty = TRUE;
}

LRESULT CALLBACK ShWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;
    LPSHCLIENTSITE pscs = (LPSHCLIENTSITE)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        if (pscs && IsWindowVisible(hwnd))
        {
            pscs->Draw(hwnd, hdc);
        }
        EndPaint(hwnd, &ps);
        break;

    case WM_CLOSE:
        if (pscs)
        {
            pscs->CloseOleObject();
            DestroyWindow(hwnd);
        }
        break;

    case WM_USER:
        if (pscs)
        {
            pscs->ReleaseOleObject();
            PostMessage(hwnd, WM_CLOSE, 0, 0);
        }
        break;

    case WM_DESTROY:
        DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc processing WM_DESTROY"));
        if (pscs)
        {
            pscs->Quit();
            pscs->Release();
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        }
        else
        {
            DebugMsg(DM_WARNING, TEXT("so WA - ShWndProc pscs==NULL on WM_DESTROY"));
        }

#if 0
        //
        // Process all the pending messages, before we post WM_QUIT message.
        //
        MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//===========================================================================
// Global functions
//===========================================================================

void CShClientSite_RegisterClass()
{
    WNDCLASS wc;

    // wc.cbSize     = SIZEOF(WNDCLASSEX);
    wc.style         = CS_DBLCLKS|CS_VREDRAW|CS_HREDRAW ;
    wc.lpfnWndProc   = ShWndProc ;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(LPSHCLIENTSITE) + SIZEOF(LPVOID);
    wc.hInstance     = g_hinst ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH) ;
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = c_szAppName ;
    // wc.hIconSm    = NULL;

    RegisterClass(&wc);
}

IOleClientSite* CShClientSite_Create(HWND hwndOwner, LPCTSTR pszFileName)
{
    DebugMsg(DM_TRACE, TEXT("sc TR:CShClientSite_Create called with %s"), pszFileName);
    CShClientSite* that = new CShClientSite(hwndOwner, pszFileName);
    if (that)
    {
        HRESULT hres = that->Load();
        DebugMsg(DM_TRACE, TEXT("sc TRACE: CShClientSite::Load returned %x"), hres);
    }
    return that;
}

void CShClientSite_Release(IOleClientSite* pcli)
{
    CShClientSite* pscs;
    if (SUCCEEDED(pcli->QueryInterface(CLSID_CShClientSite, (void**)&pscs)))
    {
        pscs->ReleaseOleObject();
        pscs->ReleaseStorage();
        pscs->MaySaveAs();
        pscs->Release();
    }
    UINT cRef = pcli->Release();
    Assert(cRef==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

USE_NT_PRODUCT_VER=1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

C_DEFINES = $(C_DEFINES) -DNOWINRES

TARGETNAME      = shscrap
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

TARGETLIBS      = $(SDK_LIB_PATH)\kernel32.lib      \
                  $(WINDOWS_LIB_PATH)\gdi32p.lib    \
                  $(WINDOWS_LIB_PATH)\user32p.lib   \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SDK_LIB_PATH)\comdlg32.lib      \
                  $(SHELL_LIB_PATH)\comctlp.lib     \
                  $(SDK_LIB_PATH)\mpr.lib           \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\uuid.lib          \
!if defined(TARGET_WIN95)
                  $(CCSHELL_DIR)\lib\$O\stock4.lib
!else
                  $(CCSHELL_DIR)\lib\$O\stock.lib
!endif

DLLENTRY        = LibMain
DLLDEF          = ..\shole.def

USE_MSVCRT      = 1

SOURCES         = \
                  ..\shole.rc     \
                  ..\debug.c      \
                  ..\sccls.cpp    \
                  ..\sccreate.cpp \
                  ..\scdata.cpp   \
                  ..\shole.cpp    \
                  ..\scext.cpp    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\scext.cpp ===
#include "shole.h"
#include "ids.h"

//===========================================================================
// CScrapExt : Class definition
//===========================================================================



class CScrapExt : public IShellExtInit, public IShellPropSheetExt
{
public:
    CScrapExt();
    ~CScrapExt();

    HRESULT GetFileName(LPTSTR pszPath);

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IShellExtInit
    virtual HRESULT __stdcall Initialize(LPCITEMIDLIST pidlFolder,
		          LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    virtual HRESULT __stdcall AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    virtual HRESULT __stdcall ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);


protected:
    UINT         _cRef;
    IDataObject* _pdtobj;
};

HRESULT CScrapExt::GetFileName(LPTSTR pszPath)
{
    STGMEDIUM medium;
    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hres = E_FAIL;
    if (_pdtobj)
    {
	hres = _pdtobj->GetData(&fmte, &medium);
	if (hres == S_OK)
	{
	    if (!DragQueryFile((HDROP)medium.hGlobal,0,pszPath,MAX_PATH))
		hres = E_FAIL;
	    ReleaseStgMedium(&medium);
	}
    }
    return hres;
}

HRESULT CScrapExt::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellExtInit*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppvObj = (IShellPropSheetExt *)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CScrapExt::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CScrapExt::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CScrapExt::CScrapExt() : _cRef(1), _pdtobj(NULL)
{
    g_cRefThisDll++;
    OleInitialize(NULL);
}

CScrapExt::~CScrapExt()
{
    if (_pdtobj) {
	_pdtobj->Release();
    }

    OleUninitialize();
    g_cRefThisDll--;
}

HRESULT CScrapExt::Initialize(LPCITEMIDLIST pidlFolder,
              LPDATAOBJECT pdtobj, HKEY hkeyProgID)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt::Initialize called"));

    if (pdtobj) {
	_pdtobj = pdtobj;
	pdtobj->AddRef();
	return S_OK;
    }
    return E_FAIL;
}

//===========================================================================
// CScrapPropSheetPage: Class definition
//
// Notes: Notice that this class has no destructor. It has no destructor
//  because the lifetime of the object itself does not mean anything
//  -- full contents will be copied by the property sheet code.
//  Instead, it has a _Release function which is explicitly called
//  when the property sheet handle is destroyed.
//===========================================================================

class CScrapPropSheetPage : public PROPSHEETPAGE // spsp
{
public:
    CScrapPropSheetPage(CScrapExt* psext);
protected:
    static INT_PTR CALLBACK _DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _CallBack(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    void _Release();

    CScrapExt*      _psext;
    HWND            _hdlg;
    IOleClientSite* _pcli;
};


CScrapPropSheetPage::CScrapPropSheetPage(CScrapExt* psext)
		: _psext(psext), _hdlg(NULL), _pcli(NULL)
{
    dwSize = sizeof(CScrapPropSheetPage);
    dwFlags = PSP_DEFAULT|PSP_USECALLBACK;
    hInstance = HINST_THISDLL;
    pszTemplate = MAKEINTRESOURCE(IDD_VIEW);
    // hIcon = NULL; // unused (PSP_USEICON is not set)
    // pszTitle = NULL; // unused (PSP_USETITLE is not set)
    pfnDlgProc = _DlgProc;
    // lParam   = 0;     // unused
    pfnCallback = _CallBack;
    // pcRefParent = NULL;
    _psext->AddRef();
    CShClientSite_RegisterClass();
}

void CScrapPropSheetPage::_Release()
{
    if (_psext) {
	_psext->Release();
    }

    if (_pcli) {
	CShClientSite_Release(_pcli);
    }
};
INT_PTR CALLBACK CScrapPropSheetPage::_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndView;
    CScrapPropSheetPage* pspsp;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hdlg, DWLP_USER, lParam);
        pspsp = (CScrapPropSheetPage *)lParam;
        pspsp->_hdlg = hdlg;
	hwndView = GetDlgItem(hdlg, IDI_SCRAPVIEW);
	if (hwndView) {
	    SetWindowText(hwndView, TEXT("Not Implemented Yet"));
	    // SetWindowLongPtr(hwndView, sizeof(LPVOID), (LPARAM)pspsp);
	    TCHAR szPath[MAX_PATH];
	    if (SUCCEEDED(pspsp->_psext->GetFileName(szPath)))
	    {
		pspsp->_pcli = CShClientSite_Create(hwndView, szPath);
	    }
	}
	break;
    }
    return FALSE;
}

UINT CALLBACK CScrapPropSheetPage::_CallBack(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CScrapPropSheetPage * pspsp = (CScrapPropSheetPage*)ppsp;
    switch(uMsg)
    {
    case PSPCB_RELEASE:
	DebugMsg(DM_TRACE, TEXT("sc - TR: _ScrapPageCallBack is releasing _psext"));
	pspsp->_Release();
	break;
    }
    return TRUE;
}


HRESULT CScrapExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt::AddPage called"));

    HPROPSHEETPAGE hpage;
    HRESULT hres = S_OK;
    CScrapPropSheetPage spsp(this);

    hpage = CreatePropertySheetPage(&spsp);
    if (hpage)
    {
	BOOL bResult = lpfnAddPage(hpage, lParam);
	if (!bResult)
	{
	   DestroyPropertySheetPage(hpage);
	   hres = E_FAIL;
	}
    }

    return hres;
}

HRESULT CScrapExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_FALSE;
}

HRESULT CScrapExt_CreateInstance(LPUNKNOWN * ppunk)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CScrapExt_CreateInstance called"));

    CScrapExt* pscd = new CScrapExt();
    if (pscd) {
        *ppunk = (LPDATAOBJECT)pscd;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\template.cpp ===
#include "shole.h"
#include "ids.h"
#include "scguid.h"

#ifdef FEATURE_SHELLEXTENSION

extern "C" const TCHAR c_szCLSID[];

class CTemplateFolder : public IShellFolder, public IPersistFolder
{
public:
    CTemplateFolder();
    ~CTemplateFolder();
    inline BOOL ConstructedSuccessfully() { return _hdpaMap != NULL; }

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IShellFolder
    virtual HRESULT __stdcall ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    virtual HRESULT __stdcall EnumObjects( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);

    virtual HRESULT __stdcall BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj);
    virtual HRESULT __stdcall CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT __stdcall CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut);
    virtual HRESULT __stdcall GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual HRESULT __stdcall GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual HRESULT __stdcall SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut);

    // IPersistFolder
    virtual HRESULT __stdcall GetClassID(LPCLSID lpClassID);
    virtual HRESULT __stdcall Initialize(LPCITEMIDLIST pidl);

protected:
    // Defview callback
    friend HRESULT CALLBACK DefViewCallback(
                                LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg,
                                WPARAM wParam, LPARAM lParam);
    HRESULT GetDetailsOfDVM(UINT ici, DETAILSINFO *pdi);

    BOOL IsMyPidl(LPCITEMIDLIST pidl)
	{ return (pidl->mkid.abID[0] == 'S' && pidl->mkid.abID[1] == 'N'); }

    UINT _cRef;

    //
    //  To speed up name lookups, we cache the mapping between CLSIDs and
    //  display names.  We cannot persist this mapping because it won't
    //  survive localization or ANSI/UNICODE interop.
    //
    typedef struct {
        CLSID clsid;
        TCHAR achName[MAX_PATH];
    } CLSIDMAP, *PCLSIDMAP;

    HDPA _hdpaMap;

    HRESULT GetNameOf(LPCITEMIDLIST pidl, LPCTSTR *ppsz);
};

class CEnumTemplate : public IEnumIDList
{
public:
    CEnumTemplate(DWORD grfFlags);
    ~CEnumTemplate();

protected:
    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    virtual HRESULT __stdcall Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched);
    virtual HRESULT __stdcall Skip(ULONG celt);
    virtual HRESULT __stdcall Reset();
    virtual HRESULT __stdcall Clone(IEnumIDList **ppenum);

    UINT	_cRef;
    const DWORD	_grfFlags;
    UINT	_iCur;
    HKEY	_hkeyCLSID;
};

//
//  For Win95/NT interop, our PIDLs are always UNICODE.
//  Use explicit packing for Win32/64 interop.
#include <pshpack1.h>
typedef struct _TIDL {
    USHORT          cb;             // This matches SHITEMID
    BYTE            abID[2];        // This matches SHITEMID
    CLSID	    clsid;
} TIDL;
typedef const UNALIGNED TIDL *PTIDL;

//
//  This is the TIDL constructor -- it has the cbZero at the end.
//
typedef struct _TIDLCONS {
    TIDL            tidl;
    USHORT          cbZero;
} TIDLCONS;

#include <poppack.h>

class CTemplateUIObj : public IExtractIcon, public IDataObject, public IContextMenu
{
public:
    static HRESULT Create(REFCLSID, REFIID, LPVOID*);
protected:
    CTemplateUIObj(REFCLSID rclsid)
                    : _clsid(rclsid), _cRef(1)
                                { DllAddRef(); }
    ~CTemplateUIObj()           { DllRelease(); }
    HRESULT _CreateInstance(IStorage* pstg);

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // *** IExtractIcon methods ***
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    // IContextMenu
    virtual HRESULT __stdcall QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    virtual HRESULT __stdcall InvokeCommand(
                             LPCMINVOKECOMMANDINFO lpici);

    virtual HRESULT __stdcall GetCommandString(
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    UINT	_cRef;
    CLSID	_clsid;
};


CTemplateFolder::CTemplateFolder() : _cRef(1)
{
    _hdpaMap = DPA_Create(10);
    OleInitialize(NULL);
    DllAddRef();
}

CTemplateFolder::~CTemplateFolder()
{
    if (_hdpaMap) {
        for (int i = DPA_GetPtrCount(_hdpaMap) - 1; i >= 0; i--) {
            PCLSIDMAP pmap = (PCLSIDMAP)DPA_FastGetPtr(_hdpaMap, i);
            LocalFree(pmap);
        }
        DPA_Destroy(_hdpaMap);
    }

    OleUninitialize();
    DllRelease();
}

HRESULT CTemplateFolder::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IShellFolder) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellFolder*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistFolder))
    {
        *ppvObj = (IPersistFolder*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateFolder::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateFolder::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTemplateFolder_CreateInstance(LPUNKNOWN * ppunk)
{
    *ppunk = NULL;

    CTemplateFolder* ptfld = new CTemplateFolder();
    if (ptfld) {
        if (ptfld->ConstructedSuccessfully()) {
            *ppunk = (IShellFolder *)ptfld;
            return S_OK;
        }
        ptfld->Release();
    }
    return E_OUTOFMEMORY;
}

HRESULT CTemplateFolder::ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList)
{
    *ppenumIDList = new CEnumTemplate(grfFlags);
    return *ppenumIDList ? S_OK : E_OUTOFMEMORY;
}

HRESULT CTemplateFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvOut)
{
    return E_NOTIMPL;
}

HRESULT CTemplateFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}

//
//  If the name is in the cache, celebrate our good fortune and return it.
//  Else, go get the name from the registry and cache it for later.
//
HRESULT CTemplateFolder::GetNameOf(LPCITEMIDLIST pidl, LPCTSTR *ppsz)
{
    if (!IsMyPidl(pidl))
        return E_INVALIDARG;

    HRESULT hres;
    PTIDL ptidl = (PTIDL)pidl;
    CLSIDMAP map;
    map.clsid = ptidl->clsid;           // Align the CLSID
    PCLSIDMAP pmap;
    for (int i = DPA_GetPtrCount(_hdpaMap) - 1; i >= 0; i--) {
        pmap = (PCLSIDMAP)DPA_FastGetPtr(_hdpaMap, i);
        if (IsEqualGUID(pmap->clsid, map.clsid)) {
            *ppsz = pmap->achName;
            return S_OK;
        }
    }

    //
    //  Not in cache -- go find it in the registry
    //
    TCHAR szKey[GUIDSTR_MAX + 6];
    _KeyNameFromCLSID(map.clsid, szKey, ARRAYSIZE(szKey));
    LONG dwSize = ARRAYSIZE(map.achName);
    LONG lError = RegQueryValue(HKEY_CLASSES_ROOT, szKey, map.achName, &dwSize);
    if (lError == ERROR_SUCCESS)
    {
        UINT cb = FIELD_OFFSET(CLSIDMAP, achName[lstrlen(map.achName)+1]);
        pmap = (PCLSIDMAP)LocalAlloc(LMEM_FIXED, cb);
        if (pmap) {
            CopyMemory(pmap, &map, cb);
            if (DPA_AppendPtr(_hdpaMap, pmap) >= 0) {
                *ppsz = pmap->achName;
                hres = S_OK;
            } else {
                LocalFree(pmap);
                hres = E_OUTOFMEMORY;
            }
        } else {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32(lError);
    }

    return hres;

}

HRESULT CTemplateFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCTSTR psz1, psz2;
    HRESULT hres;

    hres = GetNameOf(pidl1, &psz1);
    if (SUCCEEDED(hres)) {
        hres = GetNameOf(pidl2, &psz2);
        if (SUCCEEDED(hres)) {
            hres = ResultFromShort(lstrcmpi(psz1, psz2));
        }
    }
    return hres;
}


HRESULT CTemplateFolder::GetDetailsOfDVM(UINT ici, DETAILSINFO *pdi)
{
    HRESULT hres;

    switch (ici) {
    case 0:
        if (pdi->pidl) {
            hres = GetDisplayNameOf(pdi->pidl, SHGDN_NORMAL, &pdi->str);
        } else {
            pdi->fmt = LVCFMT_LEFT;
            pdi->cxChar = 30;
            pdi->str.uType = STRRET_CSTR;
            lstrcpyA(pdi->str.cStr, "Name"); 
            hres = S_OK;
        }
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }
    return hres;
}

HRESULT CALLBACK DefViewCallback(LPSHELLVIEW psvOuter, LPSHELLFOLDER psf,
                                HWND hwndOwner, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // DefView GPF if I don't pass the callback function!
    // DebugMsg(DM_TRACE, "sc TR - DefViewCallBack %d,%x,%x", uMsg, wParam, lParam);
    switch(uMsg)
    {
    case DVM_WINDOWDESTROY:
	DebugMsg(DM_TRACE, TEXT("sc TR - DefViewCallBack Calling OleFlushClipboard"));
	OleFlushClipboard();
	return S_OK;
    case DVM_GETDETAILSOF:
        return ((CTemplateFolder*)psf)->GetDetailsOfDVM((UINT)wParam, (DETAILSINFO*)lParam);
    }
    // DefView GPF if it returns S_FALSE as the default!
    return E_FAIL; // S_FALSE;
}


HRESULT CTemplateFolder::CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut)
{
    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv = {
            SIZEOF(CSFV),       // cbSize
            this,               // pshf
            NULL,               // psvOuter
            NULL,               // pidl
            0,
            DefViewCallback,    // pfnCallback
            FVM_ICON,
        };
        return SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW *)ppvOut);
    }
    return E_NOINTERFACE;
}

HRESULT CTemplateFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                    ULONG * rgfInOut)
{
    if (cidl==1)
    {
	UINT rgfOut = SFGAO_CANCOPY /* | SFGAO_HASPROPSHEET */;
	*rgfInOut &= rgfOut;
    }
    else
    {
	*rgfInOut = 0;
    }
    return S_OK;
}

HRESULT CTemplateFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)
{
    HRESULT hres = E_INVALIDARG;
    if (cidl==1 && IsMyPidl(apidl[0]))
    {
	PTIDL ptidl = (PTIDL)apidl[0];
	hres = CTemplateUIObj::Create(ptidl->clsid, riid, ppvOut);
    }

    return hres;
}

HRESULT _KeyNameFromCLSID(REFCLSID rclsid, LPTSTR pszKey, UINT cchMax)
{
    ASSERT(cchMax - 6 >= GUIDSTR_MAX);
    lstrcpyn(pszKey, TEXT("CLSID\\"), cchMax);
    SHStringFromGUID(rclsid, pszKey + 6, cchMax - 6);
    return S_OK;
}

HRESULT CTemplateFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
    LPCTSTR psz;
    HRESULT hres;

    hres = GetNameOf(pidl, &psz);
    if (SUCCEEDED(hres)) {
#ifdef UNICODE
        lpName->uType = STRRET_WSTR;
        hres = SHStrDupW(psz, &lpName->pOleStr);
#else
        lstrcpyn(lpName->cStr, psz, ARRAYSIZE(lpName->cStr));
        hres = S_OK;
#endif
    }
    return hres;
}

HRESULT CTemplateFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR lpszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut)
{
    return E_NOTIMPL;
}

HRESULT __stdcall CTemplateFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CTemplateFolder;
    return S_OK;
}

HRESULT __stdcall CTemplateFolder::Initialize(LPCITEMIDLIST pidl)
{
    return S_OK;
}

CEnumTemplate::CEnumTemplate(DWORD grfFlags)
    : _cRef(1), _grfFlags(grfFlags), _iCur(0), _hkeyCLSID(NULL)
{
    DllAddRef();
}

CEnumTemplate::~CEnumTemplate()
{
    if (_hkeyCLSID) {
        RegCloseKey(_hkeyCLSID);
    }
    DllRelease();
}

HRESULT CEnumTemplate::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IEnumIDList) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IEnumIDList*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CEnumTemplate::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CEnumTemplate::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CEnumTemplate::Next(ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched)
{
    // Assume error
    if (pceltFetched) {
        *pceltFetched = 0;
    }

    if (!(_grfFlags & SHCONTF_NONFOLDERS)) {
	return S_FALSE;
    }

    if (!_hkeyCLSID)
    {
        if (RegOpenKey(HKEY_CLASSES_ROOT, c_szCLSID, &_hkeyCLSID) != ERROR_SUCCESS)
        {
            return E_FAIL;
        }
    }

    TCHAR szKeyBuf[128];    // enough for {CLSID} or "ProgId/XXX"

    //  Subtract 64 to allow room for the goo we append later on
    while (RegEnumKey(HKEY_CLASSES_ROOT, _iCur++, szKeyBuf, ARRAYSIZE(szKeyBuf) - 64) == ERROR_SUCCESS)
    {
	TCHAR szT[128];
	LONG dwRead;
	int cchKey = lstrlen(szKeyBuf);

	// Check for \NotInsertable.
	lstrcpy(szKeyBuf+cchKey, TEXT("\\NotInsertable"));
	dwRead = ARRAYSIZE(szT);
	if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS) {
	    continue;
	}

	BOOL fInsertable = FALSE;
//
// Let's stop supporting OLE1 servers anymore.
//
#if 0
	lstrcpy(szKeyBuf+cchKey, TEXT("\\protocol\\StdFileEditing\\server"));
	dwRead = ARRAYSIZE(szT);
	if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	{
	    fInsertable = TRUE;
	}
	else
#endif
	{
	    lstrcpy(szKeyBuf+cchKey, TEXT("\\Insertable"));
	    dwRead = ARRAYSIZE(szT);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	    {
		fInsertable = TRUE;
	    }
	}

	if (fInsertable)
	{
	    lstrcpy(szKeyBuf+cchKey, TEXT("\\CLSID"));
	    dwRead = ARRAYSIZE(szT);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKeyBuf, szT, &dwRead) == ERROR_SUCCESS)
	    {
		TIDLCONS tidlCons;
                CLSID clsid;            // Aligned version
		tidlCons.tidl.cb = sizeof(TIDL);
		tidlCons.tidl.abID[0] = 'S';
		tidlCons.tidl.abID[1] = 'N';

		if (GUIDFromString(szT, &clsid))
		{
                    tidlCons.tidl.clsid = clsid;
                    tidlCons.cbZero = 0;
		    rgelt[0] = ILClone((LPITEMIDLIST)&tidlCons);
		    *pceltFetched = 1;
		    return S_OK;
		}
	    }
	}
    }

    return S_FALSE;     // no more element
}

HRESULT CEnumTemplate::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Reset()
{
    return E_NOTIMPL;
}

HRESULT CEnumTemplate::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}


//==========================================================================
// CTemplateUIObj members (IUnknown override)
//==========================================================================

HRESULT CTemplateUIObj::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IExtractIcon) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IExtractIcon*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = (IDataObject*)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        *ppvObj = (IContextMenu*)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CTemplateUIObj::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTemplateUIObj::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

//
// NOTES: This logic MUST be identical to the one in the shell.
//
int _ParseIconLocation(LPTSTR pszIconFile)
{
    int iIndex = 0;
    LPTSTR pszComma = StrChr(pszIconFile, TEXT(','));

    if (pszComma) {
        *pszComma++ = 0;            // terminate the icon file name.
        iIndex = StrToInt(pszComma);
    }
    PathRemoveBlanks(pszIconFile);
    return iIndex;
}


//==========================================================================
// CTemplateUIObj members (IExtractIcon override)
//==========================================================================

//
// szClass -- Specifies either CLSID\{CLSID} or ProgID
//
HRESULT _GetDefaultIcon(LPCTSTR szClass, LPTSTR szIconFile, UINT cchMax, int *piIndex)
{
    TCHAR szKey[256];
    wsprintf(szKey, TEXT("%s\\DefaultIcon"), szClass);
    TCHAR szValue[MAX_PATH+40];
    LONG dwSize = ARRAYSIZE(szValue);
    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
    {
	*piIndex = _ParseIconLocation(szValue);
	lstrcpyn(szIconFile, szValue, cchMax);
	return S_OK;
    }
    return E_FAIL;
}

HRESULT CTemplateUIObj::GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    *pwFlags = GIL_PERCLASS;	// Always per-class

    TCHAR szKey[128];
    HRESULT hres = _KeyNameFromCLSID(_clsid, szKey, ARRAYSIZE(szKey));
    if (SUCCEEDED(hres))
    {
	//
	// First, look at "CLSID\{CLSID}\DefautlIcon"
	//
	hres = _GetDefaultIcon(szKey, szIconFile, cchMax, piIndex);
	if (FAILED(hres))
	{
	    //
	    // Then, look at "ProgID\DefaultIcon" to work-around a bug
	    //  of "Wave Sound".
	    //
    	    lstrcat(szKey, TEXT("\\ProgID"));
	    TCHAR szValue[MAX_PATH+40];
	    LONG dwSize = ARRAYSIZE(szValue);
	    if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
	    {
		hres = _GetDefaultIcon(szValue, szIconFile, cchMax, piIndex);
	    }
	}
    }
    return hres;
}

HRESULT CTemplateUIObj::Extract(
                           LPCTSTR pszFile, UINT          nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    return S_FALSE;
}

HRESULT CTemplateUIObj::Create(REFCLSID rclsid, REFIID riid, LPVOID* ppvOut)
{
    CTemplateUIObj *pti = new CTemplateUIObj(rclsid);
    HRESULT hres;
    if (pti) {
        hres = pti->QueryInterface(riid, ppvOut);
        pti->Release();
        return hres;
    }

    *ppvOut=NULL;
    return E_OUTOFMEMORY;
}

//==========================================================================
// CTemplateUIObj members (IDataObject override)
//==========================================================================

HRESULT CTemplateUIObj::_CreateInstance(IStorage* pstg)
{
    HRESULT hres;
    IPersistStorage* pps = NULL;
    hres = OleCreate(_clsid, IID_IPersistStorage, OLERENDER_DRAW,
                     NULL, NULL, pstg, (LPVOID*)&pps);
    DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleCreate returned (%x)"), hres);

    if (SUCCEEDED(hres))
    {
        hres = OleSave(pps, pstg, TRUE);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI OleSave returned (%x)"), hres);
        pps->HandsOffStorage();
        pps->Release();

        if (SUCCEEDED(hres))
        {
            hres = pstg->Commit(STGC_OVERWRITE);
            DebugMsg(DM_TRACE, TEXT("so TR - TUO:CI pstg->Commit returned (%x)"), hres);
        }
    }

    return hres;
}

HRESULT CTemplateUIObj::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        IStorage* pstg = NULL;
        hres = StgCreateDocfile(NULL, STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pstg);
        DebugMsg(DM_TRACE, TEXT("so TR - TUO:GD StgCreateDocfile returned (%x)"), hres);
        if (SUCCEEDED(hres))
        {
            hres = _CreateInstance(pstg);
            if (SUCCEEDED(hres)) {
                pmedium->tymed = TYMED_ISTORAGE;
                pmedium->pstg = pstg;
            } else {
                pstg->Release();
            }
        }
    }
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
	&& pformatetcIn->tymed == TYMED_HGLOBAL)
    {
	DebugMsg(DM_TRACE, TEXT("so TR - TUO:GD cfFormat==CF_OBJECTDESCRIPTOR"));

	static WCHAR szUserTypeName[] = L"Foo";	// REARCHITECT: this code is really miss, and might end up returning Foo
	static WCHAR szSrcOfCopy[] = L"Bar";
	UINT cbUserTypeName = sizeof(szUserTypeName);
	UINT cbSrcOfCopy = sizeof(szSrcOfCopy);
	pmedium->hGlobal = GlobalAlloc(GPTR, sizeof(OBJECTDESCRIPTOR)+cbUserTypeName+cbSrcOfCopy);
	if (pmedium->hGlobal)
	{
	    OBJECTDESCRIPTOR* podsc = (OBJECTDESCRIPTOR*)pmedium->hGlobal;
	    podsc->cbSize = sizeof(OBJECTDESCRIPTOR);
	    podsc->clsid = _clsid;
	    podsc->dwDrawAspect = 0; // The source does not draw the object
	    // podsc->sizel = { 0, 0 }; // The source does not draw the object
	    // podsc->pointl = { 0, 0 };
	    podsc->dwStatus = 0; // FEATURE: read it from registry! CLSID/MiscStatus
	    podsc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
	    podsc->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR)+cbUserTypeName;
	    LPBYTE pbT = (LPBYTE)(podsc+1);
            lstrcpyW((LPWSTR)pbT, szUserTypeName);
            lstrcpyW((LPWSTR)(pbT+cbUserTypeName), szSrcOfCopy);
	    Assert(pbT == ((LPBYTE)podsc)+podsc->dwFullUserTypeName);
	    Assert(pbT+cbUserTypeName == ((LPBYTE)podsc)+podsc->dwSrcOfCopy);

	    pmedium->tymed = TYMED_HGLOBAL;
	    hres = S_OK;
	}
	else
	{
	    hres = E_OUTOFMEMORY;
	}
    }
    return hres;
}

HRESULT CTemplateUIObj::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT hres = DATA_E_FORMATETC;

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _CreateInstance(pmedium->pstg);
    }

    return hres;
}

HRESULT CTemplateUIObj::QueryGetData(LPFORMATETC pformatetcIn)
{
    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE)
    {
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
	&& pformatetcIn->tymed == TYMED_HGLOBAL)
    {
	return S_OK;
    }
    return DATA_E_FORMATETC;
}

HRESULT CTemplateUIObj::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CTemplateUIObj::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    return E_FAIL;
}

HRESULT CTemplateUIObj::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    static FORMATETC s_afmt[] = { { (CLIPFORMAT)CF_EMBEDDEDOBJECT }, {(CLIPFORMAT)CF_OBJECTDESCRIPTOR} };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(s_afmt), s_afmt, ppenumFormatEtc);
}

HRESULT CTemplateUIObj::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CTemplateUIObj::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

#define TIDC_INVALID    -1
#define TIDC_COPY	0
#define TIDC_MAX	1

HRESULT CTemplateUIObj::QueryContextMenu(
                    HMENU hmenu,
                    UINT indexMenu,
                    UINT idCmdFirst,
                    UINT idCmdLast,
                    UINT uFlags)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::QCM called (uFlags=%x)"), uFlags);

    //
    // REVIEW: Checking CMF_DVFILE is subtle, need to be documented clearly!
    //
    if (!(uFlags & (CMF_VERBSONLY|CMF_DVFILE)))
    {
	MENUITEMINFO mii = {
	    sizeof(MENUITEMINFO),
	    MIIM_STATE|MIIM_ID|MIIM_TYPE,
	    MFT_STRING,
	    MFS_DEFAULT,
	    idCmdFirst+TIDC_COPY,
	    NULL, NULL, NULL, 0,
	    TEXT("&Copy"),	// FEATURE: Support NLS, the Copy operation might have a different name in other languages
	    5
	};
	InsertMenuItem(hmenu, indexMenu++, TRUE, &mii);
    }
    return ResultFromShort(TIDC_MAX);
}

HRESULT CTemplateUIObj::InvokeCommand(
                 LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT hres;
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::IC called (%x)"), lpici->lpVerb);
    int idCmd = TIDC_INVALID;

    if (HIWORD(lpici->lpVerb))
    {
	if (lstrcmpiA(lpici->lpVerb, "copy") == 0) {
	    idCmd = TIDC_COPY;
	}
    }
    else
    {
	idCmd = LOWORD(lpici->lpVerb);
    }

    switch(idCmd)
    {
    case TIDC_COPY:
	hres = OleSetClipboard(this);
	break;

    default:
	hres = E_INVALIDARG;
	break;
    }

    return hres;
}

HRESULT CTemplateUIObj::GetCommandString(
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    DebugMsg(DM_TRACE, TEXT("sc TR - CTUI::GCS called (%d, %x)"), idCmd, uType);
    return E_NOTIMPL;
}

#endif // FEATURE_SHELLEXTENSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\scdata.cpp ===
#include "shole.h"
#include "ids.h"

#define INITGUID
#include <initguid.h>
#include "scguid.h"
#include <strsafe.h>

// #define SAVE_OBJECTDESCRIPTOR

extern "C" const WCHAR c_wszDescriptor[];

CLIPFORMAT _GetClipboardFormat(UINT id)
{
    static UINT s_acf[CFID_MAX] = { 0 };
    static const TCHAR * const c_aszFormat[CFID_MAX] = {
            TEXT("Embedded Object"),
            TEXT("Object Descriptor"),
            TEXT("Link Source Descriptor"),
            TEXT("Rich Text Format"),
            TEXT("Shell Scrap Object"),
            TEXT("TargetCLSID"),
            TEXT("Rich Text Format"),
            };
    if (!s_acf[id])
    {
        s_acf[id] = RegisterClipboardFormat(c_aszFormat[id]);
    }
    return (CLIPFORMAT)s_acf[id];
}

//===========================================================================
// CScrapData : Class definition
//===========================================================================

class CScrapData : public IDataObject, public IPersistFile
#ifdef FEATURE_SHELLEXTENSION
    , public IExtractIcon
#ifdef UNICODE
    , public IExtractIconA
#endif // UNICODE
#endif // FEATURE_SHELLEXTENSION
{
public:
    CScrapData();
    ~CScrapData();

    // IUnKnown
    virtual HRESULT __stdcall QueryInterface(REFIID,void **);
    virtual ULONG   __stdcall AddRef(void);
    virtual ULONG   __stdcall Release(void);

    // IDataObject
    virtual HRESULT __stdcall GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    virtual HRESULT __stdcall QueryGetData(FORMATETC *pformatetc);
    virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    virtual HRESULT __stdcall SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    virtual HRESULT __stdcall DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT __stdcall DUnadvise(DWORD dwConnection);
    virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT __stdcall IsDirty(void);

#ifdef FEATURE_SHELLEXTENSION
    // IExtractIcon
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPTSTR  szIconFile,
                         UINT   cchMax, int *piIndex, UINT *pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCTSTR pszFile, UINT nIconIndex,
			   HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

#ifdef UNICODE
    // IExtractIconA
    virtual HRESULT __stdcall GetIconLocation(
                         UINT   uFlags, LPSTR  szIconFile,
                         UINT   cchMax, int *piIndex, UINT *pwFlags);

    virtual HRESULT __stdcall Extract(
                           LPCSTR pszFile, UINT nIconIndex,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
#endif // UNICODE
#endif // FEATURE_SHELLEXTENSION

    // IPersistFile
    virtual HRESULT __stdcall GetClassID(CLSID *pClassID);
    virtual HRESULT __stdcall Load(LPCOLESTR pszFileName, DWORD dwMode);
    virtual HRESULT __stdcall Save(LPCOLESTR pszFileName, BOOL fRemember);
    virtual HRESULT __stdcall SaveCompleted(LPCOLESTR pszFileName);
    virtual HRESULT __stdcall GetCurFile(LPOLESTR *ppszFileName);

protected:
    HRESULT _OpenStorage(void);
    void    _CloseStorage(BOOL fResetFlags);
    INT     _GetFormatIndex(UINT cf);
    void    _FillCFArray(void);
#ifdef FIX_ROUNDTRIP
    HRESULT _RunObject(void);
#endif // FIX_ROUNDTRIP

#ifdef SAVE_OBJECTDESCRIPTOR
    HRESULT _GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere);
#endif // SAVE_OBJECTDESCRIPTOR

    UINT         _cRef;
    BOOL         _fDoc:1;
    BOOL         _fItem:1;
    BOOL         _fObjDesc:1;
    BOOL         _fClsidTarget:1;
#ifdef FIX_ROUNDTRIP
    BOOL         _fRunObjectAlreadyCalled:1;
    LPDATAOBJECT _pdtobjItem;
#endif // FIX_ROUNDTRIP
    LPSTORAGE    _pstgDoc;
    LPSTORAGE    _pstgItem;
    LPSTREAM     _pstmObjDesc;
    TCHAR        _szPath[MAX_PATH];
    CLSID        _clsidTarget;
    INT          _ccf;          // number of clipboard format.
    INT          _icfCacheMax;  // Max cache format index
    DWORD        _acf[64];      // 64 must be enough!
};

//===========================================================================
// CScrapData : Constructor
//===========================================================================
CScrapData::CScrapData(void) : _cRef(1)
{
    ASSERT(_pstgDoc == NULL);
    ASSERT(_pstgItem == NULL);
    ASSERT(_fDoc == FALSE);
    ASSERT(_fItem == FALSE);
    ASSERT(_fObjDesc == FALSE);
    ASSERT(_ccf == 0);
    ASSERT(_fClsidTarget == FALSE);
#ifdef FIX_ROUNDTRIP
    ASSERT(_pdtobjItem == NULL);
    ASSERT(_fRunObjectAlreadyCalled == FALSE);
#endif // FIX_ROUNDTRIP
    ASSERT(_pstmObjDesc == NULL);

    _szPath[0] = TEXT('\0');
    g_cRefThisDll++;
}

CScrapData::~CScrapData()
{
#ifdef FIX_ROUNDTRIP
    if (_pdtobjItem) {
        _pdtobjItem->Release();
    }
#endif // FIX_ROUNDTRIP
    _CloseStorage(FALSE);
    g_cRefThisDll--;
}
//===========================================================================
// CScrapData : Member functions (private)
//===========================================================================
//
// private member CScrapData::_OpenStorage
//
HRESULT CScrapData::_OpenStorage(void)
{
    if (_pstgItem) {
        return S_OK;
    }

    HRESULT hres;
    WCHAR wszFile[MAX_PATH];

    hres = StringCchCopy(wszFile, ARRAYSIZE(wszFile), _szPath);
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetStorage is called (%s)"), wszFile);
#endif
    if (SUCCEEDED(hres))
    {
        hres = StgOpenStorage(wszFile, NULL,
                            STGM_READ | STGM_SHARE_DENY_WRITE,
                            NULL, 0, &_pstgDoc);
        if (SUCCEEDED(hres))
        {
            _fDoc = TRUE;
            hres = _pstgDoc->OpenStorage(c_wszContents, NULL,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                NULL, 0, &_pstgItem);
            if (SUCCEEDED(hres))
            {
                HRESULT hresT;
                _fItem = TRUE;
    #ifdef SAVE_OBJECTDESCRIPTOR
                hresT = _pstgDoc->OpenStream(c_wszDescriptor, 0,
                                    STGM_READ | STGM_SHARE_EXCLUSIVE,
                                    0, &_pstmObjDesc);
                _fObjDesc = SUCCEEDED(hresT);
    #endif // SAVE_OBJECTDESCRIPTOR
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage failed (%x)"), hres);
                _pstgDoc->Release();
                _pstgDoc = NULL;
            }
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage StgOpenStorage failed (%x)"), hres);
        }
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_OpenStorage _pstgDoc->OpenStorage returning (%x) %x"),
                hres, _pstmObjDesc);
    return hres;
}

void CScrapData::_CloseStorage(BOOL fResetFlags)
{
#ifdef DEBUG
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::CloseStorage"));
#endif

    if (_pstgItem) {
        _pstgItem->Release();
        _pstgItem = NULL;
    }
    if (_pstmObjDesc) {
        _pstmObjDesc->Release();
        _pstmObjDesc = NULL;
    }
    if (_pstgDoc) {
        _pstgDoc->Release();
        _pstgDoc = NULL;
    }

    if (fResetFlags) {
        _fItem = FALSE;
        _fObjDesc = FALSE;
        _fDoc = FALSE;
    }
}

INT CScrapData::_GetFormatIndex(UINT cf)
{
    for (INT i=0; i<_ccf; i++)
    {
        if (_acf[i] == cf)
        {
            return i;
        }
    }
    return -1;
}

#ifdef FIX_ROUNDTRIP
extern "C" const TCHAR c_szRenderFMT[] = TEXT("DataFormats\\DelayRenderFormats");
#endif // FIX_ROUNDTRIP

extern "C" const WCHAR c_wszFormatNames[];

//
//  This function filles the clipboard format array (_acf). Following
// clipboard format may be added.
//
// Step 1. CF_EMBEEDEDOBJECT
// Step 2. CF_OBJECTDESCRIPTOR
// Step 3. CF_SCRAPOBJECT
// Step 4. Cached clipboard formats (from a stream).
// Step 5. Delay Rendered clipbaord formats (from registry).
//
void CScrapData::_FillCFArray(void)
{
    _ccf=0;
    //
    // Step 1.
    //
    if (_fItem) {
        _acf[_ccf++] = CF_EMBEDDEDOBJECT;
    }

    //
    // Step 2.
    //
    if (_fObjDesc) {
        _acf[_ccf++] = CF_OBJECTDESCRIPTOR;
    }

    //
    // Step 3.
    //
    if (_fDoc)
    {
        _acf[_ccf++] = CF_SCRAPOBJECT;
    }

#ifdef FIX_ROUNDTRIP

    HRESULT hres = _OpenStorage();

    if (SUCCEEDED(hres) && _pstgItem)
    {
        //
        // Step 3. Cached clipboard formats
        //
        //
        // Open the stream which contains the names of cached formats.
        //
        LPSTREAM pstm;
        HRESULT hres = _pstgDoc->OpenStream(c_wszFormatNames, NULL,
                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                NULL, &pstm);

        if (SUCCEEDED(hres))
        {
            //
            // For each cached format...
            //
            USHORT cb;
            DWORD cbRead;
            while(SUCCEEDED(pstm->Read(&cb, SIZEOF(cb), &cbRead)) && cbRead==SIZEOF(cb)
                  && cb && cb<128)
            {
                UINT cf = 0;

                //
                // Get the cached clipboard format name
                //
                CHAR szFormat[128];
                szFormat[cb] = '\0';
                hres = pstm->Read(szFormat, cb, &cbRead);
                if (SUCCEEDED(hres) && cbRead==cb && lstrlenA(szFormat)==cb)
                {
                    //
                    // Append it to the array.
                    //
                    TCHAR wszFormat[128];
                    MultiByteToWideChar(CP_ACP, 0,
                                        szFormat, -1,
                                        wszFormat, ARRAYSIZE(wszFormat));
                    DebugMsg(DM_TRACE, TEXT("sc TR _FillCFA Found Cached Format %s"), wszFormat);
                    cf = RegisterClipboardFormatA(szFormat);

                    if (cf)
                    {
                        _acf[_ccf++] = cf;
                    }
                }
                else
                {
                    break;
                }
            }
            pstm->Release();
        }

        _icfCacheMax = _ccf;

        //
        // Step 4. Get the list of delay-rendered clipboard formats
        //
        LPPERSISTSTORAGE pps;
        hres = OleLoad(_pstgItem, IID_IPersistStorage, NULL, (LPVOID *)&pps);
        if (SUCCEEDED(hres))
        {
            //
            // Get the CLSID of embedding.
            //
            CLSID clsid;
            hres = pps->GetClassID(&clsid);
            if (SUCCEEDED(hres))
            {
                //
                // Open the key for delay-rendered format names.
                //
                extern HKEY _OpenCLSIDKey(REFCLSID rclsid, LPCTSTR pszSubKey);
                HKEY hkey = _OpenCLSIDKey(clsid, c_szRenderFMT);
                if (hkey)
                {
                    TCHAR szValueName[128];
                    //
                    // For each delay-rendered clipboard format...
                    //
                    for(int iValue=0; ;iValue++)
                    {
                        //
                        // Get the value name, which is the format name.
                        //
                        DWORD cchValueName = ARRAYSIZE(szValueName);
                        DWORD dwType;
                        if (RegEnumValue(hkey, iValue, szValueName, &cchValueName, NULL,
                                         &dwType, NULL, NULL)==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s, %x"), szValueName, dwType);
                            UINT cf = RegisterClipboardFormat(szValueName);

                            if (cf)
                            {
                                _acf[_ccf++] = cf;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    // HACK: NT 3.5's regedit does not support named value...
                    //
                    for(iValue=0; ;iValue++)
                    {
                        TCHAR szKeyName[128];
                        //
                        // Get the value name, which is the format name.
                        //
                        if (RegEnumKey(hkey, iValue, szKeyName, ARRAYSIZE(szKeyName))==ERROR_SUCCESS)
                        {
                            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_FillCFA RegEnumValue found %s"), szValueName);
                            LONG cbValue = ARRAYSIZE(szValueName);
                            if ((RegQueryValue(hkey, szKeyName, szValueName, &cbValue)==ERROR_SUCCESS) && cbValue)
                            {
                                UINT cf = RegisterClipboardFormat(szValueName);

                                if (cf)
                                {
                                    _acf[_ccf++] = cf;
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    RegCloseKey(hkey);
                }
            }
            pps->Release();
        }
    }
#endif // FIX_ROUNDTRIP
}

#ifdef FIX_ROUNDTRIP
//
// private member CScrapData::_RunObject
//
HRESULT CScrapData::_RunObject(void)
{
    if (_pdtobjItem) {
        return S_OK;
    }

    if (_fRunObjectAlreadyCalled) {
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject returning E_FAIL"));
        return E_FAIL;
    }
    _fRunObjectAlreadyCalled = TRUE;

    HRESULT hres = _OpenStorage();

    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject _OpenStorage returned %x"), hres);

    if (SUCCEEDED(hres) && _pstgItem)
    {
        LPOLEOBJECT pole;
        hres = OleLoad(_pstgItem, IID_IOleObject, NULL, (LPVOID *)&pole);
        DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleLoad returned %x"), hres);
        if (SUCCEEDED(hres))
        {
            DWORD dw=GetCurrentTime();
            hres = OleRun(pole);
            dw = GetCurrentTime()-dw;
            DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject OleRun returned %x (%d msec)"), hres, dw);
            if (SUCCEEDED(hres))
            {
                hres = pole->GetClipboardData(0, &_pdtobjItem);
                DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject GetClipboardData returned %x"), hres);
                if (FAILED(hres))
                {
                    hres = pole->QueryInterface(IID_IDataObject, (LPVOID*)&_pdtobjItem);
                    DebugMsg(DM_TRACE, TEXT("sc TR CSD::_RunObject QI(IID_IDataIbject) returned %x"), hres);
                }
            }
            pole->Release();
        }
    }

    return hres;
}
#endif // FIX_ROUNDTRIP

//===========================================================================
// CScrapData : Member functions (virtual IDataObject)
//===========================================================================
HRESULT CScrapData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IDataObject) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (LPDATAOBJECT)this;
        _cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtractIcon))
    {
        *ppvObj = (IExtractIcon*)this;
        _cRef++;
        return S_OK;
    }
#ifdef UNICODE
    else if (IsEqualIID(riid, IID_IExtractIconA))
    {
        *ppvObj = (IExtractIconA*)this;
        _cRef++;
        return S_OK;
    }
#endif
    else if (IsEqualIID(riid, IID_IPersistFile))
    {
        *ppvObj = (LPPERSISTFILE)this;
        _cRef++;
        return S_OK;
    }
    *ppvObj = NULL;

    return E_NOINTERFACE;
}

ULONG CScrapData::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CScrapData::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::Release deleting this object"));
    delete this;
    return 0;
}


#ifdef SAVE_OBJECTDESCRIPTOR
HRESULT CScrapData::_GetObjectDescriptor(LPSTGMEDIUM pmedium, BOOL fGetHere)
{
    if (!_pstmObjDesc)
        return DATA_E_FORMATETC;

    LARGE_INTEGER dlib = { 0, 0 };
    HRESULT hres = _pstmObjDesc->Seek(dlib, STREAM_SEEK_SET, NULL);
    if (FAILED(hres))
        return hres;

    OBJECTDESCRIPTOR ods;
    ULONG cbRead;
    hres = _pstmObjDesc->Read(&ods.cbSize, SIZEOF(ods.cbSize), &cbRead);
    if (SUCCEEDED(hres) && cbRead == SIZEOF(ods.cbSize))
    {
        if (fGetHere)
        {
            if (GlobalSize(pmedium->hGlobal)<ods.cbSize) {
                hres = STG_E_MEDIUMFULL;
            }
        }
        else
        {
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE, ods.cbSize);
            hres = pmedium->hGlobal ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hres))
        {
            LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(pmedium->hGlobal);
            if (pods)
            {
                pods->cbSize = ods.cbSize;
                hres = _pstmObjDesc->Read(&pods->clsid, ods.cbSize-SIZEOF(ods.cbSize), NULL);
                GlobalUnlock(pmedium->hGlobal);
            }
            else
            {
                if (!fGetHere) {
                    GlobalFree(pmedium->hGlobal);
                    pmedium->hGlobal = NULL;
                }
                hres = E_OUTOFMEMORY;
            }
        }
    }

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::_GetObjectDescriptor returning (%x)"), hres);
    return hres;
}
#endif // SAVE_OBJECTDESCRIPTOR


HRESULT CScrapData::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    HRESULT hres;

    pmedium->pUnkForRelease = NULL;
    pmedium->pstg = NULL;

    //
    // NOTES: We should avoid calling _OpenStorage if we don't support
    //  the format.
    //

    //
    //  APP COMPAT!  Win95/NT4's shscrap.dll had a bug in that it checked
    //  the pformatetcIn->tymed's wrong.  The old scrap code accidentally
    //  used an equality test instead of a bit test.  YOU CANNOT FIX THIS
    //  BUG!  Micrografx Designer relies on it!
    //

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && (pformatetcIn->tymed == TYMED_ISTORAGE) && _fItem) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgItem->AddRef();
            pmedium->pstg = _pstgItem;
        }
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && (pformatetcIn->tymed == TYMED_ISTORAGE) && _fItem) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            pmedium->tymed = TYMED_ISTORAGE;
            _pstgDoc->AddRef();
            pmedium->pstg = _pstgDoc;
        }
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if (pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR
        && (pformatetcIn->tymed == TYMED_HGLOBAL) && _fObjDesc) // INTENTIONAL BUG! (see above)
    {
        hres = _OpenStorage();
        if (SUCCEEDED(hres))
        {
            hres = _GetObjectDescriptor(pmedium, FALSE);
        }
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else if (pformatetcIn->cfFormat == CF_TARGETCLSID
        && (pformatetcIn->tymed & TYMED_HGLOBAL) && _fClsidTarget)
    {
        pmedium->hGlobal = GlobalAlloc(GPTR, sizeof(_clsidTarget));
        if (pmedium->hGlobal)
        {
            CopyMemory(pmedium->hGlobal, &_clsidTarget, sizeof(_clsidTarget));
            pmedium->tymed = TYMED_HGLOBAL;
            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
    {
#ifdef FIX_ROUNDTRIP
        INT iFmt = _GetFormatIndex(pformatetcIn->cfFormat);

        if (iFmt != -1)
        {
            hres = _OpenStorage();
            if (FAILED(hres))
            {
                goto exit;
            }
        }

        if (iFmt>=_icfCacheMax)
        {
            //
            // Delayed Rendered format
            //
            if (SUCCEEDED(_RunObject()))
            {
                hres = _pdtobjItem->GetData(pformatetcIn, pmedium);
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called _pdtobjItem->GetData %x"), hres);
                return hres;
            }
        }
        else if (iFmt >= 0)
        {
            //
            // Cached Format
            //
            extern HRESULT _GetCacheStreamName(LPCTSTR pszFormat, LPWSTR wszStreamName, UINT cchMax);
            TCHAR szFormat[128];
            if (pformatetcIn->cfFormat < CF_MAX) 
            {
                hres = StringCchPrintf(szFormat, ARRAYSIZE(szFormat), TEXT("#%d"), pformatetcIn->cfFormat);
            } 
            else 
            {
                hres = S_OK;
                GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
            }

            if (SUCCEEDED(hres))
            {
                WCHAR wszStreamName[256];
                hres = _GetCacheStreamName(szFormat, wszStreamName, ARRAYSIZE(wszStreamName));
                if (SUCCEEDED(hres))
                {
                    if (pformatetcIn->cfFormat==CF_METAFILEPICT
                        || pformatetcIn->cfFormat==CF_ENHMETAFILE
                        || pformatetcIn->cfFormat==CF_BITMAP
                        || pformatetcIn->cfFormat==CF_PALETTE
                        )
                    {
                        LPSTORAGE pstg;
                        hres = _pstgDoc->OpenStorage(wszStreamName, NULL,
                                            STGM_READ | STGM_SHARE_EXCLUSIVE,
                                            NULL, 0, &pstg);
                        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData OpenStorage returned (%x)"), hres);
                        if (SUCCEEDED(hres))
                        {
                            LPDATAOBJECT pdtobj;
                            const CLSID* pclsid = NULL;
                            switch(pformatetcIn->cfFormat)
                            {
                            case CF_METAFILEPICT:
                                pclsid = &CLSID_Picture_Metafile;
                                break;

                            case CF_ENHMETAFILE:
                                pclsid = &CLSID_Picture_EnhMetafile;
                                break;

                            case CF_PALETTE:
                            case CF_BITMAP:
                                pclsid = &CLSID_Picture_Dib;
                                break;
                            }

                            LPPERSISTSTORAGE ppstg;
                            hres = OleCreateDefaultHandler(*pclsid, NULL, IID_IPersistStorage, (LPVOID *)&ppstg);
                            DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF OleCreteDefHandler returned %x"), hres);
                            if (SUCCEEDED(hres))
                            {
                                hres = ppstg->Load(pstg);
                                DebugMsg(DM_TRACE, TEXT("sc TR Scrap_CacheOPF ppstg->Load returned %x"), hres);
                                if (SUCCEEDED(hres))
                                {
                                    hres = ppstg->QueryInterface(IID_IDataObject, (LPVOID*)&pdtobj);
                                }
                            }
                            if (SUCCEEDED(hres))
                            {
                                hres = pdtobj->GetData(pformatetcIn, pmedium);
                                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData pobj->GetData returned (%x)"), hres);
                                pdtobj->Release();
                            }

                            // Must defer HandsOffStorage until after GetData
                            // or the GetData will fail!  And in fact, even if we defer
                            // it, the GetData *still* fails.  And if we don't call
                            // HandsOffStorage at all, THE GETDATA STILL FAILS.
                            // Bug 314308, OLE regression.
                            // I'm checking in at least this part of the fix so the OLE
                            // folks can debug it on their side.
                            if (ppstg)
                            {
                                ppstg->HandsOffStorage();
                                ppstg->Release();
                            }

                            pstg->Release();
                            return hres;
                        }
                        // fall through
                    }
                    else // if (pformatetcIn->cfFormat==CF_...)
                    {
                        LPSTREAM pstm;
                        hres = _pstgDoc->OpenStream(wszStreamName, NULL,
                                                STGM_READ | STGM_SHARE_EXCLUSIVE,
                                                0, &pstm);
                        if (SUCCEEDED(hres))
                        {
                            UINT cbData;
                            DWORD cbRead;
                            hres = pstm->Read(&cbData, SIZEOF(cbData), &cbRead);
                            if (SUCCEEDED(hres) && cbRead==SIZEOF(cbData))
                            {
                                LPBYTE pData = (LPBYTE)GlobalAlloc(GPTR, cbData);
                                if (pData)
                                {
                                    hres = pstm->Read(pData, cbData, &cbRead);
                                    if (SUCCEEDED(hres) && cbData==cbRead)
                                    {
                                        pmedium->tymed = TYMED_HGLOBAL;
                                        pmedium->hGlobal = (HGLOBAL)pData;
                                    }
                                    else
                                    {
                                        hres = E_UNEXPECTED;
                                        GlobalFree((HGLOBAL)pData);
                                    }
                                }
                                else
                                {
                                    hres = E_OUTOFMEMORY;
                                }
                            }
                            pstm->Release();

                            DebugMsg(DM_TRACE, TEXT("CSD::GetData(%s) returning %x"), szFormat, hres);
                            return hres;
                        }
                    }
                }
            }
        } // if (iFmt >= 0)
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

exit:

#ifdef DEBUG
    TCHAR szFormat[256];
    GetClipboardFormatName(pformatetcIn->cfFormat,
                           szFormat, ARRAYSIZE(szFormat));

    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetData called with %x,%x,%s and returning %x"),
                             pformatetcIn->cfFormat,
                             pformatetcIn->tymed,
                             szFormat, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetDataHere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium )
{
    HRESULT hres;

#ifdef DEBUG
    if (pformatetcIn->cfFormat<CF_MAX) {
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %x,%x,%x"),
                             pformatetcIn->cfFormat, pformatetcIn->tymed, pmedium->tymed);
    } else {
        TCHAR szName[256];
        GetClipboardFormatName(pformatetcIn->cfFormat, szName, ARRAYSIZE(szName));
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere called with %s,%x,%x"),
                             szName, pformatetcIn->tymed, pmedium->tymed);
    }
#endif

    hres = _OpenStorage();
    if (FAILED(hres)) {
        return hres;
    }

    if (pformatetcIn->cfFormat == CF_EMBEDDEDOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgItem->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
    else if (pformatetcIn->cfFormat == CF_SCRAPOBJECT
        && pformatetcIn->tymed == TYMED_ISTORAGE && pmedium->tymed == TYMED_ISTORAGE)
    {
        hres = _pstgDoc->CopyTo(0, NULL, NULL, pmedium->pstg);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere _pstgItem->CopyTo returned %x"), hres);
    }
#ifdef SAVE_OBJECTDESCRIPTOR
    else if ((pformatetcIn->cfFormat == CF_OBJECTDESCRIPTOR)
        && (pformatetcIn->tymed == TYMED_HGLOBAL) && _pstmObjDesc)
    {
        hres = _GetObjectDescriptor(pmedium, TRUE);
    }
#endif // SAVE_OBJECTDESCRIPTOR
    else
    {
#ifdef FIX_ROUNDTRIP
        if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0 && SUCCEEDED(_RunObject()))
        {
            DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GetDataHere calling _pdtobjItem->GetDataHere"));
            return _pdtobjItem->GetDataHere(pformatetcIn, pmedium);
        }
#endif // FIX_ROUNDTRIP
        hres = DATA_E_FORMATETC;
    }

    return hres;
}

HRESULT CScrapData::QueryGetData(LPFORMATETC pformatetcIn)
{
    HRESULT hres;
    if (_GetFormatIndex(pformatetcIn->cfFormat) >= 0) {
        hres = S_OK;
    } else {
        hres = DATA_E_FORMATETC;
    }

#ifdef DEBUG
    TCHAR szFormat[256] = TEXT("");
    GetClipboardFormatName(pformatetcIn->cfFormat, szFormat, ARRAYSIZE(szFormat));
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::QueryGetData(%x,%s,%x) returning %x"),
                    pformatetcIn->cfFormat, szFormat, pformatetcIn->tymed, hres);
#endif

    return hres;
}

HRESULT CScrapData::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    //
    //  This is the simplest implemtation. It means we always return
    // the data in the format requested.
    //
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}

HRESULT CScrapData::SetData(LPFORMATETC pformatetc, STGMEDIUM  * pmedium, BOOL fRelease)
{
    if (pformatetc->cfFormat == CF_TARGETCLSID && pmedium->tymed == TYMED_HGLOBAL)
    {
        CLSID *pclsid = (CLSID *)GlobalLock(pmedium->hGlobal);
        if (pclsid)
        {
            _clsidTarget = *pclsid;
            _fClsidTarget = TRUE;
            GlobalUnlock(pclsid);
            if (fRelease) {
                ReleaseStgMedium(pmedium);
            }

            /*
             *  Whenever anybody sets a drop target, close our storage handles
             *  so the drop target can move/delete us.  All our methods will
             *  reopen the storage as needed.
             */
            _CloseStorage(FALSE);
            return S_OK;
        }
    }

    return E_FAIL;
}

HRESULT CScrapData::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc)
{
    if (dwDirection!=DATADIR_GET) {
        return E_NOTIMPL; // Not supported (as documented)
    }

    if (_ccf==0) {
        return E_UNEXPECTED;
    }

    FORMATETC * pfmt = (FORMATETC*)LocalAlloc(LPTR, SIZEOF(FORMATETC)*_ccf);
    if (!pfmt) {
        return E_OUTOFMEMORY;
    }

    static const FORMATETC s_fmteInit =
    {
          0,
          (DVTARGETDEVICE __RPC_FAR *)NULL,
          DVASPECT_CONTENT,
          -1,
          TYMED_HGLOBAL         // HGLOBAL except CF_EMBEDDEDOBJECT/SCRAPOBJECT
     };

    //
    // Fills FORMATETC for each clipboard format.
    //
    for (INT i=0; i<_ccf; i++)
    {
        pfmt[i] = s_fmteInit;
        pfmt[i].cfFormat = (CLIPFORMAT)_acf[i];

        if (_acf[i]==CF_EMBEDDEDOBJECT || _acf[i]==CF_SCRAPOBJECT) {
            pfmt[i].tymed = TYMED_ISTORAGE;
        } else {
            switch(_acf[i])
            {
            case CF_METAFILEPICT:
                pfmt[i].tymed = TYMED_MFPICT;
                break;

            case CF_ENHMETAFILE:
                pfmt[i].tymed = TYMED_ENHMF;
                break;

            case CF_BITMAP:
            case CF_PALETTE:
                pfmt[i].tymed = TYMED_GDI;
                break;
            }
        }
    }

    HRESULT hres = SHCreateStdEnumFmtEtc(_ccf, pfmt, ppenumFormatEtc);
    LocalFree((HLOCAL)pfmt);

    return hres;
}

HRESULT CScrapData::DAdvise(FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::DUnadvise(DWORD dwConnection)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

HRESULT CScrapData::EnumDAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}


//===========================================================================
// CScrapData : Member functions (virtual IPersistFile)
//===========================================================================

HRESULT CScrapData::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CScrapData;
    return S_OK;
}

HRESULT CScrapData::IsDirty(void)
{
    return S_FALSE;     // meaningless (read only)
}

HRESULT CScrapData::Load(LPCOLESTR pwszFile, DWORD grfMode)
{
    //
    // Close all the storage (if there is any) and reset flags.
    //
    _CloseStorage(TRUE);

    //
    // Copy the new file name and open storage to update the flags.
    //
    HRESULT hres = StringCchCopy(_szPath, ARRAYSIZE(_szPath), pwszFile);
    if (SUCCEEDED(hres))
    {
        hres = _OpenStorage();
        _FillCFArray();

        //
        // Close all the storage, so that we can move/delete.
        //
        _CloseStorage(FALSE);
    }

    return hres;
}

HRESULT CScrapData::Save(LPCOLESTR pwszFile, BOOL fRemember)
{
    return E_FAIL;      // read only
}

HRESULT CScrapData::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

HRESULT CScrapData::GetCurFile(LPOLESTR *lplpszFileName)
{
    return E_NOTIMPL;   // nobody needs it
}

#ifdef FEATURE_SHELLEXTENSION

HRESULT CScrapData::GetIconLocation(
                         UINT   uFlags, LPTSTR szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    HRESULT hres = _OpenStorage();
    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL OpenStorage returned %x"), hres);

    if (SUCCEEDED(hres))
    {
	    STGMEDIUM medium;
	    hres = _GetObjectDescriptor(&medium, FALSE);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL _GetOD returned %x"), hres);
	    if (SUCCEEDED(hres))
	    {
                LPOBJECTDESCRIPTOR pods = (LPOBJECTDESCRIPTOR)GlobalLock(medium.hGlobal);
	        TCHAR szKey[128];
	        hres = _KeyNameFromCLSID(pods->clsid, szKey, ARRAYSIZE(szKey));
                DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL _KNFC returned %x"), hres);
	        if (SUCCEEDED(hres))
	        {
		        lstrcatn(szKey, TEXT("\\DefaultIcon"), ARRAYSIZE(szKey));
		        TCHAR szValue[MAX_PATH+40];
		        LONG dwSize = sizeof(szValue);
		        if (RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &dwSize) == ERROR_SUCCESS)
		        {
		            *pwFlags = GIL_PERINSTANCE | GIL_NOTFILENAME;
		            *piIndex = _ParseIconLocation(szValue);
		            TCHAR szT[MAX_PATH];
		            hres = StringCchPrintf(szT, ARRAYSIZE(szT), TEXT("shscrap.dll,%s"), szValue);
                    if (SUCCEEDED(hres))
                    {
		                hres = StringCchCopy(szIconFile, cchMax, szT);
                        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL Found Icon Location %s,%d"), szIconFile, *piIndex);
                    }
		            hres = S_OK;
		        }
		        else
		        {
                    DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL RegQueryValue for CLSID failed (%s)"), szKey);
		            hres = E_FAIL;
		        }
	        }

            GlobalUnlock(medium.hGlobal);
	        ReleaseStgMedium(&medium);
	    }
    }

    //
    // If Getting CLSID failed, return a generic scrap icon as per-instance
    // icon to avoid re-opening this file again.
    //
    if (FAILED(hres))
    {
        GetModuleFileName(HINST_THISDLL, szIconFile, cchMax);
        DebugMsg(DM_TRACE, TEXT("sc TR - CSD::GIL Returning default icon (%s)"), szIconFile);
	    *piIndex = -IDI_ICON;
	    *pwFlags = GIL_PERINSTANCE;
	    hres = S_OK;
    }

    return hres;	// This value is always S_OK
}


#ifdef UNICODE
HRESULT CScrapData::GetIconLocation(
                         UINT   uFlags, LPSTR szIconFile,
                         UINT   cchMax, int   * piIndex,
                         UINT  * pwFlags)
{
    WCHAR szPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szPath, ARRAYSIZE(szPath), piIndex, pwFlags);
    if (SUCCEEDED(hr)) {
        SHUnicodeToAnsi(szPath, szIconFile, cchMax);
    }
    return hr;
}
#endif
#endif // FEATURE_SHELLEXTENSION

HICON _SimulateScrapIcon(HICON hiconClass, UINT cxIcon)
{
    //
    // First load the template image.
    //
    HICON hiconTemplate = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_SCRAP),
				    IMAGE_ICON, cxIcon, cxIcon, LR_DEFAULTCOLOR);
    if (!hiconTemplate) {
	return NULL;
    }
    ICONINFO ii;
    GetIconInfo(hiconTemplate, &ii);


    HDC hdc = GetDC(NULL);
    HDC hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    HBITMAP hbmT = (HBITMAP)SelectObject(hdcMem, ii.hbmColor);

    // This assumes the generic icon is white
    PatBlt(hdcMem, cxIcon/4-1, cxIcon/4-1, cxIcon/2+2, cxIcon/2+2, WHITENESS);
    DrawIconEx(hdcMem, cxIcon/4, cxIcon/4, hiconClass, cxIcon/2, cxIcon/2, 0, NULL, DI_NORMAL);

    SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    //
    // Create the icon image to return
    //
    ii.fIcon    = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    HICON hicon = CreateIconIndirect(&ii);

    DeleteObject(ii.hbmColor);
    DeleteObject(ii.hbmMask);

    return hicon;
}

#ifdef FEATURE_SHELLEXTENSION

HRESULT CScrapData::Extract(
                           LPCTSTR pszFile, UINT	  nIconIndex,
			   HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    LPCTSTR pszComma = StrChr(pszFile, ',');

    if (pszComma++)
    {
#if 1
	HICON hiconSmall;
	UINT i = ExtractIconEx(pszComma, nIconIndex, NULL, &hiconSmall, 1);
	if (i != -1)
	{
	    if (phiconLarge) {
    		*phiconLarge = _SimulateScrapIcon(hiconSmall, LOWORD(nIconSize));
	    }
	    if (phiconSmall) {
    		*phiconSmall = _SimulateScrapIcon(hiconSmall, HIWORD(nIconSize));
	    }

	    DestroyIcon(hiconSmall);
	}
#else
    	UINT i;
	// Assumes shell icon sizes are def icon sizes
	i = ExtractIconEx(pszComma, nIconIndex, phiconLarge, phiconSmall, 1);
	DebugMsg(DM_TRACE, TEXT("sc TR - CSD::Ext ExtractIconEx(%s) returns %d)"), pszComma, i);
	return S_OK;
#endif
    }

    return E_INVALIDARG;
}

#ifdef UNICODE
HRESULT CScrapData::Extract(
                           LPCSTR pszFile, UINT   nIconIndex,
                           HICON   *phiconLarge, HICON   *phiconSmall,
                           UINT    nIconSize)
{
    WCHAR szPath[MAX_PATH];
    SHAnsiToUnicode(pszFile, szPath, ARRAYSIZE(szPath));
    return Extract(szPath, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
#endif
#endif // FEATURE_SHELLEXTENSION

HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk)
{
//
//  This test code is unrelated to the scrap itself. It just verifies that
// CLSID_ShellLink is correctly registered.
//
#ifdef DEBUG
    LPUNKNOWN punk = NULL;
    HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL,
                    CLSCTX_INPROC, IID_IShellLink, (LPVOID*)&punk);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    DebugMsg(DM_TRACE, TEXT("CoCreateInstance returned %x"), hres);
    DebugMsg(DM_TRACE, TEXT("###############################################"));
    if (SUCCEEDED(hres)) {
        punk->Release();
    }
#endif

    CScrapData* pscd = new CScrapData();
    if (pscd) {
        *ppunk = (LPDATAOBJECT)pscd;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shscrap\shole.h ===
//Prevent windows.h from pulling in OLE 1
#define _INC_OLE

#include <windows.h>
#include <stdlib.h>
#include <shlwapi.h>        // must be before commctrl.h and shlobj.h
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
#include <shsemip.h>

#include <ole2ver.h>
#include <shellp.h>     // in shell\inc
#include <debug.h>      // in shell\inc
#include <shguidp.h>    // in shell\inc
#include <shlwapip.h>   // for string helper functions

#define SAVE_OBJECTDESCRIPTOR
#define FIX_ROUNDTRIP

#define CCF_CACHE_GLOBAL        32
#define CCF_CACHE_CLSID         32
#define CCF_RENDER_CLSID        32
#define CCFCACHE_TOTAL  (CC_FCACHE_GLOBAL+CCF_CACHE_CLSID+CCF_RENDER_CLSID)


HRESULT CScrapData_CreateInstance(LPUNKNOWN * ppunk);
HRESULT CTemplateFolder_CreateInstance(LPUNKNOWN * ppunk);
HRESULT CScrapExt_CreateInstance(LPUNKNOWN * ppunk);

//
// global variables
//
extern LONG g_cRefThisDll;              // per-instance
extern HINSTANCE g_hinst;
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#ifdef __cplusplus
extern "C" {
#endif

extern const WCHAR c_wszContents[];
extern const WCHAR c_wszDescriptor[];

#ifdef __cplusplus
};

#endif

#define HINST_THISDLL g_hinst



#define CFID_EMBEDDEDOBJECT     0
#define CFID_OBJECTDESCRIPTOR   1
#define CFID_LINKSRCDESCRIPTOR  2
#define CFID_RICHTEXT           3
#define CFID_SCRAPOBJECT        4
#define CFID_TARGETCLSID        5
#define CFID_RTF                6
#define CFID_MAX                7

#define CF_EMBEDDEDOBJECT       _GetClipboardFormat(CFID_EMBEDDEDOBJECT)
#define CF_OBJECTDESCRIPTOR     _GetClipboardFormat(CFID_OBJECTDESCRIPTOR)
#define CF_LINKSRCDESCRIPTOR    _GetClipboardFormat(CFID_LINKSRCDESCRIPTOR)
#define CF_RICHTEXT             _GetClipboardFormat(CFID_RICHTEXT)
#define CF_SCRAPOBJECT          _GetClipboardFormat(CFID_SCRAPOBJECT)
#define CF_TARGETCLSID          _GetClipboardFormat(CFID_TARGETCLSID)
#define CF_RTF                  _GetClipboardFormat(CFID_RTF)

CLIPFORMAT _GetClipboardFormat(UINT id);
void DisplayError(HWND hwndOwner, HRESULT hres, UINT idsMsg, LPCTSTR szFileName);

// From shole.c
void CShClientSite_RegisterClass();
IOleClientSite* CShClientSite_Create(HWND hwnd, LPCTSTR pszFileName);
void CShClientSite_Release(IOleClientSite* pcli);

// From template.cpp
HRESULT _KeyNameFromCLSID(REFCLSID rclsid, LPTSTR pszKey, UINT cchMax);
int _ParseIconLocation(LPTSTR pszIconFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\cfact.h ===
class CSysTrayFactory: public IClassFactory
{
public:
    // IUnknown Implementation
    HRESULT __stdcall QueryInterface(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IOleCommandTarget Implementation
    HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject);
    HRESULT __stdcall LockServer(BOOL fLock);

    CSysTrayFactory(BOOL fRunTrayOnConstruct);
    ~CSysTrayFactory();
private:
    // Data
    long m_cRef;
    BOOL m_fRunTrayOnConstruct;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\cfact.cpp ===
#include "stdafx.h"
#include "cfact.h"
#include "stobject.h"

/************************************************************************************
IUnknown Implementation

************************************************************************************/

HRESULT CSysTrayFactory::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if ((iid == IID_IClassFactory) || (iid == IID_IUnknown))
    {
        *ppvObject = (IClassFactory*) this;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == S_OK)
    {
        ((IUnknown*) (*ppvObject))->AddRef();
    }

    return hr;
}

ULONG CSysTrayFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CSysTrayFactory::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

/************************************************************************************
IClassFactory Implementation

************************************************************************************/
HRESULT CSysTrayFactory::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    
    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        CSysTray* ptray = new CSysTray(m_fRunTrayOnConstruct);

        if (ptray != NULL)
        {
            hr = ptray->QueryInterface(iid, ppvObject);
            ptray->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CSysTrayFactory::LockServer(BOOL fLock)
{
    if (fLock) 
    {
        InterlockedIncrement(&g_cLocks);
    }
    else
    {
        ASSERT( 0 != g_cLocks );
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

/************************************************************************************
Constructor/Destructor Implementation

************************************************************************************/

CSysTrayFactory::CSysTrayFactory(BOOL fRunTrayOnConstruct)
{
    m_fRunTrayOnConstruct = fRunTrayOnConstruct;
    m_cRef = 1;
    InterlockedIncrement(&g_cLocks);
}

CSysTrayFactory::~CSysTrayFactory()
{
    ASSERT( 0 != g_cLocks );
    InterlockedDecrement(&g_cLocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\csc.c ===
#include "stdafx.h"
#include "systray.h"
#include <cscuiext.h>
///////////////////////////////////////////////////////////////////////////////
// CSC_CheckEnable

typedef BOOL (WINAPI* PFNCSCMSGPROCESS)(LPMSG);

static HWND g_hWndCSC = NULL;
static HMODULE g_hCSCUIDll = NULL;
static PFNCSCMSGPROCESS g_pfnMsgProcess = NULL;

BOOL CSC_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{

    if ((g_hWndCSC && IsWindow(g_hWndCSC) && !bSvcEnabled) ||
        (((!g_hWndCSC) || !IsWindow(g_hWndCSC)) && bSvcEnabled))
    
    {
        if (!g_hCSCUIDll)
            g_hCSCUIDll = LoadLibrary(TEXT("cscui.dll"));
            
        if (g_hCSCUIDll)
        {
            PFNCSCUIINITIALIZE pfn = (PFNCSCUIINITIALIZE)GetProcAddress(g_hCSCUIDll, "CSCUIInitialize");
            g_pfnMsgProcess = (PFNCSCMSGPROCESS)GetProcAddress(g_hCSCUIDll, "CSCUIMsgProcess");
            if (pfn)
            {
                DWORD dwFlags = CI_INITIALIZE | CI_CREATEWINDOW;

                if (!bSvcEnabled)
                    dwFlags = CI_TERMINATE | CI_DESTROYWINDOW;
                    
                g_hWndCSC = (*pfn)(NULL, dwFlags);
            }    
        }

        if (g_hCSCUIDll && !bSvcEnabled)
        {
            FreeLibrary(g_hCSCUIDll);
            g_hCSCUIDll = NULL;
            g_pfnMsgProcess = NULL;
        }
    }        
    return(TRUE);
}

BOOL CSC_MsgProcess(LPMSG pMsg)
{
    if (g_pfnMsgProcess)
        return (*g_pfnMsgProcess)(pMsg);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\dll.cpp ===
#include "stdafx.h"
#include <initguid.h>
#include "stobject.h"
#include "cfact.h"
#define DECL_CRTFREE
#include <crtfree.h>
#include "strsafe.h"

// One lock for each running component + one lock per LockServer call
long g_cLocks = 0;
HINSTANCE g_hinstDll = NULL;
const TCHAR g_szThreadModel[] = TEXT("Both");

STDAPI DllCanUnloadNow()
{
    return (g_cLocks == 0) ? S_OK : S_FALSE;
}

STDAPI DllGetClassObject(const CLSID& clsid, const IID& iid, void** ppvObject)
{
    HRESULT hr = S_OK;
    BOOL fRunTrayOnConstruct;
    *ppvObject = NULL;

    if (clsid == CLSID_SysTray)
    {
        // The SysTray object is being requested - we don't actually launch the tray thread until
        // told to do so though IOleCommandTarget
        fRunTrayOnConstruct = FALSE;
    }
    else if (clsid == CLSID_SysTrayInvoker)
    {
        // The simple invoker object is being requested - the tray thread will be launched immediately
        fRunTrayOnConstruct = TRUE;
    }
    else
    {
        // We don't support this object!
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    // If one of the two objects we support was requested:
    if (SUCCEEDED(hr))
    {
        // Try to create the object
        CSysTrayFactory* ptrayfact = new CSysTrayFactory(fRunTrayOnConstruct);

        if (ptrayfact != NULL)
        {
            hr = ptrayfact->QueryInterface(iid, ppvObject);
            ptrayfact->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


BOOL RegisterComponent(const CLSID& clsid, const TCHAR* szProgID)
{
    // Build a CLSID string for the registry
    BOOL fSuccess = FALSE;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szCLSID[GUIDSTR_MAX];
    TCHAR szModule[MAX_PATH];
    HKEY hkeyCLSID = NULL;
    HKEY hkeyInproc = NULL;
    DWORD dwDisp;
    TCHAR* pszNameOnly;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {
        if ((GetModuleFileName(g_hinstDll, szModule, ARRAYSIZE(szModule)) != 0) &&
            (pszNameOnly = PathFindFileName(szModule)))
        {
            if (SUCCEEDED(StringCchPrintf(szSubkey, ARRAYSIZE(szSubkey), TEXT("CLSID\\%s"), szCLSID)))
            {
                // We've built our strings, so write stuff to the registry
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szSubkey, 0, 
                    NULL, 0, KEY_WRITE, NULL, &hkeyCLSID, &dwDisp))
                {

                    RegSetValueEx(hkeyCLSID, NULL, 0, REG_SZ, (const BYTE*) szProgID, 
                        (lstrlen(szProgID) + 1) * sizeof(TCHAR));

                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCLSID, TEXT("InprocServer32"), 
                        0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyInproc, &dwDisp))
                    {

                        RegSetValueEx(hkeyInproc, NULL, 0, REG_SZ, 
                            (const BYTE*) szModule, (lstrlen(szModule) + 1) * sizeof(TCHAR));
                        RegSetValueEx(hkeyInproc, TEXT("ThreadingModel"), 0, REG_SZ, 
                            (const BYTE*) g_szThreadModel, sizeof(g_szThreadModel));
                        fSuccess = TRUE;
                    }
                }
            }
        }
    }

    if (hkeyCLSID != NULL)
        RegCloseKey(hkeyCLSID);

    if (hkeyInproc != NULL)
        RegCloseKey(hkeyInproc);

    return fSuccess;
}

BOOL UnregisterComponent(const CLSID& clsid)
{
    // Build a CLSID string for the registry
    BOOL fSuccess = FALSE;
    TCHAR szSubkey[MAX_PATH];
    TCHAR szCLSID[GUIDSTR_MAX];
    HKEY hkeyCLSID = NULL;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {
        if (SUCCEEDED(StringCchPrintf(szSubkey, ARRAYSIZE(szSubkey), TEXT("CLSID\\%s"), szCLSID)))
        {        
            // We've built our strings, so delete our registry stuff
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szSubkey, 0, 
                KEY_WRITE, &hkeyCLSID))
            {
                RegDeleteKey(hkeyCLSID, TEXT("InprocServer32"));
                RegCloseKey(hkeyCLSID);
                hkeyCLSID = NULL;

                RegDeleteKey(HKEY_CLASSES_ROOT, szSubkey);
                fSuccess = TRUE;
            }
        }
    }
    if (hkeyCLSID != NULL)
        RegCloseKey(hkeyCLSID);
    
    return fSuccess;
}

BOOL RegisterShellServiceObject(const CLSID& clsid, const TCHAR* szProgID, BOOL fRegister)
{
    const static TCHAR szSubkey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
    BOOL fSuccess = FALSE;
    TCHAR szCLSID[GUIDSTR_MAX];
    HKEY hkey = NULL;

    // Try and get all the strings we need
    if (StringFromGUID2(clsid, szCLSID, ARRAYSIZE(szCLSID)) != 0)
    {

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubkey, 0, 
            KEY_WRITE, &hkey))
        {
            if (fRegister)
            {
                fSuccess = RegSetValueEx(hkey, szProgID, 0, REG_SZ, (const BYTE*) szCLSID,
                    (lstrlen(szCLSID) + 1) * sizeof(TCHAR));
            }
            else
            {
                fSuccess = RegDeleteValue(hkey, szProgID);
            }
        }
    }

    if (hkey != NULL)
        RegCloseKey(hkey);
    
    return fSuccess;    
}

STDAPI DllRegisterServer()
{
    BOOL fSuccess;
    fSuccess = RegisterComponent(CLSID_SysTray, TEXT("SysTray"));
    fSuccess &= RegisterComponent(CLSID_SysTrayInvoker, TEXT("SysTrayInvoker"));
    fSuccess &= RegisterShellServiceObject(CLSID_SysTray, TEXT("SysTray"), TRUE);
    return fSuccess;
}

STDAPI DllUnregisterServer()
{
    BOOL fSuccess;
    fSuccess = UnregisterComponent(CLSID_SysTray);
    fSuccess &= UnregisterComponent(CLSID_SysTrayInvoker);
    fSuccess &= RegisterShellServiceObject(CLSID_SysTray, TEXT("SysTray"), FALSE);
    return fSuccess;
}

STDAPI DllMain(HINSTANCE hModule, DWORD dwReason, void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hModule);
        // Don't have DllMain called for thread init's.
        DisableThreadLibraryCalls(hModule);
        g_hinstDll = hModule;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\pccrdapi.h ===
#ifndef _INC_PCCRDAPI
#define _INC_PCCRDAPI


#ifndef PCCARD_DEVICE_ID
#define PCCARD_DEVICE_ID    0x097C
#endif

//
//  32-bit IOCTL APIs
//
#define PCCARD_IOCTL_GET_VERSION	0
//
//  Output buffer contains array of devnodes for all sockets
//
#define PCCARD_IOCTL_GET_DEVNODES	1
//
//  Input:  Devnode handle
//  Output: String description of device
//
#define PCCARD_IOCTL_GET_DESCRIPTION	2


//
//  16-Bit APIs
//
//  ENTRY:
//	  AX = 0000h - Get Version Information
//  EXIT:
//	  AX = Version number
//	  Carry clear
#define PCCARD_API_GET_VERSION		0x0000


//  ENTRY:
//	  AX = 100h - Get Devnodes for Sockets
//	  CX = user buffer length in bytes
//	  ES:BX = pointer to user buffer
//  EXIT:
//	  CX = number of logical sockets in system
//	  Carry set if error
//	  Carry clear, user buffer is filled in with devnodes for sockets
//
#define PCCARD_API_GET_DEVNODES 	0x0100

#endif // _INC_PCCRDAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\access.c ===
#include "stdafx.h"
#include "systray.h"
#include "winuserp.h"
// These two lines must be commented out before checkin
//#define DBG 1
//#include "..\..\..\osshell\accessib\inc\w95trace.c"
#define DBPRINTF 1 ? (void)0 : (void)

STICKYKEYS sk;
int skIconShown = -1; // either -1 or displacement of icon
HICON skIcon;

MOUSEKEYS mk;
DWORD mkStatus;
int mkIconShown = -1; // either -1 or equivalent to mkStatus
HICON mkIcon;

FILTERKEYS fk;
HICON fkIcon;

extern HINSTANCE g_hInstance;
void StickyKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void StickyKeys_UpdateIcon(HWND hWnd, DWORD message);
void MouseKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void MouseKeys_UpdateIcon(HWND hWnd, DWORD message);
void FilterKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon);
void FilterKeys_UpdateIcon(HWND hWnd, DWORD message);
void NormalizeIcon(HICON *phIcon);

extern DWORD g_uiShellHook; //shell hook window message

__inline void RegShellHook(HWND hWnd)
{
    // Only register the shell hook if it isn't yet registered
    if (!g_uiShellHook) {
        g_uiShellHook = RegisterWindowMessage(L"SHELLHOOK");
        RegisterShellHookWindow(hWnd);
        DBPRINTF(TEXT("RegShellHook\r\n"));
    }
}

__inline void UnregShellHook(HWND hWnd)
{
    // Only unregister the shell hook if neither sticky keys or mouse keys is on
    if (skIconShown == -1 && mkIconShown == -1) {
        g_uiShellHook = 0;
        DeregisterShellHookWindow(hWnd);
        DBPRINTF(TEXT("UnregShellHook\r\n"));
    }
}

BOOL StickyKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    sk.cbSize = sizeof(sk);
    SystemParametersInfo(
      SPI_GETSTICKYKEYS,
      sizeof(sk),
      &sk,
      0);

    bEnable = sk.dwFlags & SKF_INDICATOR && sk.dwFlags & SKF_STICKYKEYSON;

    DBPRINTF(TEXT("StickyKeys_CheckEnable\r\n"));
    StickyKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void StickyKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (skIconShown!= -1)) {
        if (bShowIcon) {
            StickyKeys_UpdateIcon(hWnd, NIM_ADD);
            RegShellHook(hWnd);
        } else {
            skIconShown = -1;
            UnregShellHook(hWnd);
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYSTICKYKEYS, NIM_DELETE, NULL, NULL);
            if (skIcon) {
                DestroyIcon(skIcon);
                skIcon = NULL;
            }
        }
    }
    if (bShowIcon) {
        StickyKeys_UpdateIcon(hWnd, NIM_MODIFY);
    }
}

void StickyKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;

    int iStickyOffset = 0;

    if (sk.dwFlags & SKF_LSHIFTLATCHED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_RSHIFTLATCHED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_LSHIFTLOCKED) iStickyOffset |= 1;
    if (sk.dwFlags & SKF_RSHIFTLOCKED) iStickyOffset |= 1;

    if (sk.dwFlags & SKF_LCTLLATCHED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_RCTLLATCHED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_LCTLLOCKED) iStickyOffset |= 2;
    if (sk.dwFlags & SKF_RCTLLOCKED) iStickyOffset |= 2;

    if (sk.dwFlags & SKF_LALTLATCHED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_RALTLATCHED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_LALTLOCKED) iStickyOffset |= 4;
    if (sk.dwFlags & SKF_RALTLOCKED) iStickyOffset |= 4;

    if (sk.dwFlags & SKF_LWINLATCHED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_RWINLATCHED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_LWINLOCKED) iStickyOffset |= 8;
    if (sk.dwFlags & SKF_RWINLOCKED) iStickyOffset |= 8;

    if ((!skIcon) || (iStickyOffset != skIconShown)) {
        if (skIcon) DestroyIcon(skIcon);
        skIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_STK000 + iStickyOffset),
                                        IMAGE_ICON, 16, 16, 0);
        skIconShown = iStickyOffset;
    }
    lpsz    = LoadDynamicString(IDS_STICKYKEYS);
    if (skIcon)
    {
        NormalizeIcon(&skIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYSTICKYKEYS, message, skIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void StickyKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,1",SW_SHOW);
        break;
    }
}

BOOL MouseKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    mk.cbSize = sizeof(mk);
    SystemParametersInfo(
      SPI_GETMOUSEKEYS,
      sizeof(mk),
      &mk,
      0);

    bEnable = mk.dwFlags & MKF_INDICATOR && mk.dwFlags & MKF_MOUSEKEYSON;

    DBPRINTF(TEXT("MouseKeys_CheckEnable\r\n"));
    MouseKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void MouseKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (mkIconShown!= -1)) {
        if (bShowIcon) {
            MouseKeys_UpdateIcon(hWnd, NIM_ADD);
            RegShellHook(hWnd);
        } else {
            mkIconShown = -1;
            UnregShellHook(hWnd);
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYMOUSEKEYS, NIM_DELETE, NULL, NULL);
            if (mkIcon) {
                DestroyIcon(mkIcon);
                mkIcon = NULL;
            }
        }
    }
    if (bShowIcon) {
        MouseKeys_UpdateIcon(hWnd, NIM_MODIFY);
    }
}

int MouseIcon[] = {
        IDI_MKPASS,           // 00 00  no buttons selected
        IDI_MKGT,             // 00 01  left selected, up
        IDI_MKTG,             // 00 10  right selected, up
        IDI_MKGG,             // 00 11  both selected, up
        IDI_MKPASS,           // 01 00  no buttons selected
        IDI_MKBT,             // 01 01  left selected, and down
        IDI_MKTG,             // 01 10  right selected, up
        IDI_MKBG,             // 01 11  both selected, left down, right up
        IDI_MKPASS,           // 10 00  no buttons selected
        IDI_MKGT,             // 10 01  left selected, right down
        IDI_MKTB,             // 10 10  right selected, down
        IDI_MKGB,             // 10 11  both selected, right down
        IDI_MKPASS,           // 11 00  no buttons selected
        IDI_MKBT,             // 11 01  left selected, down
        IDI_MKTB,             // 11 10  right selected, down
        IDI_MKBB};            // 11 11  both selected, down

void MouseKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;
    int iMouseIcon = 0;

    if (!(mk.dwFlags & MKF_MOUSEMODE)) iMouseIcon = IDI_MKPASS;
    else {
        /*
         * Set up iMouseIcon as an index into the table first
         */

        if (mk.dwFlags & MKF_LEFTBUTTONSEL) iMouseIcon |= 1;
        if (mk.dwFlags & MKF_RIGHTBUTTONSEL) iMouseIcon |= 2;
        if (mk.dwFlags & MKF_LEFTBUTTONDOWN) iMouseIcon |= 4;
        if (mk.dwFlags & MKF_RIGHTBUTTONDOWN) iMouseIcon |= 8;
        iMouseIcon = MouseIcon[iMouseIcon];
    }

    if ((!mkIcon) || (iMouseIcon != mkIconShown)) {
        if (mkIcon) DestroyIcon(mkIcon);
        mkIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(iMouseIcon),
                                        IMAGE_ICON, 16, 16, 0);
        mkIconShown = iMouseIcon;
    }
    lpsz    = LoadDynamicString(IDS_MOUSEKEYS);
    if (mkIcon)
    {
        NormalizeIcon(&mkIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYMOUSEKEYS, message, mkIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void MouseKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,4",SW_SHOW);
        break;
    }
}


BOOL FilterKeys_CheckEnable(HWND hWnd)
{
    BOOL bEnable;

    fk.cbSize = sizeof(fk);
    SystemParametersInfo(
      SPI_GETFILTERKEYS,
      sizeof(fk),
      &fk,
      0);

    bEnable = fk.dwFlags & FKF_INDICATOR && fk.dwFlags & FKF_FILTERKEYSON;

    DBPRINTF(TEXT("FilterKeys_CheckEnable\r\n"));
    FilterKeys_UpdateStatus(hWnd, bEnable);

    return(bEnable);
}

void FilterKeys_UpdateStatus(HWND hWnd, BOOL bShowIcon) {
    if (bShowIcon != (fkIcon!= NULL)) {
        if (bShowIcon) {
            FilterKeys_UpdateIcon(hWnd, NIM_ADD);
        } else {
            SysTray_NotifyIcon(hWnd, STWM_NOTIFYFILTERKEYS, NIM_DELETE, NULL, NULL);
            if (fkIcon) {
                DestroyIcon(fkIcon);
                fkIcon = NULL;
            }
        }
    }
}

void FilterKeys_UpdateIcon(HWND hWnd, DWORD message)
{
    LPTSTR      lpsz;

    if (!fkIcon) {
        fkIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_FILTER),
                                        IMAGE_ICON, 16, 16, 0);
    }
    lpsz    = LoadDynamicString(IDS_FILTERKEYS);
    if (fkIcon)
    {
        NormalizeIcon(&fkIcon);
        SysTray_NotifyIcon(hWnd, STWM_NOTIFYFILTERKEYS, message, fkIcon, lpsz);
    }
    DeleteDynamicString(lpsz);
}

void FilterKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        WinExec("rundll32.exe Shell32.dll,Control_RunDLL access.cpl,,1",SW_SHOW);
        break;
    }
}

//
// This function takes the resource icon and changes the dark blue
// pixels to the window text color (black in normal mode or white
// in high contrast).
//
// If any part of the conversion fails, the normal icon is unchanged.
// If the conversion is successful, the normal icon is destroyed and
// replaced with the converted one.
//
void NormalizeIcon(HICON *phIcon)
{
	BITMAP BmpInfo;
	ICONINFO IconInfo;
	HBITMAP hCopyBmp = NULL;
	HDC hdcCopyBmp = NULL;
	HDC hdcIconBmp = NULL;
	ICONINFO ic;
	HICON hNewIcon = NULL;
	int i, j;
	COLORREF clr = GetSysColor(COLOR_WINDOWTEXT);
    HGDIOBJ hObjTmp1, hObjTmp2;

	if (!GetIconInfo(*phIcon, &IconInfo))
    {
        DBPRINTF(TEXT("GetIconInfo failed\r\n"));
        goto Cleanup;
    }
    if (!GetObject(IconInfo.hbmColor, sizeof(BITMAP), &BmpInfo ))
    {
        DBPRINTF(TEXT("GetObject failed\r\n"));
        goto Cleanup;
    }

	hCopyBmp = CreateBitmap(BmpInfo.bmWidth,
							BmpInfo.bmHeight,
							BmpInfo.bmPlanes,			// Planes
							BmpInfo.bmBitsPixel,		// BitsPerPel
							NULL);						// bits
    if (!hCopyBmp)
    {
        DBPRINTF(TEXT("CreateBitmap failed\r\n"));
        goto Cleanup;
    }

	hdcCopyBmp = CreateCompatibleDC(NULL);
	if (!hdcCopyBmp)
    {
		DBPRINTF(TEXT("CreateCompatibleDC 1 failed\r\n"));
        goto Cleanup;
    }
	hObjTmp1 = SelectObject(hdcCopyBmp, hCopyBmp);

	// Select Icon bitmap into a memoryDC so we can use it
	hdcIconBmp = CreateCompatibleDC(NULL);
	if (!hdcIconBmp)
    {
		DBPRINTF(TEXT("CreateCompatibleDC 2 failed\r\n"));
	    SelectObject(hdcCopyBmp, hObjTmp1); // restore original bitmap
        goto Cleanup;
    }
	hObjTmp2 = SelectObject(hdcIconBmp, IconInfo.hbmColor);

	BitBlt(	hdcCopyBmp, 
			0,  
			0,  
			BmpInfo.bmWidth,  
			BmpInfo.bmHeight, 
			hdcIconBmp,  
			0,   
			0,   
			SRCCOPY  
			);

	ic.fIcon = TRUE;				// This is an icon
	ic.xHotspot = 0;
	ic.yHotspot = 0;
	ic.hbmMask = IconInfo.hbmMask;
			
	for (i=0; i < BmpInfo.bmWidth; i++)
		for (j=0; j < BmpInfo.bmHeight; j++)
		{
			COLORREF pel_value = GetPixel(hdcCopyBmp, i, j);
			if (pel_value == (COLORREF) RGB(0,0,128)) // The color on icon resource is BLUE!!
				SetPixel(hdcCopyBmp, i, j, clr);	// Window-Text icon
		}

	ic.hbmColor = hCopyBmp;

	hNewIcon = CreateIconIndirect(&ic);
    if (hNewIcon)
    {
        DestroyIcon(*phIcon);
        *phIcon = hNewIcon;

	    SelectObject(hdcIconBmp, hObjTmp2);  // restore original bitmap
    }

Cleanup:
    if (hdcIconBmp)
	    DeleteDC(hdcIconBmp);
    if (hdcCopyBmp)
	    DeleteDC(hdcCopyBmp);
    if (hCopyBmp)
        DeleteObject(hCopyBmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\hplug.c ===
/*
 *  Copyright (c) 1992-1997 Microsoft Corporation
 *  hotplug routines
 *
 *  09-May-1997 Jonle , created
 *
 */

#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "systray.h"
#include <setupapi.h>
#include <cfgmgr32.h>
#include <dbt.h>
#include <initguid.h>
#include <devguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <ntddstor.h>
#include <strsafe.h>

BOOL
HotplugPlaySoundThisSession(
    VOID
    );

//
// Hardware application sound event names.
//
#define DEVICE_ARRIVAL_SOUND            TEXT("DeviceConnect")
#define DEVICE_REMOVAL_SOUND            TEXT("DeviceDisconnect")
#define DEVICE_FAILURE_SOUND            TEXT("DeviceFail")

//
// Simple checks for console / remote TS sessions.
//
#define MAIN_SESSION      ((ULONG)0)
#define THIS_SESSION      ((ULONG)NtCurrentPeb()->SessionId)
#define CONSOLE_SESSION   ((ULONG)USER_SHARED_DATA->ActiveConsoleId)

#define IsConsoleSession()        (BOOL)(THIS_SESSION == CONSOLE_SESSION)
#define IsRemoteSession()         (BOOL)(THIS_SESSION != CONSOLE_SESSION)
#define IsPseudoConsoleSession()  (BOOL)(THIS_SESSION == MAIN_SESSION)


#define HPLUG_EJECT_EVENT           TEXT("HPlugEjectEvent")

typedef struct _HotPlugDevices {
     struct _HotPlugDevices *Next;
     DEVINST DevInst;
     WORD    EjectMenuIndex;
     BOOLEAN PendingEvent;
     PTCHAR  DevName;
     TCHAR   DevInstanceId[1];
} HOTPLUGDEVICES, *PHOTPLUGDEVICES;

BOOL HotPlugInitialized = FALSE;
BOOL ShowShellIcon = FALSE;
HICON HotPlugIcon = NULL;
BOOL ServiceEnabled = FALSE;
HANDLE hEjectEvent = NULL;   // Event to if we are in the process of ejecting a device
HDEVINFO g_hCurrentDeviceInfoSet = INVALID_HANDLE_VALUE;
HDEVINFO g_hRemovableDeviceInfoSet = INVALID_HANDLE_VALUE;
extern HINSTANCE g_hInstance;       //  Global instance handle 4 this application.

BOOL
pDoesUserHavePrivilege(
    PCTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = LocalAlloc(LPTR, BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if((Luid.LowPart  == Privileges->Privileges[i].Luid.LowPart)
            && (Luid.HighPart == Privileges->Privileges[i].Luid.HighPart)) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        LocalFree(Privileges);
    }

    CloseHandle(Token);

    return(b);
}

BOOL
IsHotPlugDevice(
    DEVINST DevInst
    )
/**+

    A device is considered a HotPlug device if the following are TRUE:
        - has Capability CM_DEVCAP_REMOVABLE
        - does NOT have Capability CM_DEVCAP_SURPRISEREMOVALOK
        - does NOT have Capability CM_DEVCAP_DOCKDEVICE
        - must be started (have the DN_STARTED devnode flag)
            - unless has capability CM_DEVCAP_EJECTSUPPORTED

Returns:
    TRUE if this is a HotPlug device
    FALSE if this is not a HotPlug device.

-**/
{
    DWORD Capabilities;
    ULONG cbSize;
    DWORD Status, Problem;

    Capabilities = Status = Problem = 0;

    cbSize = sizeof(Capabilities);

    if (CM_Get_DevNode_Registry_Property(DevInst,
                                         CM_DRP_CAPABILITIES,
                                         NULL,
                                         (PVOID)&Capabilities,
                                         &cbSize,
                                         0
                                         ) != CR_SUCCESS) {

        return FALSE;
    }

    if (CM_Get_DevNode_Status(&Status,
                              &Problem,
                              DevInst,
                              0
                              ) != CR_SUCCESS) {

        return FALSE;
    }

    //
    // If this device is not removable, or it is surprise removal ok, or
    // it is a dock device, then it is not a hotplug device.
    //
    if ((!(Capabilities & CM_DEVCAP_REMOVABLE)) ||
        (Capabilities & CM_DEVCAP_SURPRISEREMOVALOK) ||
        (Capabilities & CM_DEVCAP_DOCKDEVICE)) {

        return FALSE;
    }

    //
    // We won't consider a device to be a hotplug device if it is not started,
    // unless it is an eject capable device.
    //
    // The reason for this test is that a bus driver might set the
    // CM_DEVCAP_REMOVABLE capability, but if the PDO doesn't get loaded then
    // it can't set the CM_DEVCAP_SURPRISEREMOVALOK. So we won't trust the
    // CM_DEVCAP_REMOVABLE capability if the PDO is not started.
    //
    if ((!(Capabilities & CM_DEVCAP_EJECTSUPPORTED)) &&
        (!(Status & DN_STARTED))) {

        return FALSE;
    }

    return TRUE;
}

BOOL
IsRemovableDevice(
    IN  DEVINST     dnDevInst
    )

/*++

Routine Description:

    This routine determines whether a device is removable.

Arguments:

    dnDevInst - Device instance.

Return Value:

    Returns TRUE if the device is removable.

--*/

{
    ULONG  ulPropertyData, ulDataSize, ulRegDataType;

    //
    // Validate parameters.
    //
    if (dnDevInst == 0) {
        return FALSE;
    }

    //
    // Get the capabilities for this device.
    //
    ulDataSize = sizeof(ulPropertyData);

    if (CM_Get_DevNode_Registry_Property_Ex(dnDevInst,
                                            CM_DRP_CAPABILITIES,
                                            &ulRegDataType,
                                            &ulPropertyData,
                                            &ulDataSize,
                                            0,
                                            NULL) != CR_SUCCESS) {
        return FALSE;
    }

    //
    // Check if the device has the removable capability.
    //
    if ((ulPropertyData & CM_DEVCAP_REMOVABLE) == 0) {
        return FALSE;
    }

    return TRUE;

} // IsRemovableDevice

LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    )
{
    ULONG ulSize;
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    LPTSTR DriveName = NULL;
    LPTSTR DeviceInterface = NULL;

    if (CM_Get_Device_ID_Ex(DevInst,
                            DeviceID,
                            ARRAYSIZE(DeviceID),
                            0,
                            NULL
                            ) != CR_SUCCESS) {

        return FALSE;
    }

    ulSize = 0;

    if ((CM_Get_Device_Interface_List_Size(&ulSize,
                                           (LPGUID)&VolumeClassGuid,
                                           DeviceID,
                                           0)  == CR_SUCCESS) &&
        (ulSize > 1) &&
        ((DeviceInterface = LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
        (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
                                      DeviceID,
                                      DeviceInterface,
                                      ulSize,
                                      0
                                      )  == CR_SUCCESS) &&
        *DeviceInterface)
    {
        LPTSTR devicePath, p;
        TCHAR thisVolumeName[MAX_PATH];
        TCHAR enumVolumeName[MAX_PATH];
        TCHAR driveName[4];
        ULONG length;
        BOOL bResult;

        length = lstrlen(DeviceInterface);
        devicePath = LocalAlloc(LPTR, (length + 1) * sizeof(TCHAR) + sizeof(UNICODE_NULL));

        if (devicePath) {

            StringCchCopy(devicePath, length + 1, DeviceInterface);

            p = wcschr(&(devicePath[4]), TEXT('\\'));

            if (!p) {
                //
                // No refstring is present in the symbolic link; add a trailing
                // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                //
                p = devicePath + length;
                *p = TEXT('\\');
            }

            p++;
            *p = UNICODE_NULL;

            thisVolumeName[0] = UNICODE_NULL;
            bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                       thisVolumeName,
                                                       MAX_PATH
                                                       );
            LocalFree(devicePath);

            if (bResult && thisVolumeName[0]) {

                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = TEXT('\0');

                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = TEXT('\0');

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, MAX_PATH);

                    if (!lstrcmpi(thisVolumeName, enumVolumeName)) {

                        driveName[2] = TEXT('\0');

                        ulSize = (lstrlen(driveName) + 1) * sizeof(TCHAR);
                        DriveName = LocalAlloc(LPTR, ulSize);

                        if (DriveName) {

                            StringCbCopy(DriveName, ulSize, driveName);
                        }

                        break;
                    }
                }
            }
        }
    }

    if (DeviceInterface) {

        LocalFree(DeviceInterface);
    }

    return DriveName;
}

int
CollectRelationDriveLetters(
    DEVINST DevInst,
    LPTSTR ListOfDrives,
    ULONG CchSizeListOfDrives
    )
/*++

    This function looks at the removal relations of the specified DevInst and adds any drive
    letters associated with these removal relations to the ListOfDrives.

Return:
    Number of drive letters added to the list.

--*/
{
    int NumberOfDrives = 0;
    LPTSTR SingleDrive = NULL;
    TCHAR szSeparator[32];
    DEVINST RelationDevInst;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    ULONG cchSize;
    PTCHAR DeviceIdRelations, CurrDevId;

    if (CM_Get_Device_ID(DevInst,
                         DeviceInstanceId,
                         ARRAYSIZE(DeviceInstanceId),
                         0
                         ) == CR_SUCCESS) {

        cchSize = 0;
        if ((CM_Get_Device_ID_List_Size(&cchSize,
                                        DeviceInstanceId,
                                        CM_GETIDLIST_FILTER_REMOVALRELATIONS
                                        ) == CR_SUCCESS) &&
            (cchSize)) {

            DeviceIdRelations = LocalAlloc(LPTR, cchSize*sizeof(TCHAR));

            if (DeviceIdRelations) {

                *DeviceIdRelations = TEXT('\0');

                if ((CM_Get_Device_ID_List(DeviceInstanceId,
                                           DeviceIdRelations,
                                           cchSize,
                                           CM_GETIDLIST_FILTER_REMOVALRELATIONS
                                           ) == CR_SUCCESS) &&
                    (*DeviceIdRelations)) {

                    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {

                        if (CM_Locate_DevNode(&RelationDevInst, CurrDevId, 0) == CR_SUCCESS) {

                            SingleDrive = DevNodeToDriveLetter(RelationDevInst);

                            if (SingleDrive) {

                                NumberOfDrives++;

                                //
                                // If this is not the first drive the add a comma space separator
                                //
                                if (ListOfDrives[0] != TEXT('\0')) {

                                    LoadString(g_hInstance, IDS_SEPARATOR, szSeparator, sizeof(szSeparator)/sizeof(TCHAR));

                                    StringCchCat(ListOfDrives, CchSizeListOfDrives, szSeparator);
                                }

                                StringCchCat(ListOfDrives, CchSizeListOfDrives, SingleDrive);

                                LocalFree(SingleDrive);
                            }
                        }
                    }
                }

                LocalFree(DeviceIdRelations);
            }
        }
    }

    return NumberOfDrives;
}

int
CollectDriveLettersForDevNodeWorker(
    DEVINST DevInst,
    LPTSTR ListOfDrives,
    ULONG CchSizeListOfDrives
    )
{
    DEVINST ChildDevInst;
    DEVINST SiblingDevInst;
    int NumberOfDrives = 0;
    LPTSTR SingleDrive = NULL;
    TCHAR szSeparator[32];

    //
    // Enumerate through all of the siblings and children of this devnode
    //
    do {

        ChildDevInst = 0;
        SiblingDevInst = 0;

        CM_Get_Child(&ChildDevInst, DevInst, 0);
        CM_Get_Sibling(&SiblingDevInst, DevInst, 0);

        //
        // Only get the drive letter for this device if it is NOT a hotplug
        // device.  If it is a hotplug device then it will have it's own
        // subtree that contains it's drive letters.
        //
        if (!IsHotPlugDevice(DevInst)) {

            SingleDrive = DevNodeToDriveLetter(DevInst);

            if (SingleDrive) {

                NumberOfDrives++;

                //
                // If this is not the first drive the add a comma space separator
                //
                if (ListOfDrives[0] != TEXT('\0')) {

                    LoadString(g_hInstance, IDS_SEPARATOR, szSeparator, sizeof(szSeparator)/sizeof(TCHAR));

                    StringCchCat(ListOfDrives, CchSizeListOfDrives, szSeparator);
                }

                StringCchCat(ListOfDrives, CchSizeListOfDrives, SingleDrive);

                LocalFree(SingleDrive);
            }

            //
            // Get the drive letters for any children of this devnode
            //
            if (ChildDevInst) {

                NumberOfDrives += CollectDriveLettersForDevNodeWorker(ChildDevInst, ListOfDrives, CchSizeListOfDrives);
            }

            //
            // Add the drive letters for any removal relations of this devnode
            //
            NumberOfDrives += CollectRelationDriveLetters(DevInst, ListOfDrives, CchSizeListOfDrives);
        }

    } while ((DevInst = SiblingDevInst) != 0);

    return NumberOfDrives;
}

LPTSTR
CollectDriveLettersForDevNode(
    DEVINST DevInst
    )
{
    TCHAR Format[MAX_PATH];
    TCHAR ListOfDrives[MAX_PATH];
    DEVINST ChildDevInst;
    int NumberOfDrives = 0;
    ULONG cbSize;
    LPTSTR SingleDrive = NULL;
    LPTSTR FinalDriveString = NULL;

    ListOfDrives[0] = TEXT('\0');

    //
    //First get any drive letter associated with this devnode
    //
    SingleDrive = DevNodeToDriveLetter(DevInst);

    if (SingleDrive) {

        NumberOfDrives++;

        StringCchCat(ListOfDrives, ARRAYSIZE(ListOfDrives), SingleDrive);

        LocalFree(SingleDrive);
    }

    //
    // Next add on any drive letters associated with the children
    // of this devnode
    //
    ChildDevInst = 0;
    CM_Get_Child(&ChildDevInst, DevInst, 0);

    if (ChildDevInst) {

        NumberOfDrives += CollectDriveLettersForDevNodeWorker(ChildDevInst, 
                                                              ListOfDrives, 
                                                              ARRAYSIZE(ListOfDrives));
    }

    //
    // Finally add on any drive letters associated with the removal relations
    // of this devnode
    //
    NumberOfDrives += CollectRelationDriveLetters(DevInst, 
                                                  ListOfDrives, 
                                                  ARRAYSIZE(ListOfDrives));

    if (ListOfDrives[0] != TEXT('\0')) {

        LoadString(g_hInstance,
                   (NumberOfDrives > 1) ? IDS_DISKDRIVES : IDS_DISKDRIVE,
                   Format,
                   sizeof(Format)/sizeof(TCHAR)
                   );


        cbSize = (lstrlen(ListOfDrives) + lstrlen(Format) + 1) * sizeof(TCHAR);
        FinalDriveString = LocalAlloc(LPTR, cbSize);

        if (FinalDriveString) {

            StringCbPrintf(FinalDriveString, cbSize, Format, ListOfDrives);
        }
    }

    return FinalDriveString;
}

ULONG
RegistryDeviceName(
    DEVINST DevInst,
    PTCHAR  Buffer,
    DWORD   cbBuffer
    )
{
    ULONG ulSize = 0;
    CONFIGRET ConfigRet;
    LPTSTR ListOfDrives = NULL;

    //
    // Get the list of drives
    //
    ListOfDrives = CollectDriveLettersForDevNode(DevInst);

    //
    // Try the registry for FRIENDLYNAME
    //
    ulSize = cbBuffer;
    *Buffer = TEXT('\0');
    ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                 CM_DRP_FRIENDLYNAME,
                                                 NULL,
                                                 Buffer,
                                                 &ulSize,
                                                 0
                                                 );

    if (ConfigRet != CR_SUCCESS || !(*Buffer)) {
        //
        // Try the registry for DEVICEDESC
        //
        ulSize = cbBuffer;
        *Buffer = TEXT('\0');
        ConfigRet = CM_Get_DevNode_Registry_Property(DevInst,
                                                     CM_DRP_DEVICEDESC,
                                                     NULL,
                                                     Buffer,
                                                     &ulSize,
                                                     0);
    }

    //
    // Concatonate on the list of drive letters if this device has drive
    // letters and there is enough space
    //
    if (ListOfDrives) {

        if ((ulSize + (lstrlen(ListOfDrives) * sizeof(TCHAR))) < cbBuffer) {

            StringCbCat(Buffer, cbBuffer, ListOfDrives);

            ulSize += (lstrlen(ListOfDrives) * sizeof(TCHAR));
        }

        LocalFree(ListOfDrives);
    }

    return ulSize;
}

BOOL
IsDevInstInDeviceInfoSet(
    IN  DEVINST  DevInst,
    IN  HDEVINFO hDeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoDataInSet  OPTIONAL
    )
{
    DWORD MemberIndex;
    SP_DEVINFO_DATA DeviceInfoData;
    BOOL bIsMember = FALSE;

    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    MemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hDeviceInfoSet,
                                 MemberIndex,
                                 &DeviceInfoData
                                 )) {

        if (DevInst == DeviceInfoData.DevInst) {
            bIsMember = TRUE;
            if (ARGUMENT_PRESENT(DeviceInfoDataInSet)) {
                ASSERT(DeviceInfoDataInSet->cbSize >= DeviceInfoData.cbSize);
                memcpy(DeviceInfoDataInSet, &DeviceInfoData, DeviceInfoDataInSet->cbSize);
            }
            break;
        }
        MemberIndex++;
    }
    return bIsMember;
}

BOOL
AnyHotPlugDevices(
    IN  HDEVINFO hRemovableDeviceInfoSet,
    IN  HDEVINFO hOldDeviceInfoSet,
    OUT PBOOL    bNewHotPlugDevice           OPTIONAL
    )
{
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD dwMemberIndex;
    BOOL bAnyHotPlugDevices = FALSE;

    //
    // Initialize output parameters.
    //
    if (ARGUMENT_PRESENT(bNewHotPlugDevice)) {
        *bNewHotPlugDevice = FALSE;
    }

    if (hRemovableDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // We already have an updated list of just removable devices, so we can just
    // enumerate those devices and see if any also meet the criteria for hotplug
    // devices.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hRemovableDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        if (IsHotPlugDevice(DeviceInfoData.DevInst)) {

            bAnyHotPlugDevices = TRUE;

            //
            // If the caller doesn't want to know if any new hotplug devices
            // have arrived then just break at this point.
            //
            if (!ARGUMENT_PRESENT(bNewHotPlugDevice)) {
                break;
            }

            //
            // If the caller wants to know if the hotplug device is new, we must
            // have a list of devices to check against. If we don't have a list
            // of devices to check against then just break at this point since
            // there is nothing left to do.
            //
            if (hOldDeviceInfoSet == INVALID_HANDLE_VALUE) {
                break;
            }

            //
            // The caller wants to know if we have any new hotplug devices.  So,
            // we will compare this hotplug device to see if it is also in the
            // old current list of devices.  If it is not then we have found a
            // new hotplug device.
            //
            if (!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                          hOldDeviceInfoSet,
                                          NULL)) {
                *bNewHotPlugDevice = TRUE;
            }
        }
        dwMemberIndex++;
    }

    return bAnyHotPlugDevices;
}

BOOL
UpdateRemovableDeviceList(
    IN  HDEVINFO hDeviceInfoSet,
    OUT PBOOL    bRemovableDeviceAdded    OPTIONAL,
    OUT PBOOL    bRemovableDeviceRemoved  OPTIONAL,
    OUT PBOOL    bRemovableDeviceFailure  OPTIONAL
    )
{
    SP_DEVINFO_DATA DeviceInfoData;
    TCHAR    DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DWORD    dwMemberIndex;
    ULONG    ulDevStatus, ulDevProblem;

    //
    // Initialize output parameters.
    //
    if (ARGUMENT_PRESENT(bRemovableDeviceAdded)) {
        *bRemovableDeviceAdded = FALSE;
    }

    if (ARGUMENT_PRESENT(bRemovableDeviceRemoved)) {
        *bRemovableDeviceRemoved = FALSE;
    }

    if (ARGUMENT_PRESENT(bRemovableDeviceFailure)) {
        *bRemovableDeviceFailure = FALSE;
    }

    //
    // We at least need a current list of devices in the system.
    //
    if (hDeviceInfoSet == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (g_hRemovableDeviceInfoSet == INVALID_HANDLE_VALUE) {
        //
        // If we don't already have a global device info set for removable
        // devices in the system, create one now.  No removable devices have
        // been removed in this case, because we didn't know about any prior to
        // this.
        //
        g_hRemovableDeviceInfoSet = SetupDiCreateDeviceInfoListEx(NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL);

        //
        // If we couldn't create a list to store removable devices, there's no
        // point in checking anything else here.
        //
        if (g_hRemovableDeviceInfoSet == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

    } else {
        //
        // If we already had a list of removable devices, enumerate the devices
        // to see if any have been removed from the system since we last
        // checked.
        //
        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        dwMemberIndex = 0;

        while (SetupDiEnumDeviceInfo(g_hRemovableDeviceInfoSet,
                                     dwMemberIndex,
                                     &DeviceInfoData)) {

            if (!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                          hDeviceInfoSet,
                                          NULL)) {

                //
                // A removable device is missing from the system.
                //
                if (ARGUMENT_PRESENT(bRemovableDeviceRemoved)) {
                    *bRemovableDeviceRemoved = TRUE;
                }

#if DBG // DBG
                if (SetupDiGetDeviceInstanceId(g_hRemovableDeviceInfoSet,
                                               &DeviceInfoData,
                                               DeviceInstanceId,
                                               MAX_DEVICE_ID_LEN,
                                               NULL)) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               (0x00000010 | DPFLTR_MASK),
                               "HPLUG: Removing device %ws from g_hRemovableDeviceInfoSet.\n",
                               DeviceInstanceId));
                }
#endif  // DBG

                //
                // Remove the device from the global list of removable devices.
                //
                SetupDiDeleteDeviceInfo(g_hRemovableDeviceInfoSet,
                                        &DeviceInfoData);
            }

            //
            // Increment the enumeration index.
            //
            dwMemberIndex++;
        }
    }

    //
    // Enumerate the current list of devices and see if any removable devices
    // have been added to the system.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(hDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        //
        // If this device is not already in the removable device list, and it's
        // removable, add it to the list.
        //
        if ((!IsDevInstInDeviceInfoSet(DeviceInfoData.DevInst,
                                       g_hRemovableDeviceInfoSet,
                                       NULL)) &&
            (IsRemovableDevice(DeviceInfoData.DevInst))) {

            //
            // A removable device was added to the system.
            //
            if (ARGUMENT_PRESENT(bRemovableDeviceAdded)) {
                *bRemovableDeviceAdded = TRUE;
            }

            //
            // Add the device to the global list of removable devices.
            //
            if (SetupDiGetDeviceInstanceId(hDeviceInfoSet,
                                           &DeviceInfoData,
                                           DeviceInstanceId,
                                           MAX_DEVICE_ID_LEN,
                                           NULL)) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           (0x00000010 | DPFLTR_MASK),
                           "HPLUG: Adding device %ws to g_hRemovableDeviceInfoSet\n",
                           DeviceInstanceId));

                SetupDiOpenDeviceInfo(g_hRemovableDeviceInfoSet,
                                      DeviceInstanceId,
                                      NULL,
                                      0,
                                      NULL);
            }

            //
            // If the caller is also interested in device failures, check the
            // status of the new device.
            //
            if (ARGUMENT_PRESENT(bRemovableDeviceFailure)) {

                if (CM_Get_DevNode_Status_Ex(&ulDevStatus,
                                             &ulDevProblem,
                                             DeviceInfoData.DevInst,
                                             0,
                                             NULL) == CR_SUCCESS) {

                    if (((ulDevStatus & DN_HAS_PROBLEM) != 0) &&
                        (ulDevProblem != CM_PROB_NOT_CONFIGURED) &&
                        (ulDevProblem != CM_PROB_REINSTALL)) {

                        *bRemovableDeviceFailure = TRUE;

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   (0x00000010 | DPFLTR_MASK),
                                   "HPLUG: Device %ws considered a failed insertion (Status = 0x%08lx, Problem = 0x%08lx)\n",
                                   DeviceInstanceId, ulDevStatus, ulDevProblem));
                    }
                }
            }
        }

        //
        // Increment the enumeration index.
        //
        dwMemberIndex++;
    }

    return TRUE;
}

BOOL
AddHotPlugDevice(
    DEVINST      DeviceInstance,
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    PHOTPLUGDEVICES HotPlugDevice;
    DWORD      cbSize, cchDevName, cchDevInstanceId;
    CONFIGRET  ConfigRet;
    TCHAR      DevInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR      DevName[MAX_PATH];


    //
    // Retrieve the device instance id
    //
    *DevInstanceId = TEXT('\0');
    cchDevInstanceId = ARRAYSIZE(DevInstanceId);
    ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                 (PVOID)DevInstanceId,
                                 cchDevInstanceId,
                                 0);

    if (ConfigRet != CR_SUCCESS || !*DevInstanceId) {
        *DevInstanceId = TEXT('\0');
        cchDevInstanceId = 0;
    }

    cbSize = sizeof(HOTPLUGDEVICES) + cchDevInstanceId;
    HotPlugDevice = LocalAlloc(LPTR, cbSize);

    if (!HotPlugDevice) {
        return FALSE;
    }

    //
    // link it in
    //
    HotPlugDevice->Next = *HotPlugDevicesList;
    *HotPlugDevicesList = HotPlugDevice;
    HotPlugDevice->DevInst = DeviceInstance;

    //
    // copy in the names
    //
    StringCchCopy(HotPlugDevice->DevInstanceId, cchDevInstanceId, DevInstanceId);

    cchDevName = RegistryDeviceName(DeviceInstance, DevName, sizeof(DevName));
    HotPlugDevice->DevName = LocalAlloc(LPTR, cchDevName + sizeof(TCHAR));

    if (HotPlugDevice->DevName) {
        StringCchCopy(HotPlugDevice->DevName, cchDevName, DevName);
    }

    return TRUE;
}

BOOL
AddHotPlugDevices(
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    CONFIGRET ConfigRet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD    dwMemberIndex;

    //
    // Initialize output list of hotplug devices.
    //
    *HotPlugDevicesList = NULL;

    //
    // Enumerate the list of removable devices.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    dwMemberIndex = 0;

    while (SetupDiEnumDeviceInfo(g_hRemovableDeviceInfoSet,
                                 dwMemberIndex,
                                 &DeviceInfoData)) {

        //
        // If any removable device also meets the criteria of a hotplug device,
        // add it to the linked list.
        //
        if (IsHotPlugDevice(DeviceInfoData.DevInst)) {
            AddHotPlugDevice(DeviceInfoData.DevInst, HotPlugDevicesList);
        }
        dwMemberIndex++;
    }

    return TRUE;
}


void
FreeHotPlugDevicesList(
    PHOTPLUGDEVICES *HotPlugDevicesList
    )
{
    PHOTPLUGDEVICES HotPlugDevices, HotPlugDevicesFree;

    HotPlugDevices = *HotPlugDevicesList;
    *HotPlugDevicesList = NULL;

    while (HotPlugDevices) {

        HotPlugDevicesFree = HotPlugDevices;
        HotPlugDevices = HotPlugDevicesFree->Next;

        if (HotPlugDevicesFree->DevName) {

           LocalFree(HotPlugDevicesFree->DevName);
           HotPlugDevicesFree->DevName = NULL;
        }

        LocalFree(HotPlugDevicesFree);
    }
}


/*
 *  Shows or deletes the shell notify icon and tip
 */

void
HotPlugShowNotifyIcon(
    HWND hWnd,
    BOOL bShowIcon
    )
{
    TCHAR HotPlugTip[64];

    ShowShellIcon = bShowIcon;

    if (bShowIcon) {

        LoadString(g_hInstance,
                   IDS_HOTPLUGTIP,
                   HotPlugTip,
                   sizeof(HotPlugTip)/sizeof(TCHAR)
                   );

        HotPlugIcon = LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_HOTPLUG),
                                IMAGE_ICON,
                                16,
                                16,
                                0
                                );

        SysTray_NotifyIcon(hWnd, STWM_NOTIFYHOTPLUG, NIM_ADD, HotPlugIcon, HotPlugTip);

    } else {

        SysTray_NotifyIcon(hWnd, STWM_NOTIFYHOTPLUG, NIM_DELETE, NULL, NULL);

        if (HotPlugIcon) {

            DestroyIcon(HotPlugIcon);
        }
    }
}

//
// first time intialization of Hotplug module.
//
BOOL
HotPlugInit(
    HWND hWnd
    )
{
    HDEVINFO  hNewDeviceInfoSet;
    BOOL bAnyHotPlugDevices;
    LARGE_INTEGER liDelayTime;

    //
    // Get a new "current" list of all devices present in the system.
    //
    hNewDeviceInfoSet = SetupDiGetClassDevs(NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES | DIGCF_PRESENT);

    //
    // Update the list of removable devices, don't play any sounds.
    //
    UpdateRemovableDeviceList(hNewDeviceInfoSet,
                              NULL,
                              NULL,
                              NULL);

    //
    // Find out whether there are any HotPlug devices in the list of removable
    // devices.  We're just deciding whether the icon needs to be enabled or
    // not, so we don't care if there are any new hotplug devices or not (we
    // won't even look at g_hCurrentDeviceInfoSet).
    //
    bAnyHotPlugDevices = AnyHotPlugDevices(g_hRemovableDeviceInfoSet,
                                           g_hCurrentDeviceInfoSet,
                                           NULL);

    //
    // Delete the old current list of devices and set it
    // (g_hCurrentDeviceInfoSet) to the new current list.
    //
    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
    }

    //
    // Update the global list of devices currently in the system.
    //
    g_hCurrentDeviceInfoSet = hNewDeviceInfoSet;

    //
    // If hotplug was previously initialized, we don't need to create the events
    // and timers below.
    //
    if (HotPlugInitialized) {
        return bAnyHotPlugDevices;
    }

    hEjectEvent = CreateEvent(NULL, TRUE, TRUE, HPLUG_EJECT_EVENT);

    HotPlugInitialized = TRUE;

    return bAnyHotPlugDevices;
}

BOOL
HotPlug_CheckEnable(
    HWND hWnd,
    BOOL bSvcEnabled
    )
/*++

Routine Description:

   Called at init time and whenever services are enabled/disabled.
   Hotplug is always alive to receive device change notifications.

   The shell notify icon is enabled\disabled depending on:

   - systray registry setting for services,
        AND
   - availability of removable devices.


Arguments:

   hwnd - Our Window handle

   bSvcEnabled - TRUE Service is being enabled.


Return Value:

   BOOL Returns TRUE if active.


--*/

{
    BOOL EnableShellIcon;
    HANDLE hHotplugBalloonEvent = NULL;

    //
    // If we are being enabled and we are already enabled, or we
    // are being disabled and we are already disabled then just
    // return since we have nothing to do.
    //
    if (ServiceEnabled == bSvcEnabled) {
        return ServiceEnabled;
    }

    ServiceEnabled = bSvcEnabled;

    //
    // There are some special checks we need to make if we are enabling the
    // hotplug service.
    //
    if (bSvcEnabled) {
        //
        // If this is a remote session and the user does not have the
        // SE_LOAD_DRIVER_NAME privileges then we won't enable the service
        // since they do not have the privileges to stop any hotplug devices.
        //
        if (GetSystemMetrics(SM_REMOTESESSION) &&
            !pDoesUserHavePrivilege((PCTSTR)SE_LOAD_DRIVER_NAME)) {
            ServiceEnabled = FALSE;

        } else {
            //
            // hotplug.dll will disable the hotplug service when it is
            // displaying a balloon for a safe removal event. When it is 
            // displaying it's balloon we don't want to enable our service 
            // because then there will be two hotplug icons in the tray. 
            // So if it's named event is set then we will ignore any attempts 
            // to enable our service.  Once hotplug.dll's balloon has gone 
            // away then it will automatically enable the hotplug service.
            //
            hHotplugBalloonEvent = CreateEvent(NULL,
                                               FALSE,
                                               TRUE,
                                               TEXT("Local\\HotPlug_TaskBarIcon_Event")
                                               );

            if (hHotplugBalloonEvent) {

                if (WaitForSingleObject(hHotplugBalloonEvent, 0) != WAIT_OBJECT_0) {
                    ServiceEnabled = FALSE;
                }

                CloseHandle(hHotplugBalloonEvent);
            }
        }
    }

    EnableShellIcon = ServiceEnabled && HotPlugInit(hWnd);

    HotPlugShowNotifyIcon(hWnd, EnableShellIcon);

    return EnableShellIcon;
}

DWORD
HotPlugEjectDevice_Thread(
   LPVOID pThreadParam
   )
{
    DEVNODE DevNode = (DEVNODE)(ULONG_PTR)pThreadParam;
    CONFIGRET ConfigRet;

    ConfigRet = CM_Request_Device_Eject_Ex(DevNode,
                                           NULL,
                                           NULL,
                                           0,
                                           0,
                                           NULL);

    //
    // Set the hEjectEvent so that the right-click popup menu will work again 
    // now that we are finished ejecting/stopping the device.
    //
    SetEvent(hEjectEvent);

    SetLastError(ConfigRet);
    return (ConfigRet == CR_SUCCESS);
}

void
HotPlugEjectDevice(
    HWND hwnd,
    DEVNODE DevNode
    )
{
    DWORD ThreadId;

    //
    // Reset the hEjectEvent so that the user can't bring up the right-click 
    // popup menu when we are in the process of ejecting/stopping a device.
    //
    ResetEvent(hEjectEvent);

    //
    // We need to have stobject.dll eject/stop the device on a separate 
    // thread because if we remove a device that stobject.dll listens for 
    // (battery, sound, ect.) we will cause a large delay and the eject/stop 
    // could end up getting vetoed because the stobject.dll code could not be 
    // processed and release it's handles because we were locking up the main
    // thread.
    //
    CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE)HotPlugEjectDevice_Thread,
                 (LPVOID)(ULONG_PTR)DevNode,
                 0,
                 &ThreadId
                 );
}

void
HotPlug_Timer(
   HWND hwnd
   )
/*++

Routine Description:

   Hotplug Timer msg handler, used to invoke hmenuEject for single Left click

Arguments:

   hDlg - Our Window handle


Return Value:

   BOOL Returns TRUE if active.


--*/

{
    POINT pt;
    UINT MenuIndex;
    PHOTPLUGDEVICES HotPlugDevicesList;
    PHOTPLUGDEVICES SingleHotPlugDevice;
    TCHAR  MenuDeviceName[MAX_PATH+64];
    TCHAR  Format[64];

    KillTimer(hwnd, HOTPLUG_TIMER_ID);

    if (!HotPlugInitialized) {

        PostMessage(hwnd, STWM_ENABLESERVICE, 0, TRUE);
        return;
    }

    //
    // We only want to create the popup menu if the hEjectEvent is signaled.  
    // If it is not signaled then we are in the middle of ejecting/stopping 
    // a device on a separate thread and don't want to allow the user to 
    // bring up the menu until we are finished with that device.
    //
    if (!hEjectEvent ||
        WaitForSingleObject(hEjectEvent, 0) == WAIT_OBJECT_0) {

        //
        // We are not in the middle of ejecting/stopping a device so we should 
        // display the popup menu.
        //
        HMENU hmenuEject = CreatePopupMenu();
        if (hmenuEject) {
            SetForegroundWindow(hwnd);
            GetCursorPos(&pt);

            //
            // Add each of the removable devices in the list to the menu.
            //
            if (!AddHotPlugDevices(&HotPlugDevicesList)) {
                DestroyMenu(hmenuEject);
                return;
            }

            SingleHotPlugDevice = HotPlugDevicesList;

            //
            // Add a title and separator at the top of the menu.
            //
            LoadString(g_hInstance,
                       IDS_HPLUGMENU_REMOVE,
                       Format,
                       sizeof(Format)/sizeof(TCHAR)
                       );

            MenuIndex = 1;

            while (SingleHotPlugDevice) {

                StringCchPrintf(MenuDeviceName, 
                                ARRAYSIZE(MenuDeviceName),
                                Format, 
                                SingleHotPlugDevice->DevName);
                AppendMenu(hmenuEject, MF_STRING, MenuIndex, MenuDeviceName);
                SingleHotPlugDevice->EjectMenuIndex = MenuIndex++;
                SingleHotPlugDevice = SingleHotPlugDevice->Next;
            }

            MenuIndex = TrackPopupMenu(hmenuEject,
                                       TPM_LEFTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                                       pt.x,
                                       pt.y,
                                       0,
                                       hwnd,
                                       NULL
                                       );

            SingleHotPlugDevice = HotPlugDevicesList;

            while (SingleHotPlugDevice) {

                if (MenuIndex == SingleHotPlugDevice->EjectMenuIndex) {
                    DEVNODE DevNode;

                    if (CM_Locate_DevNode(&DevNode,
                                          SingleHotPlugDevice->DevInstanceId,
                                          0) == CR_SUCCESS) {
                        HotPlugEjectDevice(hwnd, DevNode);
                    }
                    break;
                }

                SingleHotPlugDevice = SingleHotPlugDevice->Next;
            }


            if (!SingleHotPlugDevice) {

                SetIconFocus(hwnd, STWM_NOTIFYHOTPLUG);
            }

            FreeHotPlugDevicesList(&HotPlugDevicesList);
        }

        DestroyMenu(hmenuEject);
    }

    return;
}

void
HotPlugContextMenu(
   HWND hwnd
   )
{
    POINT pt;
    HMENU ContextMenu;
    UINT MenuIndex;
    TCHAR Buffer[MAX_PATH];


    ContextMenu = CreatePopupMenu();
    if (!ContextMenu) {
        return;
    }

    SetForegroundWindow(hwnd);
    GetCursorPos(&pt);

    LoadString(g_hInstance, IDS_HPLUGMENU_PROPERTIES, Buffer, sizeof(Buffer)/sizeof(TCHAR));
    AppendMenu(ContextMenu, MF_STRING,IDS_HPLUGMENU_PROPERTIES, Buffer);

    SetMenuDefaultItem(ContextMenu, IDS_HPLUGMENU_PROPERTIES, FALSE);


    MenuIndex = TrackPopupMenu(ContextMenu,
                               TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                               pt.x,
                               pt.y,
                               0,
                               hwnd,
                               NULL
                               );

    switch (MenuIndex) {
        case IDS_HPLUGMENU_PROPERTIES:
            SysTray_RunProperties(IDS_RUNHPLUGPROPERTIES);
            break;
    }

    DestroyMenu(ContextMenu);

    SetIconFocus(hwnd, STWM_NOTIFYHOTPLUG);

    return;
}

void
HotPlug_Notify(
   HWND hwnd,
   WPARAM wParam,
   LPARAM lParam
   )

{
    switch (lParam) {

    case WM_RBUTTONUP:
        HotPlugContextMenu(hwnd);
        break;

    case WM_LBUTTONDOWN:
        SetTimer(hwnd, HOTPLUG_TIMER_ID, GetDoubleClickTime()+100, NULL);
        break;

    case WM_LBUTTONDBLCLK:
        KillTimer(hwnd, HOTPLUG_TIMER_ID);
        SysTray_RunProperties(IDS_RUNHPLUGPROPERTIES);
        break;
    }

    return;
}

int
HotPlug_DeviceChangeTimer(
   HWND hDlg
   )
{
    BOOL bAnyHotPlugDevices, bNewHotPlugDevice;
    BOOL bRemovableDeviceAdded, bRemovableDeviceRemoved, bRemovableDeviceFailure;
    HDEVINFO hNewDeviceInfoSet;

    KillTimer(hDlg, HOTPLUG_DEVICECHANGE_TIMERID);

    //
    // If the service is not enabled then don't bother because the icon will NOT
    // be shown, sounds will not be played, etc.  (see notes for
    // HotplugPlaySoundThisSession).
    //
    if (!ServiceEnabled) {
        goto Clean0;
    }

    //
    // Get a new "current" list of all devices present in the system.
    //
    hNewDeviceInfoSet = SetupDiGetClassDevs(NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES | DIGCF_PRESENT);

    //
    // Update the list of removable devices, based on the new current list.
    //
    UpdateRemovableDeviceList(hNewDeviceInfoSet,
                              &bRemovableDeviceAdded,
                              &bRemovableDeviceRemoved,
                              &bRemovableDeviceFailure);

    //
    // If we should play sounds in this session, check if any removable devices
    // were either added or removed.
    //
    if (HotplugPlaySoundThisSession()) {
        //
        // We'll only play one sound at a time, so if we discover that multiple
        // events have happened simultaneously, let failure override arrival,
        // which overrides removal.  This way the user receives notification of
        // the most important event.
        //
        if (bRemovableDeviceFailure) {
            PlaySound(DEVICE_FAILURE_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        } else if (bRemovableDeviceAdded) {
            PlaySound(DEVICE_ARRIVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        } else if (bRemovableDeviceRemoved) {
            PlaySound(DEVICE_REMOVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
        }
    }

    //
    // Let's see if we have any hot plug devices, which means we need to
    // show the systray icon.  We also want to know about new hotplug
    // devices that just arrived, so we compare the set of removable devices
    // (which we just updated) against the old current set of devices in the
    // system.
    //
    bAnyHotPlugDevices = AnyHotPlugDevices(g_hRemovableDeviceInfoSet,
                                           g_hCurrentDeviceInfoSet,
                                           &bNewHotPlugDevice);


    if (bAnyHotPlugDevices) {
        //
        // We have some hotplug devices so make sure the icon is shown
        //
        if (!ShowShellIcon) {
            HotPlugShowNotifyIcon(hDlg, TRUE);
        }
    } else {
        //
        // There are NOT any hot plug devices so if the icon is still being
        // shown, then hide it.
        //
        if (ShowShellIcon) {
            HotPlugShowNotifyIcon(hDlg, FALSE);
        }
    }

    //
    // Delete the old current list of devices and set it
    // (g_hCurrentDeviceInfoSet) to the new current list.
    //
    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
    }

    g_hCurrentDeviceInfoSet = hNewDeviceInfoSet;

 Clean0:

    return 0;
}

void
HotPlug_DeviceChange(
   HWND hwnd,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

    Handle WM_DEVICECHANGE messages.

Arguments:

   hDlg        - Window handle of Dialog

   wParam  - DBT Event

   lParam  - DBT event notification type.

Return Value:

--*/

{
    LARGE_INTEGER liDelayTime;
    NOTIFYICONDATA nid;
    BOOL bPresent;

    switch(wParam) {

        case DBT_DEVNODES_CHANGED:
            //
            // To avoid deadlock with CM, a timer is started and the timer
            // message handler does the real work.
            //
            SetTimer(hwnd, HOTPLUG_DEVICECHANGE_TIMERID, 100, NULL);
            break;

        case DBT_CONFIGCHANGED:
            //
            // A docking event (dock, undock, surprise undock, etc) has
            // occured. Play a sound for hardware profile changes if we're 
            // supposed to.
            //
            if (HotplugPlaySoundThisSession()) {
                if ((CM_Is_Dock_Station_Present(&bPresent) == CR_SUCCESS) &&
                    (bPresent)) {
                    //
                    // If there is a dock present, we most-likely just docked
                    // (though we may have just ejected one of many docks), so
                    // play an arrival.
                    //
                    PlaySound(DEVICE_ARRIVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
                } else {
                    //
                    // If no dock is present we just undocked, so play a
                    // removal.
                    //
                    PlaySound(DEVICE_REMOVAL_SOUND, NULL, SND_ASYNC|SND_NODEFAULT);
                }
            }
            break;

        default:
            break;
    }

    return;
}

void
HotPlug_WmDestroy(
    HWND hWnd
    )
{
    if (hEjectEvent) {
        CloseHandle(hEjectEvent);
    }

    if (g_hCurrentDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hCurrentDeviceInfoSet);
        g_hCurrentDeviceInfoSet = INVALID_HANDLE_VALUE;
    }

    if (g_hRemovableDeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(g_hRemovableDeviceInfoSet);
        g_hRemovableDeviceInfoSet = INVALID_HANDLE_VALUE;
    }
}

void
HotPlug_SessionChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // If our console session is getting disconnected then disable our service
    // since we don't need to do any work if no UI is being displayed.
    //
    // If our console session is getting connected then re-enable our service.
    //
    if ((wParam == WTS_CONSOLE_CONNECT) ||
        (wParam == WTS_REMOTE_CONNECT)) {
        HotPlug_CheckEnable(hWnd, TRUE);
    } else if ((wParam == WTS_CONSOLE_DISCONNECT) ||
               (wParam == WTS_REMOTE_DISCONNECT)) {
        HotPlug_CheckEnable(hWnd, FALSE);
    }
}

BOOL
IsFastUserSwitchingEnabled(
    VOID
    )

/*++

Routine Description:

    Checks to see if Terminal Services Fast User Switching is enabled.  This is
    to check if we should use the physical console session for UI dialogs, or
    always use session 0.

    Fast User Switching exists only on workstation product version, where terminal
    services are available, when AllowMultipleTSSessions is set.

    On server and above, or when multiple TS users are not allowed, session 0
    can only be attached remotely be special request, in which case it should be
    considered the "Console" session.

Arguments:

    None.

Return Value:

    Returns TRUE if Fast User Switching is currently enabled, FALSE otherwise.

--*/

{
    static BOOL bVerified = FALSE;
    static BOOL bIsTSWorkstation = FALSE;

    HKEY   hKey;
    ULONG  ulSize, ulValue;
    BOOL   bFusEnabled;

    //
    // Verify the product version if we haven't already.
    //
    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        osvix.wProductType = VER_NT_WORKSTATION;
        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_PRODUCT_TYPE | VER_SUITENAME,
                              dwlConditionMask)) {
            bIsTSWorkstation = TRUE;
        }

        bVerified = TRUE;
    }

    //
    // Fast user switching (FUS) only applies to the Workstation product where
    // Terminal Services are enabled (i.e. Personal, Professional).
    //
    if (!bIsTSWorkstation) {
        return FALSE;
    }

    //
    // Check if multiple TS sessions are currently allowed.  We can't make this
    // info static because it can change dynamically.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    ulValue = 0;
    ulSize = sizeof(ulValue);
    bFusEnabled = FALSE;

    if (RegQueryValueEx(hKey,
                        TEXT("AllowMultipleTSSessions"),
                        NULL,
                        NULL,
                        (LPBYTE)&ulValue,
                        &ulSize) == ERROR_SUCCESS) {
        bFusEnabled = (ulValue != 0);
    }
    RegCloseKey(hKey);

    return bFusEnabled;

} // IsFastUserSwitchingEnabled

BOOL
HotplugPlaySoundThisSession(
    VOID
    )

/*++

Routine Description:

    This routine determines whether a sound should be played in the current
    session.

Arguments:

    None.

Return Value:

    Returns TRUE if sounds should be played in this session.

Notes:

    The user-mode plug and play manager (umpnpmgr.dll) implements the following
    behavior for UI dialogs:

    * When Fast User Switching is enabled, only the physical Console session
      is used for UI dialogs.

    * When Fast User Switching is not enabled, only Session 0 is used for UI
      dialogs.

    Since sound events require no user interaction there is no problem with
    multiple sessions responding to these events simultaneously.

    We should *always* play a sound on the physical console when possible, and
    adopt a behavior similar to umpnpmgr for for the non-Fast User Switching
    case, such that session 0 will also play sound events when possible because
    it should be treated somewhat special in the non-FUS case...

    ... BUT, since we disable the service altogether if the session is remote
    and the user doesn't have permission to eject hotplug devices (so we don't
    show the icon), we won't even respond to DBT_DEVNODES_CHANGED events, and
    consequently won't play sound.  We could actually turn this on just by
    allowing those events to be processed when the services is disabled, but
    this function is successful.  Since the idea of allowing hardware events on
    remote session 0 without FUS is really just for remote management, then it's
    probably ok that we don't play sounds for a user that can't manage hardware.

--*/

{
    //
    // Always play sound events on the physical console.
    //
    if (IsConsoleSession()) {
        return TRUE;
    }

    //
    // If fast user switching is not enabled, play sound events on the
    // pseudo-console (Session 0) also.
    //
    if ((IsPseudoConsoleSession()) &&
        (!IsFastUserSwitchingEnabled())) {
        return TRUE;
    }

    //
    // Otherwise, no sound.
    //
    return FALSE;

} // HotplugPlaySoundThisSession

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\power.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       POWER.C
*
*  VERSION:     2.0
*
*  AUTHOR:      TCS/RAL
*
*  DATE:        08 Feb 1994
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  08 Feb 1994 TCS Original implementation.
*  11 Nov 1994 RAL Converted from batmeter to systray
*  11 Aug 1995 JEM Split batmeter functions into power.c & minor enahncements
*  23 Oct 1995 Shawnb UNICODE Enabled
*  24 Jan 1997 Reedb ACPI power management, common battery meter code.
*
*******************************************************************************/

#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <initguid.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "systray.h"

#include "batmeter.h"
#include "powrprof.h"
#include "powercfp.h"

#define UPDATE_REGISTRY TRUE
#define NO_REGISTRY_UPDATE FALSE

// Structure to manage the power profile enum proc parameters.
typedef struct _POWER_PROFILE_ENUM_PROC_PARAMS
{
    UINT    uiCurActiveIndex;
    HMENU   hMenu;
    UINT    uiCurActiveID;
} POWER_PROFILE_ENUM_PROC_PARAMS, *PPOWER_PROFILE_ENUM_PROC_PARAMS;


// G L O B A L  D A T A -------------------------------------------------------
BOOL    g_bPowerEnabled;      // Tracks the power service state.
UINT    g_uiPowerSchemeCount; // Number of power schemes, left context menu.
HMENU   g_hMenu[2];           // Context menus.

// BatMeter creation parameters.
HWND    g_hwndBatMeter;
BOOL    g_bShowMulti;
HWND    g_hwndBatMeterFrame;

GLOBAL_POWER_POLICY g_gpp;

// Context sensitive help must be added to the windows.hlp file,
// for now we will use this dummy array define. Remove when windows.hlp updated.

#define IDH_POWERCFG_ENABLEMULTI IDH_POWERCFG_POWERSTATUSBAR

const DWORD g_ContextMenuHelpIDs[] = {
    IDC_POWERSTATUSGROUPBOX,    IDH_COMM_GROUPBOX,
    IDC_ENABLEMETER,            IDH_POWERCFG_ENABLEMETER,
    IDC_ENABLEMULTI,            IDH_POWERCFG_ENABLEMULTI,
    0, 0
};

// Used to track registration for WM_DEVICECHANGED message.
HDEVNOTIFY g_hDevNotify;

/*******************************************************************************
*
*  RunningOffLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN RunningOffLine(void)
{
   SYSTEM_POWER_STATUS  sps;
   BOOLEAN              bRet = FALSE;

   if (GetSystemPowerStatus(&sps)) {
      if (sps.ACLineStatus == 0) {
         bRet = TRUE;
      }
   }
   return bRet;
}

/*----------------------------------------------------------------------------
 * Power_OnCommand
 *
 * Process WM_COMMAND msgs for the battery meter dialog.
 *
 *----------------------------------------------------------------------------*/

void
Power_OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    BOOL  Checked;
    DWORD dwMask;
    UINT  uiCommandID = GET_WM_COMMAND_ID(wParam, lParam);

    switch (uiCommandID) {

        case IDC_ENABLEMETER:
            dwMask = EnableSysTrayBatteryMeter;
            goto DoUpdateFlags;

        case IDC_ENABLEMULTI:
            dwMask = EnableMultiBatteryDisplay;
            goto DoUpdateFlags;

DoUpdateFlags:
            Checked = (IsDlgButtonChecked(hWnd, uiCommandID) == BST_CHECKED);
            Update_PowerFlags(dwMask, Checked);
            if (uiCommandID == IDC_ENABLEMETER) {
                PowerCfg_Notify();
                SysTray_EnableService(STSERVICE_POWER, g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter);
            }
            else {
                g_bShowMulti = Checked;
                Power_UpdateStatus(hWnd, NIM_MODIFY, TRUE);
            }
            break;

        case IDCANCEL:
            EndDialog(hWnd, wParam);
            break;

        default:
            // Notify battery meter of enter key events.
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage(g_hwndBatMeter, WM_COMMAND, wParam, lParam);
            }
    }
}

/*******************************************************************************
*
*  Power_OnPowerBroadcast
*
*  DESCRIPTION:
*   Process WM_POWERBROADCAS message for the battery meter dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_OnPowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   if (wParam == PBT_APMPOWERSTATUSCHANGE) {

      // If the power icon is not showing (power service disabled) and
      // we are running on batteries, enable the systray power service.
      if (!g_bPowerEnabled && RunningOffLine()) {
         PostMessage(hWnd, STWM_ENABLESERVICE, STSERVICE_POWER, TRUE);
      } else

      // If the power icon is showing (power service enabled) and
      // we are not running on batteries, disable the systray power service.
      if (g_bPowerEnabled && !RunningOffLine()) {
         PostMessage(hWnd, STWM_ENABLESERVICE, STSERVICE_POWER, FALSE);
      }

      // Don't change the state of the power service, just update the icon.
      Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
   }
}

/*******************************************************************************
*
*  Power_OnDeviceChange
*
*  DESCRIPTION:
*   Process WM_DEVICECHANGE message for the battery meter dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_OnDeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   //
   // Only listen to the WM_DEVICECHANGE if it is for GUID_DEVICE_BATTERY and
   // it is a DBT_DEVICEARRIVAL, DBT_DEVICEREMOVECOMPLETE, or DBT_DEVICEQUERYREMOVEFAILED.
   //
   if (((wParam == DBT_DEVICEARRIVAL) ||
       (wParam == DBT_DEVICEREMOVECOMPLETE) ||
       (wParam == DBT_DEVICEQUERYREMOVEFAILED)) &&
       (lParam) &&
       (((PDEV_BROADCAST_DEVICEINTERFACE)lParam)->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE) &&
       (IsEqualGUID(&((PDEV_BROADCAST_DEVICEINTERFACE)lParam)->dbcc_classguid, &GUID_DEVICE_BATTERY))) {

      // Make sure BatMeter has been initialized.
      if (g_hwndBatMeterFrame) {
         if (g_hwndBatMeter) {
            g_hwndBatMeter = DestroyBatMeter(g_hwndBatMeter);
         }
         g_hwndBatMeter = CreateBatMeter(hWnd,
                                         g_hwndBatMeterFrame,
                                         g_bShowMulti,
                                         NULL);
         InvalidateRect(hWnd, NULL, TRUE);
      }
   }
}

/*******************************************************************************
*
*  Power_OnActivate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOLEAN Power_OnActivate(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
   if (g_hwndBatMeter) {
      SendMessage(g_hwndBatMeter, WM_ACTIVATE, wParam, lParam);
      return TRUE;
   }
   return FALSE;
}

/*******************************************************************************
*
*  PowerProfileEnumProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define POWERMENU_SCHEME 300

BOOLEAN CALLBACK PowerProfileEnumProc(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPTSTR                  lpszName,
    DWORD                   dwDescSize,
    LPTSTR                  lpszDesc,
    PPOWER_POLICY           ppp,
    LPARAM                  lParam
)
{
    PPOWER_PROFILE_ENUM_PROC_PARAMS pppepp;
    MENUITEMINFO mii;

    if ((pppepp = (PPOWER_PROFILE_ENUM_PROC_PARAMS) lParam) == NULL) {
        return FALSE;
    }

    AppendMenu(pppepp->hMenu, MF_STRING,
               POWERMENU_SCHEME + g_uiPowerSchemeCount, lpszName);

    // Store the power scheme ID in the menu info.
    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_DATA;
    mii.dwItemData = uiID;
    SetMenuItemInfo(pppepp->hMenu,
                    POWERMENU_SCHEME + g_uiPowerSchemeCount,
                    FALSE, &mii);

    if (uiID == pppepp->uiCurActiveID) {
        pppepp->uiCurActiveIndex = POWERMENU_SCHEME + g_uiPowerSchemeCount;
    }

    g_uiPowerSchemeCount++;
    return TRUE;
}

/*----------------------------------------------------------------------------
 * GetPowerMenu()
 *
 * Build a menu containing battery meter/power selections.
 *
 *----------------------------------------------------------------------------*/

#define POWERMENU_OPEN          100
#define POWERMENU_PROPERTIES    101

#define POWERMENU_ENABLEWARN    200
#define POWERMENU_SHOWTIME      201
#define POWERMENU_SHOWPERCENT   202


HMENU
GetPowerMenu(LONG l)
{
    LPTSTR  lpszMenu;
    UINT    uiCurActiveID;

    POWER_PROFILE_ENUM_PROC_PARAMS  ppepp;

    if (l > 0)
    {
        // Right button menu -- can change, rebuild each time.
       if (g_hMenu[0])
       {
           DestroyMenu(g_hMenu[0]);
       }

       g_hMenu[1] = CreatePopupMenu();

       // Properties for Power, PowerCfg.
       if ((lpszMenu = LoadDynamicString(IDS_PROPFORPOWER)) != NULL)
       {
           AppendMenu(g_hMenu[1], MF_STRING, POWERMENU_PROPERTIES, lpszMenu);
           DeleteDynamicString(lpszMenu);
       }

       // If we have a battery meter, add it's menu item and set as default.
       if (g_hwndBatMeter) {
           if ((lpszMenu = LoadDynamicString(IDS_OPEN)) != NULL)
           {
               AppendMenu(g_hMenu[1], MF_STRING, POWERMENU_OPEN, lpszMenu);
               DeleteDynamicString(lpszMenu);
           }
           // Open BatMeter is default (double click action)
           SetMenuDefaultItem(g_hMenu[1], POWERMENU_OPEN, FALSE);
       }
       else {
           // Use open PowerCfg as default (double click action)
           SetMenuDefaultItem(g_hMenu[1], POWERMENU_PROPERTIES, FALSE);
       }
    }

    // Left button menu -- can change, rebuild each time.
    if (g_hMenu[0])
    {
        DestroyMenu(g_hMenu[0]);
    }

    g_hMenu[0] = CreatePopupMenu();

    // Get the currently active power policies.
    if (GetActivePwrScheme(&uiCurActiveID)) {
        g_uiPowerSchemeCount = 0;
        ppepp.hMenu = g_hMenu[0];
        ppepp.uiCurActiveID = uiCurActiveID;
        EnumPwrSchemes(PowerProfileEnumProc, (LPARAM)&ppepp);

        // Check the currently active menu item.
        CheckMenuRadioItem(g_hMenu[0],
                           POWERMENU_SCHEME,
                           POWERMENU_SCHEME + g_uiPowerSchemeCount - 1,
                           ppepp.uiCurActiveIndex,
                           MF_BYCOMMAND);
    }
    return g_hMenu[l];
}

/*----------------------------------------------------------------------------
 * Power_Open
 *
 * Update and display the battery meter dialog
 *
 *----------------------------------------------------------------------------*/

void
Power_Open(HWND hWnd)
{
    if (g_hwndBatMeter) {
        SetFocus(GetDlgItem(hWnd, IDC_ENABLEMETER));
        CheckDlgButton(hWnd, IDC_ENABLEMULTI,
                       (g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay) ?
                       BST_CHECKED : BST_UNCHECKED);

        CheckDlgButton(hWnd, IDC_ENABLEMETER,
                       (g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter) ?
                       BST_CHECKED : BST_UNCHECKED);

        Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE); // show current info
        ShowWindow(hWnd, SW_SHOW);
        SetForegroundWindow(hWnd);
    }
    else {
        SysTray_RunProperties(IDS_RUNPOWERPROPERTIES);
    }
}


/*----------------------------------------------------------------------------
 * DoPowerMenu
 *
 * Create and process a right or left button menu.
 *
 *----------------------------------------------------------------------------*/

void
DoPowerMenu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT pt;
    UINT iCmd;
    MENUITEMINFO mii;

    SetForegroundWindow(hwnd);
    GetCursorPos(&pt);

    iCmd = (UINT)TrackPopupMenu(GetPowerMenu(uMenuNum),
                          uButton | TPM_RETURNCMD | TPM_NONOTIFY,
                          pt.x, pt.y, 0, hwnd, NULL);

    if (iCmd >= POWERMENU_SCHEME) {
        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_DATA;
        if (GetMenuItemInfo(g_hMenu[uMenuNum], iCmd, FALSE, &mii)) {
            SetActivePwrScheme((UINT)mii.dwItemData, NULL, NULL);
            PowerCfg_Notify();
        }
    }
    else {
        switch (iCmd) {

            case POWERMENU_OPEN:
                Power_Open(hwnd);
                break;

            case POWERMENU_PROPERTIES:
                SysTray_RunProperties(IDS_RUNPOWERPROPERTIES);
                break;

            case 0:
                // The user cancelled the menu without choosing.
                SetIconFocus(hwnd, STWM_NOTIFYPOWER);
                break;
        }
    }
}


/*----------------------------------------------------------------------------
 * Power_Notify
 *
 * Handle a notification from the power tray icon.
 *
 *----------------------------------------------------------------------------*/

#define PN_TIMER_CLEAR  0
#define PN_TIMER_SET    1
#define PN_DBLCLK       2

UINT g_uiTimerSet = PN_TIMER_CLEAR;
LARGE_INTEGER g_liHoverUpdateTime = {0,0};

void Power_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    LARGE_INTEGER liPerformanceFrequency;
    LARGE_INTEGER liPerformanceCount;

    switch (lParam)
    {
    case WM_RBUTTONUP:
        DoPowerMenu(hWnd, 1, TPM_RIGHTBUTTON);  // right button menu
        break;

    case WM_LBUTTONUP:
        // start timing for left button menu
        if (g_uiTimerSet == PN_TIMER_CLEAR) {
            SetTimer(hWnd, POWER_TIMER_ID, GetDoubleClickTime()+100, NULL);
            g_uiTimerSet = PN_TIMER_SET;
        }
        break;

    case WM_LBUTTONDBLCLK:
        g_uiTimerSet = PN_DBLCLK;
        Power_Open(hWnd);                       // show battery meter dialog
        break;

    case WM_MOUSEMOVE:
        if (QueryPerformanceFrequency (&liPerformanceFrequency)) {
            if (QueryPerformanceCounter (&liPerformanceCount)) {
                // Update no more than once a second
                if ((liPerformanceCount.QuadPart - g_liHoverUpdateTime.QuadPart) >
                    liPerformanceFrequency.QuadPart) {
                    g_liHoverUpdateTime = liPerformanceCount;
                    Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
                }
            }
        }
        break;

    }
}

/*-----------------------------------------------------------------------------
 * Power_Timer
 *
 * Execute the left button menu on WM_LBUTTONDOWN time-out.
 *
 *----------------------------------------------------------------------------*/

void Power_Timer(HWND hwnd)
{
    KillTimer(hwnd, POWER_TIMER_ID);
    if (g_uiTimerSet != PN_DBLCLK) {
        DoPowerMenu(hwnd, 0, TPM_LEFTBUTTON);
    }
    g_uiTimerSet = PN_TIMER_CLEAR;
}

/*----------------------------------------------------------------------------
 * Update_PowerFlags
 *
 * Set power flags using powrprof.dll API's.
 *
 *----------------------------------------------------------------------------*/

void Update_PowerFlags(DWORD dwMask, BOOL bEnable)
{
    if (bEnable) {
        g_gpp.user.GlobalFlags |= dwMask;
    }
    else {
        g_gpp.user.GlobalFlags &= ~dwMask;
    }
    WriteGlobalPwrPolicy(&g_gpp);
}

/*----------------------------------------------------------------------------
 * Get_PowerFlags
 *
 * Get power flags using powrprof.dll API's.
 *
 *----------------------------------------------------------------------------*/

DWORD Get_PowerFlags(void)
{
    ReadGlobalPwrPolicy(&g_gpp);
    return g_gpp.user.GlobalFlags;
}


/*******************************************************************************
*
*  BatteryMeterInit
*
*  DESCRIPTION:
*       NOTE: Can be called multiple times.  Simply re-init.
*
*  PARAMETERS:
*     (returns), TRUE if the Battery Meter could be enabled
*
*******************************************************************************/

BOOL PASCAL BatteryMeterInit(HWND hWnd)
{
   PUINT puiBatCount = NULL;

   if (!BatMeterCapabilities(&puiBatCount)) {
      return FALSE;
   }

   if (!g_hwndBatMeter) {
      g_hwndBatMeterFrame = GetDlgItem(hWnd, IDC_STATIC_FRAME_BATMETER);
      g_bShowMulti = g_gpp.user.GlobalFlags & EnableMultiBatteryDisplay;
      g_hwndBatMeter = CreateBatMeter(hWnd,
                                      g_hwndBatMeterFrame,
                                      g_bShowMulti,
                                      NULL);
   }
   return TRUE;
}

/*******************************************************************************
*
*  Power_UpdateStatus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID PASCAL Power_UpdateStatus(
    HWND hWnd,
    DWORD NotifyIconMessage,
    BOOL bForceUpdate
)
{
   static  TCHAR szTipCache[64];
   static  HICON hIconCache;

   TCHAR   szTip[64];
   LPTSTR  lpsz;
   BATTERY_STATE bs;
   UINT    uiHour, uiMin;

   *szTip = 0;

   bs.ulSize = sizeof(BATTERY_STATE);
   UpdateBatMeter(g_hwndBatMeter,
                  g_bShowMulti,
                  bForceUpdate,
                  &bs);

   // Build up a new tool tip.
   if (g_hwndBatMeter &&
       !(((bs.ulPowerState & BATTERY_POWER_ON_LINE) &&
          !(bs.ulPowerState & BATTERY_CHARGING)))) {

      if (bs.ulBatLifePercent <= 100) {
         if (bs.ulBatLifeTime != (UINT) -1) {
            uiHour = bs.ulBatLifeTime / 3600;
            uiMin  = (bs.ulBatLifeTime % 3600) / 60;
            if (uiHour) {
               lpsz = LoadDynamicString(IDS_TIMEREMFORMATHOUR,
                                        uiHour, uiMin,
                                        bs.ulBatLifePercent);
            }
            else {
               lpsz = LoadDynamicString(IDS_TIMEREMFORMATMIN, uiMin,
                                        bs.ulBatLifePercent);
            }
            if (lpsz) {
               StrCpyN(szTip, lpsz, ARRAYSIZE(szTip));
               LocalFree(lpsz);
               if (bs.ulPowerState & BATTERY_CHARGING) {
                  if ((lpsz = LoadDynamicString(IDS_CHARGING)) != NULL) {
                     StrCatBuff(szTip, lpsz, ARRAYSIZE(szTip));
                     LocalFree(lpsz);
                  }
               }
            }
         }
         else {
            if ((lpsz = LoadDynamicString(IDS_REMAINING,
                                          bs.ulBatLifePercent)) != NULL) {
               StrCpyN(szTip, lpsz, ARRAYSIZE(szTip));
               LocalFree(lpsz);
               if (bs.ulPowerState & BATTERY_CHARGING) {
                  if ((lpsz = LoadDynamicString(IDS_CHARGING)) != NULL) {
                     StrCatBuff(szTip, lpsz, ARRAYSIZE(szTip));
                     LocalFree(lpsz);
                  }
               }
            }
         }
      }
      else {
         lpsz = LoadDynamicString(IDS_UNKNOWN);
         StrCpyN(szTip, lpsz, ARRAYSIZE(szTip));
         LocalFree(lpsz);
      }
   }
   else {
      lpsz = LoadDynamicString(IDS_ACPOWER);
      StrCpyN(szTip, lpsz, ARRAYSIZE(szTip));
      LocalFree(lpsz);
   }

   if ((NotifyIconMessage == NIM_ADD)  ||
       (hIconCache != bs.hIconCache16) ||
       (lstrcmp(szTip, szTipCache))) {

      hIconCache = bs.hIconCache16;
      StrCpyN(szTipCache, szTip, ARRAYSIZE(szTipCache));

      SysTray_NotifyIcon(hWnd, STWM_NOTIFYPOWER, NotifyIconMessage,
                         hIconCache, szTipCache);
   }
}

/*******************************************************************************
*
*  RegisterForDeviceNotification
*
*  DESCRIPTION:
*    Do onetime registration for WM_DEVICECHANGED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RegisterForDeviceNotification(HWND hWnd)
{
   DEV_BROADCAST_DEVICEINTERFACE dbc;

   memset(&dbc, 0, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
   dbc.dbcc_size         = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
   dbc.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
   dbc.dbcc_classguid    = GUID_DEVICE_BATTERY;
   g_hDevNotify = RegisterDeviceNotification(hWnd,
                                             &dbc,
                                             DEVICE_NOTIFY_WINDOW_HANDLE);
   if (!g_hDevNotify) {
      return FALSE;
   }
   return TRUE;
}

/*******************************************************************************
*
*  Power_WmDestroy
*
*  DESCRIPTION:
*
*
*  PARAMETERS:
*
*******************************************************************************/

void Power_WmDestroy(HWND hWnd)
{
   if (g_hDevNotify) {
      UnregisterDeviceNotification(g_hDevNotify);
      g_hDevNotify = NULL;
   }
}

/*******************************************************************************
*
*  Power_CheckEnable
*
*  DESCRIPTION:
*   Return TRUE if the power service icon was enabled.
*        Can be called multiple times.  Simply re-init.
*
*  PARAMETERS:
*     bSvcEnabled - Request to enable/disable power service on tray.
*
*******************************************************************************/

BOOL Power_CheckEnable(HWND hWnd, BOOL bSvcEnable)
{
   static BOOL bRegisteredForDC = FALSE;

   // Is there any reason to display the systray power icon?
   if (!PowerCapabilities()) {
      return FALSE;
   }

   // Do onetime registration for WM_DEVICECHANGED.
   if (!bRegisteredForDC) {
      bRegisteredForDC = RegisterForDeviceNotification(hWnd);
   }

   // Get current battery meter flags from the registry
   Get_PowerFlags();

   // Are we running on battery power or has the user set
   // the systray power icon to always on? If so, force enable.
   if ((g_gpp.user.GlobalFlags & EnableSysTrayBatteryMeter) ||
       (RunningOffLine())) {
      bSvcEnable = TRUE;
   }
   else {
      bSvcEnable = FALSE;
   }

   // Set the power service state.
   if (bSvcEnable) {
      if (g_bPowerEnabled) {
         Power_UpdateStatus(hWnd, NIM_MODIFY, FALSE);
      }
      else {
         BatteryMeterInit(hWnd);
         Power_UpdateStatus(hWnd, NIM_ADD, FALSE);
      }
      g_bPowerEnabled = TRUE;
   }
   else {
      SysTray_NotifyIcon(hWnd, STWM_NOTIFYPOWER, NIM_DELETE, NULL, NULL);
      g_bPowerEnabled = FALSE;
   }
   return g_bPowerEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\stdafx.h ===
// Global Headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>

#define NOPOWERSTATUSDEFINES

#include <mmsystem.h>
#include <shellapi.h>
#include <shlapip.h>
#include <commctrl.h>
#include <winuserp.h>
#include "pccrdapi.h"     
#include <systrayp.h>
#include <help.h>         
#include <dbt.h>
#include <ntpoapi.h>
#include <poclass.h>
#include <cscuiext.h>

#include <objbase.h>
#include <docobj.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <dbt.h>
#include <shfusion.h>

// Global vars
extern long g_cLocks;
extern long g_cComponents;
extern HINSTANCE g_hinstDll;

// Macros
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\stobject.h ===
#include "stclsid.h"

class CSysTray: public IOleCommandTarget
{
public:
    // IUnknown Implementation
    HRESULT __stdcall QueryInterface(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IOleCommandTarget Implementation
    HRESULT __stdcall QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    HRESULT __stdcall Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    CSysTray(BOOL fRunTrayOnConstruct);
    ~CSysTray();

private:
    // Data
    long m_cRef;

private:
    // Functions
    HRESULT CreateSysTrayThread();
    static DWORD WINAPI SysTrayThreadProc(void* lpv);
    HRESULT DestroySysTrayWindow();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\stresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       BMRESID.H
*
*  VERSION:     2.0
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        20 Feb 1994
*
*  Resource identifiers for the battery meter.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.  Seperated from RESOURCE.H so that
*                  some documentation could be added without AppStudio screwing
*                  it up later.
*
*******************************************************************************/

#ifndef _INC_STRESID
#define _INC_STRESID

//  Main battery meter dialog box.
#define IDD_BATTERYMETER                100

//  Control identifiers of IDD_BATTERYMETER.
#define IDC_STATIC_FRAME_BATMETER       1000
#define IDC_POWERSTATUSGROUPBOX         1001
#define IDC_ENABLEMETER                 1002
#define IDC_ENABLEMULTI                 1003

// Control identifiers for hotplug
#define IDI_HOTPLUG                     210
#define IDS_HOTPLUGTIP                  211
#define IDS_HPLUGMENU_PROPERTIES        215
#define IDS_HPLUGMENU_REMOVE            216
#define IDS_RUNHPLUGPROPERTIES          217
#define IDS_SEPARATOR			        218
#define IDS_DISKDRIVE			        219
#define IDS_DISKDRIVES			        220
#define IDS_DRIVELETTERS		        221
#define IDS_HOTPLUG_TITLE               222
#define IDS_HOTPLUG_INSERT_INFO         223


//  Control identifiers for Volume
#define IDI_VOLUME                      230
#define IDI_MUTE                        231
#define IDS_MMSYSPROPTITLE              233
#define IDS_MMSYSPROPTAB                234

#define IDS_VOLUME                      252
#define IDS_VOLUMEMENU1                 255
#define IDS_VOLUMEMENU2                 256
#define IDS_VOLUMEAPP                   257
#define IDS_MUTED                       258




// Control identifiers for Sticky Keys

#define IDI_STK000                      300
#define IDI_STK001                      301
#define IDI_STK002                      302
#define IDI_STK003                      303
#define IDI_STK004                      304
#define IDI_STK005                      305
#define IDI_STK006                      306
#define IDI_STK007                      307
#define IDI_STK008                      308
#define IDI_STK009                      309
#define IDI_STK00A                      310
#define IDI_STK00B                      311
#define IDI_STK00C                      312
#define IDI_STK00D                      313
#define IDI_STK00E                      314
#define IDI_STK00F                      315

#define IDI_MKTT                        316
#define IDI_MKTB                        317
#define IDI_MKTG                        318
#define IDI_MKBT                        319
#define IDI_MKBB                        320
#define IDI_MKBG                        321
#define IDI_MKGT                        322
#define IDI_MKGB                        323
#define IDI_MKGG                        324
#define IDI_MKPASS                      325

#define IDI_FILTER                      326
// access strings
#define IDS_STICKYKEYS                  330
#define IDS_MOUSEKEYS                   331
#define IDS_FILTERKEYS                  332

#define IDS_PROPFORPOWER                152
#define IDS_OPEN                        153
#define IDS_RUNPOWERPROPERTIES          157
#define IDS_REMAINING                   158
#define IDS_CHARGING                    159
#define IDS_UNKNOWN                     160
#define IDS_ACPOWER                     161
#define IDS_TIMEREMFORMATHOUR           162
#define IDS_TIMEREMFORMATMIN            163

#define IDI_BATTERYPLUG                 200

#endif // _INC_STRESID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\print.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.cpp

Abstract:

    This module implements the tray icon for printers.

Author:

    Lazar Ivanov (lazari) 17-May-2000 (initial creation)

Revision History:

--*/

#include "stdafx.h"

extern "C" {
#include <systray.h>

typedef BOOL WINAPI fntype_PrintNotifyTrayInit();
typedef BOOL WINAPI fntype_PrintNotifyTrayExit();

}

static HMODULE g_hPrintUI = NULL;
static fntype_PrintNotifyTrayInit *g_pfnPrintNotifyTrayInit = NULL;
static fntype_PrintNotifyTrayExit *g_pfnPrintNotifyTrayExit = NULL;
static LPCITEMIDLIST g_pidlPrintersFolder = NULL;
static UINT g_uPrintNotify = 0;


BOOL Print_SHChangeNotify_Register(HWND hWnd)
{
    if (NULL == g_hPrintUI && NULL == g_pidlPrintersFolder && 0 == g_uPrintNotify)
    {
        g_pidlPrintersFolder = SHCloneSpecialIDList(hWnd, CSIDL_PRINTERS, FALSE);
        if (g_pidlPrintersFolder)
        {
            SHChangeNotifyEntry fsne = {g_pidlPrintersFolder, TRUE};
            g_uPrintNotify = SHChangeNotifyRegister(hWnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel,
                                    SHCNE_CREATE | SHCNE_UPDATEITEM | SHCNE_DELETE,
                                    WM_PRINT_NOTIFY, 1, &fsne);
        }
    }
    return (g_pidlPrintersFolder && g_uPrintNotify);
}

BOOL Print_SHChangeNotify_Unregister()
{
    BOOL bReturn = (g_pidlPrintersFolder && g_uPrintNotify);

    if (g_uPrintNotify)
    {
        SHChangeNotifyDeregister(g_uPrintNotify);
        g_uPrintNotify = 0;
    }

    if (g_pidlPrintersFolder)
    {
        SHFree((void*)g_pidlPrintersFolder);
        g_pidlPrintersFolder = NULL;
    }
    
    return bReturn;
}

LRESULT Print_Notify(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch( uMsg )
    {
        case WM_PRINT_NOTIFY:
            {
                LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, NULL, NULL);
                if (pshcnl)
                {
                    // a print job was printed, init tray code
                    Print_TrayInit();
                    SHChangeNotification_Unlock(pshcnl);
                    lres = 1;
                }
            }
            break;
    }
    return lres;
}

BOOL Print_TrayInit()
{
    BOOL bReturn = FALSE;

    if (!g_hPrintUI)
    {
        g_hPrintUI = LoadLibrary(TEXT("printui.dll"));
        g_pfnPrintNotifyTrayInit = g_hPrintUI ? (fntype_PrintNotifyTrayInit *)GetProcAddress(g_hPrintUI, "PrintNotifyTray_Init") : NULL;
        g_pfnPrintNotifyTrayExit = g_hPrintUI ? (fntype_PrintNotifyTrayInit *)GetProcAddress(g_hPrintUI, "PrintNotifyTray_Exit") : NULL;
    }

    if( g_pfnPrintNotifyTrayInit && g_pfnPrintNotifyTrayExit )
    {
        // initialize print notify code
        bReturn = g_pfnPrintNotifyTrayInit();

        /*
         * temporary solution for bug #175462 until
         * we come up with better solution after Beta1
         *
        if (bReturn)
        {
            // no need to listen further...
            Print_SHChangeNotify_Unregister();
        }
         */
    }

    return bReturn;
}

BOOL Print_TrayExit()
{
    BOOL bReturn = FALSE;

    if( g_hPrintUI && g_pfnPrintNotifyTrayInit && g_pfnPrintNotifyTrayExit )
    {
        // shutdown the print tray notify code
        bReturn = g_pfnPrintNotifyTrayExit();
    }

    // cleanup...
    if( g_hPrintUI )
    {
        g_pfnPrintNotifyTrayInit = NULL;
        g_pfnPrintNotifyTrayExit = NULL;

        FreeLibrary(g_hPrintUI);
        g_hPrintUI = NULL;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\stclsid.h ===
// CLSIDs for my objects

// SysTray - This object creates normally and supports IOleCommandTarget to launch
// the systray thread.
// {35CEC8A3-2BE6-11d2-8773-92E220524153}
DEFINE_GUID(CLSID_SysTray, 
0x35cec8a3, 0x2be6, 0x11d2, 0x87, 0x73, 0x92, 0xe2, 0x20, 0x52, 0x41, 0x53);

// SysTrayInvoker - This guy automatically launches the systray thread as
// soon as he's created; works good with SHLoadInProc
// {730F6CDC-2C86-11d2-8773-92E220524153}
DEFINE_GUID(CLSID_SysTrayInvoker, 
0x730f6cdc, 0x2c86, 0x11d2, 0x87, 0x73, 0x92, 0xe2, 0x20, 0x52, 0x41, 0x53);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\stobject.cpp ===
#include "stdafx.h"
#include "stobject.h"
#include "systray.h"


#include <initguid.h>
// 7007ACCF-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionTray
DEFINE_GUID(CLSID_ConnectionTray,                   0x7007ACCF,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);

IOleCommandTarget *g_pctNetShell = NULL;

extern "C"
{
void StartNetShell()
{
    ASSERT(!g_pctNetShell);

    HRESULT hr = CoCreateInstance(CLSID_ConnectionTray, NULL, CLSCTX_INPROC_SERVER,
                            IID_IOleCommandTarget, (void **)&g_pctNetShell);

    if (SUCCEEDED(hr))
    {
        g_pctNetShell->Exec(&CGID_ShellServiceObject, SSOCMDID_OPEN, 0, NULL, NULL);
    }
}

void StopNetShell()
{
    if (g_pctNetShell)
    {
        g_pctNetShell->Exec(&CGID_ShellServiceObject, SSOCMDID_CLOSE, 0, NULL, NULL);
        g_pctNetShell->Release();
        g_pctNetShell = NULL;
    }
}
} // extern C

/************************************************************************************
IUnknown Implementation

************************************************************************************/

HRESULT CSysTray::QueryInterface(REFIID iid, void** ppvObject)
{
    HRESULT hr = S_OK;

    if ((iid == IID_IOleCommandTarget) || (iid == IID_IUnknown))
    {
        *ppvObject = (IOleCommandTarget*) this;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == S_OK)
    {
        ((IUnknown*) (*ppvObject))->AddRef();
    }

    return hr;
}

ULONG CSysTray::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CSysTray::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }    
    return cRef;
}

/************************************************************************************
IOleCommandTarget Implementation

************************************************************************************/

HRESULT CSysTray::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
 
    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

HRESULT CSysTray::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                hr = CreateSysTrayThread();
                break;

            case SSOCMDID_CLOSE:
                hr = DestroySysTrayWindow();
                break;

            default:
                hr = S_OK;
                break;
        }
    }

    return hr;
}

/************************************************************************************
Constructor/Destructor Implementation

************************************************************************************/
CSysTray::CSysTray(BOOL fRunTrayOnConstruct)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cLocks);

    if (fRunTrayOnConstruct)
    {
        // We are being called through SHLoadInProc - Launch the systray thread immediately
        CreateSysTrayThread();
    }
}

CSysTray::~CSysTray()
{
    ASSERT( 0 != g_cLocks );
    InterlockedDecrement(&g_cLocks);
}

/************************************************************************************
Private Function Implementation

************************************************************************************/

HRESULT CSysTray::CreateSysTrayThread()
{
    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD dwThreadId;
 
    hThread = CreateThread(NULL, 0, CSysTray::SysTrayThreadProc, NULL, 0, &dwThreadId);
    if (hThread != NULL)
    {
        CloseHandle(hThread);
    }
    else
        hr = E_FAIL;

    return hr;
}

DWORD CSysTray::SysTrayThreadProc(void* lpv)
{
    // We pass a "" for the command line to so that the tray applets don't start.
    TCHAR szModule[MAX_PATH];

    GetModuleFileName(g_hinstDll, szModule, ARRAYSIZE(szModule));

    HINSTANCE hInstThis = LoadLibrary(szModule);

    int Result = SysTrayMain(g_hinstDll, NULL, TEXT(""), SW_SHOWNORMAL);
    
    FreeLibraryAndExitThread(hInstThis, (DWORD) Result);

    // Never gets here
    return 0; 
}

HRESULT CSysTray::DestroySysTrayWindow()
{
    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hExistWnd) 
    {
        // Destroy the window. Note that we can't use DestroyWindow since
        // the window is on a different thread and DestroyWindow fails.
        SendMessage(hExistWnd, WM_CLOSE, 0, 0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\systray.c ===
#include "stdafx.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtsapi32.h>
#include <faxreg.h>
#include "systray.h"

#ifndef FAX_SYS_TRAY_DLL
#define FAX_SYS_TRAY_DLL       TEXT("fxsst.dll")            // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                 "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                     // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC       "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();               // FaxMonitorShutdown type
#endif


//  Global instance handle of this application.
HINSTANCE g_hInstance;

DWORD g_uiShellHook; //shell hook window message

//  Global handle to VxDs
HANDLE g_hPCCARD = INVALID_HANDLE_VALUE;

static UINT g_uEnabledSvcs = 0;

//  Context sensitive help array used by the WinHelp engine.
extern const DWORD g_ContextMenuHelpIDs[];

UINT g_msg_winmm_devicechange = 0;

DWORD g_msgTaskbarCreated;
LRESULT CALLBACK SysTrayWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

HMODULE g_hFaxLib = NULL;
PIS_FAX_MSG_PROC g_pIsFaxMessage = NULL;
PFAX_MONITOR_SHUTDOWN_PROC g_pFaxMonitorShutdown = NULL;

/*******************************************************************************
*
*  DESCRIPTION:
*       Turns the specified service on or off depending upon the value in
*       fEnable and writes the new value to the registry.
*
*  PARAMETERS:
*     (returns), Mask of all currently enabled services.
*
*******************************************************************************/

UINT EnableService(UINT uNewSvcMask, BOOL fEnable)
{
    HKEY hk;
    UINT uCurSvcMask;
    DWORD cb;
    uCurSvcMask = STSERVICE_ALL; // Enable all standard serivces

    // Disable volume on clean install
    uCurSvcMask &= ~STSERVICE_VOLUME;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, 0, NULL, 
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS)
    {
        cb = sizeof(uCurSvcMask);
        RegQueryValueEx(hk, REGSTR_VAL_SYSTRAYSVCS, NULL, NULL, (LPBYTE)&uCurSvcMask, &cb);

        if (uNewSvcMask)
        {
            if (fEnable)
            {
                uCurSvcMask |= uNewSvcMask;
            }
            else
            {
                uCurSvcMask &= ~uNewSvcMask;
            }

            RegSetValueEx(hk, REGSTR_VAL_SYSTRAYSVCS, 0, REG_DWORD, (LPSTR)&uCurSvcMask, sizeof(uCurSvcMask));
        }

        RegCloseKey(hk);
    }

    return(uCurSvcMask & STSERVICE_ALL);
}


//
//  Closes file handles IFF the global variable != INVALID_HANDLE_VALUE
//
void CloseIfOpen(LPHANDLE lph)
{
    if (*lph != INVALID_HANDLE_VALUE)
    {
        CloseHandle(*lph);
        *lph = INVALID_HANDLE_VALUE;
    }
}


// From stobject.cpp
void StartNetShell();
void StopNetShell();

// if lpCmdLine contains an integer value then we'll enable that service

STDAPI_(int) SysTrayMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    UINT iEnableServ = StrToInt(lpszCmdLine);

    CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    g_hInstance = hInstance;
    g_uiShellHook = 0;
    g_msg_winmm_devicechange = RegisterWindowMessage(TEXT("winmm_devicechange")); 

    if (hExistWnd)
    {
        // NOTE: Send an enable message even if the command line parameter
        //       is 0 to force us to re-check for all enabled services.
        SendMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
    }
    else
    {
        WNDCLASSEX wc;

        //  Register a window class for the Battery Meter.  This is done so that
        //  the power control panel applet has the ability to detect us and turn us
        //  off if we're running.

        wc.cbSize          = sizeof(wc);
        wc.style           = CS_GLOBALCLASS;
        wc.lpfnWndProc     = SysTrayWndProc;
        wc.cbClsExtra      = 0;
        wc.cbWndExtra      = DLGWINDOWEXTRA;
        wc.hInstance       = hInstance;
        wc.hIcon           = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_BATTERYPLUG));
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground   = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName    = NULL;
        wc.lpszClassName   = SYSTRAY_CLASSNAME;
        wc.hIconSm         = NULL;

        if (RegisterClassEx(&wc))
        {
            MSG Msg;
            //  Create the Battery Meter and get this thing going!!!
            HWND hWnd = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_BATTERYMETER), NULL, NULL);

            g_msgTaskbarCreated = RegisterWindowMessage(L"TaskbarCreated");

            // Ensure we're always running the CSC "service" on Win2000.
            // CSC won't work without it.
            //
            //
            // Ensure we're always running the hotplug "service" on Win2000.
            // 
            iEnableServ |= (STSERVICE_CSC | STSERVICE_HOTPLUG);

            // create the timer that will delay the startup of the fax code.
            SetTimer( hWnd, FAX_STARTUP_TIMER_ID, 20 * 1000, NULL );

            // create the timer that will delay the startup of the print tray code.
            SetTimer( hWnd, PRINT_STARTUP_TIMER_ID, 20 * 1000, NULL );
    
            //
            //   This message will initialize all existing services if iEnableServ
            //   is 0, so it's used to do the general initialization as well as to
            //   enable a new service via the command line.
            //
            SendMessage(hWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);


            // Whistler runs NETSHELL in the thread of the systray
            StartNetShell();

            while (GetMessage(&Msg, NULL, 0, 0))
            {
                if(g_pIsFaxMessage && g_pIsFaxMessage(&Msg))
                {
                    continue;
                }

                if (!IsDialogMessage(hWnd, &Msg) &&
                    !CSC_MsgProcess(&Msg))
                {
                    TranslateMessage(&Msg);
                    DispatchMessage(&Msg);
                }
            }
            // Whistler runs NETSHELL in the thread of the systray
            StopNetShell();
        }
        CloseIfOpen(&g_hPCCARD);
    }
    CoUninitialize();
    return 0;
}


/*******************************************************************************
*
*  UpdateServices
*
*  DESCRIPTION:
*       Enables or disables all services specified by the uEnabled mask.
*
*  PARAMETERS:
*     (returns), TRUE if any service wants to remain resident.
*
*******************************************************************************/

BOOL UpdateServices(HWND hWnd, UINT uEnabled)
{
    BOOL bAnyEnabled = FALSE;

    g_uEnabledSvcs = uEnabled;
    bAnyEnabled |= CSC_CheckEnable(hWnd, uEnabled & STSERVICE_CSC);
    bAnyEnabled |= Power_CheckEnable(hWnd, uEnabled & STSERVICE_POWER);
    bAnyEnabled |= HotPlug_CheckEnable(hWnd, uEnabled & STSERVICE_HOTPLUG);
    bAnyEnabled |= Volume_CheckEnable(hWnd, uEnabled & STSERVICE_VOLUME);
    bAnyEnabled |= USBUI_CheckEnable(hWnd, uEnabled & STSERVICE_USBUI);

    //
    // now check accessibility features
    //

    bAnyEnabled |= StickyKeys_CheckEnable(hWnd);
    bAnyEnabled |= MouseKeys_CheckEnable(hWnd);
    bAnyEnabled |= FilterKeys_CheckEnable(hWnd);

    // register to listen for SHChangeNotify events, so if somebody prints a job 
    // we start the print tray code before the kick off timer.
    Print_SHChangeNotify_Register(hWnd);

    return(bAnyEnabled);
}


/*******************************************************************************
*
*  SysTrayWndProc
*
*  DESCRIPTION:
*     Callback procedure for the BatteryMeter window.
*
*  PARAMETERS:
*     hWnd, handle of BatteryMeter window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT CALLBACK SysTrayWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    
    if (g_uiShellHook && Message == g_uiShellHook) // NT5: 406505 shellhook for MouseKeys
    {
        switch (wParam)
        {
        case HSHELL_ACCESSIBILITYSTATE:
            switch (lParam)
            {
            case ACCESS_STICKYKEYS:
                StickyKeys_CheckEnable(hWnd);
                break;

            case ACCESS_MOUSEKEYS:
                MouseKeys_CheckEnable(hWnd);
                break;
//  Since we only enable the shellhook when MouseKeys or StickKeys is on, we should only get that msg
//            case ACCESS_FILTERKEYS:
//                FilterKeys_CheckEnable(hWnd);
//                break;
            }
        }
        return 0;
    }


    if (Message == g_msg_winmm_devicechange)
    {
        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_WinMMDeviceChange(hWnd);
        }
        return 0;
    }

    switch (Message)
    {
    case WM_CREATE:
        WTSRegisterSessionNotification(hWnd, NOTIFY_FOR_THIS_SESSION);
        break;

    case WM_COMMAND:
        Power_OnCommand(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYPOWER:
        Power_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYUSBUI:
        USBUI_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYHOTPLUG:   
        HotPlug_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYSTICKYKEYS:
        StickyKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYMOUSEKEYS:
        MouseKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYFILTERKEYS:
        FilterKeys_Notify(hWnd, wParam, lParam);
        break;

    case STWM_NOTIFYVOLUME:
        Volume_Notify(hWnd, wParam, lParam);
        break;
    
    case STWM_ENABLESERVICE:
        UpdateServices(hWnd, EnableService((UINT)wParam, (BOOL)lParam));
        break;

    case STWM_GETSTATE:
        return((BOOL)(g_uEnabledSvcs & (UINT)wParam));

    case MM_MIXM_CONTROL_CHANGE:
        Volume_ControlChange(hWnd, (HMIXER)wParam, (DWORD)lParam);
        break;

    case MM_MIXM_LINE_CHANGE:
        Volume_LineChange(hWnd, (HMIXER)wParam, (DWORD)lParam);
        break;

    case WM_ACTIVATE:
        if (Power_OnActivate(hWnd, wParam, lParam)) 
        {
            break;
        }
        return DefWindowProc(hWnd, Message, wParam, lParam);

    case WM_TIMER:
        switch (wParam)
        {

        case VOLUME_TIMER_ID:
            Volume_Timer(hWnd);
            break;

        case POWER_TIMER_ID:
            Power_Timer(hWnd);
            break;

        case HOTPLUG_TIMER_ID:
            HotPlug_Timer(hWnd);
            break;

        case USBUI_TIMER_ID:
            USBUI_Timer(hWnd);
            break;

        case HOTPLUG_DEVICECHANGE_TIMERID:
            HotPlug_DeviceChangeTimer(hWnd);
            break;
        case FAX_STARTUP_TIMER_ID:
            KillTimer(hWnd, FAX_STARTUP_TIMER_ID);
            if (NULL == g_hFaxLib)
            {
                g_hFaxLib = LoadLibrary(FAX_SYS_TRAY_DLL);

                g_pIsFaxMessage = NULL;
                g_pFaxMonitorShutdown = NULL;
                if(g_hFaxLib)
                {
                    g_pIsFaxMessage = (PIS_FAX_MSG_PROC)GetProcAddress(g_hFaxLib, IS_FAX_MSG_PROC);
                    g_pFaxMonitorShutdown = (PFAX_MONITOR_SHUTDOWN_PROC)GetProcAddress(g_hFaxLib, FAX_MONITOR_SHUTDOWN_PROC);
                }
            }

            break;

        case PRINT_STARTUP_TIMER_ID:
            KillTimer(hWnd, PRINT_STARTUP_TIMER_ID);
            Print_TrayInit();
            break;

        case FAX_SHUTDOWN_TIMER_ID:
            {
                if (g_hFaxLib)
                {
                    if (g_pFaxMonitorShutdown)
                    {
                        g_pFaxMonitorShutdown();
                    }
                    FreeLibrary (g_hFaxLib);
                    g_hFaxLib = NULL;
                    g_pIsFaxMessage = NULL;
                    g_pFaxMonitorShutdown = NULL;
                }
            }
            break;
        }
        break;

    //
    // Handle SC_CLOSE to hide the window without destroying it. This
    // happens when we display the window and the user "closes" it.
    // Don't pass SC_CLOSE to DefWindowProc since that causes a
    // WM_CLOSE which destroys the window.
    //
    // Note that CSysTray::DestroySysTrayWindow must send WM_CLOSE
    // to destroy the window.  It can't use DestroyWindow since it's
    // typically on a different thread and DestroyWindow fails.
    //
    case WM_SYSCOMMAND:
        if (SC_CLOSE != (wParam & ~0xf))
            return DefWindowProc(hWnd, Message, wParam, lParam);
        ShowWindow(hWnd, SW_HIDE);
        break;

    case WM_POWERBROADCAST:
         Power_OnPowerBroadcast(hWnd, wParam, lParam);
         Volume_HandlePowerBroadcast(hWnd, wParam, lParam);
         break;

    case WM_DEVICECHANGE:
        Power_OnDeviceChange(hWnd, wParam, lParam);

        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_DeviceChange(hWnd, wParam, lParam);
        }

        HotPlug_DeviceChange(hWnd, wParam, lParam);
        break;

    case WM_ENDSESSION:
        if (g_uEnabledSvcs & STSERVICE_VOLUME)
        {
            Volume_Shutdown(hWnd);
        }
        break;

    case WM_WTSSESSION_CHANGE:
        HotPlug_SessionChange(hWnd, wParam, wParam);
        break;

    case WM_DESTROY:
        WTSUnRegisterSessionNotification(hWnd);
        UpdateServices(hWnd, 0);          // Force all services off
        Volume_WmDestroy(hWnd);
        Power_WmDestroy(hWnd);
        HotPlug_WmDestroy(hWnd);
        Print_SHChangeNotify_Unregister();
        Print_TrayExit();
        StopNetShell();
        if (g_hFaxLib)
        {
            if (g_pFaxMonitorShutdown)
            {
                g_pFaxMonitorShutdown();
            }
            FreeLibrary (g_hFaxLib);
            g_hFaxLib = NULL;
            g_pIsFaxMessage = NULL;
            g_pFaxMonitorShutdown = NULL;
        }
        PostQuitMessage(0);
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)g_ContextMenuHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (ULONG_PTR)(LPSTR) g_ContextMenuHelpIDs);
        break;

    case WM_SYSCOLORCHANGE:
        StickyKeys_CheckEnable(hWnd);
        FilterKeys_CheckEnable(hWnd);
        MouseKeys_CheckEnable(hWnd);
                break;


    case WM_SETTINGCHANGE:
        switch(wParam)
        {
            case SPI_SETSTICKYKEYS:
                StickyKeys_CheckEnable(hWnd);
                break;
            case SPI_SETFILTERKEYS:
                FilterKeys_CheckEnable(hWnd);
                break;
            case SPI_SETMOUSEKEYS:
                MouseKeys_CheckEnable(hWnd);
                break;
        }
        break;

    case WM_PRINT_NOTIFY:
        Print_Notify(hWnd, Message, wParam, lParam);
        break;

    default:

        //
        // if Taskbar Created notification renenable all shell notify icons.
        //

        if (Message == g_msgTaskbarCreated)
        {
            UpdateServices(hWnd, EnableService(0, TRUE));
            break;
        }


        return DefWindowProc(hWnd, Message, wParam, lParam);
    }

    return 0;
}


// Loads the specified string ID and executes it.

void SysTray_RunProperties(UINT RunStringID)
{
    LPTSTR pszRunCmd = LoadDynamicString(RunStringID);
    if (pszRunCmd)
    {
        TCHAR szRunDllPath[MAX_PATH];
        TCHAR szRunDll[] = TEXT("rundll32.exe");

        if (GetSystemDirectory(szRunDllPath, ARRAYSIZE(szRunDllPath)) && 
            PathAppend(szRunDllPath, szRunDll))
        {
            ShellExecute(NULL, TEXT("open"), szRunDllPath, pszRunCmd, NULL, SW_SHOWNORMAL);
        }
        DeleteDynamicString(pszRunCmd);
    }
}


/*******************************************************************************
*
*  SysTray_NotifyIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of BatteryMeter window.
*     Message,
*     hIcon,
*     lpTip,
*
*******************************************************************************/

VOID SysTray_NotifyIcon(HWND hWnd, UINT uCallbackMessage, DWORD Message, HICON hIcon, LPCTSTR lpTip)
{
    NOTIFYICONDATA nid = {0};

    nid.cbSize = sizeof(nid);
    nid.uID = uCallbackMessage;
    nid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    nid.uCallbackMessage = uCallbackMessage;

    nid.hWnd = hWnd;
    nid.hIcon = hIcon;
    if (lpTip)
    {
        StrCpyN(nid.szTip, lpTip, ARRAYSIZE(nid.szTip));
    }
    else
    {
        nid.szTip[0] = 0;
    }

    Shell_NotifyIcon(Message, &nid);
}


/*******************************************************************************
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*     BE CAREFUL in 16-bit code to pass 32-bit quantities for the variable
*     arguments.
*
*  PARAMETERS:
*     StringID, resource identifier of the string to use.
*     (optional), parameters to use to format the string message.
*
*******************************************************************************/

LPTSTR CDECL LoadDynamicString(UINT StringID, ...)
{
    TCHAR   Buffer[256];
    LPTSTR  pStr=NULL;
    va_list Marker;

    // va_start is a macro...it breaks when you use it as an assign
    va_start(Marker, StringID);

    LoadString(g_hInstance, StringID, Buffer, ARRAYSIZE(Buffer));

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  (void *) (LPTSTR) Buffer, 0, 0, (LPTSTR) (LPTSTR *) &pStr, 0, &Marker);

    return pStr;
}



VOID SetIconFocus(HWND hwnd, UINT uiIcon)
{
    NOTIFYICONDATA nid = {0};

    nid.cbSize = sizeof(NOTIFYICONDATA);
    nid.hWnd = hwnd;
    nid.uID = uiIcon;

    Shell_NotifyIcon(NIM_SETFOCUS, &nid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\systray.h ===
#include "stresid.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif

#define STWM_NOTIFYHOTPLUG  STWM_NOTIFYPCMCIA
#define STSERVICE_HOTPLUG   STSERVICE_PCMCIA
#define HOTPLUG_REGFLAG_NOWARN PCMCIA_REGFLAG_NOWARN

void SysTray_RunProperties(UINT RunStringID);

VOID
PASCAL
SysTray_NotifyIcon(
    HWND hWnd,
    UINT uCallbackMessage,
    DWORD Message,
    HICON hIcon,
    LPCTSTR lpTip
    );

LPTSTR
NEAR CDECL
LoadDynamicString(
    UINT StringID,
    ...
    );

UINT EnableService(UINT uNewSvcMask, BOOL fEnable);
BOOL PASCAL GenericGetSet(HKEY hKey, LPCTSTR pszValue, LPVOID pData,
                          ULONG  cbSize, BOOL   bSet);

VOID
PASCAL
SysTray_AppendMenuString(
    HMENU hmenu,
    UINT item,
    LPTSTR lpszMenuItem
    );

//  Wrapper for LocalFree to make the code a little easier to read.
#define DeleteDynamicString(x)          LocalFree((HLOCAL) (x))

#define HOTPLUG_TIMER_ID                2
#define VOLUME_TIMER_ID                 3
#define POWER_TIMER_ID                  4
#define HOTPLUG_DEVICECHANGE_TIMERID    5
#define USBUI_TIMER_ID                  6
#define FAX_STARTUP_TIMER_ID            7
#define PRINT_STARTUP_TIMER_ID          8

#define FAX_SHUTDOWN_TIMER_ID		   99

void    Power_Timer(HWND hWnd);
BOOL    Power_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
void    Power_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnPowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_OnDeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Power_WmDestroy(HWND hWnd);
BOOLEAN Power_OnActivate(HWND hWnd, WPARAM wParam, LPARAM lParam);
void    Update_PowerFlags(DWORD dwMask, BOOL bEnable);
DWORD   Get_PowerFlags(void);
VOID    PASCAL Power_UpdateStatus(HWND, DWORD, BOOL);

void CloseIfOpen(LPHANDLE);

BOOL Volume_Init(HWND hWnd);
BOOL Volume_CheckEnable(HWND hWnd, BOOL bEnabled);
void Volume_DeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_Timer(HWND hWnd);
void Volume_LineChange(HWND hWnd, HMIXER hmx, DWORD dwID );
void Volume_ControlChange(HWND hWnd, HMIXER hmx, DWORD dwID );
void Volume_Shutdown(HWND hWnd);
void Volume_WinMMDeviceChange(HWND hWnd);
void Volume_HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam);
void Volume_DeviceChange_Cleanup(void);
void Volume_WmDestroy(HWND hWnd);

BOOL HotPlug_CheckEnable(HWND hWnd, BOOL bEnabled);
void HotPlug_DeviceChange(HWND hWnd, WPARAM wParam, LPARAM lParam);
void HotPlug_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void HotPlug_Timer(HWND hWnd);
int  HotPlug_DeviceChangeTimer(HWND hWnd);
void HotPlug_WmDestroy(HWND HWnd);
void HotPlug_SessionChange(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL StickyKeys_CheckEnable(HWND hWnd);
void StickyKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL MouseKeys_CheckEnable(HWND hWnd);
void MouseKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL CSC_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
BOOL CSC_MsgProcess(LPMSG pMsg);

void USBUI_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam);
//HMENU USBUI_CreateMenu();
void USBUI_Menu(HWND hwnd, UINT uMenuNum, UINT uButton);
BOOL USBUI_Init(HWND hWnd);
void USBUI_UpdateStatus(HWND hWnd, BOOL bShowIcon);
BOOL USBUI_CheckEnable(HWND hWnd, BOOL bSvcEnabled);
void USBUI_Toggle();
BOOL USBUI_SetState(BOOL On);
void USBUI_Timer(HWND hwnd);

BOOL FilterKeys_CheckEnable(HWND hWnd);
void FilterKeys_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);

BOOL Print_SHChangeNotify_Register(HWND hWnd);
BOOL Print_SHChangeNotify_Unregister();
BOOL Print_TrayInit();
BOOL Print_TrayExit();

#define WM_PRINT_NOTIFY        (WM_APP + 1)
LRESULT Print_Notify(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

VOID
SetIconFocus(
    HWND hwnd,
    UINT uiIcon
    );

STDAPI_(int) SysTrayMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Systray shell service object"
#define VER_INTERNALNAME_STR            "stobject"
#define VER_ORIGINALFILENAME_STR        "stobject.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\usbui.c ===
#include "stdafx.h"

#include "systray.h"

#include <stdio.h>
#include <initguid.h>
#include <usbioctl.h>
#include <wmium.h>
#include <tchar.h>
#include <setupapi.h>

#define USBUIMENU               100

#define NUM_HCS_TO_CHECK 10

typedef int (CALLBACK *USBERRORMESSAGESCALLBACK)
    (PUSB_CONNECTION_NOTIFICATION,LPTSTR);

extern HINSTANCE g_hInstance;

static BOOL    g_bUSBUIEnabled = FALSE;
static BOOL    g_bUSBUIIconShown = FALSE;
static HINSTANCE g_hUsbWatch = NULL;
static USBERRORMESSAGESCALLBACK g_UsbHandler = NULL;
static BOOL    g_bSubstituteDll = FALSE;
static TCHAR   g_strSubstituteDll[MAX_PATH];
static HANDLE  g_hWait = NULL;

int _cdecl main(){
    return 0;
}

#define USBUI_OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))

LPTSTR USBUI_CountedStringToSz(LPTSTR lpString)
{
   SHORT    usNameLength;
   LPTSTR  lpStringPlusNull;

   usNameLength = * (USHORT *) lpString;

   lpStringPlusNull = (LPTSTR) LocalAlloc(LMEM_ZEROINIT,
                                          sizeof(TCHAR) * (usNameLength+1));

   if (lpStringPlusNull != NULL) {
      lpString = (LPTSTR) USBUI_OffsetToPtr(lpString, sizeof(USHORT));

      wcsncpy( lpStringPlusNull, lpString, usNameLength );

      lpStringPlusNull[usNameLength] = TEXT('0');
      // _tcscpy( lpStringPlusNull + usNameLength, _TEXT("") );
   }

   return lpStringPlusNull;
}

void USBUI_EventCallbackRoutine(PWNODE_HEADER WnodeHeader, UINT_PTR NotificationContext)
{
    PWNODE_SINGLE_INSTANCE          wNode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PUSB_CONNECTION_NOTIFICATION    usbConnectionNotification;
    LPGUID                          eventGuid = &WnodeHeader->Guid;
    LPTSTR                          strInstanceName;

    if (memcmp(&GUID_USB_WMI_STD_DATA, eventGuid, sizeof(GUID)) == 0) {
        usbConnectionNotification = (PUSB_CONNECTION_NOTIFICATION)
                                    USBUI_OffsetToPtr(wNode,
                                                      wNode->DataBlockOffset);

        //
        // Get the instance name
        //
        strInstanceName =
            USBUI_CountedStringToSz((LPTSTR)
                                    USBUI_OffsetToPtr(wNode,
                                                      wNode->OffsetInstanceName));
        if (strInstanceName) {
            if (g_hUsbWatch && g_UsbHandler) {
USBUIEngageHandler:
                g_UsbHandler(usbConnectionNotification, strInstanceName);
            } else {
                if (g_bSubstituteDll) {
                    g_hUsbWatch = LoadLibrary(g_strSubstituteDll);
                } else {
                    g_hUsbWatch = LoadLibrary(TEXT("usbui.dll"));
                }
                g_UsbHandler = (USBERRORMESSAGESCALLBACK)
                    GetProcAddress(g_hUsbWatch, "USBErrorHandler");
                goto USBUIEngageHandler;
            }
            LocalFree(strInstanceName);
        }
    }
}

VOID USBUI_WaitRoutineCallback(WMIHANDLE Handle, BOOLEAN Unused) {
    ASSERT(!Unused);
    UnregisterWaitEx(g_hWait, NULL);
    g_hWait = NULL;
    WmiReceiveNotifications(1, &Handle, USBUI_EventCallbackRoutine, (ULONG_PTR)NULL);
    RegisterWaitForSingleObject(&g_hWait,
                                 Handle,
                                 USBUI_WaitRoutineCallback,
                                 Handle, // context
                                 INFINITE,
                                 WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE);
}

int USBUI_ErrorMessagesEnable(BOOL fEnable)
{
    ULONG status = ERROR_SUCCESS;
    BOOL result;
    static WMIHANDLE hWmi = NULL;

    if (fEnable) {
        ASSERT(!g_hWait);
        ASSERT(!hWmi);
        status = WmiOpenBlock((LPGUID) &GUID_USB_WMI_STD_DATA,
                              WMIGUID_NOTIFICATION | SYNCHRONIZE,
                              &hWmi);

        if (!status) {
            result = RegisterWaitForSingleObject(&g_hWait,
                                             hWmi,
                                             USBUI_WaitRoutineCallback,
                                             hWmi, // context
                                             INFINITE,
                                             WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE);
            status = result ? 0 : ERROR_INVALID_FUNCTION;
        }
    } else {
        ASSERT(hWmi);
        if (g_hWait) {
            result = UnregisterWait(g_hWait);
        }
        if (hWmi) {
            status = WmiCloseBlock(hWmi);
        }
        hWmi = NULL;
        g_hWait = NULL;
        if (g_hUsbWatch) {

            // This allows us to replace the library

            FreeLibrary(g_hUsbWatch);
            g_hUsbWatch = NULL;
            g_UsbHandler = NULL;
        }
    }

    return status;

}

void USBUI_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

    switch (lParam)
    {
        case WM_RBUTTONUP:
        {
            USBUI_Menu(hwnd, 1, TPM_RIGHTBUTTON);
        }
        break;

        case WM_LBUTTONDOWN:
        {
            SetTimer(hwnd, USBUI_TIMER_ID, GetDoubleClickTime()+100, NULL);
        }
        break;

        case WM_LBUTTONDBLCLK:
        {
            KillTimer(hwnd, USBUI_TIMER_ID);
            USBUI_Toggle();
        }
        break;
    }
}

void USBUI_Toggle()
{
    USBUI_SetState(!g_bUSBUIEnabled);
}

void USBUI_Timer(HWND hwnd)
{
    KillTimer(hwnd, USBUI_TIMER_ID);
    USBUI_Menu(hwnd, 0, TPM_LEFTBUTTON);
}
/*
HMENU USBUI_CreateMenu()
{
    HMENU hmenu;
    LPSTR lpszMenu1;

    hmenu = CreatePopupMenu();

    if (!hmenu)
    {
        return NULL;
    }

    lpszMenu1 = LoadDynamicString(g_bUSBUIEnabled?IDS_USBUIDISABLE:IDS_USBUIENABLE);

    // AppendMenu(hmenu,MF_STRING,USBUIMENU,lpszMenu1);
    SysTray_AppendMenuString (hmenu,USBUIMENU,lpszMenu1);

    SetMenuDefaultItem(hmenu,USBUIMENU,FALSE);

    DeleteDynamicString(lpszMenu1);

    return hmenu;
}
  */
void USBUI_Menu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT   pt;
    UINT    iCmd;
    HMENU   hmenu = 0;

    GetCursorPos(&pt);

//    hmenu = USBUI_CreateMenu();

    if (!hmenu)
    {
        return;
    }

    SetForegroundWindow(hwnd);

    iCmd = TrackPopupMenu(hmenu, uButton | TPM_RETURNCMD | TPM_NONOTIFY, pt.x, pt.y, 0, hwnd, NULL);

    DestroyMenu(hmenu);

    switch (iCmd)
    {
        case USBUIMENU:
        {
            USBUI_Toggle();
        }
        break;
    }
}

BOOL USBUI_SetState(BOOL NewState)
{
    int retValue;

    if (g_bUSBUIEnabled != NewState) {
        //
        // Only enable it if not already enabled
        //
        retValue = (int) USBUI_ErrorMessagesEnable (NewState);
        g_bUSBUIEnabled = retValue ? g_bUSBUIEnabled : NewState;
    }
    return g_bUSBUIEnabled;
}

BOOL
IsErrorCheckingEnabled()
{
    DWORD ErrorCheckingEnabled = TRUE, size;
    HKEY hKey;

    //
    // Check the registry value ErrorCheckingEnabled to make sure that we should
    // be enabling this.
    //
    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Usb"),
                        0,
                        KEY_READ,
                        &hKey)) {

        // Get the ErrorCheckingEnabled value

        size = sizeof(DWORD);
        RegQueryValueEx(hKey,
                        TEXT("ErrorCheckingEnabled"),
                        0,
                        NULL,
                        (LPBYTE) &ErrorCheckingEnabled,
                        &size);

        if (ErrorCheckingEnabled) {

            // Look for a substitute dll for usbui.dll

            size = MAX_PATH*sizeof(TCHAR);

            if (ERROR_SUCCESS ==
                RegQueryValueEx(hKey,
                            TEXT("SubstituteDll"),
                            0,
                            NULL,
                            (LPBYTE) g_strSubstituteDll,
                            &size)) {
                g_bSubstituteDll = TRUE;
            } else {
                g_bSubstituteDll = FALSE;
            }
        }

        RegCloseKey(hKey);
    }

    return (BOOL) ErrorCheckingEnabled;
}

BOOL USBUI_Init(HWND hWnd)
{
    TCHAR       HCName[16];
    BOOL        ControllerFound = FALSE;
    int         HCNum;
    HDEVINFO    hHCDev;

    //
    // Check the registry to make sure that it is turned on
    //
    if (!IsErrorCheckingEnabled()) {
        return FALSE;
    }

    //
    // Check for the existence of a USB controller.
    // If there is one, load and initialize USBUI.dll which will check for
    // usb error messages.  If we can't open a controller, than we shouldn't
    // load a USB watch dll.
    //
    for (HCNum = 0; HCNum < NUM_HCS_TO_CHECK; HCNum++)
    {
        wsprintf(HCName, TEXT("\\\\.\\HCD%d"), HCNum);

        hHCDev = CreateFile(HCName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
        //
        // If the handle is valid, then we've successfully opened a Host
        // Controller.
        //

        if (hHCDev != INVALID_HANDLE_VALUE) {
            CloseHandle(hHCDev);
            return TRUE;
        }
    }



    hHCDev = SetupDiGetClassDevs(&GUID_CLASS_USB_HOST_CONTROLLER,
                                 NULL,
                                 NULL,
                                 (DIGCF_DEVICEINTERFACE | DIGCF_PRESENT));
    if(hHCDev == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    SetupDiDestroyDeviceInfoList(hHCDev);
    return TRUE;
}

//
//  Called at init time and whenever services are enabled/disabled.
//
BOOL USBUI_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{
    BOOL bEnable = bSvcEnabled && USBUI_Init(hWnd);

    if (bEnable != g_bUSBUIEnabled)
    {
        //
        // state change
        //
        USBUI_SetState(bEnable);
    }

    return(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\access.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include "access.h"


CAccessibleWrapper::CAccessibleWrapper(IAccessible *pAcc)
    : _cRef(1), _pAcc(pAcc), _pEnumVar(NULL), _pOleWin(NULL)
{
    _pAcc->AddRef();
}

CAccessibleWrapper::~CAccessibleWrapper()
{
    if (_pEnumVar)
        _pEnumVar->Release();
    if (_pOleWin)
        _pOleWin->Release();
    _pAcc->Release();
}

// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr;
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = SAFECAST(this, IAccessible*);
    }
    else if (riid == IID_IEnumVARIANT)
    {
        // Get the IEnumVariant from the object we are sub-classing so we can delegate
        // calls.
        if (!_pEnumVar)
        {
            hr = _pAcc->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &_pEnumVar));
            if (FAILED(hr))
            {
                _pEnumVar = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if (!_pEnumVar)
                return E_NOINTERFACE;
        }

        *ppv = SAFECAST(this, IEnumVARIANT*);
    }
    else if (riid == IID_IOleWindow)
    {
        // Get the IOleWindow from the object we are sub-classing so we can delegate
        // calls.
        if (!_pOleWin)
        {
            hr = _pAcc->QueryInterface(IID_PPV_ARG(IOleWindow, &_pOleWin));
            if(FAILED(hr))
            {
                _pOleWin = NULL;
                return hr;
            }
            // Paranoia (in case QI returns S_OK with NULL...)
            if (!_pOleWin)
                return E_NOINTERFACE;
        }

        *ppv = SAFECAST(this, IOleWindow*);
    }
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDispatch
// - pass all through _pAcc

STDMETHODIMP CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return _pAcc->GetTypeInfoCount(pctinfo);
}

STDMETHODIMP CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return _pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}

STDMETHODIMP CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                                               LCID lcid, DISPID* rgdispid)
{
    return _pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP CAccessibleWrapper::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags,
                                        DISPPARAMS* pdp, VARIANT* pvarResult,
                                        EXCEPINFO* pxi, UINT* puArgErr)
{
    return _pAcc->Invoke(dispid, riid, lcid, wFlags, pdp, pvarResult, pxi, puArgErr);
}

// IAccessible
// - pass all through _pAcc

STDMETHODIMP CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return _pAcc->get_accParent(ppdispParent);
}

STDMETHODIMP CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return _pAcc->get_accChildCount(pChildCount);
}

STDMETHODIMP CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return _pAcc->get_accChild(varChild, ppdispChild);
}

STDMETHODIMP CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    return _pAcc->get_accName(varChild, pszName);
}

STDMETHODIMP CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    return _pAcc->get_accValue(varChild, pszValue);
}

STDMETHODIMP CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    return _pAcc->get_accDescription(varChild, pszDescription);
}

STDMETHODIMP CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    return _pAcc->get_accRole(varChild, pvarRole);
}

STDMETHODIMP CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    return _pAcc->get_accState(varChild, pvarState);
}

STDMETHODIMP CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return _pAcc->get_accHelp(varChild, pszHelp);
}

STDMETHODIMP CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return _pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}

STDMETHODIMP CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return _pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}

STDMETHODIMP CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return _pAcc->get_accFocus(pvarFocusChild);
}

STDMETHODIMP CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return _pAcc->get_accSelection(pvarSelectedChildren);
}

STDMETHODIMP CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return _pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}

STDMETHODIMP CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return _pAcc->accSelect(flagsSel, varChild);
}

STDMETHODIMP CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return _pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}

STDMETHODIMP CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return _pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}

STDMETHODIMP CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return _pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}

STDMETHODIMP CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return _pAcc->accDoDefaultAction(varChild);
}

STDMETHODIMP CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return _pAcc->put_accName(varChild, szName);
}

STDMETHODIMP CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return _pAcc->put_accValue(varChild, pszValue);
}

// IEnumVARIANT
// - pass all through _pEnumVar

STDMETHODIMP CAccessibleWrapper::Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched)
{
    return _pEnumVar->Next(celt, rgvar, pceltFetched);
}

STDMETHODIMP CAccessibleWrapper::Skip(ULONG celt)
{
    return _pEnumVar->Skip(celt);
}

STDMETHODIMP CAccessibleWrapper::Reset()
{
    return _pEnumVar->Reset();
}

STDMETHODIMP CAccessibleWrapper::Clone(IEnumVARIANT ** ppenum)
{
    return _pEnumVar->Clone(ppenum);
}

// IOleWindow
// - pass all through _pOleWin

STDMETHODIMP CAccessibleWrapper::GetWindow(HWND* phwnd)
{
    return _pOleWin->GetWindow(phwnd);
}

STDMETHODIMP CAccessibleWrapper::ContextSensitiveHelp(BOOL fEnterMode)
{
    return _pOleWin->ContextSensitiveHelp(fEnterMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\access.h ===
#include <oleacc.h>

// Generic CAccessibleWrapper class - just calls through on all methods.
// Add overriding behavior in classes derived from this.

class CAccessibleWrapper: public IAccessible,
                          public IOleWindow,
                          public IEnumVARIANT
{
private:
    // We need to do our own refcounting for this wrapper object
    LONG            _cRef;

    // Need ptr to the IAccessible - also keep around ptrs to EnumVar and
    // OleWindow as part of this object, so we can filter those interfaces
    // and trap their QI's...
    // (We leave pEnumVar and OleWin as NULL until we need them)
    IAccessible    *_pAcc;
    IEnumVARIANT   *_pEnumVar;
    IOleWindow     *_pOleWin;

public:
    CAccessibleWrapper(IAccessible *pAcc);
    virtual ~CAccessibleWrapper();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
                               LCID lcid, DISPID* rgdispid);
    STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags,
                        DISPPARAMS* pdp, VARIANT* pvarResult,
                        EXCEPINFO* pxi, UINT* puArgErr);

    // IAccessible
    STDMETHODIMP get_accParent(IDispatch ** ppdispParent);
    STDMETHODIMP get_accChildCount(long* pChildCount);
    STDMETHODIMP get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR* pszDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT * pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT * pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    STDMETHODIMP accSelect(long flagsSel, VARIANT varChild);
    STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);

    // IEnumVARIANT
    STDMETHODIMP Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumVARIANT ** ppenum);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND* phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
};

template <class T>
static LRESULT CALLBACK AccessibleSubWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData)
{
    switch (uMsg)
    {
    case WM_GETOBJECT:
        if (lParam == OBJID_CLIENT)
        {
            CAccessibleWrapper *pWrapAcc = NULL;
            IAccessible *pAcc = NULL;
            HRESULT hr = CreateStdAccessibleObject(hWnd, OBJID_CLIENT, IID_PPV_ARG(IAccessible, &pAcc));
            if (SUCCEEDED(hr) && pAcc)
            {
                pWrapAcc = new T(pAcc, dwRefData);
                pAcc->Release();

                if (pWrapAcc != NULL)
                {
                    LRESULT lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pWrapAcc, IAccessible*));
                    pWrapAcc->Release();
                    return lres;
                }
            }
        }
        break;
    case WM_DESTROY:
        RemoveWindowSubclass(hWnd, AccessibleSubWndProc<T>, uID);
        break;    
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

template <class T>
static STDMETHODIMP WrapAccessibleControl(HWND hWnd, ULONG_PTR dwRefData=0)
{
    if (SetWindowSubclass(hWnd, AccessibleSubWndProc<T>, 0, dwRefData))
    {
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\exestub\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Systray .exe stub"
#define VER_INTERNALNAME_STR            "systray"
#define VER_ORIGINALFILENAME_STR        "systray.exe"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\makefile.inc ===
..\resource.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\dll\volume.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       VOLUME.C
*
*  VERSION:     1.0
*
*  AUTHOR:      RAL
*
*  DATE:        11/01/94
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  Nov. 11, 94 RAL Original
*  Oct. 24, 95 Shawnb UNICODE enabled
*
*******************************************************************************/
#include "stdafx.h"
#include "systray.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>


#define HWAVEOUT_MAPPER       ((HWAVEOUT)IntToPtr(WAVE_MAPPER))
#define HWAVEIN_MAPPER        ((HWAVEIN)IntToPtr(WAVE_MAPPER))
#define HMIDIOUT_MAPPER       ((HMIDIOUT)IntToPtr(WAVE_MAPPER))

#define HWAVEOUT_INDEX(i)     ((HWAVEOUT)IntToPtr(i))
#define HWAVEIN_INDEX(i)      ((HWAVEIN)IntToPtr(i))
#define HMIDIOUT_INDEX(i)     ((HMIDIOUT)IntToPtr(i))
#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))
#define HMIXEROBJ_INDEX(i)    ((HMIXEROBJ)IntToPtr(i))

/* defined in mmddk.h */
#define DRV_QUERYDEVNODE     (DRV_RESERVED + 2)

#define VOLUMEMENU_PROPERTIES               100
#define VOLUMEMENU_SNDVOL                   101

extern HINSTANCE g_hInstance;

static BOOL    g_bVolumeEnabled = FALSE;
static BOOL    g_bVolumeIconShown = FALSE;
static HICON   g_hVolumeIcon = NULL;
static HICON   g_hMuteIcon = NULL;
static HMENU   g_hVolumeMenu = NULL;
static HMIXER  g_hMixer = NULL;
static UINT    g_uMixer = 0;
static DWORD   g_dwMixerDevNode = 0;
static DWORD   g_dwMute = (DWORD) -1;
static DWORD   g_dwVSlider = 0;
static DWORD   g_dwMasterLine = (DWORD) -1;

HDEVNOTIFY DeviceEventContext = NULL;


void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void Volume_DeviceChange_Cleanup(void);

void Volume_UpdateStatus(HWND hWnd, BOOL bShowIcon, BOOL bKillSndVol32);
void Volume_VolumeControl();
void Volume_ControlPanel(HWND hwnd);
MMRESULT Volume_GetDefaultMixerID(int *pid);
void Volume_UpdateIcon(HWND hwnd, DWORD message);
BOOL Volume_Controls(UINT uMxID);
BOOL FileExists (LPCTSTR pszFileName);
BOOL FindSystemFile (LPCTSTR pszFileName, LPTSTR pszFullPath, UINT cchSize);
void Volume_WakeUpOrClose(BOOL fClose);

HMENU Volume_CreateMenu()
{
        HMENU  hmenu;
        LPTSTR lpszMenu1;
        LPTSTR lpszMenu2;

        lpszMenu1 = LoadDynamicString(IDS_VOLUMEMENU1);
        if (!lpszMenu1)
                return NULL;

        lpszMenu2 = LoadDynamicString(IDS_VOLUMEMENU2);
        if (!lpszMenu2)
        {
                DeleteDynamicString(lpszMenu1);
                return NULL;
        }

        hmenu = CreatePopupMenu();
        if (!hmenu)
        {
                DeleteDynamicString(lpszMenu1);
                DeleteDynamicString(lpszMenu2);
                return NULL;
        }

        AppendMenu(hmenu,MF_STRING,VOLUMEMENU_SNDVOL,lpszMenu2);
        AppendMenu(hmenu,MF_STRING,VOLUMEMENU_PROPERTIES,lpszMenu1);

        SetMenuDefaultItem(hmenu,VOLUMEMENU_SNDVOL,FALSE);

        DeleteDynamicString(lpszMenu1);
        DeleteDynamicString(lpszMenu2);

        return hmenu;
}





BOOL Volume_Init(HWND hWnd)
{
        UINT        uMxID;
        const TCHAR szVolApp[] = TEXT ("SNDVOL32.EXE");

        if (g_hMixer == NULL)
        {
                if (Volume_GetDefaultMixerID(&uMxID) != MMSYSERR_NOERROR)
                        return FALSE;

                //
                // check for sndvol32 existence.  checking for the .exe
                // first will ensure that the service gets disabled properly
                //
                
                if (! FindSystemFile (szVolApp, NULL, 0))
                {
                        //
                        // disable the volume service
                        //
                        EnableService (STSERVICE_VOLUME, FALSE);
                
                        return FALSE;
                }


                //
                // do we have output volume controls on this mixer?
                //
                if (! Volume_Controls(uMxID))
                        return FALSE;

                if (mixerOpen(&g_hMixer, uMxID, (DWORD_PTR)hWnd, 0
                                , CALLBACK_WINDOW | MIXER_OBJECTF_MIXER)
                        == MMSYSERR_NOERROR)
                {
            Volume_DeviceChange_Init(hWnd, uMxID);

                        g_uMixer = uMxID;
                        if (mixerMessage (HMIXER_INDEX(uMxID), DRV_QUERYDEVNODE
                                 , (DWORD_PTR)&g_dwMixerDevNode, 0L))
                                g_dwMixerDevNode = 0L;
                        return TRUE;
                }
        }
        else
                return TRUE;

        return FALSE;
}

//
//  Called at init time and whenever services are enabled/disabled.
//  Returns false if mixer services are not active.
//
BOOL Volume_CheckEnable(HWND hWnd, BOOL bSvcEnabled)
{
        BOOL bEnable = bSvcEnabled && Volume_Init(hWnd);

        if (bEnable != g_bVolumeEnabled) {
                //
                // state change
                //
                g_bVolumeEnabled = bEnable;
                Volume_UpdateStatus(hWnd, bEnable, TRUE);
        }
        return(bEnable);
}

void Volume_UpdateStatus(HWND hWnd, BOOL bShowIcon, BOOL bKillSndVol32)
{
    // Don't show icon if not enabled
    if (!g_bVolumeEnabled)
        bShowIcon = FALSE;

        if (bShowIcon != g_bVolumeIconShown) {
                g_bVolumeIconShown = bShowIcon;
                if (bShowIcon) {
                        g_hVolumeIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_VOLUME),
                                                IMAGE_ICON, 16, 16, 0);
                        g_hMuteIcon = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_MUTE),
                                                IMAGE_ICON, 16, 16, 0);
                        Volume_UpdateIcon(hWnd, NIM_ADD);
                } else {
                        SysTray_NotifyIcon(hWnd, STWM_NOTIFYVOLUME, NIM_DELETE, NULL, NULL);
                        if (g_hVolumeIcon) {
                                DestroyIcon(g_hVolumeIcon);
                                g_hVolumeIcon = NULL;
                        }
                        if (g_hMuteIcon) {
                                DestroyIcon(g_hMuteIcon);
                                g_hMuteIcon = NULL;
                        }
                        if (g_hMixer)
                        {
                                mixerClose(g_hMixer);
                                g_hMixer = NULL;
                        }
                        g_uMixer = 0;
                        g_dwMixerDevNode = 0L;

                        //
                        // SNDVOL32 may have a TRAYMASTER window open,
                        // sitting on a timer before it closes (so multiple
                        // l-clicks on the tray icon can bring up the app
                        // quickly after the first hit).  Close that app
                        // if it's around.
                        //
                        if (bKillSndVol32)
                        {
                                Volume_WakeUpOrClose (TRUE);
                        }
                }
    }
}

const TCHAR szMapperPath[]      = TEXT ("Software\\Microsoft\\Multimedia\\Sound Mapper");
const TCHAR szPlayback[]        = TEXT ("Playback");
const TCHAR szPreferredOnly[]   = TEXT ("PreferredOnly");


/*
 * Volume_GetDefaultMixerID
 *
 * Get the default mixer id.  We only appear if there is a mixer associated
 * with the default wave.
 *
 */
MMRESULT Volume_GetDefaultMixerID(int *pid)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwMixID;
    DWORD           dwFlags = 0;
    
    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (mmr == MMSYSERR_NOERROR)
    {
        mmr = mixerGetID(HMIXEROBJ_INDEX(dwWaveID), &dwMixID, MIXER_OBJECTF_WAVEOUT);

                if (mmr == MMSYSERR_NOERROR && pid)
                {
                        *pid = dwMixID;
                }
    }

    return mmr;
}
        

/*
 * Process line changes
 */
void Volume_LineChange(
    HWND        hwnd,
    HMIXER      hmx,
    DWORD       dwLineID)
{
    if (dwLineID != g_dwMasterLine)
                return;
    //
    // if our line is disabled, go away, I guess
    //
}

/*
 * Process control changes
 */
void Volume_ControlChange(
    HWND        hwnd,
    HMIXER      hmx,
    DWORD       dwControlID)
{
    if ((dwControlID != g_dwMute) && (g_dwMute != (DWORD) -1))
                return;

    //
    // Change mute icon state
    //
    Volume_UpdateIcon(hwnd, NIM_MODIFY);
}


BOOL Volume_IsMute()
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    BOOL                fMute;

    if (!g_hMixer && (g_dwMute != (DWORD) -1))
    {
                return FALSE;
    }

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = g_dwMute;
    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)&fMute;

    mmr = mixerGetControlDetails( (HMIXEROBJ)g_hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (mmr == MMSYSERR_NOERROR)
    {
                return fMute;
    }

    return FALSE;
}

BOOL Volume_Controls(
    UINT                uMxID)
{
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxctrl;
    MIXERCAPS           mxcaps;
    MMRESULT            mmr;
    BOOL                fResult = FALSE;
    DWORD               iDest;
    g_dwMasterLine      = (DWORD) -1;
    g_dwMute            = (DWORD) -1;

    mmr = mixerGetDevCaps(uMxID, &mxcaps, sizeof(mxcaps));

    if (mmr != MMSYSERR_NOERROR)
    {
                return FALSE;
    }

    for (iDest = 0; iDest < mxcaps.cDestinations; iDest++)
    {
                MIXERLINE       mlDst;
        
                mlDst.cbStruct      = sizeof ( mlDst );
                mlDst.dwDestination = iDest;
        
                mmr = mixerGetLineInfo( HMIXEROBJ_INDEX(uMxID), &mlDst, MIXER_GETLINEINFOF_DESTINATION);

                if (mmr != MMSYSERR_NOERROR)
        {
                        continue;
        }

                switch (mlDst.dwComponentType)
                {
                    default:
                    continue;
                    
                case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
            {
                            g_dwMasterLine = mlDst.dwLineID;
            }
                        break;
                }
        
                mxlc.cbStruct       = sizeof(mxlc);
                mxlc.dwLineID       = g_dwMasterLine;
                mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUTE;
                mxlc.cControls      = 1;
                mxlc.cbmxctrl       = sizeof(mxctrl);
                mxlc.pamxctrl       = &mxctrl;
                
                mmr = mixerGetLineControls( HMIXEROBJ_INDEX(uMxID), &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

                if (mmr == MMSYSERR_NOERROR)
        {
                        g_dwMute = mxctrl.dwControlID;
        }
        
                fResult = TRUE;
                break;
        
    }
    return fResult;
}

void Volume_UpdateIcon(
    HWND hWnd,
    DWORD message)
{
    BOOL        fMute;
    LPTSTR      lpsz;
    HICON       hVol;

    fMute   = Volume_IsMute();
    hVol    = fMute?g_hMuteIcon:g_hVolumeIcon;
    lpsz    = LoadDynamicString(fMute?IDS_MUTED:IDS_VOLUME);
    SysTray_NotifyIcon(hWnd, STWM_NOTIFYVOLUME, message, hVol, lpsz);
    DeleteDynamicString(lpsz);
}



// WinMM is telling us the preferred device has changed for some reason
// Dump the old, open the new
//
void Volume_WinMMDeviceChange(HWND hWnd)
{
    DWORD dwMixID;

        if (g_hMixer)               // Dumping the Old
        {
                mixerClose(g_hMixer);
                g_hMixer = NULL;
                g_uMixer = 0;
                g_dwMixerDevNode = 0L;
        }
                                // Opening the new
    if (Volume_GetDefaultMixerID(&dwMixID) == MMSYSERR_NOERROR)
    {   
                if ( Volume_Controls(dwMixID) && 
             (mixerOpen(&g_hMixer, dwMixID, (DWORD_PTR)hWnd, 0L, CALLBACK_WINDOW | MIXER_OBJECTF_MIXER) == MMSYSERR_NOERROR))
                {
                        Volume_UpdateStatus(hWnd, TRUE, TRUE);

                        if (mixerMessage (HMIXER_INDEX(dwMixID), DRV_QUERYDEVNODE, (DWORD_PTR)&g_dwMixerDevNode, 0L))
            {
                                g_dwMixerDevNode = 0L;
            }

                        g_uMixer = dwMixID;

            Volume_UpdateIcon(hWnd, NIM_MODIFY);
                }
                else
                {
                        Volume_UpdateStatus(hWnd, FALSE, TRUE);
                }
    }
    else
    {
                Volume_UpdateStatus(hWnd, FALSE, TRUE);
    }
}


// Need to free up in the event of a power broadcast as well
//
void Volume_HandlePowerBroadcast(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
            case PBT_APMQUERYSUSPEND:
        {
                if (g_hMixer)               // Dumping the Old
                {
                        mixerClose(g_hMixer);
                        g_hMixer = NULL;
                        g_uMixer = 0;
                        g_dwMixerDevNode = 0L;
                }
        }
            break;

            case PBT_APMQUERYSUSPENDFAILED:
            case PBT_APMRESUMESUSPEND:
        {
            Volume_WinMMDeviceChange(hWnd); 
        }
            break;
    }
}


void Volume_DeviceChange_Cleanup()
{
   if (DeviceEventContext) 
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }

   return;
}

/*
**************************************************************************************************
        Volume_GetDeviceHandle()

        given a mixerID this functions opens its corresponding device handle. This handle can be used 
        to register for DeviceNotifications.

        dwMixerID -- The mixer ID
        phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
                                successful
        
        return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL Volume_GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
        MMRESULT mmr;
        ULONG cbSize=0;
        TCHAR *szInterfaceName=NULL;

        //Query for the Device interface name
        mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
        if(MMSYSERR_NOERROR == mmr)
        {
                szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
                if(!szInterfaceName)
                {
                        return FALSE;
                }

                mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
                if(MMSYSERR_NOERROR != mmr)
                {
                        GlobalFreePtr(szInterfaceName);
                        return FALSE;
                }
        }
        else
        {
                return FALSE;
        }

        //Get an handle on the device interface name.
        *phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        GlobalFreePtr(szInterfaceName);
        if(INVALID_HANDLE_VALUE == *phDevice)
        {
                return FALSE;
        }

        return TRUE;
}


/*      DeviceChange_Init()
*       First time initialization for WM_DEVICECHANGE messages
*       
*       On NT 5.0, you have to register for device notification
*/
void Volume_DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{
        DEV_BROADCAST_HANDLE DevBrodHandle;
        HANDLE hMixerDevice=NULL;


        //If we had registered already for device notifications, unregister ourselves.
        Volume_DeviceChange_Cleanup();

        //If we get the device handle register for device notifications on it.
        if(Volume_GetDeviceHandle(dwMixerID, &hMixerDevice))
        {
                memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

                DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
                DevBrodHandle.dbch_handle = hMixerDevice;

                DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

                if(hMixerDevice)
                {
                        CloseHandle(hMixerDevice);
                        hMixerDevice = NULL;
                }
    }
}

// Watch for PNP events to free up the open handle when needed
// We will assume any changes will now generate a WINMM_DEVICECHANGED message from WinMM
// except for the QUERYREMOVEFAILED case, in this case we will just re-aquire the preferred mixer
//
void Volume_DeviceChange(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
    PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;
        
    //If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.

    if(!DeviceEventContext || !bh || (bh->dbch_devicetype != DBT_DEVTYP_HANDLE))
    {
        return;
    }
        
    switch (wParam)
    {
        case DBT_DEVICEQUERYREMOVE:             // Someone wants to remove this device, let's let them.
        {
                if (g_hMixer)
                    {
                            mixerClose(g_hMixer);
                            g_hMixer = NULL;
                            g_uMixer = 0;
                            g_dwMixerDevNode = 0L;
                    }
                }
            break;

            case DBT_DEVICEQUERYREMOVEFAILED:       // The query failed, the device will not be removed, so lets reopen it.
        {
            Volume_WinMMDeviceChange(hWnd);     // Lets just use this function to do it.
        }
            break;
    }
}

void Volume_WmDestroy(
   HWND hDlg
   )
{
    Volume_DeviceChange_Cleanup();
}

void Volume_Shutdown(
    HWND hWnd)
{
    Volume_UpdateStatus(hWnd, FALSE, FALSE);
}

void Volume_Menu(HWND hwnd, UINT uMenuNum, UINT uButton)
{
    POINT   pt;
    UINT    iCmd;
    HMENU   hmenu;

    GetCursorPos(&pt);

    hmenu = Volume_CreateMenu();
    if (!hmenu)
                return;

    SetForegroundWindow(hwnd);
    iCmd = TrackPopupMenu(hmenu, uButton | TPM_RETURNCMD | TPM_NONOTIFY,
        pt.x, pt.y, 0, hwnd, NULL);

    DestroyMenu(hmenu);
    switch (iCmd) {
        case VOLUMEMENU_PROPERTIES:
            Volume_ControlPanel(hwnd);
            break;

        case VOLUMEMENU_SNDVOL:
            Volume_VolumeControl();
            break;
    }

    SetIconFocus(hwnd, STWM_NOTIFYVOLUME);

}

void Volume_Notify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    switch (lParam)
    {
        case WM_RBUTTONUP:
            Volume_Menu(hwnd, 1, TPM_RIGHTBUTTON);
            break;

        case WM_LBUTTONDOWN:
            SetTimer(hwnd, VOLUME_TIMER_ID, GetDoubleClickTime()+100, NULL);
            break;

        case WM_LBUTTONDBLCLK:
            KillTimer(hwnd, VOLUME_TIMER_ID);
            Volume_VolumeControl();
            break;
    }
}


/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/*
 * MYWM_WAKEUP and the "Tray Volume" window are defined by the SNDVOL32.EXE
 * application.  Changing these values or changing the values in SNDVOL32.EXE
 * without mirroring them here will break the tray volume dialog.
 */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */
/* WARNING - WARNING - DANGER - DANGER - WARNING - WARNING - DANGER - DANGER */

#define MYWM_WAKEUP             (WM_APP+100+6)

void Volume_Timer(HWND hwnd)
{
        KillTimer(hwnd, VOLUME_TIMER_ID);

        Volume_WakeUpOrClose (FALSE);
}

void Volume_WakeUpOrClose(BOOL fClose)
{
        const TCHAR szVolWindow [] = TEXT ("Tray Volume");
        HWND hApp;

        if (hApp = FindWindow(szVolWindow, NULL))
        {
                SendMessage(hApp, MYWM_WAKEUP, (WPARAM)fClose, 0);
        }
        else if (!fClose)
        {
                const TCHAR szOpen[]    = TEXT ("open");
                const TCHAR szVolApp[]  = TEXT ("SNDVOL32.EXE");
                const TCHAR szParamsWakeup[]  = TEXT ("/t");

                ShellExecute (NULL, szOpen, szVolApp, szParamsWakeup, NULL, SW_SHOWNORMAL);
        }
}


/*
 * Volume_ControlPanel
 *
 * Launch "Audio" control panel/property sheet upon request.
 *
 * */
void Volume_ControlPanel(HWND hwnd)
{
        const TCHAR szOpen[]    = TEXT ("open");
        const TCHAR szRunDLL[]  = TEXT ("RUNDLL32.EXE");
        const TCHAR szParams[]  = TEXT ("MMSYS.CPL,ShowFullControlPanel");

        ShellExecute(NULL, szOpen, szRunDLL, szParams, NULL, SW_SHOWNORMAL);
}

/*
 * Volume_VolumeControl
 *
 * Launch Volume Control App
 *
 * */
void Volume_VolumeControl()
{
        const TCHAR szOpen[]    = TEXT ("open");
        const TCHAR szVolApp[]  = TEXT ("SNDVOL32.EXE");

        ShellExecute(NULL, szOpen, szVolApp, NULL, NULL, SW_SHOWNORMAL);
}



/*
 * FileExists
 *
 * Does a file exist
 *
 * */

BOOL FileExists(LPCTSTR pszPath)
{
        return (GetFileAttributes(pszPath) != (DWORD)-1);
} // End FileExists


/*
 * FindSystemFile
 *
 * Finds full path to specified file
 *
 * */

BOOL FindSystemFile(LPCTSTR pszFileName, LPTSTR pszFullPath, UINT cchSize)
{
        TCHAR       szPath[MAX_PATH];
        LPTSTR      pszName;
        DWORD       cchLen;

        if ((pszFileName == NULL) || (pszFileName[0] == 0))
                return FALSE;

        cchLen = SearchPath(NULL, pszFileName, NULL, MAX_PATH,
                                                szPath,&pszName);
        if (cchLen == 0)
                return FALSE;
        
        if (cchLen >= MAX_PATH)
                cchLen = MAX_PATH - 1;

        if (! FileExists (szPath))
                return FALSE;

        if ((pszFullPath == NULL) || (cchSize == 0))
                return TRUE;

           // Copy full path into buffer
        if (cchLen >= cchSize)
                cchLen = cchSize - 1;
        
        lstrcpyn (pszFullPath, szPath, cchLen);
        
        pszFullPath[cchLen] = 0;

        return TRUE;
} // End FindSystemFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\systray\exestub\systray.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       SYSTRAY.C
*
*  VERSION:     2.0
*
*  AUTHOR:      TCS/RAL
*
*  DATE:        08 Feb 1994
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  08 Feb 1994 TCS Original implementation.
*  11 Nov 1994 RAL Converted from batmeter to systray
*  11 Aug 1995 JEM Split batmeter functions into power.c & minor enahncements
*  23 Oct 1995 Shawnb Unicode enabled
*  07 Aug 1998 dsheldon Created systray.dll and made this into a stub exe
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>
#include <systrayp.h>
#include <initguid.h>
#include <stclsid.h>

//  Global instance handle of this application.
HINSTANCE g_hInstance;

INT intval(LPCTSTR lpsz)
{
    INT i = 0;
    while (*lpsz >= TEXT ('0') && *lpsz <= TEXT ('9'))
    {
        i = i * 10 + (int)(*lpsz - TEXT ('0'));
        lpsz++;
    }
    return(i);
}

// stolen from the CRT, used to shrink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine ();

    if ( *pszCmdLine == TEXT ('\"') )
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != TEXT ('\"')) )
            ;

        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT ('\"') )
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' '))
    {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo (&si);

    i = WinMain(GetModuleHandle(NULL), NULL, (LPSTR)pszCmdLine,
                si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;    // We never come here.
}



/*******************************************************************************
*
*  WinMain
*
*  DESCRIPTION:
*
*  PARAMETERS:
*       if lpCmdLine contains an integer value then we'll enable that service
*
*******************************************************************************/
STDAPI_(int) WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    HWND hWnd;

    HWND hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
    UINT iEnableServ = intval((LPTSTR)lpszCmdLine);
    g_hInstance = hInstance;

    if (hExistWnd)
    {
        //
        // NOTE: Send an enable message even if the command line parameter
        //       is 0 to force us to re-check for all enabled services.
        //
        PostMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
        goto ExitMain;
    }
    else
    {
        int i;

        // We have to inject systray.dll into the explorer process
        if (SUCCEEDED(SHLoadInProc(&CLSID_SysTrayInvoker)))
        {
            // Wait for up to 30 seconds for the window to be created, 
            // send our message every second
        
            for (i = 0; i < 30; i ++)
            {
                Sleep(1000);
                hExistWnd = FindWindow(SYSTRAY_CLASSNAME, NULL);
                if (hExistWnd)
                {
                    PostMessage(hExistWnd, STWM_ENABLESERVICE, iEnableServ, TRUE);
                    goto ExitMain;        
                }
            }
        }
    }

ExitMain:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\debug.cpp ===
#include "precomp.hxx"
#include "stdio.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "TimeWarp"
#define SZ_MODULE           "TimeWarp"
#define DECLARE_DEBUG       1

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\contextmenu.cpp ===
#include "precomp.hxx"
#pragma  hdrstop

#include <cowsite.h>
#include "contextmenu.h"

// Context Menu Forwarding base class, desinged to delegate
// to a real IContextMenu, and provide inheriting class
// an easy way to override minor bits of functionality
//
CContextMenuForwarder::CContextMenuForwarder(IUnknown* punk) : _cRef(1)
{
    _punk = punk;
    _punk->AddRef();

    _punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &_pows));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu, &_pcm));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2));
    _punk->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3));
}

CContextMenuForwarder::~CContextMenuForwarder()
{
    if (_pows) _pows->Release();
    if (_pcm)  _pcm->Release();
    if (_pcm2) _pcm2->Release();
    if (_pcm3) _pcm3->Release();
    _punk->Release();
}

STDMETHODIMP CContextMenuForwarder::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = _punk->QueryInterface(riid, ppv);

    if (SUCCEEDED(hr))
    {
        IUnknown* punkTmp = (IUnknown*)(*ppv);

        static const QITAB qit[] = {
            QITABENT(CContextMenuForwarder, IObjectWithSite),                     // IID_IObjectWithSite
            QITABENT(CContextMenuForwarder, IContextMenu3),                       // IID_IContextMenu3
            QITABENTMULTI(CContextMenuForwarder, IContextMenu2, IContextMenu3),   // IID_IContextMenu2
            QITABENTMULTI(CContextMenuForwarder, IContextMenu, IContextMenu3),    // IID_IContextMenu
            { 0 },
        };

        HRESULT hrTmp = QISearch(this, qit, riid, ppv);

        if (SUCCEEDED(hrTmp))
        {
            punkTmp->Release();
        }
        else
        {
            RIPMSG(FALSE, "CContextMenuForwarder asked for an interface it doesn't support");
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CContextMenuForwarder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// Forward everything to the given context menu,
// but remove menu items with the canonical verbs
// given in the semicolon-separated list of canonical verbs
//
class CContextMenuWithoutVerbs : CContextMenuForwarder
{
public:
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);

protected:
    CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList);

    friend HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);

private:
    LPCWSTR _pszVerbList;
};

CContextMenuWithoutVerbs::CContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList) : CContextMenuForwarder(punk) 
{
    _pszVerbList = pszVerbList; // no reference - this should be a pointer to the code segment
}

HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    if (pszVerbList)
    {
        CContextMenuWithoutVerbs* p = new CContextMenuWithoutVerbs(punk, pszVerbList);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
    }

    return hr;
}

HRESULT CContextMenuWithoutVerbs::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    HRESULT hr = CContextMenuForwarder::QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszVerb = _pszVerbList;

        while (*pszVerb)
        {
            WCHAR szVerb[64];

            LPCWSTR pszNext = StrChrW(pszVerb, L';');

            if (pszNext)
            {
                size_t cch = (size_t)(pszNext - pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyNW(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb = pszNext + 1;
            }
            else
            {
                size_t cch = lstrlenW(pszVerb) + 1;

                ASSERT(0 < cch && cch < ARRAYSIZE(szVerb)); // we should be large enough for all the canonical verbs we use

                StrCpyNW(szVerb, pszVerb, min(cch, ARRAYSIZE(szVerb)));

                pszVerb += cch - 1; // point at NULL
            }

            ContextMenu_DeleteCommandByName(_pcm, hmenu, idCmdFirst, szVerb);
        }
    }
    return hr;
}

// Forward everything to the given context menu,
// but disable popup menus
//
class CContextMenuWithoutPopups : CContextMenuForwarder
{
public:
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);

protected:
    CContextMenuWithoutPopups(IUnknown* punk) : CContextMenuForwarder(punk) {}

    friend HRESULT Create_ContextMenuWithoutPopups(IUnknown* punk, REFIID riid, void **ppv);
};

HRESULT Create_ContextMenuWithoutPopups(IUnknown* punk, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    CContextMenuWithoutPopups* p = new CContextMenuWithoutPopups(punk);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

HRESULT CContextMenuWithoutPopups::QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    HRESULT hr = CContextMenuForwarder::QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags);
    if (SUCCEEDED(hr))
    {
        MENUITEMINFO mii;

        // Disable any submenus that were just added
        mii.cbSize = sizeof(mii);
        idCmdLast = idCmdFirst + ShortFromResult(hr);
        for (UINT i = idCmdFirst; i < idCmdLast; i++)
        {
            mii.fMask = MIIM_STATE | MIIM_SUBMENU;
            if (GetMenuItemInfo(hmenu, i, FALSE, &mii)
                && mii.hSubMenu
                && (mii.fState & (MFS_DISABLED | MFS_GRAYED)) != (MFS_DISABLED | MFS_GRAYED))
            {
                mii.fMask = MIIM_STATE;
                mii.fState |= MFS_DISABLED | MFS_GRAYED;
                SetMenuItemInfo(hmenu, i, FALSE, &mii);
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\helpids.h ===
#define IDH_TIMEWARP_SNAPSHOTLIST       203
#define IDH_TIMEWARP_OPENSNAP           204
#define IDH_TIMEWARP_SAVESNAP           205
#define IDH_TIMEWARP_RESTORESNAP        206
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\contextmenu.h ===
// An IContextMenu on an existing IContextMenu, which removes the ';'-separated list of verbs from the resulting menu
HRESULT Create_ContextMenuWithoutVerbs(IUnknown* punk, LPCWSTR pszVerbList, REFIID riid, void **ppv);

// An IContextMenu on an existing IContextMenu, which removes submenus from the resulting menu
HRESULT Create_ContextMenuWithoutPopups(IUnknown* punk, REFIID riid, void **ppv);


// CContextMenuForwarder is designed as a base class that forwards all
// context menu stuff to another IContextMenu implementation.  You override
// whatever functions you want to modify.  (Like QueryContextMenu - delegate then modify the results)
// For example, CContextMenuWithoutVerbs inherits from this class.
//
class CContextMenuForwarder : IContextMenu3, IObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu3
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags) { return _pcm->QueryContextMenu(hmenu,indexMenu,idCmdFirst,idCmdLast,uFlags); }
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici) { return _pcm->InvokeCommand(lpici); }
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax) { return _pcm->GetCommandString(idCmd,uType,pwReserved,pszName,cchMax); }

    // IContextMenu2
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { return _pcm2->HandleMenuMsg(uMsg,wParam,lParam); }

    // IContextMenu3
    STDMETHODIMP HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult) { return _pcm3->HandleMenuMsg2(uMsg,wParam,lParam,plResult); }

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite) { return _pows->SetSite(punkSite); }
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite) { return _pows->GetSite(riid,ppvSite); }

protected:
    CContextMenuForwarder(IUnknown* punk);
    virtual ~CContextMenuForwarder();

private:
    LONG _cRef;

protected:
    IUnknown*        _punk;

    IObjectWithSite* _pows;
    IContextMenu*    _pcm;
    IContextMenu2*   _pcm2;
    IContextMenu3*   _pcm3;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\dll.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <advpub.h>     // RegInstall stuff

#include "twprop.h"     // CTimeWarpProp::CreateInstance
#include "twfldr.h"     // CTimeWarpFolder::CreateInstance

HINSTANCE g_hInstance = 0;
LONG g_cRefThisDll = 0;         // DLL global reference count


CF_TABLE_BEGIN(g_ObjectInfo)
    CF_TABLE_ENTRY(&CLSID_TimeWarpProp, CTimeWarpProp::CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_TimeWarpFolder, CTimeWarpRegFolder::CreateInstance, COCREATEONLY),
CF_TABLE_END(g_ObjectInfo)


STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    // No aggregation
    if (punkOuter) // && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        //if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
        //    return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    // Time Warp is only available beginning with Windows XP.
    if (!IsOS(OS_WHISTLERORGREATER))
    {
        return CO_E_WRONGOSFORAPP;
    }

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll ? S_FALSE : S_OK;
}

// Call ADVPACK for the given section of our resource based INF
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hInstance, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hInstance, "UnregDll");
    return S_OK;
}

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, void *pReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        CcshellGetDebugFlags();
        SHFusionInitializeFromModule(hInstance);
        InitSnapCheckCache();
        break;

    case DLL_PROCESS_DETACH:
        DestroySnapCheckCache();
        SHFusionUninitialize();
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDI_TIMEWARP                    100
#define DLG_TIMEWARPPROP_FOLDER         101
#define DLG_TIMEWARPPROP_FILE           102
#define POPUP_TIMEWARP_MENU             103

#define IDC_TWICON                      201
#define IDC_TOPTEXT                     202
#define IDC_LIST                        203
#define IDC_VIEW                        204
#define IDC_COPY                        205
#define IDC_REVERT                      206

#define IDS_TIMEWARP_TITLE              1024
#define IDS_FOLDER_TITLE_FORMAT         1025
#define IDS_NAMECOL                     1026
#define IDS_DATECOL                     1027
#define IDS_CONFIRM_REVERT_FOLDER       1028
#define IDS_CONFIRM_REVERT_FILE         1029
#define IDS_SUCCESS_REVERT_FOLDER       1030
#define IDS_SUCCESS_REVERT_FILE         1031
#define IDS_COPY                        1032
#define IDS_BROWSE_TITLE_COPY           1033
#define IDS_BROWSE_INTRO_COPY           1034
#define IDS_BROWSE_INTRO_COPY2          1035
#define IDS_ALLFILESFILTER              1036
#define IDS_CANNOTCREATEFOLDER          1037
#define IDS_ERROR_FILE_EXISTS           1038
#define IDS_ERROR_FILENAME_EXCED_RANGE  1039
#define IDS_ACCNAME_FORMAT              1040
#define IDS_CANTFINDSNAPSHOT_FOLDER     1041
#define IDS_CANTFINDSNAPSHOT_FILE       1042

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1043
#define _APS_NEXT_SYMED_VALUE           207
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\sources.inc ===
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

SELFREGNAME= $(O)\selfreg_twext.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)
NTTARGETFILES=

TARGETNAME= twext
TARGETTYPE= DYNLINK
TARGETPATH= obj

DLLDEF=     ..\timewarp.def
DLLENTRY=   DllMain
DLLBASE=    0x77000000

BINPLACE_PLACEFILE=placefil.txt
USE_NTDLL= 1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\user32.lib      \
            $(SDK_LIB_PATH)\gdi32.lib       \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SHELL_LIB_PATH)\shell32p.lib  \
            $(CCSHELL_DIR)\lib\$(O)\shguid.lib \
            $(CCSHELL_DIR)\lib\$(O)\shguidp.lib \
            $(SHELL_LIB_PATH)\shlwapip.lib  \
            $(SHELL_LIB_PATH)\shfusion.lib  \
            $(SDK_LIB_PATH)\mpr.lib         \
            $(SDK_LIB_PATH)\netapi32.lib    \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(SDK_LIB_PATH)\oleacc.lib      \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(CCSHELL_DIR)\lib\$(O)\stock.lib

DELAYLOAD=advapi32.dll;mpr.dll;netapi32.dll;ole32.dll;oleaut32.dll;oleacc.dll
DLOAD_ERROR_HANDLER=kernel32

INCLUDES=   ..\;..\..\..\shell32;$(DS_INC_PATH);$(BASE_INC_PATH);$(O)

SOURCES=    ..\access.cpp      \
            ..\contextmenu.cpp \
            ..\debug.cpp       \
            ..\dll.cpp         \
            ..\twfldr.cpp      \
            ..\twprop.cpp      \
            ..\util.cpp        \
            ..\timewarp.c      \
            ..\resource.rc

PRECOMPILED_INCLUDE=..\precomp.hxx
 
# Fusionized
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\timewarp.h ===
#ifndef _TIMEWARP_H
#define _TIMEWARP_H

#if defined(__cplusplus)
extern "C" {
#endif

// If the API here are ever made public, these 2 symbols should be
// moved somewhere else (not public).
#define SNAPSHOT_NAME_LENGTH    24  // strlen("@GMT-YYYY.MM.DD-HH.MM.SS")
#define SNAPSHOT_MARKER         L"@GMT-"

#define QUERY_SNAPSHOT_EXISTING     0x1
#define QUERY_SNAPSHOT_DIFFERENT    0x2

DWORD
QuerySnapshotsForPath(
    IN LPCWSTR lpszFilePath,
    IN DWORD dwQueryFlags,
    OUT LPWSTR* ppszPathMultiSZ,
    OUT LPDWORD iNumberOfPaths );
/*++

Routine Description:

    This function takes a path and returns an array of snapshot-paths to the file.
    (These are the paths to be passed to Win32 functions to obtain handles to the
    previous versions of the file.)

Arguments:

    lpszFilePath - The UNICODE path to the file or directory
    dwQueryFlags - See Notes below
    ppszPathMultiSZ - Upon successful return, the allocated array of the path
    iNumberOfPaths - Upon successful return, the number of paths returned


Return Value:

    Windows Error code

Notes:

    - The user is responsible for freeing the returned buffer with LocalFree
    - The possible flags are:

        Return only the path names where the file exists
        #define QUERY_SNAPSHOT_EXISTING     0x1

        Return the minimum set of paths to the different versions of the
        files.  (Does LastModifiedTime checking)
        #define QUERY_SNAPSHOT_DIFFERENT    0x2


--*/


DWORD
GetSnapshotTimeFromPath(
    IN LPCWSTR lpszFilePath,
    IN OUT FILETIME *pUTCTime
    );

#if defined(__cplusplus)
}
#endif

#endif  // _TIMEWARP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\timewarp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <srvfsctl.h>   // FSCTL_SRV_ENUMERATE_SNAPSHOTS
#include <lm.h>
#include <lmdfs.h>      // NetDfsGetClientInfo
#include <shlwapi.h>    // PathIsUNC
#include "timewarp.h"


typedef struct _SRV_SNAPSHOT_ARRAY
{
    ULONG NumberOfSnapshots;            // The number of snapshots for the volume
    ULONG NumberOfSnapshotsReturned;     // The number of snapshots we can fit into this buffer
    ULONG SnapshotArraySize;            // The size (in bytes) needed for the array
    WCHAR SnapShotMultiSZ[1];           // The multiSZ array of snapshot names
} SRV_SNAPSHOT_ARRAY, *PSRV_SNAPSHOT_ARRAY;

DWORD
OpenFileForSnapshot(
    IN LPCWSTR lpszFilePath,
    OUT HANDLE* pHandle
    )
/*++

Routine Description:

    This routine opens a file with the access needed to query its snapshot information
Arguments:

    lpszFilePath - network path to the file
    pHandle  - Upon return, the handle to the opened file

Return Value:

    Win32 Error

Notes:

    None

--*/
{
    NTSTATUS Status;
    UNICODE_STRING uPathName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    *pHandle = CreateFile( lpszFilePath, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );
    if( *pHandle == INVALID_HANDLE_VALUE )
    {
        return GetLastError();
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

NTSTATUS
IssueSnapshotControl(
    IN HANDLE hFile,
    IN PVOID pData,
    IN ULONG outDataSize
    )
/*++

Routine Description:

    This routine issues the snapshot enumeration FSCTL against the provided handle

Arguments:

    hFile - The handle to the file in question
    pData - A pointer to the output buffer
    outDataSize - The size of the given output buffer

Return Value:

    NTSTATUS

Notes:

    None

--*/

{
    NTSTATUS Status;
    HANDLE hEvent;
    IO_STATUS_BLOCK ioStatusBlock;
    PSRV_SNAPSHOT_ARRAY pArray;

    RtlZeroMemory( pData, outDataSize );

    // Create an event to synchronize with the driver
    Status = NtCreateEvent(
                &hEvent,
                FILE_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE
                );
    if( NT_SUCCESS(Status) )
    {
        Status = NtFsControlFile(
                    hFile,
                    hEvent,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_SRV_ENUMERATE_SNAPSHOTS,
                    NULL,
                    0,
                    pData,
                    outDataSize);
        if( Status == STATUS_PENDING )
        {
            NtWaitForSingleObject( hEvent, FALSE, NULL );
            Status = ioStatusBlock.Status;
        }

        NtClose( hEvent );
    }

    // Check the return value
    if( NT_SUCCESS(Status) )
    {
        pArray = (PSRV_SNAPSHOT_ARRAY)pData;
        if( pArray->NumberOfSnapshots != pArray->NumberOfSnapshotsReturned )
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    return Status;
}


DWORD
QuerySnapshotNames(
    IN HANDLE hFile,
    OUT LPWSTR* ppszSnapshotNameArray,
    OUT LPDWORD pdwNumberOfSnapshots
    )
/*++

Routine Description:

    This routine takes a handle to a file and returns a MultiSZ list
    of the snapshots availible on the volume the handle resides.

Arguments:

    hFile - Handle to the file in question
    ppszSnapshotNameArray - Upon return, an allocated MultiSZ array of names
    pdwNumberOfSnapshots  - the number of snapshots in the above array

Return Value:

    Win32 Error

Notes:

    The returned list of snapshots is complete for the volume.  It is not
    guaranteed that every returned entry will actually have the file existing
    in that snapshot.  The caller should check that themselves.

--*/

{
    NTSTATUS Status;
    SRV_SNAPSHOT_ARRAY sArray;
    PSRV_SNAPSHOT_ARRAY psAllocatedArray = NULL;
    LPWSTR pszNameArray = NULL;

    // Query the size needed for the snapshots
    Status = IssueSnapshotControl( hFile, &sArray, sizeof(SRV_SNAPSHOT_ARRAY) );
    if( NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW) )
    {
        ULONG AllocSize = sizeof(SRV_SNAPSHOT_ARRAY)+sArray.SnapshotArraySize;

        if( sArray.NumberOfSnapshots == 0 )
        {
            *pdwNumberOfSnapshots = 0;
            *ppszSnapshotNameArray = NULL;
        }
        else
        {
            // Allocate the array to the necessary size
            psAllocatedArray = (PSRV_SNAPSHOT_ARRAY)LocalAlloc( LPTR, AllocSize );
            if( psAllocatedArray )
            {
                // Call again with the proper size array
                Status = IssueSnapshotControl( hFile, psAllocatedArray, AllocSize );
                if( NT_SUCCESS(Status) )
                {
                    // Allocate the string needed
                    pszNameArray = (LPWSTR)LocalAlloc( LPTR, psAllocatedArray->SnapshotArraySize );
                    if( pszNameArray )
                    {
                        // Copy the string and succeed
                        RtlCopyMemory( pszNameArray, psAllocatedArray->SnapShotMultiSZ, psAllocatedArray->SnapshotArraySize );
                        *ppszSnapshotNameArray = pszNameArray;
                        *pdwNumberOfSnapshots = psAllocatedArray->NumberOfSnapshots;
                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else if( Status == STATUS_BUFFER_OVERFLOW )
                {
                    Status = STATUS_RETRY;
                }

                LocalFree( psAllocatedArray );
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return RtlNtStatusToDosError(Status);
}

LPCWSTR
FindVolumePathSplit(
    IN LPCWSTR lpszPath
    )
{
    LPCWSTR pszTail = NULL;
    WCHAR szVolumeName[MAX_PATH];

    if (GetVolumePathNameW(lpszPath, szVolumeName, MAX_PATH))
    {
        ULONG cchVolumeName = lstrlenW(szVolumeName);
        ASSERT(cchVolumeName > 0);
        ASSERT(szVolumeName[cchVolumeName-1] == L'\\');

        pszTail = lpszPath + (cchVolumeName - 1);

        ASSERT(pszTail <= lpszPath + lstrlenW(lpszPath));
        ASSERT(*pszTail == L'\\' || *pszTail == L'\0');
    }

    return pszTail;
}

LPCWSTR
FindDfsUncSplit(
    IN LPCWSTR lpszPath
    )
{
    LPCWSTR pszTail = NULL;
    PDFS_INFO_1 pDI1;
    DWORD dwErr;

    ASSERT(PathIsUNCW(lpszPath));

    // Check for DFS
    dwErr = NetDfsGetClientInfo((LPWSTR)lpszPath, NULL, NULL, 1, (LPBYTE*)&pDI1);
    if (NERR_Success == dwErr)
    {
        // Note that EntryPath has only a single leading backslash, hence +1
        pszTail = lpszPath + lstrlenW(pDI1->EntryPath) + 1;

        ASSERT(pszTail <= lpszPath + lstrlenW(lpszPath));
        ASSERT(*pszTail == L'\\' || *pszTail == L'\0');

        NetApiBufferFree(pDI1);
    }

    return pszTail;
}

LPCWSTR
FindDfsPathSplit(
    IN LPCWSTR lpszPath
    )
{
    LPCWSTR pszTail = NULL;
    DWORD cbBuffer;
    DWORD dwErr;
    REMOTE_NAME_INFOW *pUncInfo;

    if (PathIsUNCW(lpszPath))
        return FindDfsUncSplit(lpszPath);

    ASSERT(PathIsNetworkPathW(lpszPath));

    // Get the UNC path.
    //
    // Note that WNetGetUniversalName returns ERROR_INVALID_PARAMETER if you
    // specify NULL for the buffer and 0 length (asking for size).

    cbBuffer = sizeof(REMOTE_NAME_INFOW) + MAX_PATH*sizeof(WCHAR);    // initial guess
    pUncInfo = (REMOTE_NAME_INFOW*)LocalAlloc(LPTR, cbBuffer);
    if (pUncInfo)
    {
        dwErr = WNetGetUniversalNameW(lpszPath, REMOTE_NAME_INFO_LEVEL, pUncInfo, &cbBuffer);
        if (ERROR_MORE_DATA == dwErr)
        {
            // Alloc a new buffer and try again
            LocalFree(pUncInfo);
            pUncInfo = (REMOTE_NAME_INFOW*)LocalAlloc(LPTR, cbBuffer);
            if (pUncInfo)
            {
                dwErr = WNetGetUniversalNameW(lpszPath, REMOTE_NAME_INFO_LEVEL, pUncInfo, &cbBuffer);
            }
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // Find the tail
            LPCWSTR pszUncTail = FindDfsUncSplit(pUncInfo->lpUniversalName);
            if (pszUncTail)
            {
                UINT cchJunction;
                UINT cchConnectionName;

                // It's a DFS path, so we'll at least return a
                // pointer to the drive root.
                ASSERT(lpszPath[0] != L'\0' && lpszPath[1] == L':');
                pszTail = lpszPath + 2; // skip "X:"

                // If the DFS junction is deeper than the drive mapping,
                // move the pointer to after the junction point.
                cchJunction = (UINT)(pszUncTail - pUncInfo->lpUniversalName);
                cchConnectionName = lstrlenW(pUncInfo->lpConnectionName);

                if (cchJunction > cchConnectionName)
                {
                    pszTail += cchJunction - cchConnectionName;
                }

                ASSERT(pszTail <= lpszPath + lstrlenW(lpszPath));
                ASSERT(*pszTail == L'\\' || *pszTail == L'\0');
            }
        }

        LocalFree(pUncInfo);
    }

    return pszTail;
}

LPCWSTR
FindSnapshotPathSplit(
    IN LPCWSTR lpszPath
    )
/*++

Routine Description:

    This routine looks at a path and determines where the snapshot token will be
    inserted

Arguments:

    lpszPath - The path we're examining

Return Value:

    LPWSTR (pointer to the insertion point within lpszPath)

Notes:

    None

--*/

{
    LPCWSTR pszVolumeTail;
    LPCWSTR pszDfsTail;

    // FindVolumePathSplit accounts for mounted volumes, but not DFS.
    // FindDfsPathSplit accounts for DFS, but not mounted volumes.
    // Try both methods and pick the larger of the 2, if both succeed.

    pszVolumeTail = FindVolumePathSplit(lpszPath);
    pszDfsTail = FindDfsPathSplit(lpszPath);

    // Note that this comparison automatically handles the cases
    // where either or both pointers are NULL.
    if (pszDfsTail > pszVolumeTail)
    {
        pszVolumeTail = pszDfsTail;
    }

    return pszVolumeTail;
}


#define PREFIX_DRIVE        L"\\\\?\\"
#define PREFIX_UNC          L"\\\\?\\UNC\\"
#define MAX_PREFIX_LENGTH   8   // strlen(PREFIX_UNC)

DWORD
BuildSnapshotPathArray(
    IN ULONG lNumberOfSnapshots,
    IN LPWSTR pszSnapshotNameMultiSZ,
    IN LPCWSTR lpszPath,
    IN ULONG  lFlags,
    OUT LPWSTR* lplpszPathArray,
    OUT LPDWORD lpdwPathCount
    )
/*++

Routine Description:

    This routine has the fun task of assembling an array of paths based on the
    snapshot name array, the path to the file, and the flags the user passed in.

Arguments:

    lNumberOfSnapshots - The number of snapshots in the array
    pszSnapshotNameMultiSZ - A multi-SZ list of the snapshot names
    lpszPath - The path to the file
    lFlags   - The query flags to determine what the user desires to be returned
    lplpszPathArray - Upon return, the allocated array of path names
    lpdwPathCount   - Upon return, the number of paths in the array

Return Value:

    Win32 Error

Notes:

    None

--*/

{
    DWORD dwError;
    LPWSTR pPathMultiSZ;
    ULONG lPathSize;
    LPCWSTR pPathSplit;
    LPWSTR pPathCopy;
    LPWSTR pPathCopyStart;
    ULONG lPathFront, lPathBack;
    LPWSTR pSnapName = pszSnapshotNameMultiSZ;
    ULONG iCount;
    WIN32_FILE_ATTRIBUTE_DATA w32Attributes;
    FILETIME fModifiedTime;
    FILETIME fOriginalTime;

    // If the user only wants files that are different, we use the ModifiedTime field
    // to keep track of the last modified time so we can remove duplicates.  This field
    // is initialized to the current last-modified time of the file.  Since the snapshot
    // name array is passed back in newest-to-oldest format, we can simply compare the current
    // iteration to the previous one to determine if the file changed in the current snapshot
    // as we build the list
    if( lFlags & QUERY_SNAPSHOT_DIFFERENT )
    {
        fModifiedTime.dwHighDateTime = fModifiedTime.dwLowDateTime = 0;

        if( !GetFileAttributesEx( lpszPath, GetFileExInfoStandard, &w32Attributes ) )
        {
            return GetLastError();
        }

        fOriginalTime.dwHighDateTime = w32Attributes.ftLastWriteTime.dwHighDateTime;
        fOriginalTime.dwLowDateTime = w32Attributes.ftLastWriteTime.dwLowDateTime;
    }

    // Allocate the buffer to the maximum size we will need
    lPathSize = ((MAX_PREFIX_LENGTH+lstrlenW(lpszPath)+1+SNAPSHOT_NAME_LENGTH+1)*sizeof(WCHAR))*lNumberOfSnapshots + 2*sizeof(WCHAR);
    pPathMultiSZ = LocalAlloc( LPTR, lPathSize );
    if( pPathMultiSZ )
    {
        // For the path, we need to determine where the snapshot token will be inserted.  It will be
        // placed as far left in the name as possible, at the volume junction point.
        pPathSplit = FindSnapshotPathSplit( lpszPath );
        if( pPathSplit )
        {
            // Because we are inserting an extra segment into the path, it is
            // easy to start with a valid path that is less than MAX_PATH, but
            // end up with something greater than MAX_PATH. Therefore, we add
            // the "\\?\" or "\\?\UNC\" prefix to override the maximum length.
            LPCWSTR pPrefix = PREFIX_DRIVE;
            ULONG lPrefix;
            if (PathIsUNCW(lpszPath))
            {
                pPrefix = PREFIX_UNC;
                lpszPath += 2;  // skip backslashes
            }
            lPrefix = lstrlenW(pPrefix);

            pPathCopy = pPathMultiSZ;
            lPathBack = lstrlenW( pPathSplit );
            lPathFront = lstrlenW( lpszPath ) - lPathBack;

            // We now iterate through the snapshots and create the paths
            for( iCount=0; iCount<lNumberOfSnapshots; iCount++ )
            {
                BOOL bAcceptThisEntry = FALSE;

                pPathCopyStart = pPathCopy;

                // Copy the prefix
                RtlCopyMemory( pPathCopy, pPrefix, lPrefix*sizeof(WCHAR) );
                pPathCopy += lPrefix;

                // Copy the front portion of the path
                RtlCopyMemory( pPathCopy, lpszPath, lPathFront*sizeof(WCHAR) );
                pPathCopy += lPathFront;

                // Copy the seperator
                *pPathCopy++ = L'\\';

                // Copy the Snapshot name
                if (lstrlenW(pSnapName) < SNAPSHOT_NAME_LENGTH)
                {
                    LocalFree( pPathMultiSZ );
                    return ERROR_INVALID_PARAMETER;
                }
                RtlCopyMemory( pPathCopy, pSnapName, SNAPSHOT_NAME_LENGTH*sizeof(WCHAR) );
                pPathCopy += SNAPSHOT_NAME_LENGTH;

                // Copy the tail
                RtlCopyMemory( pPathCopy, pPathSplit, lPathBack*sizeof(WCHAR) );
                pPathCopy += lPathBack;

                // Copy the NULL
                *pPathCopy++ = L'\0';

                // A path is only included in the return result if it matches the users criteria
                if( lFlags & (QUERY_SNAPSHOT_EXISTING|QUERY_SNAPSHOT_DIFFERENT) )
                {
                    // If they just want Existing, we query the attributes to confirm that the file exists
                    if( GetFileAttributesEx( pPathCopyStart, GetFileExInfoStandard, &w32Attributes ) )
                    {
                        // If they want Different, we check the lastModifiedTime against the last iteration to
                        // determine acceptance
                        if( lFlags & QUERY_SNAPSHOT_DIFFERENT )
                        {
                            if( ((w32Attributes.ftLastWriteTime.dwHighDateTime != fModifiedTime.dwHighDateTime) ||
                                 (w32Attributes.ftLastWriteTime.dwLowDateTime != fModifiedTime.dwLowDateTime))   &&
                                ((w32Attributes.ftLastWriteTime.dwHighDateTime != fOriginalTime.dwHighDateTime) ||
                                 (w32Attributes.ftLastWriteTime.dwLowDateTime != fOriginalTime.dwLowDateTime))
                              )
                            {
                                // When we accept this entry, we update the LastModifiedTime for the next iteration
                                fModifiedTime.dwLowDateTime = w32Attributes.ftLastWriteTime.dwLowDateTime;
                                fModifiedTime.dwHighDateTime = w32Attributes.ftLastWriteTime.dwHighDateTime;
                                bAcceptThisEntry = TRUE;
                            }
                        }
                        else
                        {
                            bAcceptThisEntry = TRUE;
                        }
                    }
                }
                else
                {
                    bAcceptThisEntry = TRUE;
                }

                if (!bAcceptThisEntry)
                {
                    // Skip this entry and remove its reference
                    pPathCopy = pPathCopyStart;
                    lNumberOfSnapshots--;
                    iCount--;
                }

                // Move the Snapshot Name forward
                pSnapName += (SNAPSHOT_NAME_LENGTH + 1);
            }

            // Append the final NULL
            *pPathCopy = L'\0';

            *lplpszPathArray = pPathMultiSZ;
            *lpdwPathCount = lNumberOfSnapshots;
            dwError = ERROR_SUCCESS;
        }
        else
        {
            // The name was invalid, return the fact
            dwError = ERROR_INVALID_PARAMETER;
        }

        // If we're failing, free the buffer
        if( ERROR_SUCCESS != dwError )
        {
            LocalFree( pPathMultiSZ );
        }
    }
    else
    {
        // Our allocation failed.  Return the error
        dwError = ERROR_OUTOFMEMORY;
    }

    return dwError;
}

DWORD
QuerySnapshotsForPath(
    IN LPCWSTR lpszFilePath,
    IN DWORD dwQueryFlags,
    OUT LPWSTR* ppszPathMultiSZ,
    OUT LPDWORD iNumberOfPaths )
/*++

Routine Description:

    This function takes a path and returns an array of snapshot-paths to the file.
    (These are the paths to be passed to Win32 functions to obtain handles to the
    previous versions of the file)  This will be the only public export of the
    TimeWarp API

Arguments:

    lpszFilePath - The UNICODE path to the file or directory
    dwQueryFlags - See Notes below
    ppszPathMultiSZ - Upon successful return, the allocated array of the path
    iNumberOfPaths - Upon successful return, the number of paths returned


Return Value:

    Windows Error code

Notes:

    - The user is responsible for freeing the returned buffer with LocalFree
    - The possible flags are:

        Return only the path names where the file exists
        #define QUERY_SNAPSHOT_EXISTING     0x1

        Return the minimum set of paths to the different versions of the
        files.  (Does LastModifiedTime checking)
        #define QUERY_SNAPSHOT_DIFFERENT    0x2


--*/

{
    HANDLE hFile;
    DWORD dwError;
    LPWSTR pSnapshotNameArray = NULL;
    DWORD dwNumberOfSnapshots = 0;
    LPWSTR pSnapshotPathArray = NULL;
    DWORD dwSnapshotPathSize = 0;
    DWORD dwFinalSnapshoutCount = 0;

    ASSERT( lpszFilePath );

    dwError = OpenFileForSnapshot( lpszFilePath, &hFile );
    if( dwError == ERROR_SUCCESS )
    {
        // Get the array of names
        dwError = QuerySnapshotNames( hFile, &pSnapshotNameArray, &dwNumberOfSnapshots );
        if( dwError == ERROR_SUCCESS )
        {
            // Calculate the necessary string size
            if (dwNumberOfSnapshots > 0)
            {
                dwError = BuildSnapshotPathArray( dwNumberOfSnapshots, pSnapshotNameArray, lpszFilePath, dwQueryFlags, &pSnapshotPathArray, &dwFinalSnapshoutCount );
            }
            else
            {
                dwError = ERROR_NOT_FOUND;
            }

            if( dwError == ERROR_SUCCESS )
            {
                *ppszPathMultiSZ = pSnapshotPathArray;
                *iNumberOfPaths = dwFinalSnapshoutCount;
            }

            // Release the name array buffer
            LocalFree( pSnapshotNameArray );
            pSnapshotNameArray = NULL;
        }

        CloseHandle( hFile );
    }

    return dwError;
}

BOOLEAN
ExtractNumber(
    IN PCWSTR psz,
    IN ULONG Count,
    OUT CSHORT* value
    )
/*++

Routine Description:

    This function takes a string of characters and parses out a <Count> length decimal
    number.  If it returns TRUE, value has been set and the string was parsed correctly.
    FALSE indicates an error in parsing.

Arguments:

    psz - String pointer
    Count - Number of characters to pull off
    value - pointer to output parameter where value is stored

Return Value:

    BOOLEAN - See description

--*/
{
    *value = 0;

    while( Count )
    {
        if( (*psz == L'\0') ||
            (*psz == L'\\') )
        {
            return FALSE;
        }

        if( (*psz < '0') || (*psz > '9') )
        {
            return FALSE;
        }

        *value = (*value)*10+(*psz-L'0');
        Count--;
        psz++;
    }

    return TRUE;
}


DWORD
GetSnapshotTimeFromPath(
    IN LPCWSTR lpszFilePath,
    IN OUT FILETIME* pUTCTime
    )
{
    PCWSTR pszPath = lpszFilePath;
    TIME_FIELDS LocalTimeFields;
    CSHORT lValue;

    // Find the token
    pszPath = wcsstr( lpszFilePath, SNAPSHOT_MARKER );
    if( !pszPath )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Skip the GMT header
    pszPath += 5;

    // Pull the Year
    if( !ExtractNumber( pszPath, 4, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Year = lValue;
    pszPath += 4;

    // Skip the seperator
    if( *pszPath != L'.' )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszPath++;

    // Pull the Month
    if( !ExtractNumber( pszPath, 2, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Month = lValue;
    pszPath += 2;

    // Skip the seperator
    if( *pszPath != L'.' )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszPath++;


    // Pull the Day
    if( !ExtractNumber( pszPath, 2, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Day = lValue;
    pszPath += 2;

    // Skip the seperator
    if( *pszPath != L'-' )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszPath++;


    // Pull the Hour
    if( !ExtractNumber( pszPath, 2, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Hour = lValue;
    pszPath += 2;

    // Skip the seperator
    if( *pszPath != L'.' )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszPath++;


    // Pull the Minute
    if( !ExtractNumber( pszPath, 2, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Minute = lValue;
    pszPath += 2;

    // Skip the seperator
    if( *pszPath != L'.' )
    {
        return ERROR_INVALID_PARAMETER;
    }
    pszPath++;


    // Pull the Seconds
    if( !ExtractNumber( pszPath, 2, &lValue ) )
    {
        return ERROR_INVALID_PARAMETER;
    }
    LocalTimeFields.Second = lValue;
    pszPath += 2;

    // Make sure the seperator is there
    if( (*pszPath != L'\\') && (*pszPath != L'\0') )
    {
        return ERROR_INVALID_PARAMETER;
    }

    LocalTimeFields.Milliseconds = 0;
    LocalTimeFields.Weekday = 0;

    RtlTimeFieldsToTime( &LocalTimeFields, (LARGE_INTEGER*)pUTCTime );

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\twfldr.cpp ===
#include "precomp.hxx"
#pragma  hdrstop

#include <shguidp.h>    // CLSID_ShellFSFolder
#include <shellp.h>     // SHCoCreateInstance
#include <ccstock2.h>   // DataObj_GetHIDA, HIDA_ReleaseStgMedium
#include <varutil.h>    // VariantToBuffer
#include <stralign.h>   // WSTR_ALIGNED_STACK_COPY

#include "resource.h"
#include "timewarp.h"
#include "twfldr.h"
#include "contextmenu.h"
#include "util.h"

// {9DB7A13C-F208-4981-8353-73CC61AE2783}   CLSID_TimeWarpFolder
const CLSID CLSID_TimeWarpFolder = {0x9DB7A13C, 0xF208, 0x4981, {0x83, 0x53, 0x73, 0xCC, 0x61, 0xAE, 0x27, 0x83}};

const SHCOLUMNID SCID_DESCRIPTIONID = { PSGUID_SHELLDETAILS, PID_DESCRIPTIONID };


PCUIDTIMEWARP _IsValidTimeWarpID(PCUIDLIST_RELATIVE pidl)
{
    if (pidl && pidl->mkid.cb>=sizeof(IDTIMEWARP) && ((PUIDTIMEWARP)pidl)->wSignature == TIMEWARP_SIGNATURE)
        return (PCUIDTIMEWARP)pidl;
    return NULL;
}

HRESULT CTimeWarpRegFolder::CreateInstance(IUnknown* /*punkOuter*/, IUnknown **ppunk, LPCOBJECTINFO /*poi*/)
{
    HRESULT hr;

    *ppunk = NULL;

    CTimeWarpRegFolder *ptwf = new CTimeWarpRegFolder();
    if (ptwf)
    {
        hr = ptwf->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        ptwf->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CTimeWarpRegFolder::CTimeWarpRegFolder() : _cRef(1), _pmalloc(NULL), _pidl(NULL)
{
    DllAddRef();
}

CTimeWarpRegFolder::~CTimeWarpRegFolder()
{
    ATOMICRELEASE(_pmalloc);
    SHILFree((void*)_pidl); // const
    DllRelease();
}

STDMETHODIMP CTimeWarpRegFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CTimeWarpRegFolder, IDelegateFolder),
        QITABENT(CTimeWarpRegFolder, IShellFolder),
        QITABENTMULTI(CTimeWarpRegFolder, IPersist, IPersistFolder),
        QITABENT(CTimeWarpRegFolder, IPersistFolder),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CTimeWarpRegFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CTimeWarpRegFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IPersist methods
STDMETHODIMP CTimeWarpRegFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_TimeWarpFolder;
    return S_OK;
}

// IPersistFolder
HRESULT CTimeWarpRegFolder::Initialize(PCIDLIST_ABSOLUTE pidl)
{
    if (_pidl)
    {
        SHILFree((void*)_pidl); // const
        _pidl = NULL;
    }
    return pidl ? SHILCloneFull(pidl, &_pidl) : S_FALSE;
}

// IDelegateFolder
HRESULT CTimeWarpRegFolder::SetItemAlloc(IMalloc *pmalloc)
{
    IUnknown_Set((IUnknown**)&_pmalloc, pmalloc);
    return S_OK;
}

// IShellFolder
STDMETHODIMP CTimeWarpRegFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName, 
                                                  ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_UNEXPECTED;
    FILETIME ftSnapTime;

    TraceMsg(TF_TWREGFOLDER, "TimeWarp: parsing '%s'", pDisplayName);

    // We could easily support a non-delegate mode, but we are never
    // called that way, so there's no point.  This check just prevents
    // an AV below in the unlikely case that someone registers us
    // as a non-delegate (like we used to be).
    if (NULL == _pmalloc)
    {
        return E_UNEXPECTED;
    }

    // Do this first to ensure we have a time warp path
    DWORD dwErr = GetSnapshotTimeFromPath(pDisplayName, &ftSnapTime);
    if (ERROR_SUCCESS == dwErr)
    {
        // We only want to parse through the @GMT segment
        LPWSTR pszNext = wcsstr(pDisplayName, SNAPSHOT_MARKER);
        if (pszNext)
        {
            pszNext += SNAPSHOT_NAME_LENGTH;
            ASSERT(pszNext <= pDisplayName + lstrlenW(pDisplayName));
            ASSERT(*pszNext == L'\0' || *pszNext == L'\\');

            USHORT cchParse = (USHORT)(pszNext - pDisplayName);
            USHORT cbID = sizeof(IDTIMEWARP) - FIELD_OFFSET(IDTIMEWARP,wSignature) + cchParse*sizeof(WCHAR);

            ASSERT(NULL != _pmalloc);
            IDTIMEWARP *pid = (IDTIMEWARP*)_pmalloc->Alloc(cbID);
            if (pid)
            {
                ASSERT(pid->cbInner == cbID);
                pid->wSignature = TIMEWARP_SIGNATURE;
                pid->dwFlags = 0;
                pid->ftSnapTime = ftSnapTime;
                lstrcpynW(pid->wszPath, pDisplayName, cchParse+1);  // +1 to allow for NULL

                if (*pszNext != L'\0' && *(pszNext+1) != L'\0')
                {
                    // More to parse
                    IShellFolder *psfRight;

                    // skip the separator
                    ASSERT(*pszNext == L'\\');
                    pszNext++;
                    cchParse++;

                    // Bind to the child folder and ask it to parse the rest
                    hr = BindToObject((PCUIDLIST_RELATIVE)pid, pbc, IID_PPV_ARG(IShellFolder, &psfRight));
                    if (SUCCEEDED(hr))
                    {
                        PIDLIST_RELATIVE pidlRight;

                        hr = psfRight->ParseDisplayName(hwnd, pbc, pszNext, pchEaten, &pidlRight, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            *pchEaten += cchParse;
                            hr = SHILCombine((PCIDLIST_ABSOLUTE)pid, pidlRight, (PIDLIST_ABSOLUTE*)ppidl);
                            SHILFree(pidlRight);
                        }

                        psfRight->Release();
                    }

                    // Don't need this one anymore
                    SHFree(pid);
                }
                else
                {
                    // We're stopping here. Just return what we've got.
                    *pchEaten = cchParse;

                    if (pdwAttributes)
                    {
                        GetAttributesOf(1, (PCUITEMID_CHILD*)&pid, pdwAttributes);
                    }

                    *ppidl = (PIDLIST_RELATIVE)pid;
                    hr = S_OK;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

STDMETHODIMP CTimeWarpRegFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIdList)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTimeWarpRegFolder::BindToObject(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    PITEMID_CHILD pidlAlloc = NULL;
    BOOL bOneLevel = FALSE;

    *ppv = NULL;

    PCUIDLIST_RELATIVE pidlNext = ILGetNext(pidl);
    if (ILIsEmpty(pidlNext))
    {
        bOneLevel = TRUE;   // we know for sure it is one level
    }
    else
    {
        hr = SHILCloneFirst(pidl, &pidlAlloc);
        if (SUCCEEDED(hr))
        {
            pidl = (PCUIDLIST_RELATIVE)pidlAlloc;   // a single item IDLIST
        }
    }

    if (SUCCEEDED(hr))
    {
        if (bOneLevel)
        {
            hr = _CreateAndInit(pidl, pbc, riid, ppv);
        }
        else
        {
            IShellFolder *psfNext;
            hr = _CreateAndInit(pidl, pbc, IID_PPV_ARG(IShellFolder, &psfNext));
            if (SUCCEEDED(hr))
            {
                hr = psfNext->BindToObject(pidlNext, pbc, riid, ppv);
                psfNext->Release();
            }
        }
    }

    if (pidlAlloc)
        SHILFree(pidlAlloc);    // we allocated in this case

    return hr;
}

STDMETHODIMP CTimeWarpRegFolder::BindToStorage(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

// Copied from ILCompareRelIDs which has moved into shell\lib in lab06 (longhorn).
// This can be deleted in lab06.
HRESULT _CompareRelIDs(IShellFolder *psfParent, PCUIDLIST_RELATIVE pidl1, PCUIDLIST_RELATIVE pidl2, LPARAM lParam)
{
    HRESULT hr;
    PCUIDLIST_RELATIVE pidlRel1 = ILGetNext(pidl1);
    PCUIDLIST_RELATIVE pidlRel2 = ILGetNext(pidl2);
    if (ILIsEmpty(pidlRel1))
    {
        if (ILIsEmpty(pidlRel2))
            hr = ResultFromShort(0);
        else
            hr = ResultFromShort(-1);
    }
    else
    {
        if (ILIsEmpty(pidlRel2))
        {
            hr = ResultFromShort(1);
        }
        else
        {
            //
            // pidlRel1 and pidlRel2 point to something
            //  (1) Bind to the next level of the IShellFolder
            //  (2) Call its CompareIDs to let it compare the rest of IDs.
            //
            PITEMID_CHILD pidlNext;
            hr = SHILCloneFirst(pidl1, &pidlNext);    // pidl2 would work as well
            if (SUCCEEDED(hr))
            {
                IShellFolder *psfNext;
                hr = psfParent->BindToObject(pidlNext, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
                if (SUCCEEDED(hr))
                {
                    IShellFolder2 *psf2;
                    if (SUCCEEDED(psfNext->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
                    {
                        psf2->Release();    //  we can use the lParam
                    }
                    else
                    {
                        lParam = 0; //  cant use the lParam
                    }

                    // columns arent valid to pass down we just care about the flags param
                    hr = psfNext->CompareIDs((lParam & ~SHCIDS_COLUMNMASK), pidlRel1, pidlRel2);
                    psfNext->Release();
                }
                ILFree(pidlNext);
            }
        }
    }
    return hr;
}

STDMETHODIMP CTimeWarpRegFolder::CompareIDs(LPARAM lParam, PCUIDLIST_RELATIVE pidl1, PCUIDLIST_RELATIVE pidl2)
{
    PCUIDTIMEWARP pidTW1 = _IsValidTimeWarpID(pidl1);
    PCUIDTIMEWARP pidTW2 = _IsValidTimeWarpID(pidl2);

    if (!pidTW1 || !pidTW2)
        return E_INVALIDARG;

    int iResult = ualstrcmpiW(pidTW1->wszPath, pidTW2->wszPath);
    if (0 != iResult)
        return ResultFromShort(iResult);

    return _CompareRelIDs(SAFECAST(this, IShellFolder*), pidl1, pidl2, lParam);
}

STDMETHODIMP CTimeWarpRegFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CTimeWarpRegFolder::GetAttributesOf(UINT cidl, PCUITEMID_CHILD_ARRAY apidl, SFGAOF *rgfInOut)
{
    // Because of the limited way in which we're invoked, we know that all
    // child items are folders.  Furthermore, the TimeWarp space is read-only
    // so we always return the same set of attributes.
    *rgfInOut = SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_CANCOPY | SFGAO_READONLY;
    return S_OK;
}

STDMETHODIMP CTimeWarpRegFolder::GetUIObjectOf(HWND hwnd, UINT cidl, PCUITEMID_CHILD_ARRAY apidl, 
                                               REFIID riid, UINT *pRes, void **ppv)
{
    HRESULT hr = E_NOTIMPL;
    PCUIDTIMEWARP pidTW = cidl ? _IsValidTimeWarpID(apidl[0]) : NULL;

    ASSERT(!cidl || ILIsChild(apidl[0]));       // should be single level IDs only
    ASSERT(!cidl || pidTW);                     // should always be TimeWarp PIDLs

    if (pidTW && (IsEqualIID(riid, IID_IExtractIconW) || IsEqualIID(riid, IID_IExtractIconA)))
    {
        hr = _CreateDefExtIcon(pidTW, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu) && pidTW)
    {
        IQueryAssociations *pqa;
        HKEY aKeys[2] = {0};

        hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            // CLSID_ShellFSFolder = {F3364BA0-65B9-11CE-A9BA-00AA004AE837}
            hr = pqa->Init(ASSOCF_INIT_NOREMAPCLSID | ASSOCF_INIT_DEFAULTTOFOLDER, L"{F3364BA0-65B9-11CE-A9BA-00AA004AE837}", NULL, hwnd);
            if (SUCCEEDED(hr))
            {
                pqa->GetKey(0, ASSOCKEY_CLASS, NULL, &aKeys[0]);
                pqa->GetKey(0, ASSOCKEY_BASECLASS, NULL, &aKeys[1]);
            }
            pqa->Release();
        }
        hr = THR(CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, SAFECAST(this, IShellFolder*), ContextMenuCB, ARRAYSIZE(aKeys), aKeys, (IContextMenu**)ppv));

        for (int i = 0; i < ARRAYSIZE(aKeys); i++)
        {
            if (aKeys[i])
                RegCloseKey(aKeys[i]);
        }
    }
    else if (IsEqualIID(riid, IID_IDataObject) && cidl)
    {
        //hr = THR(SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject**)ppv));
        hr = THR(CIDLData_CreateFromIDArray(_pidl, cidl, (PCUIDLIST_RELATIVE_ARRAY)apidl, (IDataObject**)ppv));
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CTimeWarpRegFolder::GetDisplayNameOf(PCUITEMID_CHILD pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr;
    PCUIDTIMEWARP pidTW = _IsValidTimeWarpID(pidl);

    if (pidTW)
    {
        LPCWSTR pszPath;
        WSTR_ALIGNED_STACK_COPY(&pszPath, pidTW->wszPath);

        // If we aren't being asked for a friendly name, just use the path
        if ((uFlags & SHGDN_FORPARSING) && !(uFlags & SHGDN_FORADDRESSBAR))
        {
            pName->uType = STRRET_WSTR;
            hr = SHStrDup(pszPath, &pName->pOleStr);
        }
        else
        {
            PIDLIST_ABSOLUTE pidlTarget;

            // Ok, we're doing the friendly date thing. Start by getting the
            // target pidl without the GMT stamp.
            hr = GetFSIDListFromTimeWarpPath(&pidlTarget, pszPath);
            if (SUCCEEDED(hr))
            {
                WCHAR szName[MAX_PATH];

                // Get the name
                hr = SHGetNameAndFlagsW(pidlTarget, uFlags, szName, ARRAYSIZE(szName), NULL);
                if (SUCCEEDED(hr))
                {
                    ASSERT(!(uFlags & SHGDN_FORPARSING) || (uFlags & SHGDN_FORADDRESSBAR));

                    // Add the date string
                    pName->uType = STRRET_WSTR;
                    hr = FormatFriendlyDateName(&pName->pOleStr, szName, &pidTW->ftSnapTime);
                }
                SHILFree(pidlTarget);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return THR(hr);
}

STDMETHODIMP CTimeWarpRegFolder::SetNameOf(HWND hwnd, PCUITEMID_CHILD pidl, LPCOLESTR pName, SHGDNF uFlags, PITEMID_CHILD *ppidlOut)
{
    return E_NOTIMPL;
}

HRESULT CTimeWarpRegFolder::_CreateAndInit(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    PCUIDTIMEWARP pidTW = _IsValidTimeWarpID(pidl);

    ASSERT(ILIsChild(pidl));    // NULL is OK

    *ppv = NULL;

    if (pidTW)
    {
        // Can't do normal parsing, since it validates the path each step
        // of the way.  The @GMT element isn't enumerated in its parent dir,
        // so normal parsing fails there with ERROR_PATH_NOT_FOUND.
        //
        // Therefore, we can't let the FS folder parse the target path.
        // Instead, we create a simple pidl here and give it to him.
        PIDLIST_ABSOLUTE pidlTarget;

        LPCWSTR pszPath;
        WSTR_ALIGNED_STACK_COPY(&pszPath, pidTW->wszPath);

        hr = SimpleIDListFromAttributes(pszPath, FILE_ATTRIBUTE_DIRECTORY, &pidlTarget);
        if (SUCCEEDED(hr))
        {
            PIDLIST_ABSOLUTE pidlFull;
            hr = SHILCombine(_pidl, pidl, &pidlFull);
            if (SUCCEEDED(hr))
            {
                hr = CTimeWarpFolder::CreateInstance(CLSID_ShellFSFolder, pidlFull, pidlTarget, pszPath, &pidTW->ftSnapTime, riid, ppv);
                SHILFree(pidlFull);
            }
            SHILFree(pidlTarget);
        }
    }

    return hr;
}

HRESULT CTimeWarpRegFolder::_CreateDefExtIcon(PCUIDTIMEWARP pidTW, REFIID riid, void **ppv)
{
    // Truncation here isn't really a problem.  SHCreateFileExtractIcon
    // doesn't actually require the path to exist, so it succeeds anyway.
    // Worst case, you might see the wrong icon in the treeview.
    WCHAR szPath[MAX_PATH];
    ualstrcpynW(szPath, pidTW->wszPath, ARRAYSIZE(szPath));
    EliminateGMTPathSegment(szPath);
    return SHCreateFileExtractIconW(szPath, FILE_ATTRIBUTE_DIRECTORY, riid, ppv);
}

void _LaunchPropSheet(HWND hwnd, IDataObject *pdtobj)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        PCUIDTIMEWARP pidTW = _IsValidTimeWarpID(IDA_GetPIDLItem(pida, 0));
        if (pidTW)
        {
            PIDLIST_ABSOLUTE pidlTarget;

            LPCWSTR pszPath;
            WSTR_ALIGNED_STACK_COPY(&pszPath, pidTW->wszPath);

            HRESULT hr = GetFSIDListFromTimeWarpPath(&pidlTarget, pszPath);
            if (SUCCEEDED(hr))
            {
                SHELLEXECUTEINFOW sei =
                {
                    sizeof(sei),
                    SEE_MASK_INVOKEIDLIST,      // fMask
                    hwnd,                       // hwnd
                    L"properties",              // lpVerb
                    NULL,                       // lpFile
                    NULL,                       // lpParameters
                    NULL,                       // lpDirectory
                    SW_SHOWNORMAL,              // nShow
                    NULL,                       // hInstApp
                    pidlTarget,                 // lpIDList
                    NULL,                       // lpClass
                    0,                          // hkeyClass
                    0,                          // dwHotKey
                    NULL                        // hIcon
                };

                ShellExecuteEx(&sei);
                SHILFree(pidlTarget);
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
}

STDMETHODIMP CTimeWarpRegFolder::ContextMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        hr = S_OK;          // use default extension
        break;

    case DFM_INVOKECOMMANDEX:
        switch(wParam)
        {
        default:
            ASSERT(FALSE);
            hr = S_FALSE;   // do default
            break;

        case DFM_CMD_PROPERTIES:
            // Background properties
            _LaunchPropSheet(hwnd, pdtobj);
            hr = S_OK;
            break;
        }
        break;

    default:
        break;
    }

    return hr;
}


//
// Folder implementation aggregating the file system folder
//
STDMETHODIMP CTimeWarpFolder::CreateInstance(REFCLSID rclsid, PCIDLIST_ABSOLUTE pidlRoot, PCIDLIST_ABSOLUTE pidlTarget,
                                             LPCWSTR pszTargetPath, const FILETIME UNALIGNED *pftSnapTime,
                                             REFIID riid, void **ppv)
{
    HRESULT hr;
    CTimeWarpFolder *psf = new CTimeWarpFolder(pftSnapTime);
    if (psf)
    {
        hr = psf->_Init(rclsid, pidlRoot, pidlTarget, pszTargetPath);
        if (SUCCEEDED(hr))
        {
            hr = psf->QueryInterface(riid, ppv);
        }
        psf->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CTimeWarpFolder::CTimeWarpFolder(const FILETIME UNALIGNED *pftSnapTime) : _cRef(1), _ftSnapTime(*pftSnapTime),
    _punk(NULL), _psf(NULL), _psf2(NULL), _ppf3(NULL), _pidlRoot(NULL)
{
    DllAddRef();
}

CTimeWarpFolder::~CTimeWarpFolder()
{
    _cRef = 1000;  // deal with aggregation re-enter

    if (_punk)
    {
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder*), (IUnknown**)&_psf);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder*), (IUnknown**)&_psf2);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder*), (IUnknown**)&_ppf3);
        _punk->Release();
    }

    SHILFree((void*)_pidlRoot); // const

    DllRelease();
}

HRESULT CTimeWarpFolder::_Init(REFCLSID rclsid, PCIDLIST_ABSOLUTE pidlRoot, PCIDLIST_ABSOLUTE pidlTarget, LPCWSTR pszTargetPath)
{
    HRESULT hr = Initialize(pidlRoot);
    if (hr == S_OK)
    {
        // Aggregate the real folder object (usually CLSID_ShellFSFolder)
        hr = SHCoCreateInstance(NULL, &rclsid, SAFECAST(this, IShellFolder*), IID_PPV_ARG(IUnknown, &_punk));
        if (SUCCEEDED(hr))
        {
            hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder*), _punk, IID_PPV_ARG(IPersistFolder3, &_ppf3));
            if (SUCCEEDED(hr))
            {
                PERSIST_FOLDER_TARGET_INFO pfti;

                pfti.pidlTargetFolder = (PIDLIST_ABSOLUTE)pidlTarget;
                pfti.szNetworkProvider[0] = L'\0';
                pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
                pfti.csidl = -1;

                // We check the target path length in CTimeWarpFolder::_CreateAndInit.
                // If it's too big, we shouldn't get this far.
                ASSERT(lstrlenW(pszTargetPath) < ARRAYSIZE(pfti.szTargetParsingName));

                lstrcpynW(pfti.szTargetParsingName, pszTargetPath, ARRAYSIZE(pfti.szTargetParsingName));

                hr = _ppf3->InitializeEx(NULL, pidlRoot, &pfti);
            }
        }
    }
    return hr;
}

STDMETHODIMP CTimeWarpFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CTimeWarpFolder, IShellFolder, IShellFolder2),
        QITABENT(CTimeWarpFolder, IShellFolder2),
        QITABENTMULTI(CTimeWarpFolder, IPersist, IPersistFolder),
        QITABENT(CTimeWarpFolder, IPersistFolder),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && _punk)
        hr = _punk->QueryInterface(riid, ppv); // aggregated guy
    return hr;
}

STDMETHODIMP_ (ULONG) CTimeWarpFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CTimeWarpFolder::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IPersist
STDMETHODIMP CTimeWarpFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_TimeWarpFolder; //CLSID_ShellFSFolder?
    return S_OK;
}

// IPersistFolder
HRESULT CTimeWarpFolder::Initialize(PCIDLIST_ABSOLUTE pidl)
{
    if (_pidlRoot)
    {
        SHILFree((void*)_pidlRoot); // const
        _pidlRoot = NULL;
    }

    return pidl ? SHILCloneFull(pidl, &_pidlRoot) : S_FALSE;
}

HRESULT CTimeWarpFolder::_CreateAndInit(REFCLSID rclsid, PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    ASSERT(ILIsChild(pidl));    // NULL is OK

    *ppv = NULL;

    if (pidl && _ppf3)
    {
        PERSIST_FOLDER_TARGET_INFO targetInfo;

        hr = _ppf3->GetFolderTargetInfo(&targetInfo);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != _pidlRoot);

            // Concatenate pidl onto both _pidlRoot and targetInfo.pidlTargetFolder
            PIDLIST_ABSOLUTE pidlFull;
            hr = SHILCombine(_pidlRoot, pidl, &pidlFull);
            if (SUCCEEDED(hr))
            {
                PIDLIST_ABSOLUTE pidlTargetFull;
                hr = SHILCombine(targetInfo.pidlTargetFolder, pidl, &pidlTargetFull);
                if (SUCCEEDED(hr))
                {
                    LPWSTR pszName;

                    // Concatenate the child name onto targetInfo.szTargetParsingName
                    hr = DisplayNameOfAsOLESTR(this, ILMAKECHILD(pidl), SHGDN_INFOLDER | SHGDN_FORPARSING, &pszName);
                    if (SUCCEEDED(hr))
                    {
                        TraceMsg(TF_TWFOLDER, "TimeWarpFolder: binding to '%s'", pszName);

                        // IPersistFolder3 has a fixed path limit (MAX_PATH),
                        // which happens to be the same limit as PathAppend.
                        // Fail here if the name is too long.
                        COMPILETIME_ASSERT(ARRAYSIZE(targetInfo.szTargetParsingName) >= MAX_PATH);
                        if (PathAppend(targetInfo.szTargetParsingName, pszName))
                        {
                            hr = CTimeWarpFolder::CreateInstance(rclsid, pidlFull, pidlTargetFull, targetInfo.szTargetParsingName, &_ftSnapTime, riid, ppv);
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                        }
                        LocalFree(pszName);
                    }
                    SHILFree(pidlTargetFull);
                }
                SHILFree(pidlFull);
            }
            SHILFree(targetInfo.pidlTargetFolder);
        }
    }

    return hr;
}

// verify that _psf (aggregated file system folder) has been inited
HRESULT CTimeWarpFolder::_GetFolder()
{
    HRESULT hr = S_OK;
    if (_psf == NULL)
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder*), _punk, IID_PPV_ARG(IShellFolder, &_psf));
    return hr;
}

HRESULT CTimeWarpFolder::_GetFolder2()
{
    HRESULT hr = S_OK;
    if (_psf2 == NULL)
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder*), _punk, IID_PPV_ARG(IShellFolder2, &_psf2));
    return hr;
}

HRESULT CTimeWarpFolder::_GetClass(PCUITEMID_CHILD pidlChild, CLSID *pclsid)
{
    HRESULT hr;
    VARIANT varDID;

    hr = GetDetailsEx(pidlChild, &SCID_DESCRIPTIONID, &varDID);
    if (SUCCEEDED(hr))
    {
        SHDESCRIPTIONID did;

        if (VariantToBuffer(&varDID, &did, sizeof(did)))
        {
            // Ordinary directories (non-junctions) return GUID_NULL.
            if (SHDID_FS_DIRECTORY == did.dwDescriptionId && IsEqualGUID(did.clsid, GUID_NULL))
                *pclsid = CLSID_ShellFSFolder;
            else
                *pclsid = did.clsid;
        }
        else
        {
            hr = E_FAIL;
        }

        VariantClear(&varDID);
    }
    return hr;
}


STDMETHODIMP CTimeWarpFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName, 
                                               ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
    {
        hr = _psf->ParseDisplayName(hwnd, pbc, pDisplayName, pchEaten, ppidl, pdwAttributes);
        if (SUCCEEDED(hr) && pdwAttributes)
        {
            // Time Warp is a read-only namespace. Don't allow move, delete, etc.
            *pdwAttributes = (*pdwAttributes | SFGAO_READONLY) & ~(SFGAO_CANMOVE | SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_CANLINK);
        }
    }
    return hr;
}

STDMETHODIMP CTimeWarpFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIdList)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->EnumObjects(hwnd, grfFlags, ppEnumIdList);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::BindToObject(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    PCUITEMID_CHILD pidlChild = pidl;
    PITEMID_CHILD pidlAlloc = NULL;
    BOOL bOneLevel = FALSE;

    *ppv = NULL;

    PCUIDLIST_RELATIVE pidlNext = ILGetNext(pidl);
    if (ILIsEmpty(pidlNext))
    {
        bOneLevel = TRUE;   // we know for sure it is one level
    }
    else
    {
        hr = SHILCloneFirst(pidl, &pidlAlloc);
        if (SUCCEEDED(hr))
        {
            pidlChild = pidlAlloc;   // a single item IDLIST
        }
    }

    if (SUCCEEDED(hr))
    {
        CLSID clsid;

        // We might be at a junction to something other than FSFolder, e.g.
        // a ZIP or CAB folder, so get the CLSID of the child.

        hr = _GetClass(pidlChild, &clsid);
        if (SUCCEEDED(hr))
        {
            if (bOneLevel)
            {
                hr = _CreateAndInit(clsid, pidlChild, pbc, riid, ppv);
            }
            else
            {
                IShellFolder *psfNext;
                hr = _CreateAndInit(clsid, pidlChild, pbc, IID_PPV_ARG(IShellFolder, &psfNext));
                if (SUCCEEDED(hr))
                {
                    hr = psfNext->BindToObject(pidlNext, pbc, riid, ppv);
                    psfNext->Release();
                }
            }
        }

        if (FAILED(hr))
        {
            // Return an un-aggregated object
            if (SUCCEEDED(_GetFolder()))
            {
                hr = _psf->BindToObject(pidl, pbc, riid, ppv);
            }
        }
    }

    if (pidlAlloc)
        SHILFree(pidlAlloc);    // we allocated in this case

    return hr;
}

STDMETHODIMP CTimeWarpFolder::BindToStorage(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->BindToStorage(pidl, pbc, riid, ppv);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::CompareIDs(LPARAM lParam, PCUIDLIST_RELATIVE pidl1, PCUIDLIST_RELATIVE pidl2)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->CompareIDs(lParam, pidl1, pidl2);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IDropTarget))
    {
        // Drag/drop not allowed to a timewarp folder
        TraceMsg(TF_TWFOLDER, "TimeWarpFolder denying IDropTarget (CVO)");
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            hr = _psf->CreateViewObject(hwnd, riid, ppv);
            if (SUCCEEDED(hr) && IsEqualIID(riid, IID_IContextMenu))
            {
                // Wrap the background menu object so we can disable the New submenu
                void *pvWrap;
                if (SUCCEEDED(Create_ContextMenuWithoutPopups((IContextMenu*)*ppv, riid, &pvWrap)))
                {
                    ((IUnknown*)*ppv)->Release();
                    *ppv = pvWrap;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetAttributesOf(UINT cidl, PCUITEMID_CHILD_ARRAY apidl, SFGAOF *rgfInOut)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->GetAttributesOf(cidl, apidl, rgfInOut);

    // Time Warp is a read-only namespace. Don't allow move, delete, etc.
    *rgfInOut = (*rgfInOut | SFGAO_READONLY) & ~(SFGAO_CANMOVE | SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_CANLINK);

    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetUIObjectOf(HWND hwnd, UINT cidl, PCUITEMID_CHILD_ARRAY apidl, 
                                            REFIID riid, UINT *pRes, void **ppv)
{
    HRESULT hr = E_NOTIMPL;

    ASSERT(!cidl || ILIsChild(apidl[0]));       // should be single level IDs only

    if (IsEqualIID(riid, IID_IDropTarget))
    {
        TraceMsg(TF_TWFOLDER, "TimeWarpFolder denying IDropTarget (GUIOO)");
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            hr = _psf->GetUIObjectOf(hwnd, cidl, apidl, riid, pRes, ppv);

            if (SUCCEEDED(hr) && IsEqualIID(riid, IID_IContextMenu))
            {
                // Wrap the menu object so we can eliminate some commands
                void *pvWrap;
                if (SUCCEEDED(Create_ContextMenuWithoutVerbs((IContextMenu*)*ppv, L"pin;find", riid, &pvWrap)))
                {
                    ((IUnknown*)*ppv)->Release();
                    *ppv = pvWrap;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDisplayNameOf(PCUITEMID_CHILD pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
    {
        hr = _psf->GetDisplayNameOf(pidl, uFlags, pName);

        // If it's for the address bar, add the friendly date string
        if (SUCCEEDED(hr)&& (uFlags & SHGDN_FORADDRESSBAR))
        {
            WCHAR szName[MAX_PATH];

            // Note that this clears the STRRET
            hr = StrRetToBufW(pName, pidl, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                if (uFlags & SHGDN_FORPARSING)
                {
                    // Remove the GMT path segment in this case
                    EliminateGMTPathSegment(szName);
                }
                pName->uType = STRRET_WSTR;
                hr = FormatFriendlyDateName(&pName->pOleStr, szName, &_ftSnapTime);
            }
        }
    }
    return hr;
}

STDMETHODIMP CTimeWarpFolder::SetNameOf(HWND hwnd, PCUITEMID_CHILD pidl, LPCOLESTR pName, SHGDNF uFlags, PITEMID_CHILD *ppidlOut)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->SetNameOf(hwnd, pidl, pName, uFlags, ppidlOut);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDefaultSearchGUID(LPGUID lpGuid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultSearchGUID(lpGuid);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->EnumSearches(ppenum);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{    
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumnState(iColumn, pbState);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDetailsEx(PCUITEMID_CHILD pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsEx(pidl, pscid, pv);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::GetDetailsOf(PCUITEMID_CHILD pidl, UINT iColumn, LPSHELLDETAILS pDetail)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsOf(pidl, iColumn, pDetail);
    return hr;
}

STDMETHODIMP CTimeWarpFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->MapColumnToSCID(iCol, pscid);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Previous Versions property page"
#define VER_INTERNALNAME_STR            "twext"
#define VER_LEGALCOPYRIGHT_YEARS        "2001"
#define VER_ORIGINALFILENAME_STR        "twext.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\twprop.h ===
class CTimeWarpProp : public IShellExtInit,
                      public IShellPropSheetExt,
                      public IPreviousVersionsInfo
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // IShellExtInit
    STDMETHOD(Initialize)(PCIDLIST_ABSOLUTE pidlFolder, IDataObject *lpdobj, HKEY hkeyProgID);
    
    // IShellPropSheetExt
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IPreviousVersionsInfo
    STDMETHOD(AreSnapshotsAvailable)(LPCWSTR pszPath, BOOL fOkToBeSlow, BOOL *pfAvailable);

    static HRESULT CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

private:
    CTimeWarpProp();
    ~CTimeWarpProp();

    // dialog methods
    void    _OnInit(HWND hDlg);
    void    _OnRefresh();
    void    _OnSize();
    void    _UpdateButtons();
    void    _OnView();
    void    _OnCopy();
    void    _OnRevert();

    // helpers
    LPCWSTR _GetSelectedItemPath();
    LPWSTR  _MakeDoubleNullString(LPCWSTR psz, BOOL bAddWildcard);
    BOOL    _CopySnapShot(LPCWSTR pszSource, LPCWSTR pszDest, FILEOP_FLAGS foFlags);
    HRESULT _InvokeBFFDialog(LPWSTR pszDest, UINT cchDest);

    // Note that both of these can be TRUE at the same time, for example ZIP
    // and CAB are individual files represented as shell folders.
    BOOL    _IsFolder() { return (_fItemAttributes & SFGAO_FOLDER); }
    BOOL    _IsFile()   { return (_fItemAttributes & SFGAO_STREAM); }

    BOOL    _IsShortcut() { return (_fItemAttributes & SFGAO_LINK); }

    // callback methods
    static UINT CALLBACK PSPCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG    _cRef;
    LPWSTR  _pszPath;
    LPWSTR  _pszDisplayName;
    LPWSTR  _pszSnapList;
    int     _iIcon;
    HWND    _hDlg;
    HWND    _hList;
    SFGAOF  _fItemAttributes;   // SFGAO_ flags
};

extern const CLSID CLSID_TimeWarpProp;  // {596AB062-B4D2-4215-9F74-E9109B0A8153}

void InitSnapCheckCache(void);
void DestroySnapCheckCache(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\util.h ===
DWORD   FormatString(LPWSTR *ppszResult, HINSTANCE hInstance, LPCWSTR pszFormat, ...);
HRESULT FormatFriendlyDateName(LPWSTR *ppszResult, LPCWSTR pszName, const FILETIME UNALIGNED *pft, DWORD dwDateFlags = (FDTF_RELATIVE | FDTF_LONGDATE | FDTF_SHORTTIME));
void    EliminateGMTPathSegment(LPWSTR pszPath);
void    EliminatePathPrefix(LPWSTR pszPath);

HRESULT GetFSIDListFromTimeWarpPath(PIDLIST_ABSOLUTE *ppidlTarget, LPCWSTR pszPath, DWORD dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY);

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATAW *pfd, IBindCtx **ppbc);
STDAPI SHSimpleIDListFromFindData(LPCWSTR pszPath, const WIN32_FIND_DATAW *pfd, PIDLIST_ABSOLUTE *ppidl);
STDAPI SimpleIDListFromAttributes(LPCWSTR pszPath, DWORD dwAttributes, PIDLIST_ABSOLUTE *ppidl);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPWSTR *ppszResult, HINSTANCE hInstance, UINT idStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\twfldr.h ===
// Shell folder implementation for timewarp. The purpose of this object is
//      1) to prevent write actions (move, delete) from being attempted
//      2) to prevent upward navigation in the filesystem namespace 
//      3) to provide a friendly version of the date stamp as the folder name

// NOTE: This object aggregates the file system folder so we get away with a
// minimal set of interfaces on this object. The real file system folder does
// stuff like IPersistFolder2 for us.

extern const CLSID CLSID_TimeWarpFolder;// {9DB7A13C-F208-4981-8353-73CC61AE2783}

#define TIMEWARP_SIGNATURE  0x5754      // "TW" in the debugger

#pragma pack(1)
typedef struct _IDTIMEWARP
{
    // these memebers overlap DELEGATEITEMID struct
    // for our IDelegateFolder support
    WORD        cbSize;
    WORD        wOuter;
    WORD        cbInner;

    // Timewarp stuff
    WORD        wSignature;
    DWORD       dwFlags;    // currently unused
    FILETIME    ftSnapTime;
    WCHAR       wszPath[1]; // always room for at least NULL
} IDTIMEWARP;
typedef UNALIGNED IDTIMEWARP *PUIDTIMEWARP;
typedef const UNALIGNED IDTIMEWARP *PCUIDTIMEWARP;
#pragma pack()
 

class CTimeWarpRegFolder : public IPersistFolder,
                           public IDelegateFolder,
                           public IShellFolder
{
public:
    static HRESULT CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist, IPersistFreeThreadedObject
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(PCIDLIST_ABSOLUTE pidl);

    // IDelegateFolder
    STDMETHOD(SetItemAlloc)(IMalloc *pmalloc);
    
    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName,
                                ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList);
    STDMETHOD(BindToObject)(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, PCUIDLIST_RELATIVE pidl1, PCUIDLIST_RELATIVE pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, PCUITEMID_CHILD_ARRAY apidl, SFGAOF *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, PCUITEMID_CHILD_ARRAY apidl, REFIID riid, UINT *prgfInOut, void **ppv);
    STDMETHOD(GetDisplayNameOf)(PCUITEMID_CHILD pidl, DWORD uFlags, STRRET *pName);
    STDMETHOD(SetNameOf)(HWND hwnd, PCUITEMID_CHILD pidl, LPCOLESTR pszName, SHGDNF uFlags, PITEMID_CHILD *ppidlOut);

private:
    CTimeWarpRegFolder();
    ~CTimeWarpRegFolder();

    HRESULT _CreateAndInit(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _CreateDefExtIcon(PCUIDTIMEWARP pidTW, REFIID riid, void **ppv);

    static STDMETHODIMP ContextMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG                 _cRef;
    IMalloc *            _pmalloc;
    PIDLIST_ABSOLUTE     _pidl;         // copy of pidl passed to us in Initialize()
};

//
// Note that we don't need to override any of the IShellFolder2 methods, but
// we have to implement IShellFolder2 anyway.  Otherwise, a caller could QI
// for IShellFolder2, which would come from the aggregated CFSFolder code,
// and then call IShellFolder methods on it. Those calls would go directly
// to CFSFolder, bypassing our implementation of IShellFolder.
//
class CTimeWarpFolder : public IPersistFolder,
                        public IShellFolder2
{
public:
    static STDMETHODIMP CreateInstance(REFCLSID rclsid, PCIDLIST_ABSOLUTE pidlRoot, PCIDLIST_ABSOLUTE pidlTarget,
                                       LPCWSTR pszTargetPath, const FILETIME UNALIGNED *pftSnapTime,
                                       REFIID riid, void **ppv);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist, IPersistFreeThreadedObject
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(PCIDLIST_ABSOLUTE pidl);

    // IPersistFolder2, IPersistFolder3, etc are all implemented by 
    // the folder we aggregate, CFSFolder, so we don't want to implement them

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName,
                                ULONG *pchEaten, PIDLIST_RELATIVE *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList);
    STDMETHOD(BindToObject)(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, PCUIDLIST_RELATIVE pidl1, PCUIDLIST_RELATIVE pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, PCUITEMID_CHILD_ARRAY apidl, SFGAOF *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, PCUITEMID_CHILD_ARRAY apidl, REFIID riid, UINT *prgfInOut, void **ppv);
    STDMETHOD(GetDisplayNameOf)(PCUITEMID_CHILD pidl, DWORD uFlags, STRRET *pName);
    STDMETHOD(SetNameOf)(HWND hwnd, PCUITEMID_CHILD pidl, LPCOLESTR pszName, SHGDNF uFlags, PITEMID_CHILD *ppidlOut);

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(LPGUID lpGuid);
    STDMETHOD(EnumSearches)(LPENUMEXTRASEARCH *ppenum);
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState);
    STDMETHOD(GetDetailsEx(PCUITEMID_CHILD pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHOD(GetDetailsOf))(PCUITEMID_CHILD pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD(MapColumnToSCID)(UINT iCol, SHCOLUMNID *pscid);

private:
    CTimeWarpFolder(const FILETIME UNALIGNED *pftSnapTime);
    ~CTimeWarpFolder();

    HRESULT _Init(REFCLSID rclsid, PCIDLIST_ABSOLUTE pidlRoot, PCIDLIST_ABSOLUTE pidlTarget, LPCWSTR pszTargetPath);
    HRESULT _CreateAndInit(REFCLSID rclsid, PCUIDLIST_RELATIVE pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _GetFolder();
    HRESULT _GetFolder2();
    HRESULT _GetClass(PCUITEMID_CHILD pidlChild, CLSID *pclsid);

    LONG                _cRef;
    IUnknown *          _punk;          // points to IUnknown for shell folder in use...
    IShellFolder *      _psf;           // points to shell folder in use...
    IShellFolder2 *     _psf2;          // points to shell folder in use...
    IPersistFolder3 *   _ppf3;          // points to shell folder in use...
    PIDLIST_ABSOLUTE    _pidlRoot;      // copy of pidl passed to us in Initialize()
    FILETIME            _ftSnapTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\twprop.cpp ===
#include "precomp.hxx"
#pragma hdrstop

#include <ccstock2.h>   // DataObj_GetHIDA, IDA_ILClone, HIDA_ReleaseStgMedium 
#include <winnlsp.h>    // NORM_STOP_ON_NULL

#include "timewarp.h"
#include "twprop.h"
#include "util.h"
#include "resource.h"
#include "helpids.h"
#include "access.h"


// {596AB062-B4D2-4215-9F74-E9109B0A8153}   CLSID_TimeWarpProp
const CLSID CLSID_TimeWarpProp = {0x596AB062, 0xB4D2, 0x4215, {0x9F, 0x74, 0xE9, 0x10, 0x9B, 0x0A, 0x81, 0x53}};

WCHAR const c_szHelpFile[]          = L"twclient.hlp";
WCHAR const c_szChmPath[]           = L"%SystemRoot%\\Help\\twclient.chm";
WCHAR const c_szTimeWarpFolderID[]  = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\::{9DB7A13C-F208-4981-8353-73CC61AE2783},";
WCHAR const c_szCopyMoveTo_RegKey[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer";
WCHAR const c_szCopyMoveTo_SubKey[] = L"CopyMoveTo";
WCHAR const c_szCopyMoveTo_Value[]  = L"LastFolder";


// help IDs
const static DWORD rgdwTimeWarpPropHelp[] = 
{
    IDC_TWICON,         -1,
    IDC_TOPTEXT,        -1,
    IDC_LIST,           IDH_TIMEWARP_SNAPSHOTLIST,
    IDC_VIEW,           IDH_TIMEWARP_OPENSNAP,
    IDC_COPY,           IDH_TIMEWARP_SAVESNAP,
    IDC_REVERT,         IDH_TIMEWARP_RESTORESNAP,
    0, 0
};

static int CALLBACK BrowseCallback(HWND hDlg, UINT uMsg, LPARAM lParam, LPARAM pData);

// Simple accessibility wrapper class which concatenates accDescription onto accName
class CNameDescriptionAccessibleWrapper : public CAccessibleWrapper
{
public:
    CNameDescriptionAccessibleWrapper(IAccessible *pAcc, LPARAM) : CAccessibleWrapper(pAcc) {}

    STDMETHODIMP get_accName(VARIANT varChild, BSTR* pstrName);
};

static void SnapCheck_CacheResult(LPCWSTR pszPath, LPCWSTR pszShadowPath, BOOL bHasShadowCopy);
static BOOL SnapCheck_LookupResult(LPCWSTR pszPath, BOOL *pbHasShadowCopy);


HRESULT CTimeWarpProp::CreateInstance(IUnknown* /*punkOuter*/, IUnknown **ppunk, LPCOBJECTINFO /*poi*/)
{
    CTimeWarpProp* pmp = new CTimeWarpProp();
    if (pmp)
    {
        *ppunk = SAFECAST(pmp, IShellExtInit*);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

CTimeWarpProp::CTimeWarpProp() : _cRef(1), _hDlg(NULL), _hList(NULL),
    _pszPath(NULL), _pszDisplayName(NULL), _pszSnapList(NULL),
    _fItemAttributes(0)
{
    DllAddRef();
}

CTimeWarpProp::~CTimeWarpProp()
{
    LocalFree(_pszPath);    // NULL is OK
    LocalFree(_pszDisplayName);
    LocalFree(_pszSnapList);
    DllRelease();
}

STDMETHODIMP CTimeWarpProp::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CTimeWarpProp, IShellExtInit),
        QITABENT(CTimeWarpProp, IShellPropSheetExt),
        QITABENT(CTimeWarpProp, IPreviousVersionsInfo),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CTimeWarpProp::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CTimeWarpProp::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CTimeWarpProp::Initialize(PCIDLIST_ABSOLUTE /*pidlFolder*/, IDataObject *pdobj, HKEY /*hkey*/)
{
    HRESULT hr = E_FAIL;
    
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdobj, &medium);

    if (pida)
    {
        // Bail on multiple selection
        if (pida->cidl == 1)
        {
            // Bind to the parent folder
            IShellFolder *psf;
            hr = SHBindToObjectEx(NULL, IDA_GetPIDLFolder(pida), NULL, IID_IShellFolder, (void**)&psf);
            if (SUCCEEDED(hr))
            {
                PCUITEMID_CHILD pidlChild = IDA_GetPIDLItem(pida, 0);

                // Keep track of file vs folder
                _fItemAttributes = SFGAO_FOLDER | SFGAO_STREAM | SFGAO_LINK;
                hr = psf->GetAttributesOf(1, &pidlChild, &_fItemAttributes);
                if (SUCCEEDED(hr))
                {
                    WCHAR szTemp[MAX_PATH];

                    // For folder shortcuts, we use the target.
                    if (_IsFolder() && _IsShortcut())
                    {
                        IShellLink *psl;
                        hr = psf->BindToObject(pidlChild, NULL, IID_PPV_ARG(IShellLink, &psl));
                        if (SUCCEEDED(hr))
                        {
                            WIN32_FIND_DATA fd;
                            hr = psl->GetPath(szTemp, ARRAYSIZE(szTemp), &fd, SLGP_UNCPRIORITY);
                            psl->Release();
                        }
                    }
                    else
                    {
                        // Get the full path
                        hr = DisplayNameOf(psf, pidlChild, SHGDN_FORPARSING, szTemp, ARRAYSIZE(szTemp));
                    }
                    if (SUCCEEDED(hr))
                    {
                        // We only work with network paths.
                        if (PathIsNetworkPathW(szTemp) && !PathIsUNCServer(szTemp))
                        {
                            FILETIME ft;

                            // If this is already a snapshot path, bail. Otherwise
                            // we get into this weird recursive state where the
                            // snapshot paths have 2 GMT strings in them and the
                            // date is always the same (the first GMT string is
                            // identical for all of them).

                            if (NOERROR == GetSnapshotTimeFromPath(szTemp, &ft))
                            {
                                hr = E_FAIL;
                            }
                            else
                            {
                                // Remember the path
                                _pszPath = StrDup(szTemp);
                                if (NULL != _pszPath)
                                {
                                    // Get the display name (continue on failure here)
                                    if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_INFOLDER, szTemp, ARRAYSIZE(szTemp))))
                                    {
                                        _pszDisplayName = StrDup(szTemp);
                                    }

                                    // Get the system icon index
                                    _iIcon = SHMapPIDLToSystemImageListIndex(psf, pidlChild, NULL);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                }

                psf->Release();
            }
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return hr;
}

STDMETHODIMP CTimeWarpProp::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr = S_OK;

    if (NULL != _pszPath)
    {
        BOOL bSnapsAvailable = FALSE;

        // Are snapshots available on this server?
        if (S_OK == AreSnapshotsAvailable(_pszPath, TRUE, &bSnapsAvailable) && bSnapsAvailable)
        {
            PROPSHEETPAGE psp;
            psp.dwSize = sizeof(psp);
            psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK | PSP_HASHELP;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(_IsFolder() ? DLG_TIMEWARPPROP_FOLDER : DLG_TIMEWARPPROP_FILE);
            psp.pfnDlgProc = CTimeWarpProp::DlgProc;
            psp.pfnCallback = CTimeWarpProp::PSPCallback;
            psp.lParam = (LPARAM)this;

            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);
            if (hPage)
            {
                this->AddRef();
                
                if (!pfnAddPage(hPage, lParam))
                {
                    DestroyPropertySheetPage(hPage);
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CTimeWarpProp::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTimeWarpProp::AreSnapshotsAvailable(LPCWSTR pszPath, BOOL fOkToBeSlow, BOOL *pfAvailable)
{
    FILETIME ft;

    if (NULL == pfAvailable)
        return E_POINTER;

    // Default answer is No.
    *pfAvailable = FALSE;

    if (NULL == pszPath || L'\0' == *pszPath)
        return E_INVALIDARG;

    // It must be a network path, but can't be a snapshot path already.
    if (PathIsNetworkPathW(pszPath) && !PathIsUNCServerW(pszPath) &&
        NOERROR != GetSnapshotTimeFromPath(pszPath, &ft))
    {
        // Check the cache
        if (SnapCheck_LookupResult(pszPath, pfAvailable))
        {
            // nothing to do
        }
        else if (fOkToBeSlow)
        {
            LPWSTR pszSnapList = NULL;
            DWORD cSnaps;

            // Hit the net
            DWORD dwErr = QuerySnapshotsForPath(pszPath, 0, &pszSnapList, &cSnaps);
            if (NOERROR == dwErr && NULL != pszSnapList)
            {
                // Snapshots are available
                *pfAvailable = TRUE;
            }

            // Remember the result
            SnapCheck_CacheResult(pszPath, pszSnapList, *pfAvailable);

            LocalFree(pszSnapList);
        }
        else
        {
            // Tell caller to call again with fOkToBeSlow = TRUE
            return E_PENDING;
        }
    }

    return S_OK;
}

void CTimeWarpProp::_OnInit(HWND hDlg)
{ 
    _hDlg = hDlg;
    SendDlgItemMessage(hDlg, IDC_TWICON, STM_SETICON, (WPARAM)LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_TIMEWARP)), 0);

    // One-time listview initialization
    _hList = GetDlgItem(hDlg, IDC_LIST);
    if (NULL != _hList)
    {
        HIMAGELIST himlSmall;
        RECT rc;
        WCHAR szName[64];
        LVCOLUMN lvCol;

        ListView_SetExtendedListViewStyle(_hList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        Shell_GetImageLists(NULL, &himlSmall);
        ListView_SetImageList(_hList, himlSmall, LVSIL_SMALL);

        GetClientRect(_hList, &rc);

        lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.pszText = szName;

        LoadString(g_hInstance, IDS_NAMECOL, szName, ARRAYSIZE(szName));
        lvCol.cx = (rc.right / 3);
        lvCol.iSubItem = 0;
        ListView_InsertColumn(_hList, 0, &lvCol);

        LoadString(g_hInstance, IDS_DATECOL, szName, ARRAYSIZE(szName));
        lvCol.cx = rc.right - lvCol.cx;
        lvCol.iSubItem = 1;
        ListView_InsertColumn(_hList, 1, &lvCol);

        // Continue on failure here
        WrapAccessibleControl<CNameDescriptionAccessibleWrapper>(_hList);
    }

    // Query for snapshots and load the list
    _OnRefresh();
}

void CTimeWarpProp::_OnRefresh()
{
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (NULL != _hList)
    {
        DWORD cSnaps;

        // Start by emptying the list
        ListView_DeleteAllItems(_hList);

        // Free the old data
        LocalFree(_pszSnapList);
        _pszSnapList = NULL;

        // Hit the net
        ASSERT(NULL != _pszPath);
        DWORD dwErr = QuerySnapshotsForPath(_pszPath, _IsFile() ? QUERY_SNAPSHOT_DIFFERENT : QUERY_SNAPSHOT_EXISTING, &_pszSnapList, &cSnaps);

        // Fill the list
        if (NOERROR == dwErr && NULL != _pszSnapList)
        {
            UINT cItems = 0;
            LPCWSTR pszSnap;

            for (pszSnap = _pszSnapList; *pszSnap != L'\0'; pszSnap += lstrlenW(pszSnap)+1)
            {
                FILETIME ft;

                if (NOERROR == GetSnapshotTimeFromPath(pszSnap, &ft))
                {
                    LVITEM lvItem;
                    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                    lvItem.iItem = cItems;
                    lvItem.iSubItem = 0;
                    lvItem.pszText = _pszDisplayName ? _pszDisplayName : PathFindFileNameW(_pszPath);
                    lvItem.iImage = _iIcon;
                    lvItem.lParam = (LPARAM)pszSnap;

                    lvItem.iItem = ListView_InsertItem(_hList, &lvItem);
                    if (-1 != lvItem.iItem)
                    {
                        ++cItems;

                        WCHAR szDate[MAX_PATH];
                        DWORD dwDateFlags = FDTF_RELATIVE | FDTF_LONGDATE | FDTF_SHORTTIME;
                        SHFormatDateTime(&ft, &dwDateFlags, szDate, ARRAYSIZE(szDate));

                        lvItem.mask = LVIF_TEXT;
                        lvItem.iSubItem = 1;
                        lvItem.pszText = szDate;

                        ListView_SetItem(_hList, &lvItem);
                    }
                }
            }

            if (cItems != 0)
            {
                // Select the first item
                ListView_SetItemState(_hList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
    }

    _UpdateButtons();

    SetCursor(hcur);
}

void CTimeWarpProp::_OnSize()
{
    #define _MOVE_X         0x0001
    #define _MOVE_Y         0x0002
    #define _SIZE_WIDTH     0x0004
    #define _SIZE_HEIGHT    0x0008

    static const struct
    {
        int idCtrl;
        DWORD dwFlags;
    } rgControls[] =
    {
        { IDC_TOPTEXT,  _SIZE_WIDTH },
        { IDC_LIST,     _SIZE_WIDTH | _SIZE_HEIGHT },
        { IDC_VIEW,     _MOVE_X | _MOVE_Y },
        { IDC_COPY,     _MOVE_X | _MOVE_Y },
        { IDC_REVERT,   _MOVE_X | _MOVE_Y },
    };

    if (NULL != _hDlg)
    {
        RECT rcDlg;
        RECT rc;

        // Get the icon position (upper left ctrl) to find the margins
        GetWindowRect(GetDlgItem(_hDlg, IDC_TWICON), &rc);
        MapWindowPoints(NULL, _hDlg, (LPPOINT)&rc, 2);

        // Get the full dlg dimensions and adjust for margins
        GetClientRect(_hDlg, &rcDlg);
        rcDlg.right -= rc.left;
        rcDlg.bottom -= rc.top;

        // Get the Restore button pos (lower right ctrl) to calculate offsets
        GetWindowRect(GetDlgItem(_hDlg, IDC_REVERT), &rc);
        MapWindowPoints(NULL, _hDlg, (LPPOINT)&rc, 2);

        // This is how much things need to move or grow
        rcDlg.right -= rc.right;    // x-offset
        rcDlg.bottom -= rc.bottom;  // y-offset

        for (int i = 0; i < ARRAYSIZE(rgControls); i++)
        {
            HWND hwndCtrl = GetDlgItem(_hDlg, rgControls[i].idCtrl);
            GetWindowRect(hwndCtrl, &rc);
            MapWindowPoints(NULL, _hDlg, (LPPOINT)&rc, 2);
            rc.right -= rc.left;    // "width"
            rc.bottom -= rc.top;    // "height"

            if (rgControls[i].dwFlags & _MOVE_X)      rc.left   += rcDlg.right;
            if (rgControls[i].dwFlags & _MOVE_Y)      rc.top    += rcDlg.bottom;
            if (rgControls[i].dwFlags & _SIZE_WIDTH)  rc.right  += rcDlg.right;
            if (rgControls[i].dwFlags & _SIZE_HEIGHT) rc.bottom += rcDlg.bottom;

            MoveWindow(hwndCtrl, rc.left, rc.top, rc.right, rc.bottom, TRUE);
        }
    }
}

void CTimeWarpProp::_UpdateButtons()
{
    // Enable or disable the pushbuttons based on whether something
    // is selected in the listview

    BOOL bEnable = (NULL != _GetSelectedItemPath());

    for (int i = IDC_VIEW; i <= IDC_REVERT; i++)
    {
        HWND hwndCtrl = GetDlgItem(_hDlg, i);

        // If we're disabling the buttons, check for focus and move
        // focus to the listview if necessary.
        if (!bEnable && GetFocus() == hwndCtrl)
        {
            SetFocus(_hList);
        }

        EnableWindow(hwndCtrl, bEnable);
    }
}

void CTimeWarpProp::_OnView()
{
    LPCWSTR pszSnapShotPath = _GetSelectedItemPath();
    if (NULL != pszSnapShotPath)
    {
        // Test for existence.  QuerySnapshotsForPath already tested for
        // existence, but if the server has since gone down, or deleted
        // the snapshot, the resulting error message shown by ShellExecute
        // is quite ugly.
        if (-1 != GetFileAttributesW(pszSnapShotPath))
        {
            SHELLEXECUTEINFOW sei;
            LPWSTR pszPathAlloc = NULL;
            HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (_IsFolder())
            {
                const ULONG cchFolderID = ARRAYSIZE(c_szTimeWarpFolderID) - 1; // ARRAYSIZE counts '\0'
                ULONG cchFullPath = cchFolderID + lstrlen(pszSnapShotPath) + 1;
                pszPathAlloc = (LPWSTR)LocalAlloc(LPTR, cchFullPath*sizeof(WCHAR));
                if (pszPathAlloc)
                {
                    // "::{CLSID_NetworkPlaces}\\::{CLSID_TimeWarpFolder},\\server\share\@GMT\dir"
                    lstrcpynW(pszPathAlloc, c_szTimeWarpFolderID, cchFullPath);
                    lstrcpynW(pszPathAlloc + cchFolderID, pszSnapShotPath, cchFullPath - cchFolderID);
                    pszSnapShotPath = pszPathAlloc;
                }
                else
                {
                    // Low memory. Try to launch a normal file system folder
                    // (do nothing here).
                }
            }
            else if (SUCCEEDED(SHStrDup(pszSnapShotPath, &pszPathAlloc)))
            {
                pszSnapShotPath = pszPathAlloc;
            }

            if (pszPathAlloc)
            {
                // Some apps have problems with the "\\?\" prefix, including
                // the common dialog code.
                EliminatePathPrefix(pszPathAlloc);
            }

            sei.cbSize = sizeof(sei);
            sei.fMask = 0;
            sei.hwnd = _hDlg;
            sei.lpVerb = NULL;
            sei.lpFile = pszSnapShotPath;
            sei.lpParameters = NULL;
            sei.lpDirectory = NULL;
            sei.nShow = SW_SHOWNORMAL;

            ShellExecuteExW(&sei);

            LocalFree(pszPathAlloc);
            SetCursor(hcur);
        }
        else
        {
            // Show this error ourselves.  The ShellExecuteEx version is rather ugly.
            TraceMsg(TF_TWPROP, "Snapshot unavailable (%d)", GetLastError());
            ShellMessageBoxW(g_hInstance, _hDlg,
                             MAKEINTRESOURCE(_IsFolder() ? IDS_CANTFINDSNAPSHOT_FOLDER : IDS_CANTFINDSNAPSHOT_FILE),
                             MAKEINTRESOURCE(IDS_TIMEWARP_TITLE),
                             MB_ICONWARNING | MB_OK,
                             _pszDisplayName);
        }
    }
}

void CTimeWarpProp::_OnCopy()
{
    LPCWSTR pszSnapShotPath = _GetSelectedItemPath();
    if (NULL != pszSnapShotPath)
    {
        WCHAR szPath[2*MAX_PATH];

        // SHBrowseForFolder
        if (S_OK == _InvokeBFFDialog(szPath, ARRAYSIZE(szPath)))
        {
            int iCreateDirError = ERROR_ALREADY_EXISTS;

            //
            // If we're dealing with a folder, we have to be careful because
            // the GMT segment might be the last part of the source path.
            // If so, when SHFileOperation eventually passes this path to
            // FindFirstFile, it fails because no subfolder with that name
            // exists.  To get around this, we append a wildcard '*' to the
            // source path (see _CopySnapShot and _MakeDoubleNullString).
            //
            // But that means we also have to add _pszDisplayName to the
            // destination path and create that directory first, in order
            // to get the expected behavior from SHFileOperation.
            //
            // Note that if the directory contains files, we don't really need
            // to create the directory first, since SHFileOperation hits the
            // CopyMoveRetry code path in DoFile_Copy, which creates the parent
            // dir. But if there are only subdirs and no files, it goes through
            // EnterDir_Copy first, which fails without calling CopyMoveRetry.
            // (EnterDir_Move does the CopyMoveRetry thing, so this seems like
            // a bug in EnterDir_Copy, but normal shell operations never hit it.)
            //
            if (!_IsFile())
            {
                UINT idErrorString = 0;
                WCHAR szDriveLetter[2];
                LPCWSTR pszDirName = NULL;

                // Append the directory name.  Need to special case the root.
                if (PathIsRootW(_pszPath))
                {
                    if (PathIsUNCW(_pszPath))
                    {
                        ASSERT(PathIsUNCServerShareW(_pszPath));

                        pszDirName = wcschr(_pszPath+2, L'\\');
                        if (pszDirName)
                        {
                            ++pszDirName;
                        }
                        // else continue without a subdir
                        // (don't fall back on _pszDisplayName here)
                    }
                    else
                    {
                        szDriveLetter[0] = _pszPath[0];
                        szDriveLetter[1] = L'\0';
                        pszDirName = szDriveLetter;
                    }
                }
                else
                {
                    // Normal case
                    pszDirName = PathFindFileNameW(_pszPath);
                    if (!pszDirName)
                        pszDirName = _pszDisplayName;
                }
                if (pszDirName)
                {
                    // We could reduce szPath to MAX_PATH and use PathAppend here.
                    UINT cch = lstrlenW(szPath);
                    if (cch > 0 && szPath[cch-1] != L'\\')
                    {
                        if (cch+1 < ARRAYSIZE(szPath))
                        {
                            szPath[cch] = L'\\';
                            ++cch;
                        }
                        else
                        {
                            iCreateDirError = ERROR_FILENAME_EXCED_RANGE;
                        }
                    }
                    if (iCreateDirError != ERROR_FILENAME_EXCED_RANGE &&
                        cch + lstrlenW(pszDirName) < ARRAYSIZE(szPath))
                    {
                        lstrcpynW(&szPath[cch], pszDirName, ARRAYSIZE(szPath)-cch);
                    }
                    else
                    {
                        iCreateDirError = ERROR_FILENAME_EXCED_RANGE;
                    }
                }

                // Create the destination directory
                if (iCreateDirError != ERROR_FILENAME_EXCED_RANGE)
                {
                    iCreateDirError = SHCreateDirectory(_hDlg, szPath);
                }

                switch (iCreateDirError)
                {
                case ERROR_SUCCESS:
                    SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, NULL);
                    break;

                case ERROR_FILENAME_EXCED_RANGE:
                    idErrorString = IDS_ERROR_FILENAME_EXCED_RANGE;
                    break;

                case ERROR_ALREADY_EXISTS:
                    // We get this if there is an existing file or directory
                    // with the same name.
                    if (!(FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesW(szPath)))
                    {
                        // It's a file; show an error.
                        idErrorString = IDS_ERROR_FILE_EXISTS;
                    }
                    else
                    {
                        // It's a directory; continue normally.
                    }
                    break;

                default:
                    // For other errors, SHCreateDirectory shows a popup
                    // and returns ERROR_CANCELLED.
                    break;
                }

                if (0 != idErrorString)
                {
                    szPath[0] = L'\0';
                    LoadStringW(g_hInstance, idErrorString, szPath, ARRAYSIZE(szPath));
                    ShellMessageBoxW(g_hInstance, _hDlg,
                                     MAKEINTRESOURCE(IDS_CANNOTCREATEFOLDER),
                                     MAKEINTRESOURCE(IDS_TIMEWARP_TITLE),
                                     MB_ICONWARNING | MB_OK,
                                     pszDirName, szPath);
                    iCreateDirError = ERROR_CANCELLED;  // prevent copy below
                }
            }

            if (ERROR_SUCCESS == iCreateDirError || ERROR_ALREADY_EXISTS == iCreateDirError)
            {
                // OK, save now
                if (!_CopySnapShot(pszSnapShotPath, szPath, FOF_NOCONFIRMMKDIR))
                {
                    // SHFileOperation shows an error message if necessary

                    if (!_IsFile() && ERROR_SUCCESS == iCreateDirError)
                    {
                        // We created a folder above, so try to clean up now.
                        // This is best effort only.  Ignore failure.
                        if (RemoveDirectory(szPath))
                        {
                            SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, NULL);
                        }
                    }
                }
            }
        }
    }
}

void CTimeWarpProp::_OnRevert()
{
    LPCWSTR pszSnapShotPath = _GetSelectedItemPath();
    if (NULL != pszSnapShotPath)
    {
        // Confirm first
        if (IDYES == ShellMessageBoxW(g_hInstance, _hDlg,
                                      MAKEINTRESOURCE(_IsFolder() ? IDS_CONFIRM_REVERT_FOLDER : IDS_CONFIRM_REVERT_FILE),
                                      MAKEINTRESOURCE(IDS_TIMEWARP_TITLE),
                                      MB_ICONQUESTION | MB_YESNO))
        {
            LPCWSTR pszDest = _pszPath;
            LPWSTR pszAlloc = NULL;

            // There is a debate about whether to delete current files before
            // copying the old files over.  This mainly affects files that
            // were created after the snapshot that we are restoring.
            if (!_IsFile())
            {
#if 0
                SHFILEOPSTRUCTW fo;

                // First try to delete current folder contents, since files
                // may have been created after the snapshot was taken.

                ASSERT(NULL != _pszPath);

                fo.hwnd = _hDlg;
                fo.wFunc = FO_DELETE;
                fo.pFrom = _MakeDoubleNullString(_pszPath, TRUE);
                fo.pTo = NULL;
                fo.fFlags = FOF_NOCONFIRMATION;

                if (NULL != fo.pFrom)
                {
                    SHFileOperationW(&fo);
                    LocalFree((LPWSTR)fo.pFrom);
                }
#endif
            }
            else
            {
                // Remove the filename from the destination, otherwise
                // SHFileOperation tries to create a directory with that name.
                if (SUCCEEDED(SHStrDup(pszDest, &pszAlloc)))
                {
                    LPWSTR pszFile = PathFindFileNameW(pszAlloc);
                    if (pszFile)
                    {
                        *pszFile = L'\0';
                        pszDest = pszAlloc;
                    }
                }
            }

            // NTRAID#NTBUG9-497729-2001/11/27-jeffreys
            // Don't want 2 reverts happening at the same time
            EnableWindow(_hDlg, FALSE);

            // OK, copy the old version over
            if (_CopySnapShot(pszSnapShotPath, pszDest, FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR))
            {
                // QUERY_SNAPSHOT_DIFFERENT may return different
                // results now, so update the list.
                if (_IsFile())
                {
                    _OnRefresh();
                }

                // Let the user know we succeeded
                ShellMessageBoxW(g_hInstance, _hDlg,
                                 MAKEINTRESOURCE(_IsFolder() ? IDS_SUCCESS_REVERT_FOLDER : IDS_SUCCESS_REVERT_FILE),
                                 MAKEINTRESOURCE(IDS_TIMEWARP_TITLE),
                                 MB_ICONINFORMATION | MB_OK);
            }
            else
            {
                // SHFileOperation shows an error message if necessary
            }

            EnableWindow(_hDlg, TRUE);

            LocalFree(pszAlloc);
        }
    }
}

LPCWSTR CTimeWarpProp::_GetSelectedItemPath()
{
    if (NULL != _hList)
    {
        int iItem = ListView_GetNextItem(_hList, -1, LVNI_SELECTED);
        if (-1 != iItem)
        {
            LVITEM lvItem;
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = iItem;
            lvItem.iSubItem = 0;

            if (ListView_GetItem(_hList, &lvItem))
            {
                return (LPCWSTR)lvItem.lParam;
            }
        }
    }
    return NULL;
}

LPWSTR CTimeWarpProp::_MakeDoubleNullString(LPCWSTR psz, BOOL bAddWildcard)
{
    //
    // SHFileOperation eventually passes the source path to FindFirstFile.
    // If this path looks like "\\server\share\@GMT", this fails with
    // ERROR_PATH_NOT_FOUND.  We have to add a wildcard to the source
    // path to make SHFileOperation work.
    //
    int cch = lstrlenW(psz);
    int cchAlloc = cch + 2; // double-NULL
    if (bAddWildcard)
        cchAlloc += 2;      // "\\*"
    LPWSTR pszResult = (LPWSTR)LocalAlloc(LPTR, cchAlloc*sizeof(WCHAR));
    if (NULL != pszResult)
    {
        // Note that the buffer is zero-initialized, so it automatically
        // has a double-NULL at the end.
        CopyMemory(pszResult, psz, cch*sizeof(WCHAR));
        if (bAddWildcard)
        {
            if (cch > 0 && pszResult[cch-1] != L'\\')
            {
                pszResult[cch] = L'\\';
                ++cch;
            }
            pszResult[cch] = L'*';
        }
    }
    return pszResult;
}

BOOL CTimeWarpProp::_CopySnapShot(LPCWSTR pszSource, LPCWSTR pszDest, FILEOP_FLAGS foFlags)
{
    BOOL bResult = FALSE;
    SHFILEOPSTRUCTW fo;

    ASSERT(NULL != pszSource && L'\0' != *pszSource);
    ASSERT(NULL != pszDest && L'\0' != *pszDest);

    fo.hwnd = _hDlg;
    fo.wFunc = FO_COPY;
    fo.pFrom = _MakeDoubleNullString(pszSource, !_IsFile());
    fo.pTo = _MakeDoubleNullString(pszDest, FALSE);
    fo.fFlags = foFlags;
    fo.fAnyOperationsAborted = FALSE;

    if (NULL != fo.pFrom && NULL != fo.pTo)
    {
        TraceMsg(TF_TWPROP, "Copying from '%s'", fo.pFrom);
        TraceMsg(TF_TWPROP, "Copying to '%s'", fo.pTo);

        // NTRAID#NTBUG9-497725-2001/11/27-jeffreys
        // Cancelling usually results in a return value of ERROR_CANCELLED,
        // but if you cancel during the "Preparing to Copy" phase, SHFileOp
        // returns ERROR_SUCCESS.  Need to check fAnyOperationsAborted to
        // catch that case.

        bResult = !SHFileOperationW(&fo) && !fo.fAnyOperationsAborted;
    }

    LocalFree((LPWSTR)fo.pFrom);
    LocalFree((LPWSTR)fo.pTo);

    return bResult;
}

/**
 * Determines if the pidl still exists.  If it does not, if frees it
 * and replaces it with a My Documents pidl
 */
void _BFFSwitchToMyDocsIfPidlNotExist(PIDLIST_ABSOLUTE *ppidl)
{
    IShellFolder *psf;
    PCUITEMID_CHILD pidlChild;
    if (SUCCEEDED(SHBindToIDListParent(*ppidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        DWORD dwAttr = SFGAO_VALIDATE;
        if (FAILED(psf->GetAttributesOf(1, &pidlChild, &dwAttr)))
        {
            // This means the pidl no longer exists.  
            // Use my documents instead.
            PIDLIST_ABSOLUTE pidlMyDocs;
            if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidlMyDocs)))
            {
                // Good.  Now we can get rid of the old pidl and use this one.
                SHILFree(*ppidl);
                *ppidl = pidlMyDocs;
            }
        }
        psf->Release();
    }
}

HRESULT CTimeWarpProp::_InvokeBFFDialog(LPWSTR pszDest, UINT cchDest)
{
    HRESULT hr;
    BROWSEINFOW bi;
    LPWSTR pszTitle = NULL;
    HKEY hkey = NULL;
    IStream *pstrm = NULL;
    PIDLIST_ABSOLUTE pidlSelectedFolder = NULL;
    PIDLIST_ABSOLUTE pidlTarget = NULL;

    // "Select the place where you want to copy '%1'. Then click the Copy button."
    if (!FormatString(&pszTitle, g_hInstance, MAKEINTRESOURCE(IDS_BROWSE_INTRO_COPY), _pszDisplayName))
    {
        // "Select the place where you want to copy the selected item(s). Then click the Copy button."
        LoadStringAlloc(&pszTitle, g_hInstance, IDS_BROWSE_INTRO_COPY2);
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szCopyMoveTo_RegKey, 0, KEY_READ | KEY_WRITE, &hkey) == ERROR_SUCCESS)
    {
        pstrm = OpenRegStream(hkey, c_szCopyMoveTo_SubKey, c_szCopyMoveTo_Value, STGM_READWRITE);
        if (pstrm)  // OpenRegStream will fail if the reg key is empty.
            ILLoadFromStream(pstrm, (PIDLIST_RELATIVE*)&pidlSelectedFolder);

        // This will switch the pidl to My Docs if the pidl does not exist.
        // This prevents us from having My Computer as the default (that's what happens if our
        // initial set selected call fails).
        // Note: ideally, we would check in BFFM_INITIALIZED, if our BFFM_SETSELECTION failed
        // then do a BFFM_SETSELECTION on My Documents instead.  However, BFFM_SETSELECTION always
        // returns zero (it's doc'd to do this to, so we can't change).  So we do the validation
        // here instead.  There is still a small chance that this folder will be deleted in between our
        // check here, and when we call BFFM_SETSELECTION, but oh well.
        _BFFSwitchToMyDocsIfPidlNotExist(&pidlSelectedFolder);
    }

    bi.hwndOwner = _hDlg;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle = pszTitle;
    bi.ulFlags = BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS | BIF_VALIDATE | BIF_UAHINT /* | BIF_NOTRANSLATETARGETS*/;
    bi.lpfn = BrowseCallback;
    bi.lParam = (LPARAM)pidlSelectedFolder;
    bi.iImage = 0;

    pidlTarget = (PIDLIST_ABSOLUTE)SHBrowseForFolder(&bi);
    if (pidlTarget)
    {
        hr = SHGetNameAndFlagsW(pidlTarget, SHGDN_FORPARSING, pszDest, cchDest, NULL);
    }
    else
    {
        // Either user cancelled, or failure. Doesn't matter.
        hr = S_FALSE;
    }

    if (pstrm)
    {
        if (S_OK == hr && !PathIsNetworkPathW(pszDest))
        {
            LARGE_INTEGER li0 = {0};
            ULARGE_INTEGER uli;

            // rewind the stream to the beginning so that when we
            // add a new pidl it does not get appended to the first one
            pstrm->Seek(li0, STREAM_SEEK_SET, &uli);
            ILSaveToStream(pstrm, pidlTarget);
        }
        pstrm->Release();
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    SHILFree(pidlTarget);
    SHILFree(pidlSelectedFolder);
    LocalFree(pszTitle);

    return hr;
}

UINT CALLBACK CTimeWarpProp::PSPCallback(HWND /*hDlg*/, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg) 
    {
    case PSPCB_RELEASE:
        ((CTimeWarpProp*)ppsp->lParam)->Release();
        break;
    }

    return 1;
}

INT_PTR CALLBACK CTimeWarpProp::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTimeWarpProp *ptwp = (CTimeWarpProp*)GetWindowLongPtr(hDlg, DWLP_USER); 
    
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *pPropSheetPage = (PROPSHEETPAGE*)lParam;
        if (pPropSheetPage)
        {
            ptwp = (CTimeWarpProp*) pPropSheetPage->lParam;
            if (ptwp)
            {
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)ptwp);
                ptwp->_OnInit(hDlg);
                return 1;
            }
        } 
    }
    else if (ptwp)
    {
        switch (uMsg)
        {
        case WM_DESTROY:
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
            return 1;
            
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_REVERT:
                ptwp->_OnRevert();
                return 1;
                
            case IDC_VIEW:
                ptwp->_OnView();
                return 1;
                
            case IDC_COPY:
                ptwp->_OnCopy();
                return 1;
            }
            break;
            
        case WM_NOTIFY:
            {
                NMHDR *pnmh = (NMHDR*)lParam;

                switch (pnmh->code)
                {
                case NM_DBLCLK:
                    if (IDC_LIST == pnmh->idFrom)
                    {
                        ptwp->_OnView();
                    }
                    break;

                case LVN_ITEMCHANGED:
                    if (IDC_LIST == pnmh->idFrom)
                    {
                        NMLISTVIEW *pnmlv = (NMLISTVIEW*)lParam;
                        if (pnmlv->uChanged & LVIF_STATE)
                        {
                            ptwp->_UpdateButtons();
                        }
                    }
                    break;

                case PSN_TRANSLATEACCELERATOR:
                    {
                        MSG *pMsg = (MSG*)(((PSHNOTIFY*)lParam)->lParam);
                        if (WM_KEYUP == pMsg->message && VK_F5 == pMsg->wParam)
                        {
                            ptwp->_OnRefresh();
                        }
                    }
                    break;

                case PSN_HELP:
                    {
                        SHELLEXECUTEINFOW sei;
                        sei.cbSize = sizeof(sei);
                        sei.fMask = SEE_MASK_DOENVSUBST;
                        sei.hwnd = hDlg;
                        sei.lpVerb = NULL;
                        sei.lpFile = c_szChmPath;
                        sei.lpParameters = NULL;
                        sei.lpDirectory = NULL;
                        sei.nShow = SW_SHOWNORMAL;
                        ShellExecuteExW(&sei);
                    }
                    break;
                }
            }
            break;

        case WM_SIZE:
            ptwp->_OnSize();
            break;

        case WM_HELP:               /* F1 or title-bar help button */
            WinHelpW((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile, HELP_WM_HELP, (DWORD_PTR)rgdwTimeWarpPropHelp);
            break;
            
        case WM_CONTEXTMENU:        /* right mouse click */
            WinHelpW((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)rgdwTimeWarpPropHelp);
            break;
        }
    }
    return 0;
}

int CALLBACK BrowseCallback(HWND hDlg, UINT uMsg, LPARAM lParam, LPARAM pData)
{
    if (BFFM_INITIALIZED == uMsg)
    {
        // Set the caption ("Copy Items")
        TCHAR szTemp[100];
        if (LoadString(g_hInstance, IDS_BROWSE_TITLE_COPY, szTemp, ARRAYSIZE(szTemp)))
        {
            SetWindowText(hDlg, szTemp);
        }

        // Set the text of the Ok Button ("Copy")
        if (LoadString(g_hInstance, IDS_COPY, szTemp, ARRAYSIZE(szTemp)))  // 0x1031 in shell32
        {
            SendMessage(hDlg, BFFM_SETOKTEXT, 0, (LPARAM)szTemp);
        }

        // Set My Computer expanded
        PIDLIST_ABSOLUTE pidlMyComputer;
        HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
        if (SUCCEEDED(hr))
        {
            SendMessage(hDlg, BFFM_SETEXPANDED, FALSE, (LPARAM)pidlMyComputer);
            SHILFree(pidlMyComputer);
        }

        // Set the default selected pidl
        SendMessage(hDlg, BFFM_SETSELECTION, FALSE, pData);
    }
    return 0;
}


//
// Because the Name is the same for each entry in the listview, we have to
// expose more info in accName to make this usable in accessibility scenarios,
// e.g. to a screen reader.  We override get_accName and concatenate accDescription
// onto the name.
//
STDMETHODIMP CNameDescriptionAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pstrName)
{
    // Call the base class first in all cases.

    HRESULT hr = CAccessibleWrapper::get_accName(varChild, pstrName);

    // varChild.lVal specifies which sub-part of the component is being queried.
    // CHILDID_SELF (0) specifies the overall component - other values specify a child.

    if (SUCCEEDED(hr) && varChild.vt == VT_I4 && varChild.lVal != CHILDID_SELF)
    {
        BSTR strDescription = NULL;

        // Get accDescription and concatenate onto accName
        //
        // If anything fails, we return the result from above

        if (SUCCEEDED(CAccessibleWrapper::get_accDescription(varChild, &strDescription)))
        {
            LPWSTR pszNewName = NULL;

            if (FormatString(&pszNewName, g_hInstance, MAKEINTRESOURCE(IDS_ACCNAME_FORMAT), *pstrName, strDescription))
            {
                BSTR strNewName = SysAllocString(pszNewName);
                if (strNewName)
                {
                    SysFreeString(*pstrName);
                    *pstrName = strNewName;
                }
                LocalFree(pszNewName);
            }
            SysFreeString(strDescription);
        }
    }

    return hr;
}

extern "C"
LPCWSTR FindSnapshotPathSplit(LPCWSTR lpszPath);    // timewarp.c

typedef struct
{
    BOOL  bHasShadowCopy;
    DWORD dwCacheTime;
    ULONG cchPath;
    WCHAR szPath[1];
} SNAPCHECK_CACHE_ENTRY;

// 5 minutes
#define _CACHE_AGE_LIMIT     (5*60*1000)

CRITICAL_SECTION g_csSnapCheckCache;
HDPA g_dpaSnapCheckCache = NULL;

int CALLBACK _LocalFreeCallback(void *p, void*)
{
    // OK to pass NULL to LocalFree
    LocalFree(p);
    return 1;
}

void InitSnapCheckCache(void)
{
    InitializeCriticalSection(&g_csSnapCheckCache);
}

void DestroySnapCheckCache(void)
{
    if (NULL != g_dpaSnapCheckCache)
    {
        DPA_DestroyCallback(g_dpaSnapCheckCache, _LocalFreeCallback, 0);
    }
    DeleteCriticalSection(&g_csSnapCheckCache);
}

static int CALLBACK _CompareServerEntries(void *p1, void *p2, LPARAM lParam)
{
    int nResult;
    SNAPCHECK_CACHE_ENTRY *pEntry1 = (SNAPCHECK_CACHE_ENTRY*)p1;
    SNAPCHECK_CACHE_ENTRY *pEntry2 = (SNAPCHECK_CACHE_ENTRY*)p2;
    BOOL *pbExact = (BOOL*)lParam;

    ASSERT(NULL != pEntry1);
    ASSERT(NULL != pEntry2);
    ASSERT(NULL != pbExact);

    nResult = CompareString(LOCALE_SYSTEM_DEFAULT, SORT_STRINGSORT | NORM_IGNORECASE | NORM_STOP_ON_NULL,
                            pEntry1->szPath, pEntry1->cchPath,
                            pEntry2->szPath, pEntry2->cchPath) - CSTR_EQUAL;
    if (0 == nResult)
    {
        *pbExact = TRUE;
    }

    return nResult;
}

static void SnapCheck_CacheResult(LPCWSTR pszPath, LPCWSTR pszShadowPath, BOOL bHasShadowCopy)
{
    LPWSTR pszServer = NULL;

    if (bHasShadowCopy)
    {
        // Use the shadow path instead
        ASSERT(NULL != pszShadowPath);
        pszPath = pszShadowPath;
    }

    if (SUCCEEDED(SHStrDup(pszPath, &pszServer)))
    {
        // FindSnapshotPathSplit hits the net, so try to avoid it.
        LPWSTR pszTail = bHasShadowCopy ? wcsstr(pszServer, SNAPSHOT_MARKER) : (LPWSTR)FindSnapshotPathSplit(pszServer);
        if (pszTail)
        {
            *pszTail = L'\0';
        }
        EliminatePathPrefix(pszServer);
        PathRemoveBackslashW(pszServer);

        int cchServer = lstrlen(pszServer);
        SNAPCHECK_CACHE_ENTRY *pEntry = (SNAPCHECK_CACHE_ENTRY*)LocalAlloc(LPTR, sizeof(SNAPCHECK_CACHE_ENTRY) + sizeof(WCHAR)*cchServer);
        if (pEntry)
        {
            pEntry->bHasShadowCopy = bHasShadowCopy;
            pEntry->cchPath = cchServer;
            lstrcpynW(pEntry->szPath, pszServer, cchServer+1);

            EnterCriticalSection(&g_csSnapCheckCache);

            if (NULL == g_dpaSnapCheckCache)
            {
                // This ref is not balanced.  This causes us to remain loaded
                // until the process terminates, so the cache isn't deleted
                // prematurely (i.e. if AlwaysUnloadDlls is set).
                DllAddRef();
                g_dpaSnapCheckCache = DPA_Create(4);
            }

            if (NULL != g_dpaSnapCheckCache)
            {
                pEntry->dwCacheTime = GetTickCount();

                BOOL bExact = FALSE;
                int iIndex = DPA_Search(g_dpaSnapCheckCache, pEntry, 0, _CompareServerEntries, (LPARAM)&bExact, DPAS_SORTED | DPAS_INSERTBEFORE);
                if (bExact)
                {
                    // Found a duplicate. Replace it.
                    SNAPCHECK_CACHE_ENTRY *pOldEntry = (SNAPCHECK_CACHE_ENTRY*)DPA_FastGetPtr(g_dpaSnapCheckCache, iIndex);
                    DPA_SetPtr(g_dpaSnapCheckCache, iIndex, pEntry);
                    LocalFree(pOldEntry);
                }
                else if (-1 == DPA_InsertPtr(g_dpaSnapCheckCache, iIndex, pEntry))
                {
                    LocalFree(pEntry);
                }
            }
            else
            {
                LocalFree(pEntry);
            }

            LeaveCriticalSection(&g_csSnapCheckCache);
        }

        LocalFree(pszServer);
    }
}

static int CALLBACK _SearchServerEntries(void *p1, void *p2, LPARAM lParam)
{
    int nResult = 0;
    LPCWSTR pszFind = (LPCWSTR)p1;
    ULONG cchFind = (ULONG)lParam;
    SNAPCHECK_CACHE_ENTRY *pEntry = (SNAPCHECK_CACHE_ENTRY*)p2;

    ASSERT(NULL != pszFind);
    ASSERT(NULL != pEntry);

    // Compare the first pEntry->cchPath chars of both strings
    nResult = CompareString(LOCALE_SYSTEM_DEFAULT, SORT_STRINGSORT | NORM_IGNORECASE | NORM_STOP_ON_NULL,
                            pszFind, pEntry->cchPath,
                            pEntry->szPath, pEntry->cchPath) - CSTR_EQUAL;
    if (0 == nResult)
    {
        //
        // Check whether pszFind is longer than pEntry->szPath, but allow
        // extra path segments in pszFind.
        //
        // For example, if
        //      pEntry->szPath = "\\server\share"
        //      pszFind        = "\\server\share2"
        // then we don't have a match.  But if
        //      pEntry->szPath = "\\server\share"
        //      pszFind        = "\\server\share\dir"
        // the we DO have a match.
        //
        // Also, at the root of a mapped drive, pEntry->szPath includes
        // a trailing backslash, so we may have this:
        //      pEntry->szPath = "X:\"
        //      pszFind        = "X:\dir"
        // which we consider to be a match.
        //
        if (cchFind > pEntry->cchPath && pszFind[pEntry->cchPath] != L'\\'
            && (PathIsUNCW(pEntry->szPath) || !PathIsRootW(pEntry->szPath)))
        {
            ASSERT(pszFind[pEntry->cchPath] != L'\0'); // otherwise, cchFind == pEntry->cchPath and we don't get here
            nResult = 1;
        }
    }

    return nResult;
}

static BOOL SnapCheck_LookupResult(LPCWSTR pszPath, BOOL *pbHasShadowCopy)
{
    BOOL bFound = FALSE;

    *pbHasShadowCopy = FALSE;

    if (NULL == g_dpaSnapCheckCache)
        return FALSE;

    EnterCriticalSection(&g_csSnapCheckCache);

    int iIndex = DPA_Search(g_dpaSnapCheckCache, (void*)pszPath, 0, _SearchServerEntries, lstrlenW(pszPath), DPAS_SORTED);
    if (-1 != iIndex)
    {
        // Found a match
        SNAPCHECK_CACHE_ENTRY *pEntry = (SNAPCHECK_CACHE_ENTRY*)DPA_FastGetPtr(g_dpaSnapCheckCache, iIndex);

        DWORD dwCurrentTime = GetTickCount();
        if (dwCurrentTime > pEntry->dwCacheTime && dwCurrentTime - pEntry->dwCacheTime < _CACHE_AGE_LIMIT)
        {
            *pbHasShadowCopy = pEntry->bHasShadowCopy;
            bFound = TRUE;
        }
        else
        {
            // The entry has aged out
            DPA_DeletePtr(g_dpaSnapCheckCache, iIndex);
            LocalFree(pEntry);
        }
    }

    LeaveCriticalSection(&g_csSnapCheckCache);

    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\timewarp\util.cpp ===
#include "precomp.hxx"
#pragma  hdrstop

#include <winnlsp.h>    // NORM_STOP_ON_NULL

#include "resource.h"
#include "timewarp.h"
#include "util.h"


DWORD FormatString(LPWSTR *ppszResult, HINSTANCE hInstance, LPCWSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    LPWSTR pszFormatAlloc = NULL;

    if (IS_INTRESOURCE(pszFormat))
    {
        if (LoadStringAlloc(&pszFormatAlloc, hInstance, PtrToUlong(pszFormat)))
        {
            pszFormat = pszFormatAlloc;
        }
        else
        {
            return 0;
        }
    }

    va_start(args, pszFormat);
    dwResult = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                              pszFormat,
                              0,
                              0,
                              (LPWSTR)ppszResult,
                              1,
                              &args);
    va_end(args);

    LocalFree(pszFormatAlloc);

    return dwResult;
}

HRESULT FormatFriendlyDateName(LPWSTR *ppszResult, LPCWSTR pszName, const FILETIME UNALIGNED *pft, DWORD dwDateFlags)
{
    WCHAR szDate[MAX_PATH];

    SHFormatDateTime(pft, &dwDateFlags, szDate, ARRAYSIZE(szDate));

    if (!FormatString(ppszResult, g_hInstance, MAKEINTRESOURCE(IDS_FOLDER_TITLE_FORMAT), pszName, szDate))
    {
        DWORD dwErr = GetLastError();
        return HRESULT_FROM_WIN32(dwErr);
    }
    return S_OK;
}

void EliminateGMTPathSegment(LPWSTR pszPath)
{
    LPWSTR pszGMT = wcsstr(pszPath, SNAPSHOT_MARKER);
    if (pszGMT)
    {
        ASSERT(pszGMT >= pszPath && pszGMT < (pszPath + lstrlenW(pszPath)));

        // It's tempting to just say "pszGMT + SNAPSHOT_NAME_LENGTH" here, but
        // we might miss an intervening '\0' on a malformed path.
        LPWSTR pszSeparator = wcschr(pszGMT, L'\\');
        if (pszSeparator)
        {
            ASSERT(pszSeparator == pszGMT + SNAPSHOT_NAME_LENGTH);
            ASSERT(pszSeparator < (pszGMT + lstrlenW(pszGMT)));

            pszSeparator++; // skip '\\'
            MoveMemory(pszGMT, pszSeparator, (lstrlenW(pszSeparator)+1)*sizeof(WCHAR));
        }
        else
        {
            // Truncate here
            *pszGMT = L'\0';

            // Remove the previous separator if we can
            PathRemoveBackslashW(pszPath);
        }
    }
}

void EliminatePathPrefix(LPWSTR pszPath)
{
    // Note that sometimes the "\\?\" is not at the beginning of the
    // path.  See CTimeWarpProp::_OnView in twprop.cpp.
    LPWSTR pszPrefix = wcsstr(pszPath, L"\\\\?\\");
    if (pszPrefix)
    {
        LPWSTR pszDest;
        LPWSTR pszSrc;

        ASSERT(pszPrefix >= pszPath && pszPrefix < (pszPath + lstrlenW(pszPath)));

        if (CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                         SORT_STRINGSORT | NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                         pszPrefix+4, 4,
                                         L"UNC\\", 4))
        {
            // UNC case: preserve the 2 leading backslashes
            pszDest = pszPrefix + 2;
            pszSrc = pszPrefix + 8;
        }
        else
        {
            pszDest = pszPrefix;
            pszSrc = pszPrefix + 4;
        }

        ASSERT(pszDest >= pszPath && pszSrc > pszDest && pszSrc <= (pszPath + lstrlenW(pszPath)));
        MoveMemory(pszDest, pszSrc, (lstrlenW(pszSrc)+1)*sizeof(WCHAR));
    }
}

HRESULT GetFSIDListFromTimeWarpPath(PIDLIST_ABSOLUTE *ppidlTarget, LPCWSTR pszPath, DWORD dwFileAttributes)
{
    HRESULT hr;
    LPWSTR pszDup;

    hr = SHStrDup(pszPath, &pszDup);
    if (SUCCEEDED(hr))
    {
        // Note that SHSimpleIDListFromPath (which is exported from shell32)
        // is not good enough here.  It always uses 0 for attributes, but
        // we usually need FILE_ATTRIBUTE_DIRECTORY here.
        EliminateGMTPathSegment(pszDup);
        hr = SimpleIDListFromAttributes(pszDup, dwFileAttributes, ppidlTarget);
        LocalFree(pszDup);
    }

    return hr;
}


class CFileSysBindData : public IFileSystemBindData
{ 
public:
    CFileSysBindData();
    
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IFileSystemBindData
    STDMETHODIMP SetFindData(const WIN32_FIND_DATAW *pfd);
    STDMETHODIMP GetFindData(WIN32_FIND_DATAW *pfd);

private:
    ~CFileSysBindData();
    
    LONG _cRef;
    WIN32_FIND_DATAW _fd;
};


CFileSysBindData::CFileSysBindData() : _cRef(1)
{
    ZeroMemory(&_fd, sizeof(_fd));
}

CFileSysBindData::~CFileSysBindData()
{
}

HRESULT CFileSysBindData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysBindData, IFileSystemBindData), // IID_IFileSystemBindData
         { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysBindData::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysBindData::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFileSysBindData::SetFindData(const WIN32_FIND_DATAW *pfd)
{
    _fd = *pfd;
    return S_OK;
}

HRESULT CFileSysBindData::GetFindData(WIN32_FIND_DATAW *pfd) 
{
    *pfd = _fd;
    return S_OK;
}

STDAPI SHCreateFileSysBindCtx(const WIN32_FIND_DATAW *pfd, IBindCtx **ppbc)
{
    HRESULT hres;
    IFileSystemBindData *pfsbd = new CFileSysBindData();
    if (pfsbd)
    {
        if (pfd)
        {
            pfsbd->SetFindData(pfd);
        }

        hres = CreateBindCtx(0, ppbc);
        if (SUCCEEDED(hres))
        {
            BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
            bo.grfMode = STGM_CREATE;
            (*ppbc)->SetBindOptions(&bo);
            (*ppbc)->RegisterObjectParam(STR_FILE_SYS_BIND_DATA, pfsbd);
        }
        pfsbd->Release();
    }
    else
    {
        *ppbc = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

STDAPI SHSimpleIDListFromFindData(LPCWSTR pszPath, const WIN32_FIND_DATAW *pfd, PIDLIST_ABSOLUTE *ppidl)
{
    *ppidl = NULL;

    IBindCtx *pbc;
    HRESULT hr = SHCreateFileSysBindCtx(pfd, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = SHParseDisplayName(pszPath, pbc, ppidl, 0, NULL);
        pbc->Release();
    }
    return hr;
}

STDAPI SimpleIDListFromAttributes(LPCWSTR pszPath, DWORD dwAttributes, PIDLIST_ABSOLUTE *ppidl)
{
    WIN32_FIND_DATAW fd = {0};
    fd.dwFileAttributes = dwAttributes;
    // SHCreateFSIDList(pszPath, &fd, ppidl);
    return SHSimpleIDListFromFindData(pszPath, &fd, ppidl);
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance, UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}

//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************

int
LoadStringAlloc(LPWSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\autodial.cpp ===
/*****************************************************************/
/**               Microsoft Windows                             **/
/**           Copyright (C) Microsoft Corp., 1995               **/
/*****************************************************************/

//
//  AUTODIAL.CPP - winsock autodial hook code
//

//  HISTORY:
//
//  3/22/95 jeremys     Created.
//  4/11/97 darrenmi    Moved functionality to wininet. Only stubs remain.
//

#include "project.h"
#pragma hdrstop

#include <wininet.h>

/*******************************************************************

    The following stubs are retained for compatibility.  This 
    functionality has been moved to wininet.

********************************************************************/

INTSHCUTAPI BOOL WINAPI InetIsOffline(DWORD dwFlags)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

INTSHCUTAPI STDAPI_(BOOL) WINAPI SetInetOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

    return fOffline;
}

// forward this call to wininet.  Toast once appropriate registry entries
// are set.
extern "C" void AutodialHookCallback(DWORD dwOpCode, LPCVOID lpParam);
extern "C" void InternetAutodialCallback(DWORD dwOpCode, LPCVOID lpParam);

void AutodialHookCallback(DWORD dwOpCode,LPCVOID lpParam)
{
    InternetAutodialCallback(dwOpCode, lpParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\mapi.h ===
/*
 *  M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H


/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDescA, FAR * lpMapiFileDescA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPWSTR lpszPathName;         /* Full path name of attachment file       */
    LPWSTR lpszFileName;         /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDescW, FAR * lpMapiFileDescW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiFileDesc MapiFileDescW
#define lpMapiFileDesc lpMapiFileDescW
#else
#define MapiFileDesc MapiFileDescA
#define lpMapiFileDesc lpMapiFileDescA
#endif  

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDescA, FAR * lpMapiRecipDescA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPWSTR lpszName;            /* Recipient name                           */
    LPWSTR lpszAddress;         /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDescW, FAR * lpMapiRecipDescW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiRecipDesc MapiRecipDescW
#define lpMapiRecipDesc lpMapiRecipDescW
#else
#define MapiRecipDesc MapiRecipDescA
#define lpMapiRecipDesc lpMapiRecipDescA
#endif  

#ifndef MAPI_ORIG               /* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_DISCRETE 0x10000000/* Recipient is a P1 resend recipient       */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessageA, FAR * lpMapiMessageA;

#ifdef  WIN32
typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPWSTR lpszSubject;           /* Message Subject                        */
    LPWSTR lpszNoteText;          /* Message Text                           */
    LPWSTR lpszMessageType;       /* Message Class                          */
    LPWSTR lpszDateReceived;      /* in YYYY/MM/DD HH:MM format             */
    LPWSTR lpszConversationID;    /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessageW, FAR * lpMapiMessageW;
#endif  /* WIN32 */

#ifdef  UNICODE
#define MapiMessage MapiMessageW
#define lpMapiMessage lpMapiMessageW
#else
#define MapiMessage MapiMessageA
#define lpMapiMessage lpMapiMessageA
#endif  

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI        0x00020000  /* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session   */
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile    */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* MAPILogoff() flags.      */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG             /* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT     0x00000040     Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID         0x00004000  /* allow 512 char returned ID   */

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID      0x00004000  /* allow 512 char returned ID   */

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

#ifndef MAPILogon

typedef ULONG (FAR PASCAL MAPILOGONA)(
    ULONG ulUIParam,
    LPSTR lpszProfileName,
    LPSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONA FAR *LPMAPILOGONA;

MAPILOGONA MAPILogonA;

#ifdef WIN32
typedef ULONG (FAR PASCAL MAPILOGONW)(
    ULONG ulUIParam,
    LPWSTR lpszProfileName,
    LPWSTR lpszPassword,
    FLAGS flFlags,
    ULONG ulReserved,
    LPLHANDLE lplhSession
);
typedef MAPILOGONW FAR *LPMAPILOGONW;

MAPILOGONW MAPILogonW;
#endif

#ifdef UNICODE
#define MAPILogon MAPILogonW
#else
#define MAPILogon MAPILogonA
#endif

#endif  /* MAPILogon */

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession, ULONG ulUIParam, FLAGS flFlags,
                            ULONG ulReserved);

ULONG FAR PASCAL MAPISendMailA(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageA lpMessage, FLAGS flFlags,
                              ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPISendMailW(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageW lpMessage, FLAGS flFlags,
                              ULONG ulReserved);
#endif  

#ifdef UNICODE
#define MAPISendMail MAPISendMailW
#else
#define MAPISendMail MAPISendMailA
#endif

ULONG FAR PASCAL MAPISendDocumentsA(ULONG ulUIParam, LPSTR lpszDelimChar,
                                   LPSTR lpszFilePaths, LPSTR lpszFileNames,
                                   ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPISendDocumentsW(ULONG ulUIParam, LPWSTR lpszDelimChar,
                                   LPWSTR lpszFilePaths, LPWSTR lpszFileNames,
                                   ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPISendDocuments MAPISendDocumentsW
#else
#define MAPISendDocuments MAPISendDocumentsA
#endif  

ULONG FAR PASCAL MAPIFindNextA(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageType, LPSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPSTR lpszMessageID);

#ifdef  WIN32
ULONG FAR PASCAL MAPIFindNextW(LHANDLE lhSession, ULONG ulUIParam,
                              LPWSTR lpszMessageType, LPWSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPWSTR lpszMessageID);
#endif  

#ifdef  UNICODE
#define MAPIFindNext MAPIFindNextW
#else
#define MAPIFindNext MAPIFindNextA
#endif  

ULONG FAR PASCAL MAPIReadMailA(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessageA FAR *lppMessage);

#ifdef  WIN32
ULONG FAR PASCAL MAPIReadMailW(LHANDLE lhSession, ULONG ulUIParam,
                              LPWSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessageW FAR *lppMessage);
#endif  

#ifdef  UNICODE
#define MAPIReadMail MAPIReadMailW
#else
#define MAPIReadMail MAPIReadMailA
#endif  

ULONG FAR PASCAL MAPISaveMailA(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageA lpMessage, FLAGS flFlags,
                              ULONG ulReserved, LPSTR lpszMessageID);

#ifdef  WIN32
ULONG FAR PASCAL MAPISaveMailW(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessageW lpMessage, FLAGS flFlags,
                              ULONG ulReserved, LPWSTR lpszMessageID);
#endif  

#ifdef  UNICODE
#define MAPISaveMail MAPISaveMailW
#else
#define MAPISaveMail MAPISaveMailA
#endif  

ULONG FAR PASCAL MAPIDeleteMailA(LHANDLE lhSession, ULONG ulUIParam,
                                LPSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPIDeleteMailW(LHANDLE lhSession, ULONG ulUIParam,
                                LPWSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPIDeleteMail MAPIDeleteMailW
#else
#define MAPIDeleteMail MAPIDeleteMailA
#endif  

ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

ULONG FAR PASCAL MAPIAddressA(LHANDLE lhSession, ULONG ulUIParam,
                    LPSTR lpszCaption, ULONG nEditFields,
                    LPSTR lpszLabels, ULONG nRecips,
                    lpMapiRecipDescA lpRecips, FLAGS flFlags, ULONG ulReserved,
                    LPULONG lpnNewRecips, lpMapiRecipDescA FAR *lppNewRecips);

#ifdef  WIN32
ULONG FAR PASCAL MAPIAddressW(LHANDLE lhSession, ULONG ulUIParam,
                    LPWSTR lpszCaption, ULONG nEditFields,
                    LPWSTR lpszLabels, ULONG nRecips,
                    lpMapiRecipDescW lpRecips, FLAGS flFlags, ULONG ulReserved,
                    LPULONG lpnNewRecips, lpMapiRecipDescW FAR *lppNewRecips);
#endif  

#ifdef  UNICODE
#define MAPIAddress MAPIAddressW
#else
#define MAPIAddress MAPIAddressA
#endif  

ULONG FAR PASCAL MAPIDetailsA(LHANDLE lhSession, ULONG ulUIParam,
                    lpMapiRecipDescA lpRecip, FLAGS flFlags, ULONG ulReserved);

#ifdef  WIN32
ULONG FAR PASCAL MAPIDetailsW(LHANDLE lhSession, ULONG ulUIParam,
                    lpMapiRecipDescW lpRecip, FLAGS flFlags, ULONG ulReserved);
#endif  

#ifdef  UNICODE
#define MAPIDetails MAPIDetailsW
#else
#define MAPIDetails MAPIDetailsA
#endif  

ULONG FAR PASCAL MAPIResolveNameA(LHANDLE lhSession, ULONG ulUIParam,
                        LPSTR lpszName, FLAGS flFlags,
                        ULONG ulReserved, lpMapiRecipDescA FAR *lppRecip);

#ifdef  WIN32
ULONG FAR PASCAL MAPIResolveNameW(LHANDLE lhSession, ULONG ulUIParam,
                        LPWSTR lpszName, FLAGS flFlags,
                        ULONG ulReserved, lpMapiRecipDescW FAR *lppRecip);
#endif  

#ifdef  UNICODE
#define MAPIResolveName MAPIResolveNameW
#else
#define MAPIResolveName MAPIResolveNameA
#endif  


#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\contmenu.cpp ===
/*
 * contmenu.cpp - Context menu implementation for URL class.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <mapi.h>

/* Types
 ********/

/* MAPISendMail() typedef */

typedef ULONG (FAR PASCAL *MAPISENDMAILPROC)(LHANDLE lhSession, ULONG ulUIParam, lpMapiMessageA lpMessage, FLAGS flFlags, ULONG ulReserved);

/* RunDLL32 DLL entry point typedef */

typedef void (WINAPI *RUNDLL32PROC)(HWND hwndParent, HINSTANCE hinst, PSTR pszCmdLine, int nShowCmd);


/* Module Constants
 *******************/

// case-insensitive
PRIVATE_DATA const char s_cszFileProtocolPrefix[]     = "file:";
PRIVATE_DATA const char s_cszMailToProtocolPrefix[]   = "mailto:";
PRIVATE_DATA const char s_cszRLoginProtocolPrefix[]   = "rlogin:";
PRIVATE_DATA const char s_cszTelnetProtocolPrefix[]   = "telnet:";
PRIVATE_DATA const char s_cszTN3270ProtocolPrefix[]   = "tn3270:";

PRIVATE_DATA const char s_cszNewsDLL[]                = "mcm.dll";
PRIVATE_DATA const char s_cszTelnetApp[]              = "telnet.exe";

PRIVATE_DATA const char s_cszMAPISection[]            = "Mail";
PRIVATE_DATA const char s_cszMAPIKey[]                = "CMCDLLName32";

PRIVATE_DATA const char s_cszMAPISendMail[]           = "MAPISendMail";
PRIVATE_DATA const char s_cszNewsProtocolHandler[]    = "NewsProtocolHandler";



#define MyMsgBox(x) //(void)(x)
#define DebugEntry(x) 
extern "C" void WINAPI FileProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                           PSTR pszCmdLine, int nShowCmd)
{
    CHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    if (SUCCEEDED(PathCreateFromUrlA(pszCmdLine, sz, &cch, 0)))
        pszCmdLine = sz;

    ShellExecute(hwndParent, NULL, pszCmdLine, NULL, NULL,
                            nShowCmd);

}


extern "C" void WINAPI MailToProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                             PSTR pszCmdLine, int nShowCmd)
{
   char szMAPIDLL[MAX_PATH];
   if (GetProfileString(s_cszMAPISection, s_cszMAPIKey, "",
                        szMAPIDLL, sizeof(szMAPIDLL)) > 0)
   {
      HINSTANCE hinstMAPI = LoadLibrary(szMAPIDLL);
      if (hinstMAPI)
      {
         MAPISENDMAILPROC MAPISendMailProc = (MAPISENDMAILPROC)GetProcAddress(
                                                         hinstMAPI,
                                                         s_cszMAPISendMail);

         if (MAPISendMailProc)
         {
            PARSEDURLA pu = {sizeof(pu)};
            if (SUCCEEDED(ParseURLA(pszCmdLine, &pu)) && URL_SCHEME_MAILTO == pu.nScheme)
            {
                MapiRecipDescA mapito;
                MapiMessage mapimsg;
                pszCmdLine = (PSTR) pu.pszSuffix;

                ZeroMemory(&mapito, sizeof(mapito));

                mapito.ulRecipClass = MAPI_TO;
                mapito.lpszName = pszCmdLine;

                ZeroMemory(&mapimsg, sizeof(mapimsg));

                mapimsg.nRecipCount = 1;
                mapimsg.lpRecips = &mapito;

                (*MAPISendMailProc)(NULL, 0, &mapimsg,
                                               (MAPI_LOGON_UI | MAPI_DIALOG), 0);

            }
         }

         FreeLibrary(hinstMAPI);
      }
   }

}


extern "C" void WINAPI NewsProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                           PSTR pszCmdLine, int nShowCmd)
{
   HINSTANCE hinstNews = LoadLibrary(s_cszNewsDLL);
   if (hinstNews)
   {
      RUNDLL32PROC RealNewsProtocolHandler = (RUNDLL32PROC)GetProcAddress(hinstNews, s_cszNewsProtocolHandler);
      if (RealNewsProtocolHandler)
      {
         (*RealNewsProtocolHandler)(hwndParent, hinst, pszCmdLine, nShowCmd);
      }

      FreeLibrary(hinstNews);
   }
}


#ifndef ISSPACE
#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)
#endif
#ifndef ISQUOTE
#define ISQUOTE(ch) ((ch) == '\"' || (ch) == '\'')
#endif

void TrimString(PSTR pszTrimMe, PCSTR pszTrimChars)
{
   PSTR psz;
   PSTR pszStartMeat;

   if ( !pszTrimMe )
      return;

   /* Trim leading characters. */

   psz = pszTrimMe;

   while (*psz && StrChr(pszTrimChars, *psz))
      psz = CharNext(psz);

   pszStartMeat = psz;

   /* Trim trailing characters. */

   if (*psz)
   {
      psz += lstrlen(psz);

      psz = CharPrev(pszStartMeat, psz);

      if (psz > pszStartMeat)
      {
         while (StrChr(pszTrimChars, *psz))
            psz = CharPrev(pszStartMeat, psz);

         psz = CharNext(psz);

         *psz = '\0';
      }
   }

   /* Relocate stripped string. */

   if (pszStartMeat > pszTrimMe)
      /* (+ 1) for null terminator. */
      MoveMemory(pszTrimMe, pszStartMeat, lstrlen(pszStartMeat) + 1);

   return;
}

void TrimSlashes(PSTR pszTrimMe)
{
   TrimString(pszTrimMe, "\\/");

   /* TrimString() validates pszTrimMe on output. */

   return;
}

extern "C" void WINAPI TelnetProtocolHandler(HWND hwndParent, HINSTANCE hinst,
                                             PSTR pszCmdLine, int nShowCmd)
{
    HRESULT hr;
    char *p;
    char *pDest;
    BOOL fRemove;
    PARSEDURLA pu = {sizeof(pu)};
    if (SUCCEEDED(ParseURLA(pszCmdLine, &pu)))
    {
        if ((URL_SCHEME_TELNET == pu.nScheme)
        || (0 == StrCmpNI(pu.pszProtocol, s_cszRLoginProtocolPrefix, pu.cchProtocol))
        || (0 == StrCmpNI(pu.pszProtocol, s_cszTN3270ProtocolPrefix, pu.cchProtocol)))
        {
            pszCmdLine = (PSTR) pu.pszSuffix;
        }
    }

   // Remove leading and trailing slashes.
   TrimSlashes(pszCmdLine);

   p = StrChr(pszCmdLine, '@');

   if (p)
      pszCmdLine = p + 1;

   // Eliminate double quotes...should be no need for these
   // unless trouble is afoot.
   for (pDest = p = pszCmdLine; *p; p++)
   {
      if (!ISQUOTE(*p))
      {
          *pDest = *p;
          pDest++;
      }
   }
   *pDest = '\0';

   // For security reasons, strip the filename cmdline option
   if (pszCmdLine)
   {
       for (p = pszCmdLine; *p; p++)
       {
           // Be careful and don't nuke servernames that start with -f.
           // Since hostnames can't start with a dash, ensure previous char is
           // whitespace, or we're at the beginning.
           //
           // Also, -a sends credentials over the wire, so strip it, too.
           if ((*p == '/' || *p == '-') &&
               (*(p+1) == 'f' || *(p+1) == 'F' || *(p+1) == 'a' || *(p+1) == 'A'))
           {
               fRemove = TRUE;
               if (!((p == pszCmdLine || ISSPACE(*(p-1)) || ISQUOTE(*(p-1)) )))
               {
                   char *pPortChar = p-1;
                   // Doesn't meet easy criteria, but it might be harder to
                   // detect, such as site:-ffilename.  In this case, consider
                   // the -f piece unsafe if everything between -f and a colon
                   // to the left is a digit (no digits will also be unsafe).
                   // If anything else is hit first, then consider it to
                   // be part of the hostname.  Walking to the beginning
                   // be considered safe (e.g. "80-ffilename" would be considered
                   // the hostname).
                   while (pPortChar >= pszCmdLine && *pPortChar != ':')
                   {
                       if (*pPortChar < '0' || *pPortChar > '9')
                       {
                           fRemove = FALSE;
                           break;
                       }
                       pPortChar--;
                   }
                   if (pPortChar < pszCmdLine)
                       fRemove = FALSE;
               }

               if (!fRemove)
                   continue;

               BOOL fQuotedFilename = FALSE;
               LPSTR pStart = p;

               // move past -f
               p+=2;

               // Skip over whitespace and filename following -f option
               if (*(p-1) == 'f' || *(p-1) == 'F')
               {
                   while (*p && ISSPACE(*p))
                       p++;

                   // but wait, it may be a long filename surrounded by quotes
                   if (ISQUOTE(*p))
                   {
                       fQuotedFilename = TRUE;
                       p++;
                   }

                   // Loop until null OR whitespace if not quoted pathname OR quote if a quoted pathname
                   while (!((*p == '\0') ||
                            (ISSPACE(*p) && !fQuotedFilename) ||
                            (ISQUOTE(*p) && fQuotedFilename)))
                       p++;
               }

               // phase out the -a and -f options, but keep going to search the rest of the string
               memmove((VOID *)pStart, (VOID *)p, strlen(p)+1);
               p = pStart-1;
           }
       }
   }

   // If a port has been specified, turn ':' into space, which will make the
   // port become the second command line argument.

   p = StrChr(pszCmdLine, ':');

   if (p)
      *p = ' ';

   ShellExecute(hwndParent, NULL, s_cszTelnetApp, pszCmdLine, NULL , SW_SHOW);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\project.h ===
/*
 * project.h - Common project header file for URL Shell extension DLL.
 */


/* System Headers
 *****************/

#define INC_OLE2              /* for windows.h */
#define CONST_VTABLE          /* for objbase.h */

#pragma warning(disable:4514) /* "unreferenced __inlinefunction" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#ifndef WIN32_LEAN_AND_MEAN   /* NT builds define this for us */
#define WIN32_LEAN_AND_MEAN   /* for windows.h */
#endif                        /*  WIN32_LEAN_AND_MEAN  */
#include <windows.h>
#pragma warning(disable:4001) /* "single line comment" warning - windows.h enabled it */
#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shellp.h>
#include <comctrlp.h>
#include <shlobjp.h>
#include <shlapip.h>

#define _INTSHCUT_
#include <intshcut.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */

#include <limits.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

#include <crtfree.h>        // Use intrinsic functions to avoid CRT

/* The order of the following include files is significant. */

#ifdef NO_HELP
#undef NO_HELP
#endif

#define PRIVATE_DATA
#define PUBLIC_CODE
#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\autodial.hpp ===
/*****************************************************************/
/**				  Microsoft Windows								**/
/**		      Copyright (C) Microsoft Corp., 1995				**/
/*****************************************************************/ 

//
//	AUTODIAL.HPP - winsock autodial hook code
//

//	HISTORY:
//	
//	3/22/95	jeremys		Created.
//

#ifndef _AUTODIAL_HPP_
#define _AUTODIAL_HPP_


#include <raserror.h>

// typedefs for function pointers for RNA functions
typedef DWORD 		(WINAPI * RNAENUMDEVICES) (LPBYTE, LPDWORD, LPDWORD);
typedef DWORD 		(WINAPI * RNAIMPLICITDIAL) (HWND,LPSTR);
typedef DWORD 		(WINAPI * RNAACTIVATEENGINE) (VOID);
typedef DWORD 		(WINAPI * RNADEACTIVATEENGINE) (VOID);
typedef DWORD		(WINAPI * RNAENUMCONNENTRIES) (LPSTR,UINT,LPDWORD);
typedef DWORD		(WINAPI * RASCREATEPHONEBOOKENTRY) (HWND,LPSTR);
typedef DWORD		(WINAPI * RASEDITPHONEBOOKENTRY) (HWND,LPSTR,LPSTR);

// typedefs for function pointers for Internet wizard functions
typedef VOID		(WINAPI * INETPERFORMSECURITYCHECK) (HWND,LPBOOL);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
	PVOID * ppFcnPtr;
	LPCSTR pszName;
} APIFCN;

#define SMALLBUFLEN		48	// convenient size for small buffers

#ifndef RAS_MaxEntryName
#undef RAS_MaxEntryName
#endif // RAS_MaxEntryName
#define RAS_MaxEntryName	256


/* Prototypes
 *************/

/* autodial.cpp */

extern BOOL InitAutodialModule(void);
extern void ExitAutodialModule(void);

// opcode ordinals for dwOpCode parameter in hook
#define AUTODIAL_CONNECT		1
#define AUTODIAL_GETHOSTBYADDR	2
#define AUTODIAL_GETHOSTBYNAME	3
#define AUTODIAL_LISTEN			4
#define AUTODIAL_RECVFROM		5
#define AUTODIAL_SENDTO			6

// maximum length of local host name
#define MAX_LOCAL_HOST			255

// max length of exported autodial handler function
#define MAX_AUTODIAL_FCNNAME	48
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\dllinit.cpp ===
/*
 * dllinit.cpp - Initialization and termination routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "autodial.hpp"
#include "shdocvw.h"

PUBLIC_CODE BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason,
                                PVOID pvReserved)
{
   return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PVOID *ppvObject)
{
    *ppvObject = 0;
    return E_UNEXPECTED;
}

STDAPI DllCanUnloadNow(void)
{
    return S_OK;
}

INTSHCUTAPI HRESULT WINAPI TranslateURLA(PCSTR pcszURL, DWORD dwInFlags, PSTR *ppszTranslatedURL)
{
    return URLQualifyA(pcszURL, dwInFlags, ppszTranslatedURL);
}


INTSHCUTAPI HRESULT WINAPI TranslateURLW(PCWSTR pcszURL, DWORD dwInFlags, PWSTR UNALIGNED *ppszTranslatedURL)
{
    return URLQualifyW(pcszURL, dwInFlags, ppszTranslatedURL);
}

INTSHCUTAPI HRESULT WINAPI URLAssociationDialogW(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCWSTR pcszFile,
                                                 PCWSTR pcszURL,
                                                 PWSTR pszAppBuf,
                                                 UINT ucAppBufLen)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return E_NOTIMPL;
}

INTSHCUTAPI HRESULT WINAPI URLAssociationDialogA(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCSTR pcszFile, 
                                                 PCSTR pcszURL,
                                                 PSTR pszAppBuf,
                                                 UINT ucAppBufLen)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return E_NOTIMPL;
}

INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogW(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCWSTR pcszFile,
                                                  PCWSTR pcszMIMEContentType,
                                                  PWSTR pszAppBuf,
                                                  UINT ucAppBufLen)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return E_NOTIMPL;
}
INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogA(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCSTR pcszFile,
                                                  PCSTR pcszMIMEContentType,
                                                  PSTR pszAppBuf,
                                                  UINT ucAppBufLen)
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return E_NOTIMPL;
}

INTSHCUTAPI HRESULT WINAPI AddMIMEFileTypesPS(LPFNADDPROPSHEETPAGE pfnAddPage,
                                                  LPARAM lparam)
{
   IShellPropSheetExt* pspse;
   HRESULT hr = SHCoCreateInstance(NULL, &CLSID_FileTypes, NULL, IID_IShellPropSheetExt, (LPVOID*)&pspse);

   if (SUCCEEDED(hr))
   {
        hr = pspse->AddPages(pfnAddPage, lparam);
        pspse->Release();
   }
   return hr;
}

EXTERN_C void WINAPI OpenURL(HWND hwndParent, HINSTANCE hinst,
                               PSTR pszCmdLine, int nShowCmd)
{
    ShellExecute(hwndParent, NULL, pszCmdLine, NULL, NULL , nShowCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\resource.h ===
#define IDI_WEB_DOCUMENT                102
#define IDI_WEB_NEWS                    103
#define IDI_WEB_MAILTO                  104
#define IDI_WEB_VRML                    105
#define IDI_WEB_SPLAT                   106
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\url\url.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DEXPV \
                  -DMIME \
                  -DBUILDDLL \
                  -DIEXPLORER_DOESNT_CHECK_HEAP_RETURN_VALUES

!IF !$(FREEBUILD)
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!ENDIF

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
DELAYLOAD       =  WININET.DLL
DLOAD_ERROR_HANDLER = kernel32.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\userstub\resource.h ===
#define IDD_InstallStubProgress 10

#define IDS_UNINSTALL   100
#define IDS_DESKTOP     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\userstub\debug.c ===
// We don't use the debugging macros ourselves, but we use
// RunInstallUninstallStubs2, which uses IsOS() in stocklib,
// and stocklib uses the debugging macros, so we have to do all this
// stuff to keep the linker happy.
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "userstub"
#define SZ_MODULE       "USERSTUB"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

STDAPI_(HPROPSHEETPAGE) Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//
#define UNICODE 1

#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"
#include <shfusion.h>

HPROPSHEETPAGE Whistler_CreatePropertySheetPageW(LPCPROPSHEETPAGEW a)
{
    LPCPROPSHEETPAGEW ppsp = (LPCPROPSHEETPAGEW)a;
    PROPSHEETPAGEW psp;

    if (g_hActCtx && (a->dwSize<=PROPSHEETPAGE_V2_SIZE))
    {
        memset(&psp, 0, sizeof(psp));
        CopyMemory(&psp, a, a->dwSize);
        psp.dwSize = sizeof(psp);
        ppsp = &psp;
    }
    return CreatePropertySheetPageW(ppsp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\userstub\userstub.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       userstub.cpp
//
//  Contents:   exe to load webcheck
//
//  Classes:
//
//  Functions:
//
//  History:    12-12/96    rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------

#define _SHELL32_ // We delayload shell32

#include <windows.h>
#include <debug.h>
#include <docobj.h>
#include <webcheck.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shellp.h>
#include <shlwapi.h>

// if inststub.h is used in userstub, use LoadString() OW use MLLoadString()
#define	USERSTUB	1

//
// NOTE: ActiveSetup relies on our window name and class name
// to shut us down properly in softboot.  Do not change it.
//
//const TCHAR c_szClassName[] = TEXT("userstub");
//const TCHAR c_szWebCheck[] = TEXT("WebCheck");
//const TCHAR c_szWebCheckWindow[] = TEXT("MS_WebcheckMonitor");
//const TCHAR c_szShellReg[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
//const TCHAR c_szWebcheckKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");

typedef struct {
    HINSTANCE   hInstance;          // handle to current instance
    BOOL        fUninstallOnly;     // TRUE -> run uninstall stubs only, then quit
} GLOBALS;

GLOBALS g;

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);



// Code to run install/uninstall stubs, from shell\inc.

#define HINST_THISDLL   g.hInstance
#include "resource.h"
#include <inststub.h>

// need to do this so we can since inststub.h #includes <runonce.c>
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;


int WINAPI WinMainT(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow);


//----------------------------------------------------------------------------
// ModuleEntry
//----------------------------------------------------------------------------
extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();

    // g_hProcessHeap = GetProcessHeap();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    // DebugMsg(DM_TRACE, TEXT("c.me: Cabinet main thread exiting without ExitProcess."));
    return i;
}



//----------------------------------------------------------------------------
// WinMain
//----------------------------------------------------------------------------
int WINAPI WinMainT(
    HINSTANCE hInstance,            // handle to current instance
    HINSTANCE hPrevInstance,        // handle to previous instance
    LPSTR lpCmdLine,                // pointer to command line
    int nCmdShow                        // show state of window
   )
{
    // Save the globals
    g.hInstance = hInstance;
    g.fUninstallOnly = FALSE;

    // Parse the command line, for DEBUG options and for uninstall-only switch.
    if (!bParseCommandLine(lpCmdLine, nCmdShow))
        return 0;

    // Run all install/uninstall stubs for browser-only mode.
    // If IE4 has been uninstalled, we'll be run with the -u switch; this
    // means to run install/uninstall stubs only, no webcheck stuff.
    RunInstallUninstallStubs2(NULL);

    // Return the exit code to Windows
    return 0;
}

//----------------------------------------------------------------------------
// bParseCmdLine
//
// Parse the command line
//      -u  run install/uninstall stubs only, then quit
//  DEBUG options:
//      -v  visible window (easy to shutdown)
//      -a  add webcheck to shell service object
//      -r  remove webcheck from shell service object
//      -s  fix shell folders only
//      -?  these options
//----------------------------------------------------------------------------
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow)
{
    if (!lpCmdLine)
        return TRUE;

    CharUpper(lpCmdLine);   /* easier to parse */
    while (*lpCmdLine)
    {
        if (*lpCmdLine != '-' && *lpCmdLine != '/')
            break;

        lpCmdLine++;

        switch (*(lpCmdLine++))
        {
            case 'U':
                g.fUninstallOnly = TRUE;
                break;
        }

        while (*lpCmdLine == ' ' || *lpCmdLine == '\t') {
            lpCmdLine++;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdlagent.h ===
#ifndef _CDL_AGENT_HXX_INCLUDED
#define _CDL_AGENT_HXX_INCLUDED

class CDLAgentBSC;

class CCDLAgent : public CDeliveryAgent,
                  public CRunDeliveryAgentSink
{
    private:
        virtual ~CCDLAgent();
    
    public:
        CCDLAgent();

    // virtual functions overriding CDeliveryAgent

    public:
        void        CleanUp();
        HRESULT     AgentAbort(DWORD dwFlags);
        HRESULT     AgentPause(DWORD dwFlags);
        HRESULT     AgentResume(DWORD dwFlags);
   
    protected:
        HRESULT     StartOperation();
        HRESULT     StartDownload();
        HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);

    public:
        void        SetEndStatus(HRESULT hr) { CDeliveryAgent::SetEndStatus(hr); }
        void        SetErrorEndText(LPCWSTR szErrorText);
        LPWSTR      GetErrorMessage(HRESULT hr);

        HRESULT     StartNextDownload(LPWSTR szCodeBase, DWORD dwSize);
        HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

    private:

        IXMLElement*     m_pSoftDistElement;
        union {
            LPWSTR           m_szCDF;
            LPWSTR           m_szURL;
        };
        LPWSTR           m_szDistUnit;
        SOFTDISTINFO     m_sdi;
        LPWSTR           m_szErrorText;
        DWORD            m_dwVersionMS;
        DWORD            m_dwVersionLS;

        CDLAgentBSC     *m_pCCDLAgentBSC;
        ISoftDistExt    *m_pSoftDistExt;
        
        BOOL             m_bAcceptSoftware;
        BOOL             m_bSendEmail;
        BOOL             m_bSilentMode;

        DWORD            m_dwChannelFlags;
        DWORD            m_dwAgentFlags;
        DWORD            m_dwMaxSizeKB;
        DWORD            m_dwCurSize;
        
        CRunDeliveryAgent *m_pAgent;
};
         
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdlabsc.cpp ===
#include "private.h"
#include "cdlabsc.h"

CDLAgentBSC::CDLAgentBSC(CCDLAgent *pCdlAgent, DWORD dwMaxSizeKB, BOOL fSilentOperation,
                         LPWSTR szCDFUrl)
{
    m_cRef = 1;
    m_pIBinding = NULL;
    m_pCdlAgent = pCdlAgent;
    m_fSilentOperation = fSilentOperation;
    m_dwMaxSize = dwMaxSizeKB*1024;
    m_pSecMgr = NULL;

    StrCpyNW(m_pwzCDFBase, szCDFUrl, ARRAYSIZE(m_pwzCDFBase));

    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->AddRef();
    }
}

CDLAgentBSC::~CDLAgentBSC()
{
    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->Release();
    }

    if (m_pIBinding != NULL)
    {
        m_pIBinding->Release();
    }

    if (m_pSecMgr) {
        m_pSecMgr->Release();
    }
}

HRESULT CDLAgentBSC::Abort()
{
    if (m_pIBinding != NULL) {

        return m_pIBinding->Abort();
    
    } else {
    
        return S_OK;
    
    }
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP CDLAgentBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *) this;
        AddRef();
    }

    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT     hr = NOERROR;
    IServiceProvider        *pIServiceProvider = NULL;

    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = 0;

    if (IsEqualGUID(rsid, IID_IInternetHostSecurityManager) &&
        IsEqualGUID(riid, IID_IInternetHostSecurityManager)) {

        if (m_pSecMgr == NULL) {
            hr = CoInternetCreateSecurityManager(NULL, &m_pSecMgr, NULL);
        }
        
        if (m_pSecMgr) {
            *ppvObj = (IInternetHostSecurityManager *)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    }
    else {
        hr = E_NOINTERFACE;
        *ppvObj = NULL;
    }
        

    return hr;
}

STDMETHODIMP_(ULONG) CDLAgentBSC::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDLAgentBSC::Release()
{
    if (0L != --m_cRef)
    {
        return m_cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP CDLAgentBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (m_pIBinding != NULL)
    {
        m_pIBinding->Release();
    }
    m_pIBinding = pib;

    if (m_pIBinding != NULL)
    {
        m_pIBinding->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    HRESULT         hr = S_OK;
    
    if (m_pCdlAgent != NULL)
    {
        m_pCdlAgent->SetErrorEndText(szError);
        m_pCdlAgent->SetEndStatus(hresult);
        m_pCdlAgent->CleanUp();
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

STDMETHODIMP CDLAgentBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    if ((m_dwMaxSize > 0) && (ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)) {

        if (ulProgress > m_dwMaxSize || ulProgressMax > m_dwMaxSize) {
        
           Abort();
        
        }

    }

    return S_OK;
}


STDMETHODIMP CDLAgentBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
   if (m_fSilentOperation)
   {
       *pgrfBINDF |= BINDF_SILENTOPERATION;
   }
    return S_OK;
}

STDMETHODIMP CDLAgentBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

HRESULT CDLAgentBSC::Pause()
{
    HRESULT              hr = E_FAIL;
    if (m_pIBinding != NULL)
    {
        hr = m_pIBinding->Suspend();
    }

    return hr;
}

HRESULT CDLAgentBSC::Resume()
{
    HRESULT              hr = E_FAIL;
    if (m_pIBinding != NULL)
    {
        hr = m_pIBinding->Resume();
    }

    return hr;
}

// IInternetHostSecurityManager
STDMETHODIMP CDLAgentBSC::GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                        DWORD_PTR dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->GetSecurityId(m_pwzCDFBase, pbSecurityId,
                                     pcbSecurityId, dwReserved);
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                           BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                           DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->ProcessUrlAction(m_pwzCDFBase, dwAction, pPolicy,
                                        cbPolicy, pContext, cbContext,
                                        dwFlags, dwReserved);
    }

    return hr;
}

STDMETHODIMP CDLAgentBSC::QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                            DWORD *pcbPolicy, BYTE *pContext,
                                            DWORD cbContext, DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (m_pSecMgr) {
        hr = m_pSecMgr->QueryCustomPolicy(m_pwzCDFBase, guidKey, ppPolicy,
                                         pcbPolicy, pContext, cbContext,
                                         dwReserved);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\admin.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       admin.cpp
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    
//
//----------------------------------------------------------------------------

#include "private.h"
#include "shguidp.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "winineti.h"

#include <mluisupp.h>

// Infodelivery Policies registry locations
#define INFODELIVERY_POLICIES TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery")
// const TCHAR c_szRegKeyRestrictions[]    = INFODELIVERY_POLICIES TEXT("\\Restrictions");
const TCHAR c_szRegKeyModifications[]   = INFODELIVERY_POLICIES TEXT("\\Modifications");
const TCHAR c_szRegKeyCompletedMods[]   = INFODELIVERY_POLICIES TEXT("\\CompletedModifications");
const TCHAR c_szRegKeyIESetup[]         = TEXT("Software\\Microsoft\\IE4\\Setup");

// Wininet cache preload directory
const TCHAR c_szRegKeyCachePreload[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload");

// Registry key names of supported Modifications
const TCHAR c_szAddChannels[]               = TEXT("AddChannels");
const TCHAR c_szRemoveChannels[]            = TEXT("RemoveChannels");
const TCHAR c_szRemoveAllChannels[]         = TEXT("RemoveAllChannels");
const TCHAR c_szAddSubscriptions[]          = TEXT("AddSubscriptions");
const TCHAR c_szRemoveSubscriptions[]       = TEXT("RemoveSubscriptions");
const TCHAR c_szAddScheduleGroups[]         = TEXT("AddScheduleGroups");
const TCHAR c_szRemoveScheduleGroups[]      = TEXT("RemoveScheduleGroups");
const TCHAR c_szAddDesktopComponents[]      = TEXT("AddDesktopComponents");
const TCHAR c_szRemoveDesktopComponents[]   = TEXT("RemoveDesktopComponents");

// Registry value names of supported Modifications
const TCHAR c_szURL[]                   = TEXT("URL");
const TCHAR c_szTitle[]                 = TEXT("Title");
const TCHAR c_szLogo[]                  = TEXT("Logo");
const TCHAR c_szWideLogo[]              = TEXT("WideLogo");
const TCHAR c_szIcon[]                  = TEXT("Icon");
const TCHAR c_szCategory[]              = TEXT("Category");
const TCHAR c_szChannelGuide[]          = TEXT("ChannelGuide"); // DO NOTE CHANGE THIS STRING WITHOUT UPDATING CDFVIEW!!!
const TCHAR c_szPreloadURL[]            = TEXT("PreloadURL");
const TCHAR c_szLCID[]                  = TEXT("LangId");       // This must be an LCID despite its name
const TCHAR c_szSoftware[]              = TEXT("Software");
const TCHAR c_szSubscriptionType[]      = TEXT("SubscriptionType");
const TCHAR c_szScheduleGroup[]         = TEXT("ScheduleGroup");
const TCHAR c_szEarliestTime[]          = TEXT("EarliestTime");
const TCHAR c_szIntervalTime[]          = TEXT("IntervalTime");
const TCHAR c_szLatestTime[]            = TEXT("LatestTime");
const TCHAR c_szComponentType[]         = TEXT("DesktopComponentType");
const TCHAR c_szUsername[]              = TEXT("Username");
const TCHAR c_szPassword[]              = TEXT("Password");
const TCHAR c_szOldIEVersion[]          = TEXT("OldIEVersion");
const TCHAR c_szNonActive[]             = TEXT("NonActive");
const TCHAR c_szOffline[]               = TEXT("Offline");
const TCHAR c_szSynchronize[]           = TEXT("Synchronize");

// Names of reserved schedule groups that we support even in localized version
const WCHAR c_szScheduleAuto[]          = L"Auto";
const WCHAR c_szScheduleDaily[]         = L"Daily";
const WCHAR c_szScheduleWeekly[]        = L"Weekly";
const WCHAR c_szScheduleManual[]        = L"Manual";

// Function prototypes for Modification handlers
HRESULT ProcessAddChannels(HKEY hkey);
HRESULT ProcessRemoveChannels(HKEY hkey);
HRESULT ProcessRemoveAllChannels(HKEY hkey);
HRESULT ProcessAddSubscriptions(HKEY hkey);
HRESULT ProcessRemoveSubscriptions(HKEY hkey);
HRESULT ProcessRemoveDesktopComponents(HKEY hkey);

HRESULT Channel_GetBasePath(LPTSTR pszPath, int cch);

// Helper functions
void ShowChannelDirectories(BOOL fShow);

// Table of supported Actions and corresponding functions
// NOTE: The table must be ordered appropriately (RemoveAll must come before Add)
typedef HRESULT (*PFNACTION)(HKEY);
typedef struct { LPCTSTR szAction; PFNACTION pfnAction; } ACTIONTABLE;
ACTIONTABLE rgActionTable[] = {
    { c_szRemoveAllChannels,        &ProcessRemoveAllChannels },
    { c_szRemoveSubscriptions,      &ProcessRemoveSubscriptions },
    { c_szRemoveChannels,           &ProcessRemoveChannels },
    { c_szRemoveDesktopComponents,  &ProcessRemoveDesktopComponents },
    { c_szAddChannels,              &ProcessAddChannels },
    { c_szAddSubscriptions,         &ProcessAddSubscriptions }
};
#define ACTIONTABLECOUNT (sizeof(rgActionTable) / sizeof(ACTIONTABLE))
#define ACTIONTABLE_ADDCHANNELS 5

// Helper class to manipulate registry keys
class CRegKey
{
    HKEY m_hkey;
    DWORD dwIndex;
public:
    CRegKey(void)
    {
        m_hkey = NULL;
        dwIndex = 0;
    }
    ~CRegKey(void)
    {
        if (m_hkey)
        {
            LONG lRet = RegCloseKey(m_hkey);
            ASSERT(ERROR_SUCCESS == lRet);
            m_hkey = NULL;
        }
    }
    void SetKey(HKEY hkey)
    {
        m_hkey = hkey;
    }
    HKEY GetKey(void)
    {
        return m_hkey;
    }
    HRESULT OpenForRead(HKEY hkey, LPCTSTR szSubKey)
    {
        ASSERT(NULL == m_hkey);
        LONG lRet = RegOpenKeyEx(hkey, szSubKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &m_hkey);
        ASSERT((ERROR_SUCCESS == lRet) || !m_hkey);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT CreateForWrite(HKEY hkey, LPCTSTR szSubKey)
    {
        ASSERT(NULL == m_hkey);
        DWORD dwDisp;
        LONG lRet = RegCreateKeyEx(hkey, szSubKey, 0, TEXT(""), 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &m_hkey, &dwDisp);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetSubKeyCount(PDWORD pdwKeys)
    {
        ASSERT(NULL != m_hkey);
        LONG lRet = RegQueryInfoKey(m_hkey, NULL, NULL, NULL, pdwKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT Next(LPTSTR szSubKey)
    {
        ASSERT(NULL != m_hkey);
        DWORD dwLen = MAX_PATH; // Assumes size of incoming buffer.
        LONG lRet = RegEnumKeyEx(m_hkey, dwIndex, szSubKey, &dwLen, NULL, NULL, NULL, NULL);
        dwIndex++;
        if (ERROR_SUCCESS == lRet)
            return S_OK;
        else if (ERROR_NO_MORE_ITEMS == lRet)
            return S_FALSE;
        else
        {
            ASSERT(FALSE);
            return E_FAIL;
        }
    }
    HRESULT Reset(void)
    {
        dwIndex = 0;
        return S_OK;
    }
    HRESULT SetValue(LPCTSTR szValueName, DWORD dwValue)
    {
        ASSERT(m_hkey);
        LONG lRet = RegSetValueEx(m_hkey, szValueName, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetValue(LPCTSTR szValueName, DWORD *pdwValue)
    {
        ASSERT(m_hkey);
        DWORD dwType = REG_DWORD;
        DWORD dwLen = sizeof(DWORD);
        LONG lRet = RegQueryValueEx(m_hkey, szValueName, 0, &dwType, (LPBYTE)pdwValue, &dwLen);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetStringValue(LPCTSTR szValueName, LPTSTR szValue, DWORD cbValue)
    {
        ASSERT(m_hkey);

        return SHRegGetValue(m_hkey, NULL, szValueName, SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL, szValue, &cbValue) == ERROR_SUCCESS
            ? S_OK
            : E_FAIL;
    }
    HRESULT SetBSTRValue(LPCTSTR szValueName, BSTR bstr)
    {
        ASSERT(m_hkey);
        TCHAR szValue[INTERNET_MAX_URL_LENGTH];
        MyOleStrToStrN(szValue, ARRAYSIZE(szValue), bstr);
        LONG lRet = RegSetValueEx(m_hkey, szValueName, 0, REG_SZ, (LPBYTE)szValue, lstrlen(szValue) + 1);
        ASSERT(ERROR_SUCCESS == lRet);
        return (ERROR_SUCCESS == lRet)?(S_OK):(E_FAIL);
    }
    HRESULT GetBSTRValue(LPCTSTR szValueName, BSTR *pbstr)
    {
        ASSERT(m_hkey);
        TCHAR szValue[INTERNET_MAX_URL_LENGTH];
        DWORD cbValue = sizeof(szValue);
        HRESULT hr;

        *pbstr = NULL;

        LONG lRet = SHRegGetValue(m_hkey, NULL, szValueName, SRRF_RT_REG_SZ | SRRF_NOEXPAND, NULL, szValue, &cbValue);
        if (ERROR_SUCCESS == lRet)
        {
            DWORD cchValue = cbValue / sizeof(TCHAR);
            *pbstr = SysAllocStringLen(NULL, cchValue); // cchValue includes null terminator
            if (*pbstr)
            {
                MyStrToOleStrN(*pbstr, cchValue, szValue);
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lRet);
        }

        return hr;
    }
};

// Helper class to manage Dynamic Pointer Arrays of HKEYs.
class CRegKeyDPA
{
    HDPA m_hdpa;
    int m_count;
public:
    CRegKeyDPA(void)
    {
        m_hdpa = NULL;
        m_count = 0;
    }
    ~CRegKeyDPA(void)
    {
        if (m_hdpa)
        {
            ASSERT(m_count);
            int i;
            for (i = 0; i < m_count; i++)
                RegCloseKey(GetKey(i));
            DPA_Destroy(m_hdpa);
        }
    }
    int GetCount(void)
    {
        return m_count;
    }
    HKEY GetKey(int i)
    {
        ASSERT(i >= 0 && i < m_count);
        return (HKEY)DPA_GetPtr(m_hdpa, i);
    }
    HRESULT Add(HKEY hkey, LPCTSTR szSubKey)
    {
        if (!m_hdpa)
        {
            m_hdpa = DPA_CreateEx(5, NULL); // Choose arbitrary growth value
            if (!m_hdpa)
                return E_FAIL;
        }
        HKEY hkeyNew;
        LONG lRet = RegOpenKeyEx(hkey, szSubKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyNew);
        if (ERROR_SUCCESS != lRet)
            return E_FAIL;
        if (-1 == DPA_InsertPtr(m_hdpa, DPA_APPEND, hkeyNew))
        {
            RegCloseKey(hkeyNew);
            return E_FAIL;
        }
        m_count++;
        return S_OK;
    }
};

//
// 8/18/98 darrenmi
// Copied (and butchered) from shdocvw\util.cpp so we don't have to load it at startup
//
DWORD WCRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    DWORD dwType, dw = 0, dwSize = sizeof(DWORD);

    // we only handle NoChannelUI restriction
    if(rest != REST_NoChannelUI)
    {
        return 0;
    }

    // read registry setting
    SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions"),
            TEXT("NoChannelUI"),
            &dwType, &dw, &dwSize);

    return dw;
}


// ProcessInfodeliveryPolicies
//
// This is the main Admin API for Infodelivery.  It returns E_FAIL for errors,
// S_FALSE for nothing to process, and S_OK for correctly processed items.
//
// Reg key organization     [Modifications]         - the key to process
//                              [GUID1]             - group of actions
//                                  [AddChannels]   - sample action
//                                      [Channel1]  - element of an action
//
HRESULT ProcessInfodeliveryPolicies(void)
{
    HRESULT hr;
    CRegKey regModifications;
    TCHAR   szGUID[MAX_PATH];

    // Check if channels should be hidden.
    if (WCRestricted2W(REST_NoChannelUI, NULL, 0))
    {
        ShowChannelDirectories(FALSE);
    }
    else
    {
        ShowChannelDirectories(TRUE);
    }
    
    // Bail out quickly if there are no Modifications to perform. (Return S_FALSE)
    hr = regModifications.OpenForRead(HKEY_CURRENT_USER, c_szRegKeyModifications);
    if (FAILED(hr))
        return S_FALSE;

    // Prepare to use the CompletedModifications key.
    CRegKey regCompletedMods;
    hr = regCompletedMods.CreateForWrite(HKEY_CURRENT_USER, c_szRegKeyCompletedMods);
    if (FAILED(hr))
        return hr;

    hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Prepare queues of registry keys to actions
    CRegKeyDPA rgKeyQueue[ACTIONTABLECOUNT];

    // Enumerate the GUID keys, skipping the completed ones.
    // Enumerate the Actions beneath them and add them to queues.
    // ignoring errors here too.
    while (S_OK == regModifications.Next(szGUID))
    {
        DWORD dwValue;
        if (FAILED(regCompletedMods.GetValue(szGUID, &dwValue)))
        {
            CRegKey regGUID;
            TCHAR   szAction[MAX_PATH];
            hr = regGUID.OpenForRead(regModifications.GetKey(), szGUID);
            while (S_OK == regGUID.Next(szAction))
            {
                // Search the table to see if it's a key we understand.
                // If so, add it to the queue.
                int i;
                for (i = 0; i < ACTIONTABLECOUNT; i++)
                {
                    if (!StrCmpI(rgActionTable[i].szAction, szAction))
                    {
                        rgKeyQueue[i].Add(regGUID.GetKey(), szAction);
                        break;
                    }
                }
            }
        }
    }

    // Process all the keys we've accumulated.  (Correct order is assumed.)
    int i;
    for (i = 0; i < ACTIONTABLECOUNT; i++)
    {
        if (rgKeyQueue[i].GetCount())
        {
            int iKey;
            for (iKey = 0; iKey < rgKeyQueue[i].GetCount(); iKey++)
            {
                (rgActionTable[i].pfnAction)(rgKeyQueue[i].GetKey(iKey));
            }
        }
    }

    // Walk the GUIDs we've processed and mark them completed with the time.
    // Updating ones we skipped as well will help with garbage collection.
    regModifications.Reset();
    while (S_OK == regModifications.Next(szGUID))
    {
        SYSTEMTIME st;
        FILETIME ft;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        regCompletedMods.SetValue(szGUID, ft.dwHighDateTime);
    }

    // Delete the Actions.  NOTE: NT's RegDeleteKey() doesn't delete sub-keys.
    // This shlwapi API uses KEY_ALL_ACCESS.
    // We probably have to close all the keys here.
    SHDeleteKey(HKEY_CURRENT_USER, c_szRegKeyModifications);

    // If any channels were processed, tell the cache to reload.
    // We should only do this for default channels.
    if (rgKeyQueue[ACTIONTABLE_ADDCHANNELS].GetCount())
    {
        ASSERT(!StrCmpI(rgActionTable[ACTIONTABLE_ADDCHANNELS].szAction, c_szAddChannels));
        LoadUrlCacheContent();
    }

    CoUninitialize();

    return S_OK;
}

//
// ProcessAddChannels_SortCallback - sort in reverse order
//
int ProcessAddChannels_SortCallback(PVOID p1, PVOID p2, LPARAM lparam)
{
    return StrCmpI((LPTSTR)p2, (LPTSTR)p1);
}

//
// ProcessAddChannels
//
HRESULT ProcessAddChannels(HKEY hkey)
{
    // Enumerate the channels in the AddChannels key
    HRESULT hr;
    DWORD dwChannels;
    CRegKey regAdd;
    regAdd.SetKey(hkey);
    hr = regAdd.GetSubKeyCount(&dwChannels);
    if (SUCCEEDED(hr) && dwChannels)
    {
        // Check if the channels are the same code page as the system default.
        BOOL bCodePageMatch = TRUE;
        LCID lcidChannel = 0;
        if (SUCCEEDED(regAdd.GetValue(c_szLCID, &lcidChannel)))
        {
            TCHAR szCodePageSystem[8];
            TCHAR szCodePageChannel[8];
            szCodePageChannel[0] = 0;   // Init in case there's no locale info
            GetLocaleInfo(lcidChannel, LOCALE_IDEFAULTANSICODEPAGE, szCodePageChannel, ARRAYSIZE(szCodePageChannel));
            int iRet = GetLocaleInfo(GetSystemDefaultLCID(), LOCALE_IDEFAULTANSICODEPAGE, szCodePageSystem, ARRAYSIZE(szCodePageSystem));
            ASSERT(iRet);
            if (StrCmpI(szCodePageSystem, szCodePageChannel))
                bCodePageMatch = FALSE;
        }
    
        hr = E_FAIL;
        TCHAR *pch = (TCHAR *)MemAlloc(LMEM_FIXED, dwChannels * MAX_PATH * sizeof(TCHAR));
        if (pch)
        {
            HDPA hdpa = DPA_Create(dwChannels);
            if (hdpa)
            {
                DWORD i;
                TCHAR *pchCur = pch;
                for (i = 0; i < dwChannels; i++)
                {
                    if ((S_OK != regAdd.Next(pchCur)) || (-1 == DPA_InsertPtr(hdpa, DPA_APPEND, pchCur)))
                        break;
                    pchCur += MAX_PATH;
                }
                if (i >= dwChannels)
                {
                    // Sort channels by registry key name,
                    DPA_Sort(hdpa, ProcessAddChannels_SortCallback, 0);
                    // Now create them.
                    for (i = 0; i < dwChannels; i++)
                    {
                        BSTR bstrURL = NULL;
                        BSTR bstrTitle = NULL;
                        BSTR bstrLogo = NULL;
                        BSTR bstrWideLogo = NULL;
                        BSTR bstrIcon = NULL;
                        BSTR bstrPreloadURL = NULL;
                        DWORD dwCategory = 0;       // default to channel
                        DWORD dwChannelGuide = 0;   // default to not a guide
                        DWORD dwSoftware = 0;       // default to non-software channel
                        DWORD dwOffline = 0;
                        DWORD dwSynchronize = 0;
                        CRegKey regChannel;
                        regChannel.OpenForRead(hkey, (LPCTSTR)DPA_GetPtr(hdpa, i));
                        hr = regChannel.GetBSTRValue(c_szURL, &bstrURL);
                        hr = regChannel.GetBSTRValue(c_szTitle, &bstrTitle);
                        hr = regChannel.GetBSTRValue(c_szLogo, &bstrLogo);
                        hr = regChannel.GetBSTRValue(c_szWideLogo, &bstrWideLogo);
                        hr = regChannel.GetBSTRValue(c_szIcon, &bstrIcon);
                        hr = regChannel.GetBSTRValue(c_szPreloadURL, &bstrPreloadURL);
                        hr = regChannel.GetValue(c_szCategory, &dwCategory);
                        hr = regChannel.GetValue(c_szChannelGuide, &dwChannelGuide);
                        hr = regChannel.GetValue(c_szSoftware, &dwSoftware);
                        hr = regChannel.GetValue(c_szOffline, &dwOffline);
                        hr = regChannel.GetValue(c_szSynchronize, &dwSynchronize);
                        if (bstrTitle)
                        {
                            IChannelMgr *pChannelMgr = NULL;
                            hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
                            if (SUCCEEDED(hr))
                            {
                                // See if channel already exists - do nothing if it does (62976)
                                IEnumChannels *pEnumChannels = NULL;
                                if (SUCCEEDED(pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS, bstrURL, &pEnumChannels)))
                                {
                                    CHANNELENUMINFO Bogus={0};
                                    ULONG cFetched=0;

                                    if ((S_OK == pEnumChannels->Next(1, &Bogus, &cFetched)) && cFetched)
                                    {
                                        // Oops. It exists. Skip all this goo.
                                        hr = E_FAIL;
                                    }
                                }
                                SAFERELEASE(pEnumChannels);
                            }
                            if (SUCCEEDED(hr))
                            {
                                if (dwCategory && bCodePageMatch)
                                {
                                    // create a category (useless if code page doesn't match)
                                    CHANNELCATEGORYINFO csi = {0};
                                    csi.cbSize   = sizeof(csi);
                                    csi.pszURL   = bstrURL;
                                    csi.pszTitle = bstrTitle;
                                    csi.pszLogo  = bstrLogo;
                                    csi.pszIcon  = bstrIcon;
                                    csi.pszWideLogo = bstrWideLogo;
                                    hr = pChannelMgr->AddCategory(&csi);
                                }
                                else if (!dwCategory && bstrURL)
                                {
                                    // update the registry if it's a channel guide
                                    if (dwChannelGuide)
                                    {
                                        CRegKey reg;
                                        hr = reg.CreateForWrite(HKEY_CURRENT_USER, c_szRegKey);
                                        if (SUCCEEDED(hr))
                                            reg.SetBSTRValue(c_szChannelGuide, bstrTitle);
                                    }
                                    // tell wininet if there's preload content
                                    if (bstrPreloadURL)
                                    {
                                        CRegKey reg;
                                        hr = reg.CreateForWrite(HKEY_CURRENT_USER, c_szRegKeyCachePreload);
                                        if (SUCCEEDED(hr))
                                        {
                                            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                                            MyOleStrToStrN(szURL, ARRAYSIZE(szURL), bstrURL);
                                            reg.SetBSTRValue(szURL, bstrPreloadURL);
                                        }
                                    }
                                    // create a channel (use URL instead of Title if code page doesn't match)
                                    CHANNELSHORTCUTINFO csi = {0};
                                    csi.cbSize   = sizeof(csi);
                                    csi.pszURL   = bstrURL;
                                    if (bCodePageMatch)
                                        csi.pszTitle = bstrTitle;
                                    else
                                        csi.pszTitle = bstrURL;
                                    csi.pszLogo  = bstrLogo;
                                    csi.pszIcon  = bstrIcon;
                                    csi.pszWideLogo = bstrWideLogo;
                                    if (dwSoftware)
                                        csi.bIsSoftware = TRUE;
                                    hr = pChannelMgr->AddChannelShortcut(&csi);
                                }
                            }
                            SAFERELEASE(pChannelMgr);

                            if (dwOffline)
                            {
                                ISubscriptionMgr2 *pSubMgr2 = NULL;
                                hr = CoCreateInstance(CLSID_SubscriptionMgr, 
                                                      NULL, 
                                                      CLSCTX_INPROC_SERVER, 
                                                      IID_ISubscriptionMgr2, 
                                                      (void**)&pSubMgr2);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pSubMgr2->CreateSubscription(NULL, 
                                                                      bstrURL, 
                                                                      bstrTitle, 
                                                                      CREATESUBS_NOUI,
                                                                      SUBSTYPE_CHANNEL, 
                                                                      NULL);

                                    if (dwSynchronize)
                                    {
                                        BOOL bIsSubscribed;
                                        SUBSCRIPTIONCOOKIE cookie;

                                        if (SUCCEEDED(pSubMgr2->IsSubscribed(bstrURL, &bIsSubscribed))
                                            && bIsSubscribed &&
                                            SUCCEEDED(ReadCookieFromInetDB(bstrURL, &cookie)))
                                        {
                                            pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                                        }
                                    }
                                    pSubMgr2->Release();
                                }
                            }
                        }
                        SAFEFREEBSTR(bstrURL);
                        SAFEFREEBSTR(bstrTitle);
                        SAFEFREEBSTR(bstrLogo);
                        SAFEFREEBSTR(bstrWideLogo);
                        SAFEFREEBSTR(bstrIcon);
                        SAFEFREEBSTR(bstrPreloadURL);
                    }
                }
                DPA_Destroy(hdpa);
            }
            MemFree(pch);
        }
    }
    regAdd.SetKey(NULL);
    return S_OK;
}

//
// ProcessRemoveChannels
//
HRESULT ProcessRemoveChannels(HKEY hkey)
{
    // Enumerate the channel keys in the RemoveChannels key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szChannel[MAX_PATH];
    while (S_OK == reg.Next(szChannel))
    {
        CRegKey regChannel;
        DWORD dwNonActive = 0;  // default to deleting Active & NonActive channels
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        regChannel.OpenForRead(hkey, szChannel);
        regChannel.GetValue(c_szNonActive, &dwNonActive);
        if (SUCCEEDED(regChannel.GetStringValue(c_szURL, szURL, sizeof(szURL))))
        {
            // Check if the channel is Active to determine if we can delete it
            if (dwNonActive)
            {
                CRegKey regPreload;
                if (SUCCEEDED(regPreload.OpenForRead(HKEY_CURRENT_USER, c_szRegKeyCachePreload)))
                {
                    if (SUCCEEDED(regPreload.GetStringValue(szURL, NULL, 0)))
                    {
                        dwNonActive = 0;
                    }
                }
            }

            // Now delete the channel if appropriate
            if (!dwNonActive)
            {
                IChannelMgr *pChannelMgr = NULL;
                hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, (void**)&pChannelMgr);
                if (SUCCEEDED(hr))
                {
                    BSTR bstrURL;
                    if (SUCCEEDED(regChannel.GetBSTRValue(c_szURL, &bstrURL)))
                    {
                        IEnumChannels *pEnum;
                        hr = pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH, bstrURL, &pEnum);
                        if (SUCCEEDED(hr))
                        {
                            CHANNELENUMINFO info;
                            while (S_OK == pEnum->Next(1, &info, NULL))
                            {
                                hr = pChannelMgr->DeleteChannelShortcut(info.pszPath);
                                ASSERT(SUCCEEDED(hr));
                                CoTaskMemFree(info.pszPath);
                            }
                            pEnum->Release();
                        }
                        SysFreeString(bstrURL);
                    }
                    pChannelMgr->Release();
                }
            }    
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// ProcessAddSubscriptions
//
HRESULT ProcessAddSubscriptions(HKEY hkey)
{
    // Enumerate the subscription keys in the AddSubscriptions key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szSubscription[MAX_PATH];
    while (S_OK == reg.Next(szSubscription))
    {
        // Create the subscription
        // What if there is one already?
        CRegKey regSubscription;
        regSubscription.OpenForRead(hkey, szSubscription);
        BSTR bstrURL, bstrTitle, bstrGroup, bstrUsername, bstrPassword;
        DWORD dwSubType;
        DWORD dwSynchronize = 0;
        hr = regSubscription.GetBSTRValue(c_szURL, &bstrURL);
        hr = regSubscription.GetBSTRValue(c_szTitle, &bstrTitle);
        hr = regSubscription.GetBSTRValue(c_szScheduleGroup, &bstrGroup);
        hr = regSubscription.GetBSTRValue(c_szUsername, &bstrUsername);
        hr = regSubscription.GetBSTRValue(c_szPassword, &bstrPassword);
        hr = regSubscription.GetValue(c_szSynchronize, &dwSynchronize);
        if (bstrURL && bstrTitle && bstrGroup && SUCCEEDED(regSubscription.GetValue(c_szSubscriptionType, &dwSubType)))
        {
            SUBSCRIPTIONINFO si = {0};
            si.cbSize = sizeof(SUBSCRIPTIONINFO);
            si.fUpdateFlags = SUBSINFO_SCHEDULE;
            if (bstrUsername && bstrPassword)
            {
                si.fUpdateFlags |= (SUBSINFO_USER | SUBSINFO_PASSWORD);
                si.bstrUserName = bstrUsername;
                si.bstrPassword = bstrPassword;
            }
            if (dwSubType == SUBSTYPE_CHANNEL || dwSubType == SUBSTYPE_DESKTOPCHANNEL)
            {
                si.fUpdateFlags |= SUBSINFO_CHANNELFLAGS;
                si.fChannelFlags = 0;   //  Notify only.
            }

            if (SUCCEEDED(hr))
            {
                ISubscriptionMgr2 *pSubMgr2 = NULL;
                hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr2, (void**)&pSubMgr2);
                if (SUCCEEDED(hr))
                {
                    hr = pSubMgr2->CreateSubscription(NULL, bstrURL, bstrTitle, CREATESUBS_NOUI,
                                                     (SUBSCRIPTIONTYPE)dwSubType, &si);
                    if (dwSynchronize)
                    {
                        BOOL bIsSubscribed;
                        SUBSCRIPTIONCOOKIE cookie;

                        if (SUCCEEDED(pSubMgr2->IsSubscribed(bstrURL, &bIsSubscribed)) && 
                            bIsSubscribed &&
                            SUCCEEDED(ReadCookieFromInetDB(bstrURL, &cookie)))
                        {
                            pSubMgr2->UpdateItems(SUBSMGRUPDATE_MINIMIZE, 1, &cookie);
                        }
                    }

                    pSubMgr2->Release();
                }
            }
        }
        SAFEFREEBSTR(bstrURL);
        SAFEFREEBSTR(bstrTitle);
        SAFEFREEBSTR(bstrGroup);
        SAFEFREEBSTR(bstrUsername);
        SAFEFREEBSTR(bstrPassword);
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// ProcessRemoveSubscriptions
//
HRESULT ProcessRemoveSubscriptions(HKEY hkey)
{
    // Enumerate the subscription keys in the RemoveSubscriptions key
    HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szSubscription[MAX_PATH];
    while (S_OK == reg.Next(szSubscription))
    {
        // Find the URL to delete
        CRegKey regSubscription;
        regSubscription.OpenForRead(hkey, szSubscription);
        BSTR bstrURL;
        if (SUCCEEDED(regSubscription.GetBSTRValue(c_szURL, &bstrURL)))
        {
            ISubscriptionMgr *pSubMgr = NULL;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&pSubMgr);
            if (SUCCEEDED(hr))
            {
                hr = pSubMgr->DeleteSubscription(bstrURL, NULL);
                pSubMgr->Release();
            }
            SysFreeString(bstrURL);
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}

//
// PRIVATE VERSION HANDLING CODE - REVIEW THIS CODE SHOULD HAVE BEEN STOLEN 
// FROM SETUP
//
struct MYVERSION
{
    DWORD dw1;  // most sig version number
    DWORD dw2;
    DWORD dw3;
    DWORD dw4;  // least sig version number
};

int CompareDW(DWORD dw1, DWORD dw2)
{
    if (dw1 > dw2)
        return 1;
    if (dw1 < dw2)
        return -1;

    return 0;
}

int CompareVersion(MYVERSION * pv1, MYVERSION * pv2)
{
    int rv;

    rv = CompareDW(pv1->dw1, pv2->dw1);

    if (rv == 0)
    {
        rv = CompareDW(pv1->dw2, pv2->dw2);

        if (rv == 0)
        {
            rv = CompareDW(pv1->dw3, pv2->dw3);

            if (rv == 0)
            {
                rv = CompareDW(pv1->dw4, pv2->dw4);
            }
        }
    }

    return rv;
}

//
// Returns TRUE if an INT was parsed and *pwsz is NOT NULL
// if a . was found
//
BOOL GetDWORDFromStringAndAdvancePtr(DWORD *pdw, LPWSTR *pwsz)
{
    if (!StrToIntExW(*pwsz, 0, (int *)pdw))
        return FALSE;

    *pwsz = StrChrW(*pwsz, L'.');

    if (*pwsz)
        *pwsz = *pwsz +1;

    return TRUE;
}

BOOL GetVersionFromString(MYVERSION *pver, LPWSTR pwsz)
{
    BOOL rv;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw1, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw2, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw3, &pwsz);
    if (!rv || pwsz == NULL)
        return FALSE;

    rv = GetDWORDFromStringAndAdvancePtr(&pver->dw4, &pwsz);
    if (!rv)
        return FALSE;

    return TRUE;
}

//
// ProcessRemoveAllChannels
//
HRESULT ProcessRemoveAllChannels(HKEY hkey)
{
    HRESULT hr;
    HINSTANCE hAdvPack = NULL;
    DELNODE pfDELNODE = NULL;
    IChannelMgrPriv *pChannelMgrPriv = NULL;
    CRegKey regAdd;
    regAdd.SetKey(hkey);
    TCHAR szChannelFolder[MAX_PATH];

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgrPriv, (void**)&pChannelMgrPriv);
    if (FAILED(hr))
    {
        goto Exit;
    }

    if ((hAdvPack = LoadLibrary(TEXT("advpack.dll"))) != NULL) 
    {
        pfDELNODE = (DELNODE)GetProcAddress( hAdvPack, "DelNode");
        if (!pfDELNODE) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Loop Through Channel Folders to delete
    while (S_OK == regAdd.Next(szChannelFolder))
    {
        DWORD dwSoftware = 0, dwChannelGuide = 0;
        CRegKey regChannelFolder;
 
        CHAR szChannelPath[MAX_PATH];
        TCHAR szChannelPathT[MAX_PATH];
        TCHAR szFavsT[MAX_PATH]; //Retrieve Unicode data from registry

        BSTR bstrOldIEVersion = NULL;
        BOOL bVersion = TRUE;
        regChannelFolder.OpenForRead(hkey, szChannelFolder);
        
        // Check whether old IE version is correct.
        hr = regChannelFolder.GetBSTRValue(c_szOldIEVersion, &bstrOldIEVersion);
        if (SUCCEEDED(hr) && bstrOldIEVersion)
        {
            CRegKey regKeyIESetup;
            hr = regKeyIESetup.OpenForRead(HKEY_LOCAL_MACHINE, c_szRegKeyIESetup);
    
            if (SUCCEEDED(hr))
            {
                BSTR bstrRealOldIEVersion = NULL;
                hr = regKeyIESetup.GetBSTRValue(c_szOldIEVersion, &bstrRealOldIEVersion);
                if (SUCCEEDED(hr) && bstrRealOldIEVersion)
                {
                    MYVERSION verOldIEVersion, verRealOldIEVersion;

                    if (GetVersionFromString(&verOldIEVersion,     bstrOldIEVersion) &&
                        GetVersionFromString(&verRealOldIEVersion, bstrRealOldIEVersion))
                    {
                        //
                        // If the old version of IE that was on this machine (verRealOldIEVersion)
                        // is infact NEWER than the old version number in the CABs that we want to 
                        // delete (verOldIEVersion) then dont blow away old channel folder.
                        // Otherwise default to blow away channels.
                        //
                        if (CompareVersion(&verRealOldIEVersion, &verOldIEVersion) > 0)
                        {
                            bVersion = FALSE;
                        }
                    }

                    SAFEFREEBSTR(bstrRealOldIEVersion);
                }
            }
            SAFEFREEBSTR(bstrOldIEVersion);
        }

        if (!bVersion)
        {
            continue;
        }
        
        hr = regChannelFolder.GetValue(c_szChannelGuide, &dwChannelGuide);
        if (FAILED(hr) || (SUCCEEDED(hr) && !dwChannelGuide))
        {
            if (SUCCEEDED(pChannelMgrPriv->GetChannelFolderPath(szChannelPath, MAX_PATH, IChannelMgrPriv::CF_CHANNEL)))
            {
                // Retrieve Favorites Path from registry
                if (SUCCEEDED(Channel_GetBasePath((LPTSTR)szFavsT, ARRAYSIZE(szFavsT))))
                {   
                    // Convert from ANSI
                    SHAnsiToTChar(szChannelPath, szChannelPathT, ARRAYSIZE(szChannelPathT));
                    // If channel folder doesn't exist, then szChannelPath will contain the Favorites path.
                    // Don't delete the entries.
                    if (StrCmpI(szFavsT, szChannelPathT))
                       pfDELNODE(szChannelPath, ADN_DONT_DEL_DIR);
                }
            }
        }

        hr = regChannelFolder.GetValue(c_szSoftware, &dwSoftware);
        if (FAILED(hr) || (SUCCEEDED(hr) && !dwSoftware))
        {
            if (SUCCEEDED(pChannelMgrPriv->GetChannelFolderPath(szChannelPath, MAX_PATH, IChannelMgrPriv::CF_SOFTWAREUPDATE)))
            {
                pfDELNODE(szChannelPath, ADN_DONT_DEL_DIR);
            }
        }

        hr = S_OK;                        
    }
    regAdd.SetKey(NULL);

Exit:
    SAFERELEASE(pChannelMgrPriv);
    
    if (hAdvPack) {
        FreeLibrary(hAdvPack);
    }

    return hr;
}

//
// ProcessRemoveDesktopComponents
//
HRESULT ProcessRemoveDesktopComponents(HKEY hkey)
{
    // Enumerate the component keys in the ProcessRemoveDesktopComponents key
    // HRESULT hr;
    CRegKey reg;
    reg.SetKey(hkey);
    TCHAR szComponent[MAX_PATH];
    while (S_OK == reg.Next(szComponent))
    {
        // Find the URL to delete
        CRegKey regComponent;
        regComponent.OpenForRead(hkey, szComponent);
        BSTR bstrURL;
        if (SUCCEEDED(regComponent.GetBSTRValue(c_szURL, &bstrURL)))
        {
            SysFreeString(bstrURL);
        }
    }
    reg.SetKey(NULL);
    return S_OK;
}


//
// NoChannelUI processing.
//

#define SHELLFOLDERS \
   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")


typedef enum _tagXMLDOCTYPE {
    DOC_CHANNEL,
    DOC_SOFTWAREUPDATE
} XMLDOCTYPE;

//
// Get the path to the favorites directory.
//
HRESULT Channel_GetBasePath(LPTSTR pszPath, int cch)
{
    ASSERT(pszPath || 0 == cch);

    DWORD cbPath = cch * sizeof(TCHAR);

    return SHRegGetValue(HKEY_CURRENT_USER, SHELLFOLDERS, TEXT("Favorites"), SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, pszPath, &cbPath) == ERROR_SUCCESS
        ? S_OK
        : E_FAIL;
}

HRESULT Channel_GetFolder(LPTSTR pszPath, XMLDOCTYPE xdt )
{
    TCHAR   szFavs[MAX_PATH];
    TCHAR   szChannel[MAX_PATH];
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(Channel_GetBasePath(szFavs, ARRAYSIZE(szFavs))))
    {
        //
        // Get the potentially localized name of the Channel folder from
        // tack this on the Favorites path 
        //
        MLLoadString(
                   ((xdt == DOC_CHANNEL)? IDS_CHANNEL_FOLDER : IDS_SOFTWAREUPDATE_FOLDER),
                   szChannel, MAX_PATH);
        PathCombine(pszPath, szFavs, szChannel);

        hr = S_OK;
    }
    return hr;
}

//
// Set/Clear the "hidden" attribute of a channel directory.
//

void ShowChannelDirectory(BOOL fShow, XMLDOCTYPE xdt)
{
    TCHAR szPath[MAX_PATH];
    DWORD dwAttributes;

    if (SUCCEEDED(Channel_GetFolder(szPath, xdt)))
    {
        dwAttributes = GetFileAttributes(szPath);
        
        if (0xffffffff != dwAttributes)
        {
            if (fShow && (dwAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                SetFileAttributes(szPath, dwAttributes & ~FILE_ATTRIBUTE_HIDDEN);
            }
            else if (!fShow && !(dwAttributes & FILE_ATTRIBUTE_HIDDEN))
            {
                SetFileAttributes(szPath, dwAttributes | FILE_ATTRIBUTE_HIDDEN);
            }
        }
    }
}

//
// Hide or show channel directories
//

void ShowChannelDirectories(BOOL fShow)
{
    ShowChannelDirectory(fShow, DOC_CHANNEL);
    ShowChannelDirectory(fShow, DOC_SOFTWAREUPDATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdfagent.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "downld.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "helper.h"
#include "shguidp.h"    // IID_IChannelMgrPriv

#undef TF_THISMODULE
#define TF_THISMODULE   TF_CDFAGENT


const int MINUTES_PER_DAY = 24 * 60;


//==============================================================================
// Convert an XML OM to a TaskTrigger by looking for and converting <schedule>
//==============================================================================
// returns S_OK if succeeded. (S_FALSE if succeeded but TASK_TRIGGER was truncated).
// returns E_FAIL if no task trigger retrieved (returned *ptt is invalid TASK_TRIGGER)
//  You Must fill in ptt->cbTriggerSize!!!
// User can pass in Schedule element itself, or any parent element, in pRootEle
HRESULT XMLScheduleElementToTaskTrigger(IXMLElement *pRootEle, TASK_TRIGGER *ptt)
{
    HRESULT hr = E_FAIL;

    if (!pRootEle || !ptt)
        return E_INVALIDARG;

    ASSERT(ptt->cbTriggerSize == sizeof(TASK_TRIGGER));

    CExtractSchedule *pSched = new CExtractSchedule(pRootEle, NULL);

    if (pSched)
    {
        if (SUCCEEDED(pSched->Run()))
        {
            hr = pSched->GetTaskTrigger(ptt);
        }

        delete pSched;
    }

    return hr;
}

// CExtractSchedule doesn't get used during channel update
//  It's just used to traverse the OM and find the first Schedule tag, to
//   parse out the schedule info
CExtractSchedule::CExtractSchedule(IXMLElement *pEle, CExtractSchedule *pExtractRoot) :
        CProcessElement(NULL, NULL, pEle)
{
    m_pExtractRoot = pExtractRoot;
    if (!pExtractRoot)
        m_pExtractRoot = this;
}

HRESULT CExtractSchedule::Run()
{
    // Allow user to pass in Schedule element itself, or Root element
    BSTR bstrItem=NULL;
    HRESULT hr;

    m_pElement->get_tagName(&bstrItem);

    if (bstrItem && *bstrItem && !StrCmpIW(bstrItem, L"Schedule"))
    {
        hr = ProcessItemInEnum(bstrItem, m_pElement);
    }
    else
    {
        hr = CProcessElement::Run();
    }

    SysFreeString(bstrItem);
    return hr;
}

HRESULT CExtractSchedule::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"Schedule"))
    {
        CProcessSchedule *pPS = new CProcessSchedule(this, NULL, pItem);
        if (pPS)
        {
            pPS->Run();

            if (pPS->m_tt.cbTriggerSize)
            {
                ASSERT(pPS->m_tt.cbTriggerSize == sizeof(m_tt));
                m_pExtractRoot->m_tt = pPS->m_tt;
            }

            delete pPS;
        }
        return E_ABORT; // abort our enumerations
    }
    else if (!StrCmpIW(pwszTagName, L"Channel"))
    {
        return DoChild(new CExtractSchedule(pItem, m_pExtractRoot));
    }

    return S_OK;    // ignore other tags
}

HRESULT CExtractSchedule::GetTaskTrigger(TASK_TRIGGER *ptt)
{
    if ((0 == m_tt.cbTriggerSize) ||            // No task trigger
        (0 == m_tt.wBeginYear))                 // Invalid task trigger
    {
        return E_FAIL;
    }

    if (m_tt.cbTriggerSize <= ptt->cbTriggerSize)
    {
        *ptt = m_tt;
        return S_OK;
    }

    WORD cbTriggerSize = ptt->cbTriggerSize;

    CopyMemory(ptt, &m_tt, cbTriggerSize);
    ptt->cbTriggerSize = cbTriggerSize;

    return S_FALSE;
}

//==============================================================================
// XML OM Helper functions
//==============================================================================
HRESULT GetXMLAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, VARIANT *pvRet)
{
    BSTR bstrName=NULL;
    HRESULT hr=E_FAIL;

    pvRet->vt = VT_EMPTY;
    bstrName = SysAllocString(pwszAttribute);
    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, pvRet)))
    {
        hr = S_OK;
    }
    SysFreeString(bstrName);
    return hr;
}

HRESULT GetXMLStringAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, BSTR *pbstrRet)
{
    VARIANT var;
    BSTR bstrName=NULL;
    HRESULT hr=E_FAIL;

    *pbstrRet = NULL;

    var.vt = VT_EMPTY;
    bstrName = SysAllocString(pwszAttribute);
    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, &var)))
    {
        if (var.vt == VT_BSTR && var.bstrVal != NULL)
        {
            *pbstrRet = var.bstrVal;

            hr = S_OK;
        }
    }
    SysFreeString(bstrName);
    if (FAILED(hr) && var.vt != VT_EMPTY)
        VariantClear(&var);

    return hr;
}

DWORD GetXMLDwordAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, DWORD dwDefault)
{
    VARIANT var;

    if (SUCCEEDED(GetXMLAttribute(pItem, pwszAttribute, &var)))
    {
        if (var.vt == VT_I4)
            return var.lVal;

        if (var.vt == VT_I2)
            return var.iVal;

        if (var.vt == VT_BSTR)
        {
            LPCWSTR pwsz = var.bstrVal;
            DWORD   dwRet;

            if (!StrToIntExW(pwsz, 0, (int *)&dwRet))
                dwRet = dwDefault;

            SysFreeString(var.bstrVal);
            return dwRet;
        }

        VariantClear(&var);
    }

    return dwDefault;
}

// If failure return code, *pfRet wasn't changed
HRESULT GetXMLBoolAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, BOOL *pfRet)
{
    VARIANT var;
    HRESULT hr=E_FAIL;

    if (SUCCEEDED(GetXMLAttribute(pItem, pwszAttribute, &var)))
    {
        if (var.vt == VT_BOOL)
        {
            *pfRet = (var.boolVal == VARIANT_TRUE);
            hr = S_OK;
        }
        else if (var.vt == VT_BSTR)
        {
            if (!StrCmpIW(var.bstrVal, L"YES") ||
                !StrCmpIW(var.bstrVal, L"\"YES\""))
            {
                *pfRet = TRUE;
                hr = S_OK;
            }
            else if (!StrCmpIW(var.bstrVal, L"NO") ||
                     !StrCmpIW(var.bstrVal, L"\"NO\""))
            {
                *pfRet = FALSE;
                hr = S_OK;
            }
        }
        else
            hr = E_FAIL;

        VariantClear(&var);
    }

    return hr;
}

HRESULT GetXMLTimeAttributes(IXMLElement *pItem, CDF_TIME *pTime)
{
    pTime->wReserved = 0;

    pTime->wDay = (WORD)  GetXMLDwordAttribute(pItem, L"DAY", 0);
    pTime->wHour = (WORD) GetXMLDwordAttribute(pItem, L"HOUR", 0);
    pTime->wMin = (WORD)  GetXMLDwordAttribute(pItem, L"MIN", 0);

    pTime->dwConvertedMinutes = (24 * 60 * pTime->wDay) +
                                (     60 * pTime->wHour) +
                                (          pTime->wMin);

    return S_OK;
}

inline BOOL IsNumber(WCHAR x) { return (x >= L'0' && x <= L'9'); }

HRESULT GetXMLTimeZoneAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, int *piRet)
{
    BSTR    bstrVal;
    HRESULT hrRet = E_FAIL;

    ASSERT(pItem && piRet);

    if (SUCCEEDED(GetXMLStringAttribute(pItem, pwszAttribute, &bstrVal)))
    {
        if(bstrVal && bstrVal[0] &&
            IsNumber(bstrVal[1]) && IsNumber(bstrVal[2]) &&
            IsNumber(bstrVal[3]) && IsNumber(bstrVal[4]))
        {
            *piRet  =   1000*(bstrVal[1] - L'0') +
                         100*(bstrVal[2] - L'0') +
                          10*(bstrVal[3] - L'0') +
                              bstrVal[4] - L'0';

            hrRet = S_OK;
        }
        if(bstrVal[0] == L'-')
            *piRet *= -1;
    }

    SysFreeString(bstrVal);

    return hrRet;
}

//==============================================================================
// TEMP fn to convert ISO 1234:5678 to SYSTEMTIME
// ISODateToSystemTime returns false if there is a parse error
// true if there isn't
//==============================================================================
BOOL ValidateSystemTime(SYSTEMTIME *time)
{
    // IE6 27665. Some incompetent XML file writers provide slightly invalid dates, like 9-31-01. 
    // Everybody knows that September has 30 days. Anyway, we'll do some minimal fix-up here.
    switch (time->wMonth)
    {
    case 2: // February
        // Rule is, every four years is a leap year, except for centuries.
        if ((time->wYear % 4) || ((time->wYear % 100)==0))
        {
            if (time->wDay > 28)
            {
                time->wDay = 28;
            }
        } 
        else if (time->wDay > 29)
        {
            time->wDay = 29;
        }
        break;

    case 1: // January
    case 3: // March
    case 5: // May
    case 7: // July
    case 8: // August
    case 10: // October
    case 12: // December
        if (time->wDay>31)
        {
            time->wDay = 31;
        }
        break;

    default: // the other 4 months. These have 30 days, apparently.
        if (time->wDay>30)
        {
            time->wDay = 30;
        }
        break;
    }

    return TRUE;
}


// yyyy-mm-dd[Thh:mm[+zzzz]]
BOOL ISODateToSystemTime(LPCWSTR string, SYSTEMTIME *time, long *timezone)
{
    if (!string || (lstrlenW(string) < 10) || !time)
        return FALSE;

    ZeroMemory(time, sizeof(SYSTEMTIME));

    if (timezone)
        *timezone = 0;

    if (IsNumber(string[0]) &&
        IsNumber(string[1]) &&
        IsNumber(string[2]) &&
        IsNumber(string[3]) &&
       (string[4] != L'\0') &&
        IsNumber(string[5]) &&
        IsNumber(string[6]) &&
       (string[7] != L'\0') &&
        IsNumber(string[8]) &&
        IsNumber(string[9]))
    {
        time->wYear = 1000*(string[0] - L'0') +
                       100*(string[1] - L'0') +
                        10*(string[2] - L'0') +
                            string[3] - L'0';

        time->wMonth = 10*(string[5] - L'0') + string[6] - L'0';

        time->wDay = 10*(string[8] - L'0') + string[9] - L'0';
    }
    else
    {
        return FALSE;
    }

    if ((string[10]!= L'\0') &&
        IsNumber(string[11]) &&
        IsNumber(string[12]) &&
       (string[13] != L'\0') &&
        IsNumber(string[14]) &&
        IsNumber(string[15]))
    {
        time->wHour   = 10*(string[11] - L'0') + string[12] - L'0';
        time->wMinute = 10*(string[14] - L'0') + string[15] - L'0';

        if (timezone &&
            (string[16]!= L'\0') &&
            IsNumber(string[17]) &&
            IsNumber(string[18]) &&
            IsNumber(string[19]) &&
            IsNumber(string[20]))
        {
            *timezone  =    1000*(string[17] - L'0') +
                            100*(string[18] - L'0') +
                            10*(string[19] - L'0') +
                            string[20] - L'0';

            if(string[16] == L'-')
                *timezone = - *timezone;
        }
    }

    return ValidateSystemTime(time);
}


//==============================================================================
// CProcessElement class provides generic support for sync or async enumeration
//   of an XML OM
//==============================================================================
CProcessElement::CProcessElement(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pEle)
{
    ASSERT(m_pRunAgent == NULL && m_pCurChild == NULL && m_pCollection == NULL);
        
    m_pElement = pEle; pEle->AddRef();
    m_pRoot = pRoot;
    m_pParent = pParent;
}

CProcessElement::~CProcessElement()
{
    ASSERT(!m_pCurChild);

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    SAFERELEASE(m_pCollection);
    SAFERELEASE(m_pElement);
    SAFERELEASE(m_pChildElement);
}

HRESULT CProcessElement::Pause(DWORD dwFlags)
{
    if (m_pCurChild)
        return m_pCurChild->Pause(dwFlags);

    ASSERT(m_pRunAgent);

    if (m_pRunAgent)
        return m_pRunAgent->AgentPause(dwFlags);

    return E_FAIL;
}

HRESULT CProcessElement::Resume(DWORD dwFlags)
{
    if (m_pCurChild)
        return m_pCurChild->Resume(dwFlags);

    if (m_pRunAgent)
        m_pRunAgent->AgentResume(dwFlags);
    else
        DoEnumeration();

    return S_OK;
}

HRESULT CProcessElement::Abort(DWORD dwFlags)
{
    if (m_pCurChild)
    {
        m_pCurChild->Abort(dwFlags);
        SAFEDELETE(m_pCurChild);
    }
    if (m_pRunAgent)
    {
        // Prevent reentrancy into OnAgentEnd
        m_pRunAgent->LeaveMeAlone();
        m_pRunAgent->AgentAbort(dwFlags);
        CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }

    return S_OK;
}


HRESULT CProcessElement::Run()
{
    ASSERT(!m_pCollection);
    ASSERT(m_lMax == 0);
//  ASSERT(m_fSentEnumerationComplete == FALSE);    // DoEnumeration may have sent this

    m_lIndex = 0;

    if (SUCCEEDED(m_pElement->get_children(&m_pCollection)) && m_pCollection)
    {
        m_pCollection->get_length(&m_lMax);
    }
    else
        m_lMax = 0;

    return DoEnumeration(); // Will call OnChildDone when appropriate
}

HRESULT CProcessElement::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    // Our delivery agent is done. Continue enumeration
    ASSERT(!m_pCurChild);

    if (lSizeDownloaded > 0)
        m_pRoot->m_dwCurSizeKB += (ULONG) lSizeDownloaded;

    TraceMsg(TF_THISMODULE, "ChannelAgent up to %dkb of %dkb", m_pRoot->m_dwCurSizeKB, m_pRoot->m_pChannelAgent->m_dwMaxSizeKB);

    if ((hrResult == INET_E_AGENT_MAX_SIZE_EXCEEDED) ||
        (hrResult == INET_E_AGENT_CACHE_SIZE_EXCEEDED))
    {
        DBG("CProcessElement got max size or cache size exceeded; not running any more delivery agents");

        m_pRoot->m_fMaxSizeExceeded = TRUE;
        m_pRoot->m_pChannelAgent->SetEndStatus(hrResult);
    }

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    if (fSynchronous)
    {
        // we are still in our DoDeliveryAgent call. Let it return out through there.
        return S_OK;
    }

    // Continue enumeration, or start enumeration if we haven't yet.
    if (m_fStartedEnumeration)
        DoEnumeration();
    else
        Run();

    return S_OK;
}

HRESULT CProcessElement::DoEnumeration()
{
    IDispatch   *pDisp;
    IXMLElement *pItem;
    BSTR        bstrTagName;
    VARIANT     vIndex, vEmpty;
    HRESULT     hr = S_OK;
    BOOL        fStarted = FALSE;

    m_fStartedEnumeration = TRUE;

    ASSERT(m_pCollection || !m_lMax);

    if (m_pRoot && m_pRoot->IsPaused())
    {
        DBG("CProcessElement::DoEnumeration returning E_PENDING, we're paused");
        return E_PENDING;
    }

    vEmpty.vt = VT_EMPTY;

    for (; (m_lIndex < m_lMax) && !fStarted && (hr != E_ABORT); m_lIndex++)
    {
        vIndex.vt = VT_UI4;
        vIndex.lVal = m_lIndex;

        if (SUCCEEDED(m_pCollection->item(vIndex, vEmpty, &pDisp)))
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IXMLElement, (void **)&pItem)))
            {
                if (SUCCEEDED(pItem->get_tagName(&bstrTagName)) && bstrTagName)
                {
                    SAFERELEASE(m_pChildElement);
                    m_pChildElement=pItem;
                    m_pChildElement->AddRef();

                    hr = ProcessItemInEnum(bstrTagName, pItem);
                    SysFreeString(bstrTagName);
                    if (hr == E_PENDING)
                        fStarted = TRUE;
                }
                pItem->Release();
            }
            pDisp->Release();
        }
    }

    // Tell this instance we're done with enumeration, unless we already have
    if (!fStarted && !m_fSentEnumerationComplete)
    {
        m_fSentEnumerationComplete = TRUE;
        hr = EnumerationComplete();     // WARNING this eats E_ABORT
        if (hr == E_PENDING)
            fStarted = TRUE;
    }

    // Notify our parent if we're done with our enumeration,
    if (!fStarted)
    {
        if (m_pParent)  // Check for CExtractSchedule
            m_pParent->OnChildDone(this, hr); // This may delete us
    }

    if (hr == E_ABORT)
        return E_ABORT;

    return (fStarted) ? E_PENDING : S_OK;
}

HRESULT CProcessElement::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    ASSERT(pChild && (!m_pCurChild || (pChild == m_pCurChild)));

    if (m_pCurChild)
    {
        // A child returned from async operation.
        SAFEDELETE(m_pCurChild);

        // Continue enumeration. This will call our parent's ChildDone if it
        //  finishes, so it may delete us.
        DoEnumeration();
    }
    else
    {
        // Our child has finished synchronously. Ignore (DoChild() will take care of it).
    }

    return S_OK;
}

HRESULT CProcessElement::DoChild(CProcessElement *pChild)
{
    HRESULT hr;

    ASSERT(m_pCurChild == NULL);

    if (!pChild)
        return E_POINTER;   // FEATURE should call parent's OnChildDone here

    hr = pChild->Run();

    if (hr == E_PENDING)
    {
        // Returned async. Will call back OnChildDone.
        m_pCurChild = pChild;
        return E_PENDING;
    }

    // Synchronously returned. Clean up.
    delete pChild;

    return hr;
}

// E_PENDING if async operation started
HRESULT CProcessElement::DoDeliveryAgent(ISubscriptionItem *pItem, REFCLSID rclsid, LPCWSTR pwszURL)
{
    ASSERT(pItem);

    HRESULT hr=E_FAIL;

    if (m_pRoot->m_fMaxSizeExceeded)
    {
//      DBG("CProcessElement::RunDeliveryAgent failing; exceeded max size.");
        return E_FAIL;
    }

    if (m_pRunAgent)
    {
        DBG_WARN("CProcessElement::DoDeliveryAgent already running!");
        return E_FAIL;
    }

    m_pRunAgent = new CChannelAgentHolder(m_pRoot->m_pChannelAgent, this);

    if (m_pRunAgent)
    {
        hr = m_pRunAgent->Init(this, pItem, rclsid);

        if (SUCCEEDED(hr))
            hr = m_pRunAgent->StartAgent();

        if (hr == E_PENDING)
        {
            m_pRoot->m_pChannelAgent->SendUpdateProgress(pwszURL, ++(m_pRoot->m_iTotalStarted), -1, m_pRoot->m_dwCurSizeKB);
        }
        else
            CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CProcessElement::DoSoftDist(IXMLElement *pItem)
{
HRESULT hr = S_OK;
ISubscriptionItem *pSubsItem;

    if (SUCCEEDED(m_pRoot->CreateStartItem(&pSubsItem)))
    {
        if (pSubsItem)
        {
            hr = DoDeliveryAgent(pSubsItem, CLSID_CDLAgent);
            pSubsItem->Release();
        }
    }
    return hr;
}

HRESULT CProcessElement::DoWebCrawl(IXMLElement *pItem, LPCWSTR pwszURL /* = NULL */)
{
    BSTR bstrURL=NULL, bstrTmp=NULL;
    HRESULT hr = S_OK;
    ISubscriptionItem *pSubsItem;
    DWORD   dwLevels=0, dwFlags;
    LPWSTR  pwszUrl2=NULL;
    BOOL    fOffline=FALSE;

    if (!pwszURL && SUCCEEDED(GetXMLStringAttribute(pItem, L"HREF", &bstrURL)) && bstrURL)
        pwszURL = bstrURL;

    if (pwszURL)
    {
        SYSTEMTIME  stLastMod;
        long        lTimezone;

        hr = CombineWithBaseUrl(pwszURL, &pwszUrl2);

        if (SUCCEEDED(hr) && pwszUrl2)
            pwszURL = pwszUrl2;     // Got a new URL

        hr = CUrlDownload::IsValidURL(pwszURL);

        if (SUCCEEDED(hr) &&
            SUCCEEDED(GetXMLStringAttribute(m_pElement, L"LastMod", &bstrTmp)) &&
            ISODateToSystemTime(bstrTmp, &stLastMod, &lTimezone))
        {
            // Check Last Modified time
            TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH];
            char    chBuf[MY_MAX_CACHE_ENTRY_INFO];
            DWORD   dwBufSize = sizeof(chBuf);
            LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszURL);
            hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, 0);

            if (SUCCEEDED(hr))
            {
                FILETIME ft;

                if (SystemTimeToFileTime(&stLastMod, &ft))
                {
                    // APPCOMPAT: In an ideal world, all servers would support LastModifiedTime accurately.
                    // In our world, some do not support it and wininet returns a value of zero.
                    // Without maintaining checksums of the files, we have two options: always download
                    // the URL or never update it. Since it would be odd not to update it, we always do.
                    if ((lpInfo->LastModifiedTime.dwHighDateTime || lpInfo->LastModifiedTime.dwLowDateTime)
                        && (lpInfo->LastModifiedTime.dwHighDateTime >= ft.dwHighDateTime)
                        && ((lpInfo->LastModifiedTime.dwHighDateTime > ft.dwHighDateTime)
                         || (lpInfo->LastModifiedTime.dwLowDateTime >= ft.dwLowDateTime)))
                    {
                        // Skip it.
                        TraceMsg(TF_THISMODULE, "Running webcrawl OFFLINE due to Last Modified time URL=%ws", pwszURL);
                        fOffline = TRUE;
                    }
                }
            }

            hr = S_OK;
        }

        SAFEFREEBSTR(bstrTmp);

        if (SUCCEEDED(hr) && SUCCEEDED(m_pRoot->CreateStartItem(&pSubsItem)))
        {
            WriteOLESTR(pSubsItem, c_szPropURL, pwszURL);

            dwLevels = GetXMLDwordAttribute(pItem, L"LEVEL", 0);
            if (dwLevels && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME))
            {
                // Note: MaxChannelLevels is stored as N+1 because 0
                // means the restriction is disabled.
                DWORD dwMaxLevels = SHRestricted2W(REST_MaxChannelLevels, NULL, 0);
                if (!dwMaxLevels)
                    dwMaxLevels = MAX_CDF_CRAWL_LEVELS + 1;
                if (dwLevels >= dwMaxLevels)
                    dwLevels = dwMaxLevels - 1;
                WriteDWORD(pSubsItem, c_szPropCrawlLevels, dwLevels);
            }

            if (fOffline)
            {
                if (SUCCEEDED(ReadDWORD(pSubsItem, c_szPropCrawlFlags, &dwFlags)))
                {
                    dwFlags |= CWebCrawler::WEBCRAWL_PRIV_OFFLINE_MODE;
                    WriteDWORD(pSubsItem, c_szPropCrawlFlags, dwFlags);
                }
            }

            hr = DoDeliveryAgent(pSubsItem, CLSID_WebCrawlerAgent, pwszURL);
            
            SAFERELEASE(pSubsItem);
        }
    }

    if (bstrURL)
        SysFreeString(bstrURL);

    if (pwszUrl2)
        MemFree(pwszUrl2);

    return hr;
}

BOOL CProcessElement::ShouldDownloadLogo(IXMLElement *pLogo)
{
    return m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME);
}

// If relative url, will combine with most recent base URL
// *ppwszRetUrl should be NULL & will be MemAlloced
HRESULT CProcessElement::CombineWithBaseUrl(LPCWSTR pwszUrl, LPWSTR *ppwszRetUrl)
{
    ASSERT(ppwszRetUrl && !*ppwszRetUrl && pwszUrl);

    // Optimization: if pwszURL is absolute, we don't need to do this expensive
    //  combine operation
//  if (*pwszUrl != L'/')   // BOGUS
//  {
//      *ppwszRetUrl = StrDupW(pwszUrl);
//      return S_FALSE;     // Succeeded; pwszUrl is already OK
//  }

    // Find appropriate Base URL to use
    LPCWSTR pwszBaseUrl = GetBaseUrl();

    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = ARRAYSIZE(wszUrl);

    if (SUCCEEDED(UrlCombineW(pwszBaseUrl, pwszUrl, wszUrl, &dwLen, 0)))
    {
        *ppwszRetUrl = StrDupW(wszUrl);
        return (*ppwszRetUrl) ? S_OK : E_OUTOFMEMORY;
    }

    *ppwszRetUrl = NULL;

    return E_FAIL;  // Erg?
}



//==============================================================================
// CProcessElement derived classes, to handle specific CDF tags
//==============================================================================
// CProcessRoot doesn't behave like a normal CProcessElement class. It calls
//  CProcessChannel to process the *same element*
CProcessRoot::CProcessRoot(CChannelAgent *pParent, IXMLElement *pItem) : 
        CProcessElement(pParent, NULL, pItem)
{
    ASSERT(m_pDefaultStartItem == FALSE && m_pTracking == NULL && !m_dwCurSizeKB);

    m_pRoot = this;
    m_pChannelAgent = pParent; pParent->AddRef();
    m_iTotalStarted = 1;
}

CProcessRoot::~CProcessRoot()
{
    SAFEDELETE(m_pTracking);
    SAFERELEASE(m_pChannelAgent);
    SAFERELEASE(m_pDefaultStartItem);
}

// Should never get called. CProcessRoot is an odd duck.
HRESULT CProcessRoot::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT CProcessRoot::CreateStartItem(ISubscriptionItem **ppItem)
{
    if (ppItem)
        *ppItem = NULL;

    if (!m_pDefaultStartItem)
    {
        DoCloneSubscriptionItem(m_pChannelAgent->GetStartItem(), NULL, &m_pDefaultStartItem);

        if (m_pDefaultStartItem)
        {
            DWORD   dwTemp;

            // Clear out properties we don't want
            const LPCWSTR pwszPropsToClear[] =
            {
                c_szPropCrawlLevels,
                c_szPropCrawlLocalDest,
                c_szPropCrawlActualSize,
                c_szPropCrawlMaxSize,
                c_szPropCrawlGroupID
            };

            VARIANT varEmpty[ARRAYSIZE(pwszPropsToClear)] = {0};

            ASSERT(ARRAYSIZE(pwszPropsToClear) == ARRAYSIZE(varEmpty));
            m_pDefaultStartItem->WriteProperties(
                ARRAYSIZE(pwszPropsToClear), pwszPropsToClear, varEmpty);

            // Add in properties we do want
            dwTemp = DELIVERY_AGENT_FLAG_NO_BROADCAST |
                     DELIVERY_AGENT_FLAG_NO_RESTRICTIONS;
            WriteDWORD(m_pDefaultStartItem, c_szPropAgentFlags, dwTemp);
            if (FAILED(ReadDWORD(m_pDefaultStartItem, c_szPropCrawlFlags, &dwTemp)))
            {
                WriteDWORD(m_pDefaultStartItem, c_szPropCrawlFlags,
                    WEBCRAWL_GET_IMAGES|WEBCRAWL_LINKS_ELSEWHERE);
            }

            WriteLONGLONG(m_pDefaultStartItem, c_szPropCrawlNewGroupID, m_pChannelAgent->m_llCacheGroupID);
        }
    }

    if (m_pDefaultStartItem && ppItem)
    {
        DoCloneSubscriptionItem(m_pDefaultStartItem, NULL, ppItem);

        if (*ppItem)
        {
            // Add in properties for our new clone
            if ((m_pChannelAgent->m_dwMaxSizeKB > 0) &&
                (m_dwCurSizeKB <= m_pChannelAgent->m_dwMaxSizeKB))

            {
                WriteDWORD(*ppItem, c_szPropCrawlMaxSize, 
                    (m_pChannelAgent->m_dwMaxSizeKB - m_dwCurSizeKB));
            }
        }
    }

    return (ppItem) ? (*ppItem) ? S_OK : E_FAIL :
                      (m_pDefaultStartItem) ? S_OK : E_FAIL;
}

HRESULT CProcessRoot::Run()
{
    if (FAILED(CreateStartItem(NULL)))
        return E_FAIL;

    return DoChild(new CProcessChannel(this, this, m_pElement));
}

HRESULT CProcessRoot::DoTrackingFromItem(IXMLElement *pItem, LPCWSTR pwszUrl, BOOL fForceLog)
{
    HRESULT hr = E_FAIL;

    // if m_pTracking is not created before this call, means no <LogTarget> tag was found or
    // global logging is turned off
    if (m_pTracking)
        hr = m_pTracking->ProcessTrackingInItem(pItem, pwszUrl, fForceLog);
        
    return hr;
}

HRESULT CProcessRoot::DoTrackingFromLog(IXMLElement *pItem)
{
    HRESULT hr = S_OK;

    if (!m_pTracking 
        && !SHRestricted2W(REST_NoChannelLogging, m_pChannelAgent->GetUrl(), 0)
        && !ReadRegDWORD(HKEY_CURRENT_USER, c_szRegKey, c_szNoChannelLogging))
    {
        m_pTracking = new CUrlTrackingCache(m_pChannelAgent->GetStartItem(), m_pChannelAgent->GetUrl());
    }
    
    if (!m_pTracking)
        return E_OUTOFMEMORY;

    hr = m_pTracking->ProcessTrackingInLog(pItem);

    // skip tracking if PostURL is not specified
    if (m_pTracking->get_PostURL() == NULL)
    {
        SAFEDELETE(m_pTracking);
    }

    return hr;
}

// Overload this since we never do enumeration. Call delivery agent if necessary,
//  call m_pParent->OnChildDone if necessary
HRESULT CProcessRoot::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    ASSERT(pChild && (!m_pCurChild || (pChild == m_pCurChild)));

    // Our processing is done. Now we decide if we'd like to call the post agent.
    BSTR bstrURL=NULL;
    ISubscriptionItem *pStartItem;

    hr = S_OK;

    SAFEDELETE(m_pCurChild);

    ASSERT(m_pDefaultStartItem);
    ReadBSTR(m_pDefaultStartItem, c_szTrackingPostURL, &bstrURL);

    if (bstrURL && *bstrURL)
    {
        TraceMsg(TF_THISMODULE, "ChannelAgent calling post agent posturl=%ws", bstrURL);
        if (SUCCEEDED(m_pRoot->CreateStartItem(&pStartItem)))
        {
            m_pRunAgent = new CChannelAgentHolder(m_pChannelAgent, this);

            if (m_pRunAgent)
            {
                hr = m_pRunAgent->Init(this, pStartItem, CLSID_PostAgent);
                if (SUCCEEDED(hr))
                    hr = m_pRunAgent->StartAgent();
                if (hr != E_PENDING)
                    CRunDeliveryAgent::SafeRelease(m_pRunAgent);
            }
            pStartItem->Release();
        }
    }

    SysFreeString(bstrURL);

    if (hr != E_PENDING)
        m_pParent->OnChildDone(this, hr); // This may delete us

    return hr;
}

// Our delivery agent (post agent) is done running. Tell CDF agent we're done.
HRESULT CProcessRoot::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    if (!fSynchronous)
        m_pParent->OnChildDone(this, S_OK); // This may delete us

    return S_OK;
}

CProcessChannel::CProcessChannel(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
    m_fglobalLog = FALSE;
}

CProcessChannel::~CProcessChannel()
{
    SAFEFREEBSTR(m_bstrBaseUrl);
}

HRESULT CProcessChannel::CheckPreCache()
{
    BOOL fPreCache;

    if (SUCCEEDED(GetXMLBoolAttribute(m_pElement, L"PreCache", &fPreCache)))
    {
        if (fPreCache)
            return S_OK;
        
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CProcessChannel::Run()
{
    // Process Channel attributes, then any sub elements
    if (0 == m_lIndex)
    {
        m_lIndex ++;

        BSTR bstrURL=NULL;
        LPWSTR pwszUrl=NULL;
        HRESULT hr = S_OK;

        ASSERT(!m_bstrBaseUrl);

        // Get base URL if specified
        GetXMLStringAttribute(m_pElement, L"BASE", &m_bstrBaseUrl);

        if (SUCCEEDED(GetXMLStringAttribute(m_pElement, L"HREF", &bstrURL)) && bstrURL)
            CombineWithBaseUrl(bstrURL, &pwszUrl);

        if (pwszUrl && (m_pRoot==m_pParent))
        {
            // Use this as default "email url"
            WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);
        }

        if (pwszUrl && m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) &&
            (S_OK == CheckPreCache()))
        {
            if (E_PENDING == DoWebCrawl(m_pElement, pwszUrl))
            {
                m_fDownloadedHREF = TRUE;
                hr = E_PENDING;
            }

        }

        // If no URL for this <Channel> log, check if global log exists       
        if (SUCCEEDED(m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, m_pParent->IsGlobalLog())))
        {
            SetGlobalLogFlag(TRUE);
        }

        SAFELOCALFREE(pwszUrl);
        SAFEFREEBSTR(bstrURL);

        if (hr == E_PENDING)
            return hr;
    }

    // We've processed attributes. Run sub-elements.

    return CProcessElement::Run();
}

HRESULT CProcessChannel::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    HRESULT hr;
    BSTR    bstrTemp;

    if (!StrCmpIW(pwszTagName, L"Logo"))
    {
        if (ShouldDownloadLogo(pItem))
            return DoWebCrawl(pItem);
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"Item"))
    {
        return DoChild(new CProcessItem(this, m_pRoot, pItem));
    }
    else if (!StrCmpIW(pwszTagName, L"Channel"))
    {
        return DoChild(new CProcessChannel(this, m_pRoot, pItem));
    }
/*
    else if (!StrCmpIW(pwszTagName, L"Login"))
    {
        // No sub-elements to process. Do it here.
        return m_pRoot->ProcessLogin(pItem);
    }
*/
    else if (!StrCmpIW(pwszTagName, L"LOGTARGET"))
    {
        return m_pRoot->DoTrackingFromLog(pItem);
    }
    else if (!StrCmpIW(pwszTagName, L"Schedule"))
    {
        if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_DYNAMIC_SCHEDULE))
            return DoChild(new CProcessSchedule(this, m_pRoot, pItem));
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"SoftPkg"))
    {
        return DoSoftDist(pItem);
    }
    else if (!StrCmpIW(pwszTagName, L"A"))
    {
        // Process Anchor tag
        if (!m_fDownloadedHREF
            && (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) || (m_pRoot==m_pParent))
            && SUCCEEDED(GetXMLStringAttribute(pItem, L"HREF", &bstrTemp))
            && bstrTemp)
        {
            LPWSTR pwszUrl=NULL;

            hr = S_OK;

            CombineWithBaseUrl(bstrTemp, &pwszUrl); // not really necessary (a href)

            if (pwszUrl)
            {
                // Use this as default "email url"
                if (m_pRoot == m_pParent)
                    WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);

                if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME) &&
                    (S_OK == CheckPreCache()))
                {
                    hr = DoWebCrawl(m_pElement, pwszUrl);

                    if (E_PENDING == hr)
                        m_fDownloadedHREF = TRUE;

                    // Process tracking for this item
                    if (SUCCEEDED(m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, m_pParent->IsGlobalLog())))
                        SetGlobalLogFlag(TRUE);
                }
            }

            SAFELOCALFREE(pwszUrl);

            SysFreeString(bstrTemp);
            return hr;
        }

        return S_OK;
    }

    return S_OK;
}

CProcessItem::CProcessItem(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
}

CProcessItem::~CProcessItem()
{
    SAFEFREEBSTR(m_bstrAnchorURL);
}

HRESULT CProcessItem::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"Logo"))
    {
        if (ShouldDownloadLogo(pItem))
            return DoWebCrawl(pItem);
        else
            return S_OK;
    }
    else if (!StrCmpIW(pwszTagName, L"Usage"))
    {
        // Usage tag found.
        BSTR    bstrValue;

        if (SUCCEEDED(GetXMLStringAttribute(pItem, L"Value", &bstrValue)))
        {
            if (!m_fDesktop &&
                !StrCmpIW(bstrValue, L"DesktopComponent"))
            {
                m_fDesktop = TRUE;
            }

            if (!m_fEmail &&
                !StrCmpIW(bstrValue, L"Email"))
            {
                m_fEmail = TRUE;
            }

            SysFreeString(bstrValue);
        }
    }
    else if (!StrCmpIW(pwszTagName, L"A"))
    {
        // Anchor tag found; save URL
        if (!m_bstrAnchorURL)
            GetXMLStringAttribute(pItem, L"HREF", &m_bstrAnchorURL);
    }

    return S_OK;
}

HRESULT CProcessItem::EnumerationComplete()
{
    BOOL fPreCache, fPreCacheValid=FALSE;
    BOOL fDoDownload=FALSE;
    BSTR bstrURL=NULL;
    HRESULT hr = S_OK;
    LPWSTR pwszUrl=NULL;

    // End PCN compat

    if (SUCCEEDED(GetXMLBoolAttribute(m_pElement, L"PreCache", &fPreCache)))
    {
        fPreCacheValid = TRUE;
    }

    // Get the URL from our attribute, or from Anchor tag if not available
    if (FAILED(GetXMLStringAttribute(m_pElement, L"HREF", &bstrURL)) || !bstrURL)
    {
        bstrURL = m_bstrAnchorURL;
        m_bstrAnchorURL = NULL;
    }

    // Get the combined URL
    if (bstrURL)
        CombineWithBaseUrl(bstrURL, &pwszUrl);

    if (pwszUrl)
    {
        // Process tracking for this item
        m_pRoot->DoTrackingFromItem(m_pElement, pwszUrl, IsGlobalLog());

        // Find if we should use this url for the Email agent
        if (m_fEmail)
        {
            // Yes, put this url in the end report
            DBG("Using custom email url");
            WriteOLESTR(m_pRoot->m_pChannelAgent->GetStartItem(), c_szPropEmailURL, pwszUrl);
        }

        // Figure out if we should download our "href" based on Usage and Precache tag
        if (fPreCacheValid)
        {
            if (fPreCache)
            {
                if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_SOME))
                    fDoDownload = TRUE;
            }
        }
        else
        {
            if (m_pRoot->IsChannelFlagSet(CHANNEL_AGENT_PRECACHE_ALL))
                fDoDownload = TRUE;
        }

        // if (m_fDesktop)
        // Do something for desktop components

        if (fDoDownload && pwszUrl)
            hr = DoWebCrawl(m_pElement, pwszUrl);
    } // pwszUrl

    SAFEFREEBSTR(bstrURL);
    SAFELOCALFREE(pwszUrl);

    return hr;
}

CProcessSchedule::CProcessSchedule(CProcessElementSink *pParent,
                                 CProcessRoot *pRoot,
                                 IXMLElement *pItem) :
        CProcessElement(pParent, pRoot, pItem)
{
}

HRESULT CProcessSchedule::Run()
{
    // Get attributes (Start and End date) first
    BSTR    bstr=NULL;
    long    lTimeZone;

    if (FAILED(GetXMLStringAttribute(m_pElement, L"StartDate", &bstr)) ||
        !ISODateToSystemTime(bstr, &m_stStartDate, &lTimeZone))
    {
        GetLocalTime(&m_stStartDate);
    }
    SAFEFREEBSTR(bstr);

    if (FAILED(GetXMLStringAttribute(m_pElement, L"StopDate", &bstr)) ||
        !ISODateToSystemTime(bstr, &m_stEndDate, &lTimeZone))
    {
        ZeroMemory(&m_stEndDate, sizeof(m_stEndDate));
    }
    SAFEFREEBSTR(bstr);

    return CProcessElement::Run();
}

HRESULT CProcessSchedule::ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem)
{
    if (!StrCmpIW(pwszTagName, L"IntervalTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeInterval);
    }
    else if (!StrCmpIW(pwszTagName, L"EarliestTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeEarliest);
    }
    else if (!StrCmpIW(pwszTagName, L"LatestTime"))
    {
        GetXMLTimeAttributes(pItem, &m_timeLatest);
    }

    return S_OK;
}

HRESULT CProcessSchedule::EnumerationComplete()
{
    DBG("CProcessSchedule::EnumerationComplete");

    int iZone;

    if (FAILED(GetXMLTimeZoneAttribute(m_pElement, L"TimeZone", &iZone)))
        iZone = 9999;

    m_tt.cbTriggerSize = sizeof(m_tt);

    // m_pRoot is null for XMLElementToTaskTrigger call
    // Always run ScheduleToTaskTrigger
    if (SUCCEEDED(ScheduleToTaskTrigger(&m_tt, &m_stStartDate, &m_stEndDate,
            (long) m_timeInterval.dwConvertedMinutes,
            (long) m_timeEarliest.dwConvertedMinutes,
            (long) m_timeLatest.dwConvertedMinutes,
            iZone))
        && m_pRoot)
    {
        SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };
        if (SUCCEEDED(m_pRoot->m_pChannelAgent->GetStartItem()->GetSubscriptionItemInfo(&sii)))
        {
            if (sii.ScheduleGroup != GUID_NULL)
            {
                if (FAILED(UpdateScheduleTrigger(&sii.ScheduleGroup, &m_tt)))
                {
                    DBG_WARN("Failed to update trigger in publisher's recommended schedule.");
                }
            }
            else
                DBG_WARN("No publisher's recommended schedule in sii");
        }
    }

    return S_OK;
}

HRESULT ScheduleToTaskTrigger(TASK_TRIGGER *ptt, SYSTEMTIME *pstStartDate, SYSTEMTIME *pstEndDate,
                              long lInterval, long lEarliest, long lLatest, int iZone/*=9999*/)
{
    // Convert our schedule info to a TASK_TRIGGER struct

    ASSERT(pstStartDate);
    
    int iZoneCorrectionMinutes=0;
    TIME_ZONE_INFORMATION tzi;
    long lRandom;
    
    if ((lInterval == 0) ||
        (lInterval > 366 * MINUTES_PER_DAY))
    {
        DBG_WARN("ScheduleToTaskTrigger: Invalid IntervalTime - failing");
        return E_INVALIDARG;
    }

    if (ptt->cbTriggerSize < sizeof(TASK_TRIGGER))
    {
        DBG_WARN("ScheduleToTaskTrigger: ptt->cbTriggerSize not initialized");
        ASSERT(!"ScheduleToTaskTrigger");
        return E_INVALIDARG;
    }

    // Fix any invalid stuff
    if (lInterval < MINUTES_PER_DAY)
    {
        // ROUND so that dwIntervalMinutes is an even divisor of one day
        lInterval = MINUTES_PER_DAY / (MINUTES_PER_DAY / lInterval);
    }
    else
    {
        // ROUND to nearest day
        lInterval = MINUTES_PER_DAY * ((lInterval + 12*60)/MINUTES_PER_DAY);
    }
    if (lEarliest >= lInterval)
    {
        DBG("Invalid EarliestTime specified. Fixing."); // Earliest >= Interval!
        lEarliest = lInterval-1;
    }
    if (lLatest < lEarliest)
    {
        DBG("Invalid LatestTime specified. Fixing."); // Latest < Earliest!
        lLatest = lEarliest;
    }
    if (lLatest-lEarliest > lInterval)
    {
        DBG("Invalid LatestTime specified. Fixing.");   // Latest > Interval!
        lLatest = lEarliest+lInterval;
    }

    lRandom = lLatest - lEarliest;
    ASSERT(lRandom>=0 && lRandom<=lInterval);

    if (iZone != 9999)
    {
        int iCorrection;
        iCorrection = (60 * (iZone/100)) + (iZone % 100);

        if (iCorrection < -12*60 || iCorrection > 12*60)
        {
            DBG("ScheduleElementToTaskTrigger: Invalid timezone; ignoring");
        }
        else
        {
            if (TIME_ZONE_ID_INVALID != GetTimeZoneInformation(&tzi))
            {
                // tzi.bias has correction from client timezone to UTC (+8 for US west coast)
                // iCorrection has correction from UTC to server time zone (-5 for US east coast)
                // result is correction from server to client time zone (-3 for east to west coast)
                iZoneCorrectionMinutes = - (iCorrection + tzi.Bias + tzi.StandardBias);
                TraceMsg(TF_THISMODULE, "ServerTimeZone = %d, LocalBias = %d min, RelativeCorrection = %d min", iZone, tzi.Bias+tzi.StandardBias, iZoneCorrectionMinutes);
            }
            else
            {
                DBG_WARN("Unable to get local time zone. Not correcting for time zone.");
            }
        }
    }

    TraceMsg(TF_THISMODULE, "StartDate = %d/%d/%d StopDate = %d/%d/%d", (int)(pstStartDate->wMonth),(int)(pstStartDate->wDay),(int)(pstStartDate->wYear),(int)(pstEndDate->wMonth),(int)(pstEndDate->wDay),(int)(pstEndDate->wYear));
    TraceMsg(TF_THISMODULE, "IntervalTime = %6d minutes", (int)lInterval);
    TraceMsg(TF_THISMODULE, "EarliestTime = %6d minutes", (int)lEarliest);
    TraceMsg(TF_THISMODULE, "LatestTime   = %6d minutes", (int)lLatest);
    TraceMsg(TF_THISMODULE, "RandomTime   = %6d minutes", (int)lRandom);

    if (iZoneCorrectionMinutes != 0)
    {
        if (lInterval % 60)
        {
            DBG("Not correcting for time zone ; interval not multiple of 1 hour");
        }
        else
        {
            // Correct Earliest time for time zone
            lEarliest += (iZoneCorrectionMinutes % lInterval);

            if (lEarliest < 0)
                lEarliest += lInterval;

            TraceMsg(TF_THISMODULE, "EarliestTime = %6d minutes (after timezone)", (int)lEarliest);
        }
    }

    ZeroMemory(ptt, sizeof(*ptt));
    ptt->cbTriggerSize = sizeof(*ptt);
    ptt->wBeginYear = pstStartDate->wYear;
    ptt->wBeginMonth = pstStartDate->wMonth;
    ptt->wBeginDay = pstStartDate->wDay;
    if (pstEndDate && pstEndDate->wYear)
    {
        ptt->rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;
        ptt->wEndYear = pstEndDate->wYear;
        ptt->wEndMonth = pstEndDate->wMonth;
        ptt->wEndDay = pstEndDate->wDay;
    }

    // Set up Random period ; difference between Latesttime and Earliesttime
    ptt->wRandomMinutesInterval = (WORD) lRandom;

    ptt->wStartHour = (WORD) (lEarliest / 60);
    ptt->wStartMinute = (WORD) (lEarliest % 60);

    // Set up according to IntervalTime
    if (lInterval < MINUTES_PER_DAY)
    {
        // Less than one day (1/2 day, 1/3 day, 1/4 day, etc)
        ptt->MinutesDuration = MINUTES_PER_DAY - lEarliest;
        ptt->MinutesInterval = lInterval;
        ptt->TriggerType = TASK_TIME_TRIGGER_DAILY;
        ptt->Type.Daily.DaysInterval = 1;
    }
    else
    {
        // Greater than or equal to one day.
        DWORD dwIntervalDays = lInterval / MINUTES_PER_DAY;

        TraceMsg(TF_THISMODULE, "Using %d day interval", dwIntervalDays);

        ptt->TriggerType = TASK_TIME_TRIGGER_DAILY;
        ptt->Type.Daily.DaysInterval = (WORD) dwIntervalDays;
    }

    return S_OK;
}


//==============================================================================
// CRunDeliveryAgent provides generic support for synchronous operation of a
//   delivery agent
// It is aggregatable so that you can add more interfaces to the callback
//==============================================================================
CRunDeliveryAgent::CRunDeliveryAgent()
{
    m_cRef = 1;
}

HRESULT CRunDeliveryAgent::Init(CRunDeliveryAgentSink *pParent,
                                ISubscriptionItem *pItem,
                                REFCLSID rclsidDest)
{
    ASSERT(pParent && pItem);

    if (m_pParent || m_pItem)
        return E_FAIL;  // already initialized. can't reuse an instance.

    if (!pParent || !pItem)
        return E_FAIL;

    m_pParent = pParent;
    m_clsidDest = rclsidDest;

    m_pItem = pItem;
    pItem->AddRef();

    return S_OK;
}

CRunDeliveryAgent::~CRunDeliveryAgent()
{
    CleanUp();
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CRunDeliveryAgent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRunDeliveryAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CRunDeliveryAgent::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionAgentEvents == riid))
    {
        *ppv=(ISubscriptionAgentEvents *)this;
    }
    else
        return E_NOINTERFACE;

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

//
// ISubscriptionAgentEvents members
//
STDMETHODIMP CRunDeliveryAgent::UpdateBegin(const SUBSCRIPTIONCOOKIE *)
{
    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::UpdateProgress(
                const SUBSCRIPTIONCOOKIE *,
                long lSizeDownloaded,
                long lProgressCurrent,
                long lProgressMax,
                HRESULT hrStatus,
                LPCWSTR wszStatus)
{
    if (m_pParent)
        m_pParent->OnAgentProgress();
    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::UpdateEnd(const SUBSCRIPTIONCOOKIE *pCookie,
                long    lSizeDownloaded,
                HRESULT hrResult,
                LPCWSTR wszResult)
{
    ASSERT((hrResult != INET_S_AGENT_BASIC_SUCCESS) && (hrResult != E_PENDING));

    m_hrResult = hrResult;
    if (hrResult == INET_S_AGENT_BASIC_SUCCESS || hrResult == E_PENDING)
    {
        // Shouldn't happen; let's be robust anyway.
        m_hrResult = S_OK;
    }

    if (m_pParent)
    {
        m_pParent->OnAgentEnd(pCookie, lSizeDownloaded, hrResult, wszResult, m_fInStartAgent);
    }

    CleanUp();

    return S_OK;
}

STDMETHODIMP CRunDeliveryAgent::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    return S_FALSE;
}

HRESULT CRunDeliveryAgent::StartAgent()
{
    HRESULT hr;

    if (!m_pParent || !m_pItem || m_pAgent)
        return E_FAIL;

    AddRef();   // Release before we return from this function
    m_fInStartAgent = TRUE;

    m_hrResult = INET_S_AGENT_BASIC_SUCCESS;

    DBG("Using new interfaces to host agent");

    ASSERT(!m_pAgent);

    hr = CoCreateInstance(m_clsidDest, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionAgentControl, (void **)&m_pAgent);

    if (m_pAgent)
    {
        hr = m_pAgent->StartUpdate(m_pItem, (ISubscriptionAgentEvents *)this);
    }

    hr = m_hrResult;

    m_fInStartAgent = FALSE;
    Release();

    if (hr != INET_S_AGENT_BASIC_SUCCESS)
    {
        return hr;
    }

    return E_PENDING;
};

HRESULT CRunDeliveryAgent::AgentPause(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->PauseUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentPause with no running agent!!");
    return S_FALSE;
}

HRESULT CRunDeliveryAgent::AgentResume(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->ResumeUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentResume with no running agent!!");

    return E_FAIL;
}

HRESULT CRunDeliveryAgent::AgentAbort(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->AbortUpdate(0);

    DBG_WARN("CRunDeliveryAgent::AgentAbort with no running agent!!");
    return S_FALSE;
}

void CRunDeliveryAgent::CleanUp()
{
    SAFERELEASE(m_pItem);
    SAFERELEASE(m_pAgent);
    m_pParent = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// CChannelAgentHolder, derives from CRunDeliveryAgent
//
//////////////////////////////////////////////////////////////////////////
CChannelAgentHolder::CChannelAgentHolder(CChannelAgent *pChannelAgent, CProcessElement *pProcess)
{
    m_pChannelAgent = pChannelAgent;
    m_pProcess = pProcess;
}

CChannelAgentHolder::~CChannelAgentHolder()
{
}

// Won't compile unless we have addref & release here.
STDMETHODIMP_(ULONG) CChannelAgentHolder::AddRef(void)
{
    return CRunDeliveryAgent::AddRef();
}

STDMETHODIMP_(ULONG) CChannelAgentHolder::Release(void)
{
    return CRunDeliveryAgent::Release();
}

STDMETHODIMP CChannelAgentHolder::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    if (IID_IServiceProvider == riid)
    {
        *ppv = (IServiceProvider *)this;
    }   
    else
        return CRunDeliveryAgent::QueryInterface(riid, ppv);

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IQueryService
// CLSID_ChannelAgent   IID_ISubscriptionItem       channel agent start item
// CLSID_XMLDocument    IID_IXMLElement             current element
STDMETHODIMP CChannelAgentHolder::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    ASSERT(ppvObject);
    if (!ppvObject)
        return E_INVALIDARG;
    
    if (!m_pChannelAgent || !m_pProcess || !m_pParent)
        return E_FAIL;

    *ppvObject = NULL;

    if (guidService == CLSID_ChannelAgent)
    {
        if (riid == IID_ISubscriptionItem)
        {
            *ppvObject = m_pChannelAgent->GetStartItem();
        }
//      if (riid == IID_IXMLElement)    Root XML document?
    }
    else if (guidService == CLSID_XMLDocument)
    {
        if (riid == IID_IXMLElement)
        {
            *ppvObject = m_pProcess->GetCurrentElement();
        }
    }

    if (*ppvObject)
    {
        ((IUnknown *)*ppvObject)->AddRef();
        return S_OK;
    }

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// CChannelAgent implementation
//
//////////////////////////////////////////////////////////////////////////

CChannelAgent::CChannelAgent()
{
    DBG("Creating CChannelAgent object");

    // Initialize object
    // Many vars are initialized in StartOperation
    m_pwszURL = NULL;
    m_pCurDownload = NULL;
    m_pProcess = NULL;
    m_fHasInitCookie = FALSE;
    m_pChannelIconHelper = NULL;
}

CChannelAgent::~CChannelAgent()
{
//  DBG("Destroying CChannelAgent object");

    if (m_pwszURL)
        CoTaskMemFree(m_pwszURL);
    
    SAFELOCALFREE (m_pBuf);

    ASSERT(!m_pProcess);

    SAFERELEASE(m_pChannelIconHelper);

    DBG("Destroyed CChannelAgent object");
}

void CChannelAgent::CleanUp()
{
    if (m_pCurDownload)
    {
        m_pCurDownload->LeaveMeAlone();     // no more calls from them
        m_pCurDownload->DoneDownloading();
        m_pCurDownload->Release();
        m_pCurDownload = NULL;
    }
    SAFEFREEOLESTR(m_pwszURL);
    SAFEDELETE(m_pProcess);
    SAFELOCALFREE(m_pBuf);

    CDeliveryAgent::CleanUp();
}

HRESULT CChannelAgent::StartOperation()
{
    DBG("Channel Agent in StartOperation");
    
    DWORD dwTemp;

    SAFEFREEOLESTR(m_pwszURL);
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szPropURL, &m_pwszURL)) ||
        !CUrlDownload::IsValidURL(m_pwszURL))
    {
        DBG_WARN("Couldn't get valid URL, aborting");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    if (FAILED(ReadDWORD(m_pSubscriptionItem, c_szPropChannelFlags, &m_dwChannelFlags)))
        m_dwChannelFlags = 0;
    
    // If we download all, we also download some. Makes assumptions easier.
    if (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)
        m_dwChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;

    // NOTE: We may want REST_NoChannelContent to be similar to the webcrawl version.
    // Probably not though because the headlines are useful in the UI.
    if (SHRestricted2W(REST_NoChannelContent, NULL, 0))
        ClearFlag(m_dwChannelFlags, CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_PRECACHE_SOME);

    m_dwMaxSizeKB = SHRestricted2W(REST_MaxChannelSize, NULL, 0);
    if (SUCCEEDED(ReadDWORD(m_pSubscriptionItem, c_szPropCrawlMaxSize, &dwTemp))
        && dwTemp
        && (0 == m_dwMaxSizeKB || dwTemp < m_dwMaxSizeKB))
    {
        m_dwMaxSizeKB = dwTemp;
    }

    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        ClearFlag(m_dwChannelFlags, CHANNEL_AGENT_PRECACHE_ALL|
            CHANNEL_AGENT_PRECACHE_SOME|CHANNEL_AGENT_PRECACHE_SCRNSAVER);
        DBG("Channel agent is in 'changes only' mode.");
    }
    else
    {
        // Read old group ID
        ReadLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, &m_llOldCacheGroupID);

        // Read new ID if present
        m_llCacheGroupID = 0;
        ReadLONGLONG(m_pSubscriptionItem, c_szPropCrawlNewGroupID, &m_llCacheGroupID);
    }

    return CDeliveryAgent::StartOperation();
}

HRESULT CChannelAgent::StartDownload()
{
    ASSERT(!m_pCurDownload);
    TraceMsg(TF_THISMODULE, "Channel agent starting download of CDF: URL=%ws", m_pwszURL);

    m_pCurDownload = new CUrlDownload(this, 0);
    if (!m_pCurDownload)
        return E_OUTOFMEMORY;

    // Change detection
    m_varChange.vt = VT_EMPTY;
    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        // "Changes Only" mode, we have persisted a change detection code
        ReadVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
        m_llCacheGroupID = 0;
    }
    else
    {
        // Create new cache group
        if (!m_llCacheGroupID)
        {
            m_llCacheGroupID = CreateUrlCacheGroup(CACHEGROUP_FLAG_NONPURGEABLE, 0);

            ASSERT_MSG(m_llCacheGroupID != 0, "Create cache group failed");
        }
    }

    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

    MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, m_pwszURL);
    PreCheckUrlForChange(szUrl, &m_varChange, NULL);

    SendUpdateProgress(m_pwszURL, 0, -1, 0);

    // Start download
    return m_pCurDownload->BeginDownloadURL2(
        m_pwszURL, BDU2_URLMON, BDU2_NEEDSTREAM, NULL, m_dwMaxSizeKB<<10);
}

HRESULT CChannelAgent::OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    ASSERT((HWND)-1 == *phwnd && NULL == *ppszUsername && NULL == *ppszPassword);

    hr = ReadOLESTR(m_pSubscriptionItem, c_szPropCrawlUsername, ppszUsername);
    if (SUCCEEDED(hr))
    {
        BSTR bstrPassword = NULL;
        hr = ReadPassword(m_pSubscriptionItem, &bstrPassword);
        if (SUCCEEDED(hr))
        {
            int len = (lstrlenW(bstrPassword) + 1) * sizeof(WCHAR);
            *ppszPassword = (LPWSTR) CoTaskMemAlloc(len);
            if (*ppszPassword)
            {
                CopyMemory(*ppszPassword, bstrPassword, len);
            }
            SAFEFREEBSTR(bstrPassword);
            if (*ppszPassword)
            {
                return S_OK;
            }
        }
    }

    SAFEFREEOLESTR(*ppszUsername);
    SAFEFREEOLESTR(*ppszPassword);
    return E_FAIL;
}

HRESULT CChannelAgent::OnDownloadComplete(UINT iID, int iError)
{
    TraceMsg(TF_THISMODULE, "Channel Agent: OnDownloadComplete(%d)", iError);

    IStream *pStm = NULL;
    HRESULT hr;
    BOOL    fProcessed=FALSE;
    DWORD   dwCDFSizeKB=0, dwResponseCode;
    BSTR    bstrTmp;
    char    chBuf[MY_MAX_CACHE_ENTRY_INFO];
    DWORD   dwBufSize = sizeof(chBuf);

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    if (iError)
        hr = E_FAIL;
    else
    {
        hr = m_pCurDownload->GetResponseCode(&dwResponseCode);

        if (SUCCEEDED(hr))
        {
            hr = CheckResponseCode(dwResponseCode);
        }
        else
            DBG_WARN("CChannelAgent failed to GetResponseCode");
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pCurDownload->GetStream(&pStm);
        m_pCurDownload->ReleaseStream();
    }

    if (SUCCEEDED(hr))
    {
        TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH];
        LPWSTR  pwszThisUrl;

        m_pCurDownload->GetRealURL(&pwszThisUrl);

        if (pwszThisUrl)
        {
            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszThisUrl);

            LocalFree(pwszThisUrl);

            if (SUCCEEDED(GetUrlInfoAndMakeSticky(
                            NULL,
                            szThisUrl,
                            lpInfo,
                            dwBufSize,
                            m_llCacheGroupID)))
            {
                dwCDFSizeKB = (((LPINTERNET_CACHE_ENTRY_INFO)chBuf)->dwSizeLow+512) >> 10;
                TraceMsg(TF_THISMODULE, "CDF size %d kb", dwCDFSizeKB);

                hr = PostCheckUrlForChange(&m_varChange, lpInfo, lpInfo->LastModifiedTime);
                // If we FAILED, we mark it as changed.
                if (hr == S_OK || FAILED(hr))
                {
                    SetAgentFlag(FLAG_CDFCHANGED);
                    DBG("CDF has changed; will flag channel as changed");
                }

                // "Changes Only" mode, persist change detection code
                if (IsAgentFlagSet(FLAG_CHANGESONLY))
                {
                    WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                }

                hr = S_OK;
            }
        }
    }
    else
    {
        SetEndStatus(E_INVALIDARG);
    }

    // Get an object model on our Channel Description File
    if (SUCCEEDED(hr) && pStm)
    {
        IPersistStreamInit *pPersistStm=NULL;

        CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC,
                         IID_IPersistStreamInit, (void **)&pPersistStm);

        if (pPersistStm)
        {
            pPersistStm->InitNew();
            hr = pPersistStm->Load(pStm);
            if (SUCCEEDED(hr))
            {
                IXMLDocument *pDoc;

                hr = pPersistStm->QueryInterface(IID_IXMLDocument, (void **)&pDoc);
                if (SUCCEEDED(hr) && pDoc)
                {
                    IXMLElement *pRoot;
                    BSTR        bstrCharSet=NULL;

                    if (SUCCEEDED(pDoc->get_charset(&bstrCharSet)) && bstrCharSet)
                    {
                        WriteOLESTR(m_pSubscriptionItem, c_szPropCharSet, bstrCharSet);
                        TraceMsg(TF_THISMODULE, "Charset = \"%ws\"", bstrCharSet);
                        SysFreeString(bstrCharSet);
                    }
                    else
                        WriteEMPTY(m_pSubscriptionItem, c_szPropCharSet);

                    hr = pDoc->get_root(&pRoot);
                    if (SUCCEEDED(hr) && pRoot)
                    {
                        if (SUCCEEDED(pRoot->get_tagName(&bstrTmp)) && bstrTmp)
                        {
                            if (!StrCmpIW(bstrTmp, L"Channel"))
                            {
                                ASSERT(!m_pProcess);
                                m_pProcess = new CProcessRoot(this, pRoot);
                                if (m_pProcess)
                                {
                                    if (IsAgentFlagSet(FLAG_CDFCHANGED))
                                        SetEndStatus(S_OK);
                                    else
                                        SetEndStatus(S_FALSE);
                                     
                                    m_pProcess->m_dwCurSizeKB = dwCDFSizeKB;
                                    WriteEMPTY(m_pSubscriptionItem, c_szPropEmailURL);
            
                                    hr = m_pProcess->Run();     // This will get us cleaned up (now or later)
                                    fProcessed = TRUE;          // So we shouldn't do it ourselves
                                }
                            }
                            else
                                DBG_WARN("Valid XML but invalid CDF");

                            SAFEFREEBSTR(bstrTmp);
                        }
                        pRoot->Release();
                    }
                    pDoc->Release();
                }
            }
            pPersistStm->Release();
        }
    }

    if (!fProcessed || (FAILED(hr) && (hr != E_PENDING)))
    {
        if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
            SetEndStatus(E_FAIL);
        DBG_WARN("Failed to process CDF ; XML load failed?");
        CleanUp();      // CleanUp only if the process failed (otherwise OnChildDone does it)
    }

#ifdef DEBUG
    if (hr == E_PENDING)
        DBG("CChannelAgent::OnDownloadComplete not cleaning up, webcrawl pending");
#endif

    return S_OK;
}

HRESULT CChannelAgent::OnChildDone(CProcessElement *pChild, HRESULT hr)
{
    // Our CProcessRoot has reported that it's done. Clean up.
    DBG("CChannelAgent::OnChildDone cleaning up Channel delivery agent");

    if (m_llOldCacheGroupID)
    {
        DBG("Nuking old cache group.");
        if (!DeleteUrlCacheGroup(m_llOldCacheGroupID, 0, 0))
        {
            DBG_WARN("Failed to delete old cache group!");
        }
    }
  
    WriteLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, m_llCacheGroupID);

    // Add "total size" property
    m_lSizeDownloadedKB = (long) (m_pProcess->m_dwCurSizeKB);
    WriteDWORD(m_pSubscriptionItem, c_szPropCrawlActualSize, m_lSizeDownloadedKB);

    WriteDWORD(m_pSubscriptionItem, c_szPropActualProgressMax, m_pProcess->m_iTotalStarted);

    CleanUp();
    return S_OK;
}

HRESULT CChannelAgent::AgentPause(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentPause");

    if (m_pProcess)
        m_pProcess->Pause(dwFlags);

    return CDeliveryAgent::AgentPause(dwFlags);
}

HRESULT CChannelAgent::AgentResume(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentResume");

    if (m_pProcess)
        m_pProcess->Resume(dwFlags);

    return CDeliveryAgent::AgentResume(dwFlags);
}

// Forcibly abort current operation
HRESULT CChannelAgent::AgentAbort(DWORD dwFlags)
{
    DBG("CChannelAgent::AgentAbort");

    if (m_pCurDownload)
        m_pCurDownload->DoneDownloading();

    if (m_pProcess)
        m_pProcess->Abort(dwFlags);

    return CDeliveryAgent::AgentAbort(dwFlags);
}

HRESULT CChannelAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    // Customize our end status string
    switch (GetEndStatus())
    {
        case INET_E_AGENT_MAX_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case INET_E_AGENT_CACHE_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_OK           :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_OK;
            else
                *puiRes = IDS_URL_STATUS_OK;
            break;
        case S_FALSE        :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_UNCHANGED;
            else
                *puiRes = IDS_URL_STATUS_UNCHANGED;
            break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;
    }

    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}


const GUID  CLSID_CDFICONHANDLER =
{0xf3ba0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x35}};

extern HRESULT LoadWithCookie(LPCTSTR, POOEBuf, DWORD *, SUBSCRIPTIONCOOKIE *);

// IExtractIcon members
STDMETHODIMP CChannelAgent::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    DWORD   dwSize;
    IChannelMgrPriv*   pIChannelMgrPriv = NULL;
    HRESULT            hr = E_FAIL;
    TCHAR              szPath[MAX_PATH];

    if (!m_pBuf)    {
        m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
        if (!m_pBuf)
            return E_OUTOFMEMORY;

        HRESULT hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
        RETURN_ON_FAILURE(hr);
    }

    hr = GetChannelPath(m_pBuf->m_URL, szPath, ARRAYSIZE(szPath), &pIChannelMgrPriv);

    if (SUCCEEDED(hr) && pIChannelMgrPriv)
    {
        IPersistFile* ppf = NULL;
        BOOL          bCoinit = FALSE;
        HRESULT       hr2 = E_FAIL;

        pIChannelMgrPriv->Release();

        hr = CoCreateInstance(CLSID_CDFICONHANDLER, NULL, CLSCTX_INPROC_SERVER,
                          IID_IPersistFile, (void**)&ppf);

        if ((hr == CO_E_NOTINITIALIZED || hr == REGDB_E_IIDNOTREG) &&
            SUCCEEDED(CoInitialize(NULL)))
        {
            bCoinit = TRUE;
            hr = CoCreateInstance(CLSID_CDFICONHANDLER, NULL, CLSCTX_INPROC_SERVER,
                          IID_IPersistFile, (void**)&ppf);
        }

        if (SUCCEEDED(hr))
        {
            
            hr = ppf->QueryInterface(IID_IExtractIcon, (void**)&m_pChannelIconHelper);

            WCHAR wszPath[MAX_PATH];
            MyStrToOleStrN(wszPath, ARRAYSIZE(wszPath), szPath);
            hr2 = ppf->Load(wszPath, 0);

            ppf->Release();
        }

        if (SUCCEEDED(hr) && m_pChannelIconHelper)
        {
            hr = m_pChannelIconHelper->GetIconLocation(uFlags, szIconFile, cchMax, piIndex, pwFlags);
        }

        if (bCoinit)
            CoUninitialize();

    }

    if (m_pChannelIconHelper == NULL)
    {
        WCHAR wszCookie[GUIDSTR_MAX];

        ASSERT (piIndex && pwFlags && szIconFile);

        StringFromGUID2(m_SubscriptionCookie, wszCookie, ARRAYSIZE(wszCookie));
        MyOleStrToStrN(szIconFile, cchMax, wszCookie);
        *piIndex = 0;
        *pwFlags |= GIL_NOTFILENAME | GIL_PERINSTANCE;
        hr = NOERROR;
    }

    return hr;
}

STDMETHODIMP CChannelAgent::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    static HICON channelIcon = NULL;

    if (!phiconLarge || !phiconSmall)
        return E_INVALIDARG;

    * phiconLarge = * phiconSmall = NULL;

    if (m_pChannelIconHelper)
    {
        return m_pChannelIconHelper->Extract(szIconFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        DWORD   dwSize;

        if (!m_pBuf)    {
            m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
            if (!m_pBuf)
                return E_OUTOFMEMORY;

            HRESULT hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
            RETURN_ON_FAILURE(hr);
        }

        BYTE    bBuf[MY_MAX_CACHE_ENTRY_INFO];
        LPINTERNET_CACHE_ENTRY_INFO pEntry = (INTERNET_CACHE_ENTRY_INFO *)bBuf;

        dwSize = sizeof(bBuf);
        if (GetUrlCacheEntryInfo(m_pBuf->m_URL, pEntry, &dwSize))   {
            SHFILEINFO  sfi;
            UINT    cbFileInfo = sizeof(sfi), uFlags = SHGFI_ICON | SHGFI_LARGEICON;

            if (NULL != SHGetFileInfo(pEntry->lpszLocalFileName, 0,
                                            &sfi, cbFileInfo, uFlags))
            {
                ASSERT(sfi.hIcon);
                *phiconLarge = *phiconSmall = sfi.hIcon;
                return NOERROR;
            }
        }

        if (channelIcon == NULL) {
            channelIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CHANNEL));
            ASSERT(channelIcon);
        }

        * phiconLarge = * phiconSmall = channelIcon;
        return NOERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdlabsc.h ===
#ifndef __CDLBSC_INCLUDED__
#define __CDLBSC_INCLUDED__

class CDLAgentBSC : public IBindStatusCallback, public IServiceProvider,
                    public IInternetHostSecurityManager
{
    public:
        CDLAgentBSC(CCDLAgent *pcdlagent, DWORD dwMaxSizeKB, BOOL fSilentOperation, LPWSTR szCDFURL);
        virtual ~CDLAgentBSC();
        HRESULT Abort();
        HRESULT Pause();
        HRESULT Resume();

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID ridd, void **ppv );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
    
        // IBindStatusCallback methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo);
        STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding *pib);
        STDMETHODIMP GetPriority(LONG *pnPriority);
        STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                      FORMATETC *pformatetc,
                                      STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
        STDMETHODIMP OnLowResource(DWORD dwReserved);
        STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);

        // IServiceProvider
        STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void ** ppvObj);

        // IInternetHostSecurityManager
        STDMETHODIMP GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                   DWORD_PTR dwReserved);
        
        STDMETHODIMP ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                      BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                      DWORD dwReserved);
        
        STDMETHODIMP QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                       DWORD *pcbPolicy, BYTE *pContext,
                                       DWORD cbContext, DWORD dwReserved);
    
    
    protected:
        IBinding                   *m_pIBinding; // ibinding from code dl'er
        CCDLAgent                  *m_pCdlAgent;
        DWORD                       m_cRef;
        BOOL                        m_fSilentOperation;
        DWORD                       m_dwMaxSize;
        WCHAR                       m_pwzCDFBase[INTERNET_MAX_URL_LENGTH];
        IInternetSecurityManager   *m_pSecMgr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdfagent.h ===
#ifndef _CDFAGENT_H
#define _CDFAGENT_H

#include "msxml.h"

class CProcessElement;
class CProcessRoot;

class CUrlTrackingCache;

class CRunDeliveryAgentSink
{
public:
    // OnAgentProgress not currently called
    virtual HRESULT OnAgentProgress()
                    { return E_NOTIMPL; }
    // OnAgentEnd called when agent is complete. fSynchronous means that StartAgent call
    //  has not yet returned; hrResult will be returned from StartAgent
    virtual HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
                    { return E_NOTIMPL; }
};

class CProcessElementSink
{
public:
    virtual HRESULT OnChildDone(CProcessElement *pChild, HRESULT hr) = 0;
    virtual LPCWSTR GetBaseUrl() = 0;   // Returned pointer doesn't need to get freed
    virtual BOOL    IsGlobalLog() = 0;
};

typedef struct CDF_TIME
{
    WORD   wDay;
    WORD   wHour;
    WORD   wMin;
    WORD   wReserved;
    DWORD  dwConvertedMinutes;      // Day/Hour/Min in Minutes
} CDF_TIME;


//////////////////////////////////////////////////////////////////////////
//
// Channel Agent object
//
//////////////////////////////////////////////////////////////////////////
class CChannelAgent : public CDeliveryAgent,
                      public CUrlDownloadSink,
                      public CProcessElementSink
{
    friend CProcessElement; // for SendUpdateProgress
    friend CProcessRoot;    // for laziness
protected:
// properties
    LPWSTR      m_pwszURL;
    DWORD       m_dwChannelFlags;

// used during updating
    CUrlDownload    *m_pCurDownload;
    IExtractIcon    *m_pChannelIconHelper;

    BOOL            m_fHasInitCookie;   // One time deal, don't try again.

    VARIANT         m_varChange;

    GROUPID         m_llCacheGroupID;
    GROUPID         m_llOldCacheGroupID;

    // other agent flags
    enum {
        FLAG_CDFCHANGED  =  0x80000000  // did the CDF change?
    };

private:
    ~CChannelAgent(void);

public:
    CChannelAgent(void);

    // CUrlDownloadSink
    HRESULT     OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword);
    HRESULT     OnDownloadComplete(UINT iID, int iError);

    // CProcessElementSink
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);
    LPCWSTR     GetBaseUrl() { return GetUrl(); }
    BOOL        IsGlobalLog() { return FALSE; }

    // virtual functions overriding CDeliveryAgent
    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);

    LPCWSTR     GetUrl() { return m_pwszURL; }
    ISubscriptionItem *GetStartItem() { return m_pSubscriptionItem; }

    BOOL        IsChannelFlagSet(DWORD dwFlag) { return dwFlag & m_dwChannelFlags; }

protected:
    // CDeliveryAgent overrides
    HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    void        CleanUp();

    // Used during updates
    CProcessRoot   *m_pProcess;

public:
    DWORD           m_dwMaxSizeKB;
};

//////////////////////////////////////////////////////////////////////////
//
// CRunDeliveryAgent object
// Will run a delivery agent and host it for you
// Create, call Init, then call StartAgent
// Use static function SafeRelease to safely release this class.
//
//////////////////////////////////////////////////////////////////////////
class CRunDeliveryAgent : public ISubscriptionAgentEvents
{
protected:
    virtual ~CRunDeliveryAgent();

    CRunDeliveryAgentSink *m_pParent;

    ULONG           m_cRef;

    ISubscriptionItem         *m_pItem;
    ISubscriptionAgentControl *m_pAgent;

    HRESULT     m_hrResult;
    BOOL        m_fInStartAgent;

    CLSID       m_clsidDest;

    void        CleanUp();

public:
    CRunDeliveryAgent();

    HRESULT Init(CRunDeliveryAgentSink *pParent, ISubscriptionItem *pItem, REFCLSID rclsidDest);

    void LeaveMeAlone() { m_pParent = NULL; }

inline static void SafeRelease(CRunDeliveryAgent * &pThis)
{ if (pThis) { pThis->m_pParent=NULL; pThis->Release(); pThis=NULL; } }

static HRESULT CreateNewItem(ISubscriptionItem **ppItem, REFCLSID rclsidAgent);

    // StartAgent will return E_PENDING if agent is running. Otherwise it will return
    //  synchronous result code from agent.
    HRESULT     StartAgent();

    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);
    STDMETHODIMP UpdateProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                        long lSizeDownloaded, long lProgressCurrent, long lProgressMax,
                        HRESULT hrStatus, LPCWSTR wszStatus);
    STDMETHODIMP UpdateEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                            long lSizeDownloaded,
                            HRESULT hrResult, LPCWSTR wszResult);
    STDMETHODIMP ReportError(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                             HRESULT hrError, LPCWSTR wszError);
};

class CChannelAgentHolder : public CRunDeliveryAgent,
                            public IServiceProvider
{
protected:
    ~CChannelAgentHolder();

public:
    CChannelAgentHolder(CChannelAgent *pChannelAgent, CProcessElement *pProcess);

    // IUnknown
    STDMETHODIMP        QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

protected:
    CChannelAgent *m_pChannelAgent;
    CProcessElement *m_pProcess;
};


//////////////////////////////////////////////////////////////////////////
//
// Process Element objects
//
// User of this class
//  1) Creates & passes in self & element
//  2) Calls Run
//  3) If E_PENDING, will receive call back "OnChildDone"
//
// The purpose of this class is simply to allow us to save our state of
//  walking the XML OM, so that we can host another deliver agent
//  (webcrawler). This requires us to return out to the thread's message
//  pump after sending the "agent start" to the web crawler.
// The if a webcrawl is initiated the class creates its own sink. Classes
//  also keep references to their spawned enumerations in case of an
//  abort, which comes from the root element (CProcessRoot instance)
//
//////////////////////////////////////////////////////////////////////////
class CProcessElement : public CProcessElementSink, public CRunDeliveryAgentSink
{
public:
    CProcessElement(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pEle);
    ~CProcessElement();

    // From CRunDeliveryAgent
    HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                       long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                       BOOL fSynchronous);

    typedef HRESULT (CChannelAgent::*PFNHANDLETAG)(LPCWSTR pwszTagName, IXMLElement *pEle);
    typedef struct
    {
        LPCWSTR         pwszTagName;
        PFNHANDLETAG    pfnHandleTag;
    } TAGTABLE;

    // E_FAIL, E_PENDING, or S_OK
    virtual HRESULT    Run();

    // Called when E_PENDING DoChild returns (from m_pCurChild)
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);


    HRESULT     Pause(DWORD dwFlags);
    HRESULT     Resume(DWORD dwFlags);
    HRESULT     Abort(DWORD dwFlags);

    IXMLElement *GetCurrentElement() { return m_pChildElement; }

protected:
    // Returns E_PENDING, or S_OK if enumeration complete
    HRESULT     DoEnumeration();

    // E_PENDING if webcrawl pending
    HRESULT     DoChild(CProcessElement *pChild);

    // Should return E_PENDING, or S_OK if processing done
    // Can return E_ABORT to abort entire CDF processing
    virtual HRESULT ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem) = 0;

    // Called by DoEnumeration when it's done. Return value ignored.
    virtual HRESULT EnumerationComplete() { return S_OK; }

    // E_PENDING, or E_FAIL
    HRESULT     DoDeliveryAgent(ISubscriptionItem *pItem, REFCLSID rclsid, LPCWSTR pwszURL=NULL);
    HRESULT     DoWebCrawl(IXMLElement *pItem, LPCWSTR pwszURL=NULL);
    HRESULT     DoSoftDist(IXMLElement *pItem);

    BOOL    ShouldDownloadLogo(IXMLElement *pLogo);

    // If relative url, will combine with most recent base URL
    // *ppwszRetUrl should be NULL & will be LocalAlloced if needed
    HRESULT     CombineWithBaseUrl(LPCWSTR pwszUrl, LPWSTR *ppwszRetUrl);

    // Returned pointer doesn't need to get freed
    LPCWSTR     GetBaseUrl() { return m_pParent->GetBaseUrl(); }
    BOOL        IsGlobalLog() { return m_pParent->IsGlobalLog(); }

    CProcessRoot    *m_pRoot;

    CProcessElement *m_pCurChild;
    IXMLElementCollection *m_pCollection;
    long            m_lIndex;
    long            m_lMax;
    BOOL            m_fStartedEnumeration;
    BOOL            m_fSentEnumerationComplete;

    IXMLElement    *m_pElement;
    IXMLElement    *m_pChildElement;

    CProcessElementSink *m_pParent;

    CRunDeliveryAgent   *m_pRunAgent;
};

class CProcessRoot : public CProcessElement
{
public:
    CProcessRoot(CChannelAgent *pParent, IXMLElement *pRoot);
    ~CProcessRoot();

    CChannelAgent      *m_pChannelAgent;
    DWORD               m_dwCurSizeKB;
    int                 m_iTotalStarted;
    BOOL                m_fMaxSizeExceeded;

protected:
    ISubscriptionItem  *m_pDefaultStartItem;
    CUrlTrackingCache  *m_pTracking;

public:
    HRESULT     CreateStartItem(ISubscriptionItem **ppItem);
    IUnknown   *DefaultStartItem() { return m_pDefaultStartItem; }

    HRESULT     Run();

    // Called when E_PENDING DoChild returns (from m_pCurChild, a CProcessChannel)
    HRESULT     OnChildDone(CProcessElement *pChild, HRESULT hr);
    HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

    BOOL        IsPaused() { return m_pChannelAgent->IsPaused(); }
    BOOL        IsChannelFlagSet(DWORD dw) { return m_pChannelAgent->IsChannelFlagSet(dw); }

//  HRESULT     ProcessLogin(IXMLElement *pElement);
    HRESULT     DoTrackingFromItem(IXMLElement *pItem, LPCWSTR pwszUrl, BOOL fForceLog);
    HRESULT     DoTrackingFromLog(IXMLElement *pItem);

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);

    LPCWSTR     GetBaseUrl() { return m_pChannelAgent->GetUrl(); }
};

class CProcessChannel : public CProcessElement
{
public:
    CProcessChannel(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
    ~CProcessChannel();
 
    HRESULT     Run();

    void        SetGlobalLogFlag(BOOL flag) { m_fglobalLog = flag; }

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);

    LPCWSTR     GetBaseUrl() { if (m_bstrBaseUrl) return m_bstrBaseUrl; return m_pParent->GetBaseUrl(); }

    BOOL        IsGlobalLog() { return m_fglobalLog; }

    HRESULT     CheckPreCache();

    BOOL        m_fDownloadedHREF;
    BSTR        m_bstrBaseUrl;
    BOOL        m_fglobalLog;
};

class CProcessItem : public CProcessElement
{
public:
    CProcessItem(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
    ~CProcessItem();

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     EnumerationComplete();

    BSTR        m_bstrAnchorURL;
    BOOL        m_fDesktop;
    BOOL        m_fEmail;
};

class CProcessSchedule : public CProcessElement
{
public:
    CProcessSchedule(CProcessElementSink *pParent, CProcessRoot *pRoot, IXMLElement *pItem);
 
    HRESULT     Run();

protected:
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     EnumerationComplete();

    CDF_TIME    m_timeInterval;
    CDF_TIME    m_timeEarliest;
    CDF_TIME    m_timeLatest;

    SYSTEMTIME  m_stStartDate;
    SYSTEMTIME  m_stEndDate;

public:
    TASK_TRIGGER m_tt;
};

class CExtractSchedule : public CProcessElement
{
public:
    CExtractSchedule(IXMLElement *pEle, CExtractSchedule *m_pExtractRoot);
    HRESULT     ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT     GetTaskTrigger(TASK_TRIGGER *ptt);

    virtual HRESULT    Run();

    TASK_TRIGGER m_tt;
    CExtractSchedule *m_pExtractRoot;

protected:    
    LPCWSTR     GetBaseUrl() { return NULL; }
};

#endif // _CDFAGENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\cdlagent.cpp ===
#include "private.h"
#include <urlmon.h>
#include <wininet.h>
#include <msxml.h>
#include "cdfagent.h"
#include "cdlabsc.h"
#include "cdlagent.h"
#include <urlmon.h>
#include <subsmgr.h>
#include "subsmgrp.h"

#include <mluisupp.h>

HRESULT GetXMLAttribute(IXMLElement *pItem, LPCWSTR pwszAttribute, VARIANT *pvRet);

CCDLAgent::CCDLAgent()
: m_pCCDLAgentBSC(NULL)
, m_szCDF(NULL)
, m_bAcceptSoftware(FALSE)
{
    m_sdi.cbSize = sizeof(SOFTDISTINFO);
    m_bSilentMode = TRUE;
}

CCDLAgent::~CCDLAgent()
{

    SAFERELEASE(m_pSoftDistElement);
    SAFERELEASE(m_pSoftDistExt);

    CRunDeliveryAgent::SafeRelease(m_pAgent);

    SAFEFREEOLESTR(m_szCDF);
    SAFEFREEBSTR(m_szErrorText);
    SAFEDELETE(m_sdi.szAbstract);
    SAFEDELETE(m_sdi.szTitle);
    SAFEDELETE(m_sdi.szHREF);
    SAFEFREEOLESTR(m_szDistUnit);
}

HRESULT CCDLAgent::StartOperation()
{
    HRESULT                  hr = S_OK, hr2;

    // unknown pointers
    IUnknown                *punk = NULL;
    IServiceProvider        *pSP;
    
    m_pSoftDistElement = NULL;
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szPropURL, &m_szURL)))
    {
        hr = E_INVALIDARG;
        goto Failed;
    }


    hr2 = E_FAIL;

    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        hr2 = pSP->QueryService(CLSID_XMLDocument, IID_IXMLElement, (void **)&punk);
        pSP->Release();
    }

    if (FAILED(hr2) || !punk)
    {
        // We are processing a request to pull a CAB, probably from Web Crawler agent.
        
        if (FAILED(ReadOLESTR(m_pSubscriptionItem, L"DistUnit", &m_szDistUnit)) ||
            FAILED(ReadDWORD(m_pSubscriptionItem, L"VersionMS",&m_dwVersionMS)) ||
            FAILED(ReadDWORD(m_pSubscriptionItem, L"VersionLS", &m_dwVersionLS)))
        {
            hr = E_INVALIDARG;
            goto Failed;
        }

        m_pSoftDistElement = NULL;
    }
    else
    {
        if (FAILED(punk->QueryInterface(IID_IXMLElement, (void **)&m_pSoftDistElement)))
        {
            SAFERELEASE(punk);
            hr = E_INVALIDARG;
            goto Failed;
        }

        SAFERELEASE(punk);

        Assert(m_pSoftDistElement);
    }


    ReadDWORD(m_pSubscriptionItem, c_szPropCrawlMaxSize, &m_dwMaxSizeKB);
    ReadDWORD(m_pSubscriptionItem, c_szPropChannelFlags, &m_dwChannelFlags);
    ReadDWORD(m_pSubscriptionItem, c_szPropAgentFlags, &m_dwAgentFlags);

    hr = CDeliveryAgent::StartOperation();

    return hr;

Failed:
    SetEndStatus(hr);
    SendUpdateNone();

    return hr;
}

HRESULT CCDLAgent::StartDownload()
{
    IBindCtx *pbc = NULL;
    HRESULT hr = S_OK;
    LPWSTR szCodeBase;
    DWORD dwSize;
    BOOL bCleanUpNow = FALSE;
    DWORD dwPolicy = 0;
    DWORD dwContext = 0;
    IInternetSecurityManager * pism = NULL;

    if (FAILED(GetEndStatus())) {
    
        hr = GetEndStatus();
        goto Exit;
    }

    hr = CoCreateInstance(CLSID_SoftDistExt, NULL, CLSCTX_INPROC_SERVER, IID_ISoftDistExt, (void **)&m_pSoftDistExt);

    if (FAILED(hr))
        goto Exit;

    // Process SOFTDIST tag structure if present.
    if (m_pSoftDistElement != NULL) {

        dwPolicy = 0xFFFF0000;

        if (FAILED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IInternetSecurityManager, (void**)&pism)) || !pism)
        {
            hr = E_ACCESSDENIED;
            goto Exit;
        }

        hr = pism->ProcessUrlAction(m_szURL, URLACTION_CHANNEL_SOFTDIST_PERMISSIONS,
                                (BYTE *)&dwPolicy, sizeof(dwPolicy),
                                (BYTE *)&dwContext, sizeof(dwContext), PUAF_NOUI, 0);
        
        pism->Release();

        if (FAILED(hr))
        {
            goto Exit;
        }

        dwPolicy &= 0xFFFF0000;

        if (dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT
            && dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_PRECACHE
            && dwPolicy != URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL)
        {
            hr = E_INVALIDARG;
            goto Exit;
        }

        if (dwPolicy == URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT)
        {
            hr = E_ACCESSDENIED;
            goto Exit;
        }

        hr = m_pSoftDistExt->ProcessSoftDist(m_szCDF, m_pSoftDistElement, &m_sdi);

        if (m_sdi.dwFlags & SOFTDIST_FLAG_DELETE_SUBSCRIPTION) {
            
            ISubscriptionMgr *pSubMgr = NULL;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&pSubMgr);
            if (SUCCEEDED(hr))
            {
                hr = pSubMgr->DeleteSubscription(m_szURL,NULL);
                pSubMgr->Release();
            }
      
            hr = S_FALSE;
        }

        // Send email & update software?
        if (hr == S_OK) {

        
            if (m_sdi.dwFlags) {
                
                m_bSendEmail = TRUE;

            } else {

                // no usage flag and no restriction implies no email.
                m_bSendEmail = FALSE;            
            }

            if (m_sdi.dwFlags & SOFTDIST_FLAG_USAGE_AUTOINSTALL) {
                
                m_bAcceptSoftware = (dwPolicy == URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL) ? TRUE : FALSE;
                m_bSilentMode = FALSE;

            } else if (m_sdi.dwFlags & SOFTDIST_FLAG_USAGE_PRECACHE) {

                // to get here, we must have precache or autoinstall policy permissions
                m_bAcceptSoftware = TRUE;
                
            } else {

                m_bAcceptSoftware = FALSE;

            }

        } else {
            m_bSendEmail = FALSE;
            m_bAcceptSoftware = FALSE;
            bCleanUpNow = TRUE;
        }
      
        // Do only code download from here on.
        if (!m_bAcceptSoftware || 
            !((m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_SOME) ||
            (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)) ) {

            // No caching allowed, return immediately.
    
            bCleanUpNow = TRUE;
            goto Exit;

         } else {
         
            if (m_dwChannelFlags & CHANNEL_AGENT_PRECACHE_ALL) {
                m_dwMaxSizeKB = 0;
            }
        }
        
    }

    m_pCCDLAgentBSC = new CDLAgentBSC(this, m_dwMaxSizeKB, m_bSilentMode, m_szCDF);
    if (m_pCCDLAgentBSC == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    // attempt to use AsyncInstallDistributionUnit

    hr = CreateBindCtx(0, &pbc);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    hr = RegisterBindStatusCallback(pbc, m_pCCDLAgentBSC, NULL, 0);
    if (FAILED(hr)) {
        goto Exit;
    }

    if (m_pSoftDistElement != NULL) {

        hr = m_pSoftDistExt->AsyncInstallDistributionUnit(pbc, NULL, 0, NULL);

        if (hr == S_OK) {
            SendUpdateNone();
        }
    
    } else {
        
        CODEBASEHOLD *pcbh = new CODEBASEHOLD;
        if (pcbh == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        pcbh->cbSize = sizeof(CODEBASEHOLD);
        pcbh->szDistUnit = m_szDistUnit;
        pcbh->szCodeBase = m_szURL;
        pcbh->dwVersionMS = m_dwVersionMS;
        pcbh->dwVersionLS = m_dwVersionLS;
        pcbh->dwStyle = 0;

        // Since notification is likely from web crawler and we only support MSICD we
        // don't fire a notification back.
        hr = m_pSoftDistExt->AsyncInstallDistributionUnit(pbc, NULL, 0, pcbh);

        if (hr == S_OK) {
            SendUpdateNone();
        }
        
        SAFEDELETE(pcbh);
        goto Exit;

    }
    
    if (hr != E_NOTIMPL) {
        // May have succeeded or failed, either way, we are out of here.
        goto Exit;
    }

    hr = m_pSoftDistExt->GetFirstCodeBase(&szCodeBase, &dwSize);

    if (SUCCEEDED(hr) && szCodeBase) {

        hr = StartNextDownload(szCodeBase,dwSize);
        SAFEDELETE(szCodeBase);

    } else {

        // no CODEBASE, return OK
        bCleanUpNow = TRUE;
        hr = S_OK;
    }

Exit:
    // In case of SOFTDIST tag we work asychronously and send an END_REPORT back immediately.  If we were called
    // to install a particular CAB then CleanUp is called by CDLABSC::OnStopBinding and report is sent back then.

    SAFERELEASE(pbc);

    if (FAILED(hr) || bCleanUpNow)
    {
        SetEndStatus(hr);
        CleanUp();
    }

    return hr;
}

HRESULT CCDLAgent::StartNextDownload(LPWSTR wzCodeBase, DWORD dwSize)
{
HRESULT hr = E_FAIL;
DWORD dwTemp = 0;
ISubscriptionItem *pItem;

    if (m_dwMaxSizeKB && (dwSize > m_dwMaxSizeKB))
    {
        hr = INET_E_AGENT_MAX_SIZE_EXCEEDED;
        goto Exit;
    }
    else
    {
        // Any other type of INSTALL protocol.

        // Send notification to WebCrawl agent to crawl the codebase.  This should force it in the 
        // case. Only do this if there is any chance the DL will not overflow the cache.
        // Note this will only download the CAB file and not any dependencies inside the CAB.  They
        // should be included as separate CONFIG entries.

        if (m_dwMaxSizeKB && ((m_dwCurSize>>10) > m_dwMaxSizeKB))
        {
            // We've exceeded our maximum download KB limit and can't continue.
            hr = INET_E_AGENT_MAX_SIZE_EXCEEDED;
            goto Exit;
        }

        if (FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)) || !pItem)
        {
            goto Exit;
        }

        dwTemp = DELIVERY_AGENT_FLAG_NO_BROADCAST;
        WriteDWORD(pItem, c_szPropAgentFlags, dwTemp);
        WriteOLESTR(pItem, c_szPropURL, wzCodeBase);
        if (m_dwMaxSizeKB)
        {
            // KB limit for us to pull.
            WriteDWORD(pItem, c_szPropCrawlMaxSize, m_dwMaxSizeKB - (m_dwCurSize>>10));
        }
        WriteDWORD(pItem, c_szPropCrawlLevels, 0);

        m_dwCurSize += dwSize;

        m_pAgent = new CRunDeliveryAgent();
        if (m_pAgent)
            hr = m_pAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_WebCrawlerAgent);
        pItem->Release();

        if (m_pAgent && SUCCEEDED(hr))
        {
            hr = m_pAgent->StartAgent();
            if (hr == E_PENDING)
            {
                hr = S_OK;
            }
            else
            {
                DBG_WARN("StartNextDownload in CDL agent failed!");
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

Exit:
    return hr;
}

HRESULT CCDLAgent::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    LPWSTR wzCodeBase = NULL;
    DWORD dwSize;

    ASSERT(m_pAgent != NULL);

    if (fSynchronous)
    {
        // We must have failed. Let StartNextDownload return failure.
        return S_OK;
    }

    CRunDeliveryAgent::SafeRelease(m_pAgent);

    if (SUCCEEDED(hrResult))
    {
        hr = m_pSoftDistExt->GetNextCodeBase(&wzCodeBase, &dwSize);

        if (SUCCEEDED(hr) && wzCodeBase)
        {
            hr = StartNextDownload(wzCodeBase, dwSize);
            SAFEDELETE(wzCodeBase);
            
            if (FAILED(hr)) {
                // we are done
                fDone = TRUE;
            }
            
        } else {

            // no more codebases to crawl
            hr = S_OK;
            fDone = TRUE;
        }
    }
    else
    {
        hr = hrResult;
        fDone = TRUE;
    }

    if (fDone) {
        SetEndStatus(hr);
        CleanUp();
    }

    return hr;
}

void CCDLAgent::CleanUp()
{
    if (m_pCCDLAgentBSC != NULL) {
        m_pCCDLAgentBSC->Release();
    }

    m_pCCDLAgentBSC = NULL;
    CDeliveryAgent::CleanUp();
}

void CCDLAgent::SetErrorEndText(LPCWSTR szErrorText)
{
    if (szErrorText)
        m_szErrorText = SysAllocString(szErrorText);
}

HRESULT CCDLAgent::AgentAbort(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Abort();
    }
    
    return hr;
}

HRESULT CCDLAgent::AgentPause(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Pause();
    }
    
    return hr;
}

HRESULT CCDLAgent::AgentResume(DWORD dwFlags)
{
    HRESULT              hr = S_OK;

    if (m_pCCDLAgentBSC != NULL )
    {
        hr = m_pCCDLAgentBSC->Resume();
    }
    
    return hr;
}


HRESULT CCDLAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    VARIANT vHref;

    ASSERT(pEndItem);

    // The END_REPORT is sent for both functionalities of CDL agent (SOFTDIST and Pull single CAB).
    // customize our end status string

    switch (GetEndStatus())
    {
        case E_OUTOFMEMORY  : *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_FALSE        : *puiRes = IDS_CRAWL_STATUS_UNCHANGED; break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;

            // This is actually a success code from URLMON
        case HRESULT_FROM_WIN32(ERROR_CANCELLED)
                            : SetEndStatus(S_OK);
                              *puiRes = IDS_CRAWL_STATUS_OK; break;

        case TRUST_E_FAIL   : SetEndStatus(TRUST_E_SUBJECT_NOT_TRUSTED);

        case TRUST_E_SUBJECT_NOT_TRUSTED :
            
        case HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE) : SetEndStatus(S_OK);
                                // fall through
        case S_OK           : *puiRes = IDS_CRAWL_STATUS_OK; break;
        default             : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
                    
            break;
    }

    // force gleam on this channel if we got S_OK on precaching bits
    if (SUCCEEDED(GetEndStatus()) && (GetEndStatus() != S_FALSE)) {
        WriteDWORD(pEndItem, c_szPropEnableShortcutGleam, 1);
    }

    // If we are sending email the status must be S_OK, we incorporate the error 
    // message into the text body for reporting.

    if (m_bSendEmail) {

        VariantInit(&vHref);

        WriteDWORD(pEndItem, c_szPropEmailFlags, MAILAGENT_FLAG_CUSTOM_MSG);

        // This must exist or m_bSendEmail would never have been set in first place.
        GetXMLAttribute(m_pSoftDistElement, L"HREF", &vHref);
    
        WriteOLESTR(pEndItem, c_szPropURL, vHref.bstrVal);
                   
        VariantClear(&vHref);

        if (m_sdi.szTitle) {
            BSTR bstrTitle = SysAllocString(m_sdi.szTitle);

            if (bstrTitle)
                WriteOLESTR(pEndItem, c_szPropEmailTitle, m_sdi.szTitle);

            SAFEFREEBSTR(bstrTitle);
        }

        if (FAILED(GetEndStatus()) && !m_szErrorText) {
            m_szErrorText = GetErrorMessage(GetEndStatus());
        }

        if (m_sdi.szAbstract) {

            BSTR bstrAbstract = SysAllocString(m_sdi.szAbstract);
                       
            if (bstrAbstract != NULL) {
                           
                if (m_szErrorText) {

                    //This is wrecking havoc with the email message, some resource strings
                    //have a 'CR/LF' tacked on the end.  We kill any that exist.
                    DWORD dwLen = lstrlenW(m_szErrorText)-1;
                    while (dwLen > 0 && 
                        (m_szErrorText[dwLen] == 0x0a 
                        || m_szErrorText[dwLen] == 0x0d
                        || m_szErrorText[dwLen] == L'.'))
                    {
                        m_szErrorText[dwLen] = L'\0';
                        dwLen--;
                    }

                    //  BUGBUG - needs cleanup!
                    CHAR szPrefixMsg[MAX_PATH], szFormattedPrefixMsg[MAX_PATH*2];
                    if (MLLoadStringA(IDS_CDLAGENT_ERROR_EMAIL, szPrefixMsg, ARRAYSIZE(szPrefixMsg))>0) {
                                
                        LPWSTR wszNewAbstract = NULL;
                        LPSTR szNewAbstract = NULL;

                        wnsprintfA(szFormattedPrefixMsg, 
                                   ARRAYSIZE(szFormattedPrefixMsg),
                                   szPrefixMsg, 
                                   m_szErrorText);
                        DWORD dwNewLen = lstrlenA(szFormattedPrefixMsg) + lstrlenW(bstrAbstract) + 4;
                        szNewAbstract = (LPSTR)LocalAlloc(0,dwNewLen*sizeof(CHAR));
                        if (szNewAbstract) {
                            wnsprintfA(szNewAbstract, 
                                       dwNewLen*sizeof(CHAR),
                                       "%s%ws", 
                                       szFormattedPrefixMsg, 
                                       bstrAbstract);
                            dwNewLen = lstrlenA(szNewAbstract) + 1;
                            wszNewAbstract = (LPWSTR)LocalAlloc(0,dwNewLen*sizeof(WCHAR));

                            if (wszNewAbstract &&
                                (MultiByteToWideChar(CP_ACP, 0, szNewAbstract, -1, wszNewAbstract, dwNewLen)>0)) {
                                 SAFEFREEBSTR(bstrAbstract);
                                 bstrAbstract = SysAllocString(wszNewAbstract);               
                            }

                            if (wszNewAbstract)
                                LocalFree(wszNewAbstract);

                            LocalFree(szNewAbstract);
                        }    
                                    
                    }
                }
                            
                WriteOLESTR(pEndItem, c_szPropEmailAbstract, bstrAbstract);

                SAFEFREEBSTR(bstrAbstract);
            }
                                            
        }

        // because user is notified of error we don't pass it on anywhere else
        SetEndStatus(S_OK);

        WriteSCODE(pEndItem, c_szPropStatusCode, S_OK);
    }

    ClearAgentFlag(DELIVERY_AGENT_FLAG_NO_BROADCAST);
    
    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}

LPWSTR CCDLAgent::GetErrorMessage(HRESULT hr)
{
    LPSTR szBuf = NULL;
    LPWSTR wszBuf = NULL;
    DWORD dwLen;
    DWORD dwResource = 0;

    if (SUCCEEDED(hr))
        return NULL;

    dwLen = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                          hr, 0, (LPTSTR)&szBuf, 0, NULL);
    if (!dwLen) {

        // NOTE: If out of memory we return NULL.
        if (SUCCEEDED(hr))
            dwResource = IDS_CDLAGENT_SUCCESS;
        else if (hr == TRUST_E_SUBJECT_NOT_TRUSTED)
            dwResource = IDS_CDLAGENT_TRUST_ERROR;
        else 
            dwResource = IDS_CDLAGENT_FAILURE;

        // We know strings will fit into max_path
        WCHAR szTmp[MAX_PATH];
        if (MLLoadStringW(dwResource, szTmp, MAX_PATH)>0) {
            wszBuf = SysAllocString(szTmp);
        }
        
    } else {

        WCHAR wszTemp[MAX_PATH];
        if (MultiByteToWideChar(CP_ACP, 0, szBuf, -1, wszTemp, ARRAYSIZE(wszTemp))>0) {   
            wszBuf = SysAllocString(wszTemp);
        } else
            wszBuf = NULL;

        SAFEDELETE(szBuf);
    }

    return wszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "webcheck"
#define SZ_MODULE       "WEBCHECK"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\delagent.cpp ===
#include "private.h"
#include "subsmgrp.h"

#include <mluisupp.h>

// These next three are just so we can set the gleam on the channel bar
#include "chanmgr.h"
#include "chanmgrp.h"
#include "shguidp.h"    // IID_IChannelMgrPriv
//

#include "helper.h"
#include "propshts.h"

#include "apithk.h"

#define TF_THISMODULE TF_DELAGENT

CDeliveryAgent::CDeliveryAgent()
{
    // Maintain global count of objects
    DllAddRef();

    // Initialize object
    m_cRef = 1;

#ifdef AGENT_AUTODIAL
    m_iDialerStatus = DIALER_OFFLINE;
#endif

    SetEndStatus(INET_S_AGENT_BASIC_SUCCESS);
}

CDeliveryAgent::~CDeliveryAgent()
{
    DllRelease();

    CleanUp();
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) CDeliveryAgent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDeliveryAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDeliveryAgent::QueryInterface(REFIID riid, void ** ppv)
{

    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionAgentControl == riid))
    {
        *ppv=(ISubscriptionAgentControl *)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppv=(IShellPropSheetExt *)this;
    }
    else if (IID_IExtractIconA == riid)
    {
        *ppv=(IExtractIconA *)this;
    }
    else if (IID_IExtractIcon == riid)
    {
        *ppv=(IExtractIcon *)this;
    }
    else if (IID_ISubscriptionAgentShellExt == riid)
    {
        *ppv=(ISubscriptionAgentShellExt *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IShellPropSheetExt members

HRESULT CDeliveryAgent::RemovePages(HWND hdlg)
{
    HRESULT hr = S_OK;

    for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
    {
        if (NULL != m_hPage[i])
        {
            PropSheet_RemovePage(hdlg, 0, m_hPage[i]);
            m_hPage[i] = NULL;
        }
    }
    
    return hr;
}

HRESULT CDeliveryAgent::SaveSubscription()
{
    return SaveBufferChange(m_pBuf, TRUE);
}

HRESULT CDeliveryAgent::URLChange(LPCWSTR pwszNewURL)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::AddPages(LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    HRESULT hr = S_OK;  //  optimistic
    PROPSHEETPAGE psp;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_DEFAULT;
    psp.hInstance       = MLGetHinst();
    psp.pszIcon         = NULL;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)m_pBuf;

    psp.pszTemplate     = MAKEINTRESOURCE(IDD_SUBSPROPS_SCHEDULE);
    psp.pfnDlgProc      = SchedulePropDlgProc;

    m_hPage[0] = Whistler_CreatePropertySheetPageW(&psp);

    psp.pszTemplate     = MAKEINTRESOURCE((m_pBuf->clsidDest == CLSID_ChannelAgent) ?
                                          IDD_SUBSPROPS_DOWNLOAD_CHANNEL :
                                          IDD_SUBSPROPS_DOWNLOAD_URL);
    psp.pfnDlgProc      = DownloadPropDlgProc;
    m_hPage[1] = Whistler_CreatePropertySheetPageW(&psp);

    if ((NULL != m_hPage[0]) && (NULL != m_hPage[1]))
    {
        for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
        {
            if (!lpfn(m_hPage[i], lParam))
            {
                hr = E_FAIL;
                break;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        for (int i = 0; i < ARRAYSIZE(m_hPage); i++)
        {
            if (NULL != m_hPage[i]) 
            {
                DestroyPropertySheetPage(m_hPage[i]);
                m_hPage[i] = NULL;
            }
        }
    }

    return hr;
}

HRESULT CDeliveryAgent::ReplacePage(UINT pgId, LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    return E_NOTIMPL;
}

// IExtractIconA members
HRESULT CDeliveryAgent::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return IExtractIcon_GetIconLocationThunk((IExtractIconW *)this, uFlags, szIconFile, cchMax, piIndex, pwFlags);
}

HRESULT CDeliveryAgent::Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return IExtractIcon_ExtractThunk((IExtractIconW *)this, pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}

// IExtractIconT members
HRESULT CDeliveryAgent::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::Extract(LPCTSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return E_NOTIMPL;
}

HRESULT CDeliveryAgent::Initialize(SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                                   LPCWSTR pwszURL, LPCWSTR pwszName, 
                                   SUBSCRIPTIONTYPE subsType)
{
    HRESULT hr;

    ASSERT(NULL == m_pBuf);

    m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));

    if (NULL != m_pBuf)
    {
        ISubscriptionItem *psi;

        hr = SubscriptionItemFromCookie(FALSE, pSubscriptionCookie, &psi);
        
        if (SUCCEEDED(hr))
        {
            DWORD dwSize;

            m_SubscriptionCookie = *pSubscriptionCookie;

            hr = LoadWithCookie(NULL, m_pBuf, &dwSize, pSubscriptionCookie);
            psi->Release();
        }
        else
        {
            hr = GetDefaultOOEBuf(m_pBuf, subsType);
            MyOleStrToStrN(m_pBuf->m_URL, ARRAYSIZE(m_pBuf->m_URL), pwszURL);
            MyOleStrToStrN(m_pBuf->m_Name, ARRAYSIZE(m_pBuf->m_Name), pwszName);
            m_pBuf->m_Cookie = *pSubscriptionCookie;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


// ISubscriptionAgentControl members
STDMETHODIMP CDeliveryAgent::StartUpdate(IUnknown *pItem, IUnknown *punkAdvise)
{
    HRESULT hr;
    DWORD dwTemp;
    VARIANT_BOOL  fTemp;

    m_lSizeDownloadedKB = -1;

    SAFERELEASE(m_pAgentEvents);
    punkAdvise->QueryInterface(IID_ISubscriptionAgentEvents, (void **)&m_pAgentEvents);

    // For now detect either notification or subscription item
    if (FAILED(pItem->QueryInterface(IID_ISubscriptionItem, (void **)&m_pSubscriptionItem)))
    {
        DBG_WARN("CDeliveryAgent::StartUpdate not an ISubscriptionItem!");
        return E_FAIL;
    }

    // We have a subscription item! Use it.
    TraceMsg(TF_THISMODULE, "CDeliveryAgent::StartUpdate at thread 0x%08x", GetCurrentThreadId());

    ASSERT(!IsAgentFlagSet(FLAG_BUSY));
    if (IsAgentFlagSet(FLAG_BUSY))
        return E_FAIL;

    ASSERT(m_pSubscriptionItem);

    SetEndStatus(INET_S_AGENT_BASIC_SUCCESS);
    m_dwAgentFlags = 0;

    m_pSubscriptionItem->GetCookie(&m_SubscriptionCookie);

    if (SUCCEEDED(ReadDWORD(m_pSubscriptionItem, c_szPropAgentFlags, &dwTemp)))
    {
        ASSERT(!(dwTemp & 0xFFFF0000));
        dwTemp &= 0xFFFF;           // only let them set lower 16 bits
        m_dwAgentFlags |= dwTemp;   // set flags client specifies
    }

    fTemp=FALSE;
    ReadBool(m_pSubscriptionItem, c_szPropCrawlChangesOnly, &fTemp);
    if (fTemp)
    {
        SetAgentFlag(FLAG_CHANGESONLY);
    }

    SetAgentFlag(FLAG_OPSTARTED);
    hr = StartOperation();

    return hr;
}

STDMETHODIMP CDeliveryAgent::PauseUpdate(DWORD dwFlags)
{
    DBG("CDeliveryAgent::PauseUpdate");

    if (!IsAgentFlagSet(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE))
    {
        SetAgentFlag(FLAG_PAUSED);
        return AgentPause(dwFlags);
    }

    return S_FALSE;
}

HRESULT CDeliveryAgent::AgentPause(DWORD dwFlags)
{
    return S_OK;
}

STDMETHODIMP CDeliveryAgent::ResumeUpdate(DWORD dwFlags)
{
    DBG("CDeliveryAgent::ResumeUpdate");

    if (IsAgentFlagSet(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE))
    {
        if (IsAgentFlagSet(FLAG_WAITING_FOR_INCREASED_CACHE))
            dwFlags |= SUBSCRIPTION_AGENT_RESUME_INCREASED_CACHE;

        ClearAgentFlag(FLAG_PAUSED | FLAG_WAITING_FOR_INCREASED_CACHE);
        return AgentResume(dwFlags);
    }

    return S_FALSE;
}

HRESULT CDeliveryAgent::AgentResume(DWORD dwFlags)
{
    return S_OK;
}

STDMETHODIMP CDeliveryAgent::AbortUpdate(DWORD dwFlags)
{
    TraceMsg(TF_THISMODULE, "AbortUpdate at Thread %d", GetCurrentThreadId());

    // Fill in status code if someone else hasn't already
    if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
    {
        if (IsAgentFlagSet(FLAG_WAITING_FOR_INCREASED_CACHE))
        {
            SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
        }
        else
        {
            SetEndStatus(E_ABORT);
        }
    }

    AddRef();

    // This may release us if the agent cleans itself up
    if (E_PENDING != AgentAbort(dwFlags))
    {
        // Will call "UpdateEnd" if necessary
        CleanUp();
    }

    Release();

    return S_OK;
}

HRESULT CDeliveryAgent::AgentAbort(DWORD dwFlags)
{
    return S_OK;
}

HRESULT CDeliveryAgent::SubscriptionControl(IUnknown *pItem, DWORD dwControl)
{
    if (dwControl & SUBSCRIPTION_AGENT_DELETE)
    {
        // Clean up our cache group
        GROUPID llGroupID;
        ISubscriptionItem *psi=NULL;

        pItem->QueryInterface(IID_ISubscriptionItem, (void **)&psi);
        if (psi)
        {
            if (SUCCEEDED(ReadLONGLONG(psi, c_szPropCrawlGroupID, &llGroupID))
                && (0 != llGroupID))
            {
                if (ERROR_SUCCESS != DeleteUrlCacheGroup(llGroupID, 0, 0))
                {
                    DBG_WARN("Failed to delete subscription cache group!");
                }
            }

            psi->Release();
        }
    }

    return S_OK;
}


#ifdef AGENT_AUTODIAL
HRESULT CDeliveryAgent::OnInetOnline()
{
    HRESULT hr=S_OK;

    if (m_iDialerStatus == DIALER_CONNECTING)
    {
        DBG("Delivery Agent: connection successful, beginning download");

        m_iDialerStatus=DIALER_ONLINE;

        hr = DoStartDownload();
    }

    return hr;
}
#endif

HRESULT CDeliveryAgent::DoStartDownload()
{
    HRESULT hr;

    // Always reset cache browser session. Webcrawler will avoid downloading dups.
    // Reset the cache session to hit the net on urls
    // CUrlDownload will use RESYNCHRONIZE flag if SYNC_MODE is Never
    InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);

    // Refcount just in case our derived class cleans itself up synchronously, yet
    //  returns failure (cdlagent)
    AddRef();
    
    hr = StartDownload();

    if (FAILED(hr))
    {
        DBG_WARN("DeliveryAgent: StartDownload failed");
        if (GetEndStatus() == INET_S_AGENT_BASIC_SUCCESS)
            SetEndStatus(hr);
        CleanUp();
    }

    Release();

    return hr;
}

#ifdef AGENT_AUTODIAL
HRESULT CDeliveryAgent::OnInetOffline()
{
    DBG("DeliveryAgent: received InetOffline, aborting");

    m_iDialerStatus=DIALER_OFFLINE;

    ASSERT(IsAgentFlagSet(FLAG_BUSY));    // we have send update begin

    SetEndStatus(INET_E_AGENT_CONNECTION_FAILED);

    // we can look at Status from dialer notification here

    AbortUpdate(0);

    return S_OK;
}
#endif // AGENT_AUTODIAL

void CDeliveryAgent::SendUpdateBegin()
{
    ASSERT(!IsAgentFlagSet(FLAG_BUSY));
    ASSERT(m_pAgentEvents);

    if (!IsAgentFlagSet(FLAG_BUSY))
    {
        SetAgentFlag(FLAG_BUSY);

        AddRef();       // Keep an additional reference while "busy"
    }

    // New interface way
    m_pAgentEvents->UpdateBegin(&m_SubscriptionCookie);
}

void CDeliveryAgent::SendUpdateProgress(LPCWSTR pwszURL, long lCurrent, long lMax, long lCurSizeKB)
{
    ASSERT(IsAgentFlagSet(FLAG_BUSY));

    // New interface way
    m_pAgentEvents->UpdateProgress(&m_SubscriptionCookie, lCurSizeKB,
                                        lCurrent, lMax, S_OK, pwszURL);
}

void CDeliveryAgent::SendUpdateEnd()
{
    ASSERT(m_pSubscriptionItem);
    ASSERT(m_pAgentEvents);

    UINT uiRes;
    ISubscriptionItem *pEndItem=NULL;
    LPWSTR pwszEndStatus=NULL;
    TCHAR szEndStatus[MAX_RES_STRING_LEN];
    WCHAR wszEndStatus[MAX_RES_STRING_LEN];

    WriteSCODE(m_pSubscriptionItem, c_szPropStatusCode, GetEndStatus());

    if (SUCCEEDED(GetEndStatus()))
    {
        // Put in end time.
        SYSTEMTIME st;
        DATE dt;

        GetLocalTime(&st);
        if (SystemTimeToVariantTime(&st, &dt))
        {
            // there was no error in GetLocalTime or SystemTimeToVariantTime
            WriteDATE(m_pSubscriptionItem, c_szPropCompletionTime, &dt);
        }
        else
        {
            SetEndStatus(E_FAIL);
        }
    }

    if (GetEndStatus() == INET_S_AGENT_BASIC_SUCCESS)
        SetEndStatus(S_OK);

    switch (GetEndStatus())
    {
    case INET_E_AGENT_MAX_SIZE_EXCEEDED     : uiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
    case INET_E_AGENT_CACHE_SIZE_EXCEEDED   : uiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
    case INET_E_AUTHENTICATION_REQUIRED     : uiRes = IDS_STATUS_AUTHFAILED; break;
    case INET_E_AGENT_CONNECTION_FAILED     : uiRes = IDS_STATUS_DIAL_FAIL; break;
    case E_OUTOFMEMORY                      : uiRes = IDS_STATUS_OUTOFMEMORY; break;
    case E_INVALIDARG                       : uiRes = IDS_STATUS_BAD_URL; break;
    case E_ABORT                            : uiRes = IDS_STATUS_ABORTED; break;
    case S_FALSE                            : uiRes = IDS_STATUS_UNCHANGED; break;
    default:
        if (FAILED(GetEndStatus()))
            uiRes = IDS_STATUS_NOT_OK;
        else
            uiRes = IDS_STATUS_OK;
        break;
    }
    DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pEndItem);

    ModifyUpdateEnd(pEndItem, &uiRes);

    // Write returned uiRes string into end report (returned -1 means don't touch it)
    if (uiRes != (UINT)-1)
    {
        if (MLLoadString(uiRes, szEndStatus, ARRAYSIZE(szEndStatus)))
        {
            MyStrToOleStrN(wszEndStatus, ARRAYSIZE(wszEndStatus), szEndStatus);
            if (pEndItem)
                WriteOLESTR(pEndItem, c_szPropStatusString, wszEndStatus);
            WriteOLESTR(m_pSubscriptionItem, c_szPropStatusString, wszEndStatus);
            pwszEndStatus = wszEndStatus;
        }
        else
            WriteEMPTY(m_pSubscriptionItem, c_szPropStatusString);
    }

    // ReportError if our end status is an error
    if (FAILED(GetEndStatus()))
    {
        m_pAgentEvents->ReportError(&m_SubscriptionCookie, GetEndStatus(), pwszEndStatus);
    }

    m_pAgentEvents->UpdateEnd(&m_SubscriptionCookie, 
                    m_lSizeDownloadedKB, GetEndStatus(), pwszEndStatus);

#ifdef AGENTS_AUTODIAL
    // Tell the dialer it can hang up now
    if (m_pConnAgent != NULL)
        NotifyAutoDialer(DIALER_HANGUP);

    m_iDialerStatus = DIALER_OFFLINE;
#endif

    // Check for appropriate behavior on end item. Don't do anything if we're
    //  not a subscription in our own right.
    if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_BROADCAST))
    {
        if (pEndItem)
            ProcessEndItem(pEndItem);
        else
            ProcessEndItem(m_pSubscriptionItem);
    }

    if (!IsAgentFlagSet(FLAG_HOSTED))
    {
        m_pSubscriptionItem->NotifyChanged();
    }

    SAFERELEASE(pEndItem);

    if (IsAgentFlagSet(FLAG_BUSY))
    {
        ClearAgentFlag(FLAG_BUSY);

        // Release the reference we had to ourself
        Release();
    }
}

// This calls callback and cleans everything up properly
void CDeliveryAgent::SendUpdateNone()
{
    ASSERT(FAILED(GetEndStatus()));  // set this before calling
    ASSERT(!IsAgentFlagSet(FLAG_BUSY));// shouldn't call here if busy

    AddRef();

    if (!IsAgentFlagSet(FLAG_BUSY))
        SendUpdateEnd();

    CleanUp();

    Release();
}

// Process the End Item including all stuff set by the base class
// This has functionality previously in the Tray Agent
// Send email, set gleam, refresh desktop, etc.
HRESULT CDeliveryAgent::ProcessEndItem(ISubscriptionItem *pEndItem)
{
    HRESULT hr;

    if (SUCCEEDED(GetEndStatus()))
    {
        //
        // Special feature for desktop HTML:
        // If we receive an end report with "DesktopComponent=1" in it,
        // let the desktop know that it needs to refresh itself.  We always
        // do this instead of only on "changes detected" because desktop
        // component authors don't want to change their CDFs.
        //
        DWORD dwRet;
        HRESULT hr2 = ReadDWORD(pEndItem, c_szPropDesktopComponent, &dwRet);
        if (SUCCEEDED(hr2) && (dwRet == 1))
        {
            IActiveDesktop *pAD = NULL;
            hr2 = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (void**)&pAD);
            DBGASSERT(SUCCEEDED(hr2), "Unable to create ActiveDesktop in order to refresh desktop component");
            if (SUCCEEDED(hr2))
            {
                ASSERT(pAD);
                pAD->ApplyChanges(AD_APPLY_FORCE | AD_APPLY_REFRESH | AD_APPLY_BUFFERED_REFRESH);
                pAD->Release();
            }
        }
    }

    //
    // Gleam the Internet Shortcut for the URL if requested.  (EnableShortcutGleam=1)
    // Filter End Reports without changes (S_FALSE)
    //
    if (SUCCEEDED(GetEndStatus()) && (S_FALSE != GetEndStatus()))
    {
        DWORD dwRet;
        hr = ReadDWORD(pEndItem, c_szPropEnableShortcutGleam, &dwRet);
        if (SUCCEEDED(hr) && dwRet)
        {
            LPTSTR strURL = NULL;
            hr = ReadTSTR(pEndItem, c_szPropURL, &strURL);
            if (SUCCEEDED(hr))
            {
                PROPVARIANT propvar;
                PropVariantInit(&propvar);
                hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, FALSE);
                if (SUCCEEDED(hr) && (VT_UI4 == propvar.vt))
                {
                    // Set our flag without disturbing the others.
                    propvar.ulVal |= PIDISF_RECENTLYCHANGED;  
                }
                else
                {
                    // Be sure to clear the variant if it wasn't a DWORD.
                    PropVariantClear(&propvar);
                    propvar.vt = VT_UI4;
                    propvar.ulVal = PIDISF_RECENTLYCHANGED;  
                }

                //
                // Update channels (painful).
                //

                hr = ReadDWORD(pEndItem, c_szPropChannel, &dwRet);
                BOOL bChannel = SUCCEEDED(hr) && dwRet;

                //  REARCHITECT -  Once cdfview is fixed, we can fix this.
                
                TCHAR tszChanImgPath[MAX_PATH];
                CHAR szChanImgPath[MAX_PATH];
                CHAR szChanImgHash[MAX_PATH];
                int  iChanImgIndex = 0; // init to keep compiler happy
                UINT uChanImgFlags = 0; // init to keep compiler happy
                int  iChanImgImageIndex = 0; // init to keep compiler happy

                IChannelMgrPriv*   pIChannelMgrPriv = NULL;
                HRESULT            hr2 = E_FAIL;

                if (bChannel)
                {
                    hr2 = GetChannelPath(strURL, tszChanImgPath,
                                         ARRAYSIZE(tszChanImgPath),
                                         &pIChannelMgrPriv);
                    if (SUCCEEDED(hr2))
                    {
                        SHTCharToAnsi(tszChanImgPath, szChanImgPath, ARRAYSIZE(szChanImgPath));
                        hr2 = (pIChannelMgrPriv)->PreUpdateChannelImage(
                                                    szChanImgPath,
                                                    szChanImgHash,
                                                    &iChanImgIndex,
                                                    &uChanImgFlags,
                                                    &iChanImgImageIndex);
                    }
                }

                // Set the gleam in the intsite database
                hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, TRUE);
                DBGASSERT(SUCCEEDED(hr), "CTrayAgent::OnNotification - failed to set gleam.");

                if (bChannel && SUCCEEDED(hr2))
                {
                    ASSERT(pIChannelMgrPriv);

                    pIChannelMgrPriv->InvalidateCdfCache();
                    // brilliant - the api requires us to convert their own return value
                    WCHAR wszHash[MAX_PATH];
                    SHAnsiToUnicode(szChanImgHash, wszHash, ARRAYSIZE(wszHash));

                    pIChannelMgrPriv->UpdateChannelImage(
                                                wszHash,
                                                iChanImgIndex,
                                                uChanImgFlags,
                                                iChanImgImageIndex);
                }
                if (pIChannelMgrPriv)
                    pIChannelMgrPriv->Release();
            }
            MemFree(strURL); // Free the string allocated by ReadAnsiSTR().
        }// end setting gleam

        //
        // Send Email to notify the user if requested (EmailNotification=1)
        // NOTE: Updates without changes (S_FALSE) were filtered above.
        //
        hr = ReadDWORD(pEndItem, c_szPropEmailNotf, &dwRet);
        if (SUCCEEDED(hr) && dwRet)
        {
            hr = SendEmailFromItem(pEndItem);
        }
    }

    return S_OK;
}

// Checks the status code after all actions such as authentication and redirections
//  have taken place.
HRESULT CDeliveryAgent::CheckResponseCode(DWORD dwHttpResponseCode)
{
    TraceMsg(TF_THISMODULE, "CDeliveryAgent processing HTTP status code %d", dwHttpResponseCode);

    switch (dwHttpResponseCode / 100)
    {
        case 1 :    DBG("HTTP 1xx response?!?");
        case 2 :
            return S_OK;    // Success

        case 3 :
            if (dwHttpResponseCode == 304)
                return S_OK;    // Not Modified
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;     // Redirection

        case 4 :
            if (dwHttpResponseCode == 401)
            {
                SetEndStatus(INET_E_AUTHENTICATION_REQUIRED);
                return E_ABORT;
            }
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;

        case 5 :
        default:
            SetEndStatus(E_INVALIDARG);
            return E_ABORT;
    }

/*  
    //  Unreachable code
    SetEndStatus(E_FAIL);
    return E_FAIL;

*/
}

//============================================================
//   virtual functions designed to be overridden as necessary
//============================================================

HRESULT CDeliveryAgent::StartOperation()
{
    HRESULT hr = S_OK;

#ifdef AGENT_AUTODIAL
    // We are ready to go. Now we make sure we're actually connected to
    //  the internet and then go for it.
    if (IsAgentFlagSet(DELIVERY_AGENT_FLAG_SILENT_DIAL))
    {
        m_iDialerStatus = DIALER_CONNECTING;

        hr = NotifyAutoDialer(DIALER_START);
    }

    if (SUCCEEDED(hr))
    {
        // Send this whether we're 'dialing' or not
        SendUpdateBegin();
    }
    else
    {
        DBG("NotifyAutoDialer failed, delivery agent aborting.");
        SetEndStatus(E_ACCESSDENIED);
        SendUpdateNone();
        return E_FAIL;
    }

    if (IsAgentFlagSet(DELIVERY_AGENT_FLAG_SILENT_DIAL))
    {
        hr = DoStartDownload();
    }
#else
    SendUpdateBegin();
    hr = DoStartDownload();
#endif

    return hr;
}

HRESULT CDeliveryAgent::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    return S_OK;
}

void CDeliveryAgent::CleanUp()
{
    BOOL fAdded=FALSE;

    if (m_cRef > 0)
    {
        fAdded = TRUE;
        AddRef();
    }

    if (IsAgentFlagSet(FLAG_BUSY))
        SendUpdateEnd();

    SAFERELEASE(m_pAgentEvents);
    SAFERELEASE(m_pSubscriptionItem);

    if (fAdded)
        Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\delagent.h ===
//
// Delivery Agents base class

#ifndef _DELAGENT_H
#define _DELAGENT_H

#include "offline.h"

#define INET_S_AGENT_BASIC_SUCCESS           _HRESULT_TYPEDEF_(0x000C0FFEL)

class CDeliveryAgent :  public ISubscriptionAgentControl,
                        public IShellPropSheetExt,
                        public IExtractIconA,
                        public IExtractIcon,
                        public ISubscriptionAgentShellExt
{
private:
// Data for our OLE support
    ULONG           m_cRef;

#ifdef AGENT_AUTODIAL
    enum DIALER_STATUS { DIALER_OFFLINE, DIALER_CONNECTING, DIALER_ONLINE };
    DIALER_STATUS   m_iDialerStatus;
#endif

    enum {
        FLAG_BUSY          =0x00010000,   // addrefed ourselves; between begin & end reports
        FLAG_PAUSED        =0x00020000,   // We are paused
        FLAG_OPSTARTED     =0x00040000,   // We've entered StartOperation
    };

    // Derived agents can use high 8 bits of this field
    DWORD       m_dwAgentFlags;

    void        SendUpdateBegin();
    void        SendUpdateEnd();
    HRESULT     ProcessEndItem(ISubscriptionItem *pEndItem);


protected:
    // Upper 16 bits allowable here
    enum    {
        FLAG_HOSTED        =0x00100000,     // hosted by another delivery agent
        FLAG_CHANGESONLY   =0x00200000,     // We're in "Changes Only" mode
        FLAG_WAITING_FOR_INCREASED_CACHE = 0x00400000, // Special paused state
    };

    POOEBuf         m_pBuf;
    HPROPSHEETPAGE  m_hPage[MAX_WC_AGENT_PAGES];

    ISubscriptionAgentEvents *m_pAgentEvents;
    ISubscriptionItem        *m_pSubscriptionItem;
    
    SUBSCRIPTIONCOOKIE      m_SubscriptionCookie;

    long        m_lSizeDownloadedKB;    // Size downloaded in KB

    SCODE       m_scEndStatus;

    void        SendUpdateNone();   // Call from StartOperation if we won't be doing anything

    void        SendUpdateProgress(LPCWSTR pwszURL, long lProgress, long lMax, long lCurSizeKB=-1);

    BOOL        IsAgentFlagSet(int iFlag) { return (m_dwAgentFlags & iFlag); }
    void        ClearAgentFlag(int iFlag) { m_dwAgentFlags &= ~iFlag; }
    void        SetAgentFlag(int iFlag) { m_dwAgentFlags |= iFlag; }
    
    HRESULT     CheckResponseCode(DWORD dwHttpResponseCode);    // Also sets EndStatus. E_ABORT on error.

//  DIALER_STATUS GetDialerStatus() { return m_iDialerStatus; }
    void          SetEndStatus(SCODE sc) { m_scEndStatus = sc; }

    virtual ~CDeliveryAgent();

public:
    CDeliveryAgent();

    BOOL        GetBusy() { return IsAgentFlagSet(FLAG_BUSY); }
    BOOL        IsPaused() { return IsAgentFlagSet(FLAG_PAUSED); }

    SCODE       GetEndStatus() { return m_scEndStatus; }

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ISubscriptionAgentControl members
    STDMETHODIMP    StartUpdate(IUnknown *pItem, IUnknown *punkAdvise);
    STDMETHODIMP    PauseUpdate(DWORD dwFlags);
    STDMETHODIMP    ResumeUpdate(DWORD dwFlags);
    STDMETHODIMP    AbortUpdate(DWORD dwFlags);
    STDMETHODIMP    SubscriptionControl(IUnknown *pItem, DWORD dwControl);   // Called on delete

    // IShellPropSheetExt members
    STDMETHODIMP    AddPages(LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHODIMP    ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

    // ISubscriptionAgentShellExt
    STDMETHODIMP    Initialize(SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               LPCWSTR pwszURL, LPCWSTR pwszName, 
                               SUBSCRIPTIONTYPE subsType);
    STDMETHODIMP    RemovePages(HWND hdlg);
    STDMETHODIMP    SaveSubscription();
    STDMETHODIMP    URLChange(LPCWSTR pwszNewURL);

    //  IExtractIconA
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);

    //  IExtractIconT
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCTSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);

private:
    // Functions we provide common implementations for
    HRESULT DoStartDownload();

#ifdef AGENT_AUTODIAL
    HRESULT NotifyAutoDialer();

    HRESULT OnInetOnline();
    HRESULT OnInetOffline();
#endif

protected:
    // Virtual functions for our derived classes to override as necessary
    // We provide implementations which should be called after processing
    virtual HRESULT     AgentPause(DWORD dwFlags);
    virtual HRESULT     AgentResume(DWORD dwFlags);
    virtual HRESULT     AgentAbort(DWORD dwFlags);

    virtual HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);

    virtual HRESULT     StartOperation();       // connects to internet
    virtual HRESULT     StartDownload() = 0;    // we just got connected
    virtual void        CleanUp();
};

#endif // _DELAGENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\dialmon.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//      DIALMON.H - central header file for dial monitor app
//

//      HISTORY:
//      
//      4/18/95         jeremys         Created.
//

#ifndef _DIALMON_H_
#define _DIALMON_H_

#include <regstr.h>

// We need winver 4.00 so ras doesn't puke on our new structure sizes in
// RasEnumConnections.
#undef WINVER
#define WINVER 0x400
#include <ras.h>
#include <raserror.h>

// how to tell dialmon that something is going on
void IndicateDialmonActivity(void);

// give user 30 seconds to respond to dialog 
#define DISCONNECT_DLG_COUNTDOWN        30      

// truncate and add "..." if connectoid name longer than 20 characters
#define MAX_CONNECTOID_DISPLAY_LEN      50      

// private message sent to disconnect dialog to dismiss it
#define WM_QUIT_DISCONNECT_DLG          WM_USER+50

// sizes of various unknown things
#define MAX_RES_LEN                     255
#define DEF_CONN_BUF_SIZE               4096

// class name used for dial monitoring
#define AUTODIAL_MONITOR_CLASS_NAME     "MS_AutodialMonitor"

// max ras connections we care about
#define MAX_CONNECTION                  8

// forward declaration
class BUFFER;

///////////////////////////////////////////////////////////////////////////
//
// CDialMon class definition
//
///////////////////////////////////////////////////////////////////////////

class CDialMon
{
private:
    BOOL        _fInDisconnectFunction; // prevent dialog reentrancy
    DWORD       _dwTimeoutMins;         // timeout value, in minutes
    DWORD       _dwElapsedTicks;        // elapsed ticks with no activity
    BOOL        _fNoTimeout;            // monitor idle or just exit?
    BOOL        _fDisconnectOnExit;
    BOOL        _fConnected;
    TCHAR       _pszConnectoidName[RAS_MaxEntryName+1];   
                                        // name of connectoid of interest
    UINT_PTR    _uIdleTimerID;          // timer id on parent window
    HWND        _hwndDialmon;

public:
    HWND        _hDisconnectDlg;

    CDialMon();
    ~CDialMon();

    void        OnSetConnectoid(BOOL fNoTimeout);
    void        OnActivity(void);
    void        OnTimer(UINT_PTR uTimerID);
    void        OnExplorerExit();

    void        ResetElapsedTicks(){ _dwElapsedTicks = 0; }
    
    // Set DEBUG_KV to 1 here if you need to test hangup logic 
    // without actually having a dailup connection.
    //#define DEBUG_KV 1
 #ifdef DEBUG_KV
    // wrapper over private fn. StartMonitoring when we need to debug without 
    // actually having a dial-up connection.
    void        kvStartMonitoring(){  StartMonitoring(); }
 #endif
                
private:        
    BOOL        StartMonitoring(void);
    void        StopMonitoring(void);
    INT_PTR     StartIdleTimer(void);
    void        StopIdleTimer(void);
    void        CheckForDisconnect(BOOL fTimer);
    BOOL        PromptForDisconnect(BOOL fTimer, BOOL *pfDisconnectDisabled);
    BOOL        RefreshTimeoutSettings(void);
    BOOL        LoadRNADll(void);
    void        UnloadRNADll(void);
};

// structure for passing params to disconnect prompt dialog
typedef struct tagDISCONNECTDLGINFO {
        LPTSTR  pszConnectoidName;   // input: name of connectoid
        DWORD   dwTimeout;           // input: idle timeout in minutes
        BOOL    fTimer;              // input: timer or shutdown?
        DWORD   dwCountdownVal;      // internal: state of countdown in dialog
        BOOL    fDisconnectDisabled; // output: TRUE if disconnect disabled
        CDialMon *pDialMon;          // pointer back to dialmon class
} DISCONNECTDLGINFO;

///////////////////////////////////////////////////////////////////////////
//
// BUFFER class and helpers
//
///////////////////////////////////////////////////////////////////////////

class BUFFER_BASE
{
protected:
        UINT _cch;

        virtual BOOL Alloc( UINT cchBuffer ) = 0;
        virtual BOOL Realloc( UINT cchBuffer ) = 0;

public:
        BUFFER_BASE()  { _cch = 0; }
        ~BUFFER_BASE() { _cch = 0; }
        BOOL Resize( UINT cchNew );
        UINT QuerySize() const { return _cch; };
};

class BUFFER : public BUFFER_BASE
{
protected:
        TCHAR *_lpBuffer;

        virtual BOOL Alloc( UINT cchBuffer );
        virtual BOOL Realloc( UINT cchBuffer );

public:
        BUFFER( UINT cchInitial=0 );
        ~BUFFER();
        BOOL Resize( UINT cchNew );
        TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
        operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? TRUE : NULL!=(_hinst = LoadLibrary(TEXT(#_dll))))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        ASSERT_MSGA(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst!=NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT_MSGA(_pfn##_fn!=NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- PSTOREC.DLL ---------------
HINSTANCE g_hinstPSTOREC = NULL;

DELAY_LOAD_ERR(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore ** ppProvider, PST_PROVIDERID *pProviderID, void *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL);

#if 0
//
// darrenmi 8/18/98
// icmp only needed for dialer.cpp which is no longer built
//

// --------- ICMP.DLL ----------------

HINSTANCE g_hinstICMP = NULL;

DELAY_LOAD(g_hinstICMP, ICMP.DLL, HANDLE, IcmpCreateFile, (void), ());

DELAY_LOAD(g_hinstICMP, ICMP.DLL, BOOL, IcmpCloseHandle, (HANDLE hPing), (hPing));

DELAY_LOAD(g_hinstICMP, ICMP.DLL, DWORD, IcmpSendEcho, 
        (HANDLE     hPing,
         IPAddr     dwAddress,
         void *     pPingData,
         WORD       wPingDataLength,
         PIP_OPTION_INFORMATION
                    pIpInfo,
         void *     pReplyBuffer,
         DWORD      dwReplySize,
         DWORD      dwTimeout),
        (hPing, dwAddress, pPingData, wPingDataLength, pIpInfo, pReplyBuffer, dwReplySize, dwTimeout));

void UnloadICMP(void)
{
    _pfnIcmpCreateFile = NULL;
    _pfnIcmpCloseHandle = NULL;
    _pfnIcmpSendEcho = NULL;

    if(g_hinstICMP) {
        FreeLibrary(g_hinstICMP);
        g_hinstICMP = NULL;
    }
}
#endif

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\dialmon.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//      DIALMON.C - Window proc for dial monitor app
//

//      HISTORY:
//      
//      4/18/95         jeremys         Created.
//

#include "private.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_DIALMON

//
// Registry keys we use to get autodial information
//
                                                                     
// Internet connection goes in remote access key
const TCHAR c_szRASKey[]    = TEXT("RemoteAccess");

// Key name
const TCHAR c_szProfile[]   = TEXT("InternetProfile");
const TCHAR c_szEnable[]    = TEXT("EnableUnattended");

// registry keys of interest
const TCHAR c_szRegPathInternetSettings[] =         REGSTR_PATH_INTERNET_SETTINGS;
static const TCHAR szRegValEnableAutoDisconnect[] = REGSTR_VAL_ENABLEAUTODISCONNECT; 
static const TCHAR szRegValDisconnectIdleTime[] =   REGSTR_VAL_DISCONNECTIDLETIME; 
static const TCHAR szRegValExitDisconnect[] =       REGSTR_VAL_ENABLEEXITDISCONNECT;
static const TCHAR szEllipsis[] =                   TEXT("...");
static const CHAR szDashes[] =                      "----";
static const TCHAR szAutodialMonitorClass[] =       REGSTR_VAL_AUTODIAL_MONITORCLASSNAME;
static const TCHAR c_szDialmonClass[] =             TEXT("MS_WebcheckMonitor");

// Dialmon globals
UINT_PTR    g_uDialmonSecTimerID = 0;  

CDialMon *  g_pDialMon = NULL;

// Function prototypes for dialog handling functions
INT_PTR CALLBACK DisconnectPromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam);
BOOL DisconnectDlgInit(HWND hDlg,DISCONNECTDLGINFO * pDisconnectDlgInfo);
VOID DisconnectDlgCancel(HWND hDlg);
VOID DisconnectDlgTimerProc(HWND hDlg);
VOID DisconnectDlgDisableAutodisconnect(HWND hDlg);
VOID DisconnectDlgShowCountdown(HWND hDlg,DWORD dwSecsRemaining);
VOID EnableDisconnectDlgCtrls(HWND hDlg,BOOL fEnable);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);

////////////////////////////////////////////////////////////////////////
// RAS delay load helpers
//

typedef DWORD (WINAPI* _RASSETAUTODIALPARAM) (
    DWORD, LPVOID, DWORD
);

typedef DWORD (WINAPI* _RASENUMCONNECTIONSA) (
    LPRASCONNA, LPDWORD, LPDWORD
);

typedef DWORD (WINAPI* _RASENUMCONNECTIONSW) (
    LPRASCONNW, LPDWORD, LPDWORD
);

typedef DWORD (WINAPI* _RASHANGUP) (
    HRASCONN
);

typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

static _RASSETAUTODIALPARAM     pfnRasSetAutodialParam = NULL;
static _RASENUMCONNECTIONSA     pfnRasEnumConnectionsA = NULL;
static _RASENUMCONNECTIONSW     pfnRasEnumConnectionsW = NULL;
static _RASHANGUP               pfnRasHangUp = NULL;

static HINSTANCE    g_hRasLib = NULL;
static long         g_lRasRefCnt = 0;

APIMAPENTRY rgRasApiMap[] = {
    { (FARPROC*) &pfnRasSetAutodialParam,       "RasSetAutodialParamA" },
    { (FARPROC*) &pfnRasEnumConnectionsA,       "RasEnumConnectionsA" },
    { (FARPROC*) &pfnRasEnumConnectionsW,       "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasHangUp,                 "RasHangUpA" },
    { NULL, NULL },
};

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumHelp
//
// Abstract grusome details of getting a correct enumeration of connections 
// from RAS.  Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

class RasEnumHelp
{
private:

    //
    // Possible ways we got info from RAS
    //
    typedef enum {
        ENUM_MULTIBYTE,             // Win9x
        ENUM_UNICODE,               // NT
    } ENUM_TYPE;

    //
    // How we got the info
    //
    ENUM_TYPE       _EnumType;     

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASCONNW *      _rcList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    RASCONNW        _rcCurrentEntryW;


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD       GetError();
    DWORD       GetEntryCount();
    LPRASCONNW  GetEntryW(DWORD dwEntry);
};

RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    // figure out which kind of enumeration we're doing - start with multibyte
    _EnumType = ENUM_MULTIBYTE;
    dwStructSize = sizeof(RASCONNA);

    if (g_fIsWinNT)
    {
        _EnumType = ENUM_UNICODE;
        dwStructSize = sizeof(RASCONNW);
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _rcList = (LPRASCONNW)LocalAlloc(LMEM_FIXED, dwBufSize);
    if(_rcList)
    {
        do
        {
            // set up list
            _rcList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                if(pfnRasEnumConnectionsA)
                {
                    _dwLastError = pfnRasEnumConnectionsA(
                                    (LPRASCONNA)_rcList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
            else
            {
                if(pfnRasEnumConnectionsW)
                {
                    _dwLastError = pfnRasEnumConnectionsW(
                                    _rcList,
                                    &dwBufSize,
                                    &_dwEntries
                                    );
                }
            }
       
            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_rcList);
                _rcList = (LPRASCONNW)LocalAlloc(LMEM_FIXED, dwBufSize);
                if(NULL == _rcList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_rcList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_rcList);
        _rcList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_rcList)
    {
        LocalFree(_rcList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPRASCONNW
RasEnumHelp::GetEntryW(DWORD dwEntryNum)
{
    LPRASCONNW  prc = NULL;

    if(dwEntryNum < _dwEntries)
    {
        _rcCurrentEntryW.hrasconn = _rcList[dwEntryNum].hrasconn;

        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            {
                MultiByteToWideChar(CP_ACP, 0,
                                    ((LPRASCONNA)_rcList)[dwEntryNum].szEntryName,
                                    -1, _rcCurrentEntryW.szEntryName,
                                    ARRAYSIZE(_rcCurrentEntryW.szEntryName));
            }
            break;

        case ENUM_UNICODE:
            {
                StrCpyNW(_rcCurrentEntryW.szEntryName,
                         _rcList[dwEntryNum].szEntryName,
                         ARRAYSIZE(_rcCurrentEntryW.szEntryName));
            }   
            break;
        }

        prc = &_rcCurrentEntryW;
    }

    return prc;
}


//
// Functions we can call once ras is loaded
//

DWORD _RasEnumConnections(LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn)
{
    RasEnumHelp     reh;
    DWORD           dwRet = reh.GetError();

    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   cItems = reh.GetEntryCount();
        DWORD   cbNeeded = cItems * sizeof(RASCONNW);

        *lpdwConn = 0;

        if (*lpdwSize >= cbNeeded)
        {

            *lpdwConn = cItems;

            DWORD   dw;

            for (dw = 0; dw < cItems; dw++)
            {
                LPRASCONNW  prc = reh.GetEntryW(dw);

                ASSERT(prc != NULL);

                lpRasConn[dw].hrasconn = prc->hrasconn;
                StrCpyNW(lpRasConn[dw].szEntryName,
                         prc->szEntryName,
                         ARRAYSIZE(lpRasConn[dw].szEntryName));
            }
        }
        else
        {
            dwRet = ERROR_BUFFER_TOO_SMALL;
        }

        *lpdwSize = cbNeeded;
    }

    return dwRet;
}

DWORD _RasHangUp(HRASCONN hRasConn)
{
    if (pfnRasHangUp == NULL)
        return ERROR_UNKNOWN;

    return (*pfnRasHangUp)(hRasConn);
}

BOOL
LoadRasDll(void)
{
    if(NULL == g_hRasLib) {
        g_hRasLib = LoadLibrary(TEXT("RASAPI32.DLL"));

        if(NULL == g_hRasLib)
            return FALSE;

        int nIndex = 0;
        while (rgRasApiMap[nIndex].pszProc != NULL) {
            *rgRasApiMap[nIndex].pfn =
                    GetProcAddress(g_hRasLib, rgRasApiMap[nIndex].pszProc);
            // GetProcAddress will fail on Win95 for a couple of NT only apis.
            // ASSERT(*rgRasApiMap[nIndex].pfn != NULL);

            nIndex++;
        }
    }

    if(g_hRasLib) {
        return TRUE;
    }

    return FALSE;
}

void
UnloadRasDll(void)
{
    if(g_hRasLib) {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
        int nIndex = 0;
        while (rgRasApiMap[nIndex].pszProc != NULL) {
            *rgRasApiMap[nIndex].pfn = NULL;
            nIndex++;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// CDialmonClients
// 
//  Class to maintain a list of application Windows using Dialmon.
//  Used for auto-timeout for all these applications.
//  This class supports 
//      adding hooks to incoming applications, 
//      removing hooks for exiting applications,
//      some aggregate operations on all clients.
// 
//  This is a singleton class, and needs to support only serialized access
//  because all access is thru Dialmon which has a serialized message queue.
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////   

class CDialmonClients
{
private:

    HWND pHwndArray[MAX_DIALMON_HANDLES];
    int cCount;
    static CDialmonClients* pSingleton;

public:

    CDialmonClients();
    
    ~CDialmonClients(){}

    static CDialmonClients* getSingleton()
    {
        if( NULL == pSingleton )
            return ( pSingleton = new CDialmonClients() );
        else
            return pSingleton;
    }

    static void Shutdown()
    {
        if( pSingleton )
            delete pSingleton;
    }
    
    void ClearAll(void);
    BOOL AddHook( HWND hWnd );
    BOOL RemoveHook( HWND hWnd );
    BOOL HasEntries() { return (cCount != 0); };

    friend void BroadcastCanHangup( int iTimeoutMins );
    friend void BroadcastHangingUp( void );
    friend void OnConfirmHangup( HWND hWnd );
    friend void OnDenyHangup( HWND hWnd, CDialMon* pDialMon );
    friend BOOL CanHangup( void ); //doesn't have to be a friend - just bunched it together for now.

    void DebugPrint( void );
};

CDialmonClients* CDialmonClients::pSingleton;

CDialmonClients::CDialmonClients():cCount(0)
{
    for( int i=0; i<MAX_DIALMON_HANDLES; i++ )
        pHwndArray[i] = NULL;
}
void CDialmonClients::ClearAll(void)
{
    for( int i=0; i<MAX_DIALMON_HANDLES; i++ )
        pHwndArray[i] = NULL;
}

// client app. passes a handle to its messaging window when it starts up.
BOOL CDialmonClients::AddHook( HWND hWnd )
{  
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Add Hook\n") );

    if( cCount >= MAX_DIALMON_HANDLES )
        return false; /* BAD! */

    pHwndArray[cCount++] = hWnd;

#ifdef DEBUG
    DebugPrint();
#endif

    return true;
}

// client app. unhooks the handle from the CDialmonClients.

//IMPL: cCount always points to the next empty entry in the array.
// so when we delete a handle, we move all the entries beyond that
// handle up one place and decrement cCount.
BOOL CDialmonClients::RemoveHook( HWND hWnd )
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Remove Hook\n") );

    boolean found = false;
    int i;
    for( i=0; i<cCount; i++ )
    {
        if( hWnd == pHwndArray[i] )
        {
            pHwndArray[i] = NULL;
            --cCount;
            found = true;
            break;
        }
    }
    // move everything beyong cCount up by 1
    // so that cCount represents next free index to 
    // insert into.
    if( found )
    {
        for( ; i<cCount; i++ )
            pHwndArray[i] = pHwndArray[i+1];
        pHwndArray[cCount] = NULL;
    }
    
#ifdef DEBUG    
    DebugPrint();
#endif

    return found;
}

void CDialmonClients::DebugPrint(void)
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: ClientList->\n") );

    for( int i=0; i<cCount; i++ )
    {
        if( pHwndArray[i] )
        {
            DebugMsg( DM_TRACE, TEXT("\t\t%d: %x\n"), i, pHwndArray[i] );
        }
    }
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//             Start up and Shutdown CDialmonClients
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
CDialmonClients* g_pDialmonClients;

static void DialmonClientsInit(void)
{
    g_pDialmonClients = new CDialmonClients();
}

static void DialmonClientsShutdown(void)
{
    delete g_pDialmonClients;
}

//#define USE_CONFIRM_ARRAY 1

// We don't need to use the pConfirmHangupArray.
// The option is to simply wait for some preset time, and if no registered
// client refuses the hangup option, to go ahead and simply hangup.
// This array lets us hangup a little earlier just in case all clients reply
// immdly.
#ifdef USE_CONFIRM_ARRAY
    static BOOL pConfirmHangupArray[MAX_DIALMON_HANDLES];
#endif
static int cOutstandingReplies = 0;

// Broadcast to all registered client a query of can_hang_up?
void BroadcastCanHangup( int iTimeoutMins )
{
    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Broadcasting WM_CANHANGUP?") );
    int i;
    
    cOutstandingReplies=0;
    for( i=0; i<g_pDialmonClients->cCount; i++ )
    {
        if(PostMessage( g_pDialmonClients->pHwndArray[i], WM_CANHANGUP, 
                    0, (LPARAM)iTimeoutMins ))
            ++cOutstandingReplies;
    }

    // if we are using a confirm boolean array, then set ALL
    // entries to false.. this is to take care of any clients that come
    // in AFTER we broadcast can hangup and BEFORE all the existing clients
    // have finished confirming.
#ifdef USE_CONFIRM_ARRAY
    for( i=0; i<MAX_DIALMON_HANDLES; i++ )
    {
        pConfirmHangupArray[i] = false;
    }
#endif
}

// This is a broadcast AFTER hangingup to all registered clients.
void BroadcastHangingUp(void)
{

    DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: Broadcasting WM_HANGING_UP") );
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        PostMessage( g_pDialmonClients->pHwndArray[i], WM_HANGING_UP, 0,0 );
}


// Record that this particular client would like to hangup.
void OnConfirmHangup( HWND hWnd )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( hWnd == g_pDialmonClients->pHwndArray[i] )
        {
            pConfirmHangupArray[i] = true;
            break;
        }
#endif
    --cOutstandingReplies;
}

// Checks if all clients have replied positively.
// Returns false if any client has not yet replied.
BOOL CanHangup( void )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( false == pConfirmHangupArray[i] )
            return false;
    return true;
#else
    return (cOutstandingReplies==0);
#endif 
}

// take action to abort hangup, ( set CDialmon::_dwElapsedTicks to 0 ).
// The effect of this would be that after another timeout period, dialmon
// would again query all the clients.
// However, the client does not have to bring up a dialog again if the user
// indicates that he is not interested in the feature.. the client can
// negate the hangup without interrupting the user.
// ( see the auto-disconnect feature in dialmon ).
void OnDenyHangup( HWND hWnd, CDialMon* pDialMon )
{
#ifdef USE_CONFIRM_ARRAY
    for( int i=0; i<g_pDialmonClients->cCount; i++ )
        if( hWnd == g_pDialmonClients->pHwndArray[i] )
        {
            pConfirmHangupArray[i] = false;
            break;
        }
#endif
    pDialMon->ResetElapsedTicks();
    cOutstandingReplies=0;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Helper to tell dialmon something is going on
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
void IndicateDialmonActivity(void)
{
    static HWND hwndDialmon = NULL;
    HWND hwndMonitor;

    // this one is dynamic - have to find window every time
    hwndMonitor = FindWindow(szAutodialMonitorClass, NULL);
    if(hwndMonitor)
        PostMessage(hwndMonitor, WM_WINSOCK_ACTIVITY, 0, 0);

    // dialmon lives forever - find it once and we're set
    if(NULL == hwndDialmon)
        hwndDialmon = FindWindow(c_szDialmonClass, NULL);
    if(hwndDialmon)
        PostMessage(hwndDialmon, WM_WINSOCK_ACTIVITY, 0, 0);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Dialmon startup and shutdown
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
BOOL DialmonInit(void)
{
    g_pDialMon = new CDialMon;

    DialmonClientsInit();
    if(g_pDialMon)
        return TRUE;

    return FALSE;
}


void DialmonShutdown(void)
{
    DialmonClientsShutdown();
    SAFEDELETE(g_pDialMon);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Dialmon window functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// this cwebcheck instance is in iwebck.cpp
extern CWebCheck *g_pwc;

#ifdef DEBUG_KV
    // DEBUG_KV is set to 1 if you need to test hangup logic 
    // without actually having a dailup connection.
    static bool kvhack = true;
#endif

LRESULT CALLBACK Dialmon_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialMon *pDialMon = (CDialMon*) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
        {
            // snag our class pointer and save in window data
            CREATESTRUCT *pcs;
            pcs = (CREATESTRUCT *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            break;
        }

        // DialMon messages (starting at WM_USER+100)
        case WM_SET_CONNECTOID_NAME:
            if(pDialMon)
                pDialMon->OnSetConnectoid(wParam!=0);
            break;
        case WM_WINSOCK_ACTIVITY:
            if(pDialMon)
                pDialMon->OnActivity();
            break;
        case WM_IEXPLORER_EXITING:
            if(pDialMon)
                pDialMon->OnExplorerExit();
            break;
            
        case WM_DIALMON_HOOK:
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_HOOK recd. from Window 0x%x"), lParam );

            BOOL fRetval;
            fRetval = g_pDialmonClients->AddHook( (HWND)lParam );
            ASSERT( fRetval == TRUE );
            
#ifdef DEBUG_KV
            if( kvhack == true )
            {
                pDialMon->kvStartMonitoring();
                kvhack = false;
            }
#endif
            break;

        case WM_DIALMON_UNHOOK:            
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_UNHOOK recd. from Window 0x%x"), lParam );

            g_pDialmonClients->RemoveHook( (HWND)lParam );
            break;

        case WM_CONFIRM_HANGUP:           
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_CONFIRM_HANGUP recd. from Window 0x%x"), lParam );

            OnConfirmHangup( (HWND)lParam );
            break;

        case WM_DENY_HANGUP:          
            DebugMsg( DM_TRACE, TEXT("\tCDIALMONCLIENTS: WM_DENY_HANGUP recd. from Window 0x%x"), lParam );

            OnDenyHangup( (HWND)lParam, pDialMon );
            break;
            
        case WM_TIMER:
            if(pDialMon)
                pDialMon->OnTimer(wParam);
            break;
        case WM_LOAD_SENSLCE:
            DBG("Dialmon_WndProc - got WM_LOAD_SENSLCE");
            if(g_pwc)
            {
                g_pwc->LoadExternals();
            }
            break;
        case WM_IS_SENSLCE_LOADED:
            if(g_pwc)
            {
                return g_pwc->AreExternalsLoaded();
            }
            else
            {
                return FALSE;
            }
            break;
        case WM_WININICHANGE:
            if (lParam && !StrCmpI((LPCTSTR)lParam, TEXT("policy")))
            {
                ProcessInfodeliveryPolicies();
            }
            // FEATURE: This should be done on Policy and another filter, not for
            // all changes.  (The other filter hasn't been defined yet.)

            //  TODO: handle this in the new architecture!
            //SetNotificationMgrRestrictions(NULL);
            break;

    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                   CDialMon class implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// Constructor / Destructor
//
CDialMon::CDialMon()
{
    WNDCLASS wc;

    // register dialmon window class
    memset(&wc, 0, sizeof(wc));
    wc.lpfnWndProc = Dialmon_WndProc;
    wc.hInstance = g_hInst;
    wc.lpszClassName = c_szDialmonClass;
    RegisterClass(&wc);

    // create dialmon window
    _hwndDialmon = CreateWindow(c_szDialmonClass,
                c_szDialmonClass,
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInst,
                (LPVOID)this);
}

CDialMon::~CDialMon()
{
    if(_hwndDialmon)
        DestroyWindow(_hwndDialmon);

    // unload ras if it's still around
    UnloadRasDll();
}


///////////////////////////////////////////////////////////////////////////
//
// Start/StopMonitoring
//
///////////////////////////////////////////////////////////////////////////

BOOL CDialMon::StartMonitoring(void)
{
    DBG("CDialMon::StartMonitoring");

    // read timeout settings from registry
    RefreshTimeoutSettings();

    // set a one-minute timer
    StopIdleTimer();
    if(!StartIdleTimer())
        return FALSE;

    _dwElapsedTicks = 0;
    
    return TRUE;
}

void CDialMon::StopMonitoring(void)
{
    DBG("CDialMon::StopMonitoring");

    // don't ever hang up now but keep an eye on ras connection
    _dwTimeoutMins = 0;
    _fDisconnectOnExit = FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// Start/StopIdleTimer, OnTimer
//
///////////////////////////////////////////////////////////////////////////

INT_PTR CDialMon::StartIdleTimer(void)
{
    if(0 == _uIdleTimerID)
        _uIdleTimerID = SetTimer(_hwndDialmon, TIMER_ID_DIALMON_IDLE, 30000, NULL);

    ASSERT(_uIdleTimerID);

    return _uIdleTimerID;
}

void CDialMon::StopIdleTimer(void)
{
    if(_uIdleTimerID) {
        KillTimer(_hwndDialmon, _uIdleTimerID);
        _uIdleTimerID = 0;
    }
}

void CDialMon::OnTimer(UINT_PTR uTimerID)
{
    DBG("CDialMon::OnMonitorTimer");

    // if we're on Millennium, just bail out.  The system handles idle disconnect.
    if(g_fIsMillennium)
    {
        return;
    }

    // if it's not our timer, ignore it
    if(uTimerID != _uIdleTimerID)
        return;

    // prevent re-entrancy of timer proc (we can stay in here indefinitely
    // since we may bring up a dialog box)
    if (_fInDisconnectFunction) {
        // disconnect dialog already launched, ignore timer ticks while
        // it's present
        return;
    }

    _fInDisconnectFunction = TRUE;
    CheckForDisconnect(TRUE);
    _fInDisconnectFunction = FALSE;

#ifdef DEBUG_KV
    /* Don't stop idle timer */
#else
    if(FALSE == _fConnected) {
        StopIdleTimer();
    }
#endif
}

///////////////////////////////////////////////////////////////////////////
//
// OnSetConnectoid/OnActivity/OnExplorerExit
//
///////////////////////////////////////////////////////////////////////////

void CDialMon::OnSetConnectoid(BOOL fNoTimeout)
{
    RASCONN RasCon[MAX_CONNECTION];
    DWORD   dwBytes, dwRes, dwConnections;

    // save no timeout setting
    _fNoTimeout = fNoTimeout;

    // Ask ras which connectoid is connected and watch that one
    LoadRasDll();
    RasCon[0].dwSize = sizeof(RasCon[0]);
    dwBytes = MAX_CONNECTION * sizeof(RasCon[0]);
    dwRes = _RasEnumConnections(RasCon, &dwBytes, &dwConnections);
    
    // No connections? bail.
    if(0 == dwConnections) {
        *_pszConnectoidName = TEXT('\0');
        _fConnected = FALSE;
        return;
    }

    // Monitor first connectoid
    StrCpyN(_pszConnectoidName, RasCon[0].szEntryName, ARRAYSIZE(_pszConnectoidName));

    // send ras connect notification if we weren't previously connected
    if(FALSE == _fConnected) {
        _fConnected = TRUE;
    }

    // start watching it
    StartMonitoring();
}

void CDialMon::OnActivity(void)
{
    DBG("CDialMon::OnActivity");

    // reset idle tick count
    _dwElapsedTicks = 0;

    // if the disconnect dialog is present and winsock activity
    // resumes, then dismiss the dialog
    if(_hDisconnectDlg) {
        SendMessage(_hDisconnectDlg, WM_QUIT_DISCONNECT_DLG, 0, 0);
        _hDisconnectDlg = NULL;
    }
}

void CDialMon::OnExplorerExit()
{
    DBG("CDialMon::OnIExplorerExit");

    if(FALSE == _fDisconnectOnExit && FALSE == _fNoTimeout) {
        // no exit disconnection so bail
        DBG("CDialMon::OnIExplorerExit - exit hangup not enabled");
        return;
    }

    // prevent re-entrancy of this function (we can stay in here indefinitely
    // since we may bring up a dialog box)
    if (_fInDisconnectFunction) {
        // some UI already launched
        return;
    }

    _fInDisconnectFunction = TRUE;
    CheckForDisconnect(FALSE);
    _fInDisconnectFunction = FALSE;

    if(FALSE == _fConnected) {
        StopIdleTimer();
    }
}


///////////////////////////////////////////////////////////////////////////
//
// RefreshTimeoutSettings
//
///////////////////////////////////////////////////////////////////////////

BOOL CDialMon::RefreshTimeoutSettings(void)
{
    HKEY    hKey;
    BOOL    fSuccess = FALSE;
    TCHAR   szKey[MAX_PATH];
    DWORD   dwRes, dwData, dwSize, dwDisp;

    // assume disconnect monitoring is off
    _dwTimeoutMins = 0;
    _fDisconnectOnExit = FALSE;

    // figure out appropriate key
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\Profile\\%s"),
            REGSTR_PATH_REMOTEACCESS, _pszConnectoidName);

    // open a regstry key to the internet settings section
    dwRes = RegCreateKeyEx(HKEY_CURRENT_USER, szKey, 0, TEXT(""), 0,
            KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwDisp);
    
    if(ERROR_SUCCESS == dwRes)
    {
        //
        // is autodisconnect enabled?
        //
        dwSize = sizeof(dwData);
        if (RegQueryValueEx(hKey,szRegValEnableAutoDisconnect,NULL,NULL,
                (LPBYTE) &dwData, &dwSize) == ERROR_SUCCESS)
        {
            if(dwData)
            {
                // what's the timeout?
                dwSize = sizeof(dwData);
                if (RegQueryValueEx(hKey,szRegValDisconnectIdleTime,NULL,NULL,
                        (LPBYTE) &dwData, &dwSize) == ERROR_SUCCESS && dwData)
                {
                    _dwTimeoutMins = dwData;
                    fSuccess = TRUE;
                }
            }

            // is disconnect on exit enabled?
            dwSize = sizeof(dwData);
            if (RegQueryValueEx(hKey,szRegValExitDisconnect,NULL,NULL,
                    (LPBYTE) &dwData, &dwSize) == ERROR_SUCCESS && dwData)
            {
                _fDisconnectOnExit = TRUE;
                fSuccess = TRUE;
            }
        }
        else
        {
            //
            // couldn't find enable autodisconnect key.  Set all disconnect
            // settings to their defaults
            //

            // set class members to default values
            _dwTimeoutMins = 20;
            _fDisconnectOnExit = TRUE;
            fSuccess = TRUE;

            // enable idle disconnect and exit disconnect
            dwData = 1;
            RegSetValueEx(hKey, szRegValEnableAutoDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD));
            RegSetValueEx(hKey, szRegValExitDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD));

            // Save idle minutes
            RegSetValueEx(hKey, szRegValDisconnectIdleTime, 0, REG_DWORD,
                    (LPBYTE)&_dwTimeoutMins, sizeof(DWORD));
        }

        RegCloseKey(hKey);
    }

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////
//
// Disconnection handling
//
///////////////////////////////////////////////////////////////////////////

void CDialMon::CheckForDisconnect(BOOL fTimer)
{
    BOOL    fPromptForDisconnect = TRUE;       // assume we should prompt for disconnect
    BOOL    fDisconnectDisabled = FALSE;
    BOOL    fConnectoidAlive = FALSE;
    RASCONN RasCon[MAX_CONNECTION];
    DWORD   dwBytes, dwRes, dwConnections = 0, i;
    HRASCONN hConnection = NULL;

    // variables for auto-hangup for other client apps. (MARS)
    static int dwElapsedTicksSincePoll = 0;
    static BOOL fPolledForHangup = false; 
    BOOL fClientsOkHangup = false;
    #define MAX_MINS_CLIENT_RESPONSE    1
    
#ifdef DEBUG_KV
    // skip all the connection code..
    goto KVHACK;
#endif    

    // Verify we still have a connection
    RasCon[0].dwSize = sizeof(RasCon[0]);
    dwBytes = MAX_CONNECTION * sizeof(RasCon[0]);
    dwRes = _RasEnumConnections(RasCon, &dwBytes, &dwConnections);
    
    // If ras is connected at all, stay alive to monitor it
    if(0 == dwConnections)
        _fConnected = FALSE;

    // Find connectoid we're supposed to watch
    if(TEXT('\0') == *_pszConnectoidName) {
        DBG_WARN("DisconnectHandler: No designated connection to monitor");
        return;
    }
        
    for(i=0; i<dwConnections; i++) {
        if(!StrCmp(RasCon[i].szEntryName, _pszConnectoidName)) {
            fConnectoidAlive = TRUE;
            hConnection = RasCon[i].hrasconn;
        }
    }

    // if we're not connected to out monitor connectoid, ditch our hangup
    // dialog if we have one and bail out
    if(FALSE == fConnectoidAlive) {
        if(_hDisconnectDlg) {
            SendMessage(_hDisconnectDlg, WM_QUIT_DISCONNECT_DLG, 0, 0);
            _hDisconnectDlg = NULL;
        }

        // Also make sure that if we were waiting for client (MARS) reponses for auto-hangup,
        // we also clean up state information..
        if( fPolledForHangup )
        {
            dwElapsedTicksSincePoll = 0;
            fPolledForHangup = false;
        }
        return;
    }

#ifdef DEBUG_KV
    // label to jump to after skipping connection code..
    // also need to set _dwTimeoutMins since without connection
    KVHACK:_dwTimeoutMins = 2;
#endif

    // Check timeout if we got a timer tick
    if(fTimer) {
        // increment tick count
        _dwElapsedTicks ++;

        // Haven't exceeded idle threshold or not watching for idle
        if (0 == _dwTimeoutMins || _dwElapsedTicks < _dwTimeoutMins * 2)
            fPromptForDisconnect = FALSE;
    }

    // THIS is a good place to message out to other clients (ie Mars ) and
    // see if everybody wants to hang up ( this is the point where if
    // fPromptForDisconnect is true, then the earlier behavior would have
    // prompted for disconnect.

    // If this is a disconnect because of IExplorer exiting, we 
    // probably don't want to hangup if there are other clients using dialmon.
    if( !fTimer && g_pDialmonClients->HasEntries() )
        return;
        
    if( g_pDialmonClients->HasEntries() && fPromptForDisconnect )
    {
        if( fPolledForHangup )
        {  
            // WM_CANHANGUP messages have been sent
            // we can hangup if either all clients have replied yes,
            // or if there are no refusals so far, and time has run out.
            if( CanHangup() ||
                ( dwElapsedTicksSincePoll >= 2*MAX_MINS_CLIENT_RESPONSE ) )
            {
                //can hangup!
                dwElapsedTicksSincePoll = 0;
                fPolledForHangup = false;
                fClientsOkHangup = true;
            }
            else
            {
                dwElapsedTicksSincePoll++;
                //ensure that hangup doesn't occur on THIS particular timer message.
                fPromptForDisconnect = false;
            }        
        }
        else
        {
            // WM_CANHANGUP queries may be sent out now..
            BroadcastCanHangup( _dwTimeoutMins );
            dwElapsedTicksSincePoll = 0;
            fPolledForHangup = true;
            //ensure that hangup doesn't occur now
            fPromptForDisconnect = false;
        }
    }
    else if( fPolledForHangup )
    {
        // activity restarted while waiting for client responses.
        // do clean up of state information.
        dwElapsedTicksSincePoll = 0;
        fPolledForHangup = false;
    }
    
    if(FALSE == fPromptForDisconnect) {
        return;
    }

    // prompt user to see if they want to hang up
    if(fClientsOkHangup || PromptForDisconnect(fTimer, &fDisconnectDisabled)) {
        // hang it up
        ASSERT(hConnection);
        if(hConnection)
            _RasHangUp(hConnection);

         // broadcast WM_HANGING_UP to remaining clients - REQUIRED??
         if( g_pDialmonClients->HasEntries() ) 
            BroadcastHangingUp();
         
        _fConnected = FALSE;
    }

    if (fDisconnectDisabled) {
        StopMonitoring();
    }

    _dwElapsedTicks = 0;
}

BOOL CDialMon::PromptForDisconnect(BOOL fTimer, BOOL *pfDisconnectDisabled)
{
    ASSERT(_pszConnectoidName);
    ASSERT(pfDisconnectDisabled);

    // fill out struct to pass to dialog
    DISCONNECTDLGINFO DisconnectDlgInfo;
    memset(&DisconnectDlgInfo,0,sizeof(DisconnectDlgInfo));
    DisconnectDlgInfo.pszConnectoidName = _pszConnectoidName;
    DisconnectDlgInfo.fTimer = fTimer;
    DisconnectDlgInfo.dwTimeout = _dwTimeoutMins;
    DisconnectDlgInfo.pDialMon = this;

    // choose the appropriate dialog depending on if this a "timeout" dialog
    // or "app exiting" dialog
    UINT uDlgTemplateID = fTimer ? IDD_DISCONNECT_PROMPT:IDD_APP_EXIT_PROMPT;

    // run the dialog
    BOOL fRet = (BOOL)DialogBoxParam(MLGetHinst(),MAKEINTRESOURCE(uDlgTemplateID),
            NULL, DisconnectPromptDlgProc,(LPARAM) &DisconnectDlgInfo);

    // dialog box stores its window handle in our class so we can send
    // messages to it, clear the global handle now that it's dismissed
    _hDisconnectDlg = NULL;

    *pfDisconnectDisabled = FALSE;
    if (!fRet && DisconnectDlgInfo.fDisconnectDisabled) {
        *pfDisconnectDisabled=TRUE;

        // turn off reg keys for this connection
        TCHAR   szKey[128];
        DWORD   dwRes, dwValue = 0;
        HKEY    hKey;

        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\Profile\\%s"),
                REGSTR_PATH_REMOTEACCESS, _pszConnectoidName);
        dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_WRITE, &hKey);
        if(ERROR_SUCCESS == dwRes) {

            // Turn off idle disconnect
            RegSetValueEx(hKey, szRegValEnableAutoDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwValue, sizeof(DWORD));

            // Turn off exit disconnect
            RegSetValueEx(hKey, szRegValExitDisconnect, 0, REG_DWORD,
                    (LPBYTE)&dwValue, sizeof(DWORD));

            RegCloseKey(hKey);
        }
    }   

    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                  Disconnect dialog implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DisconnectPromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        // lParam points to data struct, store a pointer to it in window data
        SetWindowLongPtr(hDlg, DWLP_USER,lParam);
        return DisconnectDlgInit(hDlg,(DISCONNECTDLGINFO *) lParam);
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hDlg,TRUE);
            break;
        case IDCANCEL:
            DisconnectDlgCancel(hDlg);
            EndDialog(hDlg,FALSE);
            break;
        case IDC_DISABLE_AUTODISCONNECT:
            DisconnectDlgDisableAutodisconnect(hDlg);
            break;
        }
        break;
    case WM_QUIT_DISCONNECT_DLG:
        // parent window wants to terminate us
        EndDialog(hDlg,FALSE);
        break;
    case WM_TIMER:
        DisconnectDlgTimerProc(hDlg);
        break;
    }

    return FALSE;
}

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessageWrapW(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}

BOOL DisconnectDlgInit(HWND hDlg,DISCONNECTDLGINFO * pDisconnectDlgInfo)
{
    ASSERT(pDisconnectDlgInfo);
    if (!pDisconnectDlgInfo)
        return FALSE;

    // allocate buffers to build text for dialog
    BUFFER BufText(MAX_RES_LEN + MAX_CONNECTOID_DISPLAY_LEN + 1);
    BUFFER BufFmt(MAX_RES_LEN),BufConnectoidName(MAX_CONNECTOID_DISPLAY_LEN+4);
    ASSERT(BufText && BufFmt && BufConnectoidName);
    if (!BufText || !BufFmt || !BufConnectoidName)
        return FALSE;

    UINT uStringID;
    // choose the appropriate text string for dialog
    if (pDisconnectDlgInfo->fTimer) {
        uStringID = IDS_DISCONNECT_DLG_TEXT;
    } else {
        uStringID = IDS_APP_EXIT_TEXT;
    }

    // load the format string from resource
    MLLoadString(uStringID,BufFmt.QueryPtr(),BufFmt.QuerySize());

    // copy the connectoid name into buffer, and truncate it if it's really
    // long
    StrCpyN(BufConnectoidName.QueryPtr(),pDisconnectDlgInfo->pszConnectoidName,
              BufConnectoidName.QuerySize());
    if (lstrlen(pDisconnectDlgInfo->pszConnectoidName) > MAX_CONNECTOID_DISPLAY_LEN) {
        StrCpyN(((TCHAR *) BufConnectoidName.QueryPtr()) + MAX_CONNECTOID_DISPLAY_LEN,
                 szEllipsis, BufConnectoidName.QuerySize());
    }

    if (pDisconnectDlgInfo->fTimer)
    {
        _FormatMessage(BufFmt.QueryPtr(),
                       BufText.QueryPtr(),
                       BufText.QuerySize(),
                       BufConnectoidName.QueryPtr(),
                       pDisconnectDlgInfo->dwTimeout);
    }
    else
    {
        _FormatMessage(BufFmt.QueryPtr(),
                       BufText.QueryPtr(),
                       BufText.QuerySize(),
                       BufConnectoidName.QueryPtr());
    }

    // set text in dialog
    SetDlgItemText(hDlg,IDC_TX1,BufText.QueryPtr());

    // if this timeout dialog (which counts down), initialize countdown timer
    if (pDisconnectDlgInfo->fTimer) {
        pDisconnectDlgInfo->dwCountdownVal = DISCONNECT_DLG_COUNTDOWN;

        DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);

        // set a one-second timer
        g_uDialmonSecTimerID = SetTimer(hDlg,TIMER_ID_DIALMON_SEC,1000,NULL);
        ASSERT(g_uDialmonSecTimerID);
        if (!g_uDialmonSecTimerID) {
            // it's very unlikely that setting the timer will fail... but if it
            // does, then we'll act just like a normal dialog and won't have
            // a countdown.  Hide the countdown-related windows...
            ShowWindow(GetDlgItem(hDlg,IDC_TX2),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_GRP),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_TIME_REMAINING),SW_HIDE);
            ShowWindow(GetDlgItem(hDlg,IDC_TX3),SW_HIDE);
        }

        // beep to alert user
        MessageBeep(MB_ICONEXCLAMATION);
    }

    // center this dialog on the screen
    CenterWindow(hDlg,GetDesktopWindow());

    // default: assume user does not disable auto disconnect, change
    // this later if they do (this field is output to dialog invoker)
    pDisconnectDlgInfo->fDisconnectDisabled = FALSE;

    // Save dialog handle so we can get quit messages
    pDisconnectDlgInfo->pDialMon->_hDisconnectDlg = hDlg;
 
    return TRUE;
}

VOID DisconnectDlgCancel(HWND hDlg)
{
    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo = (DISCONNECTDLGINFO *)
                                             GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);

    // check to see if user checked 'disable autodisconnect' checkbox
    if(IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT))
    {
        // set the output field to indicate that user wanted to disable
        // auto disconnect
        pDisconnectDlgInfo->fDisconnectDisabled = TRUE;
    }       
}

VOID DisconnectDlgTimerProc(HWND hDlg)
{
    // ignore timer ticks (e.g. hold countdown) if "disable autodisconnect"
    // checkbox is checked
    if (IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT))
        return;

    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo =
                (DISCONNECTDLGINFO *) GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);
    if (!pDisconnectDlgInfo)
        return;

    if (pDisconnectDlgInfo->dwCountdownVal) {
        // decrement countdown value
        pDisconnectDlgInfo->dwCountdownVal --;

        // update the dialog with the new value
        if (pDisconnectDlgInfo->dwCountdownVal) {
            DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);
            return;
        }
    }

    // countdown has run out!

    // kill the timer
    KillTimer(hDlg,g_uDialmonSecTimerID);
    g_uDialmonSecTimerID = 0;

    // send a 'OK' message to the dialog to dismiss it
    SendMessage(hDlg,WM_COMMAND,IDOK,0);
}

VOID DisconnectDlgShowCountdown(HWND hDlg,DWORD dwSecsRemaining)
{
    // build a string showing the number of seconds left
    CHAR szSecs[10];
    if (dwSecsRemaining == (DWORD) -1) {
        StrCpyNA(szSecs, szDashes, ARRAYSIZE(szSecs));
    } else {
        wnsprintfA(szSecs, ARRAYSIZE(szSecs), "%lu", dwSecsRemaining);
    }

    // set string in text control
    SetDlgItemTextA(hDlg, IDC_TIME_REMAINING, szSecs);
}

VOID DisconnectDlgDisableAutodisconnect(HWND hDlg)
{
    // get pointer to data struct out of window data
    DISCONNECTDLGINFO * pDisconnectDlgInfo = (DISCONNECTDLGINFO *)
            GetWindowLongPtr(hDlg, DWLP_USER);
    ASSERT(pDisconnectDlgInfo);

    // find out if disable autodisconnect checkbox is checked
    BOOL fDisabled = IsDlgButtonChecked(hDlg,IDC_DISABLE_AUTODISCONNECT);

    // enable or disable controls appropriately
    EnableDisconnectDlgCtrls(hDlg,!fDisabled);

    if (!fDisabled) {
        // reset timer if we're re-enabling autodisconnect
        pDisconnectDlgInfo->dwCountdownVal = DISCONNECT_DLG_COUNTDOWN;
        // show timer value
        DisconnectDlgShowCountdown(hDlg,pDisconnectDlgInfo->dwCountdownVal);
    } else {
        // show "--" in countdown value
        DisconnectDlgShowCountdown(hDlg,(DWORD) -1);
    }
}

VOID EnableDisconnectDlgCtrls(HWND hDlg,BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg,IDC_TX1),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TX2),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TX3),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDC_TIME_REMAINING),fEnable);
    EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
}

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0,
            SWP_NOSIZE | SWP_NOZORDER);
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      BUFFER class implementation
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL BUFFER::Alloc( UINT cchBuffer )
{
    _lpBuffer = (LPTSTR)::MemAlloc(LPTR,cchBuffer*sizeof(TCHAR));
    if (_lpBuffer != NULL) {
        _cch = cchBuffer;
        return TRUE;
    }
    return FALSE;
}

BOOL BUFFER::Realloc( UINT cchNew )
{
    LPVOID lpNew = ::MemReAlloc((HLOCAL)_lpBuffer, cchNew*sizeof(TCHAR),
            LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (lpNew == NULL)
        return FALSE;

    _lpBuffer = (LPTSTR)lpNew;
    _cch = cchNew;
    return TRUE;
}

BUFFER::BUFFER( UINT cchInitial /* =0 */ )
  : BUFFER_BASE(),
        _lpBuffer( NULL )
{
    if (cchInitial)
        Alloc( cchInitial );
}

BUFFER::~BUFFER()
{
    if (_lpBuffer != NULL) {
        MemFree((HLOCAL) _lpBuffer);
        _lpBuffer = NULL;
    }
}

BOOL BUFFER::Resize( UINT cchNew )
{
    BOOL fSuccess;

    if (QuerySize() == 0)
        fSuccess = Alloc( cchNew*sizeof(TCHAR) );
    else {
        fSuccess = Realloc( cchNew*sizeof(TCHAR) );
    }
    if (fSuccess)
        _cch = cchNew;
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\downld.h ===
#ifndef __DOWNLD_H
#define __DOWNLD_H

#include <mshtmdid.h>

#define URLDL_WNDCLASS  TEXT("WCUrlDlClass")

class CUrlDownload_BSC;

#define ACCEPT_LANG_MAX     256

// Options for BeginDownloadURL2
typedef enum {
    BDU2_BROWSER,    // always download into the browser
    BDU2_URLMON,     // always download with urlmon only
    BDU2_SMART,      // browser if HTML; aggressive guessing
    BDU2_SNIFF,      // browser if HTML; no guessing (urlmon then browser)
    BDU2_HEADONLY,   // get HEAD info only (including Last-Modified time)
} BDUMethod;

typedef DWORD BDUOptions;

// BDUOptions
#define BDU2_NONE                       0
#define BDU2_NEEDSTREAM                 1   // keep an istream around from bdu2_urlmon download
#define BDU2_DOWNLOADNOTIFY_REQUIRED    2   // require IDownloadNotify callbacks for MSHTML
#define BDU2_FAIL_IF_NOT_HTML           4   // only download if url is html (can't use w/BDU2_BROWSER)

// OnDownloadComplete error codes
#define BDU2_ERROR_NONE         0
#define BDU2_ERROR_GENERAL      1
#define BDU2_ERROR_ABORT        2
#define BDU2_ERROR_MAXSIZE      3
#define BDU2_ERROR_TIMEOUT      4
#define BDU2_ERROR_NOT_HTML     5


// CUrlDowload hosts one browser and can handle one download at a time.
//
// CUrlDownloadSink is defined in private.h
//
// Use of class CUrlDownload:
//
// 1) Create and AddRef it
// 1.5) call put_Flags() to set the bind status callback IBrowseControl::Flags
// 2) Call BeginDownloadURL2 to start a download
// 3) Retrieve notifications through CUrlDownloadSink
// 4) Call BeginDownloadURL2 to start another download, reusing browser
// 5) Call DoneDownloading() when finished
// 6) Release()

// DoneDownloading() MUST be called before Release() or the CUrlDownload instance may
//  continue to receive notifications from the browser and attempt to pass them to
//  the parent. It unhooks itself as soon as OnProgress(-1) is received. But be safe.

// AbortDownload() may cause DownloadComplete(TRUE) notification
//   to be sent to the CUrlDownloadSink

// See webcrawl.h and webcrawl.cpp for example
class CUrlDownload :  public IOleClientSite         // e_notimpl
                    , public IPropertyNotifySink    // for readystate change notifications
                    , public IOleCommandTarget      // for client pull callbacks
                    , public IDispatch              // for ambient properties
                    , public IServiceProvider       // for IAuthenticate and IHlinkFrame
                    , public IAuthenticate          // for Basic and NTLM authentication
                    , public IHlinkFrame            // for catching the post of a form
                    , public IInternetSecurityManager // for allowing the post of a form
                    , public IHttpSecurity          // for OnSecurityProblem
{
    friend CUrlDownload_BSC;
    
private:
    ~CUrlDownload();

public:
    CUrlDownload(CUrlDownloadSink *pParent, UINT iID=0);

    void LeaveMeAlone() { m_pParent=NULL; }

    void SetFormSubmitted(BOOL fFormSubmitted) { m_fFormSubmitted = fFormSubmitted; StartTimer(); }
    BOOL GetFormSubmitted(void) { return m_fFormSubmitted; }

    // An E_ return code from this function may be ignored if desired. The
    //  client's OnDownloadComplete will be called with fAborted==TRUE after this
    //  function returns with an error value.
    HRESULT BeginDownloadURL2(LPCWSTR, BDUMethod, BDUOptions, LPTSTR, DWORD);

    HRESULT SetDLCTL(long lFlags);  // DLCTL flags used for browser control

    HRESULT AbortDownload(int iErrorCode=-1);   // S_OK, S_FALSE, E_FAIL

    HRESULT GetRealURL(LPWSTR *ppwszURL);   // Gets URL accounting for any and all redirections (MemFree)

    HRESULT GetScript(IHTMLWindow2 **pWin);    // Will cache an *additional* reference internally
    void    ReleaseScript() { SAFERELEASE(m_pScript); } // Releases internal reference

    HRESULT GetDocument(IHTMLDocument2 **ppDoc);

    HRESULT GetStream(IStream **ppStm); // Only if BDU2_NEEDSTREAM was specified
    void    ReleaseStream() { SAFERELEASE(m_pStm); } // Release our internal reference

    HRESULT GetLastModified(SYSTEMTIME *pstLastModified);   // Only if BDU2_HEADONLY was used
    HRESULT GetResponseCode(DWORD *pdwResponseCode);

    void    DoneDownloading();  // Call before releasing. Will destroy browser and windows.
    void    DestroyBrowser();   // Destroy hosted browser, leave all else alone

    LPCWSTR GetUserAgent();     // Get our webcrawler user-agent string

    // URL manipulation functions
static HRESULT StripAnchor(LPWSTR lpURL);
static BOOL IsHtmlUrl(LPCWSTR lpURL); // TRUE (yes) or FALSE (don't know)
static BOOL IsNonHtmlUrl(LPCWSTR lpURL); // TRUE (yes) or FALSE (don't know)
static BOOL IsValidURL(LPCWSTR lpURL);  // TRUE (get it) or FALSE (skip it)

    // Should only be called from CUrlDownloadMsgProc
    BOOL HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //      IDispatch (ambient properties)
    STDMETHODIMP         GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP         GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP         GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgdispid);
    STDMETHODIMP         Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IOleClientSite
    STDMETHODIMP        SaveObject(void);
    STDMETHODIMP        GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHODIMP        GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP        ShowObject(void);
    STDMETHODIMP        OnShowWindow(BOOL fShow);
    STDMETHODIMP        RequestNewObjectLayout(void);

    // IPropertyNotifySink
    STDMETHODIMP        OnChanged(DISPID dispID);
    STDMETHODIMP        OnRequestEdit(DISPID dispID);

    // IOleCommandTarget
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // IServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    // IAuthenticate
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    
    // IHlinkFrame
    STDMETHODIMP        SetBrowseContext(IHlinkBrowseContext *pihlbc);
    STDMETHODIMP        GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    STDMETHODIMP        Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    STDMETHODIMP        OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    STDMETHODIMP        UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IInternetSecurityManager
    STDMETHODIMP        SetSecuritySite(IInternetSecurityMgrSite *pSite);
    STDMETHODIMP        GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    STDMETHODIMP        MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    STDMETHODIMP        GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    STDMETHODIMP        ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP        QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    STDMETHODIMP        SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    STDMETHODIMP        GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

    // IHttpSecurity
    STDMETHODIMP        GetWindow(REFGUID rguidReason, HWND *phwnd);
    STDMETHODIMP        OnSecurityProblem(DWORD dwProblem);


protected:
    // main object stuff
    ULONG               m_cRef;
    UINT                m_iID;          // our ID for callbacks
    CUrlDownloadSink    *m_pParent;     // to pass on WebBrowserEvents
    HWND                m_hwndMe;
    UINT                m_nTimeout;     // Max timeout between notifications (seconds)

    // GetBrowser/CleanUpBrowser (browser download data)
    IPersistMoniker     *m_pPersistMk;
    IHTMLDocument2      *m_pDocument;
    IOleCommandTarget   *m_pOleCmdTarget;
    BOOL                m_fWaitingForReadyState;
    BOOL                m_fFormSubmitted;
    IConnectionPoint    *m_pCP;         // connection point for DIID_DWebBrowserEvents
    BOOL                m_fAdviseOn;    // our sink is hooked up? (ConnectionCookie valid)
    DWORD               m_dwConnectionCookie;
    BOOL                m_fBrowserValid;    // Browser pointing to 'current' URL?

    // UrlMon download data
    CUrlDownload_BSC    *m_pCbsc;
    BOOL                m_fbscValid;    // pCbsc alive for 'current' URL?
    IStream             *m_pStm;
    SYSTEMTIME          *m_pstLastModified;     // Last Modified time
    DWORD               m_dwResponseCode;
    WCHAR               m_achLang[ACCEPT_LANG_MAX];
    UINT                m_iLangStatus;  // 0=uninit, 1=init, 2=failed
    HRESULT             m_hrStatus;

    // General download data
    BDUMethod           m_iMethod;
    BDUOptions          m_iOptions;
    UINT_PTR            m_iTimerID;
    LPWSTR              m_pwszURL;      // gives us the current url after redirections
    BOOL                m_fSetResync;   // need RESYNCHRONIZE?
    DWORD               m_dwMaxSize;    // in bytes
    LPWSTR              m_pwszUserAgent;

    // IBrowseControl
    long                m_lBindFlags;

    // allow caching GetScript calls
    IHTMLWindow2        *m_pScript;

    // Client pull
    LPWSTR              m_pwszClientPullURL;
    int                 m_iNumClientPull;

    // methods that our bindstatuscallback calls back
    void        BSC_OnStopBinding(HRESULT hrStatus, IStream *pStm);
    void        BSC_OnStartBinding();
    void        BSC_OnProgress(ULONG ulProgress, ULONG ulProgressMax);
    void        BSC_FoundLastModified(SYSTEMTIME *pstLastModified);
    void        BSC_FoundMimeType(CLIPFORMAT cf);

    // other internal stuff
    HRESULT     CreateMyWindow();
    HRESULT     GetBrowser();   // Get browser and set us on connection point
    void        UnAdviseMe();   // Unhook our advise sink

    void        CleanUpBrowser();
    void        CleanUp();      // Clean up, including releasing browser

    void        StartTimer();    // for 60 second timeout
    void        StopTimer();

    LPCWSTR     GetAcceptLanguages();   // NULL if failed

    HRESULT     BeginDownloadWithUrlMon(LPCWSTR, LPTSTR, IEnumFORMATETC *);
    HRESULT     BeginDownloadWithBrowser(LPCWSTR);

    HRESULT     HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone);

    HRESULT     OnDownloadComplete(int iError);     // cancel timeout, send OnDownloadComplete

    HRESULT     ProgressBytes(DWORD dwBytes);       // Will abort if too many
};

class CUrlDownload_BSC :    public IBindStatusCallback,
                            public IHttpNegotiate,        // To set User-Agent
                            public IAuthenticate          // for Basic and NTLM authentication
{
public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IHttpNegotiate methods
    STDMETHODIMP    BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                        DWORD dwReserved, LPWSTR *pszAdditionalHeaders);
    
    STDMETHODIMP    OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders);
        
    // IAuthenticate methods
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    


    // constructors/destructors
    CUrlDownload_BSC(BDUMethod, BDUOptions, LPTSTR);
    ~CUrlDownload_BSC();

    // other methods
    HRESULT         Abort();
    void            SetParent(CUrlDownload *pUrlDownload);

    // data members
protected:
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    IStream*        m_pstm;
    LPTSTR          m_pszLocalFileDest;
    LPWSTR          m_pwszLocalFileSrc;
    BDUMethod       m_iMethod;
    BDUOptions      m_iOptions;
    BOOL            m_fSentMimeType;
    CUrlDownload    *m_pParent;
    BOOL            m_fTriedAuthenticate;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\downld.cpp ===
#include "private.h"
#include <exdisp.h>
#include <exdispid.h>
#include <htiface.h>
#include <mshtmdid.h>
#include <mshtmcid.h>
#include <mshtmhst.h>
#include <optary.h>                 // needed for IHtmlLoadOptions

#include "downld.h"

#define TF_THISMODULE   TF_DOWNLD

// CUrlDownload is a single threaded object. We can assume we are always on a single thread.

long g_lRegisteredWnd = 0;
LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

CLIPFORMAT g_cfHTML=CF_NULL;

// User-Agent strings
const WCHAR c_wszUserAgentAppend[] = L"; MSIECrawler)";

// Refresh header for http-equiv (client-pull)
const WCHAR c_wszRefresh[] = L"Refresh";

const int  MAX_CLIENT_PULL_NUM = 4;     // max # redirections
const int  MAX_CLIENT_PULL_TIMEOUT = 6; // max timeout we'll follow

// Function also present in shdocvw\basesb.cpp and in mshtml
BOOL ParseRefreshContent(LPWSTR pwzContent, UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf);

const WCHAR c_wszHeadVerb[] = L"HEAD";

const WCHAR c_szUserAgentPrefix[] = L"User-Agent: ";
const WCHAR c_szAcceptLanguagePrefix[] = L"Accept-Language: ";

#define WM_URLDL_CLEAN      (WM_USER + 0x1010)
#define WM_URLDL_ONDLCOMPLETE (WM_USER + 0x1012)
#define WM_URLDL_CLIENTPULL (WM_USER+0x1013)

#define SAFE_RELEASE_BSC() \
if (m_pCbsc) { \
m_pCbsc->SetParent(NULL); \
m_pCbsc->Release(); \
m_pCbsc = NULL; \
} else

//---------------------------------------------------------------
// CUrlDownload class
CUrlDownload::CUrlDownload(CUrlDownloadSink *pParent, UINT iID /* =0 */)
{
    DWORD cbData;

    // Maintain global count of objects
    DllAddRef();

    m_iID = iID;
    m_pParent = pParent;

    m_cRef = 1;
    
    ASSERT(m_pDocument==NULL && m_dwConnectionCookie==0 && m_pwszURL == NULL);

    // Get the timeout value (stored in seconds)
    cbData = sizeof(m_nTimeout);
    if (NO_ERROR != SHGetValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("Timeout"), NULL, &m_nTimeout, &cbData))
    {
        // Default to 120 seconds
        m_nTimeout = 120;
    }

    // find the HTML clipboard format
    if (!g_cfHTML)
    {
        g_cfHTML = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_MIME_HTML);
        TraceMsg(TF_THISMODULE, "ClipFormat for HTML = %d", (int)g_cfHTML);
    }

    // find out if we need to set the "RESYNCHRONIZE" flag
    INTERNET_CACHE_CONFIG_INFOA CacheConfigInfo;
    DWORD dwBufSize = sizeof(CacheConfigInfo);
    CacheConfigInfo.dwStructSize = sizeof(CacheConfigInfo);

    if (GetUrlCacheConfigInfoA(&CacheConfigInfo, &dwBufSize, CACHE_CONFIG_SYNC_MODE_FC))
    {
        if ((WININET_SYNC_MODE_ONCE_PER_SESSION == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_ALWAYS == CacheConfigInfo.dwSyncMode) ||
             (WININET_SYNC_MODE_AUTOMATIC == CacheConfigInfo.dwSyncMode))
        {
            m_fSetResync = FALSE;
        }
        else
        {
            m_fSetResync = TRUE;
            DBG("Browser session update='never', setting RESYNCHRONIZE");
        }
    }
    else
        DBG_WARN("GetUrlCacheConfigInfo failed! Not setting Resync.");

    m_lBindFlags = DLCTL_SILENT | DLCTL_NO_SCRIPTS | DLCTL_NO_BEHAVIORS |
        DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    // register our window class if necessary
    if (!g_lRegisteredWnd)
    {
        g_lRegisteredWnd++;

        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = UrlDownloadWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = URLDL_WNDCLASS;

        RegisterClass(&wc);
    }
}

CUrlDownload::~CUrlDownload()
{
    // Maintain global count of objects
    DllRelease();

    CleanUp();
    DBG("Destroyed CUrlDownload object");
}

void CUrlDownload::CleanUpBrowser()
{
    SAFERELEASE(m_pScript);

    if (m_fAdviseOn)
    {
        UnAdviseMe();
    }
    SAFERELEASE(m_pCP);
    SAFERELEASE(m_pDocument);
    SAFERELEASE(m_pPersistMk);
    SAFERELEASE(m_pOleCmdTarget);
    SAFELOCALFREE(m_pwszClientPullURL);
}

void CUrlDownload::CleanUp()
{
    CleanUpBrowser();
    SAFE_RELEASE_BSC();
    SAFELOCALFREE(m_pwszURL);
    SAFELOCALFREE(m_pstLastModified);
    SAFERELEASE(m_pStm);
    SAFELOCALFREE(m_pwszUserAgent);

    if (m_hwndMe)
    {
        SetWindowLongPtr(m_hwndMe, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndMe);
        m_hwndMe = NULL;
    }
}

LRESULT UrlDownloadWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CUrlDownload *pThis = (CUrlDownload*) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis && IsBadWritePtr(pThis, sizeof(*pThis)))
    {
        TraceMsg(TF_THISMODULE,
            "Invalid 'this' in UrlDownloadWndProc (0x%08x) - already destroyed?", pThis);
    }
#endif

    switch (Msg)
    {
    case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                DBG_WARN("Invalid param UrlDownloadWndProc Create");
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_URLDL_CLIENTPULL :
    case WM_URLDL_ONDLCOMPLETE :
    case WM_TIMER :
        if (pThis)
            pThis->HandleMessage(hWnd, Msg, wParam, lParam);
        break;

    default:
        return DefWindowProc(hWnd, Msg, wParam, lParam);
    }
    return 0;
}

HRESULT CUrlDownload::CreateMyWindow()
{
    // Create our callback window
    if (NULL == m_hwndMe)
    {
//      TraceMsg(TF_THISMODULE, "Creating MeWnd, this=0x%08x", (DWORD)this);
        m_hwndMe = CreateWindow(URLDL_WNDCLASS, TEXT("YO"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

        if (NULL == m_hwndMe)
        {
            DBG_WARN("CUrlDownload CreateWindow(UrlDl WndClass) failed");
            return E_FAIL;
        }
    }
    return S_OK;
}

HRESULT CUrlDownload::BeginDownloadURL2(
    LPCWSTR     pwszURL,        // URL
    BDUMethod   iMethod,        // download method
    BDUOptions  iOptions,       // download options
    LPTSTR      pszLocalFile,   // Local file to download to instead of cache
    DWORD       dwMaxSize       // Max size in bytes; will abort if exceeded
)
{
    HRESULT hr = S_OK;

    // Param validation
    ASSERT(pwszURL);
    ASSERT(!(iOptions & BDU2_NEEDSTREAM) || (iMethod == BDU2_URLMON));
    ASSERT(!pszLocalFile || (iMethod == BDU2_URLMON));

    if (pszLocalFile && iMethod != BDU2_URLMON)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CreateMyWindow();

        // Clean up some old stuff
        if (m_pCbsc)
        {
            if (m_fbscValid)
                m_pCbsc->Abort();
            SAFE_RELEASE_BSC();
        }
        SAFERELEASE(m_pScript);
        SAFERELEASE(m_pStm);

        m_fbscValid = m_fBrowserValid = FALSE;

        m_iMethod = iMethod;
        m_iOptions = iOptions;

        m_dwMaxSize = dwMaxSize;

        SAFELOCALFREE(m_pwszClientPullURL);
        m_iNumClientPull = 0;

        // Save URL
        SAFELOCALFREE(m_pwszURL);
        m_pwszURL = StrDupW(pwszURL);

        SAFELOCALFREE(m_pstLastModified);
        m_dwResponseCode = 0;

        if ((iOptions & BDU2_FAIL_IF_NOT_HTML) && IsNonHtmlUrl(pwszURL))
        {
            // Hey, this isn't an HTML url! Don't even try to download it.
            OnDownloadComplete(BDU2_ERROR_NOT_HTML);
        }
        else
        {
            // Determine how to download this URL
            if ((iMethod == BDU2_BROWSER) ||
                ((iMethod == BDU2_SMART) && IsHtmlUrl(pwszURL)))
            {
                hr = BeginDownloadWithBrowser(pwszURL);
            }
            else
            {
                hr = BeginDownloadWithUrlMon(pwszURL, pszLocalFile, NULL);
            }
        }
    }

    if (FAILED(hr))
    {
        DBG("BeginDownloadURL2 : error HRESULT - calling OnDownloadComplete w/Error");
        OnDownloadComplete(BDU2_ERROR_GENERAL);
    }

    return hr;
}

//
// Looks up the Url in the url history object and if its not CP_ACP
// inserts an IHTMLLoadOptions object that contains the codepage
// into the bind context
//
HRESULT InsertHistoricalCodepageIntoBindCtx(LPCWSTR pwszURL, IBindCtx * pbc)
{
    HRESULT hr = S_OK;

    if (pwszURL == NULL || pbc == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Get the codepage from the intsite database. This is the codepage
        // the user set when last visiting this url.
        //
        PROPVARIANT propCodepage = {0};
        propCodepage.vt = VT_UI4;

        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        MyOleStrToStrN(szURL, INTERNET_MAX_URL_LENGTH, pwszURL);
        hr = IntSiteHelper(szURL, &c_rgPropRead[PROP_CODEPAGE], 
            &propCodepage, 1, FALSE);

        if (SUCCEEDED(hr) && propCodepage.lVal != CP_ACP)
        {
            //
            // We got a codepage that wasn't the ansi one create an
            // HTMLLoadOptions object and set the code page in it.
            //
            IHtmlLoadOptions *phlo = NULL;
            hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, 
                CLSCTX_INPROC_SERVER, IID_IHtmlLoadOptions, (void**)&phlo);

            if (SUCCEEDED(hr) && phlo)
            {
                hr = phlo->SetOption(HTMLLOADOPTION_CODEPAGE, &propCodepage.lVal,
                    sizeof(propCodepage.lVal));

                if (SUCCEEDED(hr))
                {
                    //
                    // Insert the option into the bindctx
                    //
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                    TraceMsg(TF_THISMODULE,
                        "InsertHistoricalCodepageIntoBindCtx codepage=%d",
                        propCodepage.lVal);
                }
                phlo->Release();
            }
        }
    }
    return hr;
}

LPCWSTR CUrlDownload::GetUserAgent()
{
    if (m_pwszUserAgent)
    {
        return m_pwszUserAgent;
    }

    // Get default User-Agent string from urlmon
    CHAR chUA[1024];
    DWORD dwBufLen;

    // Assume that UrlMkGetSessionOption always succeeds (82160).
    chUA[0] = 0;
    UrlMkGetSessionOption(URLMON_OPTION_USERAGENT, chUA, sizeof(chUA), &dwBufLen, 0);
    
    // Append "MSIECrawler"
    int iLenUA, iLenNew;

    iLenUA = lstrlenA(chUA);
    iLenNew = iLenUA + ARRAYSIZE(c_wszUserAgentAppend);

    ASSERT(iLenUA == (int)(dwBufLen-1));

    if (iLenUA > 0)
    {
        m_pwszUserAgent = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*iLenNew);

        if (m_pwszUserAgent)
        {
            LPWSTR pwszAppend = m_pwszUserAgent+iLenUA-1;
            m_pwszUserAgent[0] = L'\0';
            SHAnsiToUnicode(chUA, m_pwszUserAgent, iLenNew);
            // find the closing parenthesis and append string there
            if (*pwszAppend != L')')
            {
                DBG("GetUserAgent: Last Char in UA isn't closing paren");
                pwszAppend = StrRChrW(m_pwszUserAgent, m_pwszUserAgent+iLenUA, L')');
            }
            if (pwszAppend)
            {
                StrCpyNW(pwszAppend, c_wszUserAgentAppend, iLenNew - (int)(pwszAppend - m_pwszUserAgent));
            }
            else
            {
                LocalFree(m_pwszUserAgent);
                m_pwszUserAgent = NULL;
            }
        }
    }

    return m_pwszUserAgent;
}
    
HRESULT CUrlDownload::BeginDownloadWithBrowser(LPCWSTR pwszURL)
{
    HRESULT hr;

    // Get browser and hook up sink
    // (no-op if we're already set up)
    hr = GetBrowser();

    if (SUCCEEDED(hr))
    {
        // browse to the required URL
        LPMONIKER           pURLMoniker = NULL;
        IBindCtx           *pbc = NULL;

        // create a URL moniker from the canonicalized path
        hr=CreateURLMoniker(NULL, pwszURL, &pURLMoniker);
        if (FAILED(hr)) DBG_WARN("CreateURLMoniker failed");

        // create an empty bind context so that Urlmon will call Trident's
        //  QueryService on the proper thread so that Trident can delegate
        //  it to use properly.
        hr=CreateBindCtx(0, &pbc);
        if (FAILED(hr)) DBG_WARN("CreateBindCtx failed");

        if (SUCCEEDED(hr))
        {
            //
            // Looks up the Url in the url history object and if its not CP_ACP
            // inserts an IHTMLLoadOptions object that contains the codepage
            // into the bind context. This is done so that TRIDENT is seeded
            // with the correct codepage.
            //
            InsertHistoricalCodepageIntoBindCtx(pwszURL, pbc);

            hr = m_pPersistMk->Load(FALSE, pURLMoniker, pbc, 0);
            if (SUCCEEDED(hr)) m_fWaitingForReadyState = TRUE;
            if (FAILED(hr)) DBG_WARN("PersistMoniker::Load failed");
        }

        // clean up junk
        if (pURLMoniker)
            pURLMoniker->Release();

        if (pbc)
            pbc->Release();

        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            StartTimer();       // Start our timeout
        }
        else
        {
            DBG("Error binding with Browser's IPersistMoniker");
            CleanUpBrowser();
        }
    }

    TraceMsg(TF_THISMODULE,
        "CUrlDownload::BeginDownloadWithBrowser (hr=0x%08x)", (long)hr);

    return hr;
}

HRESULT CUrlDownload::OnDownloadComplete(int iError)
{
    PostMessage(m_hwndMe, WM_URLDL_ONDLCOMPLETE, (WPARAM)iError, 0);
    StopTimer();
    return S_OK;
}

BOOL CUrlDownload::HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_URLDL_CLIENTPULL :
        {
            HRESULT hr = E_FAIL;

            // Ask our parent if we should do this
            if (m_pwszClientPullURL)
            {
                if (m_pParent && (m_iNumClientPull < MAX_CLIENT_PULL_NUM))
                    hr = m_pParent->OnClientPull(m_iID, m_pwszURL, m_pwszClientPullURL);

                TraceMsgA(TF_THISMODULE, "CUrlDownload %s executing client pull to %ws",
                    SUCCEEDED(hr) ? "is" : "**not**", m_pwszClientPullURL);
            }

            if (SUCCEEDED(hr))
            {
                // Download this new url. Don't give "downloadcomplete" for first one
                // Save member vars since they get reset in BDU2
                int iNumClientPull = m_iNumClientPull;
                LPWSTR pszNewURL = m_pwszClientPullURL;

                m_pwszClientPullURL = NULL;
                hr = BeginDownloadURL2(pszNewURL, m_iMethod, m_iOptions, NULL, m_dwMaxSize);
                MemFree(pszNewURL);
                if (SUCCEEDED(hr))
                {
                    m_iNumClientPull = iNumClientPull + 1;
                }
            }
        }
        break;

    case WM_URLDL_ONDLCOMPLETE :
        if (m_pParent)
            m_pParent->OnDownloadComplete(m_iID, (int)wParam);
        return TRUE;

    case WM_TIMER :
#ifdef DEBUG
        DBG_WARN("CUrlDownload ERROR - TIMING OUT");

        if ( m_fBrowserValid )
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Browser Timeout." );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Non-Browser Timeout." );
        }

        if ( m_fbscValid )
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - UrlMon Timeout." );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "CUrlDownload::HandleMessage() - Non-UrlMon Timeout." );
        }
#endif
        StopTimer();
        AbortDownload(BDU2_ERROR_TIMEOUT);
        return TRUE;
    }
    return TRUE;
}

HRESULT CUrlDownload::AbortDownload(int iErrorCode /* =-1 */)
{
    HRESULT hr=S_FALSE;
    BOOL    fAborted=FALSE;

    if (m_fBrowserValid)
    {
        ASSERT(m_pOleCmdTarget);
        if (m_pOleCmdTarget)
        {
            m_pOleCmdTarget->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
        }

        SAFELOCALFREE(m_pwszClientPullURL);

        fAborted=TRUE;
        m_fBrowserValid = FALSE;
    }

    if (m_fbscValid)
    {
        ASSERT(m_pCbsc);
        if (m_pCbsc)
        {
            hr = m_pCbsc->Abort();
            fAborted=TRUE;
            SAFE_RELEASE_BSC();
        }
        m_fbscValid=FALSE;
    }

    if (fAborted && m_pParent)
    {
        OnDownloadComplete((iErrorCode==-1) ? BDU2_ERROR_ABORT : iErrorCode);
    }

    return hr;
}

// Loads browser, creates sink and hooks it up to sinks
HRESULT CUrlDownload::GetBrowser()
{
    HRESULT hr = S_OK;

    if (m_fAdviseOn)
        return hr;

    if (NULL == m_pDocument)
    {
        ASSERT(!m_pPersistMk);
        ASSERT(!m_pCP);

        hr = CoCreateInstance(CLSID_HTMLDocument, NULL,
                    CLSCTX_INPROC, IID_IHTMLDocument2, (void **)&m_pDocument);

        DBG("Created new CLSID_HTMLDocument");

        if (SUCCEEDED(hr))
        {
            IOleObject *pOleObj;

            hr = m_pDocument->QueryInterface(IID_IOleObject, (void **)&pOleObj);
            if (SUCCEEDED(hr))
            {
                pOleObj->SetClientSite((IOleClientSite *)this);
                pOleObj->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IPersistMoniker, (void**)&m_pPersistMk);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pDocument->QueryInterface(IID_IOleCommandTarget, (void**)&m_pOleCmdTarget);
        }
    }

    // At this point we have m_pDocument and m_pPersistMk

    // Get DownloadNotify sink hooked up
    IDownloadNotify *pNotify=NULL;
    BOOL            fNotifySet=FALSE;

    if (SUCCEEDED(hr) && SUCCEEDED(m_pParent->GetDownloadNotify(&pNotify)) && pNotify)
    {
        IOleCommandTarget *pTarget=NULL;

        if (SUCCEEDED(m_pDocument->QueryInterface(IID_IOleCommandTarget, (void **)&pTarget)) && pTarget)
        {
            VARIANTARG varIn;

            varIn.vt = VT_UNKNOWN;
            varIn.punkVal = (IUnknown *)pNotify;
            if (SUCCEEDED(pTarget->Exec(&CGID_DownloadHost, DWNHCMDID_SETDOWNLOADNOTIFY, 0,
                                        &varIn, NULL)))
            {
                fNotifySet=TRUE;
            }

            pTarget->Release();
        }

        if (!fNotifySet)
        {
            DBG_WARN("IDownloadNotify provided, but couldn't set callback!");
        }

        pNotify->Release();
    }

    if (!fNotifySet && (m_iOptions & BDU2_DOWNLOADNOTIFY_REQUIRED))
    {
        DBG_WARN("Couldn't set notify, parent requires it. CUrlDownload failing MSHTML download.");
        hr = E_FAIL;
    }

    // Get PropertyNotifySink hooked up
    // Find our connection point if necessary
    if (NULL == m_pCP && SUCCEEDED(hr))
    {
        IConnectionPointContainer *pCPCont=NULL;
        hr = m_pDocument->QueryInterface(IID_IConnectionPointContainer,
                (void **)&pCPCont);

        if (SUCCEEDED(hr))
        {
            hr = pCPCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP);
            pCPCont->Release();
            pCPCont = NULL;
        }
    }

    // And hook it up to us
    if (SUCCEEDED(hr))
    {
        // create sink
        IPropertyNotifySink *pSink = (IPropertyNotifySink *)this;

        hr = m_pCP->Advise(pSink, &m_dwConnectionCookie);
        if (SUCCEEDED(hr))
        {
            m_fAdviseOn = TRUE;
        }

    }

    if (FAILED(hr)) DBG_WARN("CUrlDownload::GetBrowser returning failure");
    return hr;
}

void CUrlDownload::UnAdviseMe()
{
    if (m_fAdviseOn)
    {
        m_pCP->Unadvise(m_dwConnectionCookie);
        m_fAdviseOn = FALSE;
    }
}

void CUrlDownload::DestroyBrowser()
{
    CleanUpBrowser();
}

void CUrlDownload::DoneDownloading()
{
    // Don't send any more messages to the parent
    LeaveMeAlone();

    AbortDownload();

    CleanUp();
}

HRESULT CUrlDownload::GetScript(IHTMLWindow2 **ppWin)
{
    HRESULT hr = E_FAIL;
    IDispatch *pDisp=NULL;

    ASSERT(ppWin);
    *ppWin=NULL;

    if (!m_fBrowserValid)
    {
        DBG("m_fBrowserValid FALSE, GetScript returning failure");
        return E_FAIL;
    }

    *ppWin = NULL;

    if (m_pScript)
    {
        m_pScript->AddRef();
        *ppWin = m_pScript;
        return S_OK;
    }

    if (m_pDocument)
    {
        hr = m_pDocument->get_Script(&pDisp);
        if (!pDisp) hr=E_NOINTERFACE;
#ifdef DEBUG
        if (FAILED(hr)) DBG_WARN("CUrlDownload::GetScript:  get_Script failed");
#endif
    }

    if (SUCCEEDED(hr))
    {
        hr = pDisp->QueryInterface(IID_IHTMLWindow2, (void **)ppWin);
        if (*ppWin == NULL) hr = E_NOINTERFACE;
        pDisp->Release();
#ifdef DEBUG
        if (FAILED(hr)) DBG_WARN("CUrlDownload::GetScript:  QI IOmWindow2 failed");
#endif
    }

    // Save this so future GetScript() calls much faster
    ASSERT(!m_pScript);
    if (SUCCEEDED(hr))
    {
        m_pScript = *ppWin;
        m_pScript->AddRef();
    }

    return hr;
}

// static member function
// Strips off anchor from URL (# not after ?)
// S_FALSE : Unchanged
// S_OK    : Removed anchor
HRESULT CUrlDownload::StripAnchor(LPWSTR lpURL)
{
    if (!lpURL) return E_POINTER;

    while (*lpURL)
    {
        if (*lpURL == L'?')
            return S_FALSE;
        if (*lpURL == L'#')
        {
            *lpURL = L'\0';
            return S_OK;
        }
        lpURL ++;
    }
    return S_FALSE;
}

// Returns pointer to '.' or pointer to null-terminator or query '?'
LPWSTR                  // ptr to period or to null-term or '?'
URLFindExtensionW(
    LPCWSTR pszURL,
    int *piLen)         // length including period
{
    LPCWSTR pszDot;

    for (pszDot = NULL; *pszURL && *pszURL!='?'; pszURL++)
    {
        switch (*pszURL) {
        case TEXT('.'):
            pszDot = pszURL;         // remember the last dot
            break;
        case TEXT('/'):
            pszDot = NULL;       // forget last dot, it was in a directory
            break;
        }
    }

    if (piLen)
    {
        if (pszDot)
            *piLen = (int) (pszURL-pszDot);
        else
            *piLen = 0;
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPWSTR)pszDot : (LPWSTR)pszURL;
}

// Returns TRUE if this appears to be an HTML URL
BOOL CUrlDownload::IsHtmlUrl(LPCWSTR lpURL)
{
    LPWSTR pwch;
    int iLen;

    pwch = URLFindExtensionW(lpURL, &iLen);

    if (*pwch && iLen)
    {
        pwch ++; iLen --;

        // We found an extension. Check it out.
        if ((iLen == 4 &&
                (!MyAsciiCmpNIW(pwch, L"html", 4))) ||
            (iLen == 3 &&
                (!MyAsciiCmpNIW(pwch, L"htm", 3) ||
                 !MyAsciiCmpNIW(pwch, L"htt", 3) ||
                 !MyAsciiCmpNIW(pwch, L"asp", 3) ||
                 !MyAsciiCmpNIW(pwch, L"htx", 3)
                                            )))
        {
            // known HTML extension
            return TRUE;
        }
    }

    return FALSE;
}

// Returns TRUE if this appears NOT to be an HTML URL
BOOL CUrlDownload::IsNonHtmlUrl(LPCWSTR lpURL)
{
    LPWSTR pwch;
    int iLen;

    pwch = URLFindExtensionW(lpURL, &iLen);

    if (*pwch && iLen)
    {
        pwch ++; iLen --;

        // We found an extension. Check it out.
        if ((iLen==3) &&
                (!MyAsciiCmpNIW(pwch, L"bmp", 3) ||
                 !MyAsciiCmpNIW(pwch, L"cab", 3) ||
                 !MyAsciiCmpNIW(pwch, L"cdf", 3) ||
                 !MyAsciiCmpNIW(pwch, L"jpg", 3) ||
                 !MyAsciiCmpNIW(pwch, L"exe", 3) ||
                 !MyAsciiCmpNIW(pwch, L"zip", 3) ||
                 !MyAsciiCmpNIW(pwch, L"doc", 3) ||
                 !MyAsciiCmpNIW(pwch, L"gif", 3)
                                            ))
        {
            // known non-HTML extension
            return TRUE;
        }
    }

    return FALSE;
}

// Returns TRUE if this is a URL we should try to download (http:)
BOOL CUrlDownload::IsValidURL(LPCWSTR lpURL)
{
    // See if this protocol will give us something for the cache
    BOOL fUsesCache=FALSE;
    DWORD dwBufSize=0;
    CoInternetQueryInfo(lpURL, QUERY_USES_CACHE, 0,
        &fUsesCache, sizeof(fUsesCache), &dwBufSize, 0);

    if (!fUsesCache || (S_FALSE == ::IsValidURL(NULL, lpURL, 0)))
        return FALSE;

    return TRUE;
}

HRESULT CUrlDownload::GetRealURL(LPWSTR *ppwszURL)
{
    *ppwszURL = NULL;

    if (!m_fBrowserValid)
    {
        if (m_pwszURL)
            *ppwszURL = StrDupW(m_pwszURL);
    }
    else
    {
        // Get the real URL from the browser in case we were redirected
        // We could optimize to do this only once
        ITargetContainer *pTarget=NULL;
        LPWSTR pwszThisUrl=NULL;

        if (m_pDocument)
        {
            m_pDocument->QueryInterface(IID_ITargetContainer, (void **)&pTarget);

            if (pTarget)
            {
                pTarget->GetFrameUrl(&pwszThisUrl);
                pTarget->Release();
            }
        }

        if (pwszThisUrl)
        {
            if (m_pwszURL) MemFree(m_pwszURL);
            m_pwszURL = StrDupW(pwszThisUrl);
            *ppwszURL = StrDupW(pwszThisUrl);
            CoTaskMemFree(pwszThisUrl);
        }
        else if (m_pwszURL)
        {
            *ppwszURL = StrDupW(m_pwszURL);
        }
    }

    return (*ppwszURL) ? S_OK : E_OUTOFMEMORY;
}


HRESULT CUrlDownload::GetDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr;

    if (!m_fBrowserValid)
    {
        DBG("GetDocument failing, m_fBrowserValid FALSE");
        *ppDoc = NULL;
        return E_FAIL;
    }

    *ppDoc = m_pDocument;
    if (m_pDocument)
    {
        m_pDocument->AddRef();
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

HRESULT CUrlDownload::GetStream(IStream **ppStm)
{
    if (!m_pStm)
    {
        DBG("Stream not available, CUrlDownload::GetStream failing");
        *ppStm = NULL;
        return E_FAIL;
    }

    *ppStm = m_pStm;
    (*ppStm)->AddRef();

    return S_OK;
}

HRESULT CUrlDownload::GetLastModified(SYSTEMTIME *pstLastModified)
{
    if (NULL == pstLastModified)
        return E_INVALIDARG;

    if (NULL == m_pstLastModified)
        return E_FAIL;

    CopyMemory(pstLastModified, m_pstLastModified, sizeof(SYSTEMTIME));

    return S_OK;
}

HRESULT CUrlDownload::GetResponseCode(DWORD *pdwResponseCode)
{
    if (m_dwResponseCode == 0)
        return E_FAIL;

    *pdwResponseCode = m_dwResponseCode;

    return S_OK;
}
    
// Start or extend timer
void CUrlDownload::StartTimer()
{
    if (m_hwndMe)
    {
        if (!m_iTimerID)
        {
            m_iTimerID = 1;
            DBG("CUrlDownload Creating new timeout timer");
        }

        m_iTimerID = SetTimer(m_hwndMe, 1, 1000 * m_nTimeout, NULL);
    }
}

void CUrlDownload::StopTimer()
{
    if (m_hwndMe && m_iTimerID)
    {
        DBG("CUrlDownload destroying timeout timer");
        KillTimer(m_hwndMe, m_iTimerID);
        m_iTimerID = 0;
    }
}

//
// IUnknown of CUrlDownload
//
STDMETHODIMP CUrlDownload::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if (IID_IOleClientSite == riid)
        *ppv=(IOleClientSite *)this;
    else if (IID_IPropertyNotifySink == riid)
        *ppv=(IPropertyNotifySink *)this;
    else if (IID_IOleCommandTarget == riid)
        *ppv=(IOleCommandTarget *)this;
    else if (IID_IDispatch == riid)
        *ppv=(IDispatch *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_IAuthenticate == riid)
        *ppv = (IAuthenticate *)this;
    else if (IID_IInternetSecurityManager == riid)
        *ppv = (IInternetSecurityManager *)this;
    else if (IID_IHttpSecurity == riid)
        *ppv = (IHttpSecurity *)this;
    else if ((IID_IUnknown == riid) ||
             (IID_IHlinkFrame == riid))
        *ppv = (IHlinkFrame *)this;
    else
    {
        // DBGIID("CUrlDownload::QueryInterface() failing", riid);
    }

    // Addref through the interface
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CUrlDownload::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUrlDownload::Release(void)
{
    if (0L != --m_cRef)
        return 1L;

    delete this;
    return 0L;
}

STDMETHODIMP CUrlDownload::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS *pdispparams, VARIANT *pvarResult,
            EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(pvarResult->vt == VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        HRESULT hr = DISP_E_MEMBERNOTFOUND;
        
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            TraceMsg(TF_THISMODULE, "Returning DLCONTROL ambient property 0x%08x", m_lBindFlags);
            pvarResult->vt = VT_I4;
            pvarResult->lVal = m_lBindFlags;
            hr = S_OK;
            break;
        case DISPID_AMBIENT_USERAGENT:
            DBG("Returning User Agent ambient property");
            pvarResult->bstrVal = SysAllocString(GetUserAgent());
            if (pvarResult->bstrVal != NULL)
            {
                pvarResult->vt = VT_BSTR;
                hr = S_OK;
            }
            break;
        }
        return hr;
    }

    return DISP_E_MEMBERNOTFOUND;
}

// IPropertyNotifySink

STDMETHODIMP CUrlDownload::OnChanged(DISPID dispID)
{
    // We've received a notification, extend our timer if it's currently running
    if (m_iTimerID)
        StartTimer();

    if ((DISPID_READYSTATE == dispID) ||
        (DISPID_UNKNOWN == dispID))
    {
        // Find out if we're done
        if (m_fWaitingForReadyState)
        {
            VARIANT     varState;
            DISPPARAMS  dp;

            VariantInit(&varState);

            if (SUCCEEDED(m_pDocument->Invoke(DISPID_READYSTATE, 
                                              IID_NULL, 
                                              GetUserDefaultLCID(), 
                                              DISPATCH_PROPERTYGET, 
                                              &dp, 
                                              &varState, NULL, NULL)) &&
                V_VT(&varState)==VT_I4 && 
                V_I4(&varState)== READYSTATE_COMPLETE)
            {
                m_fWaitingForReadyState = FALSE;
                // Successful download. See if a client-pull is waiting.
                if (m_pwszClientPullURL)
                    PostMessage(m_hwndMe, WM_URLDL_CLIENTPULL, 0, 0);
                else
                    OnDownloadComplete(BDU2_ERROR_NONE);
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

// IOleCommandTarget
STDMETHODIMP CUrlDownload::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CUrlDownload::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup == NULL) 
    {
        switch(nCmdID) 
        {
        case OLECMDID_SETPROGRESSPOS:
        {
            hres = S_OK;
            VARIANT     varBytes;
            
            if (m_pOleCmdTarget)
            {
                varBytes.vt=VT_EMPTY;
                m_pOleCmdTarget->Exec(&CGID_MSHTML, IDM_GETBYTESDOWNLOADED, 0, NULL, &varBytes);

                if (varBytes.vt == VT_I4)
                {
                    DWORD dwBytes = (DWORD) varBytes.lVal;

                    TraceMsg(TF_THISMODULE, "%d bytes on page so far (mshtml)", dwBytes);

                    ProgressBytes(dwBytes);
                }
            }

            // 14032: If dialmon is around, tell it that something is going on
            IndicateDialmonActivity();

        }
            break;
        //
        // The containee has found an http-equiv meta tag; handle it
        // appropriately (client pull)
        //
        case OLECMDID_HTTPEQUIV_DONE:
            hres = S_OK;
            break;

        case OLECMDID_HTTPEQUIV:
            {
                LPWSTR  pwszEquivString = pvarargIn? pvarargIn->bstrVal : NULL;
                BOOL    fHasHeader = (pwszEquivString!=NULL);

                if (pvarargIn && pvarargIn->vt != VT_BSTR)
                    return OLECMDERR_E_NOTSUPPORTED;

                if (!fHasHeader || StrCmpNIW(c_wszRefresh, pwszEquivString, lstrlenW(c_wszRefresh)) == 0)
                {
                    // Hit.  Now do the right thing for this header
                    // We pass both the header and a pointer to the first char after
                    // ':', which is usually the delimiter handlers will look for.

                    LPWSTR pwszColon = fHasHeader ? StrChrW(pwszEquivString, ':') : NULL;
      
                    // Enforce the : at the end of the header
                    if (fHasHeader && !pwszColon)
                    {
                        return OLECMDERR_E_NOTSUPPORTED;
                    }
             
                    hres = HandleRefresh(pwszEquivString, pwszColon ? pwszColon+1:NULL,
                                         (nCmdID == OLECMDID_HTTPEQUIV_DONE));
                }
            }

            // if we return OLECMDERR_E_NOTSUPPORTED, we don't handle
            // client pull
            break;
        }
    }

    if ((hres == OLECMDERR_E_NOTSUPPORTED) && m_pParent)
    {
        hres = m_pParent->OnOleCommandTargetExec(pguidCmdGroup, nCmdID, nCmdexecopt,
                                                    pvarargIn, pvarargOut);
    }

    return hres;
}

// The basic operation was lifted from shdocvw\basesb.cpp
HRESULT CUrlDownload::HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone)
{
    unsigned int uiTimeout = 0;
    WCHAR        awch[INTERNET_MAX_URL_LENGTH];

    if (fDone)
    {
        return S_OK;    // fDone means we don't process this
    }

    // NSCompat: we only honor the first successfully parsed Refresh
    if (m_pwszClientPullURL)
        return S_OK;

    if (!pwszContent ||
        !ParseRefreshContent(pwszContent, &uiTimeout, awch, INTERNET_MAX_URL_LENGTH))
    {
        return OLECMDERR_E_NOTSUPPORTED;   // cannot handle refresh w/o timeout
    }
    
    if (!awch[0])
    {
        DBG("CUrlDownload ignoring client-pull directive with no url");
        return S_OK;
    }

    if (m_iNumClientPull >= MAX_CLIENT_PULL_NUM)
    {
        DBG("Max # client pulls exceeded; ignoring client pull directive");
        return S_OK;
    }

    TraceMsg(TF_THISMODULE, "CUrlDownload client pull (refresh=%d) url=%ws", uiTimeout, awch);
    if (uiTimeout > MAX_CLIENT_PULL_TIMEOUT)
    {
        DBG("Ignoring client-pull directive with large timeout");
        return S_OK;
    }

    m_pwszClientPullURL = StrDupW(awch);

    // If we can't copy the URL, don't set the timer or else we'll
    // keep reloading the same page.

    if (m_pwszClientPullURL == NULL)
        return OLECMDERR_E_NOTSUPPORTED;

    return S_OK;
}

HRESULT CUrlDownload::SetDLCTL(long lFlags)
{
//  TraceMsg(TF_THISMODULE, "CUrlDownload: SetDLCTL %04x", lFlags);
    m_lBindFlags = lFlags | DLCTL_SILENT;
    if (m_fSetResync)
        m_lBindFlags |= DLCTL_RESYNCHRONIZE;

    return S_OK;
}

#define INET_E_AGENT_BIND_IN_PROGRESS 0x800C0FFF

//==============================================================================
//  UrlMon download code
//==============================================================================
HRESULT CUrlDownload::BeginDownloadWithUrlMon(
    LPCWSTR     pwszURL,
    LPTSTR      pszLocalFile,
    IEnumFORMATETC *pEFE)
{
    IStream*    pstm = NULL;
    IMoniker*   pmk = NULL;
    IBindCtx*   pbc = NULL;
    HRESULT hr;

    hr = CreateURLMoniker(NULL, pwszURL, &pmk);
    if (FAILED(hr))
    {
        DBG_WARN("CreateURLMoniker failed");
        goto LErrExit;
    }

    SAFE_RELEASE_BSC();

    m_pCbsc = new CUrlDownload_BSC(m_iMethod, m_iOptions, pszLocalFile);
    if (m_pCbsc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
    }

    hr = CreateBindCtx(0, &pbc);
    if (FAILED(hr))
        goto LErrExit;

    if (pEFE)
    {
        hr = RegisterFormatEnumerator(pbc, pEFE, 0);
        if (FAILED(hr))
            DBG_WARN("RegisterFormatEnumerator failed (continuing download)");
    }

    hr = RegisterBindStatusCallback(pbc,
            (IBindStatusCallback *)m_pCbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    m_pCbsc->SetParent(this);
    m_fbscValid = TRUE;
    m_hrStatus = INET_E_AGENT_BIND_IN_PROGRESS;
    StartTimer();       // Start our timeout
    hr = pmk->BindToStorage(pbc, 0, IID_IStream, (void**)&pstm);

    if (m_hrStatus != INET_E_AGENT_BIND_IN_PROGRESS)
    {
        // Synchronous success or failure. Call OnDownloadComplete.
        // We can't do it in OnStopBinding because Urlmon returns hrStatus=S_OK...
        //   even if it fails.
        if (FAILED(hr) || FAILED(m_hrStatus))
            OnDownloadComplete(BDU2_ERROR_GENERAL);
        else
            OnDownloadComplete(BDU2_ERROR_NONE);

        DBG("Synchronous bind; OnDownloadComplete called");
    }

    m_hrStatus = S_OK;      // need this so we get OnDownloadComplete (asynch OnStopBinding)
    hr = S_OK;              // need this so we don't get extra OnDownloadComplete (BDU2)

    // Bind has started (and maybe completed), release stuff we don't need
    pmk->Release();
    pbc->Release();

    if (pstm)
        pstm->Release();

    return hr;

LErrExit:
    DBG_WARN("Error in CUrlDownload::BeginDownloadWithUrlMon");
    if (pbc) pbc->Release();
    if (pmk) pmk->Release();
    if (pstm) pstm->Release();
    SAFERELEASE(m_pCbsc);

    return hr;
} // CUrlDownload::BeginDownloadWithUrlMon

void CUrlDownload::BSC_OnStartBinding()
{
    DBG("BSC_OnStartBinding");
}

// We only get this call if we're not downloading with the browser.
void CUrlDownload::BSC_OnStopBinding(HRESULT hrStatus, IStream *pStm)
{
    TraceMsg(TF_THISMODULE, "BSC_OnStopBinding (hrStatus=0x%08x)", (long)hrStatus);
    ASSERT(m_pCbsc);

// It is ok to not have stream when we requested it (robots.txt)
//  ASSERT(( pStm &&  (m_iOptions & BDU2_NEEDSTREAM)) ||
//         (!pStm && !(m_iOptions & BDU2_NEEDSTREAM)));
    ASSERT(!pStm || (m_iOptions & BDU2_NEEDSTREAM));
    ASSERT(!m_pStm);

    // Save stream for caller if they requested it
    // We keep it until the release it (ReleaseStream) or nav to another url
    if (pStm && (m_iOptions & BDU2_NEEDSTREAM))
    {
        if (m_pStm) m_pStm->Release();
        m_pStm = pStm;
        m_pStm->AddRef();
    }

    // Send OnDownloadComplete, stop the timer
    if (m_iMethod == BDU2_HEADONLY && m_pstLastModified)
        hrStatus = S_OK;        // We got what we came for (hrStatus will be E_ABORT)

    if (m_hrStatus != INET_E_AGENT_BIND_IN_PROGRESS)
        OnDownloadComplete(SUCCEEDED(hrStatus) ? BDU2_ERROR_NONE : BDU2_ERROR_GENERAL);
    else
    {
        DBG("Not calling OnDownloadComplete; synchronous bind");
        m_hrStatus = hrStatus;
    }

    m_fbscValid = FALSE;
    SAFE_RELEASE_BSC();
}

void CUrlDownload::BSC_OnProgress(ULONG ulProgress, ULONG ulProgressMax)
{
    // extend our timer
    if (m_iTimerID)
        StartTimer();
}

void CUrlDownload::BSC_FoundLastModified(SYSTEMTIME *pstLastModified)
{
    DBG("Received last modified time");

    SAFELOCALFREE(m_pstLastModified);

    m_pstLastModified = (SYSTEMTIME *)MemAlloc(LMEM_FIXED, sizeof(SYSTEMTIME));

    if (m_pstLastModified)
    {
        CopyMemory(m_pstLastModified, pstLastModified, sizeof(SYSTEMTIME));
    }
}

void CUrlDownload::BSC_FoundMimeType(CLIPFORMAT cf)
{
    TraceMsg(TF_THISMODULE, "FoundMimeType %d", (int)cf);

    BOOL fAbort = FALSE, fBrowser=FALSE;
    HRESULT hr=S_OK;

    // Abort if not html if necessary.
    if ((m_iOptions & BDU2_FAIL_IF_NOT_HTML) && (cf != g_cfHTML))
    {
        DBG("Aborting non-HTML download");
        fAbort = TRUE;
        OnDownloadComplete(BDU2_ERROR_NOT_HTML);
    }

    // Abort the UrlMon download if necessary. Fire off
    //  a browser download if necessary.
    if (((m_iMethod == BDU2_SMART) || (m_iMethod == BDU2_SNIFF)) && (cf == g_cfHTML))
    {
        // Switch into the browser.
        ASSERT(m_pwszURL);
        if (m_pwszURL &&
            (m_dwResponseCode != 401))      // Don't bother if it's auth failure
        {
            DBG("Switching UrlMon download into browser");
            hr = BeginDownloadWithBrowser(m_pwszURL);
            if (SUCCEEDED(hr))
                fBrowser = TRUE;
        }
    }

    if (fAbort || fBrowser)
    {
        // Disconnect the BSC so that we don't get any more notifications.
        // If we're switching into the browser, don't abort the UrlMon
        //  download to help avoid getting multiple GET requests. We do
        //  disconnect the BSC but still maintain a ref to it so we abort
        //  it if necessary.
        ASSERT(m_pCbsc);
        if (m_pCbsc)
        {
            m_pCbsc->SetParent(NULL);  // We don't want OnStopBinding

            if (fAbort)
            {
                m_pCbsc->Abort();
                m_pCbsc->Release();
                m_pCbsc=NULL;
                m_fbscValid = FALSE;
            }
        }
    }
}

// Returns content for Accept-Language header
LPCWSTR CUrlDownload::GetAcceptLanguages()
{
    if (0 == m_iLangStatus)
    {
        DWORD cchLang = ARRAYSIZE(m_achLang);

        if (SUCCEEDED(::GetAcceptLanguagesW(m_achLang, &cchLang)))
        {
            m_iLangStatus = 1;
        }
        else
        {
            m_iLangStatus = 2;
        }
    }

    if (1 == m_iLangStatus)
    {
        return m_achLang;
    }
    
    return NULL;
}

HRESULT CUrlDownload::ProgressBytes(DWORD dwBytes)
{
    if (m_dwMaxSize > 0 && dwBytes > m_dwMaxSize)
    {
        TraceMsg(TF_THISMODULE, "CUrlDownload MaxSize exceeded aborting. %d of %d bytes", dwBytes, m_dwMaxSize);

        AbortDownload(BDU2_ERROR_MAXSIZE);
        return E_ABORT;
    }

    return S_OK;
}

//---------------------------------------------------------------
// IServiceProvider
STDMETHODIMP CUrlDownload::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if ((SID_SHlinkFrame == guidService && IID_IHlinkFrame == riid) ||
        (IID_IAuthenticate == guidService && IID_IAuthenticate == riid) ||
        (SID_SInternetSecurityManager == guidService && IID_IInternetSecurityManager == riid) ||
        (IID_IHttpSecurity == guidService && IID_IHttpSecurity == riid))
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}

//---------------------------------------------------------------
//IHttpSecurity
STDMETHODIMP CUrlDownload::OnSecurityProblem(DWORD dwProblem)
{
     
    return S_FALSE;
}

STDMETHODIMP CUrlDownload::GetWindow( REFGUID rguidReason, HWND *phwnd ) {
    
    if(phwnd && m_hwndMe) {
        *phwnd = m_hwndMe;
    } else
        return E_FAIL;

    return S_OK;

}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    if (m_pParent)
        hr = m_pParent->OnAuthenticate(phwnd, ppszUsername, ppszPassword);
    else
        hr = E_NOTIMPL;

    TraceMsg(TF_THISMODULE, "CUrlDownload::Authenticate returning hr=%08x", hr);

    return hr;
}

//---------------------------------------------------------------
// IHlinkFrame
STDMETHODIMP CUrlDownload::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    DBG_WARN("CUrlDownload::SetBrowseContext() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    DBG_WARN("CUrlDownload::GetBrowseContext() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    // We should only get a call through IHlinkFrame->Navigate()
    // when the webcrawler has submitted a form for authentication.
    // Bail out if that's not the case.
    if (!m_fFormSubmitted)
    {
        DBG_WARN("CUrlDownload::Navigate() without a form submission!!!");
        return E_NOTIMPL;
    }

    // Our timer has already been started. If this fails, OnDownloadComplete will get
    //  called when we time out.

    // We don't support a wide variety of parameters.
    ASSERT(grfHLNF == 0);
    ASSERT(pbc);
    ASSERT(pibsc);
    ASSERT(pihlNavigate);

    // Get the moniker from IHlink
    HRESULT hr;
    IMoniker *pmk = NULL;
    hr = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmk, NULL);
    if (SUCCEEDED(hr))
    {
        // Load the URL with the post data.
        // WARNING: What if we get redirected to something other than HTML? (beta 2)
        hr = m_pPersistMk->Load(FALSE, pmk, pbc, 0);
        SAFERELEASE(pmk);
        if (SUCCEEDED(hr))
        {
            m_fBrowserValid = TRUE;
            StartTimer();       // Start our timeout
            // Need to wait again.
            m_fWaitingForReadyState = TRUE;
            DBG("CUrlDownload::Navigate (IHLinkFrame) succeeded");
        }
    }
    return hr;
}
STDMETHODIMP CUrlDownload::OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    DBG_WARN("CUrlDownload::OnNavigate() not implemented");
    return E_NOTIMPL;
}
STDMETHODIMP CUrlDownload::UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    DBG_WARN("CUrlDownload::UpdateHlink() not implemented");
    return E_NOTIMPL;
}

//---------------------------------------------------------------------
// IInternetSecurityManager interface
// Used to override security to allow form submits, for form auth sites
HRESULT CUrlDownload::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CUrlDownload::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    if ((dwAction == URLACTION_HTML_SUBMIT_FORMS_TO) ||
        (dwAction == URLACTION_HTML_SUBMIT_FORMS_FROM))
    {
        return S_OK;
    }
    
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CUrlDownload::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}


//---------------------------------------------------------------
// CUrlDownload_BSC class
//---------------------------------------------------------------

CUrlDownload_BSC::CUrlDownload_BSC(
    BDUMethod   iMethod,
    BDUOptions  iOptions,
    LPTSTR      pszLocalFile)
{
    // Maintain global count of objects
    DllAddRef();

    m_cRef = 1;

    m_iMethod = iMethod;
    m_iOptions = iOptions;

    if (NULL != pszLocalFile)
    {
        m_pszLocalFileDest = StrDup(pszLocalFile);
        if (m_iMethod != BDU2_URLMON)
        {
            DBG_WARN("CUrlDownload_BSC changing method to URLMON (local file specified)");
            m_iMethod = BDU2_URLMON;
        }
    }
}

CUrlDownload_BSC::~CUrlDownload_BSC()
{
    // Maintain global count of objects
    DllRelease();

    ASSERT(!m_pBinding);
    SAFERELEASE(m_pstm);
    SAFELOCALFREE(m_pszLocalFileDest);
    SAFELOCALFREE(m_pwszLocalFileSrc);
}

void CUrlDownload_BSC::SetParent(CUrlDownload *pUrlDownload)
{
    m_pParent = pUrlDownload;
}

HRESULT CUrlDownload_BSC::Abort()
{
    if (m_pBinding)
    {
        return m_pBinding->Abort();
    }
    return S_FALSE;
}

STDMETHODIMP CUrlDownload_BSC::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
        AddRef();
        return S_OK;
    }
    if (riid==IID_IHttpNegotiate)
    {
        *ppv = (IHttpNegotiate *)this;
        AddRef();
        return S_OK;
    }
    if (riid==IID_IAuthenticate)
    {
        *ppv = (IAuthenticate *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

//---------------------------------------------------------------
// IAuthenticate
STDMETHODIMP CUrlDownload_BSC::Authenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{   //copied from CUrlDownload::Authenticate (to whom we pass off anyway)
    HRESULT hr;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    
    *phwnd = (HWND)-1;
    *ppszUsername = NULL;
    *ppszPassword = NULL;

    // Only try this once. If Urlmon asks again, fail it and flag an error.
    if (m_fTriedAuthenticate)
    {
        if (m_pParent)
        {
            m_pParent->m_dwResponseCode = 401;
            DBG("CUrlDownload_BSC::Authenticate called twice. Faking 401 response");
        }

        return E_FAIL;
    }

    m_fTriedAuthenticate = TRUE;

    if (m_pParent)
        hr = m_pParent->Authenticate(phwnd, ppszUsername, ppszPassword);
    else
        hr = E_NOTIMPL;

    if (FAILED(hr) && m_pParent)
    {
        m_pParent->m_dwResponseCode = 401;
        DBG("CUrlDownload_BSC::Authenticate called; no username/pass. Faking 401 response");
    }

    TraceMsg(TF_THISMODULE, "CUrlDownload_BSC::Authenticate returning hr=%08x", hr);

    return hr;
}

STDMETHODIMP CUrlDownload_BSC::OnStartBinding(
    DWORD dwReserved,
    IBinding* pbinding)
{
    m_fSentMimeType = FALSE;
    if (m_pBinding != NULL)
        m_pBinding->Release();
    m_pBinding = pbinding;
    if (m_pBinding != NULL)
    {
        m_pBinding->AddRef();
    }
    if (m_pParent)
        m_pParent->BSC_OnStartBinding();
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::GetPriority
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::GetPriority(LONG* pnPriority)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::OnLowResource
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// %%Function: CUrlDownload_BSC::OnProgress
// ---------------------------------------------------------------------------
 STDMETHODIMP
CUrlDownload_BSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
//  TraceMsg(TF_THISMODULE, "cbsc::OnProgress %d of %d : msg %ws", ulProgress, ulProgressMax, szStatusText);

    /*
    if (ulStatusCode==BINDSTATUS_USINGCACHEDCOPY)
    */
    if (ulStatusCode == BINDSTATUS_REDIRECTING)
    {
        DBG("CUrlDownload_BSC::OnProgress getting redirected url");
        TraceMsg(TF_THISMODULE, "New url=%ws", szStatusText);
        if (m_pParent)
        {
            if (m_pParent->m_pwszURL) MemFree(m_pParent->m_pwszURL);
            m_pParent->m_pwszURL = StrDupW(szStatusText);
        }
    }

    if ((ulStatusCode == BINDSTATUS_CACHEFILENAMEAVAILABLE) && m_pszLocalFileDest)
    {
        ASSERT(!m_pwszLocalFileSrc);
        DBG("CUrlDownload_BSC::OnProgress Getting local file name");
        if (!m_pwszLocalFileSrc)
            m_pwszLocalFileSrc = StrDupW(szStatusText);
    }

    if (m_pParent)
        m_pParent->BSC_OnProgress(ulProgress, ulProgressMax);

    // 14032: If dialmon is around, tell it that something is going on
    IndicateDialmonActivity();

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::OnStopBinding(
    HRESULT     hrStatus,
    LPCWSTR     pszError)
{
#ifdef DEBUG
    if (hrStatus && (hrStatus != E_ABORT))
        TraceMsg(TF_THISMODULE,
            "cbsc: File download Failed hr=%08x.", (int)hrStatus);
#endif

    if (m_pParent)
        m_pParent->BSC_OnStopBinding(hrStatus, (m_iOptions&BDU2_NEEDSTREAM) ? m_pstm : NULL);

    // We should have neither or both of these
    ASSERT(!m_pwszLocalFileSrc == !m_pszLocalFileDest);

    if (m_pwszLocalFileSrc && m_pszLocalFileDest)
    {
        // Copy or move file from cache file to file/directory requested
        // We have a LPWSTR source name and an LPTSTR destination
        TCHAR szSrc[MAX_PATH];
        TCHAR szDest[MAX_PATH];
        LPTSTR pszSrcFileName, pszDest=NULL;

        MyOleStrToStrN(szSrc, MAX_PATH, m_pwszLocalFileSrc);

        // Combine paths to find destination filename if necessary
        if (PathIsDirectory(m_pszLocalFileDest))
        {
            pszSrcFileName = PathFindFileName(szSrc);
            if (pszSrcFileName)
            {
                PathCombine(szDest, m_pszLocalFileDest, pszSrcFileName);
                pszDest = szDest;
            }
        }
        else
        {
            pszDest = m_pszLocalFileDest;
        }

        if (pszDest)
        {
            TraceMsg(TF_THISMODULE, "Copying file\n%s\n to file \n%s", szSrc, pszDest);
            CopyFile(szSrc, pszDest, FALSE);
        }
        else
            DBG_WARN("Unable to get dest path for local file");
    }

    SAFERELEASE(m_pstm);
    SAFERELEASE(m_pBinding);

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::GetBindInfo(
    DWORD       *pgrfBINDF,
    BINDINFO    *pbindInfo)
{
    if ( !pgrfBINDF || !pbindInfo || !pbindInfo->cbSize )
        return E_INVALIDARG;

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NO_UI;
    if (m_pszLocalFileDest)
        *pgrfBINDF |= BINDF_NEEDFILE;
    if (m_pParent && m_pParent->m_fSetResync)
        *pgrfBINDF |= BINDF_RESYNCHRONIZE;
    if (m_pParent && (m_pParent->m_lBindFlags & DLCTL_FORCEOFFLINE))
        *pgrfBINDF |= BINDF_OFFLINEOPERATION;

    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    pbindInfo->dwBindVerb = BINDVERB_GET;

    if (m_iMethod == BDU2_HEADONLY)
    {
        LPWSTR pwszVerb = (LPWSTR) CoTaskMemAlloc(sizeof(c_wszHeadVerb));
        if (pwszVerb)
        {
            CopyMemory(pwszVerb, c_wszHeadVerb, sizeof(c_wszHeadVerb));
            pbindInfo->dwBindVerb = BINDVERB_CUSTOM;
            pbindInfo->szCustomVerb = pwszVerb;
            DBG("Using 'HEAD' custom bind verb.");
        }
        else
        {
            DBG_WARN("MemAlloc failure CUrlDownload_BSC::GetBindInfo");
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

STDMETHODIMP CUrlDownload_BSC::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtetc,
    STGMEDIUM* pstgmed)
{
    TraceMsg(TF_THISMODULE, "%d bytes on page so far (urlmon)", dwSize);

    if (m_pParent)
        if (FAILED(m_pParent->ProgressBytes(dwSize)))
            return S_OK;

        // Get the Stream passed if we want a local file (to lock the file)
    // We just ignore any data in any case
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        if (!m_pstm && (pstgmed->tymed==TYMED_ISTREAM) &&
            (m_pszLocalFileDest || (m_iOptions & BDU2_NEEDSTREAM)))
        {
            m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
        }
    }

    if (!m_fSentMimeType && pfmtetc && m_pParent)
    {
        m_pParent->BSC_FoundMimeType(pfmtetc->cfFormat);
        m_fSentMimeType = TRUE;
    }

    if (BSCF_LASTDATANOTIFICATION & grfBSCF)
    {
        DBG("cbsc: LastDataNotification");
    }

    return S_OK;
}  // CUrlDownload_BSC::OnDataAvailable

STDMETHODIMP CUrlDownload_BSC::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload_BSC::BeginningTransaction(
        LPCWSTR szURL,      LPCWSTR szHeaders,
        DWORD dwReserved,   LPWSTR *pszAdditionalHeaders)
{
    // Add User-Agent and Accept-Language headers
    DBG("CUrlDownload_BSC::BeginningTransaction returning headers");

    LPCWSTR pwszAcceptLanguage;
    int iUAlen=0, iALlen=0;     // in chars, with \r\n, without null-term
    LPWSTR pwsz;
    LPCWSTR pwszUA = m_pParent ? m_pParent->GetUserAgent() : NULL;
    
    pwszAcceptLanguage = (m_pParent) ? m_pParent->GetAcceptLanguages() : NULL;

    if (pwszUA)
    {
        iUAlen = ARRAYSIZE(c_szUserAgentPrefix) + lstrlenW(pwszUA) + 1;
    }
    
    if (pwszAcceptLanguage)
    {
        iALlen = ARRAYSIZE(c_szAcceptLanguagePrefix) + lstrlenW(pwszAcceptLanguage)+1;
    }

    if (iUAlen || iALlen)
    {
        int iAlloc = iUAlen + iALlen + 1;
        pwsz = (WCHAR *)CoTaskMemAlloc(iAlloc * sizeof(WCHAR));

        if (pwsz)
        {
            pwsz[0] = L'\0';
            
            if (iUAlen)
            {
                StrCpyNW(pwsz, c_szUserAgentPrefix, iAlloc);
                StrCatBuffW(pwsz, pwszUA, iAlloc);
                StrCatBuffW(pwsz, L"\r\n", iAlloc);
            }

            if (iALlen)
            {
                StrCatBuffW(pwsz, c_szAcceptLanguagePrefix, iAlloc);
                StrCatBuffW(pwsz, pwszAcceptLanguage, iAlloc);
                StrCatBuffW(pwsz, L"\r\n", iAlloc);
            }

            ASSERT(lstrlenW(pwsz) == (iUAlen + iALlen));

            *pszAdditionalHeaders = pwsz;

            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}
    
STDMETHODIMP CUrlDownload_BSC::OnResponse(
        DWORD   dwResponseCode,     LPCWSTR szResponseHeaders, 
        LPCWSTR szRequestHeaders,   LPWSTR *pszAdditionalRequestHeaders)
{
    TraceMsg(TF_THISMODULE, "CUrlDownload_BSC::OnResponse - %d", dwResponseCode);

    // If we sent a "HEAD" request, Urlmon will hang expecting data.
    // Abort it here.
    if (m_iMethod == BDU2_HEADONLY)
    {
        // First get the Last-Modified date from Urlmon
        IWinInetHttpInfo    *pInfo;

        if (m_pParent
            && SUCCEEDED(m_pBinding->QueryInterface(IID_IWinInetHttpInfo, (void **)&pInfo)
            && pInfo))
        {
            SYSTEMTIME  st;
            DWORD       dwSize = sizeof(st), dwZero=0;

            if (SUCCEEDED(pInfo->QueryInfo(HTTP_QUERY_FLAG_SYSTEMTIME | HTTP_QUERY_LAST_MODIFIED,
                                           (LPVOID) &st, &dwSize, &dwZero, 0)))
            {
                m_pParent->BSC_FoundLastModified(&st);
            }

            pInfo->Release();
        }
        Abort();    // FEATURE: return E_ABORT and handle abort internally
    }

    if (m_pParent)
        m_pParent->m_dwResponseCode = dwResponseCode;
    else
        DBG_WARN("CUrlDownload_BSC::OnResponse - Parent already NULL");

    return S_OK;
}

//
// IOleClientSite
//
STDMETHODIMP CUrlDownload:: SaveObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    DBG("CUrlDownload::GetMoniker returning failure");
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: ShowObject(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CUrlDownload:: RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}



// ParseRefreshContent was lifted in its entirety from shdocvw\basesb.cpp
BOOL ParseRefreshContent(LPWSTR pwzContent,
    UINT * puiDelay, LPWSTR pwzUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ [ws]* ; [ws]* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS, PRC_SEMI, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPWSTR pwz = pwzContent;
    LPWSTR pwzUrl = NULL;
    UINT   cchUrl = 0;
    WCHAR  wch,  wchDel = 0;

    *pwzUrlBuf = 0;

    do
    {
        wch = *pwz;

        switch (uiState)
        {
            case PRC_START:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                {
                    uiState = PRC_DIG;
                    uiDelay = wch - TEXT('0');
                }
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_DIG:
                if (wch >= TEXT('0') && wch <= TEXT('9'))
                    uiDelay = uiDelay * 10 + wch - TEXT('0');
                else if (ISSPACE(wch))
                    uiState = PRC_DIG_WS;
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_WS:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI:
                if (    (wch == TEXT('u') || wch == TEXT('U'))
                    &&  (pwz[1] == TEXT('r') || pwz[1] == TEXT('R'))
                    &&  (pwz[2] == TEXT('l') || pwz[2] == TEXT('L')))
                {
                    uiState = PRC_SEMI_URL;
                    pwz += 2;
                }
                else if (!ISSPACE(wch) && wch != TEXT(';'))
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (wch == TEXT('='))
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pwzUrlBuf = 0;
                }
                else if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (wch == TEXT(';'))
                    uiState = PRC_SEMI;
                else if (!ISSPACE(wch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pwzUrl = pwzUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (wch == TEXT('\'')|| wch == TEXT('\"'))
                        wchDel = wch;
                    else
                    {
                        wchDel = 0;
                        *pwzUrl++ = wch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !wch
                    ||  ( wchDel && wch == wchDel)
                    ||  (!wchDel && wch == L';'))
                {
                    *pwzUrl = 0;
                    uiState = wch == TEXT(';') ? PRC_SEMI : PRC_DIG_WS;
                }
                else if (cchUrl > 1)
                {
                    *pwzUrl++ = wch;
                    cchUrl--;
                }
                break;
        }

        ++pwz;

    } while (wch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
} // ParseRefreshContent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\droptrgt.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "subsmgrp.h"

HRESULT _GetURLData(IDataObject *pdtobj, int iDropType, TCHAR *pszUrl, UINT cchUrl, TCHAR *pszName, UINT cchName);
HRESULT _ConvertHDROPData(IDataObject *, BOOL);
HRESULT ScheduleDefault(LPCTSTR, LPCTSTR);

#define CITBDTYPE_HDROP     1
#define CITBDTYPE_URL       2
#define CITBDTYPE_TEXT      3

//
// Constructor
//

COfflineDropTarget::COfflineDropTarget(HWND hwndParent)
{
    m_cRefs                 = 1;
    m_hwndParent            = hwndParent;
    m_pDataObj              = NULL;
    m_grfKeyStateLast       = 0;
    m_fHasHDROP             = FALSE;
    m_fHasSHELLURL          = FALSE;
    m_fHasTEXT              = FALSE;
    m_dwEffectLastReturned  = 0;

    DllAddRef();
}

//
// Destructor
//

COfflineDropTarget::~COfflineDropTarget()
{
    DllRelease();
}

//
// QueryInterface
//

STDMETHODIMP COfflineDropTarget::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT  hr = E_NOINTERFACE;

    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = (LPDROPTARGET)this;

        AddRef();

        hr = NOERROR;
    }

    return hr;
}   

//
// AddRef
//

STDMETHODIMP_(ULONG) COfflineDropTarget::AddRef()
{
    return ++m_cRefs;
}

//
// Release
//

STDMETHODIMP_(ULONG) COfflineDropTarget::Release()
{
    if (0L != --m_cRefs)
    {
        return m_cRefs;
    }

    delete this;

    return 0L;
}

//
// DragEnter
//

STDMETHODIMP COfflineDropTarget::DragEnter(LPDATAOBJECT pDataObj, 
                                           DWORD        grfKeyState,
                                           POINTL       pt, 
                                           LPDWORD      pdwEffect)
{
    // Release any old data object we might have

//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragEnter"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }

    m_grfKeyStateLast = grfKeyState;
    m_pDataObj        = pDataObj;

    //
    // See if we will be able to get CF_HDROP from this guy
    //

    if (pDataObj)
    {
        pDataObj->AddRef();
            TCHAR url[INTERNET_MAX_URL_LENGTH], name[MAX_NAME_QUICKLINK];
            FORMATETC fe = {(CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLURL), 
                        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

            m_fHasSHELLURL = m_fHasHDROP = m_fHasTEXT = FALSE;
            if (NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : SHELLURL!");
                m_fHasSHELLURL = 
                    (NOERROR == _GetURLData(pDataObj,CITBDTYPE_URL,url,ARRAYSIZE(url),name, ARRAYSIZE(name)));
            }
            if (fe.cfFormat = CF_HDROP, NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : HDROP!");
                m_fHasHDROP = (NOERROR == 
                    _ConvertHDROPData(pDataObj, FALSE));
            }
            if (fe.cfFormat = CF_TEXT, NOERROR == pDataObj->QueryGetData(&fe))
            {
                TraceMsg(TF_SUBSFOLDER, "odt - DragEnter : TEXT!");
                m_fHasTEXT = 
                    (NOERROR == _GetURLData(pDataObj,CITBDTYPE_TEXT,url,ARRAYSIZE(url),name, ARRAYSIZE(name)));
            }
    }

    // Save the drop effect

    if (pdwEffect)
    {
        *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
    }

    return S_OK;
}

//
// GetDropEffect
//

DWORD COfflineDropTarget::GetDropEffect(LPDWORD pdwEffect)
{
    ASSERT(pdwEffect);

    if (m_fHasSHELLURL || m_fHasTEXT)
    {
        return *pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK);
    }
    else if (m_fHasHDROP)    {
        return *pdwEffect & (DROPEFFECT_COPY );
    }
    else
    {
        return DROPEFFECT_NONE;
    }
}

//
// DragOver
//

STDMETHODIMP COfflineDropTarget::DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragOver"));
    if (m_grfKeyStateLast == grfKeyState)
    {
        // Return the effect we saved at dragenter time

        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned;
        }
    }
    else
    {
        if (*pdwEffect)
        {
            *pdwEffect = m_dwEffectLastReturned = GetDropEffect(pdwEffect);
        }
    }

    m_grfKeyStateLast = grfKeyState;

    return S_OK;
}

//
// DragLeave
//
 
STDMETHODIMP COfflineDropTarget::DragLeave()
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - DragLeave"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    return S_OK;
}

//
// Drop
//
STDMETHODIMP COfflineDropTarget::Drop(LPDATAOBJECT pDataObj,
                                      DWORD        grfKeyState, 
                                      POINTL       pt, 
                                      LPDWORD      pdwEffect)
{
//    UINT idCmd;             // Choice from drop popup menu
    HRESULT hr = S_OK;
  
    //
    // Take the new data object, since OLE can give us a different one than
    // it did in DragEnter
    //

//    TraceMsg(TF_SUBSFOLDER, TEXT("odt - Drop"));
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
    m_pDataObj = pDataObj;
    if (pDataObj)
    {
        pDataObj->AddRef();
    }

    // If the dataobject doesn't have an HDROP, its not much good to us

    *pdwEffect &= DROPEFFECT_COPY|DROPEFFECT_LINK; 
    if (!(*pdwEffect))  {
        DragLeave();        
        return S_OK;
    }


    hr = E_NOINTERFACE;
    if (m_fHasHDROP)
        hr = _ConvertHDROPData(pDataObj, TRUE);
    else  {
        TCHAR url[INTERNET_MAX_URL_LENGTH], name[MAX_NAME_QUICKLINK];
        if (m_fHasSHELLURL)
            hr = _GetURLData(pDataObj, CITBDTYPE_URL, url, ARRAYSIZE(url), name, ARRAYSIZE(name));
        if (FAILED(hr) && m_fHasTEXT)
            hr = _GetURLData(pDataObj, CITBDTYPE_TEXT, url, ARRAYSIZE(url), name, ARRAYSIZE(name));
        if (SUCCEEDED(hr))  {
            TraceMsg(TF_SUBSFOLDER, "URL: %s, Name: %s", url, name);  
            hr = ScheduleDefault(url, name);
        }
    }

    if (FAILED(hr))
    {
        TraceMsg(TF_SUBSFOLDER, "Couldn't DROP");
    }

    DragLeave();
    return hr;
}

HRESULT _CLSIDFromExtension(
    LPCTSTR pszExt, 
    CLSID *pclsid)
{
    TCHAR szProgID[80];
    long cb = SIZEOF(szProgID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];
        
        StrCatBuff(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID)); 
        cb = SIZEOF(szCLSID);

        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szCLSID, &cb) == ERROR_SUCCESS)
        {
            // FEATURE (scotth): call shell32's SHCLSIDFromString once it
            //                  exports A/W versions.  This would clean this
            //                  up.

            return CLSIDFromString(szCLSID, pclsid);
        }
    }
    return E_FAIL;
}


// get the target of a shortcut. this uses IShellLink which 
// Internet Shortcuts (.URL) and Shell Shortcuts (.LNK) support so
// it should work generally
//
HRESULT _GetURLTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch)
{
    IShellLink *psl;
    HRESULT hr = E_FAIL;
    CLSID clsid;

    if (FAILED(_CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *)&psl);

    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;

        hr = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(pszPath, 0);
            ppf->Release();
        }
        if (SUCCEEDED(hr))  {
            IUniformResourceLocator * purl;

            hr = psl->QueryInterface(IID_IUniformResourceLocator,(void**)&purl);
            if (SUCCEEDED(hr))
                purl->Release();
        }
        if (SUCCEEDED(hr))
            hr = psl->GetPath(pszTarget, cch, NULL, SLGP_UNCPRIORITY);
        psl->Release();
    }
    return hr;
}

HRESULT _ConvertHDROPData(IDataObject *pdtobj, BOOL bSubscribe)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    FORMATETC formatetc;
    TCHAR    url[INTERNET_MAX_URL_LENGTH];
    TCHAR    name[MAX_NAME_QUICKLINK];

    name[0] = 0;
    url[0] = 0;

    formatetc.cfFormat = CF_HDROP;
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_HGLOBAL;

    // Get the parse string
    hRes = pdtobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hRes))
    {
        LPTSTR pszURLData = (LPTSTR)GlobalLock(stgmedium.hGlobal);
        if (pszURLData) {
            TCHAR szPath[MAX_PATH];
            SHFILEINFO sfi;
            int cFiles, i;
            HDROP hDrop = (HDROP)stgmedium.hGlobal;

            hRes = S_FALSE;
            cFiles = DragQueryFile(hDrop, 0xFFFFFFFF, NULL, 0);
            for (i = 0; i < cFiles; i ++)   {
                DragQueryFile(hDrop, i, szPath, ARRAYSIZE(szPath));

                // defaults...
                StrCpyN(name, szPath, ARRAYSIZE(name));

                if (SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
                    StrCpyN(name, sfi.szDisplayName, ARRAYSIZE(name));

                if (SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi),SHGFI_ATTRIBUTES)
                        && (sfi.dwAttributes & SFGAO_LINK))
                {
                    if (SUCCEEDED(_GetURLTarget(szPath, url, INTERNET_MAX_URL_LENGTH)))
                    { 
                        TraceMsg(TF_SUBSFOLDER, "URL: %s, Name: %s", url, name);  
                        //  If we just want to see whether there is some urls
                        //  here, we can break now.
                        if (!bSubscribe)    
                        {
                            if ((IsHTTPPrefixed(url)) && 
                                (!SHRestricted2(REST_NoAddingSubscriptions, url, 0)))
                            {
                                hRes = S_OK;
                            }
                            break;
                        }
                        hRes = ScheduleDefault(url, name);
                    }
                }
            }
            GlobalUnlock(stgmedium.hGlobal);
            if (bSubscribe)
                hRes = S_OK;
        } else
            hRes = S_FALSE;

        ReleaseStgMedium(&stgmedium);
    }
    return hRes;
}
    
//  Takes a variety of inputs and returns a string for drop targets.
//  szUrl:    the URL
//  szName:   the name (for quicklinks and the confo dialog boxes)
//  returns:  NOERROR if succeeded
//
HRESULT _GetURLData(IDataObject *pdtobj, int iDropType, TCHAR *pszUrl, UINT cchUrl, TCHAR *pszName, UINT cchName)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    FORMATETC formatetc;

    *pszName = 0;
    *pszUrl = 0;

    switch (iDropType)
    {
    case CITBDTYPE_URL:
        formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLURL);
        break;
    case CITBDTYPE_TEXT:
        formatetc.cfFormat = CF_TEXT;
        break;
    default:
        return E_UNEXPECTED;
    }
    formatetc.ptd = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = -1;
    formatetc.tymed = TYMED_HGLOBAL;

    // Get the parse string
    hRes = pdtobj->GetData(&formatetc, &stgmedium);
    if (SUCCEEDED(hRes))
    {
        LPTSTR pszURLData = (LPTSTR)GlobalLock(stgmedium.hGlobal);
        if (pszURLData)
        {
            if (iDropType == CITBDTYPE_URL)
            {
                STGMEDIUM stgmediumFGD;

                 // defaults
                StrCpyN(pszUrl,  pszURLData, cchUrl);
                StrCpyN(pszName, pszURLData, cchName);

                formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
                if (SUCCEEDED(pdtobj->GetData(&formatetc, &stgmediumFGD)))
                {
                    FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(stgmediumFGD.hGlobal);
                    if (pfgd)
                    {
                        TCHAR szPath[MAX_PATH];
                        StrCpyN(szPath, pfgd->fgd[0].cFileName, ARRAYSIZE(szPath));
                        PathRemoveExtension(szPath);
                        StrCpyN(pszName, szPath, cchName);
                        GlobalUnlock(stgmediumFGD.hGlobal);
                    }
                    ReleaseStgMedium(&stgmediumFGD);
                }
            }
            else if (iDropType == CITBDTYPE_TEXT)
            {
                if (PathIsURL(pszURLData))  {
                    StrCpyN(pszUrl, pszURLData, cchUrl);
                    StrCpyN(pszName, pszURLData, cchName);
                } else
                    hRes = E_FAIL;
            }
            GlobalUnlock(stgmedium.hGlobal);
        }
        ReleaseStgMedium(&stgmedium);
    }

    if (SUCCEEDED(hRes))
    {
        if (!IsHTTPPrefixed(pszUrl) || SHRestricted2(REST_NoAddingSubscriptions, pszUrl, 0))
        {
            hRes = E_FAIL;
        }
    }
    return hRes;
}

HRESULT ScheduleDefault(LPCTSTR url, LPCTSTR name)
{
    if (!IsHTTPPrefixed(url))
        return E_INVALIDARG;

    ISubscriptionMgr    * pSub= NULL;
    HRESULT hr = CoInitialize(NULL);
    RETURN_ON_FAILURE(hr);

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, 
                IID_ISubscriptionMgr, (void **)&pSub);
    CoUninitialize();
    RETURN_ON_FAILURE(hr);
    ASSERT(pSub);

    BSTR    bstrURL = NULL, bstrName = NULL;
    hr = CreateBSTRFromTSTR(&bstrURL, url);
    if (S_OK == hr)
        hr = CreateBSTRFromTSTR(&bstrName, name);

    //  We need a perfectly valid structure.
    SUBSCRIPTIONINFO    subInfo;
    ZeroMemory((void *)&subInfo, sizeof (subInfo));
    subInfo.cbSize = sizeof(SUBSCRIPTIONINFO);

    if (S_OK == hr)
        hr = pSub->CreateSubscription(NULL, bstrURL, bstrName,
                                      CREATESUBS_NOUI, SUBSTYPE_URL, &subInfo);

    SAFERELEASE(pSub);
    SAFEFREEBSTR(bstrURL);
    SAFEFREEBSTR(bstrName);

    if (FAILED(hr)) {
        TraceMsg(TF_ALWAYS, "Failed to add default object.");
        TraceMsg(TF_ALWAYS, "  hr = 0x%x\n", hr);
        return (FAILED(hr))?hr:E_FAIL;
    } else if (hr == S_FALSE)   {
        TraceMsg(TF_SUBSFOLDER, "%s(%s) is already there.", url, name);
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\factory.cpp ===
#include "private.h"
#include "factory.h"

CClassFactory::CClassFactory(const CFactoryData *pFactoryData) :
    m_pFactoryData(pFactoryData)
{
    ASSERT(NULL != m_pFactoryData);

    m_cRef = 1;

    DllAddRef();
}

CClassFactory::~CClassFactory()
{
    DllRelease();
}

// IUnknown members
STDMETHODIMP CClassFactory::QueryInterface(
    REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }
    
    *ppv=NULL;

    // Validate requested interface
    if( IID_IUnknown == riid || IID_IClassFactory == riid )
        *ppv = (IClassFactory *)this;

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

// IClassFactory members
STDMETHODIMP CClassFactory::CreateInstance(
    LPUNKNOWN punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if ((NULL == ppv) ||
        (punkOuter && (IID_IUnknown != riid)))
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if ((NULL != punkOuter) && 
        !(m_pFactoryData->m_dwFlags & FD_ALLOWAGGREGATION))
    {
        return CLASS_E_NOAGGREGATION;
    }

    IUnknown *punk;
    hr = m_pFactoryData->m_pCreateProc(punkOuter, &punk);

    if (SUCCEEDED(hr))
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    }

    ASSERT((SUCCEEDED(hr) && (NULL != *ppv)) || 
           (FAILED(hr) && (NULL == *ppv)))

    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllLock();
    }
    else
    {
        DllUnlock();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\factory.h ===
#ifndef _factory_h
#define _factory_h

#define FD_ALLOWAGGREGATION     0x00000001

struct CFactoryData
{
    CLSID const *m_pClsid;
    CREATEPROC  m_pCreateProc;
    DWORD       m_dwFlags;
};

class CClassFactory : public IClassFactory
{
public:
    CClassFactory(const CFactoryData *pFactoryData);
    ~CClassFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **ppvObj);
    STDMETHODIMP         LockServer(BOOL fLock);

private:
    ULONG               m_cRef;
    const CFactoryData  *m_pFactoryData;
};

#endif // _factory_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\filetime.h ===
#ifndef _FILETIME_H_
#define _FILETIME_H_

//**************************************************************************
//  NOTE:  This file is duplicated in urlmon and webcheck.  If you make 
//         changes please sync them!
//**************************************************************************

#define MAKEINT64(lo, hi)   ((__int64)(((DWORD)(lo)) | ((__int64)((DWORD)(hi))) << 32))

#ifndef LODWORD
#define LODWORD(i)          ((DWORD)(i))
#endif

#ifndef HIDWORD
#define HIDWORD(i)          ((DWORD)(((__int64)(i) >> 32) & 0xFFFFFFFF))
#endif

// This is Monday, January 1, 1601 at 12:00:00 am
#define MIN_FILETIME            0i64

// This is Thursday, September 14, 30828 at 2:48:05 am
#define MAX_FILETIME            0x7FFFFFFFFFFFFFFFi64

//  For clarity since FILETIME is expressed as 100-nanosecond intervals
#define ONE_SECOND_IN_FILETIME  10000000i64
#define ONE_MSEC_IN_FILEITME    10000i64
#define ONE_MINUTE_IN_FILETIME  (ONE_SECOND_IN_FILETIME * 60i64)

struct CFileTime : public FILETIME
{
    // Constructors
    CFileTime()             { *this = 0; }
    CFileTime(const FILETIME& f)  { *this = f; }
    CFileTime(const CFileTime& f) { *this = f; }
    CFileTime(__int64 i)    { *this = i; }

    // Assignment operators
    inline CFileTime& operator = (const FILETIME& f)
    {   
        dwLowDateTime = f.dwLowDateTime;
        dwHighDateTime = f.dwHighDateTime;
        return *this;
    }

    inline CFileTime& operator = (const CFileTime& f)
    {   
        dwLowDateTime = f.dwLowDateTime;
        dwHighDateTime = f.dwHighDateTime;
        return *this;
    }

    inline CFileTime& operator = (__int64 i)
    {   
        dwLowDateTime = LODWORD(i);
        dwHighDateTime = HIDWORD(i);
        return *this;
    }

    // Comparison operators
    inline BOOL operator == (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) == i;
    }

    inline BOOL operator > (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) > i;
    }

    inline BOOL operator < (__int64 i)
    {   
        return MAKEINT64(dwLowDateTime, dwHighDateTime) < i;
    }

    inline BOOL operator != (__int64 i)
    {   
        return !(*this == i);
    }

    inline BOOL operator >= (__int64 i)
    {   
        return !(*this < i);
    }

    inline BOOL operator <= (__int64 i)
    {   
        return !(*this > i);
    }

    inline BOOL operator == (const FILETIME& f)
    {   
        return *this == MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator > (const FILETIME& f)
    {   
        return *this > MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator < (const FILETIME& f)
    {   
        return *this < MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }

    inline BOOL operator != (const FILETIME& f)
    {   
        return !(*this == f);
    }

    inline BOOL operator >= (const FILETIME& f)
    {   
        return !(*this < f);
    }

    inline BOOL operator <= (const FILETIME& f)
    {   
        return !(*this > f);
    }

    // Arithemetic operators
    inline CFileTime operator + (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) + i);
    }
    
    inline CFileTime operator += (__int64 i)
    {
        *this = *this + i;
        return *this;
    }

    inline CFileTime operator - (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) - i);
    }
    
    inline CFileTime operator -= (__int64 i)
    {
        *this = *this - i;
        return *this;
    }

    inline CFileTime operator * (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) * i);
    }
    
    inline CFileTime operator *= (__int64 i)
    {
        *this = *this * i;
        return *this;
    }

    inline CFileTime operator / (__int64 i)
    {
        return CFileTime(MAKEINT64(dwLowDateTime, dwHighDateTime) / i);
    }
    
    inline CFileTime operator /= (__int64 i)
    {
        *this = *this / i;
        return *this;
    }

    inline CFileTime operator + (const FILETIME& f)
    {
        return *this + MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator += (const FILETIME& f)
    {
        *this = *this + f;
        return *this;
    }

    inline CFileTime operator - (const FILETIME& f)
    {
        return *this - MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator -= (const FILETIME& f)
    {
        *this = *this - f;
        return *this;
    }

    inline CFileTime operator * (const FILETIME& f)
    {
        return *this * MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator *= (const FILETIME& f)
    {
        *this = *this * f;
        return *this;
    }

    inline CFileTime operator / (const FILETIME& f)
    {
        return *this / MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
    }
    
    inline CFileTime operator /= (const FILETIME& f)
    {
        *this = *this / f;
        return *this;
    }
};

//
//  Conversions 
//  NOTE: We can't do want operator __int64() since what causes to many
//  ambiguous situations that the compiler just can't handle.
//
inline  __int64 FileTimeToInt64(const FILETIME& f)
{
    return MAKEINT64(f.dwLowDateTime, f.dwHighDateTime);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\helper.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "subsmgrp.h"
#include "helper.h"

#include <mluisupp.h>

#ifdef DEBUG
void    DumpTaskTrigger(TASK_TRIGGER * pTaskTrigger);
#endif  // DEBUG

// {D994B6F0-DA3C-11d1-857D-00C04FA35C89}
const GUID NOOP_SCHEDULE_COOKIE =
{ 0xd994b6f0, 0xda3c, 0x11d1, { 0x85, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x5c, 0x89
} };

#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif

const PROPSPEC c_rgPropRead[] = {
    { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION},
    { PRSPEC_PROPID, PID_INTSITE_FLAGS},
    { PRSPEC_PROPID, PID_INTSITE_TRACKING},
    { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
};

void UpdateTimeFormat(LPTSTR tszTimeFormat, ULONG cchTimeFormat);

HRESULT WriteProperties(POOEntry pooe);
HRESULT ReadProperties(POOEBuf pBuf);

const TCHAR c_szLoadWC[] = TEXT("LoadWC");

void FixupRandomTrigger(TASK_TRIGGER *pTrigger)
{
    if (pTrigger->wRandomMinutesInterval > 0)
    {
        //  We have a random interval so we need to add a random number of minutes to it.
        //  Given the fact that all of the fields need to carry over to the next, the
        //  simplest way to do this is to flatten the start time into FILETIME, add the
        //  random minutes, and then convert back to a TASK_TRIGGER.  This let's us use
        //  Win32 APIs instead of doing all of the calendar and carry over stuff ourselves.

        SYSTEMTIME st;
        CFileTime ft;

        memset(&st, 0, sizeof(st));
        st.wYear = pTrigger->wBeginYear;
        st.wMonth = pTrigger->wBeginMonth;
        st.wDay = pTrigger->wBeginDay;
        st.wHour = pTrigger->wStartHour;
        st.wMinute = pTrigger->wStartMinute;

        SystemTimeToFileTime(&st, &ft);

        ft += ONE_MINUTE_IN_FILETIME * (__int64)Random(pTrigger->wRandomMinutesInterval);

        FileTimeToSystemTime(&ft, &st);

        pTrigger->wBeginYear = st.wYear;
        pTrigger->wBeginMonth = st.wMonth;
        pTrigger->wBeginDay = st.wDay;
        pTrigger->wStartHour = st.wHour;
        pTrigger->wStartMinute = st.wMinute;

        pTrigger->wRandomMinutesInterval = 0;
    }
}

//  Come up with a name like "MSN Recommended Schedule"
void CreatePublisherScheduleNameW(WCHAR *pwszSchedName, int cchSchedName,
                                  const TCHAR *pszName, const WCHAR *pwszName)
{
    WCHAR wszFormat[MAX_PATH];
    WCHAR wszPubName[MAX_PATH];
    const WCHAR *pwszPubName;

    ASSERT((NULL != pszName) || (NULL != pwszName));
    ASSERT((NULL != pwszSchedName) && (cchSchedName > 0));

    if (NULL == pwszName)
    {
        ASSERT(NULL != pszName);
        MyStrToOleStrN(wszPubName, ARRAYSIZE(wszPubName), pszName);
        pwszPubName = wszPubName;
    }
    else
    {
        pwszPubName = pwszName;
    }


    MLLoadStringW(IDS_RECOMMENDED_SCHEDULE_FORMAT, wszFormat, ARRAYSIZE(wszFormat));

    wnsprintfW(pwszSchedName, cchSchedName, wszFormat, pwszPubName);
}

void CreatePublisherScheduleName(TCHAR *pszSchedName, int cchSchedName,
                                 const TCHAR *pszName, const WCHAR *pwszName)
{
    WCHAR wszSchedName[MAX_PATH];

    CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                 pszName, pwszName);

    MyOleStrToStrN(pszSchedName, cchSchedName, wszSchedName);
}

HICON LoadItemIcon(ISubscriptionItem *psi, BOOL bLarge)
{
    HICON hIcon = NULL;
    SUBSCRIPTIONITEMINFO sii;
    SUBSCRIPTIONCOOKIE cookie;
    HRESULT hr;

    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

    psi->GetCookie(&cookie);

    hr = psi->GetSubscriptionItemInfo(&sii);

    if (SUCCEEDED(hr))
    {
        ISubscriptionAgentShellExt *pSubscriptionAgentShellExt;

        hr = CoCreateInstance(sii.clsidAgent, NULL, CLSCTX_INPROC_SERVER,
                              IID_ISubscriptionAgentShellExt,
                              (void **)&pSubscriptionAgentShellExt);
        if (SUCCEEDED(hr))
        {
            hr = pSubscriptionAgentShellExt->Initialize(&cookie, L"", L"", (SUBSCRIPTIONTYPE)-1);

            if (SUCCEEDED(hr))
            {
                IExtractIcon *pExtractIcon;
                hr = pSubscriptionAgentShellExt->QueryInterface(IID_IExtractIcon,
                                                                (void **)&pExtractIcon);

                if (SUCCEEDED(hr))
                {
                    TCHAR szIconFile[INTERNET_MAX_URL_LENGTH];
                    int iIndex;
                    UINT wFlags;
                    HICON hIconScrap = NULL;
                    HICON *phIconLarge = bLarge ? &hIcon : &hIconScrap;
                    HICON *phIconSmall = bLarge ? &hIconScrap : &hIcon;

                    hr = pExtractIcon->GetIconLocation(0, szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);

                    if (SUCCEEDED(hr))
                    {
                        hr = pExtractIcon->Extract(szIconFile, iIndex, phIconLarge, phIconSmall,
                                                   MAKELONG(GetSystemMetrics(SM_CXICON),
                                                            GetSystemMetrics(SM_CXSMICON)));

                        if (S_FALSE == hr)
                        {
                            hIcon = ExtractIcon(g_hInst, szIconFile, iIndex);

                            if (NULL == hIcon)
                            {
                                hr = E_FAIL;
                            }
                        }
                        else if ((NULL != hIconScrap) && (hIcon != hIconScrap))
                        {
                            DestroyIcon(hIconScrap);
                        }
                    }
                    pExtractIcon->Release();
                }
            }

            pSubscriptionAgentShellExt->Release();
        }
    }

    if (FAILED(hr))
    {
        DWORD dwChannel = 0;
        DWORD dwDesktop = 0;
        int iSize = bLarge ? GetSystemMetrics(SM_CXICON) : GetSystemMetrics(SM_CXSMICON);
        int id;
        HINSTANCE   hinstSrc;

        ReadDWORD(psi, c_szPropChannel, &dwChannel);
        ReadDWORD(psi, c_szPropDesktopComponent, &dwDesktop);

        if (dwDesktop == 1)
        {
            id = IDI_DESKTOPITEM;
            hinstSrc = MLGetHinst();
        }
        else if (dwChannel == 1)
        {
            id = IDI_CHANNEL;
            hinstSrc = g_hInst;
        }
        else
        {
            id = IDI_WEBDOC;
            hinstSrc = g_hInst;
        }

        hIcon = (HICON)LoadImage(hinstSrc, MAKEINTRESOURCE(id), IMAGE_ICON,
                                 iSize, iSize, LR_DEFAULTCOLOR);

    }

    return hIcon;
}

BOOL ScheduleCookieExists(SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule = NULL;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr == S_OK;
}

struct CONFLICT_DATA
{
    TCHAR szSchedName[MAX_PATH];
    TCHAR szFriendlyTrigger[MAX_PATH];
};

INT_PTR CALLBACK SchedConflictDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szConflictFormat[MAX_PATH];
            TCHAR szConflictMsg[MAX_PATH * 2];
            CONFLICT_DATA *pcd = (CONFLICT_DATA *)lParam;

            ASSERT(NULL != pcd);

            MLLoadString(IDS_SCHED_CONFLICT_FORMAT,
                       szConflictFormat, ARRAYSIZE(szConflictFormat));

            wnsprintf(szConflictMsg, ARRAYSIZE(szConflictMsg),
                      szConflictFormat, pcd->szSchedName);

            SetDlgItemText(hdlg, IDC_SCHEDULE_MESSAGE, szConflictMsg);
            SetDlgItemText(hdlg, IDC_FRIENDLY_SCHEDULE_TEXT, pcd->szFriendlyTrigger);

            bResult = TRUE;
            break;
        }

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EndDialog(hdlg, LOWORD(wParam));
                bResult = TRUE;
            }
            break;
    }

    return bResult;
}

BOOL CompareTaskTrigger(TASK_TRIGGER *pTrigA, TASK_TRIGGER *pTrigB)
{
    BOOL bDontMatch;    //  TRUE if any elements don't match

    //  Simple memcmp won't work since the start date will be different
    //  when in fact they are effectively the same schedule - at least
    //  from a user perspective.

    //  FEATURE - this is far from complete - we only check for values
    //  which can be set by our wizard.

    bDontMatch  = pTrigA->wStartHour != pTrigB->wStartHour;
    bDontMatch |= pTrigA->wStartMinute != pTrigB->wStartMinute;
    bDontMatch |= pTrigA->TriggerType != pTrigB->TriggerType;
    bDontMatch |= pTrigA->Type.Daily.DaysInterval != pTrigB->Type.Daily.DaysInterval;
    bDontMatch |= pTrigA->MinutesDuration != pTrigB->MinutesDuration;
    bDontMatch |= pTrigA->MinutesInterval != pTrigB->MinutesInterval;
    bDontMatch |= pTrigA->wRandomMinutesInterval != pTrigB->wRandomMinutesInterval;

    return !bDontMatch;
}


//  HandleScheduleNameConflict
//
//  Return values:
//  CONFLICT_NONE               - pSchedCookie will be GUID_NULL and the caller is
//                                free to create a new schedule
//  CONFLICT_RESOLVED_USE_NEW   - pSchedCookie will be the cookie of an existing
//                                schedule which the caller should update with
//                                it's new TASK_TRIGGER
//  CONFLICT_RESOLVED_USE_OLD   - pSchedCookie will be the cookie of an existing
//                                schedule which the caller should use without
//                                modifying anything
//  CONFLICT_UNRESOLVED         - pSchedCookie will be GUID_NULL and the caller
//                                shouldn't do anything until the user has made
//                                up his/her mind
//
int HandleScheduleNameConflict(/* in  */ TCHAR *pszSchedName,
                               /* in  */ TASK_TRIGGER *pTrigger,
                               /* in  */ HWND hwndParent,
                               /* out */ SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;
    int iResult = CONFLICT_NONE;

    *pSchedCookie = GUID_NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule = NULL;
            SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;
            WCHAR wszSchedName[MAX_PATH];

            MyStrToOleStrN(wszSchedName, ARRAYSIZE(wszSchedName), pszSchedName);

            {
                CWaitCursor waitCursor;

                hr = pSyncScheduleMgr->CreateSchedule(wszSchedName, 0,
                                                      &schedCookie, &pSyncSchedule);
            }
            if (SUCCEEDED(hr))
            {
                pSyncSchedule->Release();
            }
            else if (SYNCMGR_E_NAME_IN_USE == hr)
            {
                //  schedCookie will have the cookie of the conflicting schedule
                hr = pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule);

                if (SUCCEEDED(hr))
                {
                    ITaskTrigger *pITaskTrigger;

                    hr = pSyncSchedule->GetTrigger(&pITaskTrigger);

                    if (SUCCEEDED(hr))
                    {
                        TASK_TRIGGER existTrigger = { sizeof(TASK_TRIGGER) };

                        hr = pITaskTrigger->GetTrigger(&existTrigger);

                        if (SUCCEEDED(hr))
                        {
                            if (!CompareTaskTrigger(&existTrigger, pTrigger))
                            {
                                CONFLICT_DATA cd;
                                LPWSTR pwszFriendlyTrigger;

                                StrCpyN(cd.szSchedName, pszSchedName, ARRAYSIZE(cd.szSchedName));
                                if (SUCCEEDED(pITaskTrigger->GetTriggerString(&pwszFriendlyTrigger)))
                                {
                                    MyOleStrToStrN(cd.szFriendlyTrigger,
                                                   ARRAYSIZE(cd.szFriendlyTrigger),
                                                   pwszFriendlyTrigger);
                                    CoTaskMemFree(pwszFriendlyTrigger);
                                }
                                else
                                {
                                    cd.szFriendlyTrigger[0] = TEXT('\0');
                                }

                                INT_PTR iRet = DialogBoxParam(MLGetHinst(),
                                                              MAKEINTRESOURCE(IDD_DUPLICATE_SCHEDULE),
                                                              hwndParent,
                                                              SchedConflictDlgProc,
                                                              (LPARAM)&cd);
                                switch (iRet)
                                {
                                    case IDC_NEW_SETTINGS:
                                        iResult = CONFLICT_RESOLVED_USE_NEW;
                                        *pSchedCookie = schedCookie;
                                        break;

                                    case IDC_OLD_SETTINGS:
                                        iResult = CONFLICT_RESOLVED_USE_OLD;
                                        *pSchedCookie = schedCookie;
                                        break;

                                    default:
                                        iResult = CONFLICT_UNRESOLVED;
                                        break;
                                }
                            }
                        }
                        pITaskTrigger->Release();
                    }
                    pSyncSchedule->Release();
                }
            }

            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return iResult;
}

HRESULT UpdateScheduleTrigger(SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                ITaskTrigger *pITaskTrigger;

                hr = pSyncSchedule->GetTrigger(&pITaskTrigger);
                if (SUCCEEDED(hr))
                {
                    FixupRandomTrigger(pTrigger);

                    hr = pITaskTrigger->SetTrigger(pTrigger);

                    if (SUCCEEDED(hr))
                    {
                        hr = pSyncSchedule->Save();
                    }

                    pITaskTrigger->Release();
                }
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT RemoveItemFromAllSchedules(SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            IEnumSyncSchedules *pEnumSyncSchedules;

            hr = pSyncScheduleMgr->EnumSyncSchedules(&pEnumSyncSchedules);

            if (SUCCEEDED(hr))
            {
                SYNCSCHEDULECOOKIE schedCookie;
                ULONG ulFetched;

                while (S_OK == pEnumSyncSchedules->Next(1, &schedCookie, &ulFetched) &&
                       (0 != ulFetched))    //  this shouldn't be necessary
                {
                    ISyncSchedule *pSyncSchedule;

                    //  If this fails, there ain't much we can do about
                    //  it so just plod along anyhow

                    if (SUCCEEDED(pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule)))
                    {
                        //  Don't care about the return value, it's cheaper
                        //  for us to just delete than to ask if it's there
                        //  and then delete.
                        pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                    pCookie,
                                                    SYNCMGRITEMSTATE_UNCHECKED);
                        pSyncSchedule->Save();
                        pSyncSchedule->Release();
                    }
                }
                pEnumSyncSchedules->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT AddRemoveScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, // For Add
                               SUBSCRIPTIONCOOKIE *pCookie,                  // For Remove
                               SYNCSCHEDULECOOKIE *pSchedCookie, BOOL bAdd)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    ASSERT((bAdd && (NULL != pSyncHandlerItemInfo)) ||
            (!bAdd && (NULL != pCookie)));

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                if (bAdd)
                {

                    hr = pSyncSchedule->AddItem(pSyncHandlerItemInfo);
                    hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                     &pSyncHandlerItemInfo->itemID,
                                                     SYNCMGRITEMSTATE_CHECKED);
                }
                else
                {

                    hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                     pCookie,
                                                     SYNCMGRITEMSTATE_UNCHECKED);
                }
                hr = pSyncSchedule->Save();
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT SetScheduleValues(ISyncSchedule *pSyncSchedule,
                          TASK_TRIGGER *pTrigger,
                          DWORD dwSyncScheduleFlags)
{
    HRESULT hr;
    ITaskTrigger *pITaskTrigger;

    ASSERT(NULL != pSyncSchedule);
    ASSERT(NULL != pTrigger);

    hr = pSyncSchedule->GetTrigger(&pITaskTrigger);

    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        FixupRandomTrigger(pTrigger);
        hr = pITaskTrigger->SetTrigger(pTrigger);
        pITaskTrigger->Release();

        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            DWORD dwFlags;
            DWORD dwConnectionType = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;
            WCHAR wszConnectionName[MAX_PATH];

            //  Return code doesn't help us.  This returns the best guess
            //  at connection:
            //      1) LAN
            //      2) currently connected connectoid
            //      3) auto-dial connectoid
            //  This is according to darrenmi, if this changes - kill him.
            InternetGetConnectedStateExW(&dwFlags, wszConnectionName,
                                         ARRAYSIZE(wszConnectionName), 0);

            if (dwFlags & INTERNET_CONNECTION_MODEM)
            {
                dwConnectionType = SYNCSCHEDINFO_FLAGS_CONNECTION_WAN;
            }

            hr = pSyncSchedule->SetConnection(
                (dwConnectionType == SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) ?
                    wszConnectionName : NULL,
                dwConnectionType);

            ASSERT(SUCCEEDED(hr));

            if (SUCCEEDED(hr))
            {
                hr = pSyncSchedule->SetFlags(dwSyncScheduleFlags);

                ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr))
                {
                    hr = pSyncSchedule->Save();

                    ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }

    return hr;
}

HRESULT CreateSchedule(LPWSTR pwszScheduleName, DWORD dwSyncScheduleFlags,
                       SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger,
                       BOOL fDupCookieOK)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;
    ISyncSchedule *pSyncSchedule = NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            hr = pSyncScheduleMgr->CreateSchedule(pwszScheduleName, 0,
                                      pSchedCookie, &pSyncSchedule);

            ASSERT((FAILED(hr) && (NULL == pSyncSchedule)) ||
                   (SUCCEEDED(hr) && (NULL != pSyncSchedule)));

            switch (hr)
            {
                case S_OK:
                    hr = SetScheduleValues(pSyncSchedule, pTrigger, dwSyncScheduleFlags);

                #ifdef DEBUG
                    if (FAILED(hr))
                    {
                        TraceMsg(TF_ALWAYS, "SetScheduleValues failed - hr=0x%08x", hr);
                    }
                #endif

                    break;

                case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
                    if (fDupCookieOK)
                    {
                        hr = S_OK;
                    }
                    break;
            }

            SAFERELEASE(pSyncSchedule);

            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

BOOL IsCookieOnSchedule(ISyncSchedule *pSyncSchedule, SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr;
    DWORD dwCheckState = SYNCMGRITEMSTATE_UNCHECKED;

    hr = pSyncSchedule->GetItemCheck(CLSID_WebCheckOfflineSync,
                                     pCookie,
                                     &dwCheckState);

    return SUCCEEDED(hr) && (SYNCMGRITEMSTATE_CHECKED & dwCheckState);
}

struct GIS_DATA
{
    SUBSCRIPTIONCOOKIE *pSubsCookie;
    SYNCSCHEDULECOOKIE *pSchedCookie;
};

BOOL GetItemScheduleCallback(ISyncSchedule *pSyncSchedule,
                             SYNCSCHEDULECOOKIE *pSchedCookie,
                             LPARAM lParam)
{
    BOOL bContinue = TRUE;
    GIS_DATA *pgd = (GIS_DATA *)lParam;

    if (IsCookieOnSchedule(pSyncSchedule, pgd->pSubsCookie))
    {
        *pgd->pSchedCookie = *pSchedCookie;
        bContinue = FALSE;
    }

    return bContinue;
}


HRESULT GetItemSchedule(SUBSCRIPTIONCOOKIE *pSubsCookie, SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    *pSchedCookie = GUID_NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);
        if (SUCCEEDED(hr))
        {
            ISubscriptionItem *psi;

            //  First let's chech to see if it has a custom schedule
            hr = SubscriptionItemFromCookie(FALSE, pSubsCookie, &psi);

            if (SUCCEEDED(hr))
            {
                SUBSCRIPTIONITEMINFO sii;

                sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

                hr = psi->GetSubscriptionItemInfo(&sii);

                psi->Release();

                if (SUCCEEDED(hr) && (sii.ScheduleGroup != GUID_NULL))
                {
                    *pSchedCookie = sii.ScheduleGroup;
                }
                else
                {
                    GIS_DATA gd;

                    gd.pSubsCookie = pSubsCookie;
                    gd.pSchedCookie = pSchedCookie;
                    EnumSchedules(GetItemScheduleCallback, (LPARAM)&gd);
                }
            }


            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT EnumSchedules(SCHEDULEENUMCALLBACK pCallback, LPARAM lParam)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            IEnumSyncSchedules *pEnumSyncSchedules;

            hr = pSyncScheduleMgr->EnumSyncSchedules(&pEnumSyncSchedules);

            if (SUCCEEDED(hr))
            {
                SYNCSCHEDULECOOKIE schedCookie;
                ULONG ulFetched;

                while (S_OK == pEnumSyncSchedules->Next(1, &schedCookie, &ulFetched)&&
                       (0 != ulFetched))    //  this shouldn't be necessary
                {
                    ISyncSchedule *pSyncSchedule;

                    HRESULT hrTemp = pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule);
                    if (SUCCEEDED(hrTemp) && pSyncSchedule)
                    {
                        BOOL bContinue = pCallback(pSyncSchedule, &schedCookie, lParam);
                        pSyncSchedule->Release();

                        if (!bContinue)
                        {
                            hr = S_FALSE;
                            break;
                        }
                    }
                }
                pEnumSyncSchedules->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

SUBSCRIPTIONTYPE GetItemCategory(BOOL bDesktop, const CLSID& clsidDest)
{
    SUBSCRIPTIONTYPE st;

    if (clsidDest == CLSID_WebCrawlerAgent)
    {
        st = (!bDesktop) ? SUBSTYPE_URL : SUBSTYPE_DESKTOPURL;
    }
    else if (clsidDest == CLSID_ChannelAgent)
    {
        st = (!bDesktop) ? SUBSTYPE_CHANNEL : SUBSTYPE_DESKTOPCHANNEL;
    }
    else
    {
        st = SUBSTYPE_EXTERNAL;
    }

    return st;
}


SUBSCRIPTIONSCHEDULE GetGroup(BOOL bDesktop, const CLSID& clsidDest,
                              DWORD fChannelFlags, const NOTIFICATIONCOOKIE& groupCookie)
{


    SUBSCRIPTIONTYPE category = GetItemCategory(bDesktop, clsidDest);
    if (category == SUBSTYPE_CHANNEL || category == SUBSTYPE_DESKTOPCHANNEL) {
        if ((fChannelFlags & CHANNEL_AGENT_DYNAMIC_SCHEDULE) &&
            (GUID_NULL == groupCookie))
            return SUBSSCHED_AUTO;
    }

    //  We have no idea about the AUTO schedule stuff of unknown types.

    if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_DAILY)
            return SUBSSCHED_DAILY;
    else if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY)
        return SUBSSCHED_WEEKLY;
    else if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_MANUAL)
        return SUBSSCHED_MANUAL;
    else
        return SUBSSCHED_CUSTOM;
}

HRESULT LoadGroupCookie(NOTIFICATIONCOOKIE * pCookie, SUBSCRIPTIONSCHEDULE subGroup)
{
    if (pCookie)    {
        switch (subGroup)   {
        case SUBSSCHED_DAILY:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
            break;
        case SUBSSCHED_WEEKLY:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
            break;
        case SUBSSCHED_MANUAL:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;
            break;
        default:
            *pCookie = CLSID_NULL;
            ASSERT(0);
            break;
        }
        return S_OK;
    }

    return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////
//  Subscription helper functions.


HRESULT TSTR2BSTR(VARIANT * pvarBSTR, LPCTSTR srcTSTR)
{
    ASSERT(pvarBSTR);
    ASSERT(srcTSTR);

    BSTR    bstrBuf = NULL;
    LONG    lTSTRLen = 0;

    lTSTRLen = lstrlen(srcTSTR) + 1;
    bstrBuf = SysAllocStringLen(NULL, lTSTRLen);
    if (!bstrBuf)
        return E_OUTOFMEMORY;
    MyStrToOleStrN(bstrBuf, lTSTRLen, srcTSTR);
    pvarBSTR->vt = VT_BSTR;
    pvarBSTR->bstrVal = bstrBuf;
    return S_OK;
}

HRESULT WriteCookieToInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie, BOOL bRemove)
{
    PROPVARIANT propCookie;
    LPOLESTR pclsid = NULL; // init to keep compiler happy

    ASSERT(pszURL);
    if (bRemove)
    {
        propCookie.vt = VT_EMPTY;
    }
    else
    {
        ASSERT(pCookie);

        if (FAILED(StringFromCLSID(*pCookie, &pclsid)))
            return E_FAIL;

        propCookie.vt = VT_LPWSTR;
        propCookie.pwszVal = pclsid;
    }

    HRESULT hr = IntSiteHelper(pszURL, &c_rgPropRead[PROP_SUBSCRIPTION], &propCookie, 1, TRUE);

    if (!bRemove)
        CoTaskMemFree(pclsid);

    return hr;
}

HRESULT WritePropertiesToItem(POOEntry pooe, ISubscriptionItem *psi)
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL bHasUNAME = TRUE;

    ASSERT(NULL != psi);

    VariantInit(&var);
    if (pooe->dwFlags & PROP_WEBCRAWL_URL)
    {
        if (FAILED(TSTR2BSTR(&var, URL(pooe))))
            return E_FAIL;
        WriteVariant(psi, c_szPropURL, &var);
        VariantClear(&var);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_NAME)
    {
        if (FAILED(TSTR2BSTR(&var, NAME(pooe))))
            return E_FAIL;
        WriteVariant(psi, c_szPropName, &var);
        VariantClear(&var);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_UNAME)
    {
        if(*(UNAME(pooe)))
        {
            if (FAILED(TSTR2BSTR(&var, UNAME(pooe))))
                return E_FAIL;
            WriteVariant(psi, c_szPropCrawlUsername, &var);
            VariantClear(&var);
        }
        else
        {
            WriteEMPTY(psi, c_szPropCrawlUsername);
            bHasUNAME = FALSE;
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_DESKTOP)
    {
        if (pooe->bDesktop)
        {
            WriteDWORD(psi, c_szPropDesktopComponent, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropDesktopComponent);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANNEL)
    {
        if (pooe->bChannel)
        {
            WriteDWORD(psi, c_szPropChannel, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropChannel);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_GLEAM)
    {
        if (pooe->bGleam)
        {
            WriteDWORD(psi, c_szPropEnableShortcutGleam, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropEnableShortcutGleam);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANGESONLY)
    {
        if (pooe->bChangesOnly)
        {
            WriteDWORD(psi, c_szPropCrawlChangesOnly, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropCrawlChangesOnly);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANNELFLAGS)
    {
        if (pooe->fChannelFlags)
        {
            WriteDWORD(psi, c_szPropChannelFlags, pooe->fChannelFlags);
        }
        else
        {
            WriteEMPTY(psi, c_szPropChannelFlags);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_EMAILNOTF)
    {
        if (pooe->bMail)
        {
            WriteDWORD(psi, c_szPropEmailNotf, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropEmailNotf);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_PSWD)
    {
        if (*(PASSWD(pooe)) && bHasUNAME)
        {
            if (FAILED(TSTR2BSTR(&var, PASSWD(pooe))))
                return E_FAIL;
            WritePassword(psi, var.bstrVal);
            VariantClear(&var);
        }
        else
        {
            WritePassword(psi, NULL);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_LEVEL)
    {
        if(pooe->m_RecurseLevels)
        {
            WriteDWORD(psi, c_szPropCrawlLevels, pooe->m_RecurseLevels);
        }
        else
        {
            // top page only was specified, empty out levels
            WriteEMPTY(psi, c_szPropCrawlLevels);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_FLAGS)
    {
        WriteDWORD(psi, c_szPropCrawlFlags, pooe->m_RecurseFlags);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_ACTUALSIZE)
    {
        WriteDWORD(psi, c_szPropCrawlActualSize, pooe->m_ActualSize);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_SIZE)
    {
        if(pooe->m_SizeLimit)
        {
            // limit was specified
            WriteDWORD(psi, c_szPropCrawlMaxSize, pooe->m_SizeLimit);
        }
        else
        {
            // no limit was specified, empty out limit prop
            WriteEMPTY(psi, c_szPropCrawlMaxSize);
        }
    }

    SUBSCRIPTIONITEMINFO sii;
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
    {
        sii.dwFlags = pooe->grfTaskTrigger;
        psi->SetSubscriptionItemInfo(&sii);
    }

    //  We don't write Status/Last update.

    // FEATURE: We should fail the subscription if we were unable to write
    // any of the properties into the notification for some reason.


    return hr;
}

HRESULT WriteProperties(POOEntry pooe)
{
    HRESULT hr;
    ISubscriptionItem *psi = NULL;

    ASSERT(NULL != pooe);

    hr = SubscriptionItemFromCookie(FALSE, &pooe->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        hr = WritePropertiesToItem(pooe, psi);
        psi->Release();
    }
    return hr;
}

#define RANDOM_TIME_START       0       // 12am (in minutes)
#define RANDOM_TIME_END         300     // 5am (in minutes)
#define RANDOM_TIME_INC         30      // 30min increment

DWORD GetRandomTime(DWORD StartMins, DWORD EndMins, DWORD Inc)
{
    DWORD Range;
    DWORD nIncrements;

    if (StartMins > EndMins)
    {
        Range = ((1440 - StartMins) + EndMins);
    }
    else
    {
        Range = (EndMins - StartMins);
    }

    nIncrements = ((Range / Inc) + 1);

    return (StartMins + (Random(nIncrements) * Inc));
}

HRESULT CreateDefaultSchedule(SUBSCRIPTIONSCHEDULE subsSchedule,
                              SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr = S_OK;
    TASK_TRIGGER trig;
    int resID;

    memset((void*) &trig, 0x0, sizeof(TASK_TRIGGER));
    *pSchedCookie = GUID_NULL;

    ZeroMemory(&trig, sizeof(trig));

    switch (subsSchedule)
    {
        case SUBSSCHED_DAILY:
            trig.TriggerType = TASK_TIME_TRIGGER_DAILY;
            trig.Type.Daily.DaysInterval = 1;
            resID = IDS_DAILY_GRO;
            *pSchedCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
            break;

        case SUBSSCHED_WEEKLY:
            trig.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
            trig.Type.Weekly.WeeksInterval = 1;
            trig.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY;
            resID = IDS_WEEKLY_GRO;
            *pSchedCookie = NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
            break;

        case SUBSSCHED_AUTO:
        case SUBSSCHED_CUSTOM:
        case SUBSSCHED_MANUAL:
        default:
            resID = 0;
            hr = E_FAIL;
            break;
    }

    if (SUCCEEDED(hr))
    {
        if (!ScheduleCookieExists(pSchedCookie))
        {
            WCHAR wszSchedName[MAX_PATH];
            DWORD dwRandTime = GetRandomTime(RANDOM_TIME_START,
                                             RANDOM_TIME_END,
                                             RANDOM_TIME_INC);

            trig.cbTriggerSize = sizeof(TASK_TRIGGER);
            trig.wRandomMinutesInterval = RANDOM_TIME_INC;
            trig.wStartHour = (UINT)(dwRandTime / 60);
            trig.wStartMinute = (UINT)(dwRandTime % 60);
            trig.rgFlags = 0;

            MLLoadStringW(resID, wszSchedName, ARRAYSIZE(wszSchedName));

            hr = CreateSchedule(wszSchedName, 0, pSchedCookie, &trig, TRUE);

            if (hr == SYNCMGR_E_NAME_IN_USE)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT AddIt(ISubscriptionItem *psi, POOEntry pooe, SUBSCRIPTIONSCHEDULE subGroup)
{
    SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;
    HRESULT hr = E_FAIL;

    switch (subGroup)
    {
        case SUBSSCHED_DAILY:
        case SUBSSCHED_WEEKLY:
            hr = CreateDefaultSchedule(subGroup, &schedCookie);
            break;

        case SUBSSCHED_CUSTOM:
            schedCookie = pooe->groupCookie;
            hr = S_OK;
            break;

        case SUBSSCHED_MANUAL:
	    SUBSCRIPTIONCOOKIE cookie;

	    cookie = pooe->m_Cookie;
            RemoveItemFromAllSchedules(&cookie);
	    pooe->m_Cookie = cookie;
            hr = S_FALSE;
            break;

        case SUBSSCHED_AUTO:
            //  FEATURE - for now, until pub schedules are wired in
            hr = CreateDefaultSchedule(SUBSSCHED_DAILY, &schedCookie);
            break;
    }

    if (hr == S_OK)
    {
        ASSERT(GUID_NULL != schedCookie);

        if (NOOP_SCHEDULE_COOKIE == schedCookie)
        {
            hr = S_FALSE;
        }
        if (GUID_NULL != schedCookie)
        {
            SYNC_HANDLER_ITEM_INFO shii;

            shii.handlerID = CLSID_WebCheckOfflineSync;
            shii.itemID = pooe->m_Cookie;
            shii.hIcon = NULL;
            MyStrToOleStrN(shii.wszItemName, ARRAYSIZE(shii.wszItemName), NAME(pooe));
            shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

            hr = AddScheduledItem(&shii, &schedCookie);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return S_OK;
//  return hr;
}

HRESULT ScheduleIt(ISubscriptionItem *psi, TCHAR *pszName, TASK_TRIGGER *pTrigger)
{
    HRESULT hr;
    SUBSCRIPTIONITEMINFO subscriptionItemInfo;

    ASSERT(pTrigger->cbTriggerSize == sizeof(TASK_TRIGGER));

    subscriptionItemInfo.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

#ifdef DEBUG
    DumpTaskTrigger(pTrigger);
#endif

    hr = psi->GetSubscriptionItemInfo(&subscriptionItemInfo);

    if (SUCCEEDED(hr))
    {
        if (GUID_NULL != subscriptionItemInfo.ScheduleGroup)
        {
            hr = UpdateScheduleTrigger(&subscriptionItemInfo.ScheduleGroup, pTrigger);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        WCHAR wszSchedName[MAX_PATH];

        CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                     pszName, NULL);

        hr = CreateSchedule(wszSchedName, SYNCSCHEDINFO_FLAGS_READONLY,
                            &subscriptionItemInfo.ScheduleGroup, pTrigger, TRUE);

        if (SUCCEEDED(hr) || (hr == SYNCMGR_E_NAME_IN_USE))
        {
            psi->SetSubscriptionItemInfo(&subscriptionItemInfo);
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ALWAYS, "Error creating schedule - hr=0x%08x", hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        SYNC_HANDLER_ITEM_INFO shii;

        shii.handlerID = CLSID_WebCheckOfflineSync;
        psi->GetCookie(&shii.itemID);
        shii.hIcon = NULL;
        MyStrToOleStrN(shii.wszItemName, ARRAYSIZE(shii.wszItemName), pszName);

        hr = AddScheduledItem(&shii, &subscriptionItemInfo.ScheduleGroup);
    }

    return S_OK;
//    return hr;
}

HRESULT ReadProperties(POOEBuf pBuf)
{
    VARIANT var;
    HRESULT hr;
    ASSERT(pBuf);
    BOOL    bHasUNAME = TRUE;
    ISubscriptionItem *psi = NULL;

    ASSERT(NULL != pBuf);

    hr = SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        VariantInit(&var);
        if (pBuf->dwFlags & PROP_WEBCRAWL_URL)
        {
            hr = ReadVariant(psi, c_szPropURL, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->m_URL, MAX_URL, var.bstrVal);
            }
            else
            {
                pBuf->m_URL[0] = (TCHAR)0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_NAME)
        {
            hr = ReadVariant(psi, c_szPropName, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->m_Name, MAX_NAME, var.bstrVal);
            }
            else
            {
                pBuf->m_Name[0] = (TCHAR)0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_UNAME)
        {
            hr = ReadVariant(psi, c_szPropCrawlUsername, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->username, MAX_USERNAME, var.bstrVal);
            }
            else
            {
                pBuf->username[0] = (TCHAR)0;
                bHasUNAME = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_DESKTOP)
        {
            hr = ReadVariant(psi, c_szPropDesktopComponent, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bDesktop = TRUE;
            }
            else
            {
                pBuf->bDesktop = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANNEL)
        {
            hr = ReadVariant(psi, c_szPropChannel, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bChannel = TRUE;
            }
            else
            {
                pBuf->bChannel = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_GLEAM)
        {
            hr = ReadVariant(psi, c_szPropEnableShortcutGleam, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bGleam = TRUE;
            }
            else
            {
                pBuf->bGleam = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANGESONLY)
        {
            hr = ReadVariant(psi, c_szPropCrawlChangesOnly, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bChangesOnly = TRUE;
            }
            else
            {
                pBuf->bChangesOnly = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANNELFLAGS)
        {
            hr = ReadVariant(psi, c_szPropChannelFlags, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4))
            {
                pBuf->fChannelFlags = var.lVal;
            }
            else
            {
                pBuf->fChannelFlags = 0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_EMAILNOTF)
        {
            hr = ReadVariant(psi, c_szPropEmailNotf, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bMail = TRUE;
            }
            else
            {
                pBuf->bMail = FALSE;
            }
            VariantClear(&var);
        }

        if ((pBuf->dwFlags & PROP_WEBCRAWL_PSWD) && bHasUNAME)
        {
            BSTR bstrVal = NULL;
            hr = ReadPassword(psi, &bstrVal);
            if (SUCCEEDED(hr) && bstrVal)
            {
                MyOleStrToStrN(pBuf->password, MAX_PASSWORD, bstrVal);
            }
            else
            {
                pBuf->password[0] = (TCHAR)0;
            }
            SAFEFREEBSTR(bstrVal);
        }

        if ((pBuf->dwFlags & PROP_WEBCRAWL_PSWD) || (pBuf->dwFlags & PROP_WEBCRAWL_UNAME)) {
            //bNeedPassword isn't stored in the property map... calculate it from the presence
            //of username/password.
            pBuf->bNeedPassword = pBuf->password[0] || pBuf->username[0];
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_STATUS)
        {
            hr = ReadVariant(psi, c_szPropStatusString, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->statusStr, MAX_STATUS, var.bstrVal);
            }
            else
            {
                pBuf->statusStr[0] = (TCHAR)0;
            }
            VariantClear(&var);

            hr = ReadSCODE(psi, c_szPropStatusCode, &(pBuf->status));
            //  FEATURE What should we put here if we don't have last status?
            if (FAILED(hr))
            {
                pBuf->status = S_OK;
            }
            VariantClear(&var);
        }

        //
        // Use the CompletionTime property if present and it is greater than
        // value in the NOTIFICATIONITEM structure.
        //

        if (pBuf->dwFlags & PROP_WEBCRAWL_LAST)
        {
            CFileTime ft;
            hr = ReadVariant(psi, c_szPropCompletionTime, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_DATE))
            {
                VariantTimeToFileTime(var.date, ft);

                if (ft > pBuf->m_LastUpdated)
                {
                    pBuf->m_LastUpdated = ft;
                }
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_LEVEL)
        {
            hr = ReadDWORD(psi, c_szPropCrawlLevels, (DWORD *)&(pBuf->m_RecurseLevels));
            if (FAILED(hr))
            {
                pBuf->m_RecurseLevels = 0;
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_FLAGS)
        {
            hr = ReadDWORD(psi, c_szPropCrawlFlags, (DWORD *)&(pBuf->m_RecurseFlags));
            if (FAILED(hr))
            {
                pBuf->m_RecurseFlags = 0;   //  Minimal memory usage.
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_SIZE)
        {
            hr = ReadDWORD(psi, c_szPropCrawlMaxSize, (DWORD *)&(pBuf->m_SizeLimit));
            if (FAILED(hr))
            {
                pBuf->m_SizeLimit = 0;
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_ACTUALSIZE)
        {
            hr = ReadDWORD(psi, c_szPropCrawlActualSize, (DWORD *)&(pBuf->m_ActualSize));
            if (FAILED(hr))
            {
                pBuf->m_ActualSize = 0;
            }
        }

        SUBSCRIPTIONITEMINFO sii;
        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
        if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
        {
            pBuf->grfTaskTrigger = sii.dwFlags;
        }

        psi->Release();
    }

    // FEATURE: Need to support c_szPropEnableShortcutGleam here.

    return S_OK;
}

// If url is NULL, no need to compare.
HRESULT LoadWithCookie(LPCTSTR pszURL, POOEBuf pBuf, DWORD *pdwBufferSize, SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr = LoadOOEntryInfo(pBuf, pCookie, pdwBufferSize);

    if (SUCCEEDED(hr) && pszURL)
    {
        if (UrlCompare(pBuf->m_URL, pszURL, TRUE))
        {
            TraceMsg(TF_ALWAYS, "Mismatched cookie/URL in LoadWithCookie");
            hr = E_FAIL;      //  Mismatched cookie!
        }
    }

    return hr;
}

HRESULT ReadCookieFromInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(pszURL && pCookie);
    PROPVARIANT propCookie;

    PropVariantInit(&propCookie);

    HRESULT hr = FindURLProps(pszURL, &propCookie);

    if (SUCCEEDED(hr) && (propCookie.vt == VT_LPWSTR))
    {
        hr = CLSIDFromString(propCookie.pwszVal, pCookie);
    }
    PropVariantClear(&propCookie);

    //  If we couldn't find it, use a brute force approach
    if (S_OK != hr)
    {
        CEnumSubscription *pes = new CEnumSubscription;

        if (NULL != pes)
        {
            if (SUCCEEDED(pes->Initialize(0)))
            {
                SUBSCRIPTIONCOOKIE cookie;
                BOOL bFound = FALSE;

                while (!bFound && (S_OK == pes->Next(1, &cookie, NULL)))
                {
                    ISubscriptionItem *psi;

                    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &cookie, &psi)))
                    {
                        LPTSTR pszCurURL;

                        if (SUCCEEDED(ReadTSTR(psi, c_szPropURL, &pszCurURL)))
                        {
                            bFound = (StrCmpI(pszCurURL, pszURL) == 0);
                            CoTaskMemFree(pszCurURL);
                        }
                        psi->Release();
                    }
                }

                if (bFound)
                {
                    WriteCookieToInetDB(pszURL, &cookie, FALSE);
                    *pCookie = cookie;
                    hr = S_OK;
                }
            }
            pes->Release();
        }
    }

    return hr;
}

HRESULT LoadSubscription(LPCTSTR url, LPMYPIDL *ppidl)
{
    HRESULT hr;

    POOEntry pooe = NULL;
    OOEBuf  ooeBuf;
    DWORD   dwBufferSize;
    SUBSCRIPTIONCOOKIE cookie;

    hr = ReadCookieFromInetDB(url, &cookie);
    if (S_OK == hr)
    {
        hr = LoadWithCookie(url, &ooeBuf, &dwBufferSize, &cookie);
        if (hr == S_OK)
        {
            *ppidl = COfflineFolderEnum::NewPidl(dwBufferSize);
            if (!(*ppidl))
            {
                return E_OUTOFMEMORY;
            }
            pooe = &((*ppidl)->ooe);
            CopyToMyPooe(&ooeBuf, pooe);
        }
        else
        {
            WriteCookieToInetDB(url, NULL, TRUE);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// KENSY: This needs to work like GetDefaultInfo

HRESULT GetDefaultOOEBuf(OOEBuf * pBuf, SUBSCRIPTIONTYPE subType)
{
    ASSERT(pBuf);
    ASSERT(IS_VALID_SUBSCRIPTIONTYPE(subType));

    memset((void *)pBuf, 0, sizeof(OOEBuf));
    pBuf->dwFlags = PROP_WEBCRAWL_ALL;
    pBuf->m_RecurseLevels = DEFAULTLEVEL;
    pBuf->m_RecurseFlags = DEFAULTFLAGS;
    pBuf->m_Priority = AGENT_PRIORITY_NORMAL;
    if (subType == SUBSTYPE_CHANNEL || subType == SUBSTYPE_DESKTOPCHANNEL)
    {
        pBuf->clsidDest = CLSID_ChannelAgent;
        pBuf->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
    }
    else
    {
        pBuf->clsidDest = CLSID_WebCrawlerAgent;
    }
    pBuf->bDesktop = (subType == SUBSTYPE_DESKTOPCHANNEL || subType == SUBSTYPE_DESKTOPURL);
    pBuf->bChannel = (subType == SUBSTYPE_CHANNEL || subType == SUBSTYPE_DESKTOPCHANNEL);
    pBuf->bGleam = !(pBuf->bDesktop);
    pBuf->m_LastUpdated = 0;
    pBuf->m_NextUpdate = 0;

    //  APPCOMPAT: Is this what we want?  IE 4 was DAILY.
    //  Default to not changing the schedule settings -- if it's already subscribed
    //  we won't blast anything and if it's not already subscribed then it will
    //  just be manual.
    pBuf->groupCookie = NOOP_SCHEDULE_COOKIE;

    pBuf->grfTaskTrigger = TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET |     // Default to not autodial
                           TASK_FLAG_START_ONLY_IF_IDLE;               // and to idle time

    return S_OK;
}

HRESULT CreateSubscriptionFromOOEBuf(OOEBuf *pBuf, LPMYPIDL *ppidl)
{
    HRESULT hr;
    DWORD dwBufferSize = BufferSize(pBuf);
    SUBSCRIPTIONCOOKIE cookie;

    *ppidl = COfflineFolderEnum::NewPidl(dwBufferSize);
    if (!(*ppidl))
    {
        return E_OUTOFMEMORY;
    }
    POOEntry pooe = &((*ppidl)->ooe);
    CopyToMyPooe(pBuf, pooe);

    //  See if the caller has already given us a cookie
    if (GUID_NULL == pooe->m_Cookie)
    {
        //  Nope, see if we have one already
	cookie = pooe->m_Cookie;
        ReadCookieFromInetDB(URL(pooe), &cookie);
	pooe->m_Cookie = cookie;

        if (GUID_NULL == pooe->m_Cookie)
        {
            //  Nope, so create one
            CreateCookie(&pooe->m_Cookie);
        }
    }

    cookie = pooe->m_Cookie;
    WriteCookieToInetDB(URL(pooe), &cookie, FALSE);
    pooe->m_Cookie = cookie;

    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    SUBSCRIPTIONITEMINFO sii;
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    sii.dwFlags = 0;
    sii.dwPriority = 0;
    sii.ScheduleGroup = CLSID_NULL;
    sii.clsidAgent = pooe->clsidDest;
    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), URL(pooe));
    hr = AddUpdateSubscription(&(pooe->m_Cookie), &sii, wszURL, 0, NULL, NULL);

    if (SUCCEEDED(hr))
    {
        hr = WriteProperties(pooe);

        if (SUCCEEDED(hr))
        {
            ISubscriptionItem *psi;

            hr = SubscriptionItemFromCookie(TRUE, &pooe->m_Cookie, &psi);

            if (SUCCEEDED(hr))
            {
                SUBSCRIPTIONSCHEDULE subGroup = GetGroup(pooe);
                SUBSCRIPTIONTYPE   subType = GetItemCategory(pooe);

                if (subGroup == SUBSSCHED_AUTO)
                {
                    if (subType != SUBSTYPE_CHANNEL && subType != SUBSTYPE_DESKTOPCHANNEL)
                    {
                        hr = AddIt(psi, pooe, SUBSSCHED_DAILY);
                    }
                    else
                    {
                        if (pooe->m_Trigger.cbTriggerSize == sizeof(TASK_TRIGGER))
                        {
			    TASK_TRIGGER trigger;

			    trigger = pooe->m_Trigger;
                            hr = ScheduleIt(psi, NAME(pooe), &trigger);
			    pooe->m_Trigger = trigger;

                            pooe->groupCookie = CLSID_NULL;
                        }
                        else
                        {
                            hr = AddIt(psi, pooe, SUBSSCHED_DAILY);
                        }
                    }
                }
                else
                {
                    hr = AddIt(psi, pooe, subGroup);
                }

                psi->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        FireSubscriptionEvent(SUBSNOTF_CREATE, &pooe->m_Cookie);
    }
    else
    {
        TraceMsg(TF_ALWAYS, "Failed to add new subscription");
        TraceMsg(TF_ALWAYS, "\thr = 0x%x", hr);
        COfflineFolderEnum::FreePidl(*ppidl);
        *ppidl = NULL;
    }

    return hr;
}

HRESULT SendUpdateRequests(HWND hwnd, CLSID * arrClsid, UINT count)
{
    ISubscriptionMgr2 *pSubsMgr2;
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                              IID_ISubscriptionMgr2, (void**)&pSubsMgr2);
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONCOOKIE *pCookies = NULL;
            ULONG nItemsToRun = count;

            if (NULL == arrClsid)
            {
                IEnumSubscription *pes;

                hr = pSubsMgr2->EnumSubscriptions(0, &pes);

                if (SUCCEEDED(hr))
                {
                    ASSERT(NULL != pes);

                    pes->GetCount(&nItemsToRun);
                    if (nItemsToRun > 0)
                    {
                        pCookies = new SUBSCRIPTIONCOOKIE[nItemsToRun];

                        if (NULL != pCookies)
                        {
                            hr = pes->Next(nItemsToRun, pCookies, &nItemsToRun);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    pes->Release();
                }
            }
            else
            {
                pCookies = arrClsid;
            }

            if (SUCCEEDED(hr))
            {
                hr = pSubsMgr2->UpdateItems(0, nItemsToRun, pCookies);
            }

            if ((NULL == arrClsid) && (NULL != pCookies))
            {
                delete [] pCookies;
            }

            pSubsMgr2->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT DoDeleteSubscription(POOEntry pooe)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    ASSERT(NULL != pooe);

    hr = SubscriptionItemFromCookie(FALSE, &pooe->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        WritePassword(psi, NULL);

        hr = DoDeleteSubscriptionItem(&pooe->m_Cookie, TRUE);

        if (SUCCEEDED(hr) && (GetItemCategory(pooe) != SUBSTYPE_EXTERNAL))
        {
            WriteCookieToInetDB(URL(pooe), NULL, TRUE);
        }
    }

    return hr;
}

HRESULT PersistUpdate(POOEntry pooe, BOOL bCreate)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    hr = SubscriptionItemFromCookie(bCreate, &(pooe->m_Cookie), &psi);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };

        hr = psi->GetSubscriptionItemInfo(&sii);

        if (SUCCEEDED(hr) || bCreate)
        {
            sii.clsidAgent = pooe->clsidDest;
            hr = psi->SetSubscriptionItemInfo(&sii);

            if (SUCCEEDED(hr))
            {
                hr = WritePropertiesToItem(pooe, psi);

                if (SUCCEEDED(hr) && IsNativeAgent(pooe->clsidDest))
                {
		    SUBSCRIPTIONCOOKIE cookie;

		    cookie = pooe->m_Cookie;
                    WriteCookieToInetDB(URL(pooe), &cookie, FALSE);
		    pooe->m_Cookie = cookie;
                }
            }
        }

        // REVIEW: should we delete on failure here?
        psi->Release();
    }

    return hr;
}

#ifdef NEWSCHED_AUTONAME
void NewSched_AutoNameHelper(HWND hDlg)
{
    TCHAR szDays[16];
    TCHAR szTime[128];
    TCHAR szFormat[MAX_PATH];
    TCHAR szSchedName[MAX_PATH];
    LPTSTR lpArguments[2];
    BOOL bTranslate;
    int nDays = GetDlgItemInt(hDlg, IDC_SCHEDULE_DAYS, &bTranslate, FALSE);

    if (MLLoadString((nDays == 1) ? IDS_SCHED_FORMAT_DAILY : IDS_SCHED_FORMAT,
        szFormat, ARRAYSIZE(szFormat)))
    {
        TCHAR szTimeFormat[32];
        SYSTEMTIME st;

        DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_SCHEDULE_TIME), &st);

        UpdateTimeFormat(szTimeFormat, ARRAYSIZE(szTimeFormat));
        GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st,
                      szTimeFormat, szTime, ARRAYSIZE(szTime));
        GetDlgItemText(hDlg, IDC_SCHEDULE_DAYS, szDays, ARRAYSIZE(szDays));

        lpArguments[0] = szDays;
        lpArguments[1] = szTime;

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFormat, 0, 0, szSchedName, ARRAYSIZE(szSchedName),
                          (va_list *)&lpArguments[0]))
        {
            SetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName);
        }
    }
}
#endif

BOOL NewSched_ResolveNameConflictHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                        SYNCSCHEDULECOOKIE *pSchedCookie)
{
    BOOL bResult;

    SYSTEMTIME st;
    TCHAR szSchedName[MAX_PATH];

    GetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName, ARRAYSIZE(szSchedName));

    TrimWhiteSpace(szSchedName);

    if (szSchedName[0] != 0)
    {
        bResult = TRUE;

        memset(pTrig, 0, sizeof(TASK_TRIGGER));
        pTrig->cbTriggerSize = sizeof(TASK_TRIGGER);

        GetLocalTime(&st);
        pTrig->wBeginYear = st.wYear;
        pTrig->wBeginMonth = st.wMonth;
        pTrig->wBeginDay = st.wDay;

        DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_SCHEDULE_TIME), &st);
        pTrig->wStartHour = st.wHour;
        pTrig->wStartMinute = st.wMinute;

        pTrig->TriggerType = TASK_TIME_TRIGGER_DAILY;

        BOOL bTranslated;
        pTrig->Type.Daily.DaysInterval = (WORD)GetDlgItemInt(hDlg, IDC_SCHEDULE_DAYS, &bTranslated, FALSE);

        int iConflictResult = HandleScheduleNameConflict(szSchedName,
                                                         pTrig,
                                                         hDlg,
                                                         pSchedCookie);
        switch (iConflictResult)
        {
            case CONFLICT_NONE:
                ASSERT(GUID_NULL == *pSchedCookie);
                break;

            case CONFLICT_RESOLVED_USE_NEW:
                ASSERT(GUID_NULL != *pSchedCookie);
                break;

            case CONFLICT_RESOLVED_USE_OLD:
                ASSERT(GUID_NULL == *pSchedCookie);
                pTrig->cbTriggerSize = 0;
                break;

            case CONFLICT_UNRESOLVED:
                bResult = FALSE;
                break;
        }
    }
    else
    {
        SGMessageBox(hDlg, IDS_EMPTY_SCHEDULE_NAME, MB_OK | MB_ICONWARNING);
        bResult = FALSE;
    }

    return bResult;
}

void NewSched_CreateScheduleHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                   SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;

    if (GUID_NULL == *pSchedCookie)
    {
        //  Create new schedule
        TCHAR szSchedName[MAX_PATH];
        WCHAR wszSchedName[MAX_PATH];

        DWORD dwSyncScheduleFlags =
            (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_AUTOCONNECT) == BST_CHECKED)
                 ? SYNCSCHEDINFO_FLAGS_AUTOCONNECT : 0;

        GetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName, ARRAYSIZE(szSchedName));
        MyStrToOleStrN(wszSchedName, ARRAYSIZE(wszSchedName), szSchedName);
        hr = CreateSchedule(wszSchedName, dwSyncScheduleFlags, pSchedCookie, pTrig, FALSE);

        ASSERT(SUCCEEDED(hr));
    }
    else if (sizeof(TASK_TRIGGER) == pTrig->cbTriggerSize)
    {
        //  Update existing schedule with new task trigger
        hr = UpdateScheduleTrigger(pSchedCookie, pTrig);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        //  Use existing schedule without munging it
    }
}

void NewSched_SetDefaultScheduleName(HWND hDlg)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        ISyncScheduleMgr *pSyncScheduleMgr;

        if (SUCCEEDED(CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                                       IID_ISyncScheduleMgr,
                                       (void **)&pSyncScheduleMgr)))
        {
            SYNCSCHEDULECOOKIE schedCookie;
            ISyncSchedule *pSyncSchedule;

            if (SUCCEEDED(pSyncScheduleMgr->CreateSchedule(L"", 0, &schedCookie, &pSyncSchedule)))
            {
                WCHAR wszSchedName[MAX_PATH];
                DWORD cchSchedName = ARRAYSIZE(wszSchedName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchSchedName, wszSchedName)))
                {
                    TCHAR szSchedName[MAX_PATH];

                    MyOleStrToStrN(szSchedName, ARRAYSIZE(szSchedName), wszSchedName);
                    SetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName);
                }
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }
}

void NewSched_OnInitDialogHelper(HWND hDlg)
{
    SYSTEMTIME st;

    GetLocalTime(&st);

    Edit_LimitText(GetDlgItem(hDlg, IDC_SCHEDULE_NAME), MAX_PATH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS), 2);
    SendMessage(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS_SPIN),
                UDM_SETRANGE, 0, MAKELONG(99, 1));
    SendMessage(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS_SPIN), UDM_SETPOS, 0, 1);

    HWND hwndTimePicker = GetDlgItem(hDlg, IDC_SCHEDULE_TIME);
    TCHAR szTimeFormat[32];

    UpdateTimeFormat(szTimeFormat, ARRAYSIZE(szTimeFormat));
    DateTime_SetSystemtime(hwndTimePicker, GDT_VALID, &st);
    DateTime_SetFormat(hwndTimePicker, szTimeFormat);

    NewSched_SetDefaultScheduleName(hDlg);
}

int KeepSpinNumberInRange(HWND hdlg, int idEdit, int idSpin, int minVal, int maxVal)
{
    BOOL bTranslate;
    int val = GetDlgItemInt(hdlg, idEdit, &bTranslate, FALSE);
    if (!bTranslate || (val  < minVal) || (val > maxVal))
    {
        //  We have a problem, query the spin control
        val = LOWORD(SendDlgItemMessage(hdlg, idSpin, UDM_GETPOS, 0, 0));
        val = max(minVal, min(maxVal, val));
        SetDlgItemInt(hdlg, idEdit, val, FALSE);
    }

    return val;
}


void SetPropSheetFlags(POOEBuf pBuf, BOOL bSet, DWORD dwPropSheetFlags)
{
    if (bSet)
    {
        pBuf->m_dwPropSheetFlags |= dwPropSheetFlags;
    }
    else
    {
        pBuf->m_dwPropSheetFlags &= ~dwPropSheetFlags;
    }
}


HRESULT FindURLProps(LPCTSTR m_URL, PROPVARIANT * pVarInfo)
{
    HRESULT hr;

    hr = IntSiteHelper(m_URL, &c_rgPropRead[PROP_SUBSCRIPTION], pVarInfo, 1, FALSE);
    return hr;
}

HRESULT LoadOOEntryInfo(POOEBuf pBuf, SUBSCRIPTIONCOOKIE *pCookie, DWORD *pdwSize)
{
    HRESULT hr;

    if (!pBuf || !pCookie || !pdwSize)
    {
        TraceMsg(TF_ALWAYS, "Invalid ARG (1/2/3) %x %x", pBuf, pCookie, pdwSize);
        return E_INVALIDARG;
    }

    ISubscriptionItem *psi;
    hr = SubscriptionItemFromCookie(FALSE, pCookie, &psi);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

        hr = psi->GetSubscriptionItemInfo(&sii);

        if (SUCCEEDED(hr))
        {
            ZeroMemory((void *)pBuf, sizeof(OOEBuf));
            pBuf->m_Cookie = *pCookie;

        //  TODO: resolve scheduling goo!

        //    pBuf->groupCookie = pItem->groupCookie;
        //    pBuf->grfTaskTrigger = pItem->TaskData.dwTaskFlags;
        /*    if (pItem->groupCookie == CLSID_NULL)   {
                pBuf->m_Trigger = pItem->TaskTrigger;
                if (pBuf->m_Trigger.cbTriggerSize != sizeof(TASK_TRIGGER))  {
                    ASSERT(0);
                    return E_INVALIDARG;
                }
            } else  {
                pBuf->m_Trigger.cbTriggerSize = 0;  //  Invalid
            }
        */

            pBuf->clsidDest = sii.clsidAgent;

            if (!IsNativeAgent(sii.clsidAgent))
            {
                pBuf->dwFlags = PROP_WEBCRAWL_EXTERNAL;
            }
            else
            {
                pBuf->dwFlags = PROP_WEBCRAWL_ALL;
            }

            hr = ReadProperties(pBuf);
            *pdwSize = BufferSize(pBuf);
        }
        psi->Release();
    }

    return hr;
}

/////////////////////////////////////////////////
//
//  SaveBufferChange
//      newBuf: [in/out]
/////////////////////////////////////////////////

HRESULT SaveBufferChange(POOEBuf newBuf, BOOL bCreate)
{
    HRESULT hr;
    DWORD   dwSize;
    POOEntry pooe;
    LPMYPIDL newPidl;

    ASSERT (newBuf);
    if (newBuf->dwFlags == 0)
        return S_OK;

    dwSize = BufferSize(newBuf);
    newPidl = COfflineFolderEnum::NewPidl(dwSize);
    if (!newPidl)
        return E_OUTOFMEMORY;

    pooe = &(newPidl->ooe);
    CopyToMyPooe(newBuf, pooe);
    newBuf->dwFlags = 0;
    hr = PersistUpdate(pooe, bCreate);
    if (SUCCEEDED(hr))  {
        SUBSCRIPTIONCOOKIE cookie;

        DWORD dwPropSheetFlags = newBuf->m_dwPropSheetFlags; //  Preserve prop sheet flags

	cookie = pooe->m_Cookie;
        hr = LoadWithCookie(URL(pooe), newBuf, &dwSize, &cookie);
	pooe->m_Cookie = cookie;

        newBuf->m_dwPropSheetFlags = dwPropSheetFlags;  //  restore
        newBuf->dwFlags = 0;
        if (hr == S_OK)  {
            COfflineFolderEnum::FreePidl(newPidl);
            newPidl = COfflineFolderEnum::NewPidl(dwSize);
            if (!(newPidl))  {
                return E_OUTOFMEMORY;
            }
            pooe = &(newPidl->ooe);
            CopyToMyPooe(newBuf, pooe);
        }
        _GenerateEvent(SHCNE_UPDATEITEM, (LPITEMIDLIST)newPidl, NULL);
    }
    COfflineFolderEnum::FreePidl(newPidl);
    return hr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IntSiteHelper
//
// pszURL               url to read/write props for
// pPropspec            properties to read or write
// pReadPropvar         where to store or get properties
// uPropVarArraySize    number of properties
// fWrite               read/write flag
//

HRESULT IntSiteHelper(LPCTSTR pszURL, const PROPSPEC *pPropspec,
        PROPVARIANT *pPropvar, UINT uPropVarArraySize, BOOL fWrite)
{
    HRESULT                     hr;
    IUniformResourceLocator *   purl = NULL;
    IPropertySetStorage *       ppropsetstg = NULL; // init to keep compiler happy
    IPropertyStorage *          ppropstg = NULL; // init to keep compiler happy

    hr = SHCoCreateInstance(NULL, &CLSID_InternetShortcut, NULL,
            IID_IUniformResourceLocator, (LPVOID*)&purl);

    if(SUCCEEDED(hr)) {
        hr = purl->SetURL(pszURL, 0);
    }

    if(SUCCEEDED(hr)) {
        hr = purl->QueryInterface(IID_IPropertySetStorage,
                (LPVOID *)&ppropsetstg);
    }

    if(SUCCEEDED(hr)) {
        hr = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
        ppropsetstg->Release();
    }

    if(SUCCEEDED(hr)) {
        if(fWrite) {
            hr = ppropstg->WriteMultiple(uPropVarArraySize, pPropspec,
                            pPropvar, 0);
            ppropstg->Commit(STGC_DEFAULT);
        } else {
            hr = ppropstg->ReadMultiple(uPropVarArraySize, pPropspec,
                            pPropvar);
        }
        ppropstg->Release();
    }

    if(purl)
        purl->Release();

    return hr;
}

// CODE FROM SYNCMGR SOURCES.

//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))
#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")
#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                break;                                  \
            }                                           \
        }
//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------
void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80];
    BOOL  fAmPm = FALSE;
    BOOL  fAmPmPrefixes = FALSE;
    BOOL  fLeadingZero = FALSE;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        StrCpyN(tszTimeFormat, DEFAULT_TIME_FORMAT, cchTimeFormat);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            StrCpyN(tszTimeFormat, TEXT("tt "), cchTimeFormat);
        }

        StrCatBuff(tszTimeFormat, TEXT("h"), cchTimeFormat);

        if (fLeadingZero)
        {
            StrCatBuff(tszTimeFormat, TEXT("h"), cchTimeFormat);
        }
    }
    else
    {
        StrCatBuff(tszTimeFormat, TEXT("H"), cchTimeFormat);

        if (fLeadingZero)
        {
            StrCatBuff(tszTimeFormat, TEXT("H"), cchTimeFormat);
        }
    }

    StrCatBuff(tszTimeFormat, tszScratch, cchTimeFormat); // separator
    StrCatBuff(tszTimeFormat, TEXT("mm"), cchTimeFormat);

    if (fAmPm && !fAmPmPrefixes)
    {
        StrCatBuff(tszTimeFormat, TEXT(" tt"), cchTimeFormat);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\item.cpp ===
#include "private.h"
#include "offl_cpp.h"

#include <mluisupp.h>

// registered clipboard formats
UINT g_cfFileDescriptor = 0;
UINT g_cfFileContents = 0;
UINT g_cfPrefDropEffect = 0;
UINT g_cfURL = 0;

HICON g_webCrawlerIcon = NULL;
HICON g_channelIcon = NULL;
HICON g_desktopIcon = NULL;

#define MAX_ITEM_OPEN 10

//////////////////////////////////////////////////////////////////////////////
// COfflineObjectItem Object
//////////////////////////////////////////////////////////////////////////////

void LoadDefaultIcons()
{
    if (g_webCrawlerIcon == NULL) 
    {
        g_webCrawlerIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SUBSCRIBE));
        g_channelIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CHANNEL));
        g_desktopIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_DESKTOPITEM));
    }
}

COfflineObjectItem::COfflineObjectItem() 
{
    TraceMsg(TF_SUBSFOLDER, "hci - COfflineObjectItem() called.");
    DllAddRef();
    _cRef = 1;
}        

COfflineObjectItem::~COfflineObjectItem()
{
    Assert(_cRef == 0);                 // we should have zero ref count here

    TraceMsg(TF_SUBSFOLDER, "hci - ~COfflineObjectItem() called.");
    
    SAFERELEASE(m_pUIHelper);
    SAFERELEASE(_pOOFolder);

    if (_ppooi)
    {
        for (UINT i = 0; i < _cItems; i++) 
        {
            if (_ppooi[i])
                ILFree((LPITEMIDLIST)_ppooi[i]);
        }
        MemFree((HLOCAL)_ppooi);
    }
    
    DllRelease();
}

HRESULT COfflineObjectItem::Initialize(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl)
{
    _ppooi = (LPMYPIDL *)MemAlloc(LPTR, cidl * sizeof(LPMYPIDL));
    if (!_ppooi)
        return E_OUTOFMEMORY;
    
    _cItems     = cidl;

    for (UINT i = 0; i < cidl; i++)
    {
        // we need to clone the whole array, so if one of them fails, we'll
        // destroy the ones we've already created
        _ppooi[i] = (LPMYPIDL)ILClone(ppidl[i]);
        if (!_ppooi[i]) {
            UINT j = 0;

            for (; j < i; j++)  {
                ILFree((LPITEMIDLIST)_ppooi[j]);
                _ppooi[j] = NULL;
            }

            MemFree((HLOCAL)_ppooi);
            return E_OUTOFMEMORY;
        }
    }   
    
    _pOOFolder = pOOFolder;
    _pOOFolder->AddRef();      // we're going to hold onto this pointer, so
                               // we need to AddRef it.

    //  If there is only one item here, we initialize UI helper.
    if (_cItems == 1)
    {
        ASSERT(!m_pUIHelper);
        POOEntry pooe = &(_ppooi[0]->ooe);

        HRESULT hr = CoInitialize(NULL);

        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(*(&(pooe->clsidDest)), NULL, CLSCTX_INPROC_SERVER, 
                                  IID_IUnknown, (void **)&m_pUIHelper);

            ASSERT(SUCCEEDED(hr));
            ASSERT(m_pUIHelper);

            if (SUCCEEDED(hr))
            {
                ISubscriptionAgentShellExt *psase;
                
                hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszURL[MAX_URL + 1];
                    WCHAR wszName[MAX_NAME + 1];
                    SUBSCRIPTIONCOOKIE alignedCookie;

                    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), URL(pooe));
                    MyStrToOleStrN(wszName, ARRAYSIZE(wszName), NAME(pooe));

                    alignedCookie = pooe->m_Cookie;
                    psase->Initialize(&alignedCookie, wszURL, wszName, (SUBSCRIPTIONTYPE)-1);
                    pooe->m_Cookie = alignedCookie;

                    psase->Release();
                }
            }
            CoUninitialize();
        }
    }
    return S_OK;
}        

HRESULT COfflineObjectItem_CreateInstance
(
    COfflineFolder *pOOFolder,
    UINT cidl, 
    LPCITEMIDLIST *ppidl, 
    REFIID riid, 
    void **ppvOut
)
{
    COfflineObjectItem *pOOItem;
    HRESULT hr;

    *ppvOut = NULL;                 // null the out param

    if (!_ValidateIDListArray(cidl, ppidl))
        return E_FAIL;

    if (((riid == IID_IExtractIconA) || (riid == IID_IExtractIconW)) && (cidl != 1))
        return E_FAIL;      //  What do you need this icon for?

    pOOItem = new COfflineObjectItem;
    if (!pOOItem)
        return E_OUTOFMEMORY;

    hr = pOOItem->Initialize(pOOFolder, cidl, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = pOOItem->QueryInterface(riid, ppvOut);
    }
    pOOItem->Release();

    if (g_cfPrefDropEffect == 0)
    {
        g_cfFileDescriptor = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR); // "FileContents"
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);     // "FileDescriptor"
        g_cfPrefDropEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
    }
    
    return hr;
}

// IUnknown Methods...

HRESULT COfflineObjectItem::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
//    TraceMsg(TF_ALWAYS, TEXT("hci - QueryInterface() called."));
    
    *ppvObj = NULL;     // null the out param
    
    if (iid == IID_IUnknown) {
        TraceMsg(TF_SUBSFOLDER, "  getting IUnknown");
        *ppvObj = (LPVOID)this;
    }
    else if (iid == IID_IContextMenu) {
        TraceMsg(TF_SUBSFOLDER, "   getting IContextMenu");
        *ppvObj = (LPVOID)(IContextMenu *)this;
    }
    else if (iid == IID_IQueryInfo)  {
        TraceMsg(TF_SUBSFOLDER, "  getting IQueryInfo");
        *ppvObj = (LPVOID)(IQueryInfo *)this;
    }
    else if (iid == IID_IDataObject) {
        TraceMsg(TF_SUBSFOLDER, "  getting IDataObject");
        *ppvObj = (LPVOID)(IDataObject *)this;
    }

    else if ((iid == IID_IExtractIconA) || (iid == IID_IExtractIconW)) {
        if (m_pUIHelper)    {
            TraceMsg(TF_SUBSFOLDER, "  getting IExtractIcon from UIHelper");
            if (S_OK == m_pUIHelper->QueryInterface(iid, ppvObj))
                return S_OK;
            else
                TraceMsg(TF_SUBSFOLDER, "  failed to get IExtractIcon from UIHelper");
        } 
        TraceMsg(TF_SUBSFOLDER, "  getting default IExtractIcon");

        *ppvObj = iid == IID_IExtractIconA ? 
            (LPVOID)(IExtractIconA *)this :
            (LPVOID)(IExtractIconW *)this;
    }
    else if (iid == IID_IOfflineObject) {
        TraceMsg(TF_SUBSFOLDER, "  getting IOfflineObject");
        *ppvObj = (LPVOID)this;
    }        
    
    if (*ppvObj) 
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
        return S_OK;
    }

    DBGIID("COfflineObjectItem::QueryInterface() failed", iid);
    return E_NOINTERFACE;
}

ULONG COfflineObjectItem::AddRef()
{
    return ++_cRef;
}

ULONG COfflineObjectItem::Release()
{
    if (0L != --_cRef)
        return _cRef;

    delete this;
    return 0;   
}


// IContextMenu Methods

HRESULT COfflineObjectItem::QueryContextMenu
(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst,
    UINT idCmdLast, 
    UINT uFlags
)
{
    UINT cItems;

    TraceMsg(TF_SUBSFOLDER, "Item::QueryContextMenu() called.");
    
    ///////////////////////////////////////////////////////////
    //  FEATURE: May also need some category specific code here.

#ifdef DEBUG
    int imi = GetMenuItemCount(hmenu);
    while (--imi >= 0)
    {
        MENUITEMINFO mii = {
            sizeof(MENUITEMINFO), MIIM_ID | MIIM_SUBMENU | MIIM_TYPE, 
            0, 0, 0, 0, 0, 0, 0, 0, 0};
        if (GetMenuItemInfo(hmenu, imi, TRUE, &mii)) {
            ;
        }
    }
#endif
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_VERBSONLY, 0, indexMenu, 
                                idCmdFirst - RSVIDM_FIRST, idCmdLast);
    else
    {
        if (_ppooi[0]->ooe.bChannel &&
            SHRestricted2(REST_NoEditingChannels, URL(&(_ppooi[0]->ooe)), 0))
        {
            cItems = MergePopupMenu(&hmenu, POPUP_RESTRICTED_CONTEXT, 0, indexMenu,
                                    idCmdFirst - RSVIDM_FIRST, idCmdLast);
        }
        else
        {
            cItems = MergePopupMenu(&hmenu, POPUP_OFFLINE_CONTEXT, 0, indexMenu,
                                    idCmdFirst - RSVIDM_FIRST, idCmdLast);
        }
        if (_cItems > 1)
            EnableMenuItem(hmenu, RSVIDM_PROPERTIES + idCmdFirst - RSVIDM_FIRST, MF_BYCOMMAND | MF_GRAYED);
    }

    if (SHRestricted2(REST_NoManualUpdates, URL(&(_ppooi[0]->ooe)), 0))
        EnableMenuItem(hmenu, RSVIDM_UPDATE + idCmdFirst - RSVIDM_FIRST, MF_BYCOMMAND | MF_GRAYED); 
    
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}


STDMETHODIMP COfflineObjectItem::InvokeCommand
(
    LPCMINVOKECOMMANDINFO pici
)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    CLSID   * pClsid = NULL;
    int     updateCount = 0;

    TraceMsg(TF_SUBSFOLDER, "hci - cm - InvokeCommand() called.");

    if (idCmd == RSVIDM_DELETE)
    {
        BOOL fRet = ConfirmDelete(pici->hwnd, _cItems, _ppooi);
        if (!fRet)
            return S_FALSE;
    } else if (idCmd == RSVIDM_UPDATE)  {
        pClsid = (CLSID *)MemAlloc(LPTR, sizeof(CLSID) * _cItems);
        if (!pClsid)
            return E_OUTOFMEMORY;
    }
        
    for (i = 0; i < _cItems; i++)
    {
        if (_ppooi[i]) 
        {
            SUBSCRIPTIONTYPE    subType; 
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                subType = GetItemCategory(&(_ppooi[i]->ooe)); 
                switch (subType)   {
                case SUBSTYPE_URL:
                case SUBSTYPE_CHANNEL:
                case SUBSTYPE_DESKTOPURL:
                case SUBSTYPE_DESKTOPCHANNEL:
                    hres = _LaunchApp(pici->hwnd,URL(&(_ppooi[i]->ooe))); 
                    break;
                default:
                    break;
                }
                break;

            case RSVIDM_COPY:
                OleSetClipboard((IDataObject *)this);
                goto Done;

            case RSVIDM_DELETE:
                hres = DoDeleteSubscription(&(_ppooi[i]->ooe));
                if (SUCCEEDED(hres))
                    _GenerateEvent(SHCNE_DELETE,(LPITEMIDLIST)(_ppooi[i]),NULL);
                break;

            case RSVIDM_PROPERTIES: 
                { 
                    POOEntry pooe = &(_ppooi[i]->ooe);
                    OOEBuf ooeBuf;
                    int iRet;

                    pooe->dwFlags = 0;
                    CopyToOOEBuf(pooe, &ooeBuf);

                    subType = GetItemCategory(&(_ppooi[i]->ooe)); 
                    switch (subType)   {
                    case SUBSTYPE_URL:
                    case SUBSTYPE_CHANNEL:
                    case SUBSTYPE_DESKTOPCHANNEL:
                    case SUBSTYPE_DESKTOPURL:
                    case SUBSTYPE_EXTERNAL:
                        iRet = _CreatePropSheet(pici->hwnd,&ooeBuf);
                        break;
                    default:
                        goto Done;
                    }

                    if (iRet <= 0) 
                        goto Done;

                    LPMYPIDL newPidl = NULL;
                    hres = LoadSubscription(ooeBuf.m_URL, &newPidl);

                    if (FAILED(hres))   {
                        ASSERT(0);
                    } else  {
                        ILFree((LPITEMIDLIST)_ppooi[i]);
                        _ppooi[i] = newPidl;
                    }
                }
                goto Done;

            case RSVIDM_UPDATE: 
                {
                    POOEntry pooe = &(_ppooi[i]->ooe);
                    pClsid[updateCount] = pooe->m_Cookie;
                    updateCount ++;
                } 
                break;

            default:
                hres = E_FAIL;
                break;
            }
        }
    }

    if (idCmd == RSVIDM_UPDATE) {
        hres = SendUpdateRequests(pici->hwnd, pClsid, updateCount);
        MemFree(pClsid);
    }
Done:
    return hres;
}


STDMETHODIMP COfflineObjectItem::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

//    TraceMsg(TF_ALWAYS, TEXT("OOI/IContextMenu - GetCommandString() called."));

    if (uFlags == GCS_VERBA)
    {
        LPCSTR pszSrc = NULL;

        switch(idCmd)
        {
            case RSVIDM_OPEN:
                pszSrc = c_szOpen;
                break;

            case RSVIDM_COPY:
                pszSrc = c_szCopy;
                break;

            case RSVIDM_DELETE:
                pszSrc = c_szDelete;
                break;

            case RSVIDM_PROPERTIES:
                pszSrc = c_szProperties;
                break;
        }
        
        if (pszSrc)
        {
            lstrcpynA(pszName, pszSrc, cchMax);
            hres = NOERROR;
        }
    }
    
    else if (uFlags == GCS_HELPTEXTA)
    {
        switch(idCmd)
        {
            case RSVIDM_OPEN:
            case RSVIDM_RENAME:
            case RSVIDM_UPDATE:
            case RSVIDM_COPY:
            case RSVIDM_DELETE:
            case RSVIDM_PROPERTIES:
                MLLoadStringA((UINT)(IDS_SB_FIRST+idCmd), pszName, cchMax);
                hres = NOERROR;
                break;

            default:
                break;
        }
    }
    return hres;
}

// IQueryInfo Method
HRESULT COfflineObjectItem::GetInfoTip(DWORD dwFlags, WCHAR ** ppwsz)
{
    *ppwsz = NULL;
    int clen = lstrlen(STATUS(&(_ppooi[0]->ooe)))+1;
    *ppwsz = (LPOLESTR)SHAlloc(clen*sizeof(WCHAR)) ;
    if (!(*ppwsz))  {
        return E_OUTOFMEMORY;
    }
    MyStrToOleStrN(*ppwsz, clen, STATUS(&(_ppooi[0]->ooe)));
    return S_OK;
}

HRESULT COfflineObjectItem::GetInfoFlags(DWORD *pdwFlags)
{
    return E_NOTIMPL;
}

// IDataObject Methods...

HRESULT COfflineObjectItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfPrefDropEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileDescriptor) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptor(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileContents) && (pFEIn->tymed & TYMED_ISTREAM))
        hres = _CreateFileContents(pSTM, pFEIn->lindex);

    else if ((pFEIn->cfFormat == g_cfURL || pFEIn->cfFormat == CF_TEXT) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateURL(pSTM);
  
    else
        hres = DATA_E_FORMATETC;
    
    return hres;

}

HRESULT COfflineObjectItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - GetDataHere() called."));
    return E_NOTIMPL;
}

HRESULT COfflineObjectItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

#endif

    if (pFEIn->cfFormat == g_cfPrefDropEffect   ||
        pFEIn->cfFormat == g_cfFileDescriptor   ||
        pFEIn->cfFormat == g_cfFileContents     ||
        pFEIn->cfFormat == g_cfURL              ||
        pFEIn->cfFormat == CF_TEXT
       )  {
#ifdef DEBUG
        TraceMsg(TF_ALWAYS, "\t%s format supported.", szName);
#endif
        return NOERROR;
    }
    
    return S_FALSE;
}

HRESULT COfflineObjectItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - GetCanonicalFormatEtc() called."));
    return DATA_S_SAMEFORMATETC;
}

HRESULT COfflineObjectItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - SetData() called.");
    return E_NOTIMPL;
}

HRESULT COfflineObjectItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC objectfmte[5] = {
        {(CLIPFORMAT) g_cfFileDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) g_cfFileContents,   NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
        {(CLIPFORMAT) g_cfPrefDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) g_cfURL,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) CF_TEXT,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
    };
    HRESULT hres;

    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - EnumFormatEtc() called.");

    hres = SHCreateStdEnumFmtEtc(ARRAYSIZE(objectfmte), objectfmte, ppEnum);
    TraceMsg(TF_SUBSFOLDER, "\t- EnumFormatEtc() return %d.", hres);
    return  hres;
}

HRESULT COfflineObjectItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
    LPDWORD pdwConnection)
{
    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - DAdvise() called.");
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT COfflineObjectItem::DUnadvise(DWORD dwConnection)
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("COfflineObjectItem - DUnAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT COfflineObjectItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - EnumAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

    
HRESULT COfflineObjectItem::_CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;

    TraceMsg(TF_SUBSFOLDER, "OOI/CreatePrefDropEffect");
    pSTM->hGlobal = MemAlloc(LPTR, sizeof(DWORD));

    //  FEATURE: Need category specific code.

    DWORD prefEffect = DROPEFFECT_COPY;

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = prefEffect;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}

HRESULT COfflineObjectItem::_CreateURL(LPSTGMEDIUM pSTM)
{
    LPTSTR pszURL = URL(&(((LPMYPIDL)_ppooi[0])->ooe));    
    int cchAlloc = (lstrlen(pszURL) + 1) * 2;
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = MemAlloc(LPTR, cchAlloc);

    if (pSTM->hGlobal)
    {
        SHTCharToAnsi(pszURL, (LPSTR)pSTM->hGlobal, cchAlloc);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT COfflineObjectItem::_CreateFileContents(LPSTGMEDIUM pSTM, LONG lindex)
{
    HRESULT hr;
    LONG iIndex;
    
    // make sure the index is in a valid range.
    if (lindex == -1)
    {
        if (_cItems == 1)
            lindex = 0;
        else
            return E_FAIL;
    }

    Assert((unsigned)lindex < _cItems);
    Assert(lindex >= 0);

    iIndex = lindex;
    
    pSTM->tymed = TYMED_ISTREAM;
    pSTM->pUnkForRelease = NULL;
    
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER li = {0L, 0L};
        IUniformResourceLocator *purl;

        hr = SHCoCreateInstance(NULL, &CLSID_InternetShortcut, NULL,
            IID_IUniformResourceLocator, (void **)&purl);
        if (SUCCEEDED(hr))
        {
            hr = purl->SetURL(URL(&(_ppooi[iIndex]->ooe)), TRUE);
            if (SUCCEEDED(hr))
            {
                IPersistStream *pps;
                hr = purl->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
                if (SUCCEEDED(hr))
                {
                    hr = pps->Save(pSTM->pstm, TRUE);
                    pps->Release();
                }
            }
            purl->Release();
        }               
        pSTM->pstm->Seek(li, STREAM_SEEK_SET, NULL);
    }

    return hr;
}

HRESULT COfflineObjectItem::_CreateFileDescriptor(LPSTGMEDIUM pSTM)
{
    FILEGROUPDESCRIPTOR *pfgd;
    
    // render the file descriptor
    // we only allocate for _cItems-1 file descriptors because the filegroup
    // descriptor has already allocated space for 1.
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pfgd = (FILEGROUPDESCRIPTOR *)MemAlloc(LPTR, sizeof(FILEGROUPDESCRIPTOR) + (_cItems-1) * sizeof(FILEDESCRIPTOR));
    if (pfgd == NULL)
    {
        TraceMsg(TF_ALWAYS, "ooi -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    pfgd->cItems = _cItems;

    for (UINT i = 0; i < _cItems; i++)
    {
        FILEDESCRIPTOR *pfd = &(pfgd->fgd[i]);
        StrCpyN(pfd->cFileName, NAME(&(_ppooi[i]->ooe)), ARRAYSIZE(pfd->cFileName));
        int len = lstrlen(pfd->cFileName);
        StrCpyN(pfd->cFileName + len, TEXT(".URL"), ARRAYSIZE(pfd->cFileName) - len);
    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}

// IExtractIconA members
HRESULT COfflineObjectItem::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return IExtractIcon_GetIconLocationThunk((IExtractIconW *)this, uFlags, szIconFile, cchMax, piIndex, pwFlags);
}

HRESULT COfflineObjectItem::Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return IExtractIcon_ExtractThunk((IExtractIconW *)this, pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}

HRESULT COfflineObjectItem::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    ASSERT (piIndex && pwFlags);

    StrCpyN(szIconFile, TEXT("not used"), cchMax);

    SUBSCRIPTIONTYPE    subType = GetItemCategory(&(_ppooi[0]->ooe)); 
    switch (subType)   {
    case SUBSTYPE_URL:
        *piIndex = 10;
         break;
    case SUBSTYPE_CHANNEL:
        *piIndex = 11;
        break;
    case SUBSTYPE_DESKTOPCHANNEL:
    case SUBSTYPE_DESKTOPURL:
        *piIndex = 12;
        break;
    default:
        *piIndex = 13;   //  Unknown!
        break;
    }
    *pwFlags |= GIL_NOTFILENAME | GIL_PERINSTANCE | GIL_DONTCACHE;

    return NOERROR;
}

HRESULT COfflineObjectItem::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    * phiconLarge = * phiconSmall = NULL;
    
    LoadDefaultIcons();

    SUBSCRIPTIONTYPE    subType = GetItemCategory(&(_ppooi[0]->ooe)); 
    switch (subType)   {
    case SUBSTYPE_URL:
        * phiconLarge = * phiconSmall = g_webCrawlerIcon;
        break;
    case SUBSTYPE_CHANNEL:
        * phiconLarge = * phiconSmall = g_channelIcon;
        break;
    case SUBSTYPE_DESKTOPURL:
    case SUBSTYPE_DESKTOPCHANNEL:
        * phiconLarge = * phiconSmall = g_desktopIcon;
        break;
    default:
        break;
    }
    if (!(*phiconLarge))   {
        if (_ppooi[0]->ooe.bDesktop)
            * phiconLarge = * phiconSmall = g_desktopIcon;
        else if (_ppooi[0]->ooe.bChannel)
            * phiconLarge = * phiconSmall = g_channelIcon;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\folder.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include <htmlhelp.h>
#include <shdocvw.h>

#include <mluisupp.h>

// {F5175861-2688-11d0-9C5E-00AA00A45957}
const GUID CLSID_OfflineFolder = 
{ 0xf5175861, 0x2688, 0x11d0, { 0x9c, 0x5e, 0x0, 0xaa, 0x0, 0xa4, 0x59, 0x57 } };

// {F5175860-2688-11d0-9C5E-00AA00A45957}
const GUID IID_IOfflineObject = 
{ 0xf5175860, 0x2688, 0x11d0, { 0x9c, 0x5e, 0x0, 0xaa, 0x0, 0xa4, 0x59, 0x57 } };

// Column definition for the Cache Folder DefView
    
ColInfoType s_AllItems_cols[] = {
        {ICOLC_SHORTNAME,   IDS_NAME_COL,           20, LVCFMT_LEFT},
        {ICOLC_LAST,        IDS_LAST_COL,           14, LVCFMT_LEFT},
        {ICOLC_STATUS,      IDS_STATUS_COL,         14, LVCFMT_LEFT},
        {ICOLC_URL,         IDS_URL_COL,            20, LVCFMT_LEFT}, 
        {ICOLC_ACTUALSIZE,  IDS_SIZE_COL,           10, LVCFMT_LEFT}};

ColInfoType * colInfo = s_AllItems_cols;

LPMYPIDL _CreateFolderPidl(IMalloc *pmalloc, DWORD dwSize);

HRESULT OfflineFolderView_InitMenuPopup(HWND hwnd, UINT idCmdFirst, int nIndex, HMENU hMenu)
{
    UINT platform = WhichPlatform();

    if (platform != PLATFORM_INTEGRATED)    {
        MENUITEMINFO    mInfo = {0};
        mInfo.cbSize = sizeof(MENUITEMINFO);
        mInfo.fMask = MIIM_STATE;
        if (IsGlobalOffline())  {
            mInfo.fState = MFS_CHECKED;
        } else  {
            mInfo.fState = MFS_UNCHECKED;
        }
        SetMenuItemInfo(hMenu, RSVIDM_WORKOFFLINE + idCmdFirst, FALSE, &mInfo);
    }

    return NOERROR;
}

HRESULT OfflineFolderView_MergeMenu(LPQCMINFO pqcm)
{
    HMENU hmenu = NULL;
    UINT  platform = WhichPlatform();
    
    if (platform == PLATFORM_INTEGRATED) {
        hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_OFFLINE_TOP));
    } else  {
        hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_OFFLINE_BRONLY));
    }

    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast, TRUE);
        DestroyMenu(hmenu);
    }

    return S_OK;
}

extern HRESULT CancelAllDownloads();

HRESULT OfflineFolderView_Command(HWND hwnd, UINT uID)
{
    switch (uID) {
    case RSVIDM_SORTBYNAME:
        ShellFolderView_ReArrange(hwnd, ICOLC_SHORTNAME);
        break;
    case RSVIDM_UPDATEALL:
        SendUpdateRequests(hwnd, NULL, 0);
        break;
    case RSVIDM_WORKOFFLINE:
        SetGlobalOffline(!IsGlobalOffline());
        break;
    case RSVIDM_HELP:
        SHHtmlHelpOnDemandWrap(hwnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("subs_upd.htm"), ML_CROSSCODEPAGE);
        break;

    case RSVIDM_UPDATE:
        {
            LPMYPIDL *  pidlsSel = NULL;
            UINT    count = 0;

            count = (UINT) ShellFolderView_GetSelectedObjects
                                (hwnd, (LPITEMIDLIST*) &pidlsSel);

            if ((!pidlsSel) || !count)
                break;

            CLSID   * cookies = (CLSID *)MemAlloc(LPTR, count * sizeof(CLSID));
            UINT    validCount = 0;

            if (cookies)
            {
                for (UINT i = 0; i < count; i ++)   {
                    if (IS_VALID_MYPIDL(pidlsSel[i]))
                        cookies[validCount++] = pidlsSel[i]->ooe.m_Cookie;
                }

                if (validCount)
                    SendUpdateRequests(hwnd, cookies, validCount);
            
                MemFree(cookies);
                cookies = NULL;
            }
            break;
        }
    default:
        return E_FAIL;
    }
    return NOERROR;
}

//  We should make this a generic function for all types of items, even
//  for the third party items they should support these properties.

HRESULT Generic_GetDetails(PDETAILSINFO pdi, UINT iColumn)
{
    LPMYPIDL pooi = (LPMYPIDL)pdi->pidl;
    POOEntry pooe = NULL;
    TCHAR timeSTR[128];

    pdi->str.uType = STRRET_CSTR;
    pdi->str.cStr[0] = '\0';

    pooe = &(pooi->ooe);
    switch (iColumn)
    {
    case ICOLC_SHORTNAME:
        SHTCharToAnsi(NAME(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_URL:
        SHTCharToAnsi(URL(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_LAST:
        DATE2DateTimeString(pooe->m_LastUpdated, timeSTR, ARRAYSIZE(timeSTR));
        SHTCharToAnsi(timeSTR, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_STATUS:
        SHTCharToAnsi(STATUS(pooe), pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    case ICOLC_ACTUALSIZE:
        StrFormatByteSizeA(pooe->m_ActualSize * 1024, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;
    }

    return S_OK;
}

HRESULT OfflineFolderView_OnGetDetailsOf(HWND hwnd, UINT iColumn, PDETAILSINFO pdi)
{
    LPMYPIDL pooi = (LPMYPIDL)pdi->pidl;

    if (iColumn > ICOLC_ACTUALSIZE)
        return E_NOTIMPL;

    if (!pooi)
    {
        pdi->str.uType = STRRET_CSTR;
        pdi->str.cStr[0] = '\0';
        MLLoadStringA(colInfo[iColumn].ids, pdi->str.cStr, sizeof(pdi->str.cStr));
        pdi->fmt = colInfo[iColumn].iFmt;
        pdi->cxChar = colInfo[iColumn].cchCol;
        return S_OK;
    }

    UINT    colId = colInfo[iColumn].iCol;
    return Generic_GetDetails(pdi, colId);
}

HRESULT OfflineFolderView_OnColumnClick(HWND hwnd, UINT iColumn)
{
    ShellFolderView_ReArrange(hwnd, colInfo[iColumn].iCol);
    return NOERROR;
}

const TBBUTTON c_tbOffline[] = {
    { 0, RSVIDM_UPDATE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 1, RSVIDM_UPDATEALL,    TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 0,  0,                  TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };

HRESULT OfflineFolderView_OnGetButtons(HWND hwnd, UINT idCmdFirst, LPTBBUTTON ptButton)
{
    UINT i;
    LONG_PTR iBtnOffset;
    IShellBrowser * psb = FileCabinet_GetIShellBrowser(hwnd);
    TBADDBITMAP ab;

    // add the toolbar button bitmap, get it's offset
    ab.hInst =g_hInst;
    ab.nID   = IDB_TB_SMALL;        // std bitmaps
    psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 2, (LPARAM)&ab, &iBtnOffset);

    for (i = 0; i < ARRAYSIZE(c_tbOffline); i++)
    {
        ptButton[i] = c_tbOffline[i];

        if (!(c_tbOffline[i].fsStyle & TBSTYLE_SEP))
        {
            ptButton[i].idCommand += idCmdFirst;
            ptButton[i].iBitmap += (int)iBtnOffset;
        }
    }

    return S_OK;
}

HRESULT OfflineFolderView_OnGetButtonInfo(TBINFO * ptbInfo)
{
    ptbInfo->uFlags = TBIF_PREPEND;
    ptbInfo->cbuttons = ARRAYSIZE(c_tbOffline);
    return S_OK;
}

HRESULT OfflineFolderView_DidDragDrop(HWND hwnd,IDataObject *pdo,DWORD dwEffect)
{
    if ((dwEffect & (DROPEFFECT_MOVE |DROPEFFECT_COPY)) == DROPEFFECT_MOVE)
    {
        COfflineObjectItem *pOOItem;
        
        if (SUCCEEDED(pdo->QueryInterface(IID_IOfflineObject, (void **)&pOOItem)))
        {
            BOOL fDel = ConfirmDelete(hwnd, pOOItem->_cItems, pOOItem->_ppooi);
            if (!fDel)  {
                pOOItem->Release();
                return S_FALSE;
            }

            for (UINT i = 0; i < pOOItem->_cItems; i++)
            {
                if (SUCCEEDED(DoDeleteSubscription(&(pOOItem->_ppooi[i]->ooe)))) {
                    _GenerateEvent(SHCNE_DELETE, 
                            (LPITEMIDLIST)pOOItem->_ppooi[i], 
                            NULL);
                }
            }

            pOOItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CALLBACK OfflineFolderView_ViewCallback(
     IShellView *psvOuter,
     IShellFolder *psf,
     HWND hwnd,
     UINT uMsg,
     WPARAM wParam,
     LPARAM lParam)
{
    HRESULT hres = NOERROR;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    case DVM_GETTOOLTIPTEXT:
    {
        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        if (g_fIsWinNT)   
        {
            WCHAR * pszBuf = (WCHAR *)lParam;
            MLLoadStringW(id + IDS_SB_FIRST, pszBuf, cchBuf);
        }
        else  
        {
            CHAR * pszBuf = (CHAR *)lParam;
            MLLoadStringA(id + IDS_SB_FIRST, pszBuf, cchBuf);
        }
    }   
        break;

    case DVM_DIDDRAGDROP:
        hres = OfflineFolderView_DidDragDrop(hwnd,(IDataObject *)lParam,(DWORD)wParam);
        break;
      
    case DVM_INITMENUPOPUP:
        hres = OfflineFolderView_InitMenuPopup(hwnd, LOWORD(wParam), HIWORD(wParam), (HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        OfflineFolderView_Command(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        hres = OfflineFolderView_OnColumnClick(hwnd, (UINT)wParam);
        break;

    case DVM_GETDETAILSOF:
        hres = OfflineFolderView_OnGetDetailsOf(hwnd, (UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_MERGEMENU:
        hres = OfflineFolderView_MergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case DVM_GETBUTTONINFO:
        hres = OfflineFolderView_OnGetButtonInfo((TBINFO *)lParam);
        break;

    case DVM_GETBUTTONS:
        hres = OfflineFolderView_OnGetButtons(hwnd, LOWORD(wParam), (TBBUTTON *)lParam);
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}

HRESULT OfflineFolderView_CreateInstance(COfflineFolder *pOOFolder, LPCITEMIDLIST pidl, void **ppvOut)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pOOFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pidl;
    csfv.lEvents = SHCNE_DELETE | SHCNE_CREATE | SHCNE_RENAMEITEM | SHCNE_UPDATEITEM | SHCNE_UPDATEDIR;
    csfv.pfnCallback = OfflineFolderView_ViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppvOut); // &this->psv);
}



//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////


COfflineFolderEnum::COfflineFolderEnum(DWORD grfFlags)
{
    TraceMsg(TF_SUBSFOLDER, "hcfe - COfflineFolderEnum() called");
    
    m_cRef = 1;
    DllAddRef();

    m_grfFlags = grfFlags;
}

IMalloc *COfflineFolderEnum::s_pMalloc = NULL;

void COfflineFolderEnum::EnsureMalloc()
{
    if (NULL == s_pMalloc)
    {
        SHGetMalloc(&s_pMalloc);
    }

    ASSERT(NULL != s_pMalloc);
}


COfflineFolderEnum::~COfflineFolderEnum()
{
    ASSERT(m_cRef == 0);         // we should always have a zero ref count here

    SAFERELEASE(m_pFolder);
    SAFEDELETE(m_pCookies);

    TraceMsg(TF_SUBSFOLDER, "hcfe - ~COfflineFolderEnum() called.");
    DllRelease();
}

HRESULT COfflineFolderEnum::Initialize(COfflineFolder *pFolder)
{
    HRESULT hr = S_OK;

    ASSERT(pFolder);
    
    if (NULL != pFolder)
    {
        m_pFolder = pFolder;
        m_pFolder->AddRef();

        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            ISubscriptionMgr2 *pSubsMgr2;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_ISubscriptionMgr2, (void **)&pSubsMgr2);
            if (SUCCEEDED(hr))
            {
                IEnumSubscription *pes;

                hr = pSubsMgr2->EnumSubscriptions(0, &pes);
                if (SUCCEEDED(hr))
                {
                    pes->GetCount(&m_nCount);

                    if (m_nCount > 0)
                    {
                        m_pCookies = new SUBSCRIPTIONCOOKIE[m_nCount];

                        if (NULL != m_pCookies)
                        {
                            hr = pes->Next(m_nCount, m_pCookies, &m_nCount);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    pes->Release();
                }
                pSubsMgr2->Release();
            }

            CoUninitialize();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum_CreateInstance(DWORD grfFlags, COfflineFolder *pFolder, 
                                          LPENUMIDLIST *ppeidl)
{
    HRESULT hr;

    *ppeidl = NULL;

    COfflineFolderEnum *pOOFE = new COfflineFolderEnum(grfFlags);
    
    if (NULL != pOOFE)
    {
        hr = pOOFE->Initialize(pFolder);

        if (SUCCEEDED(hr))
        {
            *ppeidl = pOOFE;
        }
        else
        {
            pOOFE->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}


//////////////////////////////////
//
// IUnknown Methods...
//

HRESULT COfflineFolderEnum::QueryInterface(REFIID iid,void **ppv)
{
//    TraceMsg(TF_SUBSFOLDER, "COfflineFolderEnum - QI called.");
    
    if ((iid == IID_IEnumIDList) || (iid == IID_IUnknown))
    {
        *ppv = (IEnumIDList *)this;
        AddRef();
        return S_OK;
    }
    
    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG COfflineFolderEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG COfflineFolderEnum::Release(void)
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

LPMYPIDL COfflineFolderEnum::NewPidl(DWORD dwSize)
{
    LPMYPIDL pidl;

//  TraceMsg(TF_MEMORY, "NewPidl called");

    EnsureMalloc();

    pidl = _CreateFolderPidl(s_pMalloc, dwSize);

//  TraceMsg(TF_MEMORY, "\tNewPidl returned with 0x%x", pidl);

    return pidl;
}

void COfflineFolderEnum::FreePidl(LPMYPIDL pidl)
{
    ASSERT(NULL != pidl);

//  TraceMsg(TF_MEMORY, "FreePidl on (0x%x) called", pidl);

    EnsureMalloc();

    s_pMalloc->Free(pidl);
}

// IEnumIDList Methods 

HRESULT COfflineFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG nCopied;
    DWORD dwBuffSize;
    OOEBuf ooeBuf;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    memset(&ooeBuf, 0, sizeof(ooeBuf));

    for (nCopied = 0; (S_OK == hr) && (m_nCurrent < m_nCount) && (nCopied < celt); 
         m_nCurrent++, nCopied++)
    {
        rgelt[nCopied] = NULL;
        hr = LoadOOEntryInfo(&ooeBuf, &m_pCookies[m_nCurrent], &dwBuffSize);

        if (SUCCEEDED(hr))
        {
            if (IsNativeAgent(ooeBuf.clsidDest))
            {
                CLSID   cookie;
                HRESULT hrTmp = ReadCookieFromInetDB(ooeBuf.m_URL, &cookie);
                if (S_OK != hrTmp)
                {
                    hrTmp = WriteCookieToInetDB(ooeBuf.m_URL,&(ooeBuf.m_Cookie), FALSE);
                    ASSERT(SUCCEEDED(hrTmp));
                }
            }

            LPMYPIDL pooi = NewPidl(dwBuffSize);
            if (pooi)
            {
                CopyToMyPooe(&ooeBuf, &(pooi->ooe));  //  Always succeeds!
                rgelt[nCopied] = (LPITEMIDLIST)pooi;
            }
            else 
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = (celt == nCopied) ? S_OK : S_FALSE;
    }
    else
    {
        for (ULONG i = 0; i < nCopied; i++)
        {
            FreePidl((LPMYPIDL)rgelt[i]);
        }
    }

    if (NULL != pceltFetched)
    {
        *pceltFetched = SUCCEEDED(hr) ? nCopied : 0;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum::Skip(ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

HRESULT COfflineFolderEnum::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolder Object
//
//////////////////////////////////////////////////////////////////////////////

COfflineFolder::COfflineFolder(void) 
{
    TraceMsg(TF_SUBSFOLDER, "Folder - COfflineFolder() called.");
    _cRef = 1;
    viewMode = 0;
    colInfo = s_AllItems_cols;
    DllAddRef();
}       

COfflineFolder::~COfflineFolder()
{
    Assert(_cRef == 0);                 // should always have zero
    TraceMsg(TF_SUBSFOLDER, "Folder - ~COfflineFolder() called.");

    if (_pidl)
        ILFree(_pidl);
        
    DllRelease();
}    

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT COfflineFolder::QueryInterface(REFIID iid, void **ppvObj)
{
    *ppvObj = NULL;     // null the out param
    
    if (iid == IID_IUnknown) {
         *ppvObj = (void *)this;
    }
    else if (iid == IID_IShellFolder) {
         *ppvObj = (void *)(IShellFolder *)this;
    }
    else if ((iid == IID_IPersistFolder) || (iid == IID_IPersist) || (iid == IID_IPersistFolder2)) {
         *ppvObj = (void *)(IPersistFolder *)this;
    }
    else if (iid == IID_IContextMenu)
    {
         *ppvObj = (void *)(IContextMenu *)this;
    }
    else if (iid == IID_IShellView)
    {
         return OfflineFolderView_CreateInstance(this, _pidl, ppvObj);
    }
    else if (iid == IID_IOfflineObject)
    {
         *ppvObj = (void *)this;
    }
    else if (iid == IID_IDropTarget)
    {
        // APPCOMPAT: Implementation of IDropTarget didn't follow the COM rules.
        //  We create following object by aggregattion but QI on it for IUnknown
        //  won't get us ptr THIS.
        COfflineDropTarget * podt = new COfflineDropTarget(GetDesktopWindow());
        if (podt)
        {
            HRESULT hr = podt->QueryInterface(iid, ppvObj);
            podt->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }     
    }

    if (*ppvObj) 
    {
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG COfflineFolder::AddRef()
{
    return ++_cRef;
}

ULONG COfflineFolder::Release()
{
    if (0L != --_cRef)
        return _cRef;

    delete this;
    return 0;   
}

//////////////////////////////////
//
// IShellFolder methods...
//
HRESULT COfflineFolder::ParseDisplayName(HWND hwndOwner, LPBC pbcReserved,
                        LPOLESTR lpszDisplayName, ULONG *pchEaten,
                        LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - ParseDisplayName.");
    *ppidl = NULL;
    return E_FAIL;
}


HRESULT COfflineFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags,
                        LPENUMIDLIST *ppenumIDList)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - EnumObjects.");
    return COfflineFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}


HRESULT COfflineFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                        REFIID riid, void **ppvOut)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - BindToObject.");
    *ppvOut = NULL;
    return E_FAIL;
}

HRESULT COfflineFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                        REFIID riid, void **ppvObj)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - BindToStorage.");
    *ppvObj = NULL;
    return E_NOTIMPL;
}

HRESULT COfflineFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - CompareIDs(%d).", lParam);

    if (!IS_VALID_MYPIDL(pidl1) || !IS_VALID_MYPIDL(pidl2))
        return E_FAIL;

    switch (lParam) {
        case ICOLC_SHORTNAME:
            iRet = _CompareShortName((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_URL:
            iRet = _CompareURL((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_STATUS:
            iRet = _CompareStatus((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_LAST:
            iRet = _CompareLastUpdate((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_ACTUALSIZE:
            iRet = (((LPMYPIDL)pidl1)->ooe.m_ActualSize - ((LPMYPIDL)pidl2)->ooe.m_ActualSize);
            break;
        default:
            iRet = -1;
            break;
    }
    return ResultFromShort((SHORT)iRet);
}


HRESULT COfflineFolder::CreateViewObject(HWND hwndOwner, REFIID riid, void **ppvOut)
{
    HRESULT hres;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - CreateViewObject() called.");

    if (riid == IID_IShellView)
    {
        hres = OfflineFolderView_CreateInstance(this, _pidl, ppvOut);
    }
    else if (riid == IID_IContextMenu)
    {
        COfflineFolder * pof = new COfflineFolder();

        if (pof)
        {
            hres = pof->Initialize(this->_pidl);
            if (SUCCEEDED(hres))
                hres = pof->QueryInterface(riid, ppvOut);
            pof->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IDropTarget)
    {
        COfflineDropTarget * podt = new COfflineDropTarget(hwndOwner);

        if (podt)
        {
            hres = podt->QueryInterface(riid, ppvOut);
            podt->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellDetails)
    {
        COfflineDetails *pod = new COfflineDetails(hwndOwner);
        if (NULL != pod)
        {
            hres = pod->QueryInterface(IID_IShellDetails, ppvOut);
            pod->Release();
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        DBGIID("COfflineFolder::CreateViewObject() failed", riid);
        *ppvOut = NULL;         // null the out param
        hres = E_NOINTERFACE;
    }
    
    return hres;    
}

HRESULT COfflineFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                        ULONG * prgfInOut)
{
    // Should we initialize this for each item in here?  In other words,
    // if cidl > 1, then we should initialize each entry in the prgInOut array
    Assert( cidl == 1 );
    
    UINT    attr = SFGAO_CANCOPY | SFGAO_CANDELETE | SFGAO_CANRENAME |
                    SFGAO_HASPROPSHEET;
    *prgfInOut = attr;
    
    return NOERROR;
}

HRESULT COfflineFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppvOut)
{
    HRESULT hres;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - GetUIObjectOf.");
    if ((riid == IID_IContextMenu) || (riid == IID_IDataObject) || 
        (riid == IID_IExtractIcon) || (riid == IID_IQueryInfo))
    {
        hres = COfflineObjectItem_CreateInstance(this, cidl, apidl, riid, ppvOut);
    }
    else if (riid == IID_IDropTarget)
    {
        hres = CreateViewObject(hwndOwner, IID_IDropTarget, ppvOut);
    }
    else 
    {
        *ppvOut = NULL;
        hres = E_FAIL;
        DBGIID("Unsupported interface in COfflineFolder::GetUIObjectOf()", riid);
    }
    return hres;    
}

HRESULT COfflineFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
//    TraceMsg(TF_SUBSFOLDER, "Folde:ISF - GetDisplayNameOf.");
    
    if (!IS_VALID_MYPIDL(pidl))
    {
        lpName->uType = 0;
        return E_FAIL;
    }

    lpName->uType = STRRET_CSTR;
    lpName->cStr[0] = '\0';

    PCTSTR pszNameLocal;
    LPTSTR szNameUnaligned = NAME(&(((LPMYPIDL)pidl)->ooe));

    TSTR_ALIGNED_STACK_COPY( &pszNameLocal, szNameUnaligned );

    SHTCharToAnsi( pszNameLocal, lpName->cStr, ARRAYSIZE(lpName->cStr) );

    TraceMsg(TF_ALWAYS, "COfflineFolder::GetDisplayNameOf() - pszNameLocal='%s'", pszNameLocal );

    TraceMsg(TF_ALWAYS, "COfflineFolder::GetDisplayNameOf() - lpName->cStr='%S'", lpName->cStr );

    return NOERROR;    
}

HRESULT COfflineFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                        LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut)
{
    OOEBuf  ooeBuf;
    POOEntry    pooe = NULL;
//    TraceMsg(TF_SUBSFOLDER, "Folde:ISF - SetNameOf.");
    
    if (ppidlOut)  {
        *ppidlOut = NULL;               // null the out param
    }

    if (!IS_VALID_MYPIDL(pidl))
        return E_FAIL;

    HRESULT hr;
    WCHAR szTempName[MAX_PATH];

    ASSERT(lpszName);

    StrCpyNW(szTempName, lpszName, ARRAYSIZE(szTempName));

    PathRemoveBlanks(szTempName);

    if (szTempName[0])
    {   
        memset(&ooeBuf, 0, sizeof(ooeBuf));

        pooe = &(((LPMYPIDL)pidl)->ooe);
        CopyToOOEBuf(pooe, &ooeBuf);
        MyOleStrToStrN(ooeBuf.m_Name, MAX_NAME, szTempName);

        ooeBuf.dwFlags = PROP_WEBCRAWL_NAME;
        hr = SaveBufferChange(&ooeBuf, FALSE);
        
        if (ppidlOut)   {
            DWORD   dwSize = BufferSize(&ooeBuf);
            *ppidlOut = (LPITEMIDLIST)COfflineFolderEnum::NewPidl(dwSize);
            if (*ppidlOut)  {
                pooe = &(((LPMYPIDL)(*ppidlOut))->ooe);
                CopyToMyPooe(&ooeBuf, pooe);
            }
        }
    }
    else
    {
        WCMessageBox(hwndOwner, IDS_NONULLNAME, IDS_RENAME, MB_OK | MB_ICONSTOP);
        hr = E_FAIL;
    }
    return hr;    
}

//////////////////////////////////
//
// IPersistFolder Methods...
//
HRESULT COfflineFolder::GetClassID(LPCLSID lpClassID)
{
//    TraceMsg(TF_SUBSFOLDER, "hcf - pf - GetClassID.");
    
    *lpClassID = CLSID_OfflineFolder;
    return S_OK;
}


HRESULT COfflineFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    if (_pidl)
        ILFree(_pidl);

    _pidl = ILClone(pidlInit);

    if (!_pidl)
        return E_OUTOFMEMORY;

    return NOERROR;
}

HRESULT COfflineFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
    {
        *ppidl = ILClone(_pidl);
        return *ppidl ? NOERROR : E_OUTOFMEMORY;
    }

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

//////////////////////////////////
//
// IContextMenu Methods...
//
HRESULT COfflineFolder::QueryContextMenu
(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst,
    UINT idCmdLast, 
    UINT uFlags)
{
    USHORT cItems = 0;

//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu- QueryContextMenu.");
    if (uFlags == CMF_NORMAL)
    {
        HMENU hmenuHist = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(CONTEXT_MENU_OFFLINE));
        if (hmenuHist)
        {
            cItems = (USHORT) MergeMenuHierarchy(hmenu, hmenuHist, idCmdFirst, idCmdLast, TRUE);

            DestroyMenu(hmenuHist);
        }
    }
    
    return ResultFromShort(cItems);    // number of menu items    
}

STDMETHODIMP COfflineFolder::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu - InvokeCommand.");
    
    int idCmd = _GetCmdID(pici->lpVerb);
    
    if (idCmd != RSVIDM_PASTE)
        return OfflineFolderView_Command(pici->hwnd, idCmd);
     
    IDataObject * dataSrc = NULL;
    IDropTarget * pDropTrgt = NULL;
    HRESULT hr;

    hr = OleGetClipboard(&(dataSrc));

    if (SUCCEEDED(hr))
        hr = this->QueryInterface(IID_IDropTarget, (void **) &pDropTrgt);

    if (SUCCEEDED(hr))  {
        DWORD dwPrefEffect = DROPEFFECT_COPY;
        POINTL pt = {0, 0};

        hr = pDropTrgt->DragEnter(dataSrc, 0/*keystate*/, pt, &dwPrefEffect);
        if (SUCCEEDED(hr))  {
            hr = pDropTrgt->Drop(dataSrc, 0, pt, &dwPrefEffect);
        }
    }

    if (dataSrc)
        SAFERELEASE(dataSrc);
    if (pDropTrgt)
        SAFERELEASE(pDropTrgt);

    return hr;
}

STDMETHODIMP COfflineFolder::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu - GetCommandString.");
    if (uFlags == GCS_HELPTEXTA)
    {
        MLLoadStringA((UINT)idCmd + IDS_SB_FIRST, pszName, cchMax);
        hres = NOERROR;
    }
    return hres;
}

COfflineDetails::COfflineDetails(HWND hwndOwner)
{
    ASSERT(NULL != hwndOwner);
    m_hwndOwner = hwndOwner;
    m_cRef = 1;
}

STDMETHODIMP COfflineDetails::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IUnknown == riid) || (IID_IShellDetails == riid))
    {
        *ppv = (IShellDetails *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) COfflineDetails::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineDetails::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP COfflineDetails::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails)
{
    HRESULT hr;

    if (iColumn > ICOLC_ACTUALSIZE)
        return E_NOTIMPL;

    if (NULL == pDetails)
    {
        return E_INVALIDARG;
    }
    
    if (NULL != pidl)
    {
        DETAILSINFO di = { pidl };
        hr = Generic_GetDetails(&di, colInfo[iColumn].iCol);
        pDetails->fmt = di.fmt;
        pDetails->cxChar = di.cxChar;
        memcpy(&pDetails->str, &di.str, sizeof(di.str));
    }
    else
    {
        pDetails->str.uType = STRRET_CSTR;
        pDetails->str.cStr[0] = '\0';
        MLLoadStringA(colInfo[iColumn].ids, pDetails->str.cStr, sizeof(pDetails->str.cStr));
        pDetails->fmt = colInfo[iColumn].iFmt;
        pDetails->cxChar = colInfo[iColumn].cchCol;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP COfflineDetails::ColumnClick(UINT iColumn)
{
    ShellFolderView_ReArrange(m_hwndOwner, colInfo[iColumn].iCol);
    return S_OK;
}


LPMYPIDL _CreateFolderPidl(IMalloc *pmalloc, DWORD dwSize)
{
    LPMYPIDL pooi = (LPMYPIDL)pmalloc->Alloc(sizeof(MYPIDL) + dwSize + sizeof(USHORT));
    if (pooi)
    {
        memset(pooi, 0, sizeof(MYPIDL) + dwSize + sizeof(USHORT));
        pooi->cb = (USHORT)(dwSize + sizeof(MYPIDL));
        pooi->usSign = (USHORT)MYPIDL_MAGIC;
//      TraceMsg(TF_MEMORY, "CreatePidl %d", sizeof(MYPIDL) + dwSize);
    }
    return pooi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\helper.h ===
#ifndef __helper_h
#define __helper_h

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

HRESULT LoadWithCookie(LPCTSTR url, POOEBuf pBuf, DWORD * pdwBufferSize, SUBSCRIPTIONCOOKIE * pcookie);
HRESULT GetDefaultOOEBuf(OOEBuf * pBuf, SUBSCRIPTIONTYPE subType);

HICON LoadItemIcon(ISubscriptionItem *psi, BOOL bLarge);

BOOL HandleScheduleNameConflict(TCHAR *pszSchedName, SYNCSCHEDULECOOKIE *pSchedCookie);
HRESULT RemoveItemFromAllSchedules(SUBSCRIPTIONCOOKIE *pCookie);

HRESULT AddRemoveScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, // For Add
                               SUBSCRIPTIONCOOKIE *pCookie,                  // For Remove
                               SYNCSCHEDULECOOKIE *pSchedCookie, BOOL bAdd);

inline HRESULT AddScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, 
                                SYNCSCHEDULECOOKIE *pSchedCookie)
{
    return AddRemoveScheduledItem(pSyncHandlerItemInfo, NULL, pSchedCookie, TRUE);
}

inline HRESULT RemoveScheduledItem(SUBSCRIPTIONCOOKIE *pCookie, 
                                  SYNCSCHEDULECOOKIE *pSchedCookie)
{
    return AddRemoveScheduledItem(NULL, pCookie, pSchedCookie, FALSE);
}

HRESULT CreateSchedule(LPWSTR pwszScheduleName, DWORD dwSyncScheduleFlags, 
                       SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger,
                       BOOL fDupCookieOK);

BOOL IsCookieOnSchedule(ISyncSchedule *pSyncSchedule, SUBSCRIPTIONCOOKIE *pCookie);

typedef BOOL (CALLBACK * SCHEDULEENUMCALLBACK)(ISyncSchedule *pSyncSchedule, 
                                               SYNCSCHEDULECOOKIE *pSchedCookie,
                                               LPARAM lParam);
HRESULT EnumSchedules(SCHEDULEENUMCALLBACK pCallback, LPARAM lParam);

BOOL ScheduleCookieExists(SYNCSCHEDULECOOKIE *pSchedCookie);

void SetPropSheetFlags(POOEBuf pBuf, BOOL bSet, DWORD dwPropSheetFlags);
int KeepSpinNumberInRange(HWND hdlg, int idEdit, int idSpin, int minVal, int maxVal);

HRESULT GetItemSchedule(SUBSCRIPTIONCOOKIE *pSubsCookie, SYNCSCHEDULECOOKIE *pSchedCookie);

enum { CONFLICT_NONE, 
       CONFLICT_RESOLVED_USE_NEW, 
       CONFLICT_RESOLVED_USE_OLD, 
       CONFLICT_UNRESOLVED,
       CONFLICT_EMPTY};

int HandleScheduleNameConflict(/* in  */ TCHAR *pszSchedName, 
                               /* in  */ TASK_TRIGGER *pTrigger,
                               /* in  */ HWND hwndParent,
                               /* out */ SYNCSCHEDULECOOKIE *pSchedCookie);

HRESULT UpdateScheduleTrigger(SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger);

HRESULT ScheduleIt(ISubscriptionItem *psi, TCHAR *pszName, TASK_TRIGGER *pTrigger);

void CreatePublisherScheduleNameW(WCHAR *pwszSchedName, int cchSchedName, 
                                  const TCHAR *pszName, const WCHAR *pwszName);

void CreatePublisherScheduleName(TCHAR *pszSchedName, int cchSchedName, 
                                 const TCHAR *pszName, const WCHAR *pwszName);

#ifdef NEWSCHED_AUTONAME
void NewSched_AutoNameHelper(HWND hDlg);
#endif

BOOL NewSched_ResolveNameConflictHelper(HWND hDlg, TASK_TRIGGER *pTrig, 
                                        SYNCSCHEDULECOOKIE *pSchedCookie);
void NewSched_CreateScheduleHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                   SYNCSCHEDULECOOKIE *pSchedCookie);

void NewSched_OnInitDialogHelper(HWND hDlg);

class CWaitCursor
{
    HCURSOR hPrevCursor;
public:
    CWaitCursor()
    {
        hPrevCursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    
    ~CWaitCursor()
    {
        if (hPrevCursor)
            SetCursor(hPrevCursor);
    }
};

#endif //__helper_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\idle.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       idle.cpp
//
//  Contents:   user idle detection
//
//  Classes:
//
//  Functions:
//
//  History:    05-14-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

#include "private.h"
#include "throttle.h"

typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);
typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);
typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

#define TF_THISMODULE TF_WEBCHECKCORE

HINSTANCE           g_hinstMSIDLE = NULL;
_BEGINIDLEDETECTION g_pfnBegin = NULL;
_ENDIDLEDETECTION   g_pfnEnd = NULL;

//
// extra stuff so we don't need msidle.dll on win95
//
BOOL    g_fWin95PerfWin = FALSE;            // using msidle.dll or not?
UINT_PTR g_uIdleTimer = 0;                  // timer handle if not
HANDLE  g_hSageVxd = INVALID_HANDLE_VALUE;  // vxd handle if not
DWORD   g_dwIdleMin = 3;                    // inactivity mins before idle
BOOL    g_fIdle = FALSE;                    // are we idle?
DWORD   g_dwIdleBeginTicks = 0;             // when did idle begin?

VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

//
// A little code copied from msidle.dll.  We use this on Win95 with sage.vxd
// so we don't have to load msidle.dll. 
//

//
// SetIdleTimer - decide how often to poll and set the timer appropriately
//
void SetIdleTimer(void)
{
    UINT uInterval = 1000 * 60;

    //
    // If we're idle and looking for busy, check every 2 seconds
    //
    if(g_fIdle) {
        uInterval = 1000 * 4;
    }

    //
    // kill off the old timer
    //
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
    }

    //
    // Set the timer
    //
    TraceMsg(TF_THISMODULE,"SetIdleTimer uInterval=%d", uInterval);
    g_uIdleTimer = SetTimer(NULL, 0, uInterval, OnIdleTimer);
}
       
//
// OnIdleTimer - idle timer has gone off
//
VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    DWORD dwDiff, dwLastActivityTicks;

    //
    // get last activity ticks from sage
    //
    DeviceIoControl(g_hSageVxd, 2, &dwLastActivityTicks, sizeof(DWORD),
        NULL, 0, NULL, NULL);

    //
    // check to see if we've changed state
    //
    if(g_fIdle) {
        //
        // currently in idle state
        //
        if(dwLastActivityTicks != g_dwIdleBeginTicks) {
            // activity since we became idle - stop being idle!
            g_fIdle = FALSE;

            // set timer
            SetIdleTimer();

            // call back client
            CThrottler::OnIdleStateChange(STATE_USER_IDLE_END);
        }

    } else {
        //
        // currently not in idle state
        //
        dwDiff = GetTickCount() - dwLastActivityTicks;

        if(dwDiff > 1000 * 60 * g_dwIdleMin) {
            // Nothing's happened for our threshold time.  We're now idle.
            g_fIdle = TRUE;

            // save time we became idle
            g_dwIdleBeginTicks = dwLastActivityTicks;

            // set timer
            SetIdleTimer();

            // call back client
            CThrottler::OnIdleStateChange(STATE_USER_IDLE_BEGIN);
        }
    }
}

BOOL LoadSageVxd(void)
{
    int inpVXD[3];

    if(INVALID_HANDLE_VALUE != g_hSageVxd)
        return TRUE;

    g_hSageVxd = CreateFile(TEXT("\\\\.\\sage.vxd"), 0, 0, NULL, 0,
            FILE_FLAG_DELETE_ON_CLOSE, NULL);

    // can't open it?  can't use it
    if(INVALID_HANDLE_VALUE == g_hSageVxd)
        return FALSE;

    // start it monitoring
    inpVXD[0] = -1;         // no window - will query
    inpVXD[1] = 0;          // unused
    inpVXD[2] = 0;          // post delay - not used without a window

    DeviceIoControl(g_hSageVxd, 1, &inpVXD, sizeof(inpVXD), NULL, 0, NULL, NULL);

    return TRUE;
}

BOOL UnloadSageVxd(void)
{
    if(INVALID_HANDLE_VALUE != g_hSageVxd) {
        CloseHandle(g_hSageVxd);
        g_hSageVxd = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

void IdleBegin(HWND hwndParent)
{
    DWORD dwValue;

    // Override idle minutes with reg value if present
    if(ReadRegValue(HKEY_CURRENT_USER,
            c_szRegKey,
            TEXT("IdleMinutes"),
            &dwValue,
            sizeof(dwValue)) &&
        dwValue) {

        g_dwIdleMin = dwValue;
    }

    if(FALSE == g_fIsWinNT && LoadSageVxd()) {
        // using optimal win95 configuration
        g_fWin95PerfWin = TRUE;
        SetIdleTimer();
        return;
    }

    // Bail out if the DebuggerFriendly registry value is set on NT4.
    OSVERSIONINFOA vi;
    vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&vi);

    if(   vi.dwPlatformId == VER_PLATFORM_WIN32_NT
       && vi.dwMajorVersion == 4
       && ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("DebuggerFriendly"), &dwValue, sizeof(dwValue))
       && dwValue)
    {
        return;
    }


    // load msidle.dll
    g_hinstMSIDLE = LoadLibrary(TEXT("msidle.dll"));

    // get begin and end functions
    if(g_hinstMSIDLE) {
        g_pfnBegin = (_BEGINIDLEDETECTION)GetProcAddress(g_hinstMSIDLE, (LPSTR)3);
        g_pfnEnd = (_ENDIDLEDETECTION)GetProcAddress(g_hinstMSIDLE, (LPSTR)4);

        // call start monitoring
        if(g_pfnBegin)
            (g_pfnBegin)(CThrottler::OnIdleStateChange, g_dwIdleMin, 0);
    }
}

void IdleEnd(void)
{
    if(g_fWin95PerfWin) {
        // clean up timer
        KillTimer(NULL, g_uIdleTimer);
        UnloadSageVxd();
    } else {
        // clean up msidle.dll
        if(g_pfnEnd) {
            (g_pfnEnd)(0);
            FreeLibrary(g_hinstMSIDLE);
            g_hinstMSIDLE = NULL;
            g_pfnBegin = NULL;
            g_pfnEnd = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\imnact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Tue Jun 03 10:53:09 1997
 */
/* Compiler settings for imnact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnact_h__
#define __imnact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IImnAdviseAccount_FWD_DEFINED__
#define __IImnAdviseAccount_FWD_DEFINED__
typedef interface IImnAdviseAccount IImnAdviseAccount;
#endif 	/* __IImnAdviseAccount_FWD_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_FWD_DEFINED__
#define __IImnAdviseMigrateServer_FWD_DEFINED__
typedef interface IImnAdviseMigrateServer IImnAdviseMigrateServer;
#endif 	/* __IImnAdviseMigrateServer_FWD_DEFINED__ */


#ifndef __IImnEnumAccounts_FWD_DEFINED__
#define __IImnEnumAccounts_FWD_DEFINED__
typedef interface IImnEnumAccounts IImnEnumAccounts;
#endif 	/* __IImnEnumAccounts_FWD_DEFINED__ */


#ifndef __IImnAccountManager_FWD_DEFINED__
#define __IImnAccountManager_FWD_DEFINED__
typedef interface IImnAccountManager IImnAccountManager;
#endif 	/* __IImnAccountManager_FWD_DEFINED__ */


#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


#ifndef __IImnAccount_FWD_DEFINED__
#define __IImnAccount_FWD_DEFINED__
typedef interface IImnAccount IImnAccount;
#endif 	/* __IImnAccount_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_imnact_0000
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 



//=--------------------------------------------------------------------------=
// Imnact.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Mail and News Account Manager Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
DEFINE_GUID(CLSID_ImnAccountManager, 0x8d4b04e1, 0x1331, 0x11d0, 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccountManager, 0xfd465481, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccount, 0xfd465482, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnEnumAccounts, 0xfd465483, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseMigrateServer, 0x8d0aed11, 0x1638, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseAccount, 0xa06bd31, 0x166f, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNACCT_)
#define IMNACCTAPI DECLSPEC_IMPORT HRESULT WINAPI
#define IMNACCTAPI_(_type_) DECLSPEC_IMPORT _type_ WINAPI
#else
#define IMNACCTAPI HRESULT WINAPI
#define IMNACCTAPI_(_type_) _type_ WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager);
IMNACCTAPI ValidEmailAddress(LPSTR lpAddress);
IMNACCTAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(0xCD00)
#define E_RegQueryInfoKeyFailed      HR_E(0xCD01)
#define E_UserCancel                 HR_E(0xCD02)
#define E_RegOpenKeyFailed           HR_E(0xCD03)
#define E_RegSetValueFailed          HR_E(0xCD04)
#define E_RegDeleteKeyFailed         HR_E(0xCD05)
#define E_DuplicateAccountName       HR_E(0xCD06)
#define S_NonStandardValue           HR_S(0xCD07)
#define E_InvalidValue               HR_E(0xCD08)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(0xCDA0)
#define E_BufferTooSmall             HR_E(0xCDA1)
#define E_BadPropType                HR_E(0xCDA2)
#define E_BufferSizeMismatch         HR_E(0xCDA3)
#define E_InvalidBooleanValue        HR_E(0xCDA4)
#define E_InvalidMinMaxValue         HR_E(0xCDA5)
#define E_PropNotFound               HR_E(0xCDA6)
#define E_InvalidPropTag             HR_E(0xCDA7)
#define E_InvalidPropertySet         HR_E(0xCDA8)
#define E_EnumFinished               HR_E(0xCDA9)
#define S_NoSaveNeeded               HR_S(0xCDAA)
#define S_PasswordDeleted            HR_S(0xCDAB)
#define S_PasswordNotFound           HR_S(0xCDAC)

// --------------------------------------------------------------------------------
// ImnAccountManager errors
// --------------------------------------------------------------------------------
#define E_NoAccounts                 HR_E(0xCDD0)
#define E_BadFriendlyName            HR_E(0xCDD1)

// --------------------------------------------------------------------------------
// RAS Connection Types
// --------------------------------------------------------------------------------
#define CF_AUTO_CONNECT          FLAG02 // Automatically connect

// --------------------------------------------------------------------------------
// Property Macros
// --------------------------------------------------------------------------------
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)

// --------------------------------------------------------------------------------
// IImnAccount Properties
// --------------------------------------------------------------------------------
#define AP_FIRST                    0X1234
// per account properties
#define AP_ACCOUNT_NAME             PROPTAG(TYPE_STRING,    AP_FIRST+1)
#define AP_ACCOUNT_FIRST            AP_ACCOUNT_NAME
#define AP_TEMP_ACCOUNT             PROPTAG(TYPE_DWORD,     AP_FIRST+3)
#define AP_LAST_UPDATED             PROPTAG(TYPE_FILETIME,  AP_FIRST+4)
#define AP_RAS_CONNECTION_TYPE      PROPTAG(TYPE_DWORD,     AP_FIRST+5)
#define AP_RAS_CONNECTOID           PROPTAG(TYPE_STRING,    AP_FIRST+6)
#define AP_RAS_CONNECTION_FLAGS     PROPTAG(TYPE_DWORD,     AP_FIRST+7)
#define AP_ACCOUNT_ID               PROPTAG(TYPE_STRING,    AP_FIRST+9)
#define AP_ACCOUNT_LAST             AP_ACCOUNT_ID

// IMAP properties
#define AP_IMAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+100)
#define AP_IMAP_FIRST               AP_IMAP_SERVER
#define AP_IMAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+101)
#define AP_IMAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+102)
#define AP_IMAP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+104)
#define AP_IMAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+105)
#define AP_IMAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+106)
#define AP_IMAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+107)
#define AP_IMAP_ROOT_FOLDER         PROPTAG(TYPE_STRING,    AP_FIRST+108)
#define AP_IMAP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+109)
#define AP_IMAP_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+110)
#define AP_IMAP_LAST                AP_IMAP_SKIP

// LDAP properties
#define AP_LDAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+200)
#define AP_LDAP_FIRST               AP_LDAP_SERVER
#define AP_LDAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+201)
#define AP_LDAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+202)
#define AP_LDAP_AUTHENTICATION      PROPTAG(TYPE_DWORD,     AP_FIRST+203)
#define AP_LDAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+204)
#define AP_LDAP_SEARCH_RETURN       PROPTAG(TYPE_DWORD,     AP_FIRST+205)
#define AP_LDAP_SEARCH_BASE         PROPTAG(TYPE_STRING,    AP_FIRST+206)
#define AP_LDAP_SERVER_ID           PROPTAG(TYPE_DWORD,     AP_FIRST+207)
#define AP_LDAP_RESOLVE_FLAG        PROPTAG(TYPE_DWORD,     AP_FIRST+208)
#define AP_LDAP_URL                 PROPTAG(TYPE_STRING,    AP_FIRST+209)
#define AP_LDAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+210)
#define AP_LDAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+211)
#define AP_LDAP_LOGO                PROPTAG(TYPE_STRING,    AP_FIRST+212)
#define AP_LDAP_USE_BIND_DN         PROPTAG(TYPE_DWORD,     AP_FIRST+213)
#define AP_LDAP_LAST                AP_LDAP_USE_BIND_DN

// NNTP properties
#define AP_NNTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+300)
#define AP_NNTP_FIRST               AP_NNTP_SERVER
#define AP_NNTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+301)
#define AP_NNTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+302)
#define AP_NNTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+304)
#define AP_NNTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+305)
#define AP_NNTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+306)
#define AP_NNTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+307)
#define AP_NNTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+308)
#define AP_NNTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+309)
#define AP_NNTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+310)
#define AP_NNTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+311)
#define AP_NNTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+312)
#define AP_NNTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+313)
#define AP_NNTP_USE_DESCRIPTIONS    PROPTAG(TYPE_BOOL,      AP_FIRST+314)
#define AP_NNTP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+315)
#define AP_NNTP_LAST                AP_NNTP_DATA_DIR

// POP3 properties
#define AP_POP3_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+400)
#define AP_POP3_FIRST               AP_POP3_SERVER
#define AP_POP3_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+401)
#define AP_POP3_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+402)
#define AP_POP3_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+404)
#define AP_POP3_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+405)
#define AP_POP3_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+406)
#define AP_POP3_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+407)
#define AP_POP3_LEAVE_ON_SERVER     PROPTAG(TYPE_BOOL,      AP_FIRST+408)
#define AP_POP3_REMOVE_DELETED      PROPTAG(TYPE_BOOL,      AP_FIRST+409)
#define AP_POP3_REMOVE_EXPIRED      PROPTAG(TYPE_BOOL,      AP_FIRST+410)
#define AP_POP3_EXPIRE_DAYS         PROPTAG(TYPE_DWORD,     AP_FIRST+411)
#define AP_POP3_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+412)
#define AP_POP3_LAST                AP_POP3_SKIP

// SMTP properties
#define AP_SMTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+500)
#define AP_SMTP_FIRST               AP_SMTP_SERVER
#define AP_SMTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+501)
#define AP_SMTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+502)
#define AP_SMTP_USE_SICILY          PROPTAG(TYPE_DWORD,     AP_FIRST+504) // SMTPAUTHTYEP
#define AP_SMTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+505)
#define AP_SMTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+506)
#define AP_SMTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+507)
#define AP_SMTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+508)
#define AP_SMTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+509)
#define AP_SMTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+510)
#define AP_SMTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+511)
#define AP_SMTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+512)
#define AP_SMTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+513)
#define AP_SMTP_CERTIFICATE         PROPTAG(TYPE_BINARY,    AP_FIRST+514)
#define AP_SMTP_LAST                AP_SMTP_CERTIFICATE

// --------------------------------------------------------------------------------
// Account Flags
// --------------------------------------------------------------------------------
#define ACCT_FLAG_NEWS           ((DWORD)1)
#define ACCT_FLAG_MAIL           ((DWORD)2)
#define ACCT_FLAG_DIR_SERV       ((DWORD)4)
#define ACCT_FLAG_ALL            (ACCT_FLAG_NEWS | ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV)

// --------------------------------------------------------------------------------
// Server Types
// --------------------------------------------------------------------------------
#define SRV_NNTP                 ((DWORD)1)
#define SRV_IMAP                 ((DWORD)2)
#define SRV_POP3                 ((DWORD)4)
#define SRV_SMTP                 ((DWORD)8)
#define SRV_LDAP                 ((DWORD)16)
#define SRV_MAIL                 ((DWORD)(SRV_IMAP | SRV_POP3 | SRV_SMTP))
#define SRV_ALL                  ((DWORD)(SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP))

// --------------------------------------------------------------------------------
// LDAP Authentication Types
// --------------------------------------------------------------------------------
#define LDAP_AUTH_ANONYMOUS      ((DWORD)0)
#define LDAP_AUTH_PASSWORD       ((DWORD)1)
#define LDAP_AUTH_MEMBER_SYSTEM  ((DWORD)2)
#define LDAP_AUTH_MAX            ((DWORD)2)

// -----------------------------------------------------------------------------
// Account Manager Notification Types
// -----------------------------------------------------------------------------
#define AN_ACCOUNT_DELETED           WM_USER + 1
#define AN_ACCOUNT_ADDED             WM_USER + 2
#define AN_ACCOUNT_CHANGED           WM_USER + 3
#define AN_DEFAULT_CHANGED           WM_USER + 4
#define AN_SERVERTYPES_CHANGED       WM_USER + 5

// IImnAccountManager::AccountListDialog flags
// IImnAccount::ShowProperties flags
#define ACCTDLG_NO_IMAP          0x0001
#define ACCTDLG_NO_REMOVEDELETE  0x0002
#define ACCTDLG_NO_BREAKMESSAGES 0x0004
#define ACCTDLG_NO_REMOVEAFTER   0x0008
#define ACCTDLG_NO_SENDRECEIVE   0x0010
#define ACCTDLG_ALL              0x001f

// AP_RAS_CONNECTION_TYPE values
#define CONNECTION_TYPE_LAN      0
#define CONNECTION_TYPE_MANUAL   1
#define CONNECTION_TYPE_RAS      2

// IImnAccount::DoWizard flags
#define ACCT_WIZ_MIGRATE         0x0001

typedef 
enum tagSMTPAUTHTYPE
    {	SMTP_AUTH_NONE	= 0,
	SMTP_AUTH_SICILY	= SMTP_AUTH_NONE + 1,
	SMTP_AUTH_USE_POP3ORIMAP_SETTINGS	= SMTP_AUTH_SICILY + 1,
	SMTP_AUTH_USE_SMTP_SETTINGS	= SMTP_AUTH_USE_POP3ORIMAP_SETTINGS + 1
    }	SMTPAUTHTYPE;

#define	CCHMAX_ORG_NAME	( 256 )

#define	CCHMAX_DISPLAY_NAME	( 256 )

#define	CCHMAX_ACCOUNT_NAME	( 256 )

#define	CCHMAX_SERVER_NAME	( 256 )

#define	CCHMAX_PASSWORD	( 256 )

#define	CCHMAX_USERNAME	( 256 )

#define	CCHMAX_EMAIL_ADDRESS	( 256 )

#define	CCHMAX_CONNECTOID	( 256 )

#define	CCHMAX_SEARCH_BASE	( 256 )

#define	CCHMAX_ROOT_FOLDER	( 256 )



extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_s_ifspec;

#ifndef __IImnAdviseAccount_INTERFACE_DEFINED__
#define __IImnAdviseAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseAccount
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL_IImnAdviseAccount_0001
    {	ACCT_NEWS	= 0,
	ACCT_MAIL	= ACCT_NEWS + 1,
	ACCT_DIR_SERV	= ACCT_MAIL + 1,
	ACCT_LAST	= ACCT_DIR_SERV + 1
    }	ACCTTYPE;

typedef struct  tagAccountContext
    {
    ACCTTYPE AcctType;
    LPSTR pszAccountID;
    LPSTR pszOldName;
    DWORD dwServerType;
    }	ACTX;


EXTERN_C const IID IID_IImnAdviseAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0A06BD31-166F-11d0-81B9-00C04FD85AB4")
    IImnAdviseAccount : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseAccount( 
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseAccount )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx);
        
        END_INTERFACE
    } IImnAdviseAccountVtbl;

    interface IImnAdviseAccount
    {
        CONST_VTBL struct IImnAdviseAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseAccount_AdviseAccount(This,dwAdviseType,pAcctCtx)	\
    (This)->lpVtbl -> AdviseAccount(This,dwAdviseType,pAcctCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseAccount_AdviseAccount_Proxy( 
    IImnAdviseAccount __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseType,
    /* [in] */ ACTX __RPC_FAR *pAcctCtx);


void __RPC_STUB IImnAdviseAccount_AdviseAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseAccount_INTERFACE_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_INTERFACE_DEFINED__
#define __IImnAdviseMigrateServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseMigrateServer
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAdviseMigrateServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8D0AED11-1638-11d0-81B9-00C04FD85AB4")
    IImnAdviseMigrateServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MigrateServer( 
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseMigrateServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MigrateServer )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount);
        
        END_INTERFACE
    } IImnAdviseMigrateServerVtbl;

    interface IImnAdviseMigrateServer
    {
        CONST_VTBL struct IImnAdviseMigrateServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseMigrateServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseMigrateServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseMigrateServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseMigrateServer_MigrateServer(This,dwSrvType,pAccount)	\
    (This)->lpVtbl -> MigrateServer(This,dwSrvType,pAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseMigrateServer_MigrateServer_Proxy( 
    IImnAdviseMigrateServer __RPC_FAR * This,
    /* [in] */ DWORD dwSrvType,
    /* [in] */ IImnAccount __RPC_FAR *pAccount);


void __RPC_STUB IImnAdviseMigrateServer_MigrateServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseMigrateServer_INTERFACE_DEFINED__ */


#ifndef __IImnEnumAccounts_INTERFACE_DEFINED__
#define __IImnEnumAccounts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnEnumAccounts
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnEnumAccounts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465483-1384-11d0-ABBD-0020AFDFD10A")
    IImnEnumAccounts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SortByAccountName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnEnumAccountsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortByAccountName )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        END_INTERFACE
    } IImnEnumAccountsVtbl;

    interface IImnEnumAccounts
    {
        CONST_VTBL struct IImnEnumAccountsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnEnumAccounts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnEnumAccounts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnEnumAccounts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnEnumAccounts_GetCount(This,pcItems)	\
    (This)->lpVtbl -> GetCount(This,pcItems)

#define IImnEnumAccounts_SortByAccountName(This)	\
    (This)->lpVtbl -> SortByAccountName(This)

#define IImnEnumAccounts_GetNext(This,ppAccount)	\
    (This)->lpVtbl -> GetNext(This,ppAccount)

#define IImnEnumAccounts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetCount_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IImnEnumAccounts_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_SortByAccountName_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_SortByAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetNext_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnEnumAccounts_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_Reset_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnEnumAccounts_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager_INTERFACE_DEFINED__
#define __IImnAccountManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccountManager
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef struct  tagACCTLISTINFO
    {
    DWORD cbSize;
    ACCTTYPE AcctTypeInit;
    DWORD dwAcctFlags;
    DWORD dwFlags;
    }	ACCTLISTINFO;


EXTERN_C const IID IID_IImnAccountManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465481-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccountManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAccountObject( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountCount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAccount( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccountName( 
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateDefaultSendAccount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AccountListDialog( 
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        END_INTERFACE
    } IImnAccountManagerVtbl;

    interface IImnAccountManager
    {
        CONST_VTBL struct IImnAccountManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager_Init(This,pAdviseMigrateServer)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer)

#define IImnAccountManager_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager_AccountListDialog(This,hwnd,pinfo)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,pinfo)

#define IImnAccountManager_Advise(This,pAdviseAccount,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdviseAccount,pdwConnection)

#define IImnAccountManager_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager_Init_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);


void __RPC_STUB IImnAccountManager_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_CreateAccountObject_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_CreateAccountObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Enumerate_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwSrvTypes,
    /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);


void __RPC_STUB IImnAccountManager_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetAccountCount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ ULONG __RPC_FAR *pcServers);


void __RPC_STUB IImnAccountManager_GetAccountCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_FindAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPCTSTR pszSearchData,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_FindAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_GetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [ref][in] */ LPTSTR pszAccount,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager_GetDefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ProcessNotification_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IImnAccountManager_ProcessNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ValidateDefaultSendAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This);


void __RPC_STUB IImnAccountManager_ValidateDefaultSendAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_AccountListDialog_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);


void __RPC_STUB IImnAccountManager_AccountListDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Advise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IImnAccountManager_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Unadvise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IImnAccountManager_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager_INTERFACE_DEFINED__ */


#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_PASS	= TYPE_BOOL + 1,
	TYPE_LAST	= TYPE_PASS + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465484-1384-11d0-ABBD-0020AFDFD10A")
    IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_GetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_GetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_GetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_SetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_SetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


#ifndef __IImnAccount_INTERFACE_DEFINED__
#define __IImnAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccount
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465482-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccount : public IPropertyContainer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Exist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAsDefault( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountType( 
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerTypes( 
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperty( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoWizard( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exist )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsDefault )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountType )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerTypes )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateProperty )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoWizard )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountVtbl;

    interface IImnAccount
    {
        CONST_VTBL struct IImnAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccount_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IImnAccount_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IImnAccount_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IImnAccount_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IImnAccount_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IImnAccount_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)


#define IImnAccount_Exist(This)	\
    (This)->lpVtbl -> Exist(This)

#define IImnAccount_SetAsDefault(This)	\
    (This)->lpVtbl -> SetAsDefault(This)

#define IImnAccount_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IImnAccount_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IImnAccount_GetAccountType(This,pAcctType)	\
    (This)->lpVtbl -> GetAccountType(This,pAcctType)

#define IImnAccount_GetServerTypes(This,pdwSrvTypes)	\
    (This)->lpVtbl -> GetServerTypes(This,pdwSrvTypes)

#define IImnAccount_ShowProperties(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd,dwFlags)

#define IImnAccount_ValidateProperty(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> ValidateProperty(This,dwPropTag,pb,cb)

#define IImnAccount_DoWizard(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> DoWizard(This,hwnd,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccount_Exist_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Exist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SetAsDefault_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SetAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_Delete_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SaveChanges_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetAccountType_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);


void __RPC_STUB IImnAccount_GetAccountType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetServerTypes_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);


void __RPC_STUB IImnAccount_GetServerTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ShowProperties_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ValidateProperty_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IImnAccount_ValidateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_DoWizard_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_DoWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccount_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\iwebck.cpp ===
#include "private.h"
#include <shlguid.h>

#define TF_THISMODULE TF_WEBCHECKCORE

DWORD   g_idSchedThread = 0;

// global containing pointer to instance of CWebcheck.  Needed to control
// externals loading on demand.
CWebCheck *g_pwc = NULL;

//////////////////////////////////////////////////////////////////////////
//
// CWebCheck implementation
//
//////////////////////////////////////////////////////////////////////////

CWebCheck::CWebCheck()
{
    // Maintain global object count
    DllAddRef();

    // Initialize object
    m_cRef = 1;

    // save our instance
    g_pwc = this;
}

CWebCheck::~CWebCheck()
{
    // Maintain global object count
    DllRelease();

    // no longer available
    g_pwc = NULL;
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) CWebCheck::AddRef(void)
{
//  TraceMsg(TF_THISMODULE, "CWebCheck::AddRef m_cRef=%d", m_cRef+1);

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CWebCheck::Release(void)
{
//  TraceMsg(TF_THISMODULE, "CWebCheck::Release m_cRef=%d", m_cRef-1);

    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CWebCheck::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppv = (IOleCommandTarget *)this;
    else
        return E_NOINTERFACE;

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}

//
// IOleCommandTarget members
// The shell will send notifications to us through this interface.
//

STDMETHODIMP CWebCheck::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
    {
        // We like Shell Service Object notifications...
        return S_OK;
    }

    return(OLECMDERR_E_UNKNOWNGROUP);
}

STDMETHODIMP CWebCheck::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                             DWORD nCmdexecopt, VARIANTARG *pvaIn,
                             VARIANTARG *pvaOut)
{
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
    {
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                StartService(FALSE);
                break;

            case SSOCMDID_CLOSE:
                StopService();
                break;
        }
        return S_OK;
    }

    return(E_NOTIMPL);
}


//
// IWebCheck members
//

// Starts the webcheck service in a process
STDMETHODIMP CWebCheck::StartService(BOOL fForceExternals)
{
    DBG("CWebCheck::StartService entered");

    // reset offline mode for all platforms except NT5
    if(FALSE == g_fIsWinNT5)
    {
        HMODULE hWininet = GetModuleHandle(TEXT("WININET.DLL"));
        if(hWininet)
        {
            // wininet is loaded - tell it to go online
            INTERNET_CONNECTED_INFO ci;
            memset(&ci, 0, sizeof(ci));
            ci.dwConnectedState = INTERNET_STATE_CONNECTED;
            InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
        }
        else
        {
            // wininet not loaded - blow away offline reg key so we'll
            // be online when it does load
            DWORD dwOffline = 0;        // FALSE => not offline
            WriteRegValue(HKEY_CURRENT_USER, c_szRegPathInternetSettings,
                TEXT("GlobalUserOffline"), &dwOffline, sizeof(DWORD), REG_DWORD);
        }
    }

    // create dialmon window
    DialmonInit();

    // Fire up LCE and sens if necessary
    if(fForceExternals || ShouldLoadExternals())
        LoadExternals();

    //
    // Process the Infodelivery Admin Policies on user login.  (User login coincides
    // with webcheck's StartService() call.)
    //
    ProcessInfodeliveryPolicies();

    DBG("CWebCheck::StartService exiting");
    return S_OK;
}


// Stops Webcheck if running.
STDMETHODIMP CWebCheck::StopService(void)
{
    DBG("CWebCheck::StopService entered");

    // kill dialmon window
    DialmonShutdown();

    // shut down the external bits
    if(FALSE == g_fIsWinNT)
        UnloadExternals();

    DBG("CWebCheck::StopService exiting");
    return S_OK;
}

//
// load behavior: (win9x)
//
// "auto"   Load if on a laptop
// "yes"    Load always
// "no"     Load never
//
static const WCHAR s_szAuto[] = TEXT("auto");
static const WCHAR s_szYes[] = TEXT("yes");
static const WCHAR s_szNo[] = TEXT("no");

BOOL CWebCheck::ShouldLoadExternals(void)
{
    WCHAR   szSens[16], szLce[16];
    DWORD   cbData;

    //
    // don't load on NT
    //
    if(g_fIsWinNT)
    {
        DBG("CWebCheck::ShouldLoadExternals -> NO (NT)");
        return FALSE;
    }

    //
    // read sens/lce user settings - no setting means auto
    //
    cbData = sizeof(szLce);
    if(ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE, c_szRegKey, L"LoadLCE", NULL, szLce, &cbData))
    {
        StrCpyNW(szLce, s_szAuto, ARRAYSIZE(szLce));
    }

    cbData = sizeof(szSens);
    if(ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE, c_szRegKey, L"LoadSens", NULL, szSens, &cbData))
    {
        StrCpyNW(szSens, s_szAuto, ARRAYSIZE(szSens));
    }

    //
    // if either is yes, load
    //
    if(0 == StrCmpIW(szLce, s_szYes) || 0 == StrCmpIW(szSens, s_szYes))
    {
        DBG("CWebCheck::ShouldLoadExternals -> YES (reg = yes)");
        return TRUE;
    }

    //
    // if either is auto, check for laptop
    //
    if(0 == StrCmpIW(szLce, s_szAuto) || 0 == StrCmpIW(szSens, s_szAuto))
    {
        if(SHGetMachineInfo(GMI_LAPTOP))
        {
            // Is a laptop - load
            DBG("CWebCheck::ShouldLoadExternals -> YES (reg = auto, laptop)");
            return TRUE;
        }
    }

    // don't load
    DBG("CWebCheck::ShouldLoadExternals -> NO");
    return FALSE;
}

BOOL CWebCheck::AreExternalsLoaded(void)
{
    return (_hThread != NULL);
}

void CWebCheck::LoadExternals(void)
{
    DWORD dwThreadId;

    DBG("CWebCheck::LoadExternals");

    if(_hThread)
    {
        DBG("CWebCheck::LoadExternals - already loaded");
        return;
    }

    // fire up a thread to do the work
    _hThread = CreateThread(NULL, 4096, ExternalsThread, this, 0, &dwThreadId);
    if(NULL == _hThread) {
        DBG("LoadExternals failed to create externals thread!");
        return;
    }

    // create initializion and termination events

    //
    // [darrenmi 2/7/00] Wininet now tries to find this named mutex instead of querying
    // dialmon.  It's the A version because wininet isn't unicode and OpenEventA can't
    // find events created with CreateEventW.
    //
    // See GetSensLanState in inet\wininet\dll\autodial.cxx.
    //
    _hTerminateEvent = CreateEventA(NULL, TRUE, FALSE, "MS_WebcheckExternalsTerminateEvent");
    if(NULL == _hTerminateEvent) {
        DBG("LoadExternals failed to create termination event");
        return;
    }

    DBG("CWebCheck::LoadExternals exiting");
    return;
}

void CWebCheck::UnloadExternals(void)
{
    if(NULL == _hThread)
    {
        DBG("CWebCheck::UnloadExternals - nothing to unload");
        return;
    }

    // tell externals thread to go away by setting termination event
    SetEvent(_hTerminateEvent);

    // Give thread a 10 second grace period to shut down
    // don't really care if it goes away or not... our process is going away!
    WaitForSingleObject(_hThread, 10000);

    // clean up
    CloseHandle(_hThread);
    CloseHandle(_hTerminateEvent);
    _hThread = NULL;
    _hTerminateEvent = NULL;

    return;
}

DWORD WINAPI ExternalsThread(LPVOID lpData)
{
    CWebCheck * pWebCheck = (CWebCheck *)lpData;
    HINSTANCE hLCE, hSENS = NULL;
    BOOL fLCEStarted = FALSE, fSENSStarted = FALSE;
    DWORD dwRet;
    MSG msg;

    // sleep for 10 seconds before firing off externals
    Sleep(10 * 1000);

    // fire up com
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr)) {
        DBG("LoadExternals: Failed to initialize COM");
        return 0;
    }

    // load and start LCE
    hLCE = LoadLibrary(TEXT("estier2.dll"));
    DBGASSERT(hLCE, "LoadExternals: Failed to load estier2.dll");
    if(hLCE) {
        LCESTART startfunc;
        startfunc = (LCESTART)GetProcAddress(hLCE, "LCEStartServer");
        DBGASSERT(startfunc, "LoadExternals: Failed to find LCEStartServer");
        if(startfunc) {
            hr = startfunc();
            if(SUCCEEDED(hr))
                fLCEStarted = TRUE;
            DBGASSERT(fLCEStarted, "LoadExternals: Failed to start LCE");
        }
    }

    // if LCE started sucessfully, load and start SENS
    if(fLCEStarted) {
        hSENS = LoadLibrary(TEXT("sens.dll"));
        DBGASSERT(hSENS, "LoadExternals: Failed to load sens.dll");
        if(hSENS) {
            SENSSTART startfunc;
            startfunc = (SENSSTART)GetProcAddress(hSENS, "SensInitialize");
            DBGASSERT(startfunc, "LoadExternals: Failed to find SensInitialize");
            if(startfunc) {
                if(startfunc())
                    fSENSStarted = TRUE;
                DBGASSERT(fSENSStarted, "LoadExternals: Failed to start SENS");
            }
        }
    }

    // Wait for our shutdown event but pump messages in the mean time
    do {
        dwRet = MsgWaitForMultipleObjects(1, &(pWebCheck->_hTerminateEvent),
                    FALSE, INFINITE, QS_ALLINPUT);
        if(WAIT_OBJECT_0 == dwRet) {
            // got our event, drop out of do loop
            break;
        }

        // empty the message queue...
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } while(TRUE);

    // shut down SENS
    if(fSENSStarted) {
        ASSERT(hSENS);
        SENSSTOP stopfunc;
        stopfunc = (SENSSTOP)GetProcAddress(hSENS, "SensUninitialize");
        if(stopfunc) {
            stopfunc();
        }
    }

    //
    // [darrenmi] beta-1 hack: Sens may have a thread sitting in its code
    // at this point so it's not safe to unload sens.  Since we're in the
    // process of shutting down anyway, just leave it alone and let the
    // system unload it.
    //
    //if(hSENS) {
    //    FreeLibrary(hSENS);
    //}

    // shut down LCE
    if(fLCEStarted) {
        ASSERT(hLCE)
        LCESTOP stopfunc;
        stopfunc = (LCESTOP)GetProcAddress(hLCE, "LCEStopServer");
        if(stopfunc) {
            stopfunc();
        }
    }

    if(hLCE) {
        FreeLibrary(hLCE);
    }

    // clean up com goo
    CoUninitialize();

    return 0;
}


//
// OLE bypass code
//
// Expose a couple of APIs to call start and stop service so loadwc doesn't
// need to load up OLE at start time.
//

HRESULT
ExtStartService(
    BOOL    fForceExternals
    )
{
    HRESULT hr = E_FAIL;

    // make a webcheck object
    ASSERT(NULL == g_pwc);
    if(NULL == g_pwc)
    {
        g_pwc = new CWebCheck;
        if(g_pwc)
        {
            hr = g_pwc->StartService(fForceExternals);
        }
    }

    return hr;
}

HRESULT
ExtStopService(
    void
    )
{
    HRESULT hr = E_FAIL;

    if(g_pwc)
    {
        hr = g_pwc->StopService();
        SAFERELEASE(g_pwc);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\notfcvt.h ===
#ifndef _notfcvt_h
#define _notfcvt_h

typedef enum
{
     PT_NOT_INITIALIZED     = 0   //
    ,PT_NORMAL              = 1
    ,PT_WITHREPLY
    ,PT_REPORT_TO_SENDER
    ,PT_REPORT_TO_DEST
    ,PT_INVALID
    ,PT_GROUPLEADER
    ,PT_GROUPMEMBER

} PACKAGE_TYPE;

// package flags inidicate what the package is doing and is
typedef enum
{
     PF_READY            = 0x00000001
    ,PF_RUNNING          = 0x00000002
    ,PF_WAITING          = 0x00000004
    ,PF_REVOKED          = 0x00000008
    ,PF_SUSPENDED        = 0x00000010
    ,PF_ABORTED          = 0x00000020

    // the pacakge was delivered cross process
    ,PF_CROSSPROCESS     = 0x00010000
    ,PF_SCHEDULED        = 0x00020000
    ,PF_DELIVERED        = 0x00040000
    ,PF_DISPATCHED       = 0x00080000
    
    // idle flags
    ,PF_WAITING_USER_IDLE= 0x00100000
    
} _PACKAGE_FLAGS;
typedef DWORD PACKAGE_FLAGS;

typedef enum _tagPACKAGE_CONTENT_ENUM
{
     PC_EMPTY            = 0x00000000
    ,PC_CLSIDSENDER      = 0x00000001
    ,PC_CLSIDDEST        = 0x00000002
    ,PC_GROUPCOOKIE      = 0x00000004
    ,PC_RUNCOOKIE        = 0x00000008
    ,PC_TASKTRIGGER      = 0x00000010
    ,PC_TASKDATA         = 0x00000020
    ,PC_BASECOOKIE       = 0x00000040

    ,PC_CLSID            = 0x00000100
    ,PC_SINK             = 0x00000200
    ,PC_THREADID         = 0x00000400
} PACKAGE_CONTENT_ENUM;

typedef DWORD PACKAGE_CONTENT;

struct NOTIFICATIONITEMEXTRA
{
    DELIVERMODE             deliverMode;
    FILETIME                dateNextRun;        //  Ignore
    FILETIME                datePrevRun;
    NOTIFICATIONCOOKIE      RunningCookie;      //  Ignore
    NOTIFICATIONCOOKIE      BaseCookie;         //  Ignore
    PACKAGE_TYPE            PackageType;
    PACKAGE_FLAGS           PackageFlags;
    PACKAGE_CONTENT         PackageContent;
    DWORD                   dwThreadIdDestPort; //  Ignore
    HWND                    hWndDestPort;       //  Ignore
};

typedef struct _tagSaveSTATPROPMAP
{
    DWORD           cbSize;
    DWORD           cbStrLen;
    DWORD           dwFlags;
    DWORD           cbVarSizeExtra;
} SaveSTATPROPMAP;

#ifndef __msnotify_h__

EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_MONTHLY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;

typedef GUID NOTIFICATIONTYPE;
typedef GUID NOTIFICATIONCOOKIE;
typedef DWORD NOTIFICATIONFLAGS;

typedef 
enum _tagDELIVERMODE
    {	DM_DELIVER_PREFERED	= 0x1,
	DM_DELIVER_DELAYED	= 0x2,
	DM_DELIVER_LAST_DELAYED	= 0x4,
	DM_ONLY_IF_RUNNING	= 0x20,
	DM_THROTTLE_MODE	= 0x80,
	DM_NEED_COMPLETIONREPORT	= 0x100,
	DM_NEED_PROGRESSREPORT	= 0x200,
	DM_DELIVER_DEFAULT_THREAD	= 0x400,
	DM_DELIVER_DEFAULT_PROCESS	= 0x800
    }	_DELIVERMODE;

typedef DWORD DELIVERMODE;

typedef struct  _tagTASKDATA
    {
    ULONG cbSize;
    DWORD dwReserved;
    DWORD dwTaskFlags;
    DWORD dwPriority;
    DWORD dwDuration;
    DWORD nParallelTasks;
    }	TASK_DATA;

typedef struct _tagTASKDATA __RPC_FAR *PTASK_DATA;

typedef void *LPNOTIFICATION;
typedef struct  _tagNotificationItem
    {
    ULONG cbSize;
    LPNOTIFICATION pNotification;
    NOTIFICATIONTYPE NotificationType;
    NOTIFICATIONFLAGS NotificationFlags;
    DELIVERMODE DeliverMode;
    NOTIFICATIONCOOKIE NotificationCookie;
    TASK_TRIGGER TaskTrigger;
    TASK_DATA TaskData;
    NOTIFICATIONCOOKIE groupCookie;
    CLSID clsidSender;
    CLSID clsidDest;
    FILETIME dateLastRun;
    FILETIME dateNextRun;
    DWORD dwNotificationState;
    }	NOTIFICATIONITEM;

typedef struct _tagNotificationItem __RPC_FAR *PNOTIFICATIONITEM;

typedef DWORD GROUPMODE;

#endif // __msnotify_h__

typedef enum
{
     GS_Created     = 0
    ,GS_Running     = 1
    ,GS_Initialized = 2


} GROUP_STATE;

typedef enum
{
     GT_NORMAL     = 0x00000001
    ,GT_STATIC     = 0x00000002

} _GROUP_TYPE;

typedef DWORD GROUP_TYPE;

typedef struct _tagSCHEDULEGROUPITEM
{
    ULONG               cbSize;
    ULONG               cElements;     // the # of packages in the group
    NOTIFICATIONCOOKIE  GroupCookie;
    GROUPMODE           grfGroupMode;
    GROUP_STATE         grpState;
    TASK_TRIGGER        TaskTrigger;
    TASK_DATA           TaskData;
    GROUP_TYPE          GroupType;
    GROUPINFO           GroupInfo;
} SCHEDULEGROUPITEM, *PSCHEDULEGROUPITEM;

HRESULT ConvertIE4Subscriptions();

#endif // _notfcvt_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\offline.h ===
#ifndef OFFLINE_H
#define OFFLINE_H

typedef enum AGENT_PRIORITY {
    AGENT_PRIORITY_NORMAL = 2
} AGENT_PRIORITY;

typedef enum    {_INIT_FROM_URL, _INIT_FROM_INTSHCUT, _INIT_FROM_CHANNEL} INIT_SRC_ENUM;

#define MAX_NAME_QUICKLINK      MAX_PATH
#define MAX_NAME                MAX_NAME_QUICKLINK
#define MAX_URL                 INTERNET_MAX_URL_LENGTH
#define MAX_USERNAME            127
#define MAX_PASSWORD            63
#define MAX_STATUS              127

#define MAX_PROP_PAGES          10
#define MAX_WC_AGENT_PAGES      2

typedef struct {
    int     templateRCID;
    DLGPROC dlgProc;
} PageType, * LPPageType;
typedef const PageType *CLPPageType;

// PIDL format for this folder...
typedef struct OOEntry
{
    DWORD       dwSize;
    DWORD       dwFlags;
    CFileTime   m_LastUpdated;
    CFileTime   m_NextUpdate;
    LONG        m_SizeLimit;
    LONG        m_ActualSize;
    LONG        m_RecurseLevels;
    LONG        m_RecurseFlags;
    AGENT_PRIORITY  m_Priority;
    BOOL        bDesktop;
    BOOL        bChannel;
    BOOL        bMail;
    BOOL        bGleam;
    BOOL        bChangesOnly;
    BOOL        bNeedPassword;
    TASK_TRIGGER    m_Trigger;
    DWORD       fChannelFlags;
    SUBSCRIPTIONCOOKIE m_Cookie;
    SUBSCRIPTIONCOOKIE groupCookie;
    DWORD       grfTaskTrigger;
    CLSID       clsidDest;
    SCODE       status;
    LPTSTR      username;
    LPTSTR      password;
    LPTSTR      m_URL;
    LPTSTR      m_Name;
    LPTSTR      statusStr;
} OOEntry;

typedef UNALIGNED OOEntry * POOEntry;

#define PSF_NO_SCHEDULED_UPDATES    0x00000001
#define PSF_NO_EDITING_SCHEDULES    0x00000002
#define PSF_NO_AUTO_NAME_SCHEDULE   0x00000004
#define PSF_NO_CHECK_SCHED_CONFLICT 0x00000008
#define PSF_IS_ALREADY_SUBSCRIBED   0x00000010

typedef struct
{ 
    DWORD       dwFlags;
    CFileTime   m_LastUpdated;
    CFileTime   m_NextUpdate;
    LONG        m_SizeLimit;
    LONG        m_ActualSize;
    LONG        m_RecurseLevels;
    LONG        m_RecurseFlags;
    AGENT_PRIORITY  m_Priority;
    BOOL        bDesktop;
    BOOL        bChannel;
    BOOL        bMail;
    BOOL        bGleam;
    BOOL        bChangesOnly;
    BOOL        bNeedPassword;
    TASK_TRIGGER    m_Trigger;
    DWORD       fChannelFlags;
    SUBSCRIPTIONCOOKIE m_Cookie;
    SUBSCRIPTIONCOOKIE groupCookie;
    DWORD       grfTaskTrigger;
    CLSID       clsidDest;
    SCODE       status;
    TCHAR       username[MAX_USERNAME + 1];
    TCHAR       password[MAX_PASSWORD + 1];
    TCHAR       m_URL[MAX_URL + 1];
    TCHAR       m_Name[MAX_NAME + 1];
    TCHAR       statusStr[MAX_STATUS +1];
    DWORD       m_dwPropSheetFlags;     // used internally by propsheets and wizard
    HWND        hwndNewSchedDlg;
} OOEBuf, * POOEBuf;

typedef struct
{
    USHORT  cb;
    USHORT  usSign;
    OOEntry ooe;  //  Should point to the place right after itself.
} MYPIDL;

typedef UNALIGNED MYPIDL *LPMYPIDL;

typedef struct _ColInfoType {
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} ColInfoType;

enum {
    ICOLC_SHORTNAME = 0,
    ICOLC_LAST,
    ICOLC_STATUS, 
    ICOLC_URL,
    ICOLC_ACTUALSIZE
};
  
#define MYPIDL_MAGIC       0x7405

#define RETURN_ON_FAILURE(hr)   if (FAILED(hr)) return hr

#define IS_VALID_MYPIDL(pidl)      ((((LPMYPIDL)pidl)->cb > sizeof(MYPIDL)) && \
                                     (((LPMYPIDL)pidl)->usSign == (USHORT)MYPIDL_MAGIC))

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define NAME(pooe)  (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->m_Name))
#define URL(pooe)   (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->m_URL))
#define UNAME(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->username))
#define PASSWD(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->password))
#define STATUS(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->statusStr))

#ifdef __cplusplus
extern "C" {
#endif
    
extern HINSTANCE g_hInst;
extern const CHAR c_szOpen[];
extern const CHAR c_szUpdate[];
extern const CHAR c_szDelete[];
extern const CHAR c_szProperties[];
extern const CHAR c_szCopy[];

extern const CLSID CLSID_OfflineFolder;
extern const CLSID CLSID_WebcrawlHelper;
extern const CLSID IID_IOfflineObject;

#ifdef __cplusplus
};
#endif

#include "wizards.h"
#include "utils.h"  // NOTE: must come at end to get all the definitions

#endif // OFFLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\mailagnt.cpp ===
//
// WebCheck Mail Agent
//
// A user specifies that they are to be notified via email when a web checked
// object (usually a page) changes.
//
// When the subscription is the delivery agent will call the mail agent upon completion
//  with a temporary ISubscriptionItem
// 
// Julian Jiggins (julianj), January 8, 1997
//

#include "private.h"
#include "mapi.h"
#include "smtp.h"
#include "mlang.h"

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE   TF_MAILAGENT

//
// Global strings
// REVIEW move to a better place
//
#define MAIL_HANDLER    TEXT("Software\\Clients\\Mail")
#define MAIL_ATHENA     TEXT("Internet Mail and News")
#define SUBJECT_LINE TEXT("Subscription delivered")
#define MESSAGE_PREFIX TEXT(" \r\nThe website you requested ")
#define MESSAGE_SUFFIX TEXT(" has been delivered")

#define ATHENA_SMTP_SERVER \
    TEXT("Software\\Microsoft\\Internet Mail and News\\Mail\\SMTP")
#define NETSCAPE_SMTP_SERVER \
    TEXT("Software\\Netscape\\netscape Navigator\\Services\\SMTP_Server")
#define EUDORA_COMMANDLINE TEXT("Software\\Qualcomm\\Eudora\\CommandLine")

#define NOTE_TEXT_LENGTH 4096

#define ENCODING_STRLEN 32

//////////////////////////////////////////////////////////////////////////
//
// Email helper functions
//
//////////////////////////////////////////////////////////////////////////

//
// Returns a MemAlloc'd string with HTMLBreak inserted in place of '\d'.
//
void AddHTMLBreakText(LPSTR szText, LPSTR szHTMLBreak, LPSTR *lpHTMLText)
{
    ASSERT(szText);
    ASSERT(szHTMLBreak);
    ASSERT(!*lpHTMLText);

    LPSTR lpTmp = NULL, lpTmp2 = NULL, lpHTMLAbstract = NULL;
    int cbCRs = 0;
    int cbLFs = 0;
    DWORD dwExtra = 0;
    
    //
    // Count number of carriage returns
    //
    for (lpTmp = szText; *lpTmp; lpTmp++)
    {
        if (*lpTmp == 0x0d)
            cbCRs++;
        if (*lpTmp == 0x0a)
            cbLFs++;
    }
    
    dwExtra = lstrlenA(szText) - cbCRs - cbLFs + cbCRs * lstrlenA(szHTMLBreak) + 1;

    //
    // Allocate appropriate size string
    //
    *lpHTMLText = lpHTMLAbstract = (LPSTR)MemAlloc(LPTR, dwExtra);
    if (!lpHTMLAbstract)
        return;

    // 
    // Create new HTML abstract string.
    //
    for (lpTmp = szText; *lpTmp; lpTmp++)
    {
        if (*lpTmp == 0x0d)
        {
            for (lpTmp2 = szHTMLBreak; *lpTmp2; lpTmp2++, lpHTMLAbstract++)
                *lpHTMLAbstract = *lpTmp2;
        }
        else if (*lpTmp != 0x0a)
        {
            *lpHTMLAbstract = *lpTmp;
            lpHTMLAbstract++;
        }
    }

    *lpHTMLAbstract = '\0';

}

#ifdef DEBUG
void DBG_OUTPUT_MAPI_ERROR(ULONG ul)
{
    switch(ul)
    {
    case MAPI_E_LOGON_FAILURE: 
        DBG("MailAgent: MAPI LOGON FAILURE"); break;
    case MAPI_E_FAILURE:
        DBG("MailAgent: MAPI_E_FAILURE"); break;
    default: 
        DBG("MailAgent: Failed to send mail message"); break;
    }
}
#else
#define DBG_OUTPUT_MAPI_ERROR(ul)
#endif

//
// Build an HTML message containing a frameset that effectively inlines
// the requested URL
//
BOOL BuildHTMLMessage(LPSTR szEmailAddress, LPSTR szName, LPSTR szURL, 
                      CHAR **ppHTMLMessage,  LPSTR szTitle, LPSTR szAbstract,
                      LPSTR szSrcCharset)
{
    *ppHTMLMessage = NULL; // clear out parameter
    
    CHAR * lpBuffer = NULL;

    CHAR szWrapper[NOTE_TEXT_LENGTH];
    CHAR szMessageFormat[NOTE_TEXT_LENGTH];
    CHAR szMessageFormat2[NOTE_TEXT_LENGTH];
    CHAR szMessageText[NOTE_TEXT_LENGTH];
    CHAR szMessageHTML[NOTE_TEXT_LENGTH];
    CHAR szTextBreak[10];
    CHAR szHTMLBreak[10];

    //
    // Load the wrapper for the HTML message. This is the header stuff 
    // and multipart MIME and HTML goop
    //
    int iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGEWRAPPER, szWrapper, NOTE_TEXT_LENGTH);
    ASSERT(iRet > 0);

    if (szTitle != NULL) {

        // NOTE: Size is probably slightly larger than necessary due to %1's.

        LPSTR lpHTMLAbstract = NULL, lpNewAbstract = NULL;
        DWORD dwTotalSize = 0;
        //
        // load string for single HTML line break as well as tag on for custom email
        //

        MLLoadStringA(IDS_AGNT_EMAILMESSAGE, szMessageText, ARRAYSIZE(szMessageText));

        MLLoadStringA(IDS_AGNT_HTMLBREAKSINGLE, szHTMLBreak, ARRAYSIZE(szHTMLBreak));

        // 
        // Create new abstract string (szAbstract + email tagger)
        //
        dwTotalSize = lstrlenA(szAbstract) + lstrlenA(szMessageText) + 1;

        LPSTR szNewAbstract = (LPSTR)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!szNewAbstract)
            return FALSE;

        lstrcpynA(szNewAbstract, szAbstract, dwTotalSize);
        StrCatBuffA(szNewAbstract, szMessageText, dwTotalSize);
        
        AddHTMLBreakText(szNewAbstract, szHTMLBreak, &lpHTMLAbstract);
        if (!lpHTMLAbstract) 
        {
            MemFree(szNewAbstract);
            return FALSE;
        }
            
        dwTotalSize = lstrlenA(szWrapper) + lstrlenA(szEmailAddress) + 
                            2*lstrlenA(szTitle) + lstrlenA(szNewAbstract) + lstrlenA(szSrcCharset) +
                            lstrlenA(lpHTMLAbstract) + lstrlenA(szURL) + 1;

        lpBuffer = (CHAR *)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!lpBuffer)
            return FALSE;

        LPSTR lpArguments[6];
        lpArguments[0] = szEmailAddress;
        lpArguments[1] = szTitle;
        lpArguments[2] = szNewAbstract;
        lpArguments[3] = szSrcCharset;    // the charset of the HTML page
        lpArguments[4] = szURL;
        lpArguments[5] = lpHTMLAbstract;

        //
        // Reason for FormatMessage is that wsprintf is limited up to 1024 bytes
        //

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szWrapper, 0, 0, lpBuffer, dwTotalSize, (va_list *)&lpArguments[0]);

        MemFree(szNewAbstract);
        MemFree(lpHTMLAbstract);

    } else {

        //
        // Load line breaks for the plaintext and html messages
        //
        iRet = MLLoadStringA(IDS_AGNT_TEXTBREAK, szTextBreak, ARRAYSIZE(szTextBreak));
        ASSERT(iRet > 0);
        iRet = MLLoadStringA(IDS_AGNT_HTMLBREAK, szHTMLBreak, ARRAYSIZE(szHTMLBreak));
        ASSERT(iRet > 0);

        //
        // Load the actual text message to put sent
        //
        iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGETEXT, szMessageFormat, NOTE_TEXT_LENGTH);
        ASSERT(iRet > 0);

        iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGETEXT2, szMessageFormat2, NOTE_TEXT_LENGTH);
        ASSERT(iRet > 0);

        //
        // Insert the text messages into the wrapper. Note two message get
        // Once in the mime section for text/ascii and once in the 
        // noframes section of the text/html frameset. This is a work around
        // for clients (like Outlook) that think they can render HTML
        // but cannot really. 
        // The second message IDS_AGNT_HTMLMESSAGETEXT2 should NOT be localized
        // this is only going to be seen by Exchange users. In the future exchange
        // will handle html mail correct, so it acceptable that for example
        // Japanese Exchange users see english in this message. Most Japanese
        // users will user Outlook Express and so will just see the html message
        //

        // First we format 2 text messages, one for text and one for HTML,
        // since message itself is relatively small we know its < 1024 bytes

        iRet = wnsprintfA(szMessageText, ARRAYSIZE(szMessageText), szMessageFormat, 
                         szName, szTextBreak, szURL, szTextBreak);
        ASSERT(iRet > lstrlenA(szMessageFormat));

        iRet = wnsprintfA(szMessageHTML, ARRAYSIZE(szMessageHTML), szMessageFormat2, 
                         szName, szHTMLBreak, szURL, szHTMLBreak);
        ASSERT(iRet > lstrlenA(szMessageFormat2));

        DWORD dwTotalSize = lstrlenA(szWrapper) + lstrlenA(szEmailAddress) +
                            lstrlenA(szName) + lstrlenA(szMessageText) + lstrlenA(szSrcCharset) +
                            lstrlenA(szMessageHTML) + lstrlenA(szURL) + 1;

        lpBuffer = (CHAR *)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!lpBuffer)
            return FALSE;

        LPSTR lpArguments[6];
        lpArguments[0] = szEmailAddress;  // target email address
        lpArguments[1] = szName;          // the name of the page that goes in the subject line  
        lpArguments[2] = szMessageText;   // the plain text message
        lpArguments[3] = szSrcCharset;    // the charset of the HTML page
        lpArguments[4] = szURL;           // the href of the page that goes in the frame set
        lpArguments[5] = szMessageHTML;   // the plain text message that goes in the 
                                          // noframes part of the frameset

        DWORD dwRet;
        dwRet = FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szWrapper, 0, 0, lpBuffer, dwTotalSize, (va_list *)&lpArguments[0]);
        ASSERT(dwRet);            
    }

    *ppHTMLMessage = lpBuffer;

    return TRUE;
}

//
// Build the actual text of the message to be sent via SMTP,
// load format string from resource and insert URL and URL's friently name.
//
void BuildSMTPMessage(LPSTR szName, LPSTR szURL, LPSTR *szMessage,
                      LPSTR szTitle, LPSTR szAbstract)
{
    CHAR szFormatText[NOTE_TEXT_LENGTH];
    int i;
    ASSERT(szMessage);
    
    if (!szMessage)
        return;


    *szMessage = NULL;

    if (szTitle != NULL) {
        i = MLLoadStringA(IDS_AGNT_SMTPMESSAGE_OTHER, szFormatText, NOTE_TEXT_LENGTH);
        ASSERT(i != 0);
        
        DWORD dwLen = lstrlenA(szFormatText) + lstrlenA(szTitle) + lstrlenA(szAbstract) + 1;

        *szMessage = (LPSTR) MemAlloc(LPTR, dwLen * sizeof(CHAR));
        if (!*szMessage)
            return;

        LPSTR lpArgs[2];
        lpArgs[0] = szTitle;
        lpArgs[1] = szAbstract;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatText, 0, 0, *szMessage, dwLen, (va_list *)&lpArgs[0]);

    } else {
        i = MLLoadStringA(IDS_AGNT_SMTPMESSAGE, szFormatText, NOTE_TEXT_LENGTH);
        ASSERT(i != 0);
        
        DWORD dwLen = lstrlenA(szFormatText) + 2*lstrlenA(szName) + lstrlenA(szURL) + 1;

        *szMessage = (LPSTR) MemAlloc(LPTR, dwLen * sizeof(CHAR));
        if (!*szMessage)
            return;

        LPSTR lpArgs[3];
        lpArgs[0] = lpArgs[1] = szName;
        lpArgs[2] = szURL;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatText, 0, 0, *szMessage, dwLen, (va_list *)&lpArgs[0]);
    }

}


//
// Use the MLANG apis to translate the string
//
// Returns success if translation occurred, fails otherwise
//
// Note if lpszSrcCharSet is NULL then use CP_ACP as the codepage
//

HRESULT TranslateCharset(
    LPSTR lpszSrcString, LPSTR lpszDstString, UINT uiDstSize,
    LPSTR lpszSrcCharset, LPSTR lpszDstCharset
    )
{
    HRESULT hr = E_FAIL;

    WCHAR wszSrcCharset[ENCODING_STRLEN];
    WCHAR wszDstCharset[ENCODING_STRLEN];

    if (lpszSrcString  == NULL || lpszDstString  == NULL || 
        lpszDstCharset == NULL)
    {
        return E_INVALIDARG;
    }

    SHAnsiToUnicode(lpszDstCharset, wszDstCharset, ARRAYSIZE(wszDstCharset));
    if (lpszSrcCharset)
        SHAnsiToUnicode(lpszSrcCharset, wszSrcCharset, ARRAYSIZE(wszSrcCharset));

    LPMULTILANGUAGE2 pIML2 = NULL;

    //
    // Create the MLANG object
    //
    if (SUCCEEDED(CoCreateInstance (CLSID_CMultiLanguage, NULL,
        CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&pIML2)))
    {
        UINT srcCodePage = (UINT)-1, dstCodePage;
        MIMECSETINFO mcsi = {0};

        //
        // First get the source code page either from the passed in string
        // name of source Charset or from the default one if null if passed in
        //
        if (lpszSrcCharset == NULL)
        {
            srcCodePage = GetACP();
            hr = S_OK;
        }
        else
        {
            //
            // Use the mlang object to get the codepages
            //
            hr = pIML2->GetCharsetInfo(wszSrcCharset, &mcsi);
            if (SUCCEEDED(hr))
            {
                srcCodePage = mcsi.uiInternetEncoding;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pIML2->GetCharsetInfo(wszDstCharset, &mcsi);

            if (SUCCEEDED(hr))
            {
                dstCodePage = mcsi.uiInternetEncoding;

                if (srcCodePage != dstCodePage)
                {
                    //
                    // To work around a bug in the Mlang::ConvertString api
                    // have to pass in a ptr to length of the src string
                    //
                    UINT uiSrcSize = lstrlenA(lpszSrcString) + 1;

                    DWORD dwMode = 0;
                    hr = pIML2->ConvertString(
                        &dwMode, 
                        srcCodePage, 
                        dstCodePage,
                        (LPBYTE)lpszSrcString,
                        &uiSrcSize,
                        (LPBYTE)lpszDstString,
                        &uiDstSize);
                }
                else
                {
                    lstrcpynA(lpszDstString, lpszSrcString, uiDstSize);
                }
            }
        }
        pIML2->Release();
    }
    return hr;
}



//////////////////////////////////////////////////////////////////////////
//
// Mail notification implementation
//
//////////////////////////////////////////////////////////////////////////

//
// Notify via email that the pszURL has changed
//
// There are 3 ways to send via email -
//
// Use straight MAPI (IE Exchange or Outlook)
//      Most people don't have Exchange in the real world.
//
// Use Athena's MAPI implementation
//      It's broken and doesn't handle UI'less mode
//
// Use straight SMTP,
//      Need to get the name of an SMTP server
//
HRESULT
NotifyViaEMail(
    LPSTR lpszURL,             // url that was downloaded
    LPSTR lpszEmailAddress,    // email address to send notification to
    LPSTR lpszSMTPServer,      // SMTP server to use to deliver email
    LPSTR &lpszName,           // friendly name of url (probably page title)
    LPSTR lpszTitle,           // optional: NULL if not custom message
    LPSTR lpszAbstract,        // optional: NULL if not custom message
    LPSTR lpszCharSet,         // optional: charset of html page
    BOOL  fSendHTMLEmail )     // TRUE if registry allows it and check mode
                               // supports it.
{
    BOOL b;
    
    LPSTR lpszSMTPMessage;

    //
    // lpszName comes from the title of the web page. If the charset of the page
    // is not the same as the one that this version of IE has been localized to
    // then we need to use the MLANG api's to coerce the string into the correct
    // charset
    //
    CHAR szTargetEncoding[ENCODING_STRLEN];
    MLLoadStringA(IDS_TARGET_CHARSET_EMAIL, szTargetEncoding, ARRAYSIZE(szTargetEncoding));

    //
    // Allocate buffer for new name. This is a conversion from one dbcs charset 
    // to another so size shouldn't but to be safe use *2 multiplier.
    //
    UINT uiSize = lstrlenA(lpszName) * 2;
    LPSTR lpszNewName = (LPSTR) MemAlloc(LMEM_FIXED, uiSize * sizeof(CHAR));

    if (lpszNewName)
    {
        //
        // Note check for S_OK as will return S_FALSE if there is no appropriate
        // translation installed on this machine
        //
        if (S_OK == TranslateCharset(lpszName, lpszNewName, uiSize, lpszCharSet,
                                     szTargetEncoding))
        {
            //
            // if translation occurred alias new name to old name
            //
            SAFELOCALFREE(lpszName);
            lpszName = lpszNewName;
        }
        else
        {
            SAFELOCALFREE(lpszNewName); // don't need newname after all
        }
    }
    
    //
    // If we are requested to HTML mail and we successfully built the html
    //
    if (!(fSendHTMLEmail &&
         BuildHTMLMessage(lpszEmailAddress, lpszName, lpszURL, &lpszSMTPMessage,
                          lpszTitle, lpszAbstract, lpszCharSet)))
    {
        //
        // If sending a simple notification or BuildHTMLMessage failed
        // force fSendHTMLEmail to false and build simple smtp message
        //
        fSendHTMLEmail = FALSE;
        BuildSMTPMessage(lpszName, lpszURL, &lpszSMTPMessage, lpszTitle, lpszAbstract);
    }

    //
    // Send message to given address and from given address
    //
    if (lpszSMTPMessage)
    {
        b = SMTPSendMessage(lpszSMTPServer,  lpszEmailAddress, 
                            lpszEmailAddress, lpszSMTPMessage);

        MemFree(lpszSMTPMessage);

    }
    else
    {
        b = FALSE;
    }

    if (b)
        return S_OK;

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// Helper function to send email
//
//////////////////////////////////////////////////////////////////////////
HRESULT SendEmailFromItem(ISubscriptionItem *pItem)
{
    HRESULT hr = E_FAIL;
    LPSTR pszURL = NULL;
    LPSTR pszName = NULL;
    LPSTR pszTitle = NULL;
    LPSTR pszAbstract = NULL;
    LPSTR pszCharSet = NULL;
    
    // Get the Email URL to send.  Fall back to the download URL.
    ReadAnsiSTR(pItem, c_szPropEmailURL, &pszURL);
    if (!pszURL)
        ReadAnsiSTR(pItem, c_szPropURL, &pszURL);
    ASSERT(pszURL);

    // Get the friendly name.  Fall back to the download URL.
    ReadAnsiSTR(pItem, c_szPropName, &pszName);
    ASSERT(pszName);
    if (!pszName)
        ReadAnsiSTR(pItem, c_szPropURL, &pszName);

    // Get Email Title and Abstract if flag is set.
    DWORD dwEmailFlags = 0;
    ReadDWORD(pItem, c_szPropEmailFlags, &dwEmailFlags);
    if (dwEmailFlags & MAILAGENT_FLAG_CUSTOM_MSG)
    {
        ReadAnsiSTR(pItem, c_szPropEmailTitle, &pszTitle);
        ASSERT(pszTitle);
        ReadAnsiSTR(pItem, c_szPropEmailAbstract, &pszAbstract);
        ASSERT(pszAbstract);
    }

    //
    // Get the charset in the notification
    //
    ReadAnsiSTR(pItem, c_szPropCharSet, &pszCharSet);

    // Get Email address and SMTP server
    TCHAR tszBuf[MAX_PATH];
    CHAR szEmailAddress[MAX_PATH];
    CHAR szSMTPServer[MAX_PATH];
    
    ReadDefaultEmail(tszBuf, ARRAYSIZE(tszBuf));
    SHTCharToAnsi(tszBuf, szEmailAddress, ARRAYSIZE(szEmailAddress));
    ReadDefaultSMTPServer(tszBuf, ARRAYSIZE(tszBuf));
    SHTCharToAnsi(tszBuf, szSMTPServer, ARRAYSIZE(szSMTPServer));

    // Send the email
    if (pszURL && pszName)
    {
        //
        // Check if HTML Mail notification is enabled or disabled thru the registry
        //
        BOOL fSendHTMLEmail = FALSE;

        if (!ReadRegValue(HKEY_CURRENT_USER, c_szRegKey,
            TEXT("EnableHTMLMailNotification"),
            &fSendHTMLEmail, sizeof(fSendHTMLEmail)))
        {
            fSendHTMLEmail = TRUE; // default to on if not read from registry
        }

        // Now make sure our crawling mode supports HTML mail. We don't
        // want to send HTML if we're in check-for-change only.
        DWORD dwTemp = 0;
        ReadDWORD(pItem, c_szPropCrawlChangesOnly, &dwTemp);
        if (dwTemp != 0)
        {
            fSendHTMLEmail = FALSE;
        }
        // else, leave fSendHTMLEmail in its reg-based setting.

        hr = NotifyViaEMail(pszURL, szEmailAddress, szSMTPServer, 
                            pszName, pszTitle, pszAbstract, pszCharSet,
                            fSendHTMLEmail );
    }

    // Clean up.
    SAFELOCALFREE(pszURL);
    SAFELOCALFREE(pszName);
    SAFELOCALFREE(pszTitle);
    SAFELOCALFREE(pszAbstract);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\offl_cpp.h ===
#ifndef OFFLINE_CPP_H
#define OFFLINE_CPP_H

#ifdef __cplusplus

//  #include <debug.h>
//  #include <crtfree.h>

// Forward class declarations
class COfflineFolderEnum;
class COfflineFolder;
class COfflineObjectItem;
class COfflineDropTarget;

#define PROP_WEBCRAWL_SIZE      0x00000001
#define PROP_WEBCRAWL_FLAGS     0x00000002
#define PROP_WEBCRAWL_LEVEL     0x00000004
#define PROP_WEBCRAWL_ACTUALSIZE    0x00000008
#define PROP_WEBCRAWL_URL       0x00000010
#define PROP_WEBCRAWL_NAME      0x00000020
#define PROP_WEBCRAWL_EMAILNOTF 0x00000040
#define PROP_WEBCRAWL_PSWD      0x00000080
#define PROP_WEBCRAWL_UNAME     0x00000100
#define PROP_WEBCRAWL_DESKTOP   0x00000200
#define PROP_WEBCRAWL_RESCH     0x00000400
#define PROP_WEBCRAWL_COOKIE    0x00000800
#define PROP_WEBCRAWL_LAST      0x00001000
#define PROP_WEBCRAWL_STATUS    0x00002000
#define PROP_WEBCRAWL_CHANNEL   0x00004000
#define PROP_WEBCRAWL_PRIORITY  0x00008000
#define PROP_WEBCRAWL_GLEAM     0x00010000
#define PROP_WEBCRAWL_CHANGESONLY   0x00020000
#define PROP_WEBCRAWL_CHANNELFLAGS  0x00040000
#define PROP_WEBCRAWL_ALL       0x0007FFFF
#define PROP_WEBCRAWL_EXTERNAL  PROP_WEBCRAWL_ACTUALSIZE | PROP_WEBCRAWL_URL | \
                                PROP_WEBCRAWL_NAME | PROP_WEBCRAWL_EMAILNOTF | \
                                PROP_WEBCRAWL_RESCH | PROP_WEBCRAWL_LAST | \
                                PROP_WEBCRAWL_DESKTOP | PROP_WEBCRAWL_CHANNEL |\
                                PROP_WEBCRAWL_STATUS | PROP_WEBCRAWL_PRIORITY

#define PROP_GENERAL_MASK       PROP_WEBCRAWL_PSWD | PROP_WEBCRAWL_UNAME
#define PROP_RECEIVING_MASK     PROP_WEBCRAWL_SIZE | PROP_WEBCRAWL_FLAGS | \
                                PROP_WEBCRAWL_CHANGESONLY | PROP_WEBCRAWL_EMAILNOTF \
                                PROP_WEBCRAWL_PRIORITY | PROP_WEBCRAWL_LEVEL | \
                                PROP_WEBCRAWL_CHANNELFLAGS
#define PROP_SCHEDULE_MASK      PROP_WEBCRAWL_CHANNELFLAGS | PROP_WEBCRAWL_RESCH

// Forwawd declarations for create instance functions 
HRESULT COfflineObjectItem_CreateInstance(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);
HRESULT DoDeleteSubscription(POOEntry);
HRESULT FindURLProps(LPCTSTR, PROPVARIANT *);

SUBSCRIPTIONSCHEDULE GetGroup(BOOL bDesktop, const CLSID& clsidDest, 
                              DWORD fChannelFlags, const NOTIFICATIONCOOKIE& groupCookie);
inline SUBSCRIPTIONSCHEDULE GetGroup(POOEBuf pBuf)
{
    ASSERT(pBuf);
    return GetGroup(pBuf->bDesktop, pBuf->clsidDest, pBuf->fChannelFlags, pBuf->groupCookie);
}
inline SUBSCRIPTIONSCHEDULE GetGroup(POOEntry pooe)
{
    ASSERT(pooe);
    return GetGroup(pooe->bDesktop, pooe->clsidDest, pooe->fChannelFlags, pooe->groupCookie);
}

SUBSCRIPTIONTYPE GetItemCategory(BOOL bDesktop, const CLSID& clsidDest);
inline SUBSCRIPTIONTYPE GetItemCategory(POOEBuf pBuf)
{
    ASSERT(pBuf);
    return GetItemCategory(pBuf->bDesktop, pBuf->clsidDest);
}

inline SUBSCRIPTIONTYPE GetItemCategory(POOEntry pEntry)
{
    ASSERT(pEntry);
    return GetItemCategory(pEntry->bDesktop, pEntry->clsidDest);
}

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class COfflineFolderEnum : public IEnumIDList
{
public:
    COfflineFolderEnum(DWORD grfFlags);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods 
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum);

    // Helper functions

    static LPMYPIDL NewPidl(DWORD);
    static void FreePidl(LPMYPIDL);
    static void EnsureMalloc();
    static IMalloc *s_pMalloc;

    HRESULT Initialize(COfflineFolder *pFolder);

protected:
    ~COfflineFolderEnum();

    UINT                m_cRef;      // ref count
    UINT                m_grfFlags;  // enumeration flags 

private:
    ULONG               m_nCount;
    ULONG               m_nCurrent;
    SUBSCRIPTIONCOOKIE  *m_pCookies;
    COfflineFolder      *m_pFolder;
};

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolder Object
//
//////////////////////////////////////////////////////////////////////////////

class COfflineFolder : public IShellFolder, 
                       public IPersistFolder2,
                       public IContextMenu
{
    // COfflineFolder interfaces
    friend COfflineObjectItem;
    friend COfflineDropTarget;
    friend COfflineFolderEnum;
    friend HRESULT OfflineFolderView_CreateInstance(COfflineFolder *pOOFolder, LPCITEMIDLIST pidl, void **ppvOut);
    friend HRESULT OfflineFolderView_DidDragDrop(HWND, IDataObject *pdo, DWORD dwEffect);
    friend LPMYPIDL ScheduleDefault(LPCTSTR, LPCTSTR, COfflineFolder *);
        
public:
    COfflineFolder(void);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved,
            LPOLESTR lpszDisplayName, ULONG *pchEaten,
            LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags,
            LPENUMIDLIST *ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
            REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
            REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
            ULONG * rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IPersist Methods 
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IContextMenu Methods -- This handles the background context menus
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);

protected:
    ~COfflineFolder();

    UINT            _cRef;
    LPITEMIDLIST    _pidl;      //  Clone;
#define VIEWMODE_WEBCRAWLONLY   1
    UINT            viewMode;

};


class COfflineDetails : public IShellDetails
{
public:
    COfflineDetails(HWND hwndOwner);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellDetails Methods
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails);
    STDMETHODIMP ColumnClick(UINT iColumn);

private:
    ~COfflineDetails() {}

    HWND    m_hwndOwner;
    ULONG   m_cRef;
};

////////////////////////////////////////////////////////////////////////////
//
// COfflineObjectItem Object
//
////////////////////////////////////////////////////////////////////////////

class COfflineObjectItem : public IContextMenu, 
                           public IExtractIconA,
                           public IExtractIcon,
                           public IDataObject,
                           public IQueryInfo
{
    // COfflineObjectItem interfaces
    friend HRESULT OfflineFolderView_DidDragDrop(HWND, IDataObject *pdo, DWORD dwEffect);

public:
    COfflineObjectItem();
    HRESULT Initialize(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID,void **);
    
    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
    
    // IDataObject helper functions
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);
    HRESULT _CreateNameMap(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptor(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);

    //  IExtractIconA
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);

    // IExtractIconT Methods
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);
   
    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR ** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

protected:

    ~COfflineObjectItem();

    UINT	                _cRef;       // reference count
    COfflineFolder*         _pOOFolder;   // back pointer to our shell folder
    
    UINT                    _cItems;     // number of items we represent
    LPMYPIDL*               _ppooi;      // variable size array of items
    IUnknown                *m_pUIHelper;  // UI helper. For 1 item only.
    
        
};

class COfflineDropTarget : public IDropTarget
{
private:

    LPDATAOBJECT        m_pDataObj;
    ULONG               m_cRefs;
    DWORD               m_grfKeyStateLast;
    BOOL                m_fHasHDROP;
    BOOL                m_fHasSHELLURL;
    BOOL                m_fHasTEXT;
    DWORD               m_dwEffectLastReturned;
    HWND                m_hwndParent;

public:
    
    COfflineDropTarget(HWND hwndParent);
    ~COfflineDropTarget();

    STDMETHODIMP            QueryInterface      (REFIID riid,LPVOID FAR *ppv);
    STDMETHODIMP_(ULONG)    AddRef              ();
    STDMETHODIMP_(ULONG)    Release             ();
    STDMETHODIMP            DragEnter           (LPDATAOBJECT pDataObj, 
                                                 DWORD        grfKeyState,
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragOver            (DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragLeave           ();
    STDMETHODIMP            Drop                (LPDATAOBJECT pDataObj,
                                                 DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    DWORD                   GetDropEffect       (LPDWORD      pdwEffect);

};

#endif  // __cplusplus

#endif  // OFFLINE_CPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\offsync.cpp ===
#include "private.h"
#include "offsync.h"
#include "throttle.h"
#include "helper.h"
#include "subsmgrp.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_DELAGENT

COfflineSync::COfflineSync()
{
    // Maintain global count of objects
    DllAddRef();

    ASSERT(NULL == m_pThrottler);
    ASSERT(FALSE == m_fCookiesSpecified);

    // Initialize object
    m_cRef = 1;

    DBG("Creating COfflineSync object");
}

COfflineSync::~COfflineSync()
{
    DllRelease();

    Cleanup();

    DBG("Destroying COfflineSync object");

    if (m_pSyncCallback)
    {
        m_pSyncCallback->Release();
    }

    SAFERELEASE(m_pSubsMgr2);
}

void COfflineSync::Cleanup()
{
    if (NULL != m_pThrottler)
    {
        m_pThrottler->Unadvise(this);
        m_pThrottler->Release();
        m_pThrottler = NULL;
    }

    m_hWndParent = NULL;

    if (NULL != m_pSyncCallback)
    {
        m_pSyncCallback->SynchronizeCompleted(m_hrResult);
    }

    m_nItemsToRun = 0;

    SAFEDELETE(m_pItems);
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) COfflineSync::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineSync::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP COfflineSync::QueryInterface(REFIID riid, void ** ppv)
{

    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISyncMgrSynchronize == riid))
    {
        *ppv = (ISyncMgrSynchronize *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

//
// IOfflineSynchronize members
//
HRESULT COfflineSync::Initialize(DWORD dwReserved, DWORD dwSyncFlags,
                                   DWORD cbCookie, const BYTE *lpCookie)
{
    HRESULT hr = S_OK;

    if (SYNCMGRFLAG_INVOKE == (dwSyncFlags & SYNCMGRFLAG_EVENTMASK) )
    {
        ASSERT((0 == cbCookie) || (0 == cbCookie % sizeof(SUBSCRIPTIONCOOKIE)));

        if ((cbCookie != 0) &&
            ((0 != (cbCookie % sizeof(SUBSCRIPTIONCOOKIE))) || (NULL == lpCookie)))
        {
            return E_INVALIDARG;
        }

        if (cbCookie > 0)
        {
            hr = DupItems(cbCookie / sizeof(SUBSCRIPTIONCOOKIE), (SUBSCRIPTIONCOOKIE *)lpCookie);
            if (SUCCEEDED(hr))
            {
                m_fCookiesSpecified = TRUE;
            }
        }
    }

    m_dwSyncFlags = dwSyncFlags;

    return hr;
}

HRESULT COfflineSync::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    HRESULT hr;
    if (NULL == ppSyncMgrHandlerInfo)
    {
        return E_INVALIDARG;
    }

    *ppSyncMgrHandlerInfo = (SYNCMGRHANDLERINFO *)CoTaskMemAlloc(sizeof(SYNCMGRHANDLERINFO));

    if (NULL != *ppSyncMgrHandlerInfo)
    {
        (*ppSyncMgrHandlerInfo)->cbSize = sizeof(SYNCMGRHANDLERINFO);
        (*ppSyncMgrHandlerInfo)->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WEBCHECK));
        (*ppSyncMgrHandlerInfo)->SyncMgrHandlerFlags = 0; //SYNCMGRHANDLER_HASPROPERTIES

        MLLoadStringW(IDS_SYNCMGR_NAME, 
                    (*ppSyncMgrHandlerInfo)->wszHandlerName, 
                    ARRAYSIZE((*ppSyncMgrHandlerInfo)->wszHandlerName));
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT COfflineSync::EnumSyncMgrItems(ISyncMgrEnumItems **ppSyncMgrEnumItems)
{
    HRESULT hr;
    
    if (NULL == ppSyncMgrEnumItems)
    {
        return E_INVALIDARG;
    }

    hr = GetSubsMgr2();

    if (SUCCEEDED(hr))
    {   
        COfflineEnum *pEnum = new COfflineEnum();

        if (NULL != pEnum)
        {
            ASSERT(((TRUE == m_fCookiesSpecified) && ((m_nItemsToRun > 0) && (NULL != m_pItems))) ||
                   ((FALSE == m_fCookiesSpecified) && ((m_nItemsToRun == 0) && (NULL == m_pItems))))

            hr = pEnum->Init(m_pSubsMgr2, m_nItemsToRun, m_pItems, ppSyncMgrEnumItems, m_dwSyncFlags);
            pEnum->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT COfflineSync::GetItemObject(REFSYNCMGRITEMID ItemID, REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

HRESULT COfflineSync::ShowProperties(HWND hWndParent, REFSYNCMGRITEMID ItemID)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;
    ISubscriptionItem *pSubsItem;

    hrTmp = SubscriptionItemFromCookie(FALSE, &ItemID, &pSubsItem);

    if (SUCCEEDED(hrTmp))
    {
        BSTR bstrURL;

        hrTmp = ReadBSTR(pSubsItem, c_szPropURL, &bstrURL);

        if (SUCCEEDED(hrTmp))
        {
            ISubscriptionMgr2 *pSubsMgr2;

            hrTmp = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                  IID_ISubscriptionMgr2, (void **)&pSubsMgr2);

            if (SUCCEEDED(hrTmp))
            {
                BOOL bIsSubscribed;
                
                hrTmp = pSubsMgr2->ShowSubscriptionProperties(bstrURL, hWndParent);

                if (FAILED(pSubsMgr2->IsSubscribed(bstrURL, &bIsSubscribed)) || !bIsSubscribed)
                {
                    hr = S_SYNCMGR_ITEMDELETED;
                }

                pSubsMgr2->Release();
            }

            SysFreeString(bstrURL);
        }
        
        pSubsItem->Release();
    }

    if (NULL != m_pSyncCallback)
    {
        m_pSyncCallback->ShowPropertiesCompleted(hr);
    }

    return hr;
}

HRESULT COfflineSync::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    SAFERELEASE(m_pSyncCallback);
    m_pSyncCallback = lpCallBack;

    if (m_pSyncCallback)
    {
        m_pSyncCallback->AddRef();
    }

    return S_OK;
}

HRESULT COfflineSync::PrepareForSync(ULONG cbNumItems, SYNCMGRITEMID *pItemIDs,
                                     HWND hWndParent, DWORD dwReserved)
{
    HRESULT hr;

    DBG("PrepareForSync");

    if ((0 == cbNumItems) ||
        (NULL == pItemIDs))
    {
        hr = E_INVALIDARG;
    }

    if (NULL == m_pSyncCallback)
    {
        return E_UNEXPECTED;
    }

    hr = DupItems(cbNumItems, pItemIDs);

    m_pSyncCallback->PrepareForSyncCompleted(hr);
    
    return hr;
}

HRESULT COfflineSync::Synchronize(HWND hWndParent)
{
    HRESULT hr;

    m_hrResult = E_FAIL;
    m_hWndParent = hWndParent;

    hr = CThrottler::GetThrottler(&m_pThrottler);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != m_pThrottler);

        hr = m_pThrottler->Advise(this);

        if (SUCCEEDED(hr))
        {
            hr = m_pThrottler->RunCookies(m_nItemsToRun, m_pItems, m_dwSyncFlags);
        }
        //  ************************************************************************
        //  Don't access m_pThrottler after this without checking for NULL since
        //  we could have released it during the call to RunCookies!
        //  ************************************************************************
    }

    if (FAILED(hr))
    {
        Cleanup();
    }
    return hr;
}

HRESULT COfflineSync::SetItemStatus(REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus)
{
    HRESULT hr = S_OK;
    
    if (NULL != m_pThrottler)
    {
        switch (dwSyncMgrStatus)
        {
            case SYNCMGRSTATUS_SKIPPED:
                hr = m_pThrottler->AbortItems(1, &ItemID);
                break;
                
            case SYNCMGRSTATUS_STOPPED:
                hr = m_pThrottler->AbortItems(m_nItemsToRun, m_pItems);
                break;
        }
    }
    else
    {
        ULONG i;
        
        //  This means we are getting called before Synchronize is called
        switch (dwSyncMgrStatus)
        {
            case SYNCMGRSTATUS_SKIPPED:
                for (i = 0; i < m_nItemsToRun; i++)
                {
                    if (ItemID == m_pItems[i])
                    {
                        m_pItems[i] = GUID_NULL;
                    }
                }
                break;
                
            case SYNCMGRSTATUS_STOPPED:
                m_nItemsToRun = 0;
                break;
        }
    }

    return hr;
}

HRESULT COfflineSync::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
    return E_NOTIMPL;
}

HRESULT COfflineSync::UpdateBegin(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    UpdateProgress(pSubscriptionCookie, -1, -1, -1, S_OK, NULL);
    return S_OK;
}

HRESULT COfflineSync::UpdateProgress(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    long lSizeDownloaded,
    long lProgressCurrent,
    long lProgressMax,
    HRESULT hrStatus,
    LPCWSTR wszStatus)
{
    HRESULT hr;

    ASSERT(NULL != m_pSyncCallback);
    ASSERT(NULL != m_pThrottler);

    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        int iProgValue;

        switch (hrStatus)
        {
            case WC_INTERNAL_S_PAUSED:
                iProgValue = SYNCMGRSTATUS_PAUSED;
                break;

            case WC_INTERNAL_S_RESUMING:
                iProgValue = SYNCMGRSTATUS_RESUMING;
                break;

            case WC_INTERNAL_S_PENDING:
                iProgValue = SYNCMGRSTATUS_PENDING;
                break;

            default:
                iProgValue = SYNCMGRSTATUS_UPDATING;
                break;
        }
        
        CallSyncMgrProgress(pSubscriptionCookie, wszStatus, iProgValue,
                            lProgressCurrent, lProgressMax);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT COfflineSync::UpdateEnd(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    long lSizeDownloaded,
    HRESULT hrResult,
    LPCWSTR wszResult)
{
    HRESULT hr;

    int index = FindCookie(pSubscriptionCookie);
    if (index != -1)
    {
        DWORD dwStatus;

        m_pItems[index] = CLSID_NULL;   //  Forget about it
        m_nItemsCompleted++;
        
        if (SUCCEEDED(hrResult))
        {
            dwStatus = SYNCMGRSTATUS_SUCCEEDED;
        }
        else if (E_ABORT == hrResult)
        {
            dwStatus = SYNCMGRSTATUS_SKIPPED;
        }
        else
        {
            dwStatus = SYNCMGRSTATUS_FAILED;
        }

        CallSyncMgrProgress(pSubscriptionCookie, wszResult, dwStatus, 100, 100);

        AreWeDoneYet();
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP COfflineSync::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    HRESULT hr;
    
    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        DWORD dwErrorLevel; 

        switch (hrError)
        {
            case E_ABORT:
                dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
                break;

            case INET_E_AGENT_MAX_SIZE_EXCEEDED:
            case INET_E_SCHEDULED_UPDATES_DISABLED:
            case INET_E_SCHEDULED_UPDATES_RESTRICTED:
            case INET_E_SCHEDULED_UPDATE_INTERVAL:
            case INET_E_SCHEDULED_EXCLUDE_RANGE:
            case INET_E_AGENT_WARNING:
                dwErrorLevel = SYNCMGRLOGLEVEL_WARNING;
                break;

            default:
                dwErrorLevel = FAILED(hrError) ? SYNCMGRLOGLEVEL_ERROR : SYNCMGRLOGLEVEL_INFORMATION;
                break;
        }

        SYNCMGRLOGERRORINFO errInfo;

        errInfo.cbSize = sizeof(SYNCMGRLOGERRORINFO);
        errInfo.mask = SYNCMGRLOGERROR_ITEMID;
        errInfo.ItemID = *pSubscriptionCookie;

        m_pSyncCallback->LogError(dwErrorLevel, wszError, &errInfo);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT COfflineSync::CallSyncMgrProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    const WCHAR *lpcStatusText, DWORD dwStatusType, INT iProgValue, INT iMaxValue)
{
    HRESULT hr = S_OK;
    SYNCMGRPROGRESSITEM smpi;

    ASSERT(NULL != m_pSyncCallback);

    smpi.cbSize = sizeof(SYNCMGRPROGRESSITEM);
    smpi.mask = 0;
  
    if (NULL != lpcStatusText)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_STATUSTEXT;
        smpi.lpcStatusText = lpcStatusText;
    }

    if ((DWORD)(-1) != dwStatusType)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_STATUSTYPE;
        smpi.dwStatusType = dwStatusType;
    }

    if (iProgValue >= 0)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_PROGVALUE;
        smpi.iProgValue = iProgValue;
    }

    if (iMaxValue >= 0)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_MAXVALUE;
        smpi.iMaxValue = iMaxValue;
    }

    //  We still call progress even if smpi.mask is 0 just in case we should
    //  respond to a cancel.

    HRESULT hrProgress = m_pSyncCallback->Progress(*pSubscriptionCookie, &smpi);
    
    switch(hrProgress)
    {
        case S_SYNCMGR_CANCELITEM:
            m_pThrottler->AbortItems(1, pSubscriptionCookie);
            break;
            
        case S_SYNCMGR_CANCELALL:
            m_pThrottler->AbortAll();
            break;
    }

    return hr;
}

HRESULT COfflineSync::UpdateSyncMgrStatus(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
    LPCWSTR wszStatusMsg, DWORD dwStatus)
{
    HRESULT hr;

    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        CallSyncMgrProgress(pSubscriptionCookie, wszStatusMsg, dwStatus, -1, -1);

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT COfflineSync::DupItems(ULONG cbNumItems, SUBSCRIPTIONCOOKIE *pItemIDs)
{
    HRESULT hr;
    
    ASSERT(0 != cbNumItems);
    ASSERT(NULL != pItemIDs);
    ASSERT((0 == m_nItemsToRun) || (TRUE == m_fCookiesSpecified));

    if (NULL != m_pItems)
    {
        delete [] m_pItems;
    }

    m_pItems = new SUBSCRIPTIONCOOKIE[cbNumItems];

    if (NULL != m_pItems)
    {
        memcpy(m_pItems, pItemIDs, cbNumItems * sizeof(SUBSCRIPTIONCOOKIE));
        m_nItemsToRun = cbNumItems;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

BOOL COfflineSync::AreWeDoneYet()
{
    BOOL rc;

    if (m_nItemsCompleted != m_nItemsToRun)
    {
        rc = FALSE;
    }
    else
    {
        Cleanup();
        rc = TRUE;
    }

    return rc;
}

HRESULT COfflineSync::GetSubsMgr2()
{
    HRESULT hr = S_FALSE;

    if (NULL == m_pSubsMgr2)
    {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                IID_ISubscriptionMgr2, (void**)&m_pSubsMgr2);

        if (FAILED(hr))
        {
            DBG_WARN("Failed to allocate subscription store (aborting)");
        }
    }

    return hr;
}

//  returns index into m_pItems on success, -1 on failure
int COfflineSync::FindCookie(const SUBSCRIPTIONCOOKIE *pCookie)
{
    int index = -1;

    if (NULL != m_pItems)
    {
        for (ULONG i = 0; i < m_nItemsToRun; i++)
        {
            if (m_pItems[i] == *pCookie)
            {
                index = i;
                break;
            }
        }
    }

    return index;
}

COfflineEnum::COfflineEnum()
{
    ASSERT(NULL == m_pItems);
    ASSERT(0 == m_iNumItems);

    // Maintain global count of objects
    DllAddRef();

    // Initialize object
    m_cRef = 1;
}

COfflineEnum::~COfflineEnum()
{
    DllRelease();

    SAFELOCALFREE(m_pItems);
}

HRESULT COfflineEnum::LoadItem(ISubscriptionMgr2 *pSubsMgr2, 
    const SUBSCRIPTIONCOOKIE *pCookie, SYNCMGRITEM *pItem, DWORD dwItemState)
{
    HRESULT hr;
    ISubscriptionItem *pSubItem;

    ASSERT(NULL != pSubsMgr2);

    hr = pSubsMgr2->GetItemFromCookie(pCookie, &pSubItem);
    if (SUCCEEDED(hr))
    {
        BSTR bstrName;
       
        pItem->cbSize = sizeof(SYNCMGRITEM);
        pItem->dwFlags = SYNCMGRITEM_HASPROPERTIES;
        pItem->ItemID = *pCookie;
        pItem->dwItemState = dwItemState;

        DATE dt;
        
        if (SUCCEEDED(ReadDATE(pSubItem, c_szPropCompletionTime, &dt)))
        {
            FILETIME ft;
            pItem->dwFlags |= SYNCMGRITEM_LASTUPDATETIME;

            VariantTimeToFileTime(dt, ft);
            LocalFileTimeToFileTime(&ft, &pItem->ftLastUpdate);
        }

        ReadBSTR(pSubItem, c_szPropName, &bstrName);

        if (NULL != bstrName)
        {
            StrCpyNW(pItem->wszItemName, bstrName, ARRAYSIZE(pItem->wszItemName));

            SysFreeString(bstrName);
        }
        else
        {
            ASSERT(L'\0' == pItem->wszItemName[0]);
        }

        pItem->hIcon = LoadItemIcon(pSubItem, FALSE);

        pSubItem->Release();
    }

    return hr;
}

HRESULT COfflineEnum::Init(ISubscriptionMgr2 *pSubsMgr2, ULONG nItems, 
    SUBSCRIPTIONCOOKIE *pInitCookies, ISyncMgrEnumItems **ppenum, DWORD dwSyncFlags)
{
    HRESULT hr = E_FAIL;
    DWORD dwCheckState;

    ASSERT(NULL != ppenum);

    if ((NULL == pSubsMgr2) || 
        (NULL == ppenum) ||
        ((nItems > 0) && (pInitCookies == NULL)))
    {
        return E_UNEXPECTED;
    }

    switch (dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
    {
        case SYNCMGRFLAG_CONNECT:           // Sync was invoked by a network connect
        case SYNCMGRFLAG_PENDINGDISCONNECT: // Sync was invoked by a pending network disconnect
        case SYNCMGRFLAG_MANUAL:            // Sync was invoked manually
        case SYNCMGRFLAG_IDLE:              // Sync was programmatically invokd
        case SYNCMGRFLAG_INVOKE:            // Sync was programmatically invokd
        case SYNCMGRFLAG_SCHEDULED:         // Sync was invoked by a scheduled update
            dwCheckState = SYNCMGRITEMSTATE_CHECKED;
            break;
            
        default:
            dwCheckState = SYNCMGRITEMSTATE_UNCHECKED;
            break;
    }

    // Enumerate cookies
    m_iEnumPtr = 0;

    if (0 == nItems)
    {
        IEnumSubscription *pEnumSubscriptions;

        hr = pSubsMgr2->EnumSubscriptions(0, &pEnumSubscriptions);

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pEnumSubscriptions);

            pEnumSubscriptions->GetCount(&m_iNumItems);

            SUBSCRIPTIONCOOKIE *pCookies = (SUBSCRIPTIONCOOKIE *)MemAlloc(LMEM_FIXED, 
                m_iNumItems * sizeof(SUBSCRIPTIONCOOKIE));

            m_pItems = (SYNCMGRITEM *)MemAlloc(LMEM_FIXED, m_iNumItems * sizeof(SYNCMGRITEM));

            if ((NULL != m_pItems) && (NULL != pCookies))
            {
                hr = pEnumSubscriptions->Next(m_iNumItems, pCookies, &m_iNumItems);

                SYNCMGRITEM *pItem = m_pItems;

                for (ULONG i = 0; i < m_iNumItems; i++, pItem++)
                {
                    hr = LoadItem(pSubsMgr2, &pCookies[i], pItem, 
                                  dwCheckState);

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SAFELOCALFREE(pCookies);

            pEnumSubscriptions->Release();
        }
    }
    else
    {
        m_pItems = (SYNCMGRITEM *)MemAlloc(LMEM_FIXED, nItems * sizeof(SYNCMGRITEM));
        if (NULL != m_pItems)
        {
            SYNCMGRITEM *pItem = m_pItems;
            SUBSCRIPTIONCOOKIE *pCurCookie = pInitCookies;

            m_iNumItems = nItems;

            for (ULONG i = 0; i < m_iNumItems; i++, pCurCookie++, pItem++)
            {
                hr = LoadItem(pSubsMgr2, pCurCookie, pItem, dwCheckState);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
   }

    if (SUCCEEDED(hr))
    {
        //  If we were invoked programatically, then tell syncmgr to leave
        //  item preferences alone.
        hr = (nItems == 0) ? S_OK : S_OK; // TODO: S_SYNCMGR_MISSINGITEMS;
        *ppenum = this;
        AddRef();
    }

    return hr;
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) COfflineEnum::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineEnum::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP COfflineEnum::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISyncMgrEnumItems == riid))
    {
        *ppv = (ISyncMgrEnumItems *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IEnumOfflineItems members
STDMETHODIMP COfflineEnum::Next(ULONG celt, LPSYNCMGRITEM rgelt, ULONG *pceltFetched)
{
    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    if (!m_pItems)
    {
        return E_FAIL;
    }

    *pceltFetched = 0;
    ULONG ul;

    for (ul=0; (ul<celt) && (m_iEnumPtr<m_iNumItems); m_iEnumPtr++)
    {
        *rgelt = m_pItems[m_iEnumPtr];
        rgelt ++; ul++;
    }

    *pceltFetched = ul;

    return (ul == celt) ? S_OK : S_FALSE;
}

STDMETHODIMP COfflineEnum::Skip(ULONG celt)
{
    m_iEnumPtr += celt;
    if (m_iEnumPtr > m_iNumItems)
    {
        m_iEnumPtr = m_iNumItems;
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP COfflineEnum::Reset(void)
{
    m_iEnumPtr = 0;
    return S_OK;
}

STDMETHODIMP COfflineEnum::Clone(ISyncMgrEnumItems **ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\offsync.h ===
//
// OneStop Offline Synch handler
//

#ifndef _OFFSYNC_H
#define _OFFSYNC_H

class CThrottler;

class COfflineSync : public ISyncMgrSynchronize,
                     public ISubscriptionAgentEvents
{
private:
    ~COfflineSync();
    ULONG           m_cRef;

    ISyncMgrSynchronizeCallback *m_pSyncCallback;
    ISubscriptionMgr2           *m_pSubsMgr2;

    DWORD               m_dwSyncFlags;
    HWND                m_hWndParent;
    CThrottler          *m_pThrottler;
    HRESULT             m_hrResult;

    ULONG               m_nItemsToRun;
    ULONG               m_nItemsCompleted;

    BOOL                m_fCookiesSpecified;
    
    SUBSCRIPTIONCOOKIE  *m_pItems;

    void Cleanup();
    BOOL AreWeDoneYet();
    HRESULT GetSubsMgr2();
    int FindCookie(const SUBSCRIPTIONCOOKIE *pCookie);
    HRESULT DupItems(ULONG cbNumItems, SUBSCRIPTIONCOOKIE *pItemIDs);

    HRESULT CallSyncMgrProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        const WCHAR *lpcStatusText, DWORD dwStatusType, INT iProgValue, INT iMaxValue);

public:
    COfflineSync();

    HWND GetParentWindow() { return m_hWndParent; }

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ISyncMgrSynchronize members
    STDMETHODIMP Initialize( 
        /* [in] */ DWORD dwReserved,
        /* [in] */ DWORD dwSyncMgrFlags,
        /* [in] */ DWORD cbCookie,
        /* [in] */ const BYTE *lpCookie);
    
    STDMETHODIMP GetHandlerInfo( 
        /* [out] */ LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    
    STDMETHODIMP EnumSyncMgrItems( 
        /* [out] */ ISyncMgrEnumItems **ppSyncMgrEnumItems);
    
    STDMETHODIMP GetItemObject( 
        /* [in] */ REFSYNCMGRITEMID ItemID,
        /* [in] */ REFIID riid,
        /* [out] */ void **ppv);
    
    STDMETHODIMP ShowProperties( 
        /* [in] */ HWND hWndParent,
        /* [in] */ REFSYNCMGRITEMID ItemID);
    
    STDMETHODIMP SetProgressCallback( 
        /* [in] */ ISyncMgrSynchronizeCallback *lpCallBack);
    
    STDMETHODIMP PrepareForSync( 
        /* [in] */ ULONG cbNumItems,
        /* [in] */ SYNCMGRITEMID *pItemIDs,
        /* [in] */ HWND hWndParent,
        /* [in] */ DWORD dwReserved);
    
    STDMETHODIMP Synchronize( 
        /* [in] */ HWND hWndParent);
    
    STDMETHODIMP SetItemStatus( 
        /* [in] */ REFSYNCMGRITEMID ItemID,
        /* [in] */ DWORD dwSyncMgrStatus);
    
    STDMETHODIMP ShowError( 
        /* [in]  */ HWND hWndParent,
        /* [in]  */ REFSYNCMGRERRORID ErrorID);

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);

    STDMETHODIMP UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus);

    STDMETHODIMP UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult);

    STDMETHODIMP ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError);

    HRESULT UpdateSyncMgrStatus(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        LPCWSTR wszStatusMsg, DWORD dwStatus);

};

class COfflineEnum : public ISyncMgrEnumItems
{
private:
    ~COfflineEnum();
    ULONG           m_cRef;

    SYNCMGRITEM    *m_pItems;
    ULONG           m_iNumItems;
    ULONG           m_iEnumPtr;

    HRESULT LoadItem(ISubscriptionMgr2 *pSubsMgr2, 
        const SUBSCRIPTIONCOOKIE *pCookie, SYNCMGRITEM *pItem, DWORD dwItemState);

public:
    COfflineEnum();

    HRESULT Init(ISubscriptionMgr2 *pSubsMgr2, ULONG nItems, 
            SUBSCRIPTIONCOOKIE *pInitCookies, ISyncMgrEnumItems **ppenum, DWORD dwSyncFlags);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumOfflineItems members
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ LPSYNCMGRITEM rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ ISyncMgrEnumItems **ppenum);
};

#include "throttle.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\notfcvt.cpp ===
#include "private.h"
#include "notfcvt.h"
#include "subsmgrp.h"
#include "subitem.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "helper.h"
#include "shguidp.h"    // IID_IChannelMgrPriv

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE   TF_ADMIN

const CHAR c_pszRegKeyNotfMgr[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr";
const CHAR c_pszRegKeyScheduleItems[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr\\SchedItems 0.6";
const CHAR c_pszRegKeyScheduleGroup[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr\\ScheduleGroup 0.6";

const WCHAR c_wszIE4IntlPre[]  = L"http://www.microsoft.com/ie_intl/";
const WCHAR c_wszIE4IntlPre2[] = L"http://www.microsoft.com/windows/ie_intl/";
const WCHAR c_wszIE4IntlPost[] = L"/ie40/download/cdf/ie4updates-";
const WCHAR c_wszIE4English[]  = L"http://www.microsoft.com/ie/ie40/download/cdf/ie4updates-";
const WCHAR c_wszIE4English2[] = L"http://www.microsoft.com/windows/ie/ie40/download/cdf/ie4updates-";

HRESULT ConvertNotfMgrScheduleGroup(NOTIFICATIONCOOKIE *pSchedCookie);

BOOL IsIE4UpdateChannel(LPCWSTR pwszURL)
{
    BOOL bResult = FALSE;
    int len = lstrlenW(pwszURL);

    //  For update channels from the non-international version, simply compare the 
    //  English base name witht the passed in URL.
    //
    //  International update channels look like:
    //      http://www.microsoft.com/ie_intl/XX/ie40/download/cdf/ie4updates-XX.cdf
    //  So we do two compares skipping the middle XX
    
    if (
        (   
            (len > ARRAYSIZE(c_wszIE4English)) && 
            (0 == memcmp(c_wszIE4English, pwszURL, sizeof(c_wszIE4English) - sizeof(WCHAR)))
        )       
        ||
        (   
            (len > ARRAYSIZE(c_wszIE4English2)) && 
            (0 == memcmp(c_wszIE4English2, pwszURL, sizeof(c_wszIE4English2) - sizeof(WCHAR)))
        )       
        ||
        (
            (len > (ARRAYSIZE(c_wszIE4IntlPre) + ARRAYSIZE(c_wszIE4IntlPost) + 4)) &&
            (0 == memcmp(c_wszIE4IntlPre, pwszURL, sizeof(c_wszIE4IntlPre)  - sizeof(WCHAR))) &&
            (0 == memcmp(c_wszIE4IntlPost, pwszURL + ARRAYSIZE(c_wszIE4IntlPre) + 1, 
                         sizeof(c_wszIE4IntlPost) - sizeof(WCHAR)))
        )
        ||
        (
            (len > (ARRAYSIZE(c_wszIE4IntlPre2) + ARRAYSIZE(c_wszIE4IntlPost) + 4)) &&
            (0 == memcmp(c_wszIE4IntlPre2, pwszURL, sizeof(c_wszIE4IntlPre2)  - sizeof(WCHAR))) &&
            (0 == memcmp(c_wszIE4IntlPost, pwszURL + ARRAYSIZE(c_wszIE4IntlPre2) + 1, 
                         sizeof(c_wszIE4IntlPost) - sizeof(WCHAR)))
        )
       )
    {
        bResult = TRUE;
    }

    return bResult;
}

struct NOTFSUBS
{
    NOTIFICATIONITEM        ni;
    NOTIFICATIONITEMEXTRA   nix;
    CLSID                   clsidItem;  //  Ignore
    NOTIFICATIONCOOKIE      notfCookie;
    NOTIFICATIONTYPE        notfType;
    ULONG                   nProps;

    // Variable length data here:
    //SaveSTATPROPMAP       statPropMap;
    //char                  szPropName[];
    //BYTE                  variant property data

    //...

    //SaveSTATPROPMAP       statPropMap;
    //char                  szPropName[];
    //BYTE                  variant property data
};

HRESULT SubscriptionFromNotification(NOTFSUBS *pns, 
                                     LPCWSTR pwszURL,
                                     LPCWSTR pwszName,
                                     const LPWSTR rgwszName[], 
                                     VARIANT rgValue[])
{
    HRESULT hr;

    ASSERT(NULL != pns);
    ASSERT(NULL != rgwszName);
    ASSERT(NULL != rgValue);

    if ((pns->ni.NotificationType == NOTIFICATIONTYPE_AGENT_START) &&
        (pns->nix.PackageFlags & PF_SCHEDULED) &&
        (NULL != pwszURL) &&
        (NULL != pwszName) &&
        (!IsIE4UpdateChannel(pwszURL)))
    {

        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
        sii.dwFlags = 0;
        sii.dwPriority = 0;
        sii.ScheduleGroup = CLSID_NULL;
        sii.clsidAgent = pns->ni.clsidDest;

        hr = AddUpdateSubscription(&pns->notfCookie,
                                   &sii,
                                   pwszURL,
                                   pns->nProps,
                                   rgwszName,
                                   rgValue);

        if (SUCCEEDED(hr))
        {
            if (NOTFCOOKIE_SCHEDULE_GROUP_MANUAL != pns->ni.groupCookie)
            {
                ISubscriptionItem *psi;

                hr = SubscriptionItemFromCookie(FALSE, &pns->notfCookie, &psi);

                if (SUCCEEDED(hr))
                {
                    SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;

                    if (GUID_NULL == pns->ni.groupCookie)
                    {
                        WCHAR wszSchedName[MAX_PATH];

                        CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                                     NULL, pwszName);

                        //  Create the schedule
                        hr = CreateSchedule(wszSchedName, SYNCSCHEDINFO_FLAGS_READONLY, 
                                            &schedCookie, &pns->ni.TaskTrigger, FALSE);

                        //  If we created a new one or for some strange reason
                        //  "MSN Recommended Schedule" already exists we go with it
                        if (SUCCEEDED(hr) || (hr == SYNCMGR_E_NAME_IN_USE))
                        {
                            //  sii should have been initialized and set above
                            ASSERT(sizeof(SUBSCRIPTIONITEMINFO) == sii.cbSize);
                            ASSERT(GUID_NULL == sii.ScheduleGroup);

                            sii.ScheduleGroup = schedCookie;
                            hr = psi->SetSubscriptionItemInfo(&sii);
                        }
                    }
                    else
                    {
                        schedCookie = pns->ni.groupCookie;
                        hr = ConvertNotfMgrScheduleGroup(&schedCookie);
                    }

                    if (SUCCEEDED(hr))
                    {
                        SYNC_HANDLER_ITEM_INFO shii;

                        shii.handlerID = CLSID_WebCheckOfflineSync;
                        shii.itemID = pns->notfCookie;
                        shii.hIcon = NULL;
                        StrCpyNW(shii.wszItemName, pwszName, ARRAYSIZE(shii.wszItemName));
                        shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

                        //  Not much we can do if this fails other than jump up and down
                        //  and scream like a baby.
                        hr = AddScheduledItem(&shii, &schedCookie);
                    }
                    psi->Release();
                }
            }
        }
    }
    else
    {
        TraceMsgA(TF_THISMODULE, "Not converting Notification subscription %S URL: %S", pwszName, pwszURL);
        hr = S_FALSE;
    }

    return hr;
}

HRESULT ConvertScheduleItem(CHAR *pszSubsName)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;
    CHAR szKeyName[MAX_PATH];

    //  Build path to this notification item
    StrCpyNA(szKeyName, c_pszRegKeyScheduleItems, ARRAYSIZE(szKeyName));
    StrCatBuffA(szKeyName, "\\", ARRAYSIZE(szKeyName));
    StrCatBuffA(szKeyName, pszSubsName, ARRAYSIZE(szKeyName));

    //  We just enumerated so this should be here!
    if (RegOpenKeyExA(HKEY_CURRENT_USER, szKeyName, 0, KEY_READ, &hkey) 
        == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        //  Read the {GUID} value.  We need to alloc a buffer but don't know how big yet.
        //  This gets us the size and type.  If it's not binary or not big enough, bail.
        if ((RegQueryValueExA(hkey, pszSubsName, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS) &&
            (dwType == REG_BINARY) &&
            (dwSize >= sizeof(NOTFSUBS)))
        {
            BYTE *pData = new BYTE[dwSize];

            if (NULL != pData)
            {
                if (RegQueryValueExA(hkey, pszSubsName, NULL, &dwType, pData, &dwSize) == ERROR_SUCCESS)
                {
                    //  Shouldn't have gotten here based on the check above.
                    ASSERT(dwType == REG_BINARY);
                    ASSERT(dwSize >= sizeof(NOTFSUBS));

                    ULONG i;
                    NOTFSUBS *pns = (NOTFSUBS *)pData;

                    //  Point to the repeated variable size block
                    BYTE *pVarData = pData + FIELD_OFFSET(NOTFSUBS, nProps) + sizeof(ULONG);

                    //  Allocate buffers to hold the arrays of property names and values
                    WCHAR **ppwszPropNames = new WCHAR *[pns->nProps];
                    VARIANT *pVars = new VARIANT[pns->nProps];
                    WCHAR *pwszURL = NULL;
                    WCHAR *pwszName = NULL;

                    if ((NULL != ppwszPropNames) && (NULL != pVars))
                    {
                        //  adjust size remaining
                        dwSize -= sizeof(NOTFSUBS);

                        for (i = 0, hr = S_OK; 
                             (i < pns->nProps) && (dwSize >= sizeof(SaveSTATPROPMAP)) &&
                                 SUCCEEDED(hr);
                             i++)
                        {
                            SaveSTATPROPMAP *pspm = (SaveSTATPROPMAP *)pVarData;
                            CHAR *pszPropName = (CHAR *)(pVarData + sizeof(SaveSTATPROPMAP));
                            DWORD cbUsed;

                            ppwszPropNames[i] = new WCHAR[pspm->cbStrLen + 1];
                            if (NULL == ppwszPropNames[i])
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            MultiByteToWideChar(CP_ACP, 0, pszPropName, pspm->cbStrLen, 
                                                ppwszPropNames[i], pspm->cbStrLen);

                            //  Point to where the variant blob starts
                            pVarData += sizeof(SaveSTATPROPMAP) + pspm->cbStrLen;

                            //  adjust size remaining
                            dwSize -= sizeof(SaveSTATPROPMAP) + pspm->cbStrLen;
                            
                            hr = BlobToVariant(pVarData, dwSize, &pVars[i], &cbUsed, TRUE);

                            if ((3 == pspm->cbStrLen)
                                && (StrCmpNIA(pszPropName, "URL", 3) == 0))
                            {
                                pwszURL = pVars[i].bstrVal;
                            }
                            else if ((4 == pspm->cbStrLen)
                                && (StrCmpNIA(pszPropName, "Name", 4) == 0))
                            {
                                pwszName = pVars[i].bstrVal; 
                            }

                            //  Point to start of next SaveSTATPROPMAP
                            pVarData += cbUsed;

                            //  adjust size remaining
                            dwSize -= cbUsed;
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = SubscriptionFromNotification(pns, 
                                                              pwszURL,
                                                              pwszName,
                                                              ppwszPropNames, 
                                                              pVars);
                        }
                        else
                        {
                            TraceMsgA(TF_THISMODULE, "Not converting notification subscription %s", pszSubsName);
                        }

                        for (i = 0; i < pns->nProps; i++)
                        {
                            if (ppwszPropNames[i])
                            {
                                delete [] ppwszPropNames[i];
                            }
                            VariantClear(&pVars[i]);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    SAFEDELETE(ppwszPropNames);
                    SAFEDELETE(pVars);
                }
                delete [] pData;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT ConvertNotfMgrSubscriptions()
{
    HRESULT hr = S_OK;
    HKEY hkey;

    if (RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegKeyScheduleItems, 0, KEY_READ, &hkey) 
        == ERROR_SUCCESS)
    {
        int i = 0;
        CHAR szSubsName[MAX_PATH];

        TraceMsg(TF_THISMODULE, "Converting Notification Mgr subscriptions");

        while (RegEnumKeyA(hkey, i++, szSubsName, sizeof(szSubsName)) == ERROR_SUCCESS)
        {
            HRESULT hrConvert = ConvertScheduleItem(szSubsName);
            if (FAILED(hrConvert))
            {
                ASSERT(0);
                hr = S_FALSE;
                //  Something failed, should we break or keep on truckin'?
                //  break;
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_THISMODULE, "No Notification Mgr subscriptions to convert");
        //  No Notification Manager schedule items key so there's nothing to do...
        hr = S_FALSE;
    }

    return hr;
}

struct NOTFSCHED
{
    SCHEDULEGROUPITEM   sgi;
    DWORD               cchName;
    WCHAR               wszName[1];   //  varies depending on cchName
};

HRESULT ConvertNotfMgrScheduleGroup(NOTIFICATIONCOOKIE *pSchedCookie)
{
    HRESULT hr = S_OK;

    if (!ScheduleCookieExists(pSchedCookie))
    {
        HKEY hkey;
        DWORD dwResult;

        dwResult = RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegKeyScheduleGroup, 0, KEY_READ, &hkey);

        if (ERROR_SUCCESS == dwResult)
        {
            TCHAR szGuid[GUIDSTR_MAX];
            DWORD dwType;
            DWORD cbSize;
            
            SHStringFromGUID(*pSchedCookie, szGuid, ARRAYSIZE(szGuid));

            dwResult = RegQueryValueEx(hkey, szGuid, NULL, &dwType, NULL, &cbSize);

            if (ERROR_SUCCESS == dwResult)
            {
                BYTE *pData = new BYTE[cbSize];

                if (NULL != pData)
                {
                    dwResult = RegQueryValueEx(hkey, szGuid, NULL, &dwType, pData, &cbSize);
                    
                    if (ERROR_SUCCESS == dwResult)
                    {                          
                        if (dwType == REG_BINARY)
                        {
                            NOTFSCHED *pns = (NOTFSCHED *)pData;

                            hr = CreateSchedule(pns->wszName, 0, &pns->sgi.GroupCookie, 
                                                &pns->sgi.TaskTrigger, TRUE);
                                                 
                            if (SYNCMGR_E_NAME_IN_USE == hr)
                            {
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwResult);
                    }

                    delete [] pData;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwResult);
            }
            RegCloseKey(hkey);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}

HRESULT WhackIE4UpdateChannel()
{
    HRESULT hr;
    IChannelMgr *pChannelMgr;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IChannelMgr, (void**)&pChannelMgr);

    if (SUCCEEDED(hr))
    {
        IEnumChannels *pEnumChannels;

        hr = pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH | CHANENUM_URL,
                                       NULL, &pEnumChannels);

        if (SUCCEEDED(hr))
        {
            CHANNELENUMINFO cei;

            while (S_OK == pEnumChannels->Next(1, &cei, NULL))
            {
                if (IsIE4UpdateChannel(cei.pszURL))
                {
                    TraceMsgA(TF_THISMODULE, "Whacking IE 4 update channel: %S %S", cei.pszURL, cei.pszPath);
                    hr = pChannelMgr->DeleteChannelShortcut(cei.pszPath);

                    ASSERT(SUCCEEDED(hr));
                }

                CoTaskMemFree(cei.pszURL);
                CoTaskMemFree(cei.pszPath);
            }
            pEnumChannels->Release();
        }
        pChannelMgr->Release();
    }

    return hr;
}

HRESULT ConvertIE4Subscriptions()
{
    HRESULT hr;

    hr = ConvertNotfMgrSubscriptions();
    
    ASSERT(SUCCEEDED(hr));

    hr = WhackIE4UpdateChannel();

    ASSERT(SUCCEEDED(hr));
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\postagnt.cpp ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//

#include "private.h"
#include "downld.h"
#include "urlmon.h"

#undef TF_THISMODULE
#define TF_THISMODULE   TF_POSTAGENT

// Advanced inetcpl setting to disable channel logging
const TCHAR c_szNoChannelLogging[] = TEXT("NoChannelLogging");

const char c_szHeaders[] = "Content-Type: application/x-www-form-urlencoded\r\n";
#define c_ccHearders  (ARRAYSIZE(c_szHeaders) - 1)

#define ENCODE_LOG
#ifdef ENCODE_LOG
const char c_szEncodeHeader[] = "Content-Transfer-Encoding: x-";
#define c_ccEncodeHeader (ARRAYSIZE(c_szEncodeHeader) - 1)
#endif  //ENCODE_LOG

// *** W3C extended log format *** //
// text strings definitions
const char c_szUrlFields[] = "#Fields: s-URI";
#define c_ccUrlFields  (ARRAYSIZE(c_szUrlFields) - 1)

const char c_szLogFields[] = "#Fields: x-context x-cache x-date x-time x-duration x-meta";
#define c_ccLogFields  (ARRAYSIZE(c_szLogFields) - 1);
// *** W3C extended log format *** //

const TCHAR c_szPostRetryReg[] = TEXT("PostRetry");
const TCHAR c_szUserAgent[] = TEXT("User Agent");
extern TCHAR szInternetSettings[];

//-----------------------------------------------------------------------------
//
// CTrackingStg implementation
//
//-----------------------------------------------------------------------------

// this will empty log contents without removing the entry
//
HRESULT	CTrackingStg::EmptyCacheEntry(GROUPID enumId)
{
    HANDLE      hEnum, hFile;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;
    DWORD       cbSize;
    HRESULT     hr = S_OK;

    ASSERT(enumId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                     0,              //dwFlags
                                     URLCACHE_FIND_DEFAULT_FILTER,  //dwFilters,
                                     0,             //enumId, IE50:wininet change, not support group in extensible cache
                                     lpCE,
                                     &cbSize,
                                     NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;

        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime &&
                lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {
                hFile = OpenItemLogFile(lpCE->lpszLocalFileName);
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFile);
                    DeleteFileA(lpCE->lpszLocalFileName);

                    DeleteUrlCacheEntryA(lpCE->lpszSourceUrlName);
                    
                    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
                    SHAnsiToTChar(lpCE->lpszSourceUrlName, szUrl, ARRAYSIZE(szUrl));
                    CreateLogCacheEntry(szUrl, lpCE->ExpireTime,
                                         ftModified, lpCE->CacheEntryType);
                }

            }
            
            // reuse lpCE
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                //  This code used to check GetLastError() for ERROR_NO_MORE_ITEMS before
                //  it would break.  Well, that could put us in an infinite loop if the
                //  reason for failure were something else (like insufficient buffer) because
                //  wininet would not move forward in it's enumeration and we would not
                //  have done anything to address the error.
                break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

// this will delete url cache entries 
// and delete url cache group
HRESULT	CTrackingStg::RemoveCacheEntry(GROUPID enumId)
{
    HANDLE      hEnum;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;
    DWORD       cbSize;
    PROPVARIANT vProp = {0};
    HRESULT     hr = S_OK;

    ASSERT(enumId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                     0,              //dwFlags
                                     URLCACHE_FIND_DEFAULT_FILTER,   //dwFilters,
                                     0,              //enumId, IE50: wininet change
                                     lpCE,
                                     &cbSize,
                                     NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;

        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime &&
                lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {
                DeleteUrlCacheEntryA(lpCE->lpszSourceUrlName);
                vProp.vt = VT_UI4;
                vProp.ulVal = 0;            // clear tracking flag

                TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
                SHAnsiToTChar(lpCE->lpszSourceUrlName+lstrlenA(_lpPfx), szUrl, ARRAYSIZE(szUrl));
                hr = IntSiteHelper(szUrl,
                                   &c_rgPropRead[PROP_TRACKING], &vProp, 1, TRUE);
                PropVariantClear( &vProp );        
            }
            
            // reuse lpCE
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

HANDLE CTrackingStg::OpenItemLogFile(LPCSTR lpFile)
{
   HANDLE   hFile = NULL;

    hFile = CreateFileA(lpFile, 
                GENERIC_READ | GENERIC_WRITE,
                0,                              //no sharing
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    return hFile;
}

DWORD CTrackingStg::ReadLogFile(LPCSTR lpFile, LPSTR* lplpbuf)
{
    HANDLE  hFile = NULL;
    DWORD   cbFile = 0;
    DWORD   cbRead;

    hFile = OpenItemLogFile(lpFile);
    if (hFile == INVALID_HANDLE_VALUE) 
        return 0;

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        CloseHandle(hFile);
        return 0;
    }
        
    *lplpbuf = (LPSTR)MemAlloc(LPTR, (cbFile + 2) * sizeof(CHAR));
    cbRead = 0;
    if (!ReadFile(hFile, *lplpbuf, cbFile, &cbRead, NULL))
    {
        cbRead = 0;
    }    
        
    ASSERT((cbRead == cbFile));
    CloseHandle(hFile);
    return cbRead;
}


void CTrackingStg::AppendLogEntries(LPINTERNET_CACHE_ENTRY_INFOA lpce)
{
    LPSTR  lpbuf = NULL;
    DWORD   cbsize, cbWritten;
    
    cbsize = ReadLogFile(lpce->lpszLocalFileName, &lpbuf);
    cbWritten = 0;
    if (lpbuf && (cbsize > c_ccEmptyLog))   //change this threshold if modify
    {                                       //CreatePrefixedCacheEntry in trkcache.cpp
        AppendLogUrlField(lpce);            
        WriteFile(_hLogFile, lpbuf, cbsize, &cbWritten, NULL);
        ASSERT((cbsize == cbWritten));
    }

    SAFELOCALFREE(lpbuf);
    
    return;

}

void CTrackingStg::AppendLogUrlField(LPINTERNET_CACHE_ENTRY_INFOA lpce)
{
    DWORD dwWritten = 0;
    LPSTR lpbuf = NULL;
    DWORD cb;

    // lpce->lpszSourcesUrlName contains prefixed string
    DWORD cchAlloc = lstrlenA(lpce->lpszSourceUrlName) - lstrlenA(_lpPfx) + c_ccUrlFields 
                        + c_ccLogFields;
    cb = (cchAlloc + 7) * sizeof(CHAR);
    lpbuf = (LPSTR)MemAlloc(LPTR, cb);
    if (lpbuf)
    {
        wnsprintfA(lpbuf, cb, "%s\r\n%s\r\n%s\r\n", c_szUrlFields, 
                 lpce->lpszSourceUrlName+lstrlenA(_lpPfx), c_szLogFields);
        WriteFile(_hLogFile, lpbuf, lstrlenA(lpbuf), &dwWritten, NULL);
    }
    
    SAFELOCALFREE(lpbuf);
    return;
}

HRESULT CTrackingStg::Enumeration(LONGLONG enumId)
{
    HRESULT hr = E_FAIL;
    HANDLE  hEnum;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    DWORD   cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                    0,              //dwFlags
                                    URLCACHE_FIND_DEFAULT_FILTER,              //dwFilters,
                                    0,              //enumId, IE50: wininet change, not support group in extensible cache
                                    lpCE,
                                    &cbSize,
                                    NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;
    
        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (!StrCmpNIA(lpCE->lpszSourceUrlName, _lpPfx, lstrlenA(_lpPfx))
                && lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime 
                && lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {    
                AppendLogEntries(lpCE);
            }
            
            // reuse lpCE
            cbSize = MY_MAX_CACHE_ENTRY_INFO;
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                break;
            }
        }

        FindCloseUrlCache(hEnum);
        hr = S_OK;
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

HRESULT CTrackingStg::RetrieveLogData(ISubscriptionItem* pCDFItem)
{
    HRESULT hr = E_FAIL;

    // heck: wininet does not support multiple groups to same URL
    // have to enumerate new and old groups to cover
    GROUPID newId;

    ReadLONGLONG(pCDFItem, c_szTrackingCookie, &newId);
    if (newId)
    {
        hr = Enumeration(newId);
    }
    // heck: end

    hr = Enumeration(_groupId);

    CloseLogFile();
    return hr;
}

HRESULT CTrackingStg::RetrieveAllLogStream(ISubscriptionItem* pCDFItem, LPCSTR lpFile)
{
    HRESULT hr = E_FAIL;
    LPTSTR  lpPfx = ReadTrackingPrefix();

    if (lpPfx)
    {
        int len = lstrlenW(lpPfx) + 1;
        
        _lpPfx = (LPSTR)MemAlloc(LPTR, len * sizeof(CHAR));

        if (_lpPfx)
        {
            SHUnicodeToAnsi(lpPfx, _lpPfx, len);
        }

        MemFree(lpPfx);
    }

    _hLogFile = CreateFileA(lpFile, 
                GENERIC_WRITE,
                0,                              //no sharing
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (_hLogFile == INVALID_HANDLE_VALUE)      //turn-around is read into a buffer.
        return hr;

    hr = RetrieveLogData(pCDFItem);

    return S_OK;    
}

//  
//  Validate the Posting by
//  1. attempt to post this log does not exceed limits set in registry
//  2. the log itself is valid
//
BOOL CTrackingStg::IsExpired(ISubscriptionItem* pItem)
{
    BOOL    bret;
    DWORD   regRetry = 3;   // Intelligent default so we don't need the registry value set.
        
    ReadRegValue(HKEY_LOCAL_MACHINE, MY_WEBCHECK_POST_REG,
                     c_szPostRetryReg, (void *)&regRetry, sizeof(regRetry));
                     
    bret = (_dwRetry < regRetry) ? FALSE : TRUE;

    if (bret) return bret;

    // read the purgetime from subscription property bag
    DATE        dt = 0.0;

    if (SUCCEEDED(ReadDATE(pItem, c_szPostPurgeTime, &dt)) && dt != 0)
    {
        SYSTEMTIME  st, expiredst;
        FILETIME    ft, expiredft;

        VariantTimeToSystemTime(dt, &expiredst);
        SystemTimeToFileTime(&expiredst, &expiredft);

        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ft);

        bret = (CompareFileTime(&ft, &expiredft) > 0) ? TRUE : FALSE;
    }

    return bret;
}


CTrackingStg::CTrackingStg
(
)
{
    _pwszURL = NULL;
    _groupId = 0;
    _dwRetry = 0;
    _lpPfx = NULL;
}

CTrackingStg::~CTrackingStg()
{
    //
    // Release/delete any resources
    //
    DBG("CTrackingStg d'tor");

    SAFEFREEOLESTR(_pwszURL);
    SAFELOCALFREE(_lpPfx);
    
    if (_hLogFile)
        CloseHandle(_hLogFile);

}

//------------------------------------------------------------
//
//  CWCPostAgent implementation
//
//------------------------------------------------------------

//------------------------------------------------------------
// virtual functions overriding CDeliveryAgent
//------------------------------------------------------------

ISubscriptionMgr2 *
CWCPostAgent::GetSubscriptionMgr()
{
    ISubscriptionMgr2* pSubsMgr=NULL;

    CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                    IID_ISubscriptionMgr2, (void**)&pSubsMgr);

    return pSubsMgr;
}

//
// Re-stamp a set of tracking URLs from old group to new group
// without losing logging data
//
void
CWCPostAgent :: MergeGroupOldToNew()
{
    GROUPID newId;
    HANDLE  hEnum;
    LPINTERNET_CACHE_ENTRY_INFO lpCE = NULL;
    DWORD   cbSize;
    LPTSTR  lpPfx = NULL;

    newId = 0;
    ReadLONGLONG(_pCDFItem, c_szTrackingCookie, &newId);

    if (!newId && !_pUploadStream->_groupId)
        return;
    
    ASSERT(newId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return;
    }

    lpPfx = ReadTrackingPrefix();
    if (!lpPfx)
    {
        MemFree(lpCE);
        return;
    }

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryEx(lpPfx,
                                    0,              //dwFlags
                                    URLCACHE_FIND_DEFAULT_FILTER,              //dwFilters,
                                    0,              //_pUploadStream->_groupId, IE50 changed
                                    lpCE,
                                    &cbSize,
                                    NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified, ftOld;

        ftModified.dwHighDateTime = (DWORD)(newId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & newId);
        ftOld.dwHighDateTime = (DWORD)(_pUploadStream->_groupId >> 32);
        ftOld.dwLowDateTime = (DWORD)(0x00000000ffffffff & _pUploadStream->_groupId);

        for(;;)
        {
            if (!StrCmpNI(lpCE->lpszSourceUrlName, lpPfx, lstrlen(lpPfx))
                && lpCE->LastModifiedTime.dwLowDateTime == ftOld.dwLowDateTime 
                && lpCE->LastModifiedTime.dwHighDateTime == ftOld.dwHighDateTime)
            {
                // commit changes to url cache
                lpCE->LastModifiedTime.dwHighDateTime = ftModified.dwHighDateTime;
                lpCE->LastModifiedTime.dwLowDateTime = ftModified.dwLowDateTime;
                
                SetUrlCacheEntryInfo(lpCE->lpszSourceUrlName, lpCE, CACHE_ENTRY_MODTIME_FC);
            }

            // reuse lpCE
            cbSize = MY_MAX_CACHE_ENTRY_INFO;
            if (!FindNextUrlCacheEntryEx(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return;
}

HRESULT CWCPostAgent::InitRequest
(
    LPCSTR lpszVerb
)
{
    char    hostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
    char    userName[INTERNET_MAX_USER_NAME_LENGTH+1];
    char    password[INTERNET_MAX_PASSWORD_LENGTH+1];
    char    urlPath[INTERNET_MAX_PATH_LENGTH+1];
    URL_COMPONENTSA     uc;
    BOOL    bRet;
    LPSTR   pszPostURL;
    int     iLen;
    TCHAR   pszUA[128];
    HRESULT hr = E_FAIL;

    if ( !_pUploadStream->_pwszURL )
        return S_OK;             //do nothing if post url doesn't exist

    iLen = lstrlenW(_pUploadStream->_pwszURL) + 1;
    pszPostURL = new CHAR[iLen];
    if (!pszPostURL)
        return E_OUTOFMEMORY;

    SHUnicodeToAnsi(_pUploadStream->_pwszURL, pszPostURL, iLen);

    memset(&uc, 0, sizeof(uc));
    uc.dwStructSize = sizeof(uc);
    uc.lpszHostName = hostName;
    uc.dwHostNameLength = sizeof(hostName);
    uc.nPort = INTERNET_INVALID_PORT_NUMBER;
    uc.lpszUserName = userName;
    uc.dwUserNameLength = sizeof(userName);
    uc.lpszPassword = password;
    uc.dwPasswordLength = sizeof(password);
    uc.lpszUrlPath = urlPath;
    uc.dwUrlPathLength = sizeof(urlPath);
    
    bRet = InternetCrackUrlA(pszPostURL, lstrlenA(pszPostURL), 
                            ICU_DECODE, &uc);
    if (!bRet)
    {
        DBG("InternetCrackUrl failed");
        goto _exitInit;
    }

    // read User Agent string
    if (!ReadRegValue(HKEY_CURRENT_USER, szInternetSettings, c_szUserAgent, pszUA, sizeof(pszUA)))
        StrCpyN(pszUA, TEXT("PostAgent"), ARRAYSIZE(pszUA));

    _hSession = InternetOpen(pszUA,                  // used in User-Agent: header 
                            INTERNET_OPEN_TYPE_PRECONFIG,  //INTERNET_OPEN_TYPE_DIRECT, 
                            NULL,
                            NULL, 
                            //INTERNET_FLAG_ASYNC);  
                            0);         //synchronous operation

    if ( !_hSession )
    {
        DBG("!_hSession");
        goto _exitInit;
    }

    _hHttpSession = InternetConnectA(_hSession, 
                                    uc.lpszHostName,    //"peihwalap", 
                                    uc.nPort,           //INTERNET_INVALID_PORT_NUMBER,
                                    uc.lpszUserName,    //NULL, 
                                    uc.lpszPassword,    //NULL, 
                                    INTERNET_SERVICE_HTTP, 
                                    INTERNET_FLAG_KEEP_CONNECTION, 
                                    0); 
                                    //(DWORD)this); //dwContext.

//    InternetSetStatusCallback(m_hSession, CWCPostAgent::PostCallback);
                                
    if ( !_hHttpSession )
    {
        DBG( "!_hHttpSession");
        CloseRequest();
        goto _exitInit;
    }                                    
    

    // ignore security problem

    _hHttpRequest = HttpOpenRequestA(_hHttpSession, lpszVerb, 
                                    uc.lpszUrlPath,
                                    HTTP_VERSIONA, 
                                    NULL,                             //lpszReferer
                                    NULL,                             //lpszAcceptTyypes
                                    //INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                                    //INTERNET_FLAG_IGNORE_CERT_DATE_INVALID |
                                    //INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS |
                                    //INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP |
                                    INTERNET_FLAG_NO_COOKIES, 
                                    0);
                                    //(DWORD)this);	//dwContext
                            

    if ( !_hHttpRequest )
    {
        DBG_WARN("Post Agent: !_hHttpRequest");
        CloseRequest();
        goto _exitInit;
    }
    else
        hr = S_OK;


_exitInit:

    delete [] pszPostURL;
    return hr;
    
}                                                                
    
HRESULT CWCPostAgent::SendRequest
(
    LPCSTR     lpszHeaders,
    LPDWORD    lpdwHeadersLength,
    LPCSTR     lpszOption,
    LPDWORD    lpdwOptionLength
)
{
    BOOL bRet=FALSE;

    HttpAddRequestHeadersA(_hHttpRequest, 
                           (LPCSTR)c_szHeaders, 
                           (DWORD)-1L, 
                           HTTP_ADDREQ_FLAG_ADD);

    if (lpszHeaders && *lpszHeaders)        // don't bother if it's empty
        bRet = HttpAddRequestHeadersA(_hHttpRequest, 
                          (LPCSTR)lpszHeaders, 
                          *lpdwHeadersLength, 
                          HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
/*
    bRet = HttpSendRequest(_hHttpRequest, 
                          (LPCTSTR)lpszHeaders,           //HEADER_ENCTYPE, 
                          *lpdwHeadersLength,              //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          *lpdwOptionLength);
*/
    bRet = HttpSendRequest(_hHttpRequest, 
                          NULL,                            //HEADER_ENCTYPE, 
                          0,                               //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          *lpdwOptionLength);

    if ( !bRet )
    {
        DWORD dwLastError = GetLastError();

        TraceMsg(TF_ERROR, "HttpSendRequest failed: Error = %lx", dwLastError);
        DBG_WARN("Post Agent: HttpSendRequest failed");
        return E_FAIL;
    }

    DWORD dwBuffLen;
    TCHAR buff[1024];

    dwBuffLen = sizeof(buff);

    bRet = HttpQueryInfo(_hHttpRequest,
                        //HTTP_QUERY_CONTENT_TYPE,  //HTTP_QUERY_REQUEST_METHOD,
                        HTTP_QUERY_STATUS_CODE,   //HTTP_QUERY_RAW_HEADERS,
                        buff,
                        &dwBuffLen,
                        NULL);
 
    if ( !bRet )
    {
        DWORD dwLastError = GetLastError();

        TraceMsg(TF_ERROR, "HttpQueryInfo failed: Error = %lx", dwLastError);
        DBG_WARN("Post Agent: HttpQueryInfo failed");
    }
    else
    {
        int iretcode = StrToInt(buff);
        if (iretcode == 200)   // || iretcode == 100)   //HTTP_STATUS_OK
            return S_OK;             //100: too many semaphors
                                     //501: required not supported
                                     //502: bad gateway
    }

    return E_FAIL;    
}                                                                

HRESULT CWCPostAgent::CloseRequest
(
    void
)
{
    InternetCloseHandle(_hSession);
    _hSession = _hHttpSession = _hHttpRequest = 0;
    return S_OK;
}

// Called if upload failed
//   just increase retry number
HRESULT CWCPostAgent::OnPostFailed()
{
    WriteDWORD(_pCDFItem, c_szPostingRetry, _pUploadStream->_dwRetry+1);

    MergeGroupOldToNew();

    return S_OK;
}

// Called if upload succeeded
//   1) remove PostUrl from item
//   2) delete tracking cache entry  (Doh!)
HRESULT CWCPostAgent::OnPostSuccess()
{
    GROUPID newId = 0;

    if (!_pCDFItem)
        return E_INVALIDARG;

    ReadLONGLONG(_pCDFItem, c_szTrackingCookie, &newId);
    _pUploadStream->RemoveCacheEntry(_pUploadStream->_groupId);

    if (newId == _pUploadStream->_groupId)
    {
        BSTR  bstrURL = NULL;
        ReadBSTR(_pCDFItem, c_szTrackingPostURL, &bstrURL);
        if (!StrCmpIW(bstrURL, _pUploadStream->_pwszURL))
        {
            WriteOLESTR(_pCDFItem, c_szTrackingPostURL, bstrURL);
        }

        SAFEFREEBSTR(bstrURL);

    }
    else
        _pUploadStream->EmptyCacheEntry(newId);

    return S_OK;
}

HRESULT
CWCPostAgent::FindCDFStartItem()
{
    IServiceProvider    *pSP;
    
    if (_pCDFItem)
        return S_OK;
    
    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        pSP->QueryService(CLSID_ChannelAgent, IID_ISubscriptionItem, (void **)&_pCDFItem);
        pSP->Release();
    }

    if (NULL == _pCDFItem)
    {
        TraceMsg(TF_THISMODULE, "PostAgent : FindCDFStartItem failed");
    }

    return (_pCDFItem) ? S_OK : E_NOINTERFACE;
}

HRESULT CWCPostAgent::DoFileUpload()
{
    HRESULT hr;
    DWORD   dwLen, dwHdr;

    SAFELOCALFREE(_pszPostStream);
    dwLen = _pUploadStream->ReadLogFile(_lpLogFile, &_pszPostStream);
    if (dwLen == 0)
    {
        // no log to post, should clean up cache entries for this group.
        OnPostSuccess();
        return S_OK;
    }
  
    if (FAILED(hr = InitRequest("POST")))
        return hr;

#ifdef ENCODE_LOG
    CHAR   lpEncodeHdr[c_ccEncodeHeader+MAX_PATH];

    lpEncodeHdr[0] = '\0';
    if (SUCCEEDED(ReadBSTR(m_pSubscriptionItem, c_szPostHeader, &_pwszEncoding)))
    {
        if (_pwszEncoding && *_pwszEncoding)
        {
            IEncodingFilterFactory* pEflt = NULL;
            IDataFilter*    pDF = NULL;
                 
            CoCreateInstance(CLSID_StdEncodingFilterFac, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IEncodingFilterFactory, (void**)&pEflt);

            if (pEflt)
            {
                pEflt->GetDefaultFilter(_pwszEncoding, L"text", &pDF);
                if (pDF)
                {
                    LONG lInUsed = 0;
                    LONG lOutUsed = 0;
                    LPSTR  pInBuf = _pszPostStream;
                    LPSTR  pOutBuf = NULL;
                    HRESULT hrCode = NOERROR;

                    pOutBuf = (LPSTR)MemAlloc(LPTR, dwLen);
                    if (pOutBuf == NULL)
                        goto do_upload;

                    hrCode = pDF->DoEncode(
                                            0,
                                            dwLen,
                                            (BYTE *)pInBuf, 
                                            dwLen,
                                            (BYTE *)pOutBuf, 
                                            dwLen,
                                            &lInUsed,
                                            &lOutUsed,
                                            0);

                    if (SUCCEEDED(hrCode))
                    {
                        // add encoding header information, e.g.
                        // "Content-Transfer-Encoding: x-gzip\r\n"
                        wnsprintfA(lpEncodeHdr, ARRAYSIZE(lpEncodeHdr), "%s%S\r\n", 
                                   c_szEncodeHeader, _pwszEncoding);
                        
                        SAFELOCALFREE(_pszPostStream);
                        _pszPostStream = (LPSTR)MemAlloc(LPTR, lOutUsed+2);
                        if (_pszPostStream)
                        {
                            memcpy(_pszPostStream, pOutBuf, lOutUsed);  //do I need to append CR?
                            dwLen = (DWORD)lOutUsed;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    pDF->Release();
                    SAFELOCALFREE(pOutBuf);
                }
                pEflt->Release();
            }
        }   // if (_pwszEncoding && *_pwszEncoding)

    }   //ReadBSTR


do_upload:
    dwHdr = lstrlenA(lpEncodeHdr);
    hr = SendRequest(lpEncodeHdr, &dwHdr, _pszPostStream, &dwLen);
#else
    dwHdr = lstrlenA("");
    hr = SendRequest(NULL, &dwHdr, _pszPostStream, &dwLen);
#endif  //ENCODE_LOG

    CloseRequest();

    if (FAILED(hr))
    {
        TraceMsg(TF_THISMODULE, "PostAgent failed to SendRequest");
        OnPostFailed();
    }
    else
    {
        TraceMsg(TF_THISMODULE, "PostAgent Posted data");
        OnPostSuccess();
    }


    return hr;
}

BOOL CWCPostAgent::GetTmpLogFileName()
{
    char   szPath[MAX_PATH];
    
    if (GetTempPathA(MAX_PATH, szPath) > 0)
    {
        _lpLogFile = (LPSTR)MemAlloc(LPTR, MAX_PATH+1);
        if (GetTempFileNameA(szPath, "trk", 0, _lpLogFile))
        {
            return TRUE;
        }
    }

    return FALSE;
}
    
HRESULT CWCPostAgent::DoPost()
{
    HRESULT hr = E_FAIL;
    
    _pUploadStream->_groupId = 0L;
    if (FAILED(ReadLONGLONG(m_pSubscriptionItem, c_szTrackingCookie, &_pUploadStream->_groupId)))
        return hr;

    if (FAILED(ReadDWORD(m_pSubscriptionItem, c_szPostingRetry, &_pUploadStream->_dwRetry)))
        _pUploadStream->_dwRetry = 0;

    if (_pUploadStream->IsExpired(m_pSubscriptionItem))
    {
        // post is expired, clean up log cache entries
        OnPostSuccess();
        return hr;
    }

    if (!GetTmpLogFileName())
    {
        if (NULL != _lpLogFile)
        {
            MemFree(_lpLogFile);
        }
        int nLen = MAX_PATH + 1;
        _lpLogFile = (LPSTR)MemAlloc(LPTR, nLen * sizeof(CHAR));
        if (_lpLogFile)
        {
            StrCpyNA(_lpLogFile, "trkad.tmp", nLen);
        }
    }
        
    if (FAILED(hr = _pUploadStream->RetrieveAllLogStream(_pCDFItem, _lpLogFile)))
        return hr;

    hr = DoFileUpload();

    if (_lpLogFile)
        DeleteFileA(_lpLogFile);
    
    return hr;
}

// OnInetOnline
HRESULT CWCPostAgent::StartDownload()
{
    HRESULT hr;
    ASSERT(_pUploadStream && _pUploadStream->_pwszURL);

    hr = FindCDFStartItem();

    if (SUCCEEDED(hr))
    {
        BSTR bstrChannelURL = NULL;
        hr = ReadBSTR(m_pSubscriptionItem, c_szPropURL, &bstrChannelURL);
        ASSERT(SUCCEEDED(hr) && *bstrChannelURL);
        if (SUCCEEDED(hr) && !SHRestricted2W(REST_NoChannelLogging, bstrChannelURL, 0)
            && !ReadRegDWORD(HKEY_CURRENT_USER, c_szRegKey, c_szNoChannelLogging))
        {
            hr = DoPost();
        }
        else
        {
            OnPostSuccess();                // log is off, clean up log cache entries
        }
        SAFEFREEBSTR(bstrChannelURL);
    }
    SAFERELEASE(_pCDFItem);

    SetEndStatus(S_OK);

    CleanUp();

    return S_OK;
}

// OnAgentStart
HRESULT CWCPostAgent::StartOperation()
{
    if (_pUploadStream)
    {
        DBG_WARN("Agent busy, returning failure");
        SetEndStatus(E_FAIL);
        SendUpdateNone();
        return E_FAIL;
    }

    _pUploadStream = NULL;
    _pUploadStream = new CTrackingStg();
    if (!_pUploadStream)
    {
        DBG("failed to allocate CTrackStg");
        SetEndStatus(E_OUTOFMEMORY);
        SendUpdateNone();
        return E_OUTOFMEMORY;
    }

    SAFEFREEOLESTR(_pUploadStream->_pwszURL);
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szTrackingPostURL, &_pUploadStream->_pwszURL)) ||
        !CUrlDownload::IsValidURL(_pUploadStream->_pwszURL))
    {
        DBG_WARN("Couldn't get valid URL from start item (aborting)");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    // After calling this, we'll reenter either in "StartDownload" or in 
    // "AbortUpdate" with m_scEndStatus = E_ACCESSDENIED
    return CDeliveryAgent::StartOperation();
}

//------------------------------------------------------------
//
// override CDeliveryAgent virtual functions
//
//------------------------------------------------------------

// OnInetOffline
// Forcibly abort current operation
HRESULT CWCPostAgent::AgentAbort(DWORD dwFlags)
{
    DBG("CWCPostAgent::AbortUpdate");

    if (_pUploadStream)
    {
        if (SUCCEEDED(FindCDFStartItem()))
        {
            OnPostFailed();
        }
    }

    return CDeliveryAgent::AgentAbort(dwFlags);
}

void CWCPostAgent::CleanUp()
{
    SAFEDELETE(_pUploadStream);

    if (_lpLogFile)
        DeleteFileA(_lpLogFile);

    SAFEFREEBSTR(_pwszEncoding);

    SAFELOCALFREE(_lpLogFile);
    SAFELOCALFREE(_pszPostStream);
    
    CDeliveryAgent::CleanUp();
}

//------------------------------------------------------------
//
// CWCPostAgent Constructor/D'Constr
//
//------------------------------------------------------------

CWCPostAgent::CWCPostAgent()
{
    DBG("Creating CWCPostAgent object");

    //
    // Maintain global count of objects in webcheck.dll
    //
    DllAddRef();

    //
    // Initialize object member variables
    //
    _pUploadStream = NULL;
    _pwszEncoding = NULL;
    _pszPostStream = NULL;
    _lpLogFile = NULL;
    _hSession = _hHttpSession = _hHttpRequest = 0;
}

CWCPostAgent::~CWCPostAgent()
{
    SAFERELEASE(_pCDFItem);

    //
    // Maintain global count of objects
    //
    DllRelease();

    //
    // Release/delete any resources
    //
    DBG("Destroyed CWCPostAgent object");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\rsrchdr.h ===
// This file contains resource contants that would get munged by MSDEV. 

#define RSVIDM_FIRST                    0
#define RSVIDM_OPEN                     RSVIDM_FIRST+0
#define RSVIDM_UPDATE                   RSVIDM_FIRST+1
#define RSVIDM_RENAME                   RSVIDM_FIRST+2
#define RSVIDM_COPY                     RSVIDM_FIRST+3
#define RSVIDM_DELETE                   RSVIDM_FIRST+4
#define RSVIDM_PROPERTIES               RSVIDM_FIRST+5
#define RSVIDM_WORKOFFLINE              RSVIDM_FIRST+7
#define RSVIDM_UPDATEALL                RSVIDM_FIRST+8
#define RSVIDM_PASTE                    RSVIDM_FIRST+9
#define RSVIDM_SORTBYNAME               RSVIDM_FIRST+10
#define RSVIDM_HELP                     RSVIDM_FIRST+20

#define IDI_SUBSCRIBE			IDI_TRAYICON
#define IDI_SITE			IDI_TRAYICON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\smtp.h ===
//
// SMTP - Simple Mail Transfer Protocol 
//
// Julian Jiggins, January 13th 1997
//

//
// SMTPSendMessage -
//		loads winsock, 
//		connects to the specified server on the SMTP port 25
//		sends the szMessage to the szAddress
//
BOOL SMTPSendMessage(
	char * szServer, 
	char * szToAddress, 
	char * szFromAddress, 
	char * szMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\propshts.h ===
#ifndef __propshts_h
#define __propshts_h

INT_PTR CALLBACK SummaryPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SchedulePropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DownloadPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvancedDownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LoginOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif //__propshts_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\smtp.cpp ===
//
// SMTP - Simple Mail Transfer Protocol Code
//
// Implements sends mail using SMTP RFC 821.
// Julian Jiggins, 12 January 1997
//

#include "private.h"
#include <winsock.h>

#define TF_THISMODULE  TF_MAILAGENT

#define IS_DIGIT(ch)    InRange(ch, TEXT('0'), TEXT('9'))

//
// Function prototypes for this module
//
SOCKET Connect(char *host, u_short port);

#define READ_BUF_LEN 512

//
// Read all you can from a socket
//
void Read(SOCKET sock, char * readBuffer, int bufLen)
{
    int numRead;

    numRead = recv(sock, readBuffer, bufLen, 0);

    //  recv can return SOCKET_ERROR which is -1, we don't want to underflow the buffer.
    if (numRead < 0)
    {
        numRead = 0;
    }

    //
    // NULL terminate read string
    //
    readBuffer[numRead] = 0;
}

//
// Send a string specifying an SMTP command and read in response, returning
// TRUE if it is the one expected.
// Note the SMTP protocol is designed such that only the 1 character of the 
// response need be checked, but we check for the exact response (mostly cause
// I just read that bit in the RFC)
// 
BOOL SendAndExpect(SOCKET sock, char * sendBuffer, char * szExpect)
{
    char readBuffer[READ_BUF_LEN];
    int len;
    int numSent;

    //
    // Send string to socket
    //
    numSent = send(sock, sendBuffer, lstrlenA(sendBuffer), 0);
    if (numSent == SOCKET_ERROR) 
    {
        DBG_WARN("Error on send");
        return FALSE;
    }

    //
    // Now read in response
    //
    Read(sock, readBuffer, READ_BUF_LEN);

    DBG2("Sent: %s", sendBuffer);
    DBG2("Read: %s", readBuffer);

    //
    // Expect beginning of response to contain szExpect string
    //
    len = lstrlenA(szExpect);
    if (CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, 
        readBuffer, len, szExpect, len) == 2)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define SMTP_221 "221"
#define SMTP_250 "250"
#define SMTP_354 "354"
#define SMTP_EOM "\r\n.\r\n"

//
// Carry out SMTP negotiation
//
BOOL SMTPSendEmail(SOCKET sock, char * szToAddress, char * szFromAddress, char *szMessage)
{
    char sendBuffer[256];
    char readBuffer[READ_BUF_LEN];
    BOOL b = TRUE;
    int r, len;

    //
    // Read the opening response
    //
    Read(sock, readBuffer, sizeof(readBuffer));
    DBG(readBuffer);

    //
    // say Hello and specify my domain
    //
    b = SendAndExpect(sock, "HELO ActiveDesktop\r\n", SMTP_250);
    if (!b) goto done;

    //
    // First special sender in MAIL command
    //
    wnsprintfA(sendBuffer, ARRAYSIZE(sendBuffer), "MAIL FROM:<%s>\r\n", 
              szFromAddress);
    b = SendAndExpect(sock, sendBuffer, SMTP_250);
    if (!b) goto done;

    //
    // Now specify recipient(s)
    //
    wnsprintfA(sendBuffer, ARRAYSIZE(sendBuffer), "RCPT TO:<%s>\r\n", 
              szToAddress);
    b = SendAndExpect(sock, sendBuffer, SMTP_250);
    if (!b) goto done;

    //
    // Now send DATA command
    //
    b = SendAndExpect(sock, "DATA\r\n", SMTP_354);
    if (!b) goto done;

    //
    // Now send mail message
    //
    len = lstrlenA(szMessage);
    r = send(sock, szMessage, len, 0);
    ASSERT(r != SOCKET_ERROR);
    ASSERT(r == len);

    //
    // Specify end of message with single period.
    //
    b = SendAndExpect(sock, SMTP_EOM, SMTP_250);
    if (!b) goto done;

    //
    // Say goodbye
    //
    b = SendAndExpect(sock, "QUIT\r\n", SMTP_221);
 
done:
    return b;
}

//
// Main entry point - 
//  start winsock dll, 
//  connect to socket,
//  and negotiate transfer
//
SMTPSendMessage(char * szServer, char * szToAddress, char * szFromAddress, char * szMessage)
{
    int err;
    SOCKET sock;
    BOOL b = FALSE;
    WSADATA wsaData;

    //
    // Init the winsock dll specifying which version we want.
    //
    err = WSAStartup((WORD)0x0101, &wsaData);
    if (err)
    {
        DBG_WARN("WinSock startup error");
        return FALSE;
    }
    DBG("WinSock successfully started");

    //
    // Actually form the socket connection to the host on port 25
    //
    sock = Connect(szServer, 25);

    if (sock != 0)
    {
        DBG("Connected");
        b = SMTPSendEmail(sock, szToAddress, szFromAddress, szMessage);
    }

    //
    // Done with winsock dll for now
    //
    WSACleanup();
    return b;
}

SOCKET
Connect(char *host, u_short port)
{
    struct sockaddr_in sockaddress;
    DWORD  err;
    SOCKET sock, connectresult;

    //
    // Get the socket address
    //
    if(IS_DIGIT(*host))                            
        sockaddress.sin_addr.s_addr=inet_addr(host);
    else 
    {
        struct hostent *hp;
        if((hp=gethostbyname(host))==NULL) 
        {
            DBG_WARN2("Unknown host %s", host);
            return 0;
        }
        memcpy(&sockaddress.sin_addr, hp->h_addr, sizeof(sockaddress.sin_addr));
    }

    //
    // port address
    //
    sockaddress.sin_port=htons(port);      
    sockaddress.sin_family=AF_INET;

    //
    // Create a stream style socket
    //
    if((sock=socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
        DBG_WARN("socket error");


    DBG("Trying to connect");

    connectresult=connect(sock,(struct sockaddr *) &sockaddress, sizeof(sockaddress));

    if (connectresult == SOCKET_ERROR) 
    {
        switch(err = WSAGetLastError()) 
        {
        case WSAECONNREFUSED:
            DBG_WARN("ERROR - CONNECTION REFUSED.");
            break;
        case WSAENETUNREACH:
            DBG_WARN("ERROR - THE NETWORK IS NOT REACHABLE FROM THIS HOST.");
            break;
        case WSAEINVAL:
            DBG_WARN("ERROR - The socket is not already bound to an address.");
            break;
        case WSAETIMEDOUT:
            DBG_WARN("ERROR - Connection timed out.");
            break;
        default:
            DBG_WARN2("Couldn't connect %d", err);
            break;
        } 
        closesocket(sock);
        return 0;
    }
    return sock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\postagnt.h ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//

#ifndef POSTAGNT_H_
#define POSTAGNT_H_

#define MAX_CONTENT_LENGTH 2048

#define WEBCRAWL_POST_BEGIN 2
#define WEBCRAWL_POST_END   0


class CTrackingStg;

//////////////////////////////////////////////////////////////////////////
//
// Actual Post Agent objects
//
//////////////////////////////////////////////////////////////////////////

class CWCPostAgent : public CDeliveryAgent
{
private:
    ~CWCPostAgent(void);

public:
    CWCPostAgent(void);

    //
    // CDeliveryAgent
    //
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    
    HRESULT     AgentAbort(DWORD dwFlags);

//    void CALLBACK PostCallback(HINTERNET hInternet, DWORD dwContext, 
//                               DWORD dwInternetStatus, LPVOID lpvStatusInfo,
//                               DWORD dwInfoLen);

    void        CleanUp();

protected:
    HRESULT     DoPost();
    HRESULT     DoFileUpload();
    BOOL        GetTmpLogFileName();

    HRESULT     InitRequest(LPCSTR lpszVerb);
    HRESULT     SendRequest(LPCSTR lpszHeaders, LPDWORD lpdwHeadersLength,
                            LPCSTR lpszOption, LPDWORD lpdwOptionLength);
    HRESULT     CloseRequest(void);
  
    HRESULT     OnPostSuccess();
    HRESULT     OnPostFailed();
    void        MergeGroupOldToNew();

    ISubscriptionMgr2 *GetSubscriptionMgr();
    HRESULT     FindCDFStartItem();
    //HRESULT     ScheduleMe(INotificationMgr* pNotMgr, INotification *pNot);


private:

    // for wininet
    HINTERNET   _hSession;
    HINTERNET   _hHttpSession;
    HINTERNET   _hHttpRequest;

    CTrackingStg*   _pUploadStream;
    LPSTR       _pszPostStream;
    LPSTR       _lpLogFile;
    LPWSTR      _pwszEncoding;

    ISubscriptionItem* _pCDFItem;
};

class CTrackingStg
{

public:
    CTrackingStg();
    ~CTrackingStg();

    BOOL        IsExpired(ISubscriptionItem* pItem); 

    // data retrieving
    HRESULT     RetrieveAllLogStream(ISubscriptionItem* pItem, LPCSTR lpFile);
    HRESULT     RetrieveLogData(ISubscriptionItem* pItem);
    HRESULT     Enumeration(LONGLONG logId);
    void        AppendLogUrlField(LPINTERNET_CACHE_ENTRY_INFOA lpce);
    void        AppendLogEntries(LPINTERNET_CACHE_ENTRY_INFOA lpce);
    DWORD       ReadLogFile(LPCSTR lpFile, LPSTR* lplpBuf);
    
    HRESULT     EmptyCacheEntry(GROUPID enumId);
    HRESULT     RemoveCacheEntry(GROUPID enumId);

    HANDLE      OpenItemLogFile(LPCSTR lpFile);
    HRESULT     CloseLogFile()
                {
                    CloseHandle(_hLogFile);
                    _hLogFile = NULL;
                    return S_OK;
                }
    
    LPWSTR      _pwszURL;
    GROUPID     _groupId;
    DWORD       _dwRetry;
    LPSTR       _lpPfx;

private:
    HANDLE      _hLogFile;
};

#endif POSTAGNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\propshts.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "propshts.h"
#include "subsmgrp.h"
#include <iehelpid.h>

#include <mluisupp.h>

#define INITGUID
#include <initguid.h>
#include "imnact.h"
#include "helper.h"

void WriteDefaultEmail(LPTSTR szBuf);
void WriteDefaultSMTPServer(LPTSTR szBuf);

const TCHAR c_szDefEmail[] = TEXT("DefaultEmail");
const TCHAR c_szDefServer[] = TEXT("DefaultSMTPServer");
TCHAR c_szHelpFile[] = TEXT("iexplore.hlp");

struct NEWSCHED_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
    TCHAR szSchedName[MAX_PATH];
};

#define MIN_DOWNLOAD_K  50
#define MAX_DOWNLOAD_K  UD_MAXVAL
#define DEF_DOWNLOAD_K  500

DWORD aHelpIDs[] = {

//  Schedule page
    IDC_SCHEDULE_TEXT,              IDH_GROUPBOX,
    IDC_MANUAL_SYNC,                IDH_SUBPROPS_SCHEDTAB_MANUAL_SCHEDULE,
    IDC_SCHEDULED_SYNC,             IDH_SUBPROPS_SCHEDTAB_CUSTOM_SCHEDULE,
    IDC_SCHEDULE_LIST,              IDH_SUBPROPS_SCHEDTAB_SCHEDDESC,
    IDC_SCHEDULE_NEW,               IDH_NEW_OFFLINE_SCHED,
    IDC_SCHEDULE_EDIT,              IDH_EDIT_OFFLINE_SCHED,
    IDC_SCHEDULE_REMOVE,            IDH_REMOVE_OFFLINE_SCHED,
//    IDC_IDLE_ONLY,                  IDH_SUBPROPS_SCHED_DONTUPDATE,

//  Download page
    IDC_CONTENT_GROUPBOX,           IDH_GROUPBOX,
    IDC_DOWNLOAD_PAGES_LABEL1,      IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_LEVELS,                     IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_LEVELS_SPIN,                IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_DOWNLOAD_PAGES_LABEL2,      IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_FOLLOW_LINKS,               IDH_SUBPROPS_RECTAB_ADVOPTS_FOLLOW_LINKS,
    IDC_LIMIT_SPACE_CHECK,          IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_EDIT,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_SPIN,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_TEXT,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,   
    IDC_ADVANCED,                   IDH_SUBPROPS_RECTAB_ADVANCED,
    IDC_EMAIL_GROUPBOX,             IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION,
    IDC_EMAIL_NOTIFY,               IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION,
    IDC_EMAIL_ADDRESS_TEXT,         IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS,
    IDC_EMAIL_ADDRESS,              IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS,
    IDC_EMAIL_SERVER_TEXT,          IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER,
    IDC_EMAIL_SERVER,               IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER,
    IDC_LOGIN_LABEL,                IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN,
    IDC_LOGIN,                      IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN,
    IDC_DOWNLOAD_ALL,               IDH_CHANNEL_DOWNLOAD_ALL,
    IDC_DOWNLOAD_MIN,               IDH_CHANNEL_DOWNLOAD_COVER_N_TOC,

    //  Advanced popup
    IDC_ADVANCED_GROUPBOX,          IDH_GROUPBOX,
    IDC_DOWNLOAD_IMAGES,            IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_IMAGES,
    IDC_DOWNLOAD_MEDIA,             IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_SOUND,
    IDC_DOWNLOAD_APPLETS,           IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_ACTIVEX,
    IDC_DOWNLOAD_ONLY_HTML_LINKS,   IDH_SUBPROPS_RECTAB_ADVOPTS_ONLY_HTML_LINKS,

    //  Login popup
    IDC_USERNAME_LABEL,             IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
    IDC_USERNAME,                   IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
    IDC_PASSWORD_LABEL,             IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
    IDC_PASSWORD,                   IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
    IDC_PASSWORDCONFIRM_LABEL,      IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM,
    IDC_PASSWORDCONFIRM,            IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM,

    //  New schedule popup
    IDC_SCHEDULE_LABEL1,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_DAYS,              IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_DAYS_SPIN,         IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_LABEL2,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_TIME,              IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_NAME_TEXT,         IDH_NEWSCHED_NAME,
    IDC_SCHEDULE_NAME,              IDH_NEWSCHED_NAME,
    IDC_SCHEDULE_LABEL3,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_WIZ_SCHEDULE_AUTOCONNECT,   IDH_SUBPROPS_NEW_SCHEDULE_AUTOCONNECT,

    //  Summary page
    IDC_NAME,                   IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME,
    IDC_URL_TEXT,               IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_URL,                    IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_VISITS_TEXT,            IDH_WEBDOC_VISITS,
    IDC_VISITS,                 IDH_WEBDOC_VISITS,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    IDC_SUMMARY,                IDH_GROUPBOX,
    IDC_LAST_SYNC_TEXT,         IDH_SUBPROPS_SUBTAB_LAST,
    IDC_LAST_SYNC,              IDH_SUBPROPS_SUBTAB_LAST,
    IDC_DOWNLOAD_SIZE_TEXT,     IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_SIZE,          IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_RESULT_TEXT,   IDH_SUBPROPS_SUBTAB_RESULT,
    IDC_DOWNLOAD_RESULT,        IDH_SUBPROPS_SUBTAB_RESULT,

    //  dah end
    0,                              0
};



/********************************************************************************
    Property sheet helpers
*********************************************************************************/

inline POOEBuf GetBuf(HWND hdlg)
{
    POOEBuf pBuf = (POOEBuf) GetWindowLongPtr(hdlg, DWLP_USER);

    return pBuf;
}

void EnableControls(HWND hdlg, const int *pIDs, int nIDs, BOOL bEnable)
{
    for (int i = 0; i < nIDs; i++)
    {
        EnableWindow(GetDlgItem(hdlg, *pIDs++), bEnable);
    }
}

/********************************************************************************
    Summary property sheet code
*********************************************************************************/
inline POOEBuf Summary_GetBuf(HWND hdlg)
{
    CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);

    ASSERT(NULL != pSubsMgr);

    return (NULL != pSubsMgr) ? pSubsMgr->m_pBuf : NULL;
}

void Summary_ShowOfflineSummary(HWND hdlg, POOEBuf pBuf, BOOL bShow)
{
    static const int offSumIDs[] =
    {
        IDC_SUMMARY,
        IDC_LAST_SYNC_TEXT,
        IDC_LAST_SYNC,
        IDC_DOWNLOAD_SIZE_TEXT,
        IDC_DOWNLOAD_SIZE,
        IDC_DOWNLOAD_RESULT,
        IDC_DOWNLOAD_RESULT_TEXT,
        IDC_FREESPACE_TEXT
    };

    if (bShow)
    {
        TCHAR szLastSync[128];
        TCHAR szDownloadSize[128];
        TCHAR szDownloadResult[128];

        MLLoadString(IDS_VALUE_UNKNOWN, szLastSync, ARRAYSIZE(szLastSync));
        StrCpyN(szDownloadSize, szLastSync, ARRAYSIZE(szDownloadSize));
        StrCpyN(szDownloadResult, szLastSync, ARRAYSIZE(szDownloadResult));

        ISubscriptionItem *psi;
            
        if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi)))
        {
            enum { spLastSync, spDownloadSize, spDownloadResult };

            static const LPCWSTR pProps[] =
            { 
                c_szPropCompletionTime,
                c_szPropCrawlActualSize,
                c_szPropStatusString
            };
            VARIANT vars[ARRAYSIZE(pProps)];

            if (SUCCEEDED(psi->ReadProperties(ARRAYSIZE(pProps), pProps, vars)))
            {
                if (VT_DATE == vars[spLastSync].vt)
                {
                    FILETIME ft, ft2;
                    DWORD dwFlags = FDTF_DEFAULT;
                    
                    VariantTimeToFileTime(vars[spLastSync].date, ft);
                    LocalFileTimeToFileTime(&ft, &ft2);
                    SHFormatDateTime(&ft2, &dwFlags, szLastSync, ARRAYSIZE(szLastSync));
                }

                if (VT_I4 == vars[spDownloadSize].vt)
                {
                    StrFormatByteSize(vars[spDownloadSize].lVal * 1024, 
                                      szDownloadSize, ARRAYSIZE(szDownloadSize));
                }

                if (VT_BSTR == vars[spDownloadResult].vt)
                {
                    wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                              TEXT("%s"), vars[spDownloadResult].bstrVal);
                }

                for (int i = 0; i < ARRAYSIZE(pProps); i++)
                {
                    VariantClear(&vars[i]);
                }
            }
            psi->Release();
        }

        SetDlgItemText(hdlg, IDC_LAST_SYNC, szLastSync);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_SIZE, szDownloadSize);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_RESULT, szDownloadResult);
    }

    for (int i = 0; i < ARRAYSIZE(offSumIDs); i++)
    {
        ShowWindow(GetDlgItem(hdlg, offSumIDs[i]), bShow ? SW_SHOW : SW_HIDE);
    }
}

BOOL Summary_AddPageCallback(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    return PropSheet_AddPage((HWND)lParam, hpage) ? TRUE : FALSE;
}


BOOL Summary_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bResult = FALSE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = Summary_GetBuf(hdlg);

    switch (wID)
    {
        case IDC_MAKE_OFFLINE:
            if (BN_CLICKED == wNotifyCode)
            {
                CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);

                BOOL bShow = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);

                Summary_ShowOfflineSummary(hdlg, pBuf, bShow);
                
                if (NULL != pSubsMgr)
                {
                    if (bShow)
                    {
                        pSubsMgr->AddPages(Summary_AddPageCallback, (LPARAM)GetParent(hdlg));
                    }
                    else
                    {
                        pSubsMgr->RemovePages(GetParent(hdlg));
                    }
                }
                bChanged = TRUE;
            }
            bResult = TRUE;
            break;
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bResult;
}

BOOL Summary_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bResult = TRUE;

    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);
            POOEBuf pBuf = Summary_GetBuf(hdlg);

            ASSERT(NULL != pSubsMgr);
            ASSERT(NULL != pBuf);
            
            if ((NULL != pSubsMgr) && (NULL != pBuf))
            {
                if (IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))
                {
                    pBuf->dwFlags = PROP_WEBCRAWL_ALL;
                    SaveBufferChange(pBuf, TRUE);
                }
                else
                {                
                    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

                    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pBuf->m_URL);
                    pSubsMgr->DeleteSubscription(wszURL, NULL); 
                }
            }
            break;
        }
            
        default:
            bResult = FALSE;
            break;
    }
    return bResult;
}

BOOL Summary_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  Now read in values and populate the dialog
    POOEBuf pBuf = Summary_GetBuf(hdlg);
    ISubscriptionItem *psi;
    HICON hicon;
    BOOL bSubscribed;

    HRESULT hr = SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        bSubscribed = TRUE;
        hicon = LoadItemIcon(psi, TRUE);
        psi->Release();
    }
    else
    {
        bSubscribed = FALSE;
        hicon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WEBDOC));
    }

    SendDlgItemMessage(hdlg, IDC_ICONEX2, STM_SETICON, (WPARAM)hicon, 0);

    if ((!IsHTTPPrefixed(pBuf->m_URL)) ||
        (bSubscribed && SHRestricted2(REST_NoRemovingSubscriptions, pBuf->m_URL, 0)) ||
        (!bSubscribed && SHRestricted2(REST_NoAddingSubscriptions, pBuf->m_URL, 0)))
    {
        EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
    }
        
    SetDlgItemText(hdlg, IDC_NAME, pBuf->m_Name);
    SetDlgItemText(hdlg, IDC_URL, pBuf->m_URL);

    CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, bSubscribed);

    TCHAR szVisits[256];

    BYTE cei[MY_MAX_CACHE_ENTRY_INFO];
    LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
    DWORD cbcei = sizeof(cei);

    if (GetUrlCacheEntryInfo(pBuf->m_URL, pcei, &cbcei))
    {
        wnsprintf(szVisits, ARRAYSIZE(szVisits), TEXT("%d"), 
                  pcei->dwHitRate);
    }
    else
    {
        MLLoadString(IDS_VALUE_UNKNOWN, szVisits, 
                   ARRAYSIZE(szVisits));
    }
    SetDlgItemText(hdlg, IDC_VISITS, szVisits);


    Summary_ShowOfflineSummary(hdlg, pBuf, bSubscribed);

    return TRUE;
}

void Summary_OnDestroy(HWND hdlg)
{
    POOEBuf pBuf = Summary_GetBuf(hdlg);

    if (NULL != pBuf && !(pBuf->m_dwPropSheetFlags & PSF_IS_ALREADY_SUBSCRIBED) && 
        IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))
    {
        SendUpdateRequests(NULL, &pBuf->m_Cookie, 1);
    }
}

INT_PTR CALLBACK SummaryPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Summary_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Summary_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_DESTROY:
            Summary_OnDestroy(hdlg);
            break;
            
        case WM_NOTIFY:
            bHandled = Summary_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}


/********************************************************************************
    Schedule property sheet code
*********************************************************************************/

void Sched_EnableScheduleButtons(HWND hdlg)
{
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    BOOL bEditAllowed = !(pBuf->m_dwPropSheetFlags & 
                            (PSF_NO_EDITING_SCHEDULES | PSF_NO_SCHEDULED_UPDATES));
    BOOL bEnable = (bEditAllowed) &&
                   ListView_GetSelectedCount(GetDlgItem(hdlg, IDC_SCHEDULE_LIST));

    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_NEW), bEditAllowed);
    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_EDIT), bEnable);

    //  TODO: Don't enable remove for publisher's schedule
    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_REMOVE), bEnable);
}

struct SCHED_ENUM_DATA
{
    HWND hwndSchedList;
    POOEBuf pBuf;
    SYNCSCHEDULECOOKIE customSchedule;
    BOOL bHasAtLeastOneSchedule;
};

struct SCHED_LIST_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
    BOOL bChecked;
    BOOL bStartChecked;
};

inline int SchedList_GetIndex(HWND hwndSchedList, int index)
{
    return (index != -1) ? index :
           ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);
}

void SchedList_GetName(HWND hwndSchedList, int index, TCHAR *pszSchedName, int cchSchedName)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_TEXT;
        lvi.pszText = pszSchedName;
        lvi.cchTextMax = cchSchedName;
        ListView_GetItem(hwndSchedList, &lvi);
    }
}

void SchedList_SetName(HWND hwndSchedList, int index, LPTSTR pszSchedName)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_TEXT;
        lvi.pszText = pszSchedName;
        ListView_SetItem(hwndSchedList, &lvi);
    }
}

SCHED_LIST_DATA *SchedList_GetData(HWND hwndSchedList, int index)
{
    SCHED_LIST_DATA *psld = NULL;
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_PARAM;
        if (ListView_GetItem(hwndSchedList, &lvi))
        {
            psld = (SCHED_LIST_DATA *)lvi.lParam;
        }
    }

    return psld;
}

void SchedList_UncheckAll(HWND hwndSchedList)
{
    int count = ListView_GetItemCount(hwndSchedList);
    
    for (int i = 0; i < count; i++)
    {
        SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

        if (NULL != psld)
        {
            psld->bChecked = 0;
            ListView_SetItemState(hwndSchedList, i, COMP_UNCHECKED, LVIS_STATEIMAGEMASK);
        }
    }
}

void SchedList_Select(HWND hwndSchedList, int index)
{
    int curIndex = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);

    if (curIndex != index)
    {
        ListView_SetItemState(hwndSchedList, curIndex, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(hwndSchedList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void SchedList_DeleteData(HWND hwndSchedList, int index, BOOL bDeleteItem)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {

        SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, lvi.iItem);

        lvi.mask = LVIF_PARAM;
        lvi.lParam = NULL;

        if ((NULL != psld) && ListView_SetItem(hwndSchedList, &lvi))
        {
            delete psld;
        }

        if (bDeleteItem)
        {
            ListView_DeleteItem(hwndSchedList, lvi.iItem);
        }
    }
}

void SchedList_DeleteAllData(HWND hwndSchedList)
{
    int count = ListView_GetItemCount(hwndSchedList);
    
    for (int i = 0; i < count; i++)
    {
        SchedList_DeleteData(hwndSchedList, i, FALSE);
    }
}

BOOL Sched_EnumCallback(ISyncSchedule *pSyncSchedule, 
                        SYNCSCHEDULECOOKIE *pSchedCookie,
                        LPARAM lParam)
{
    BOOL bAdded = FALSE;
    SCHED_ENUM_DATA *psed = (SCHED_ENUM_DATA *)lParam;
    DWORD dwSyncScheduleFlags;
    SCHED_LIST_DATA *psld = NULL;

    if (SUCCEEDED(pSyncSchedule->GetFlags(&dwSyncScheduleFlags)))
    {
        //  This checks to make sure we only add a publisher's schedule to the
        //  list if it belongs to this item.
        if ((!(dwSyncScheduleFlags & SYNCSCHEDINFO_FLAGS_READONLY)) ||
            (*pSchedCookie == psed->customSchedule))
        {
            psld = new SCHED_LIST_DATA;

            if (NULL != psld)
            {
                WCHAR wszName[MAX_PATH];
                DWORD cchName = ARRAYSIZE(wszName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchName, wszName)))
                {
                    TCHAR szName[MAX_PATH];

                    MyOleStrToStrN(szName, ARRAYSIZE(szName), wszName);

                    psld->SchedCookie = *pSchedCookie;
                    psld->bStartChecked = IsCookieOnSchedule(pSyncSchedule, &psed->pBuf->m_Cookie);
                    psld->bChecked = psld->bStartChecked;

                    if (psld->bStartChecked)
                    {
                        psed->bHasAtLeastOneSchedule = TRUE;
                    }

                    LV_ITEM lvItem = { 0 };

                    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                    lvItem.iItem = (*pSchedCookie == psed->customSchedule) ? 0 : 0x7FFFFFFF;
                    lvItem.lParam = (LPARAM)psld;
                    lvItem.pszText = szName;

                    int index = ListView_InsertItem(psed->hwndSchedList, &lvItem);

                    if (index != -1)
                    {
                            
                        ListView_SetItemState(psed->hwndSchedList, index, 
                                              psld->bStartChecked ? COMP_CHECKED : COMP_UNCHECKED, 
                                              LVIS_STATEIMAGEMASK);
                        ListView_SetColumnWidth(psed->hwndSchedList, 0, LVSCW_AUTOSIZE);
                        bAdded = TRUE;
                    }
                }
            }
        }
    }

    if (!bAdded)
    {
        SAFEDELETE(psld);
    }
    
    return TRUE;
}

BOOL Sched_FillScheduleList(HWND hdlg, POOEBuf pBuf)
{
    SCHED_ENUM_DATA sed;

    sed.hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    sed.pBuf = pBuf;

    sed.customSchedule = GUID_NULL;
    
    ISubscriptionItem *psi;
    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi)))
    {
        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

        if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
        {
            sed.customSchedule = sii.ScheduleGroup;
        }
        psi->Release();
    }
    sed.bHasAtLeastOneSchedule = FALSE;

    EnumSchedules(Sched_EnumCallback, (LPARAM)&sed);

    return sed.bHasAtLeastOneSchedule;
}

BOOL Sched_NewSchedule(HWND hdlg)
{
    NEWSCHED_DATA nsd;

    INT_PTR nResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_NEW_SCHEDULE),
                                 hdlg, NewScheduleDlgProc, (LPARAM)&nsd);

    if (IDOK == nResult)
    {
        SCHED_LIST_DATA *psld;
        LV_FINDINFO lvfi = { 0 };
        HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);

        lvfi.flags = LVFI_STRING;
        lvfi.psz = nsd.szSchedName;

        int index = ListView_FindItem(hwndSchedList, -1, &lvfi);

        if (index == -1)
        {

            psld = new SCHED_LIST_DATA;           
            
            if (NULL != psld)
            {
                psld->SchedCookie = nsd.SchedCookie;
                psld->bChecked = TRUE;
                psld->bStartChecked = FALSE;

                LV_ITEM lvItem = { 0 };

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.iItem = 0;
                lvItem.lParam = (LPARAM)psld;
                lvItem.pszText = nsd.szSchedName;

                index = ListView_InsertItem(hwndSchedList, &lvItem);
            }
        }
        else
        {
            psld = SchedList_GetData(hwndSchedList, index);
            if (NULL != psld)
            {
                psld->bChecked = TRUE;
            }
        }

        if (index != -1)
        {
            ListView_SetItemState(hwndSchedList, index, COMP_CHECKED, LVIS_STATEIMAGEMASK);
            ListView_SetColumnWidth(hwndSchedList, 0, LVSCW_AUTOSIZE);
            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                             IDC_SCHEDULED_SYNC);
            SchedList_Select(hwndSchedList, index);
            Sched_EnableScheduleButtons(hdlg);
        }

    }

    SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hdlg, IDC_SCHEDULE_LIST), TRUE);

    return nResult == IDOK;
}

BOOL Sched_EditSchedule(HWND hdlg, POOEBuf pBuf)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    ASSERT(NULL != pBuf);

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {

        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {   
            HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
            int index = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);
            SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, index);

            if (NULL != psld)
            {
                ISyncSchedule *pSyncSchedule;

                hr = pSyncScheduleMgr->OpenSchedule(&psld->SchedCookie, 0, &pSyncSchedule);

                if (SUCCEEDED(hr))
                {
                    if (psld->bChecked)
                    {
                        hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                         &pBuf->m_Cookie,
                                                         SYNCMGRITEMSTATE_CHECKED);
                    }
                    
                    hr = pSyncSchedule->EditSyncSchedule(hdlg, 0);

                    if (S_OK == hr)
                    {
                        psld->bChecked = IsCookieOnSchedule(pSyncSchedule, &pBuf->m_Cookie);

                        if (psld->bChecked)
                        {
                            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                                             IDC_SCHEDULED_SYNC);
                        }

                        ListView_SetItemState(hwndSchedList, index, 
                                              psld->bChecked ? COMP_CHECKED : COMP_UNCHECKED, 
                                              LVIS_STATEIMAGEMASK);
                    }

                    WCHAR wszScheduleName[MAX_PATH];
                    DWORD cchScheduleName = ARRAYSIZE(wszScheduleName);

                    if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchScheduleName, wszScheduleName)))
                    {
                        SchedList_SetName(hwndSchedList, index, wszScheduleName);

                        ListView_SetColumnWidth(hwndSchedList, 0, LVSCW_AUTOSIZE);
                    }


                    SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)hwndSchedList, TRUE);

                    pSyncSchedule->Release();
                }
                pSyncScheduleMgr->Release();
            }
        }
        CoUninitialize();
    }

    //  This is not undoable by hitting cancel so don't say we changed.
    return FALSE;
}

BOOL Sched_RemoveSchedule(HWND hdlg)
{
    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    int index = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);

    if (index >= 0)
    {
        SCHED_LIST_DATA *psld = SchedList_GetData(GetDlgItem(hdlg, IDC_SCHEDULE_LIST), index);

        if (NULL != psld)
        {
            TCHAR szSchedName[MAX_PATH];

            SchedList_GetName(hwndSchedList, index, szSchedName, ARRAYSIZE(szSchedName));

            if (WCMessageBox(hdlg, IDS_CONFIRM_SCHEDULE_DELETE,
                            IDS_SCHEDULE_DELETE_CAPTION, MB_YESNO | MB_ICONQUESTION,
                            szSchedName) == IDYES)
            {
                HRESULT hr = CoInitialize(NULL);
                if (SUCCEEDED(hr))
                {
                    ISyncScheduleMgr *pSyncScheduleMgr;
                    hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                                          IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

                    if (SUCCEEDED(hr))
                    {                
                        hr = pSyncScheduleMgr->RemoveSchedule(&psld->SchedCookie);

                        ASSERT(SUCCEEDED(hr));

                        if (SUCCEEDED(hr))
                        {
                            SchedList_DeleteData(hwndSchedList, -1, TRUE);
                            SchedList_Select(hwndSchedList, 0);
                        }

                        pSyncScheduleMgr->Release();
                    }
                    CoUninitialize();
                }
            }

            SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hdlg, IDC_SCHEDULE_LIST), TRUE);
        }
    }
    //  This is not undoable by hitting cancel so don't say we changed.
    return FALSE;
}

BOOL Sched_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = GetBuf(hdlg);

    if (NULL != pBuf)
    {

        switch (wID)
        {
            case IDC_MANUAL_SYNC:
            case IDC_SCHEDULED_SYNC:
//            case IDC_IDLE_ONLY:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = TRUE;
                }
                break;
            
            case IDC_SCHEDULE_NEW:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_NewSchedule(hdlg);
                }
                break;

            case IDC_SCHEDULE_EDIT:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_EditSchedule(hdlg, pBuf);
                }
                break;

            case IDC_SCHEDULE_REMOVE:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_RemoveSchedule(hdlg);
                }
                break;

            default:
                bHandled = FALSE;
                break;
        }
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bHandled;
}

BOOL Sched_Validate(HWND hdlg, POOEBuf pBuf)
{
/*
    if (IsDlgButtonChecked(hdlg, IDC_IDLE_ONLY))
    {
        pBuf->grfTaskTrigger |= TASK_FLAG_START_ONLY_IF_IDLE;
    }
    else
    {
        pBuf->grfTaskTrigger &= ~TASK_FLAG_START_ONLY_IF_IDLE;
    }
*/

    if (IsDlgButtonChecked(hdlg, IDC_SCHEDULED_SYNC))
    {
        HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
        int count = ListView_GetItemCount(hwndSchedList);

        BOOL bHaveASchedule = FALSE;
        
        for (int i = 0; i < count; i++)
        {
            SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

            if (NULL != psld && psld->bChecked)
            {
                bHaveASchedule = TRUE;
                break;
            }
        }

        if (!bHaveASchedule)
        {
            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                             IDC_MANUAL_SYNC);
        }
    }

    return TRUE;
}

BOOL Sched_ApplyProps(HWND hdlg, POOEBuf pBuf)
{
    BOOL bResult;
    HRESULT hr;

    pBuf->dwFlags = PROP_WEBCRAWL_ALL;

    bResult = SUCCEEDED(SaveBufferChange(pBuf, TRUE));

    if (bResult)
    {
        
        if (IsDlgButtonChecked(hdlg, IDC_MANUAL_SYNC))
        {
            SchedList_UncheckAll(GetDlgItem(hdlg, IDC_SCHEDULE_LIST));
            hr = RemoveItemFromAllSchedules(&pBuf->m_Cookie);

            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
            int count = ListView_GetItemCount(hwndSchedList);
            
            for (int i = 0; i < count; i++)
            {
                SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

                ASSERT(NULL != psld);

                if (NULL != psld)
                {
                    if (psld->bChecked != psld->bStartChecked)
                    {
                        if (psld->bChecked)
                        {
                            ISubscriptionItem *psi;

                            if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, 
                                                                     &pBuf->m_Cookie,
                                                                     &psi)))
                            {
                                SYNC_HANDLER_ITEM_INFO shii;

                                shii.handlerID = CLSID_WebCheckOfflineSync;
                                shii.itemID = pBuf->m_Cookie;
                                shii.hIcon = NULL;
                                MyStrToOleStrN(shii.wszItemName, 
                                               ARRAYSIZE(shii.wszItemName),
                                               pBuf->m_Name);
                                shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

                                AddScheduledItem(&shii, &psld->SchedCookie);
                            }
                        }
                        else
                        {
                            RemoveScheduledItem(&pBuf->m_Cookie, &psld->SchedCookie);
                        }
                        psld->bStartChecked = psld->bChecked;
                    }
                }
            }
        }
    }

    return bResult;
}

BOOL Sched_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);
    
    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            if (!Sched_Validate(hdlg, pBuf))
            {
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
            }
            break;

        case PSN_APPLY:
            Sched_ApplyProps(hdlg, pBuf);
            break;

        case NM_DBLCLK:
            if (IDC_SCHEDULE_LIST == pnmh->idFrom)
            {
                Sched_EditSchedule(hdlg, pBuf);
            }
            break;
            
        case LVN_ITEMCHANGED:
        {
            NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)pnmh;
            if ((pnmlv->iItem != -1) && 
                (pnmlv->uChanged & LVIF_STATE) &&
                ((pnmlv->uNewState ^ pnmlv->uOldState) & COMP_CHECKED))

            {
                SCHED_LIST_DATA *psld = SchedList_GetData(pnmh->hwndFrom, pnmlv->iItem);

                if (NULL != psld)
                {
                    psld->bChecked = (pnmlv->uNewState & COMP_CHECKED) ? TRUE : FALSE;

                    if (psld->bChecked)
                    {
                        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                                         IDC_SCHEDULED_SYNC);
                    }
                    PropSheet_Changed(GetParent(hdlg), hdlg);
                }
            }

            if ((pnmlv->uChanged & LVIF_STATE) &&
                ((pnmlv->uNewState ^ pnmlv->uOldState) & LVIS_SELECTED))
            {
                Sched_EnableScheduleButtons(hdlg);
            }
            break;
        }

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

void Sched_OnDestroy(HWND hdlg)
{
    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);

    SchedList_DeleteAllData(hwndSchedList);
}

BOOL Sched_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  Now read in values and populate the dialog
    POOEBuf pBuf = (POOEBuf)((LPPROPSHEETPAGE)lParam)->lParam;

/*    CheckDlgButton(hdlg, IDC_IDLE_ONLY, 
                   pBuf->grfTaskTrigger & TASK_FLAG_START_ONLY_IF_IDLE ?
                   1 : 0);
*/

    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    ListView_SetExtendedListViewStyle(hwndSchedList, LVS_EX_CHECKBOXES);

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwndSchedList, 0, &lvc);

    //  Now handle restrictions
    SetPropSheetFlags(pBuf, SHRestricted2W(REST_NoScheduledUpdates, NULL, 0), PSF_NO_SCHEDULED_UPDATES);
    SetPropSheetFlags(pBuf, SHRestricted2W(REST_NoEditingScheduleGroups, NULL, 0), PSF_NO_EDITING_SCHEDULES);

    BOOL bHasSchedules = Sched_FillScheduleList(hdlg, pBuf);
    
    if (pBuf->m_dwPropSheetFlags & PSF_NO_SCHEDULED_UPDATES)
    {
        EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_LIST), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULED_SYNC), FALSE);
        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, IDC_MANUAL_SYNC);
    }
    else
    {
        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                         bHasSchedules ? IDC_SCHEDULED_SYNC : IDC_MANUAL_SYNC);
    }

    SchedList_Select(hwndSchedList, 0);

    //  Finally, do the enable/disable controls thing...
    Sched_EnableScheduleButtons(hdlg);

    return TRUE;
}

INT_PTR CALLBACK SchedulePropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Sched_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Sched_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            bHandled = Sched_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_DESTROY:
            Sched_OnDestroy(hdlg);
            //  return 0
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    Download property sheet code
*********************************************************************************/

void Download_EnableFollowLinks(HWND hdlg)
{
    BOOL bTranslate;
    int i = GetDlgItemInt(hdlg, IDC_LEVELS, &bTranslate, FALSE);

    EnableWindow(GetDlgItem(hdlg, IDC_FOLLOW_LINKS), (bTranslate && i));
}

void Download_EnableLimitSpaceControls(HWND hdlg)
{
    static const int IDs[] = { IDC_LIMIT_SPACE_EDIT, IDC_LIMIT_SPACE_SPIN, IDC_LIMIT_SPACE_TEXT };
    EnableControls(hdlg, IDs, ARRAYSIZE(IDs), IsDlgButtonChecked(hdlg, IDC_LIMIT_SPACE_CHECK));
}

void Download_EnableEmailControls(HWND hdlg)
{
    static const int IDs[] = { IDC_EMAIL_ADDRESS_TEXT, IDC_EMAIL_ADDRESS, 
                               IDC_EMAIL_SERVER_TEXT, IDC_EMAIL_SERVER };
    EnableControls(hdlg, IDs, ARRAYSIZE(IDs), IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY));
}

BOOL Download_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  First do basic control setup
    HWND hwndLimitSpin = GetDlgItem(hdlg, IDC_LIMIT_SPACE_SPIN);
    SendMessage(hwndLimitSpin, UDM_SETRANGE, 0, 
                MAKELONG(MAX_DOWNLOAD_K, MIN_DOWNLOAD_K));

    UDACCEL ua[] = { {0, 1}, {1, 10}, {2, 100}, {3, 1000} };
    SendMessage(hwndLimitSpin, UDM_SETACCEL, ARRAYSIZE(ua), (LPARAM)ua);

    Edit_LimitText(GetDlgItem(hdlg, IDC_LIMIT_SPACE_EDIT), 5);

    //  Now read in values and populate the dialog
    pBuf = (POOEBuf)((LPPROPSHEETPAGE)lParam)->lParam;

    SUBSCRIPTIONTYPE subType = GetItemCategory(pBuf);
    switch (subType)
    {
        case SUBSTYPE_CHANNEL:
        case SUBSTYPE_DESKTOPCHANNEL:
            CheckRadioButton(hdlg, IDC_DOWNLOAD_ALL, IDC_DOWNLOAD_MIN,
                             pBuf->fChannelFlags & CHANNEL_AGENT_PRECACHE_ALL ? 
                             IDC_DOWNLOAD_ALL : IDC_DOWNLOAD_MIN);
            break;

        case SUBSTYPE_URL:
        case SUBSTYPE_DESKTOPURL:
        case SUBSTYPE_EXTERNAL:
        {
            HWND hwndLevelsSpin = GetDlgItem(hdlg, IDC_LEVELS_SPIN);
            SendMessage(hwndLevelsSpin, UDM_SETRANGE, 0, MAKELONG(MAX_WEBCRAWL_LEVELS, 0));
            SendMessage(hwndLevelsSpin, UDM_SETPOS, 0, pBuf->m_RecurseLevels);
            CheckDlgButton(hdlg, IDC_FOLLOW_LINKS, 
                           (pBuf->m_RecurseFlags & WEBCRAWL_LINKS_ELSEWHERE) || (0 == pBuf->m_RecurseLevels)
                           ? 1 : 0);
            Download_EnableFollowLinks(hdlg);
            break;
        }
    }

    SendMessage(hwndLimitSpin, UDM_SETPOS, 0, pBuf->m_SizeLimit ? pBuf->m_SizeLimit : DEF_DOWNLOAD_K);
    CheckDlgButton(hdlg, IDC_LIMIT_SPACE_CHECK, pBuf->m_SizeLimit ? 1 : 0);

    CheckDlgButton(hdlg, IDC_EMAIL_NOTIFY, pBuf->bMail ? 1 : 0);

    TCHAR szText[MAX_PATH];

    ReadDefaultEmail(szText, ARRAYSIZE(szText));
    Edit_LimitText(GetDlgItem(hdlg, IDC_EMAIL_ADDRESS), MAX_PATH - 1);
    SetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szText);

    ReadDefaultSMTPServer(szText, ARRAYSIZE(szText));
    Edit_LimitText(GetDlgItem(hdlg, IDC_EMAIL_SERVER), MAX_PATH - 1);
    SetDlgItemText(hdlg, IDC_EMAIL_SERVER, szText);

    //  Now handle restrictions
    if (SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        EnableWindow(GetDlgItem(hdlg, IDC_LOGIN), FALSE);
    }

    //  Finally, do the enable/disable controls thing...
    Download_EnableLimitSpaceControls(hdlg);
    Download_EnableEmailControls(hdlg);

    return TRUE;
}

BOOL Download_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = GetBuf(hdlg);

    if (NULL != pBuf)
    {
        switch (wID)
        {
            case IDC_LIMIT_SPACE_EDIT:
                if (wNotifyCode == EN_CHANGE)
                {
                    if (pBuf->m_SizeLimit != 
                        LOWORD(SendDlgItemMessage(hdlg, IDC_LIMIT_SPACE_SPIN, UDM_GETPOS, 0, 0)))
                    {
                        bChanged = TRUE;
                    }
                }
                else if (wNotifyCode == EN_KILLFOCUS)
                {
                    KeepSpinNumberInRange(hdlg, IDC_LIMIT_SPACE_EDIT, 
                                          IDC_LIMIT_SPACE_SPIN, 
                                          MIN_DOWNLOAD_K, MAX_DOWNLOAD_K);
                }
                break;
            
            case IDC_LEVELS:
                if (wNotifyCode == EN_UPDATE)
                {
                    int levels = KeepSpinNumberInRange(hdlg, IDC_LEVELS, 
                                    IDC_LEVELS_SPIN, 0, MAX_WEBCRAWL_LEVELS);

                    if (pBuf->m_RecurseLevels != levels)
                    {
                        bChanged = TRUE;
                    }
                    Download_EnableFollowLinks(hdlg);
                }
                break;

            case IDC_LIMIT_SPACE_CHECK:
                if (wNotifyCode == BN_CLICKED)
                {
                    Download_EnableLimitSpaceControls(hdlg);
                    bChanged = TRUE;
                }
                break;
                
            case IDC_FOLLOW_LINKS:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_EMAIL_NOTIFY:
                if (wNotifyCode == BN_CLICKED)
                {
                    Download_EnableEmailControls(hdlg);
                    bChanged = TRUE;
                }
                break;
                
            case IDC_EMAIL_ADDRESS:
            case IDC_EMAIL_SERVER:
                if (wNotifyCode == EN_CHANGE)
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_LOGIN:
                if ((wNotifyCode == BN_CLICKED) &&
                    (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SUBSPROPS_LOGIN),
                                    hdlg, LoginOptionDlgProc, (LPARAM)pBuf) == IDOK))
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_ADVANCED:
                if ((wNotifyCode == BN_CLICKED) &&
                    (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SUBSPROPS_ADVANCED),
                                    hdlg, AdvancedDownloadDlgProc, (LPARAM)pBuf) == IDOK))
                {
                    bChanged = TRUE;
                }
                break;

            default:
                bHandled = FALSE;
                break;
        }
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bHandled;
}

BOOL Download_Validate(HWND hdlg, POOEBuf pBuf)
{
    pBuf->bMail = IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY);

    if (pBuf->bMail)
    {
        TCHAR szEmail[MAX_PATH];
        TCHAR szServer[MAX_PATH];

        GetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail));
        GetDlgItemText(hdlg, IDC_EMAIL_SERVER, szServer, ARRAYSIZE(szServer));

        if (!szEmail[0] || !szServer[0])
        {
            SGMessageBox(hdlg, IDS_EMAIL_INCOMPLETE, MB_ICONWARNING);
            return FALSE;
        }
    }

    SUBSCRIPTIONTYPE subType = GetItemCategory(pBuf);
    switch (subType)
    {
        case SUBSTYPE_CHANNEL:
        case SUBSTYPE_DESKTOPCHANNEL:
            pBuf->fChannelFlags &= ~(CHANNEL_AGENT_PRECACHE_SOME | CHANNEL_AGENT_PRECACHE_ALL);
            if (IsDlgButtonChecked(hdlg, IDC_DOWNLOAD_ALL))
            {
                pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;
            }
            else
            {
                pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;
            }
            break;

        case SUBSTYPE_URL:
        case SUBSTYPE_DESKTOPURL:
        case SUBSTYPE_EXTERNAL:
        {
            if (IsDlgButtonChecked(hdlg, IDC_FOLLOW_LINKS))
            {
                pBuf->m_RecurseFlags |= WEBCRAWL_LINKS_ELSEWHERE;
            }
            else
            {
                pBuf->m_RecurseFlags &= ~WEBCRAWL_LINKS_ELSEWHERE;
            }

            pBuf->m_RecurseLevels = LOWORD(SendDlgItemMessage(hdlg, 
                                           IDC_LEVELS_SPIN, UDM_GETPOS, 0, 0));

            ASSERT((pBuf->m_RecurseLevels >= 0) &&
                   (pBuf->m_RecurseLevels <= MAX_WEBCRAWL_LEVELS));
        }
    }

    pBuf->m_SizeLimit = IsDlgButtonChecked(hdlg, IDC_LIMIT_SPACE_CHECK) ? 
                        (LONG)SendDlgItemMessage(hdlg, IDC_LIMIT_SPACE_SPIN,
                                           UDM_GETPOS, 0, 0) : 
                        0;
    ASSERT((0 == pBuf->m_SizeLimit) ||
           ((pBuf->m_SizeLimit >= MIN_DOWNLOAD_K) && 
            (pBuf->m_SizeLimit <= MAX_DOWNLOAD_K)));

    return TRUE;
}

BOOL Download_ApplyProps(HWND hdlg, POOEBuf pBuf)
{
    pBuf->dwFlags = PROP_WEBCRAWL_ALL;

    if (IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY))
    {
        TCHAR szText[MAX_PATH];

        GetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szText, ARRAYSIZE(szText));
        WriteDefaultEmail(szText);
        GetDlgItemText(hdlg, IDC_EMAIL_SERVER, szText, ARRAYSIZE(szText));
        WriteDefaultSMTPServer(szText);
    }

    if (pBuf->bChannel)
    {
        pBuf->dwFlags |= PROP_WEBCRAWL_CHANNELFLAGS;
    }

    return SUCCEEDED(SaveBufferChange(pBuf, TRUE));
}

BOOL Download_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);
    
    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            if (!Download_Validate(hdlg, pBuf))
            {
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
            }
            break;

        case PSN_APPLY:
            Download_ApplyProps(hdlg, pBuf);
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK DownloadPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Download_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Download_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            bHandled = Download_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    New schedule popup code
*********************************************************************************/

BOOL NewSched_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = FALSE;
    
    switch (wID)
    {
        case IDC_SCHEDULE_DAYS:
            if (wNotifyCode == EN_UPDATE)
            {
                KeepSpinNumberInRange(hdlg, IDC_SCHEDULE_DAYS, 
                                      IDC_SCHEDULE_DAYS_SPIN, 1, 99);
            }
#ifdef NEWSCHED_AUTONAME
            else if (wNotifyCode == EN_CHANGE)
            {
                NewSched_AutoNameHelper(hdlg);
            }
#endif
            bHandled = TRUE;
            break;

        case IDOK:
        {
            TASK_TRIGGER trig;
            NEWSCHED_DATA *pnsd = (NEWSCHED_DATA*) GetWindowLongPtr(hdlg, DWLP_USER);

            ASSERT(NULL != pnsd);
            
            if (NewSched_ResolveNameConflictHelper(hdlg, &trig, &pnsd->SchedCookie))
            {
                NewSched_CreateScheduleHelper(hdlg, &trig, &pnsd->SchedCookie);

                GetDlgItemText(hdlg, IDC_SCHEDULE_NAME, 
                               pnsd->szSchedName, ARRAYSIZE(pnsd->szSchedName));
                EndDialog(hdlg, IDOK);
            }
            break;
        }


        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            break;
    }

    return bHandled;
}

#ifdef NEWSCHED_AUTONAME
BOOL NewSched_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;

    switch (pnmh->code)
    {
        case DTN_DATETIMECHANGE:
            NewSched_AutoNameHelper(hdlg);
            break;
            
        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}
#endif

INT_PTR CALLBACK NewScheduleDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);
            NewSched_OnInitDialogHelper(hdlg);
            bHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            bHandled = NewSched_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

#ifdef NEWSCHED_AUTONAME
        case WM_NOTIFY:
            bHandled = NewSched_OnNotify(hdlg, wParam, (LPNMHDR)lParam);
            break;            
#endif

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }

    return bHandled;
}


/********************************************************************************
    Advanced properties code
*********************************************************************************/

BOOL Advanced_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != (POOEBuf)lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, lParam);

    pBuf = (POOEBuf)lParam;

    UINT flags = pBuf->m_RecurseFlags;
    CheckDlgButton(hdlg, IDC_DOWNLOAD_IMAGES, flags & WEBCRAWL_GET_IMAGES);
    CheckDlgButton(hdlg, IDC_DOWNLOAD_APPLETS, flags & WEBCRAWL_GET_CONTROLS);
    CheckDlgButton(hdlg, IDC_DOWNLOAD_MEDIA, 
                   flags & (WEBCRAWL_GET_BGSOUNDS | WEBCRAWL_GET_VIDEOS));

    CheckDlgButton(hdlg, IDC_DOWNLOAD_ONLY_HTML_LINKS, flags & WEBCRAWL_ONLY_LINKS_TO_HTML);

    return TRUE;
}

void Advanced_SetFlag(HWND hdlg, POOEBuf pBuf, int ID, LONG flags)
{
    if (IsDlgButtonChecked(hdlg, ID))
    {
        pBuf->m_RecurseFlags |= flags;
    }
    else
    {
        pBuf->m_RecurseFlags &= ~flags;
    }
}

BOOL Advanced_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    switch (wID)
    {
        case IDOK:
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_IMAGES, WEBCRAWL_GET_IMAGES);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_APPLETS, WEBCRAWL_GET_CONTROLS);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_MEDIA, 
                             WEBCRAWL_GET_BGSOUNDS | WEBCRAWL_GET_VIDEOS);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_ONLY_HTML_LINKS, WEBCRAWL_ONLY_LINKS_TO_HTML);
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case IDC_DOWNLOAD_IMAGES:
        case IDC_DOWNLOAD_APPLETS:
        case IDC_DOWNLOAD_MEDIA:
        case IDC_DOWNLOAD_ONLY_HTML_LINKS:
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK AdvancedDownloadDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
            bHandled = Advanced_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Advanced_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;
            
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    Login properties code
*********************************************************************************/

BOOL Login_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != (POOEBuf)lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, lParam);

    pBuf = (POOEBuf)lParam;

    Edit_LimitText(GetDlgItem(hdlg, IDC_USERNAME), ARRAYSIZE(pBuf->username) - 1);
    SetDlgItemText(hdlg, IDC_USERNAME, pBuf->username);

    Edit_LimitText(GetDlgItem(hdlg, IDC_PASSWORD), ARRAYSIZE(pBuf->password) - 1);
    SetDlgItemText(hdlg, IDC_PASSWORD, pBuf->password);

    Edit_LimitText(GetDlgItem(hdlg, IDC_PASSWORDCONFIRM), ARRAYSIZE(pBuf->password) - 1);
    SetDlgItemText(hdlg, IDC_PASSWORDCONFIRM, pBuf->password);

    return TRUE;
}

BOOL Login_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    switch (wID)
    {
        case IDOK:
        {
            TCHAR szUsername[ARRAYSIZE(pBuf->username) + 1];
            TCHAR szPassword[ARRAYSIZE(pBuf->password) + 1];
            TCHAR szPasswordConfirm[ARRAYSIZE(pBuf->password) + 1];

            GetDlgItemText(hdlg, IDC_USERNAME, szUsername, ARRAYSIZE(szUsername));
            GetDlgItemText(hdlg, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));
            GetDlgItemText(hdlg, IDC_PASSWORDCONFIRM, szPasswordConfirm, ARRAYSIZE(szPasswordConfirm));

            if (!szUsername[0] && (szPassword[0] || szPasswordConfirm[0]))
            {
                SGMessageBox(hdlg, 
                            (pBuf->bChannel ? IDS_NEEDCHANNELUSERNAME : IDS_NEEDUSERNAME), 
                            MB_ICONWARNING);
            }
            else if (szUsername[0] && !szPassword[0])
            {
                SGMessageBox(hdlg, 
                            (pBuf->bChannel ? IDS_NEEDCHANNELPASSWORD : IDS_NEEDPASSWORD), 
                            MB_ICONWARNING);
            }
            else if (StrCmp(szPassword, szPasswordConfirm) != 0)
            {
                SGMessageBox(hdlg, IDS_MISMATCHED_PASSWORDS, MB_ICONWARNING);
            }
            else
            {
                StrCpyN(pBuf->username, szUsername, ARRAYSIZE(pBuf->username));
                StrCpyN(pBuf->password, szPassword, ARRAYSIZE(pBuf->password));
                pBuf->dwFlags |= (PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
                EndDialog(hdlg, IDOK);
            }
            break;
        }
 
        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK LoginOptionDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
            bHandled = Login_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Login_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

//
// Read the users default email address and smtp from the Athena Account Mgr
//
// Expects lpszEmailAddress and lpszSMTPServer to pt to char buffers of 
// CCHMAX_EMAIL_ADDRESS and CCHMAX_SERVER_NAME size, resp.
//
BOOL ReadAthenaMailSettings(LPSTR lpszEmailAddress, LPSTR lpszSMTPServer)
{
    //
    // This api gets called from threads that haven't used COM before so wrap
    // in CoInitialize/CoUninitialize
    //
    HRESULT hr = CoInitialize(NULL);
    ASSERT(SUCCEEDED(hr));

    //
    // Create an Internet Mail and News Account Manager
    //
    IImnAccountManager * pAccountManager;
    hr = CoCreateInstance(
        CLSID_ImnAccountManager,
        NULL,                       // no aggregation
        CLSCTX_INPROC_SERVER,       // inproc server implemented in webcheck.dll
        IID_IImnAccountManager,     //
        (void **)&pAccountManager);

    if (SUCCEEDED(hr)) {
        hr = pAccountManager->Init(NULL);

        if (SUCCEEDED(hr)) {
            //
            // Get the default SMTP account
            //
            IImnAccount * pAccount;
            hr = pAccountManager->GetDefaultAccount(ACCT_MAIL, &pAccount);

            if (hr == S_OK) {               
                //
                // Get the SMTP_SERVER name for this account
                //
                if (NULL != lpszSMTPServer)
                {
                    hr = pAccount->GetPropSz(
                        AP_SMTP_SERVER, 
                        lpszSMTPServer,
                        CCHMAX_SERVER_NAME);
                }
                
                //
                // Get the Users email address for this account
                //

                if (NULL != lpszEmailAddress)
                {
                    hr |= pAccount->GetPropSz(
                        AP_SMTP_EMAIL_ADDRESS, 
                        lpszEmailAddress,
                        CCHMAX_EMAIL_ADDRESS);
                }

                pAccount->Release();    // done with IImnAccount
            }
        }
        pAccountManager->Release();     // done with IImnAccountManager
    }

    //
    // This api gets called from threads that haven't used COM before so wrap
    // in CoInitialize/CoUninitialize
    //
    CoUninitialize();

    if (hr == S_OK)
        return TRUE;
    else
        return FALSE;
}

void ReadDefaultEmail(LPTSTR szBuf, UINT cch)
{
    ASSERT(szBuf);

    szBuf[0] = (TCHAR)0;
    if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefEmail, szBuf, cch * sizeof(TCHAR)))
        return;

    //  TODO: Look for eudora/netscape as well
    CHAR szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    if (ReadAthenaMailSettings(szEmailAddress, NULL))
    {
        SHAnsiToTChar(szEmailAddress, szBuf, cch);
    }
}

void WriteDefaultEmail(LPTSTR szBuf)
{
    ASSERT(szBuf);
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefEmail, szBuf, (lstrlen(szBuf) + 1) * sizeof(TCHAR), REG_SZ);
}

void ReadDefaultSMTPServer(LPTSTR szBuf, UINT cch)
{
    ASSERT(szBuf);

    szBuf[0] = (TCHAR)0;
    if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefServer, szBuf, cch * sizeof(TCHAR)))
        return;

    //  TODO: Look for eudora/netscape as well
    CHAR szSMTPServer[CCHMAX_SERVER_NAME];
    if (ReadAthenaMailSettings(NULL, szSMTPServer))
    {
        SHAnsiToTChar(szSMTPServer, szBuf, cch);
    }
}

void WriteDefaultSMTPServer(LPTSTR szBuf)
{
    ASSERT(szBuf);
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefServer, szBuf, (lstrlen(szBuf) + 1) * sizeof(TCHAR), REG_SZ);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wc.rc
//

#define CONTEXT_MENU_OFFLINE            2001

#define IDA_DOWNLOAD                    113

#define IDB_IDLE                        1000
#define IDB_SUBSCRIBE                   1001
#define IDB_SUBSCRIPTION_WIZARD         1002
#define IDB_SUMCHAN                     1003
#define IDB_TB_SMALL                    1004
#define IDB_UNSUBSCRIBE                 1005

#define IDCMD_ABORT                     3000
#define IDCMD_DETAILS                   3001
#define IDCMD_HIDE                      3002
#define IDCMD_SKIP                      3003

#define IDC_ADVANCED                    2000
#define IDC_AGENTSTATUS                 2001
#define IDC_CUSTOM_DAILY                2002
#define IDC_CUSTOM_DAILY_EVERYNDAYS     2003
#define IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT 2004
#define IDC_CUSTOM_DAILY_EVERYNDAYS_SPIN 2005
#define IDC_CUSTOM_DAILY_EVERYWEEKDAY   2006
#define IDC_CUSTOM_DAILY_STATIC1        2007
#define IDC_CUSTOM_GROUP_DAILY          2008
#define IDC_CUSTOM_GROUP_DEST           2009
#define IDC_CUSTOM_GROUP_EDIT           2010
#define IDC_CUSTOM_GROUP_LIST           2011
#define IDC_CUSTOM_GROUP_MONTHLY        2012
#define IDC_CUSTOM_GROUP_WEEKLY         2013
#define IDC_CUSTOM_MINIMIZENETUSE       2014
#define IDC_CUSTOM_MONTHLY              2015
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH   2016
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT 2017
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_SPIN 2018
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT 2019
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_SPIN 2020
#define IDC_CUSTOM_MONTHLY_PERIODIC     2021
#define IDC_CUSTOM_MONTHLY_PERIODIC_EDIT 2022
#define IDC_CUSTOM_MONTHLY_PERIODIC_LIST1 2023
#define IDC_CUSTOM_MONTHLY_PERIODIC_LIST2 2024
#define IDC_CUSTOM_MONTHLY_PERIODIC_SPIN 2025
#define IDC_CUSTOM_MONTHLY_STATIC1      2026
#define IDC_CUSTOM_MONTHLY_STATIC2      2027
#define IDC_CUSTOM_MONTHLY_STATIC3      2028
#define IDC_CUSTOM_MONTHLY_STATIC4      2029
#define IDC_CUSTOM_NEWGROUP             2030
#define IDC_CUSTOM_NEXTUPDATE           2031
#define IDC_CUSTOM_REMOVEGROUP          2032
#define IDC_CUSTOM_TIME_REPEATBETWEEN   2033
#define IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME 2034
#define IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME 2035
#define IDC_CUSTOM_TIME_REPEATEVERY     2036
#define IDC_CUSTOM_TIME_REPEATEVERY_EDIT 2037
#define IDC_CUSTOM_TIME_REPEATEVERY_SPIN 2038
#define IDC_CUSTOM_TIME_UPDATEAT        2039
#define IDC_CUSTOM_TIME_UPDATEAT_TIME   2040
#define IDC_CUSTOM_WEEKLY               2041
#define IDC_CUSTOM_WEEKLY_DAY1          2042
#define IDC_CUSTOM_WEEKLY_DAY2          2043
#define IDC_CUSTOM_WEEKLY_DAY3          2044
#define IDC_CUSTOM_WEEKLY_DAY4          2045
#define IDC_CUSTOM_WEEKLY_DAY5          2046
#define IDC_CUSTOM_WEEKLY_DAY6          2047
#define IDC_CUSTOM_WEEKLY_DAY7          2048
#define IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT 2049
#define IDC_CUSTOM_WEEKLY_REPEATWEEKS_SPIN 2050
#define IDC_CUSTOM_WEEKLY_STATIC1       2051
#define IDC_CUSTOM_WEEKLY_STATIC2       2052
#define IDC_DESKTOP_SUMMARY_TEXT        2053
#define IDC_DISABLE_AUTODISCONNECT      2054
#define IDC_DONTASKAGAIN                2055
#define IDC_DOWNLOAD_APPLETS            2056
#define IDC_DOWNLOAD_EXTERNALLINKS      2057
#define IDC_DOWNLOAD_IMAGES             2058
#define IDC_DOWNLOAD_MAXSIZE            2059
#define IDC_DOWNLOAD_MEDIA              2060
#define IDC_DRTRUNNING                  2061
#define IDC_DRTSTATUS                   2062
#define IDC_EMAIL_ADDRESS               2063
#define IDC_EMAIL_ADDRESS_TEXT          2064
#define IDC_EMAIL_NOTIFY                2065
#define IDC_EMAIL_SERVER                2066
#define IDC_EMAIL_SERVER_TEXT           2067
#define IDC_FOLLOW_LINKS                2068
#define IDC_GENERAL_PROMPT              2069
#define IDC_GENPROP_SCHED               2070
#define IDC_GENPROP_SUBSTYPE            2071
#define IDC_GENPROP_TYPEST              2072
#define IDC_GENPROP_UPDATEST            2073
#define IDC_GRP                         2074
//#define IDC_IDLE_ONLY                   2075
#define IDC_LAST                        2076
#define IDC_LAST_HEADING                2077
#define IDC_LEVELS                      2078
#define IDC_LEVELS_SPIN                 2079
#define IDC_LIMITSIZE                   2080
#define IDC_LIMIT_SPACE_CHECK           2081
#define IDC_LIMIT_SPACE_EDIT            2082
#define IDC_LIMIT_SPACE_SPIN            2083
#define IDC_LIMIT_SPACE_TEXT            2084
#define IDC_LOCATION                    2085
#define IDC_LOCSTATIC                   2086
#define IDC_LOGIN                       2087
#define IDC_LOGIN_PROMPT                2088
#define IDC_MANUAL_SYNC                 2089
#define IDC_MINBORDER                   2090
#define IDC_NAME                        2091
#define IDC_NAMESTATIC                  2092
#define IDC_NEXT                        2093
#define IDC_NEXT_HEADING                2094
#define IDC_PASSWORD                    2096
#define IDC_PROMPT_SUBSCRIBEME          2097
#define IDC_RESULT                      2098
#define IDC_RESULT_HEADING              2099
#define IDC_SCHEDULED_SYNC              2100
#define IDC_SCHEDULESUMMARY             2101
#define IDC_SCHEDULE_DAYS               2102
#define IDC_SCHEDULE_DAYS_SPIN          2103
#define IDC_SCHEDULE_EDIT               2104
#define IDC_SCHEDULE_LIST               2105
#define IDC_SCHEDULE_NAME               2106
#define IDC_SCHEDULE_NEW                2107
#define IDC_SCHEDULE_REMOVE             2108
#define IDC_SCHEDULE_TIME               2109
#define IDC_SIZENODETAILS               2110
#define IDC_STATISTICS                  2111
#define IDC_SUBSCRIBE_ADI_NAME          2112
#define IDC_SUBSCRIBE_ADI_URL           2113
#define IDC_SUBSCRIBE_CUSTOMIZE         2114
#define IDC_SUBSCRIBE_LINKDEPTH         2115
#define IDC_SUBSCRIBE_LINKDEPTH_SPIN    2116
#define IDC_TIME_REMAINING              2117
#define IDC_TX1                         2118
#define IDC_TX2                         2119
#define IDC_TX3                         2120
#define IDC_URL                         2121
#define IDC_USERNAME                    2122
#define IDC_WARNING1                    2123
#define IDC_WARNING2                    2124
#define IDC_WIZ_DONT_SHOW_INTRO         2125
#define IDC_WIZ_GET_LINKS_TEXT          2126
#define IDC_WIZ_INTRO_DETAILS_TEXT      2127
#define IDC_WIZ_INTRO_NEXT_TEXT         2128
#define IDC_WIZ_LINKS_YES               2129
#define IDC_WIZ_LINKS_NO                2130
#define IDC_WIZ_MADE_OFFLINE_TEXT       2131
#define IDC_WIZ_SCHEDULE_NONE           2132
#define IDC_WIZ_SCHEDULE_NEW            2133
#define IDC_WIZ_SCHEDULE_EXISTING       2134
#define IDC_WIZ_SCHEDULE_LIST           2135
#define IDC_WIZ_SCHED_DETAILS_TEXT      2136
#define IDC_WIZ_SCHED_QUESTION_TEXT     2137
#define IDC_WIZ_WHEN_TO_SYNC_TEXT       2138
#define IDC_DOWNLOAD_ALL                2139
#define IDC_DOWNLOAD_MIN                2140
#define IDC_PASSWORDCONFIRM             2141
#define IDC_USENEW                      2142
#define IDC_USEOLD                      2143
#define IDC_RENAME                      2144
#define IDC_SCHEDULE_MESSAGE            2145
#define IDC_FRIENDLY_SCHEDULE_TEXT      2146
#define IDC_NEW_SETTINGS                2147
#define IDC_OLD_SETTINGS                2148
#define IDC_CONTENT_GROUPBOX            2149
#define IDC_DOWNLOAD_PAGES_LABEL1       2150
#define IDC_DOWNLOAD_PAGES_LABEL2       2151
#define IDC_EMAIL_GROUPBOX              2152
#define IDC_LOGIN_LABEL                 2153
#define IDC_USERNAME_LABEL              2154
#define IDC_PASSWORD_LABEL              2155
#define IDC_SCHEDULE_LABEL1             2156
#define IDC_SCHEDULE_LABEL2             2157
#define IDC_SCHEDULE_NAME_TEXT          2158
#define IDC_SCHEDULE_TEXT               2159
#define IDC_ADVANCED_GROUPBOX           2160
#define IDC_ICONEX2                     2161
#define IDC_URL_TEXT                    2162
#define IDC_VISITS_TEXT                 2163
#define IDC_VISITS                      2164
#define IDC_MAKE_OFFLINE                2165
#define IDC_SUMMARY                     2166
#define IDC_LAST_SYNC_TEXT              2167
#define IDC_LAST_SYNC                   2168
#define IDC_DOWNLOAD_SIZE_TEXT          2169
#define IDC_DOWNLOAD_SIZE               2170
#define IDC_DOWNLOAD_RESULT_TEXT        2171
#define IDC_DOWNLOAD_RESULT             2172
#define IDC_PASSWORD_NO                 2174
#define IDC_PASSWORD_YES                2175
#define IDC_LOGIN_PROMPT_CHANNEL        2176
#define IDC_LOGIN_PROMPT_URL            2177
#define IDC_PASSWORDCONFIRM_LABEL       2178
#define IDC_DOWNLOAD_ONLY_HTML_LINKS    2179
//#define IDC_CACHE_LIMIT_MESSAGE         2180
//#define IDI_CACHE_LIMIT_REACHED         2181
//#define IDC_CACHE_LIMIT_NOASK           2182
#define IDC_FREESPACE_TEXT              2183
#define IDC_WIZ_LINKSDEEP_STATIC1       2184
#define IDC_WIZ_LINKSDEEP_STATIC2       2185
#define IDC_WIZ_LINKSDEEP_EDIT          2186
#define IDC_WIZ_LINKSDEEP_SPIN          2187
#define IDC_WIZ_SCHEDULE_AUTOCONNECT    2188
#define IDC_SCHEDULE_LABEL3             2189

#define IDD_ANIMATE                     110

#define IDD_APP_EXIT_PROMPT             6000
#define IDD_DESKTOP_SUBSCRIPTION_SUMMARY 6002
#define IDD_DISCONNECT_PROMPT           6003
#define IDD_OBJECTDEL_WARNING           6007
#define IDD_PROBAR                      6008
#define IDD_SPLITTER                    6010
#define IDD_SUBSCRIPTION_ENABLECHANNELSAVER 6011
#define IDD_SUBSPROPS_ADVANCED          6013
#define IDD_SUBSPROPS_LOGIN             6014
#define IDD_SUBSPROPS_DOWNLOAD_CHANNEL  6015
#define IDD_SUBSPROPS_DOWNLOAD_URL      6016
#define IDD_SUBSPROPS_SCHEDULE          6017
#define IDD_WIZARD0                     6018
#define IDD_WIZARD1                     6019
#define IDD_WIZARD2                     6020
#define IDD_WIZARD3                     6021
#define IDD_WIZARD4                     6022
#define IDD_DUPLICATE_SCHEDULE          6024
#define IDD_NEW_SCHEDULE                6025
#define IDD_SUBSPROPS_SUMMARY           6026
//#define IDD_CACHE_LIMIT_REACHED         6028

#define IDI_WEBCHECK                    114
#define IDI_STAT_SUCCEEDED              115
#define IDI_STAT_FAILED                 116
#define IDI_STAT_UPDATING               117
#define IDI_DISCONNECT                  118
#define IDI_STAT_PENDING                119
#define IDI_STAT_SKIPPED                120
#define IDI_CHANNEL                     121
#define IDI_GLEAMED                     122
#define IDI_SCHEDULE                    123
#define IDI_DESKTOPITEM                 160
#define IDI_IDLE                        162
#define IDI_BUSY                        163
#define IDI_NOTIFICATION                197
#define IDI_DOWNLOAD                    198
#define IDI_ICON                        400
#define IDI_WEBDOC                      400
#define IDI_OFFLINEICON                 401
#define IDI_OBJECTDELETED               402
#define IDI_TRAYICON                    403
#define IDI_SCREENSAVER                 407
#define IDI_GROUP                       251

#define IDL_SUBSCRIPTION                1171

#define IDS_ABORTING                    8000
#define IDS_AGNT_EMAILMESSAGE           8001
#define IDS_AGNT_HTMLBREAK              8002
#define IDS_AGNT_HTMLBREAKSINGLE        8003
#define IDS_AGNT_HTMLMESSAGETEXT        8004
#define IDS_AGNT_HTMLMESSAGETEXT2       8005
#define IDS_AGNT_HTMLMESSAGEWRAPPER     8006
#define IDS_AGNT_MAPIMESSAGE            8007
#define IDS_AGNT_MAPIMESSAGE_OTHER      8008
#define IDS_AGNT_MAPISUBJECT            8009
#define IDS_AGNT_MAPISUBJECT_OTHER      8010
#define IDS_AGNT_SMTPMESSAGE            8011
#define IDS_AGNT_SMTPMESSAGE_OTHER      8012
#define IDS_AGNT_STATUS_CACHELIMIT      8013
#define IDS_AGNT_STATUS_SIZELIMIT       8014
#define IDS_AGNT_TEXTBREAK              8015
#define IDS_APP_EXIT_TEXT               8016
#define IDS_BEEN_DISCONNECTED           8018
#define IDS_CANCELDL                    8019
#define IDS_CAPTION_ERROR_CONNECTING    8020
#define IDS_CAPTION_NOTHING_TO_UPDATE   8021
#define IDS_CDLAGENT_ERROR_EMAIL        8022
#define IDS_CDLAGENT_FAILURE            8023
#define IDS_CDLAGENT_SUCCESS            8024
#define IDS_CDLAGENT_TRUST_ERROR        8025
#define IDS_CHANNEL_FOLDER              8030
#define IDS_CRAWL_STATUS_MOSTLYOK       8032
#define IDS_CRAWL_STATUS_NOT_OK         8033
#define IDS_CRAWL_STATUS_OK             8034
#define IDS_CRAWL_STATUS_UNCHANGED      8035
//#define IDS_CUSTOM_ERROR_NAMEEXISTS     8036
//#define IDS_CUSTOM_ERROR_NAMEREQUIRED   8037
//#define IDS_CUSTOM_ERROR_NAMETOOLONG    8038
#define IDS_DAILY_GRO                   8044
#define IDS_DEL_MULTIPLE_FMT            8046
#define IDS_DESKTOPCHANNEL_SUMMARY_NOPW 8047
#define IDS_DESKTOPCHANNEL_SUMMARY_TEXT 8048
#define IDS_DETAILS                     8049
#define IDS_DETAIL_COL                  8050
#define IDS_DIAL_ALREADY_CONNECTED      8051
#define IDS_DIAL_DIRECT                 8052
#define IDS_DIAL_FAILURE                8053
#define IDS_DIAL_PROXY                  8054
#define IDS_DIAL_SUCCESS                8055
#define IDS_DISCONNECT_DLG_TEXT         8056
//#define IDS_DOWNLOAD_ABORT_WARNING      8060
#define IDS_GROUP_COL                   8076
#define IDS_HIGH_PRI                    8077
#define IDS_HTTPONLY                    8078

//#define IDS_ITEM_STAT_UPDATING_URL      8089

#define IDS_LAST_COL                    8090
#define IDS_LEVELLIMIT                  8091
#define IDS_LOGINTEXT1                  8092
#define IDS_LOGINTEXT2                  8093
#define IDS_LOW_PRI                     8095
#define IDS_NAME_COL                    8103
#define IDS_NEEDCHANNELPASSWORD         8104
#define IDS_NEEDCHANNELUSERNAME         8105
#define IDS_NEEDEMAILINFO               8106
#define IDS_NEEDPASSWORD                8107
#define IDS_NEEDUNATTENDEDINFO          8108
#define IDS_NEEDUSERNAME                8109
#define IDS_NEXT_COL                    8111
#define IDS_NODETAILS                   8112
#define IDS_NONE                        8113
#define IDS_NORMAL_PRI                  8114
#define IDS_NO_SUBSCRIPTIONS            8116
#define IDS_PRI_FIRST                   8121
#define IDS_RESTRICTED                  8124
#define IDS_RNADLL_FILENAME             8125
#define IDS_SCREENSAVEREXE              8137
#define IDS_SESSIONEND                  8138
#define IDS_SHOWPROG                    8139
#define IDS_SIZELIMIT                   8143
#define IDS_SIZE_COL                    8144
#define IDS_SIZE_KB                     8145
#define IDS_SOFTWAREUPDATE_FOLDER       8146
#define IDS_STATISTICS                  8147
#define IDS_STATUS_ABORTED              8148
#define IDS_STATUS_AUTHFAILED           8149
#define IDS_STATUS_BAD_URL              8150
#define IDS_STATUS_COL                  8151
#define IDS_STATUS_DIAL_FAIL            8152
#define IDS_STATUS_NOT_OK               8153
#define IDS_STATUS_OK                   8154
#define IDS_STATUS_OUTOFMEMORY          8155
#define IDS_STATUS_UNCHANGED            8156
#define IDS_STRING_E_CONFIG             8157
#define IDS_STRING_E_FAILURE            8158
#define IDS_STRING_E_SECURITYCHECK      8159
#define IDS_STRING_NOTHING_TO_UPDATE    8160
#define IDS_SUMMARY_MANUAL              8177
#define IDS_SYNCMGR_NAME                8190
#define IDS_TARGET_CHARSET_EMAIL        8191
#define IDS_TRAY_TOOLTIP                8192
#define IDS_UNKNOWN                     8195
#define IDS_UPDATE_SUBS                 8197
#define IDS_URL_COL                     8198
#define IDS_URL_STATUS_NOT_OK           8199
#define IDS_URL_STATUS_OK               8200
#define IDS_URL_STATUS_UNCHANGED        8201
#define IDS_VIEW_SUBS                   8203
#define IDS_WEEK1                       8205
#define IDS_WEEK2                       8206
#define IDS_WEEK3                       8207
#define IDS_WEEK4                       8208
#define IDS_WEEK5                       8209
#define IDS_WEEKLY_GRO                  8210
#define IDS_WIZ_GET_LINKS_CHANNEL       8214
#define IDS_WIZ_GET_LINKS_URL           8215
#define IDS_WIZ_INTRO_DETAILS_CHANNEL   8216
#define IDS_WIZ_INTRO_DETAILS_URL       8217
#define IDS_WIZ_INTRO_NEXT_CHANNEL      8218
#define IDS_WIZ_INTRO_NEXT_URL          8219
#define IDS_WIZ_MADE_OFFLINE_CHANNEL    8220
#define IDS_WIZ_MADE_OFFLINE_URL        8221
#define IDS_WIZ_SCHED_DETAILS_CHANNEL   8222
#define IDS_WIZ_SCHED_DETAILS_URL       8223
#define IDS_WIZ_SCHED_QUESTION_CHANNEL  8224
#define IDS_WIZ_SCHED_QUESTION_URL      8225
#define IDS_WIZ_WHEN_TO_SYNC_CHANNEL    8226
#define IDS_WIZ_WHEN_TO_SYNC_URL        8227
#define IDS_EMAIL_INCOMPLETE            8228
#define IDS_RECOMMENDED_SCHEDULE_FORMAT 8229
#define IDS_CONFIRM_SCHEDULE_DELETE     8230
#define IDS_MISMATCHED_PASSWORDS        8231
#define IDS_SCHED_FORMAT                8232
#define IDS_SCHED_CONFLICT_FORMAT       8233
#define IDS_NO_SCHEDULE_SELECTED        8234
#define IDS_SCHED_FORMAT_DAILY          8236
#define IDS_DEFAULT_MSG_CAPTION         8237
#define IDS_SCHEDULE_DELETE_CAPTION     8239
#define IDS_VALUE_UNKNOWN               8240
#define IDS_DELETE_CAPTION              8241
#define IDS_UPDATE_PAUSED               8244
#define IDS_UPDATE_RESUMING             8245
#define IDS_EMPTY_SCHEDULE_NAME         8246
#define IDS_NONULLNAME                  8247
#define IDS_RENAME                      8248
#define IDS_CACHELIMIT_TITLE            8249
#define IDS_CACHELIMIT_MESSAGE          8250
#define IDS_CRAWL_ROBOTS_TXT_WARNING    8251

#define IDS_SCHEDULED_UPDATES_DISABLED      8300
#define IDS_SCHEDULED_UPDATES_RESTRICTED    8301
#define IDS_SCHEDULED_UPDATE_INTERVAL       8302
#define IDS_SCHEDULED_EXCLUDE_RANGE         8303

#define IDS_SB_FIRST                    8600
#define IDS_SB_OPEN                     IDS_SB_FIRST + RSVIDM_OPEN
#define IDS_SB_UPDATE                   IDS_SB_FIRST + RSVIDM_UPDATE
#define IDS_SB_RENAME                   IDS_SB_FIRST + RSVIDM_RENAME
#define IDS_SB_COPY                     IDS_SB_FIRST + RSVIDM_COPY
#define IDS_SB_DELETE                   IDS_SB_FIRST + RSVIDM_DELETE
#define IDS_SB_PROPERTIES               IDS_SB_FIRST + RSVIDM_PROPERTIES
#define IDS_SB_WORKOFFLINE              IDS_SB_FIRST + RSVIDM_WORKOFFLINE
#define IDS_SB_UPDATEALL                IDS_SB_FIRST + RSVIDM_UPDATEALL
#define IDS_SB_SORTBYNAME               IDS_SB_FIRST + RSVIDM_SORTBYNAME
#define IDS_SB_HELP                     IDS_SB_FIRST + RSVIDM_HELP

#define MENU_OFFLINE_BRONLY             2003
#define MENU_OFFLINE_TOP                2000

#define POPUP_CONTEXT_VERBSONLY         301
#define POPUP_OFFLINE_CONTEXT           300
#define POPUP_RESTRICTED_CONTEXT        302

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\private.h ===
#define INC_OLE2
#define _SHDOCVW_
#ifdef UNICODE
#define POST_IE5_BETA
#include <w95wraps.h>
#endif
#include <windows.h>
#include <windowsx.h>
#include <ccstock.h>
#include <ole2.h>
#include <ole2ver.h>
#include <oleauto.h>
#include <docobj.h>
#include <shlwapi.h>
#include <wininet.h>   // INTERNET_MAX_URL_LENGTH.  Must be before shlobjp.h!
#include <winineti.h>
#include <shlobj.h>
#include <inetsdk.h>
#include <intshcut.h>
#include <mshtml.h>
#include <notftn.h>
#include <webcheck.h>
#include <exdisp.h>
#include <inetreg.h>
#include <advpub.h>
#include <htiframe.h>
#include <ieguidp.h>
#include <lmcons.h>         // for UNLEN/PWLEN
#include <ipexport.h>       // for ping
#include <icmpapi.h>        // for ping
#include <mobsync.h>
#include <mobsyncp.h>
#undef MAX_STATUS   // goofy
#include "debug.h"
#include "resource.h"
#include "rsrchdr.h"
#include "shfusion.h"

#include "pstore.h"
#include <shdocvw.h> // to get SHRestricted2*
#include <dwnnot.h> // IDownloadNotify
#include <malloc.h> // TSTR_ALIGNED_STACK_COPY

#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression

// How user of CUrlDownload receives notifications from it.
class CUrlDownloadSink
{
public:
    virtual HRESULT OnDownloadComplete(UINT iID, int iError) = 0;
    virtual HRESULT OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
                        { return E_NOTIMPL; }
    virtual HRESULT OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL)
                        { return S_OK; }
    virtual HRESULT OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
                        { return OLECMDERR_E_NOTSUPPORTED; }

    // returns free threaded callback interface
    // If you use this, make your implementation of IDownloadNotify fast
    virtual HRESULT GetDownloadNotify(IDownloadNotify **ppOut)
                        { return E_NOTIMPL; }
};

class CUrlDownload;

#include "filetime.h"
#include "offline.h"
#include "utils.h"
#include "delagent.h"
#include "cdfagent.h"
#include "webcrawl.h"
#include "trkcache.h"
#include "postagnt.h"
#include "cdlagent.h"

// Note: dialmon.h changes winver to 0x400
#include "dialmon.h"

#ifndef GUIDSTR_MAX
// GUIDSTR_MAX is 39 and includes the terminating zero.
// == Copied from OLE source code =================================
// format for string form of GUID is (leading identifier ????)
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
// ================================================================
#endif

// Trace and debug flags
#define TF_WEBCHECKCORE 0x00001000
//#define TF_SCHEDULER    0x00002000
#define TF_WEBCRAWL     0x00004000
#define TF_SEPROX       0x00008000
#define TF_CDFAGENT     0x00010000
#define TF_STRINGLIST   0x00020000
#define TF_URLDOWNLOAD  0x00040000
#define TF_DOWNLD       0x00080000
#define TF_DIALMON      0x00100000
#define TF_MAILAGENT    0x00200000
//#define TF_TRAYAGENT    0x00400000
#define TF_SUBSFOLDER   0x00800000
#define TF_MEMORY       0x01000000
#define TF_UPDATEAGENT  0x02000000
#define TF_POSTAGENT    0x04000000
#define TF_DELAGENT     0x08000000
#define TF_TRACKCACHE   0x10000000
#define TF_SYNCMGR      0x20000000
#define TF_THROTTLER    0x40000000
#define TF_ADMIN        0x80000000  //  Admin and IE upgrade

#define PSM_QUERYSIBLINGS_WPARAM_RESCHEDULE 0XF000

#undef DBG
#define DBG(sz)             TraceMsg(TF_THISMODULE, sz)
#define DBG2(sz1, sz2)      TraceMsg(TF_THISMODULE, sz1, sz2)
#define DBG_WARN(sz)        TraceMsg(TF_WARNING, sz)
#define DBG_WARN2(sz1, sz2) TraceMsg(TF_WARNING, sz1, sz2)

#ifdef DEBUG
#define DBGASSERT(expr,sz)  do { if (!(expr)) TraceMsg(TF_WARNING, (sz)); } while (0)
#define DBGIID(sz,iid)      DumpIID(sz,iid)
#else
#define DBGASSERT(expr,sz)  ((void)0)
#define DBGIID(sz,iid)      ((void)0)
#endif

// shorthand
#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#endif
#ifndef SAFEFREEBSTR
#define SAFEFREEBSTR(p) if ((p) != NULL) { SysFreeString(p); (p) = NULL; } else
#endif
#ifndef SAFEFREEOLESTR
#define SAFEFREEOLESTR(p) if ((p) != NULL) { CoTaskMemFree(p); (p) = NULL; } else
#endif
#ifndef SAFELOCALFREE
#define SAFELOCALFREE(p) if ((p) != NULL) { MemFree(p); (p) = NULL; } else
#endif
#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; } else
#endif

// MAX_WEBCRAWL_LEVELS is the max crawl depth for site subscriptions
// MAX_CDF_CRAWL_LEVELS is the max crawl depth for the "LEVEL" attrib value for CDFs
#define MAX_WEBCRAWL_LEVELS 3
#define MAX_CDF_CRAWL_LEVELS 3

#define MY_MAX_CACHE_ENTRY_INFO 6144

//
// Define the location of the webcheck registry key.
//
#define WEBCHECK_REGKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck")
#define WEBCHECK_REGKEY_NOTF TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck\\Notification Handlers")
#define WEBCHECK_REGKEY_STORE (WEBCHECK_REGKEY TEXT("\\Store.1"))



//
// Registry Keys
//
extern const TCHAR c_szRegKey[];                // registry key for webcheck stuff
extern const TCHAR c_szRegKeyUsernames[];       // registry key for webcheck stuff
extern const TCHAR c_szRegKeyPasswords[];       // registry key for webcheck stuff
extern const TCHAR c_szRegKeyStore[];
extern const TCHAR c_szRegPathInternetSettings[];
// extern const TCHAR c_szRegKeyRestrictions[];    // HKCU\Policies\...\Infodelivery\Restrictions
// extern const TCHAR c_szRegKeyModifications[];   // HKCU\Policies\...\Infodelivery\Modification
// extern const TCHAR c_szRegKeyCompletedMods[];   // HKCU\Policies\...\Infodelivery\CompletedModifications

//
// Registry Values
//
extern const TCHAR c_szNoChannelLogging[];

//
// Globals
//
extern HINSTANCE    g_hInst;                // dll instance
extern ULONG        g_cLock;                // outstanding locks
extern ULONG        g_cObj;                 // outstanding objects
extern BOOL         g_fIsWinNT;             // are we on winNT? Always initialized.
extern BOOL         g_fIsWinNT5;            // are we on winNT5? Always initialized.
extern BOOL         g_fIsMillennium;        // are we on Millennium?
extern const TCHAR c_szEnable[];            // enable unattended dialup

extern const TCHAR  c_szStrEmpty[];

inline ULONG DllLock()     { return InterlockedIncrement((LONG *)&g_cLock); }
inline ULONG DllUnlock()   { return InterlockedDecrement((LONG *)&g_cLock); }
inline ULONG DllGetLock()  { return g_cLock; }

inline ULONG DllAddRef()   { return InterlockedIncrement((LONG *)&g_cObj); }
inline ULONG DllRelease()  { return InterlockedDecrement((LONG *)&g_cObj); }
inline ULONG DllGetRef()   { return g_cObj; }

//
// Subscription property names; webcheck.cpp
//
// Agent Start
extern const WCHAR  c_szPropURL[];          // BSTR
extern const WCHAR  c_szPropName[];         // BSTR; friendly name
extern const WCHAR  c_szPropAgentFlags[];   // I4
extern const WCHAR  c_szPropCrawlLevels[];  // I4; webcrawler
extern const WCHAR  c_szPropCrawlFlags[];   // I4; webcrawler
extern const WCHAR  c_szPropCrawlMaxSize[]; // I4; webcrawler (in KB)
extern const WCHAR  c_szPropCrawlChangesOnly[];  // BOOL
extern const WCHAR  c_szPropChangeCode[];   // I4 or CY
extern const WCHAR  c_szPropEmailNotf[];    // BOOL;
extern const WCHAR  c_szPropCrawlUsername[];  // BSTR
extern const WCHAR  c_szPropCrawlLocalDest[]; // BSTR
extern const WCHAR  c_szPropEnableShortcutGleam[]; // I4
extern const WCHAR  c_szPropChannelFlags[];     // I4; channel agent specific flags
extern const WCHAR  c_szPropChannel[];          // I4; indicates a channel
extern const WCHAR  c_szPropDesktopComponent[]; // I4; indicates a desktop component
// set by agents in Agent Start
extern const WCHAR  c_szPropCrawlGroupID[];  // cache group ID
extern const WCHAR  c_szPropCrawlNewGroupID[]; // ID for new (existing) cache group
extern const WCHAR  c_szPropCrawlActualSize[];  // in KB
extern const WCHAR  c_szPropActualProgressMax[]; // Progress Max at end of last update
extern const WCHAR  c_szStartCookie[];      // The cookie of Start Notification.
extern const WCHAR  c_szPropStatusCode[];       // SCODE
extern const WCHAR  c_szPropStatusString[];     // BSTR (sentence)
extern const WCHAR  c_szPropCompletionTime[];   // DATE
extern const WCHAR  c_szPropPassword[];   // BSTR
// End Report
extern const WCHAR  c_szPropEmailURL[];         // BSTR
extern const WCHAR  c_szPropEmailFlags[];       // I4
extern const WCHAR  c_szPropEmailTitle[];       // BSTR
extern const WCHAR  c_szPropEmailAbstract[];    // BSTR
extern const WCHAR  c_szPropCharSet[];          // BSTR

// Tray Agent Properties
extern const WCHAR  c_szPropGuidsArr[];     // SAFEARRAY for a list of GUIDs

// Initial cookie used in AGENT_INIT notification.
extern const WCHAR  c_szInitCookie[];      // The cookie of Start Notification.
// Tracking
extern const WCHAR  c_szTrackingCookie[];   // Channel identity
extern const WCHAR  c_szTrackingPostURL[];  // tracking post url
extern const WCHAR  c_szPostingRetry[];     //
extern const WCHAR  c_szPostHeader[];       // specify encoding method of postdata
extern const WCHAR  c_szPostPurgeTime[];    // DATE

//
// Mail agent flags for the c_szPropEmailFlags property
//
enum MAILAGENT_FLAGS {
    MAILAGENT_FLAG_CUSTOM_MSG = 0x1
};

//
// Mail functions
//
HRESULT SendEmailFromItem(ISubscriptionItem *pItem);
HRESULT MimeOleEncodeStreamQP(IStream *pstmIn, IStream *pstmOut);
void ReadDefaultSMTPServer(LPTSTR pszBuf, UINT cch);
void ReadDefaultEmail(LPTSTR pszBuf, UINT cch);

// utils.cpp
interface IChannelMgrPriv;
HRESULT GetChannelPath(LPCTSTR pszURL, LPTSTR pszPath, int cch, IChannelMgrPriv** ppIChannelMgrPriv);

//
// Timer id's for scheduler and dialmon
//
#define TIMER_ID_DIALMON_IDLE   2       // every minute while connected
#define TIMER_ID_DIALMON_SEC    3       // every second for 30 seconds
#define TIMER_ID_DBL_CLICK      4       // did the user single or double click
#define TIMER_ID_USER_IDLE      5       // used to detect user idle on system

// Custom schedule dialog proc
BOOL CALLBACK CustomDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int SGMessageBox(HWND, UINT, UINT);

//
// Dialmon messages - send to scheduler window by various pieces of the system
// to tell us when dialup related stuff happens
//
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0
#define WM_REFRESH_SETTINGS     WM_DIALMON_FIRST + 1
#define WM_SET_CONNECTOID_NAME  WM_DIALMON_FIRST + 2
#define WM_IEXPLORER_EXITING    WM_DIALMON_FIRST + 3

// new set of Dialmon messages to support timeout for Mars + any other apps.
#define WM_DIALMON_HOOK         WM_DIALMON_FIRST + 4
#define WM_DIALMON_UNHOOK       WM_DIALMON_FIRST + 5
#define WM_CANHANGUP            WM_DIALMON_FIRST + 6
#define WM_CONFIRM_HANGUP       WM_DIALMON_FIRST + 7
#define WM_DENY_HANGUP          WM_DIALMON_FIRST + 8
#define WM_HANGING_UP           WM_DIALMON_FIRST + 9

// maximum number of application processes using dialmon at the same time.
#define MAX_DIALMON_HANDLES     10

// message used to report user mouse or kbd activity
// Note: sage.vxd uses this value and we can't change it.
#define WM_USER_ACTIVITY        WM_USER+5

// message sent by loadwc requesting a dynaload of sens/lce.
#define WM_LOAD_SENSLCE         WM_USER+200
#define WM_IS_SENSLCE_LOADED    WM_USER+201

//
// Random subscription defaults
//
#define DEFAULTLEVEL    0
#define DEFAULTFLAGS  (WEBCRAWL_GET_IMAGES | WEBCRAWL_LINKS_ELSEWHERE | WEBCRAWL_GET_CONTROLS)

#define IsNativeAgent(CLSIDAGENT)       (((CLSIDAGENT) == CLSID_WebCrawlerAgent) || ((CLSIDAGENT) == CLSID_ChannelAgent))
#define IS_VALID_SUBSCRIPTIONTYPE(st)   ((st == SUBSTYPE_URL) || (st == SUBSTYPE_CHANNEL) || (st == SUBSTYPE_DESKTOPCHANNEL) || (st == SUBSTYPE_DESKTOPURL))

//
// Useful functions
//
int MyOleStrToStrN(LPTSTR psz, int cchMultiByte, LPCOLESTR pwsz);
int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz);
void DumpIID(LPCSTR psz, REFIID riid);

// String comparison routines ; assume 8-bit characters. Return 0 or nonzero.
// Will work correctly if one or both strings are entirely 8-bit characters.
int MyAsciiCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);
int MyAsciiCmpNIW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen);
inline
 int MyAsciiCmpNW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen)
 { return memcmp(pwsz1, pwsz2, iLen*sizeof(WCHAR)); }

// Implementation in CDFagent.cpp
HRESULT XMLScheduleElementToTaskTrigger(IXMLElement *pRootEle, TASK_TRIGGER *ptt);
HRESULT ScheduleToTaskTrigger(TASK_TRIGGER *ptt, SYSTEMTIME *pstStartDate, SYSTEMTIME *pstEndDate,
                              long lInterval, long lEarliest, long lLatest, int iZone=9999);

// Admin related functions
HRESULT ProcessInfodeliveryPolicies(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

//  IE 5 versions - sans notfmgr support
HRESULT ReadDWORD       (ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet);
HRESULT ReadLONGLONG    (ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet);
HRESULT ReadGUID        (ISubscriptionItem *pItem, LPCWSTR szName, GUID *);
HRESULT ReadDATE        (ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT ReadBool        (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet);
HRESULT ReadBSTR        (ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet);
HRESULT ReadOLESTR      (ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *pszRet);
HRESULT ReadAnsiSTR     (ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet);
HRESULT ReadSCODE       (ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet);
HRESULT ReadVariant     (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet);

HRESULT WriteDWORD      (ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal);
HRESULT WriteLONGLONG   (ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal);
HRESULT WriteGUID       (ISubscriptionItem *pItem, LPCWSTR szName, GUID *);
HRESULT WriteDATE       (ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT WriteOLESTR     (ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal);
HRESULT WriteResSTR     (ISubscriptionItem *pItem, LPCWSTR szName, UINT uID);
HRESULT WriteAnsiSTR    (ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal);
HRESULT WriteSCODE      (ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal);
HRESULT WriteEMPTY      (ISubscriptionItem *pItem, LPCWSTR szName);
HRESULT WriteVariant    (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal);

#ifdef UNICODE
#define ReadTSTR        ReadOLESTR
#define WriteTSTR       WriteOLESTR
#else
#define ReadTSTR        ReadAnsiSTR
#define WriteTSTR       WriteAnsiSTR
#endif


HRESULT WritePassword   (ISubscriptionItem *pItem, BSTR szPassword);
HRESULT ReadPassword    (ISubscriptionItem *pItem, BSTR *ppszPassword);

// WEBCRAWL.CPP helper functions

// Do cool stuff to a single URL in the cache. Make sticky, get size, put in group...
// Returns E_OUTOFMEMORY if make sticky fails
HRESULT GetUrlInfoAndMakeSticky(
            LPCTSTR pszBaseUrl,         // Base URL. May be NULL if pszThisUrl is absolute
            LPCTSTR pszThisUrl,         // Absolute or relative url
            LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,       // Required
            DWORD   dwBufSize,          // Size of *lpCacheEntryInfo
            GROUPID llCacheGroupID);    // Group ID ; may be 0

// PreCheckUrlForChange and PostCheckUrlForChange are documented in webcrawl.cpp
HRESULT PreCheckUrlForChange(LPCTSTR lpURL, VARIANT *pvarChange, BOOL *pfGetContent);
HRESULT PostCheckUrlForChange(VARIANT *pvarChange,
                              LPINTERNET_CACHE_ENTRY_INFO lpInfo, FILETIME ftNewLastModified);

HRESULT WriteCookieToInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie, BOOL bRemove);
HRESULT ReadCookieFromInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie);

#define MAX_RES_STRING_LEN 128      // max resource string len for WriteStringRes

// IntSite helper function
HRESULT IntSiteHelper(LPCTSTR pszURL, const PROPSPEC *pReadPropspec,
        PROPVARIANT *pReadPropvar, UINT uPropVarArraySize, BOOL fWrite);
extern const PROPSPEC c_rgPropRead[];
#define PROP_SUBSCRIPTION   0
#define PROP_FLAGS          1
#define PROP_TRACKING       2
#define PROP_CODEPAGE       3

//=============================================================================
// Helper class for aggregation. Inherit from this like another interface, then
//  implement InnerQI and include IMPLEMENT_DELEGATE_UNKNOWN in your class declaration
class CInnerUnknown
{
public:
    CInnerUnknown() { m_cRef = 1; m_punkOuter=(IUnknown *)(CInnerUnknown *)this; }

    void InitAggregation(IUnknown *punkOuter, IUnknown **punkInner)
    {
        if (punkOuter)
        {
            m_punkOuter = punkOuter;
            *punkInner = (IUnknown *)(CInnerUnknown *)this;
        }
    }

    virtual HRESULT STDMETHODCALLTYPE InnerQI(REFIID riid, void **ppunk) = 0;
    virtual ULONG STDMETHODCALLTYPE InnerAddRef() { return ++m_cRef; }
    virtual ULONG STDMETHODCALLTYPE InnerRelease() = 0;

protected:
    long     m_cRef;
    IUnknown *m_punkOuter;
};

#define IMPLEMENT_DELEGATE_UNKNOWN() \
STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk) \
    { return m_punkOuter->QueryInterface(riid, ppunk); } \
STDMETHODIMP_(ULONG) AddRef() { return m_punkOuter->AddRef(); } \
STDMETHODIMP_(ULONG) Release() { return m_punkOuter->Release(); } \
STDMETHODIMP_(ULONG) InnerRelease() { \
        if (0L != --m_cRef) return m_cRef; \
        delete this; \
        return 0L; }
// end aggregation helpers
//=============================================================================



// Registry helper functions
BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   void *pData, DWORD dwBytes);
BOOL WriteRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                    void *pData, DWORD dwBytes, DWORD dwType);

DWORD ReadRegDWORD(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue);

// Event logging function
DWORD __cdecl LogEvent(LPTSTR pszEvent, ...);

// Thread proc for firing up sens and lce
DWORD WINAPI ExternalsThread(LPVOID lpData);

// Used to set syncmgr "warning" level
#define INET_E_AGENT_WARNING 0x800C0FFE
//
// Main WebCheck class
//
class CWebCheck : public IOleCommandTarget
{
protected:
    ULONG           m_cRef;

public:
    CWebCheck(void);
    ~CWebCheck(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IWebCheck members
    STDMETHODIMP         StartService(BOOL fForceExternals);
    STDMETHODIMP         StopService(void);

    // IOleCommandTarget members
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // External handling members
    BOOL                 ShouldLoadExternals(void);
    BOOL                 AreExternalsLoaded(void);
    void                 LoadExternals(void);
    void                 UnloadExternals(void);

    // thread for handling external bits
    HANDLE               _hThread;

    // events to synchronize with external thread
    HANDLE               _hTerminateEvent;
};

//
// CMemStream class
//
class CMemStream
{
protected:
    IStream *   m_pstm;
    BOOL        m_fDirty;
    BOOL        m_fError;

public:
    BOOL        m_fNewStream;

public:
    CMemStream(BOOL fNewStream=TRUE);
    ~CMemStream();

    BOOL        IsError() { return m_fError; }

    HRESULT     Read(void *pv, ULONG cb, ULONG *cbRead);
    HRESULT     Write(void *pv, ULONG cb, ULONG *cbWritten);
    HRESULT     Seek(long lMove, DWORD dwOrigin, DWORD *dwNewPos);
    HRESULT     SaveToStream(IUnknown *punk);
    HRESULT     LoadFromStream(IUnknown **ppunk);

    HRESULT     CopyToStream(IStream *pStm);
};



extern BOOL IsGlobalOffline(void);
extern void SetGlobalOffline(BOOL fOffline);

#define MemAlloc LocalAlloc
#define MemFree LocalFree
#define MemReAlloc LocalReAlloc

typedef HRESULT (* CREATEPROC)(IUnknown *, IUnknown **);

// Helper functions to read and write passwords to an encrypted store.

STDAPI ReadNotificationPassword(LPCWSTR wszUrl, BSTR * pbstrPassword);
STDAPI WriteNotificationPassword(LPCWSTR wszUrl, BSTR  bstrPassword);

// dialmon functions
BOOL DialmonInit(void);
void DialmonShutdown(void);

// LCE dynaload entry points
typedef HRESULT (* LCEREGISTER)(HMODULE);
typedef HRESULT (* LCEUNREGISTER)(HMODULE);
typedef HRESULT (* LCESTART)(void);
typedef HRESULT (* LCESTOP)(void);

// SENS dynaload entry points
typedef HRESULT (* SENSREGISTER)(void);
typedef BOOL (* SENSSTART)(void);
typedef BOOL (* SENSSTOP)(void);

// event dispatching
DWORD DispatchEvent(DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\subsmgr2.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "subitem.h"

//  Contains implementations of IEnumSubscription and ISubscriptionMgr2

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie, 
                                   ISubscriptionItem **ppSubscriptionItem);

HRESULT DoGetItemFromURL(LPCTSTR pszURL, ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE cookie;

    if ((NULL == pszURL) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    hr = ReadCookieFromInetDB(pszURL, &cookie);
    if (SUCCEEDED(hr))
    {
        hr = SubscriptionItemFromCookie(FALSE, &cookie, ppSubscriptionItem);
    }

    return hr;
}

HRESULT DoGetItemFromURLW(LPCWSTR pwszURL, ISubscriptionItem **ppSubscriptionItem)
{
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if ((NULL == pwszURL) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    StrCpyN(szURL, pwszURL, ARRAYSIZE(szURL));

    return DoGetItemFromURL(szURL, ppSubscriptionItem);
}


HRESULT DoAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    HRESULT hr;

    if ((0 == dwNumCookies) || (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->AbortItems(dwNumCookies, pCookies);
        pst->Release();
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT DoCreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    if ((NULL == pSubscriptionItemInfo) ||
        (NULL == pNewCookie) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    *ppSubscriptionItem = NULL;

    CreateCookie(pNewCookie);

    hr = SubscriptionItemFromCookie(TRUE, pNewCookie, &psi);

    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != psi);

        hr = psi->SetSubscriptionItemInfo(pSubscriptionItemInfo);
        if (SUCCEEDED(hr))
        {
            *ppSubscriptionItem = psi;
        }
        else
        {
            //  Don't leak or leave slop hanging around
            psi->Release();
            DoDeleteSubscriptionItem(pNewCookie, FALSE);
        }
    }

    return hr;
}

HRESULT DoCloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE NewCookie;

    if ((NULL == pSubscriptionItem) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    IEnumItemProperties *peip;
    SUBSCRIPTIONITEMINFO sii;

    *ppSubscriptionItem = NULL;

    //  First get existing subscription details
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    hr = pSubscriptionItem->GetSubscriptionItemInfo(&sii);

    if (SUCCEEDED(hr))
    {
        ISubscriptionItem *psi;

        //  Mark as temp and create a new subscription item
        sii.dwFlags |= SI_TEMPORARY;

        hr = DoCreateSubscriptionItem(&sii, &NewCookie, &psi);

        if (SUCCEEDED(hr))
        {
            if (pNewCookie)
                *pNewCookie = NewCookie;

            //  Get properties from existing item 
            hr = pSubscriptionItem->EnumProperties(&peip);
            if (SUCCEEDED(hr))
            {
                ULONG count;
                
                ASSERT(NULL != peip);

                hr = peip->GetCount(&count);

                if (SUCCEEDED(hr))
                {
                    ITEMPROP *pProps = new ITEMPROP[count];
                    LPWSTR *pNames = new LPWSTR[count];
                    VARIANT *pVars = new VARIANT[count];

                    if ((NULL != pProps) && (NULL != pNames) && (NULL != pVars))
                    {
                        hr = peip->Next(count, pProps, &count);

                        if (SUCCEEDED(hr))
                        {
                            ULONG i;

                            for (i = 0; i < count; i++)
                            {
                                pNames[i] = pProps[i].pwszName;
                                pVars[i] = pProps[i].variantValue;
                            }

                            hr = psi->WriteProperties(count, pNames, pVars);

                            //  clean up from enum
                            for (i = 0; i < count; i++)
                            {
                                if (pProps[i].pwszName)
                                {
                                    CoTaskMemFree(pProps[i].pwszName);
                                }
                                VariantClear(&pProps[i].variantValue);
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    SAFEDELETE(pProps);
                    SAFEDELETE(pNames);
                    SAFEDELETE(pVars);
                }
                
                peip->Release();
            }

            if (SUCCEEDED(hr))
            {
                *ppSubscriptionItem = psi;
            }
            else
            {
                psi->Release();
            }
        }
    }
    return hr;
}

HRESULT DoDeleteSubscriptionItem(
    /* [in] */ const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua,
    /* [in] */ BOOL fAbortItem)
{
    HRESULT hr;
    TCHAR szKey[MAX_PATH];
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    if (pCookie_ua != NULL) {
        cookie_buf = *pCookie_ua;
        pCookie = &cookie_buf;
    } else {
        pCookie = NULL;
    }

    if (NULL == pCookie)
    {
        return E_INVALIDARG;
    }

    if (fAbortItem)
    {
        DoAbortItems(1, pCookie);
    }

    if (ItemKeyNameFromCookie(pCookie, szKey, ARRAYSIZE(szKey)))
    {
        // Notify the agent that it is about to get deleted.
        ISubscriptionItem *pItem=NULL;
        if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, pCookie, &pItem)))
        {
            SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };

            if (SUCCEEDED(pItem->GetSubscriptionItemInfo(&sii)))
            {
                ASSERT(!(sii.dwFlags & SI_TEMPORARY));

                ISubscriptionAgentControl *psac=NULL;

                if (SUCCEEDED(
                    CoCreateInstance(sii.clsidAgent,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ISubscriptionAgentControl,
                                      (void**)&psac)))
                {
                    psac->SubscriptionControl(pItem, SUBSCRIPTION_AGENT_DELETE);
                    psac->Release();
                }

                FireSubscriptionEvent(SUBSNOTF_DELETE, pCookie);

                if (GUID_NULL != sii.ScheduleGroup)
                {
                    ISyncScheduleMgr *pSyncScheduleMgr;
                    hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                                          IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

                    if (SUCCEEDED(hr))
                    {                
                        pSyncScheduleMgr->RemoveSchedule(&sii.ScheduleGroup);
                        pSyncScheduleMgr->Release();
                    }
                }
            }

            pItem->Release();
        }

        hr = (SHDeleteKey(HKEY_CURRENT_USER, szKey) == ERROR_SUCCESS) ? S_OK : E_FAIL;
    }
    else
    {
        TraceMsg(TF_ALWAYS, "Failed to delete subscription item.");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT AddUpdateSubscription(SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua,
                              SUBSCRIPTIONITEMINFO *psii,
                              LPCWSTR pwszURL,
                              ULONG nProps,
                              const LPWSTR rgwszName[], 
                              VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    cookie_buf = *pCookie_ua;
    pCookie = &cookie_buf;
    
    ASSERT((0 == nProps) || ((NULL != rgwszName) && (NULL != rgValue)));

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    ISubscriptionItem *psi = NULL;
    SUBSCRIPTIONCOOKIE cookie;

    StrCpyNW(szURL, pwszURL, ARRAYSIZE(szURL));

    //  Try and get the cookie from the inet db otherwise 
    //  create a new one.

    if (*pCookie == CLSID_NULL)
    {
        CreateCookie(&cookie);
    }
    else
    {
        cookie = *pCookie;
    }
    //  Update the inet db
    WriteCookieToInetDB(szURL, &cookie, FALSE);
       
    hr = SubscriptionItemFromCookie(TRUE, &cookie, &psi);

    if (SUCCEEDED(hr))
    {
        hr = psi->SetSubscriptionItemInfo(psii);
        if (SUCCEEDED(hr) && (nProps > 0))
        {
            ASSERT(NULL != psi);

            hr = psi->WriteProperties(nProps, rgwszName, rgValue);
        }
        psi->Release();

        if (FAILED(hr))
        {
            DoDeleteSubscriptionItem(&cookie, TRUE);
        }
    }

    *pCookie_ua = cookie_buf;

    return hr;
}

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua, 
                                   ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    if (pCookie_ua != NULL) {
        cookie_buf = *pCookie_ua;
        pCookie = &cookie_buf;
    } else {
        pCookie = NULL;
    }

    ASSERT((NULL != pCookie) && (NULL != ppSubscriptionItem));

    HKEY hkey;
    
    if (OpenItemKey(pCookie, fCreateNew ? TRUE : FALSE, KEY_READ | KEY_WRITE, &hkey))
    {
        *ppSubscriptionItem = new CSubscriptionItem(pCookie, hkey);
        if (NULL != *ppSubscriptionItem)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        RegCloseKey(hkey);
    }
    else
    {
        *ppSubscriptionItem = NULL;
        hr = E_FAIL;
    }
    return hr;
}

BOOL ItemKeyNameFromCookie(const SUBSCRIPTIONCOOKIE *pCookie, 
    TCHAR *pszKeyName, DWORD cchKeyName)
{
    WCHAR wszGuid[GUIDSTR_MAX];

    ASSERT((NULL != pCookie) && 
           (NULL != pszKeyName) && 
           (cchKeyName >= ARRAYSIZE(WEBCHECK_REGKEY_STORE) + GUIDSTR_MAX));

    if (StringFromGUID2(*pCookie, wszGuid, ARRAYSIZE(wszGuid)))
    {
        wnsprintfW(pszKeyName, cchKeyName, L"%s\\%s", c_szRegKeyStore, wszGuid);
        return TRUE;
    }

    return FALSE;
}

BOOL OpenItemKey(const SUBSCRIPTIONCOOKIE *pCookie, BOOL fCreateNew, REGSAM samDesired, HKEY *phkey)
{
    TCHAR szKeyName[MAX_PATH];

    ASSERT((NULL != pCookie) && (NULL != phkey));

    if (ItemKeyNameFromCookie(pCookie, szKeyName, ARRAYSIZE(szKeyName)))
    {
        if (fCreateNew)
        {
            DWORD dwDisposition;
            return RegCreateKeyEx(HKEY_CURRENT_USER, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  samDesired, NULL, phkey, &dwDisposition) == ERROR_SUCCESS;
        }
        else
        {
            return RegOpenKeyEx(HKEY_CURRENT_USER, szKeyName, 0, samDesired, phkey) == ERROR_SUCCESS;
        }
    }

    return FALSE;
}

//  ISubscriptionMgr2 members

STDMETHODIMP CSubscriptionMgr::GetItemFromURL( 
    /* [in] */ LPCWSTR pwszURL,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoGetItemFromURLW(pwszURL, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::GetItemFromCookie( 
    /* [in] */ const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    if ((NULL == pSubscriptionCookie) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    return SubscriptionItemFromCookie(FALSE, pSubscriptionCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::GetSubscriptionRunState(
    /* [in] */ DWORD dwNumCookies,
    /* [in] */ const SUBSCRIPTIONCOOKIE *pSubscriptionCookies,
    /* [out] */ DWORD *pdwRunState)
{
    HRESULT hr;
    
    if ((0 == dwNumCookies) || 
        (NULL == pSubscriptionCookies) ||
        (NULL == pdwRunState))
    {
        return E_INVALIDARG;
    }

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->GetSubscriptionRunState(dwNumCookies, pSubscriptionCookies, pdwRunState);
        pst->Release();
    }
    else
    {
        //  Couldn't connect to a running throttler so assume nothing
        //  is running.
        for (DWORD i = 0; i < dwNumCookies; i++)
        {
            *pdwRunState++ = 0;
        }

        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::EnumSubscriptions( 
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumSubscription **ppEnumSubscriptions)
{
    HRESULT hr;

    if ((dwFlags & ~SUBSMGRENUM_MASK) || (NULL == ppEnumSubscriptions))
    {
        return E_INVALIDARG;
    }
    
    CEnumSubscription *pes = new CEnumSubscription;

    *ppEnumSubscriptions = NULL;

    if (NULL != pes)
    {
        hr = pes->Initialize(dwFlags);
        if (SUCCEEDED(hr))
        {
            hr = pes->QueryInterface(IID_IEnumSubscription, (void **)ppEnumSubscriptions);
        }
        pes->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSubscriptionMgr::UpdateItems(
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    HRESULT hr;

    if ((dwFlags & ~SUBSMGRUPDATE_MASK) || (0 == dwNumCookies) || (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    ISyncMgrSynchronizeInvoke *pSyncMgrInvoke;
    
    hr = CoCreateInstance(CLSID_SyncMgr, 
                          NULL, 
                          CLSCTX_ALL,
                          IID_ISyncMgrSynchronizeInvoke, 
                          (void **)&pSyncMgrInvoke);

    if (SUCCEEDED(hr))
    {
        DWORD dwInvokeFlags = SYNCMGRINVOKE_STARTSYNC;

        if (dwFlags & SUBSMGRUPDATE_MINIMIZE) 
        {
            dwInvokeFlags |= SYNCMGRINVOKE_MINIMIZED;
        }
        hr = pSyncMgrInvoke->UpdateItems(dwInvokeFlags, CLSID_WebCheckOfflineSync,
                                    dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE),
                                    (const BYTE *)pCookies);
        pSyncMgrInvoke->Release();
    }
    
    return hr;
}

STDMETHODIMP CSubscriptionMgr::AbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    return DoAbortItems(dwNumCookies, pCookies);
}

STDMETHODIMP CSubscriptionMgr::AbortAll()
{
    HRESULT hr;

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->AbortAll();
        pst->Release();
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

// ISubscriptionMgrPriv
STDMETHODIMP CSubscriptionMgr::CreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoCreateSubscriptionItem(pSubscriptionItemInfo, pNewCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::CloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoCloneSubscriptionItem(pSubscriptionItem, pNewCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::DeleteSubscriptionItem( 
    /* [in] */ const SUBSCRIPTIONCOOKIE *pCookie)
{
    return DoDeleteSubscriptionItem(pCookie, TRUE);
}

//  ** CEnumSubscription **

CEnumSubscription::CEnumSubscription()
{
    ASSERT(NULL == m_pCookies);
    ASSERT(0 == m_nCurrent);
    ASSERT(0 == m_nCount);

    m_cRef = 1;

    DllAddRef();
}

CEnumSubscription::~CEnumSubscription()
{
    if (NULL != m_pCookies)
    {
        delete [] m_pCookies;
    }

    DllRelease();
}

HRESULT CEnumSubscription::Initialize(DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = NULL;
    DWORD dwDisposition;

    ASSERT(0 == m_nCount);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegKeyStore, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD nCount;

        if (RegQueryInfoKey(hkey,
            NULL,   // address of buffer for class string 
            NULL,   // address of size of class string buffer 
            NULL,   // reserved 
            &nCount,    // address of buffer for number of subkeys 
            NULL,   // address of buffer for longest subkey name length  
            NULL,   // address of buffer for longest class string length 
            NULL,   // address of buffer for number of value entries 
            NULL,   // address of buffer for longest value name length 
            NULL,   // address of buffer for longest value data length 
            NULL,   // address of buffer for security descriptor length 
            NULL    // address of buffer for last write time
            ) == ERROR_SUCCESS)
        {
            SUBSCRIPTIONCOOKIE Cookie;
            m_pCookies = new SUBSCRIPTIONCOOKIE[nCount];
                       
            if (NULL != m_pCookies)
            {
                TCHAR szKeyName[GUIDSTR_MAX];

                hr = S_OK;

                for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
                {
                    if (RegEnumKey(hkey, i, szKeyName, ARRAYSIZE(szKeyName)) ==
                        ERROR_SUCCESS)
                    {
                        HRESULT hrConvert;
                        hrConvert = CLSIDFromString(szKeyName, &Cookie);

                        if (SUCCEEDED(hrConvert))
                        {
                            ISubscriptionItem *psi;

                            m_pCookies[m_nCount] = Cookie;

                            hr = SubscriptionItemFromCookie(FALSE, &Cookie, &psi);
                            
                            if (SUCCEEDED(hr))
                            {
                                SUBSCRIPTIONITEMINFO sii;
                                sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
                                
                                if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
                                {
                                    //  Only count this if it's not a temporary
                                    //  or the caller asked for temporary items.
                                    if ((!(sii.dwFlags & SI_TEMPORARY)) ||
                                        (dwFlags & SUBSMGRENUM_TEMP))
                                    {
                                        m_nCount++;
                                    }
                                }
                                psi->Release();
                            }
                        }
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        RegCloseKey(hkey);
    }

    return hr;
}

// IUnknown members
STDMETHODIMP CEnumSubscription::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_IEnumSubscription == riid))
    {
        *ppv = (IEnumSubscription *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

STDMETHODIMP_(ULONG) CEnumSubscription::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumSubscription::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CEnumSubscription::CopyRange(ULONG nStart, ULONG nCount, 
                                     SUBSCRIPTIONCOOKIE *pCookies, ULONG *pnCopied)
{
    ULONG nCopied = 0;

    ASSERT((NULL != pCookies) && (NULL != pnCopied));

    if (m_nCurrent < m_nCount)
    {
        ULONG nRemaining = m_nCount - m_nCurrent;
        nCopied = min(nRemaining, nCount); 
        memcpy(pCookies, m_pCookies + m_nCurrent, nCopied * sizeof(SUBSCRIPTIONCOOKIE));
    }
    
    *pnCopied = nCopied;

    return (nCopied == nCount) ? S_OK : S_FALSE;
}

// IEnumSubscription
STDMETHODIMP CEnumSubscription::Next(
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ SUBSCRIPTIONCOOKIE *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hr;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    DWORD nFetched;

    hr = CopyRange(m_nCurrent, celt, rgelt, &nFetched);

    m_nCurrent += nFetched;

    if (pceltFetched)
    {
        *pceltFetched = nFetched;
    }

    return hr;
}

STDMETHODIMP CEnumSubscription::Skip( 
    /* [in] */ ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}


STDMETHODIMP CEnumSubscription::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

STDMETHODIMP CEnumSubscription::Clone( 
    /* [out] */ IEnumSubscription **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppenum = NULL;

    CEnumSubscription *pes = new CEnumSubscription;

    if (NULL != pes)
    {
        pes->m_pCookies = new SUBSCRIPTIONCOOKIE[m_nCount];

        if (NULL != pes->m_pCookies)
        {
            ULONG nFetched;

            hr = E_FAIL;

            pes->m_nCount = m_nCount;
            CopyRange(0, m_nCount, pes->m_pCookies, &nFetched);

            ASSERT(m_nCount == nFetched);

            if (m_nCount == nFetched)
            {
                hr = pes->QueryInterface(IID_IEnumSubscription, (void **)ppenum);
            }
        }
        pes->Release();
    }    
    return hr;
}


STDMETHODIMP CEnumSubscription::GetCount( 
    /* [out] */ ULONG *pnCount)
{
    if (NULL == pnCount)
    {
        return E_INVALIDARG;
    }

    *pnCount = m_nCount;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\subitem.cpp ===
#include "private.h"
#include "subitem.h"
#include "subsmgrp.h"

#include "helper.h"
#include "offl_cpp.h"   // Yech. Pidl stuff.

const TCHAR c_szSubscriptionInfoValue[] = TEXT("~SubsInfo");


#define c_wszSubscriptionInfoValue c_szSubscriptionInfoValue

//  pragmas are for compatibility with the notification manager
//  registry data structures which were not pack 8

#pragma pack(push, RegVariantBlob, 1)

//#pragma pack(8)
struct NT32PACKAGE
{
    unsigned _int16 vt; /* VARTYPE *//* unsigned short int */
    unsigned _int16 wReserved1; /* WORD *//* unsigned short int */
    unsigned _int16 wReserved2; /* WORD *//* unsigned short int */
    unsigned _int16 wReserved3; /* WORD *//* unsigned short int */

   _int64 llVal; /* LONGLONG *//* __int64 */
};

// Q: What's going on here?
// A: Not a whole lot.
//    We used to store a variant in the registry. Unfortunately, variants are 
//    16 bytes on Win32 (8 byte header + 8 bytes of data)
//    24 bytes on Win64 (8 byte header + 16 bytes of data)

// Unfortunately, Win64 webcheck and Win32 webcheck both read from
// the same registry location, i.e. the same blob, and won't understand one another.
// Thus, boom! At least, for BSTRs that are stored inline

// Fortunately, we care only about only the first 16 bytes on both platforms. 
// Ergo, it's sufficient to store only the top half of the Win64 variant.

struct SimpleVariantBlob
{
    NT32PACKAGE var;
};

struct BSTRVariantBlob : public SimpleVariantBlob
{
    DWORD   dwSize;
//    WCHAR   wsz[];    //  Variable length string
};

struct OldBSTRVariantBlob
{
    DWORD   dwSize;
    VARIANT var;
};


struct SignatureSimpleBlob
{
    DWORD               dwSignature;
    SimpleVariantBlob   svb;
};

struct SignatureBSTRBlob
{
    DWORD               dwSignature;
    BSTRVariantBlob     bvb;
};

#pragma pack(pop, RegVariantBlob)


#define BLOB_SIGNATURE 0x4b434f4d

// We need fStream to indicate when we're upgrading IE4-style streams-of-blobs. (IE6 24398)
HRESULT BlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar, DWORD *pcbUsed, BOOL fStream)
{
    HRESULT hr = S_OK;
    SimpleVariantBlob *pBlob = (SimpleVariantBlob *)pData;

    ASSERT(NULL != pBlob);
    ASSERT(cbData >= sizeof(SimpleVariantBlob));
    ASSERT(NULL != pVar);

    if ((NULL != pBlob) &&
        (cbData >= sizeof(SimpleVariantBlob)) &&
        (NULL != pVar))
    {
        memcpy(pVar, &pBlob->var, sizeof(NT32PACKAGE));

        switch (pVar->vt)
        {
            case VT_I4:                 // LONG           
            case VT_UI1:                // BYTE           
            case VT_I2:                 // SHORT          
            case VT_R4:                 // FLOAT          
            case VT_R8:                 // DOUBLE         
            case VT_BOOL:               // VARIANT_BOOL   
            case VT_ERROR:              // SCODE          
            case VT_CY:                 // CY             
            case VT_DATE:               // DATE
            case VT_I1:                 // CHAR           
            case VT_UI2:                // USHORT         
            case VT_UI4:                // ULONG          
            case VT_INT:                // INT            
            case VT_UINT:               // UINT           
                if (pcbUsed)
                {
                    *pcbUsed = sizeof(SimpleVariantBlob);
                }
                break;                

            case VT_BSTR:               // BSTR
                hr = E_UNEXPECTED;

                ASSERT(cbData >= sizeof(BSTRVariantBlob));

                if (cbData >= sizeof(BSTRVariantBlob))
                {
                    BSTRVariantBlob *pbstrBlob = (BSTRVariantBlob *)pData;
                    DWORD dwSize = pbstrBlob->dwSize;

#ifdef WIN64
                    ASSERT((cbData==(sizeof(BSTRVariantBlob) + dwSize)) 
                           || (cbData==(sizeof(OldBSTRVariantBlob) + dwSize)));
#else
                    ASSERT((cbData==(sizeof(BSTRVariantBlob) + dwSize))
                            || (fStream && (cbData>=(sizeof(BSTRVariantBlob) + dwSize))));

#endif
                    if ((cbData==(sizeof(BSTRVariantBlob) + dwSize))
                        || (fStream && (cbData>=(sizeof(BSTRVariantBlob) + dwSize))))
                    {
                        pVar->bstrVal = SysAllocStringByteLen(NULL, dwSize);

                        if (NULL != pVar->bstrVal)
                        {
                            if (pcbUsed)
                            {
                                *pcbUsed = sizeof(BSTRVariantBlob) + pbstrBlob->dwSize;
                            }
                            memcpy(pVar->bstrVal, 
                                   ((BYTE *)pbstrBlob) + 
                                        (FIELD_OFFSET(BSTRVariantBlob, dwSize) + 
                                        sizeof(dwSize)),
                                   dwSize);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                if (FAILED(hr))
                {
                    pVar->vt = VT_EMPTY;
                }
                break;                

            default:
                hr = E_NOTIMPL;
                break;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT SignatureBlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar)
{
    HRESULT hr;
    
    SignatureSimpleBlob *pBlob = (SignatureSimpleBlob *)pData;

    ASSERT(NULL != pBlob);
    ASSERT(cbData >= sizeof(SignatureSimpleBlob));
    ASSERT(NULL != pVar);
    ASSERT(BLOB_SIGNATURE == pBlob->dwSignature);

    if ((NULL != pBlob) &&
        (cbData >= sizeof(SignatureSimpleBlob)) &&
        (NULL != pVar) &&
        (BLOB_SIGNATURE == pBlob->dwSignature))
    {
        hr = BlobToVariant((BYTE *)&pBlob->svb, 
                           cbData - (FIELD_OFFSET(SignatureSimpleBlob, svb)),
                           pVar,
                           NULL);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT VariantToSignatureBlob(const VARIANT *pVar, BYTE **ppData, DWORD *pdwSize)
{
    HRESULT hr;

    ASSERT(NULL != pVar);
    ASSERT(NULL != ppData);
    ASSERT(NULL != pdwSize);

    if ((NULL != pVar) && (NULL != ppData) && (NULL != pdwSize))
    {
        DWORD dwSize;
        DWORD dwBstrLen = 0;

        hr = S_OK;
     
        switch (pVar->vt)
        {
            case VT_I4:                 // LONG           
            case VT_UI1:                // BYTE           
            case VT_I2:                 // SHORT          
            case VT_R4:                 // FLOAT          
            case VT_R8:                 // DOUBLE         
            case VT_BOOL:               // VARIANT_BOOL   
            case VT_ERROR:              // SCODE          
            case VT_CY:                 // CY             
            case VT_DATE:               // DATE
            case VT_I1:                 // CHAR           
            case VT_UI2:                // USHORT         
            case VT_UI4:                // ULONG          
            case VT_INT:                // INT            
            case VT_UINT:               // UINT           
                dwSize = sizeof(SignatureSimpleBlob);
                break;                

            case VT_BSTR:               // BSTR
                if (NULL != pVar->bstrVal) 
                    dwBstrLen = SysStringByteLen(pVar->bstrVal);
                dwSize = sizeof(SignatureBSTRBlob) + dwBstrLen;
                break;
                        
            default:
                hr = E_NOTIMPL;
                dwSize = 0;
                break;
        }

        if (SUCCEEDED(hr))
        {
            SignatureSimpleBlob *pSignatureBlob = (SignatureSimpleBlob *)new BYTE[dwSize];

            if (NULL != pSignatureBlob)
            {
                *ppData = (BYTE *)pSignatureBlob;
                *pdwSize = dwSize;
                
                pSignatureBlob->dwSignature = BLOB_SIGNATURE;

                switch (pVar->vt)
                {
                    case VT_I4:                 // LONG           
                    case VT_UI1:                // BYTE           
                    case VT_I2:                 // SHORT          
                    case VT_R4:                 // FLOAT          
                    case VT_R8:                 // DOUBLE         
                    case VT_BOOL:               // VARIANT_BOOL   
                    case VT_ERROR:              // SCODE          
                    case VT_CY:                 // CY             
                    case VT_DATE:               // DATE
                    case VT_I1:                 // CHAR           
                    case VT_UI2:                // USHORT         
                    case VT_UI4:                // ULONG          
                    case VT_INT:                // INT            
                    case VT_UINT:               // UINT
                    {
                        SimpleVariantBlob *pBlob = &pSignatureBlob->svb;

                        memcpy(&pBlob->var, pVar, sizeof(NT32PACKAGE));
                        break;
                    }

                    case VT_BSTR:               // BSTR
                    {
                        BSTRVariantBlob *pbstrBlob = 
                            &((SignatureBSTRBlob *)pSignatureBlob)->bvb;
                        
                        memcpy(&pbstrBlob->var, pVar, sizeof(NT32PACKAGE));
                        pbstrBlob->dwSize = dwBstrLen;
                        memcpy(((BYTE *)pbstrBlob) + 
                                  (FIELD_OFFSET(BSTRVariantBlob, dwSize) + 
                                  sizeof(dwSize)),
                               pVar->bstrVal, 
                               dwBstrLen);
                        break;
                    }
                                
                    default:
                        ASSERT(0);  // Default case should have been eliminated!
                        break;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else        
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

CEnumItemProperties::CEnumItemProperties()
{
    ASSERT(0 == m_nCurrent);
    ASSERT(0 == m_nCount);
    ASSERT(NULL == m_pItemProps);

    m_cRef = 1;

    DllAddRef();    
}

CEnumItemProperties::~CEnumItemProperties()
{
    if (NULL != m_pItemProps)
    {
        for (ULONG i = 0; i < m_nCount; i++)
        {
            VariantClear(&m_pItemProps[i].variantValue);
            if (NULL != m_pItemProps[i].pwszName)
            {
                CoTaskMemFree(m_pItemProps[i].pwszName);
            }
        }
        delete [] m_pItemProps;
    }
    DllRelease();
}

HRESULT CEnumItemProperties::Initialize(const SUBSCRIPTIONCOOKIE *pCookie, ISubscriptionItem *psi)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;

    ASSERT(NULL != pCookie);

    if (OpenItemKey(pCookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwMaxValNameSize;
        DWORD dwMaxDataSize;
        DWORD dwCount;

        if (RegQueryInfoKey(hkey,
            NULL,   // address of buffer for class string 
            NULL,   // address of size of class string buffer 
            NULL,   // reserved 
            NULL,   // address of buffer for number of subkeys 
            NULL,   // address of buffer for longest subkey name length  
            NULL,   // address of buffer for longest class string length 
            &dwCount,   // address of buffer for number of value entries 
            &dwMaxValNameSize,  // address of buffer for longest value name length 
            &dwMaxDataSize, // address of buffer for longest value data length 
            NULL,   // address of buffer for security descriptor length 
            NULL    // address of buffer for last write time
            ) == ERROR_SUCCESS)
        {
            //  This allocates enough for Password as well
            m_pItemProps = new ITEMPROP[dwCount];

            dwMaxValNameSize++; //  Need room for NULL

            //  alloca candidates:

            TCHAR *pszValName = new TCHAR[dwMaxValNameSize];
            BYTE *pData = new BYTE[dwMaxDataSize];  
            
            if ((NULL != m_pItemProps) && (NULL != pData) && 
                (NULL != pszValName) 
               )
            {
                hr = S_OK;

                for (ULONG i = 0; i < dwCount; i++)
                {
                    DWORD dwType;
                    DWORD dwSize = dwMaxDataSize;
                    DWORD dwNameSize = dwMaxValNameSize;

                    if (SHEnumValue(hkey, i, pszValName, &dwNameSize, 
                                    &dwType, pData, &dwSize) != ERROR_SUCCESS)
                    {
                        hr = E_UNEXPECTED;
                        break;
                    }

                    //  Skip the default value and our subscription info structure
                    if ((NULL == *pszValName) ||
                        (0 == StrCmp(pszValName, c_szSubscriptionInfoValue))
                       )
                    {
                        continue;
                    }

                    if (dwType != REG_BINARY)
                    {
                        hr = E_UNEXPECTED;
                        break;
                    }

                    hr = SignatureBlobToVariant(pData, dwSize, &m_pItemProps[m_nCount].variantValue);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR *pwszName;
 
                        pwszName = pszValName;

                        ULONG ulSize = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);
                        m_pItemProps[m_nCount].pwszName = (WCHAR *)CoTaskMemAlloc(ulSize);
                        if (NULL != m_pItemProps[m_nCount].pwszName)
                        {
                            StrCpyNW(m_pItemProps[m_nCount].pwszName, pwszName, ulSize / sizeof(WCHAR));
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        m_nCount++;
                    }
                    else
                    {
                        break;
                    }
                }

                if (SUCCEEDED(ReadPassword(psi, &m_pItemProps[m_nCount].variantValue.bstrVal)))
                {
                    ULONG ulSize = sizeof(L"Password");
                    m_pItemProps[m_nCount].pwszName = (WCHAR *)CoTaskMemAlloc(ulSize);

                    if (NULL != m_pItemProps[m_nCount].pwszName)
                    {
                        StrCpyNW(m_pItemProps[m_nCount].pwszName, L"Password", ulSize / sizeof(WCHAR));
                        m_pItemProps[m_nCount].variantValue.vt = VT_BSTR;
                        m_nCount++;
                    }
                    else
                    {
                        SysFreeString(m_pItemProps[m_nCount].variantValue.bstrVal);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            SAFEDELETE(pszValName);
            SAFEDELETE(pData);
        }
        RegCloseKey(hkey);
    }
    return hr;
}

// IUnknown members
STDMETHODIMP CEnumItemProperties::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_IEnumItemProperties == riid))
    {
        *ppv = (IEnumItemProperties *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

STDMETHODIMP_(ULONG) CEnumItemProperties::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumItemProperties::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CEnumItemProperties::CopyItem(ITEMPROP *pip, WCHAR *pwszName, VARIANT *pVar)
{
    HRESULT hr;

    ASSERT(NULL != pwszName);
    
    if (NULL != pwszName)
    {
        
        ULONG cb = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);

        pip->pwszName = (WCHAR *)CoTaskMemAlloc(cb);
        if (NULL != pip->pwszName)
        {
            StrCpyNW(pip->pwszName, pwszName, cb /sizeof(WCHAR));
            pip->variantValue.vt = VT_EMPTY;    // is this a good idea?
            hr = VariantCopy(&pip->variantValue, pVar);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CEnumItemProperties::CopyRange(ULONG nStart, ULONG nCount, 
                                       ITEMPROP *ppip, ULONG *pnCopied)
{
    HRESULT hr = S_OK;
    ULONG n = 0;
    ULONG i;

    ASSERT((NULL != ppip) && (NULL != pnCopied));
    
    for (i = nStart; (S_OK == hr) && (i < m_nCount) && (n < nCount); i++, n++)
    {
        hr = CopyItem(&ppip[n], m_pItemProps[i].pwszName, &m_pItemProps[i].variantValue);
    }

    *pnCopied = n;

    if (SUCCEEDED(hr))
    {
        hr = (n == nCount) ? S_OK : S_FALSE;
    }
    
    return hr;
}

// IEnumItemProperties
STDMETHODIMP CEnumItemProperties::Next( 
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ITEMPROP *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hr;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    DWORD nFetched;

    hr = CopyRange(m_nCurrent, celt, rgelt, &nFetched);

    m_nCurrent += nFetched;

    if (pceltFetched)
    {
        *pceltFetched = nFetched;
    }

    return hr;
}

STDMETHODIMP CEnumItemProperties::Skip( 
    /* [in] */ ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}

STDMETHODIMP CEnumItemProperties::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

STDMETHODIMP CEnumItemProperties::Clone( 
    /* [out] */ IEnumItemProperties **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppenum = NULL;

    CEnumItemProperties *peip = new CEnumItemProperties;

    if (NULL != peip)
    {
        peip->m_pItemProps = new ITEMPROP[m_nCount];

        if (NULL != peip->m_pItemProps)
        {
            ULONG nFetched;

            hr = E_FAIL;

            peip->m_nCount = m_nCount;
            hr = CopyRange(0, m_nCount, peip->m_pItemProps, &nFetched);

            if (SUCCEEDED(hr))
            {
                ASSERT(m_nCount == nFetched);

                if (m_nCount == nFetched)
                {
                    hr = peip->QueryInterface(IID_IEnumItemProperties, (void **)ppenum);
                }
            }
        }
        peip->Release();
    }    
    return hr;
}

STDMETHODIMP CEnumItemProperties::GetCount( 
    /* [out] */ ULONG *pnCount)
{
    if (NULL == pnCount)
    {
        return E_INVALIDARG;
    }

    *pnCount = m_nCount;

    return S_OK;
}


CSubscriptionItem::CSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie, HKEY hkey)
{
    ASSERT(NULL != pCookie);
    ASSERT(0 == m_dwFlags);

    m_cRef = 1;

    if (NULL != pCookie)
    {
        m_Cookie = *pCookie;
    }

    SUBSCRIPTIONITEMINFO sii;

    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

    if ((hkey != NULL) && 
        SUCCEEDED(Read(hkey, c_wszSubscriptionInfoValue, (BYTE *)&sii, sizeof(SUBSCRIPTIONITEMINFO))))

    {
        m_dwFlags = sii.dwFlags;
    }

    DllAddRef();
}

CSubscriptionItem::~CSubscriptionItem()
{
    if (m_dwFlags & SI_TEMPORARY)
    {
        TCHAR szKey[MAX_PATH];

        if (ItemKeyNameFromCookie(&m_Cookie, szKey, ARRAYSIZE(szKey)))
        {
             SHDeleteKey(HKEY_CURRENT_USER, szKey);
        }
    }
    DllRelease();
}

HRESULT CSubscriptionItem::Read(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                BYTE *pData, DWORD dwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != pData) && (0 != dwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwType;
        DWORD dwSize = dwDataSize;

        if ((RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, pData, &dwSize) == ERROR_SUCCESS) &&
            (dwSize == dwDataSize) && (REG_BINARY == dwType))
        {
            hr = S_OK;
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}

HRESULT CSubscriptionItem::ReadWithAlloc(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                         BYTE **ppData, DWORD *pdwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != ppData) && (NULL != pdwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwType;
        DWORD dwSize = 0;


        if (RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
        {
            BYTE *pData = new BYTE[dwSize];
            *pdwDataSize = dwSize;

            if (NULL != pData)
            {
                if ((RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, pData, pdwDataSize) == ERROR_SUCCESS) &&
                    (dwSize == *pdwDataSize) && (REG_BINARY == dwType))
                {
                    *ppData = pData;
                    hr = S_OK;
                }
                else
                {
                    delete [] pData;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}

HRESULT CSubscriptionItem::Write(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                 BYTE *pData, DWORD dwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != pData) && (0 != dwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_WRITE, &hkey))
    {
        if (RegSetValueExW(hkey, pwszValueName, 0, REG_BINARY, pData, dwDataSize) == ERROR_SUCCESS)
        {
            hr = S_OK;
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}


STDMETHODIMP CSubscriptionItem::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_ISubscriptionItem == riid))
    {
        *ppv = (ISubscriptionItem *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}


STDMETHODIMP_(ULONG) CSubscriptionItem::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSubscriptionItem::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSubscriptionItem::GetCookie(SUBSCRIPTIONCOOKIE *pCookie)
{
    if (NULL == pCookie)
    {
        return E_INVALIDARG;
    }

    *pCookie = m_Cookie;

    return S_OK;
}

STDMETHODIMP CSubscriptionItem::GetSubscriptionItemInfo( 
    /* [out] */ SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo)
{
    HRESULT hr;

    if ((NULL == pSubscriptionItemInfo) ||
        (pSubscriptionItemInfo->cbSize < sizeof(SUBSCRIPTIONITEMINFO)))
    {
        return E_INVALIDARG;
    }

    hr = Read(NULL, c_wszSubscriptionInfoValue, (BYTE *)pSubscriptionItemInfo, sizeof(SUBSCRIPTIONITEMINFO));

    ASSERT(sizeof(SUBSCRIPTIONITEMINFO) == pSubscriptionItemInfo->cbSize);
    
    if (SUCCEEDED(hr) &&
        (sizeof(SUBSCRIPTIONITEMINFO) != pSubscriptionItemInfo->cbSize))
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::SetSubscriptionItemInfo( 
    /* [in] */ const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo)
{
    if ((NULL == pSubscriptionItemInfo) ||
        (pSubscriptionItemInfo->cbSize < sizeof(SUBSCRIPTIONITEMINFO)))
    {
        return E_INVALIDARG;
    }

    m_dwFlags = pSubscriptionItemInfo->dwFlags;
    
    return Write(NULL, c_wszSubscriptionInfoValue, (BYTE *)pSubscriptionItemInfo, sizeof(SUBSCRIPTIONITEMINFO));
}

STDMETHODIMP CSubscriptionItem::ReadProperties( 
    ULONG nCount,
    /* [size_is][in] */ const LPCWSTR rgwszName[],
    /* [size_is][out] */ VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    
    if ((0 == nCount) || (NULL == rgwszName) || (NULL == rgValue))
    {
        return E_INVALIDARG;
    }

    HKEY hkey;

    if (OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
        {
            BYTE *pData;
            DWORD dwDataSize;

            if (StrCmpIW(rgwszName[i], c_szPropPassword) == 0)
            {
                if (SUCCEEDED(ReadPassword(this, &rgValue[i].bstrVal)))
                {
                    rgValue[i].vt = VT_BSTR;
                }
                else
                {
                    rgValue[i].vt = VT_EMPTY;
                }
            }
            else
            {
                HRESULT hrRead = ReadWithAlloc(hkey, rgwszName[i], &pData, &dwDataSize);

                if (SUCCEEDED(hrRead))
                {
                    hr = SignatureBlobToVariant(pData, dwDataSize, &rgValue[i]);
                    delete [] pData;
                }
                else
                {
                    rgValue[i].vt = VT_EMPTY;
                }
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::WriteProperties( 
    ULONG nCount,
    /* [size_is][in] */ const LPCWSTR rgwszName[],
    /* [size_is][in] */ const VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    
    if ((0 == nCount) || (NULL == rgwszName) || (NULL == rgValue))
    {
        return E_INVALIDARG;
    }

    HKEY hkey;

    if (OpenItemKey(&m_Cookie, FALSE, KEY_WRITE, &hkey))
    {
        for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
        {
            if (rgValue[i].vt == VT_EMPTY)
            {
                //  We don't actually care if this fails since it is
                //  meant to delete the property anyhow

                RegDeleteValueW(hkey, rgwszName[i]);
            }
            else
            {
                BYTE *pData;
                DWORD dwDataSize;

                //  Special case the name property for easy viewing
                if ((VT_BSTR == rgValue[i].vt) && 
                    (StrCmpIW(rgwszName[i], c_szPropName) == 0))
                {   
                    RegSetValueExW(hkey, NULL, 0, REG_SZ, (LPBYTE)rgValue[i].bstrVal, 
                                   (lstrlenW(rgValue[i].bstrVal) + 1) * sizeof(WCHAR));
                }

                if (StrCmpIW(rgwszName[i], c_szPropPassword) == 0)
                {
                    if (VT_BSTR == rgValue[i].vt)
                    {
                        hr = WritePassword(this, rgValue[i].bstrVal);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = VariantToSignatureBlob(&rgValue[i], &pData, &dwDataSize);

                    if (SUCCEEDED(hr))
                    {
                        hr = Write(hkey, rgwszName[i], pData, dwDataSize);
                        delete [] pData;
                    }
                }
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::EnumProperties( 
    /* [out] */ IEnumItemProperties **ppEnumItemProperties)
{
    HRESULT hr;

    if (NULL == ppEnumItemProperties)
    {
        return E_INVALIDARG;
    }
    CEnumItemProperties *peip = new CEnumItemProperties;

    *ppEnumItemProperties = NULL;

    if (NULL != peip)
    {
        hr = peip->Initialize(&m_Cookie, this);
        if (SUCCEEDED(hr))
        {
            hr = peip->QueryInterface(IID_IEnumItemProperties, (void **)ppEnumItemProperties);
        }
        peip->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSubscriptionItem::NotifyChanged()
{
    HRESULT hr;

    // Notify the shell folder of the updated item
    // This is SOMEWHAT inefficient... why do we need 1000 properties for a pidl?
    // Why do we copy them around? Why why why?

    OOEBuf      ooeBuf;
    LPMYPIDL    newPidl = NULL;
    DWORD       dwSize = 0;

    memset(&ooeBuf, 0, sizeof(ooeBuf));

    hr = LoadWithCookie(NULL, &ooeBuf, &dwSize, &m_Cookie);

    if (SUCCEEDED(hr))
    {
        newPidl = COfflineFolderEnum::NewPidl(dwSize);
        if (newPidl)
        {
            CopyToMyPooe(&ooeBuf, &(newPidl->ooe));
            _GenerateEvent(SHCNE_UPDATEITEM, (LPITEMIDLIST)newPidl, NULL);
            COfflineFolderEnum::FreePidl(newPidl);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\subsmgrp.h ===
#include "offline.h"

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie, 
                                   ISubscriptionItem **ppSubscriptionItem);

HRESULT AddUpdateSubscription(SUBSCRIPTIONCOOKIE UNALIGNED *pCookie,
                              SUBSCRIPTIONITEMINFO *psii,
                              LPCWSTR pwszURL,
                              ULONG nProps,
                              const LPWSTR rgwszName[], 
                              VARIANT rgValue[]);

BOOL ItemKeyNameFromCookie(const SUBSCRIPTIONCOOKIE *pCookie, 
                           TCHAR *pszKeyName, 
                           DWORD cchKeyName);

BOOL OpenItemKey(const SUBSCRIPTIONCOOKIE *pCookie, BOOL fCreate, REGSAM samDesired, HKEY *phkey);

HRESULT GetInfoFromDataObject(IDataObject *pido,
                              TCHAR *pszPath, DWORD cchPath,
                              TCHAR *pszFriendlyName, DWORD cchFriendlyName,
                              TCHAR *pszURL, DWORD cchURL,
                              INIT_SRC_ENUM *peInitSrc);

HRESULT DoGetItemFromURL(LPCTSTR pszURL, ISubscriptionItem **ppSubscriptionItem);
HRESULT DoGetItemFromURLW(LPCWSTR pwszURL, ISubscriptionItem **ppSubscriptionItem);

HRESULT DoAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies);

HRESULT DoCreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem);

HRESULT DoCloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem);

HRESULT DoDeleteSubscriptionItem(
    /* [in] */ const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie,
    /* [in] */ BOOL fAbortItem);

//
// Subscription manager
//
class CSubscriptionMgr : public IShellPropSheetExt,
                         public IShellExtInit,
                         public ISubscriptionMgr2,
                         public ISubscriptionMgrPriv
{
friend INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND, UINT, WPARAM, LPARAM);
friend POOEBuf Summary_GetBuf(HWND hdlg);

protected:
    long        m_cRef;       
    LPMYPIDL    _pidl;
    SUBSCRIPTIONCOOKIE  m_cookie;
    TCHAR       m_pszURL[INTERNET_MAX_URL_LENGTH];
    TCHAR       m_pszFriendly[MAX_PATH];
    TCHAR       m_pszPath[MAX_PATH];
    POOEBuf     m_pBuf;
    IUnknown    * m_pUIHelper;
    UINT            m_nPages;
    INIT_SRC_ENUM   m_eInitSrc;
    SUBSCRIPTIONTYPE    m_oldType;

private:
    ~CSubscriptionMgr();

public:
    CSubscriptionMgr();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellExtInit members
    STDMETHODIMP         Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP         AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP         ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam);

    // ISubscriptionMgr
    STDMETHODIMP         DeleteSubscription(LPCWSTR pURL, HWND hwnd);
    STDMETHODIMP         IsSubscribed(LPCWSTR pURL, BOOL *);
    STDMETHODIMP         GetDefaultInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         GetSubscriptionInfo(LPCWSTR    pwszURL,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         ShowSubscriptionProperties(LPCWSTR pURL, HWND hwnd);
    STDMETHODIMP         CreateSubscription(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         UpdateSubscription(LPCWSTR pwszURL);
    STDMETHODIMP         UpdateAll();

    //  ISubscriptionMgr2
    STDMETHODIMP         GetItemFromURL(LPCWSTR pwszURL,
                                        ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP         GetItemFromCookie(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
                                           ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP         GetSubscriptionRunState(DWORD dwNumCookies,
                                                 const SUBSCRIPTIONCOOKIE *pCookies,
                                                 DWORD *pdwRunState);
    STDMETHODIMP         EnumSubscriptions(DWORD dwFlags,
                                           IEnumSubscription **ppEnumSubscriptions);
    STDMETHODIMP         UpdateItems(DWORD dwFlags,
                                     DWORD dwNumCookies,
                                     const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP         AbortItems(DWORD dwNumCookies,
                                    const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP         AbortAll();

    // ISubscriptionMgrPriv
    STDMETHODIMP        CreateSubscriptionItem(const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
                                               SUBSCRIPTIONCOOKIE *pNewCookie,
                                               ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP        CloneSubscriptionItem(ISubscriptionItem *pSubscriptionItem, 
                                              SUBSCRIPTIONCOOKIE *pNewCookie,
                                              ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP        DeleteSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie);

    STDMETHODIMP        RemovePages(HWND hdlg);
    STDMETHODIMP        SaveSubscription();
    STDMETHODIMP        URLChange(LPCWSTR pwszNewURL);


    HRESULT              CountSubscriptions(SUBSCRIPTIONTYPE subType, PDWORD pdwCount);

protected:
    void                 ChangeSubscriptionValues(OOEBuf *pCurrent, SUBSCRIPTIONINFO *pNew);
//    HRESULT              ResyncData(HWND);
    BOOL                 IsValidSubscriptionInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pSI);

    //helpers for CreateSubscription -- not exported via ISubscriptionMgr
    STDMETHODIMP         CreateSubscriptionNoSummary(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         CreateDesktopSubscription(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
};

class CEnumSubscription : public IEnumSubscription
{
public:
    CEnumSubscription();
    HRESULT Initialize(DWORD dwFlags);
    HRESULT CopyRange(ULONG nStart, ULONG nCount, SUBSCRIPTIONCOOKIE *pCookies, ULONG *pnCopied);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSubscription
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ SUBSCRIPTIONCOOKIE *rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ IEnumSubscription **ppenum);
    
    STDMETHODIMP GetCount( 
        /* [out] */ ULONG *pnCount);

private:
    ~CEnumSubscription();

    ULONG   m_nCurrent;
    ULONG   m_nCount;
    ULONG   m_cRef;

    SUBSCRIPTIONCOOKIE *m_pCookies;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\subsmgr.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "offl_cpp.h"
#include "helper.h"
#include "propshts.h"
#include "apithk.h"

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE TF_WEBCHECKCORE

extern HRESULT LoadSubscription(LPCTSTR url, LPMYPIDL *);
extern TCHAR szInternetSettings[];

extern void PropagateGeneralProp(HWND, POOEBuf);
extern HRESULT CreateSubscriptionFromOOEBuf(POOEBuf, LPMYPIDL *);

extern BOOL CALLBACK _AddOnePropSheetPage(HPROPSHEETPAGE, LPARAM);

#define MAX_STR_LENGTH 200

extern DWORD  aHelpIDs[];
extern TCHAR  c_szHelpFile[];

typedef struct
{
    CSubscriptionMgr* pMgr;
    LPCWSTR pwszName;
    LPCWSTR pwszUrl;
    SUBSCRIPTIONINFO* pSubsInfo;
    SUBSCRIPTIONTYPE subsType;
    DWORD dwFlags;
} SUBSCRIBE_ADI_INFO;

static const TCHAR SUBSCRIBEADIPROP[] = TEXT("SADIP");

INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////////
// Private imports from shdocvw (AddToFavorites API)
//
STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo);
////////////////////////////////////////////////////////////////////////////////


void UpdateSubsInfoFromOOE (SUBSCRIPTIONINFO* pInfo, POOEBuf pooe);

HRESULT CreateBSTRFromTSTR(BSTR * pBstr, LPCTSTR sz)
{
    int i = lstrlen(sz) + 1;
    *pBstr = SysAllocStringLen(NULL, i);
    if(NULL == *pBstr)
        return E_OUTOFMEMORY;

    MyStrToOleStrN(*pBstr, i, sz);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                        Subsctiption Manager
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// constructor / destructor
//
CSubscriptionMgr::CSubscriptionMgr(void)
{
    ASSERT(NULL == _pidl);

    m_cRef = 1;
    m_eInitSrc = _INIT_FROM_URL;    //  Default.
    m_oldType = SUBSTYPE_URL;       //  Default.
    DllAddRef();
}

CSubscriptionMgr::~CSubscriptionMgr()
{
    if (_pidl)
    {
        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
    }
    SAFELOCALFREE(m_pBuf);
    SAFERELEASE(m_pUIHelper);
    DllRelease();
}

//
// IUnknown members
//
STDMETHODIMP CSubscriptionMgr::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionMgr == riid) ||
        (IID_ISubscriptionMgr2 == riid))
    {
        *ppv=(ISubscriptionMgr2 *)this;
    } 
    else if(IID_ISubscriptionMgrPriv == riid)
    {
        *ppv=(ISubscriptionMgrPriv *)this;
    }
    else if(IID_IShellExtInit == riid)
    {
        *ppv=(IShellExtInit *)this;
    }
    else if(IID_IShellPropSheetExt == riid)
    {
        *ppv=(IShellPropSheetExt *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSubscriptionMgr::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSubscriptionMgr::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


HRESULT CSubscriptionMgr::RemovePages(HWND hDlg)
{
    HRESULT hr;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    ISubscriptionAgentShellExt *psase;

    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

    if (SUCCEEDED(hr))
    {
        hr = psase->RemovePages(hDlg);
        psase->Release();
    }

    return hr;
}

HRESULT CSubscriptionMgr::SaveSubscription()
{
    HRESULT hr;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    DWORD dwMaxCount = SHRestricted2W(REST_MaxSubscriptionCount, NULL, 0);
    DWORD dwCount;
    SUBSCRIPTIONTYPE subsType = (m_eInitSrc == _INIT_FROM_INTSHCUT) ? 
                                SUBSTYPE_URL : 
                                SUBSTYPE_CHANNEL;
    
    if ((dwMaxCount > 0) && 
        SUCCEEDED(CountSubscriptions(subsType, &dwCount)) &&
        (dwCount >= dwMaxCount))
    {
        SGMessageBox(GetForegroundWindow(), IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }
    
    ISubscriptionAgentShellExt *psase;

    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

    if (SUCCEEDED(hr))
    {
        hr = psase->SaveSubscription();
        psase->Release();
    }

    return hr;
}

HRESULT CSubscriptionMgr::URLChange(LPCWSTR pwszNewURL)
{
    return E_NOTIMPL;
}

HRESULT GetInfoFromDataObject(IDataObject *pido,
                              TCHAR *pszPath, DWORD cchPath,
                              TCHAR *pszFriendlyName, DWORD cchFriendlyName,
                              TCHAR *pszURL, DWORD cchURL,
                              INIT_SRC_ENUM *peInitSrc)
{
    STGMEDIUM stgmed;
    FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    HRESULT hr = pido->GetData(&fmtetc, &stgmed);

    if (hr == S_OK)
    {
        TCHAR szTempURL[INTERNET_MAX_URL_LENGTH];
        TCHAR *pszSection;
        TCHAR *pszEntry;
        TCHAR szTempPath[MAX_PATH];
        TCHAR szIniPath[MAX_PATH];

        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, szTempPath, ARRAYSIZE(szTempPath)))
        {
            // save path
            if (NULL != pszPath)
            {
                StrCpyN(pszPath, szTempPath, cchPath);
            }

            StrCpyN(szIniPath, szTempPath, ARRAYSIZE(szIniPath));
            
            // make friendly name from path
            if (NULL != pszFriendlyName)
            {
                PathStripPath(szTempPath);
                PathRemoveExtension(szTempPath);
                StrCpyN(pszFriendlyName, szTempPath, cchFriendlyName);
            }

            if ((NULL != pszURL) || (NULL != peInitSrc))
            {

                if (PathIsDirectory(szIniPath))
                {
                    PathAppend(szIniPath, TEXT("desktop.ini"));
                    pszSection = TEXT("Channel");
                    pszEntry = TEXT("CDFURL");

                    if (NULL != peInitSrc)
                        *peInitSrc = _INIT_FROM_CHANNEL;
                }
                else
                {
                    pszSection = TEXT("InternetShortcut");
                    pszEntry = TEXT("URL");
                    
                    if (NULL != peInitSrc)
                        *peInitSrc = _INIT_FROM_INTSHCUT;
                }

                if (NULL != pszURL)
                {
                    // canonicalize url
                    if (SHGetIniString(pszSection, pszEntry,
                                                szTempURL, 
                                                INTERNET_MAX_URL_LENGTH, 
                                                szIniPath))
                    {
                        if(!InternetCanonicalizeUrl(szTempURL, pszURL, &cchURL, ICU_NO_ENCODE))
                        {
                            // failed - use non-canonical version
                            StrCpyN(pszURL, szTempURL, cchURL);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
        else 
        {
            hr = E_FAIL;
        }

        ReleaseStgMedium(&stgmed);
    }

    return hr;
}

//
// IShellExtInit / IShellPropSheetExt members
//
STDMETHODIMP CSubscriptionMgr::Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pido, HKEY hkeyProgID)
{
    HRESULT hr;
    ISubscriptionItem *psi;
    CLSID clsid;
    SUBSCRIPTIONCOOKIE cookie;

    hr = GetInfoFromDataObject(pido, m_pszPath, ARRAYSIZE(m_pszPath),
                               m_pszFriendly, ARRAYSIZE(m_pszFriendly),
                               m_pszURL, ARRAYSIZE(m_pszURL),
                               &m_eInitSrc);

    if (SUCCEEDED(hr))
    {
        hr = DoGetItemFromURL(m_pszURL, &psi);
        
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONITEMINFO sii;

            sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

            hr = psi->GetSubscriptionItemInfo(&sii);

            if (SUCCEEDED(hr))
            {
                clsid = sii.clsidAgent;
            }

            psi->GetCookie(&cookie);

            psi->Release();
        }

        if (FAILED(hr))
        {
            //  New subscription       
            hr = S_OK;
            CreateCookie(&cookie);

            switch (m_eInitSrc)
            {
                case _INIT_FROM_INTSHCUT:
                    clsid = CLSID_WebCrawlerAgent;
                    break;
                    
                case _INIT_FROM_CHANNEL:
                    clsid = CLSID_ChannelAgent;
                    break;

                default:
                    hr = E_FAIL;
                    break;
            }
        }

        if (SUCCEEDED(hr))
        {
            //  HACKHACK:
            //  We call coinit and uninit and keep an object pointer around.
            //  This ain't cool but will work as long as the agents are in
            //  webcheck.  Need to fix this for multi-cast handler.
            hr = CoInitialize(NULL);

            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IUnknown, (void**)&m_pUIHelper);

                if (SUCCEEDED(hr))
                {
                    ISubscriptionAgentShellExt *psase;

                    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR wszURL[ARRAYSIZE(m_pszURL)];
                        WCHAR wszName[MAX_NAME + 1];

                        MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), m_pszURL);
                        MyStrToOleStrN(wszName, ARRAYSIZE(wszName), m_pszFriendly);
                        
                        hr = psase->Initialize(&cookie, wszURL, wszName,
                                               (clsid == CLSID_ChannelAgent) ?
                                               SUBSTYPE_CHANNEL : SUBSTYPE_URL);
                        psase->Release();
                    }
                }
                CoUninitialize();
            }
        }
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    if (SHRestricted2W(REST_NoEditingSubscriptions, NULL, 0))
        return E_FAIL;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    IShellPropSheetExt *pspse;

    hr = m_pUIHelper->QueryInterface(IID_IShellPropSheetExt, (void **)&pspse);

    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(lpfnAddPage, lParam);
        pspse->Release();
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// ISubscriptionMgr members
//

STDMETHODIMP CSubscriptionMgr::IsSubscribed(LPCWSTR pURL, BOOL * pFSub)
{
    HRESULT hr;

    ASSERT (pURL && pFSub);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);
 
    * pFSub = FALSE;

    if (!_pidl)
    {
        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return S_OK;
    }
    else if (UrlCompare(URL(&(_pidl->ooe)), m_pszURL, TRUE))
    {
        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return S_OK;
    }

    * pFSub = TRUE;
    return S_OK;
}

STDMETHODIMP CSubscriptionMgr::DeleteSubscription(LPCWSTR pURL, HWND hwnd)
{
    ASSERT(pURL);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);

    if (!_pidl)
    {
        HRESULT hr;

        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return E_FAIL;
    }

    // This is a restricted action.  The restriction
    // is checked in ConfirmDelete.  If you remove this call,
    // you must add the restriction check here.
    if (!ConfirmDelete(hwnd, 1, &_pidl))
        return E_FAIL;

    HRESULT hr = DoDeleteSubscription(&(_pidl->ooe));
    if (SUCCEEDED(hr))
    {
        TraceMsg(TF_ALWAYS, "%s(URL:%s) deleted", NAME(&(_pidl->ooe)), URL(&(_pidl->ooe)));

        _GenerateEvent(SHCNE_DELETE, (LPITEMIDLIST)_pidl, NULL);

        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
    }
    return hr;
}

STDMETHODIMP CSubscriptionMgr::ShowSubscriptionProperties(LPCWSTR pURL, HWND hwnd)
{
    HRESULT hr = S_OK;
    LPMYPIDL oldPidl = NULL, newPidl = NULL;

    ASSERT(pURL);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);

    if (!m_pBuf)
    {
        m_pBuf = (OOEBuf *)MemAlloc(LPTR, sizeof(OOEBuf));
        if (NULL == m_pBuf)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        GetDefaultOOEBuf(m_pBuf, SUBSTYPE_URL);

        if(SUCCEEDED(LoadSubscription(m_pszURL, &oldPidl)))
        {
            POOEntry pooe = &(oldPidl->ooe);

            StrCpyN(m_pszFriendly, NAME(&(oldPidl->ooe)), ARRAYSIZE(m_pszFriendly));

            CopyToOOEBuf(&(oldPidl->ooe), m_pBuf);

            m_pBuf->m_dwPropSheetFlags = PSF_IS_ALREADY_SUBSCRIBED;
        }
        else
        {
            CreateCookie(&m_pBuf->m_Cookie);
            StrCpyN(m_pszFriendly, m_pszURL, ARRAYSIZE(m_pszFriendly));
            StrCpyN(m_pBuf->m_URL, m_pszURL, ARRAYSIZE(m_pBuf->m_URL));
            StrCpyN(m_pBuf->m_Name, m_pszURL, ARRAYSIZE(m_pBuf->m_Name));
        }

        hr = CoCreateInstance(*(&m_pBuf->clsidDest), NULL, CLSCTX_INPROC_SERVER, 
                              IID_IUnknown, (void **)&m_pUIHelper);

        if (SUCCEEDED(hr))
        {
            ISubscriptionAgentShellExt *psase;
            
            hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

            if (SUCCEEDED(hr))
            {
                WCHAR wszURL[MAX_URL + 1];
                WCHAR wszName[MAX_NAME + 1];

                MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), m_pBuf->m_URL);
                MyStrToOleStrN(wszName, ARRAYSIZE(wszName), m_pBuf->m_Name);

                hr = psase->Initialize(&m_pBuf->m_Cookie, wszURL, wszName, (SUBSCRIPTIONTYPE)-1);
                psase->Release();
            }

            if (SUCCEEDED(hr))
            {
                PROPSHEETHEADER psh = { 0 } ;
                HPROPSHEETPAGE hPropPage[MAX_PROP_PAGES];

                // initialize propsheet header.
                psh.dwSize      = sizeof(PROPSHEETHEADER);
                psh.dwFlags     = PSH_PROPTITLE;
                psh.hwndParent  = hwnd;
                psh.pszCaption  = m_pszFriendly;
                psh.hInstance   = g_hInst;
                psh.nPages      = 0;
                psh.nStartPage  = 0;
                psh.phpage      = hPropPage;

                PROPSHEETPAGE psp;
                psp.dwSize          = sizeof(PROPSHEETPAGE);
                psp.dwFlags         = PSP_DEFAULT;
                psp.hInstance       = MLGetHinst();
                psp.pszIcon         = NULL;
                psp.pszTitle        = NULL;
                psp.lParam          = (LPARAM)this;

                psp.pszTemplate     = MAKEINTRESOURCE(IDD_SUBSPROPS_SUMMARY);
                psp.pfnDlgProc      = SummaryPropDlgProc;

                psh.phpage[psh.nPages++] = Whistler_CreatePropertySheetPageW(&psp);

                if (NULL != hPropPage[0])
                {
                    if (m_pBuf->m_dwPropSheetFlags & PSF_IS_ALREADY_SUBSCRIBED)
                    {
                        hr = AddPages(_AddOnePropSheetPage, (LPARAM)&psh);
                    }

                    if (SUCCEEDED(hr))
                    {
                        INT_PTR iRet = PropertySheet(&psh);

                        if (iRet < 0)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = LoadSubscription(m_pszURL, &newPidl);
                            if (SUCCEEDED(hr))
                            {
                                if (_pidl)
                                {
                                    COfflineFolderEnum::FreePidl(_pidl);
                                }

                                _pidl = newPidl;
                            }
                        }
                    }
                }
            }
        }

        if (NULL != oldPidl)
        {
            COfflineFolderEnum::FreePidl(oldPidl);
        }
    }

    return hr;
}

//
//
//

void
CSubscriptionMgr::ChangeSubscriptionValues (
    OOEBuf *pCurrent,
    SUBSCRIPTIONINFO *pNew
)
{
    //
    // Channel flags
    //

    if (SUBSINFO_CHANNELFLAGS & pNew->fUpdateFlags)
    {
        pCurrent->fChannelFlags = pNew->fChannelFlags;
    }


    //
    // The subscription schedule.
    //

    if (SUBSINFO_SCHEDULE & pNew->fUpdateFlags)
    {

        switch (pNew->schedule)
        {

            case SUBSSCHED_DAILY:
            case SUBSSCHED_MANUAL:
            case SUBSSCHED_WEEKLY:
                LoadGroupCookie(&pCurrent->groupCookie, pNew->schedule);
                break;

            case SUBSSCHED_CUSTOM:
                pCurrent->groupCookie = pNew->customGroupCookie;
                break;

            case SUBSSCHED_AUTO:
                {
                    //  FEATURE. We should look at subType;
                    memset(&pCurrent->groupCookie, 0, sizeof(pCurrent->groupCookie));  //t-mattgi so it will look at the trigger
                    PTASK_TRIGGER pNewTrigger = ((PTASK_TRIGGER)pNew->pTrigger);
                    if (pNewTrigger && pNewTrigger->cbTriggerSize == sizeof(TASK_TRIGGER))
                    {
                        pCurrent->m_Trigger = *pNewTrigger;
                    }
                    else    //bad trigger; use daily as default
                    {
                        pCurrent->m_Trigger.cbTriggerSize = 0;
                        pCurrent->groupCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
                    }
                }
                pCurrent->fChannelFlags |= CHANNEL_AGENT_DYNAMIC_SCHEDULE;
                break;

            default:
                ASSERT(FALSE);
                break;
        }
    }

    //
    // Recurse levels.
    //

    if (SUBSINFO_RECURSE & pNew->fUpdateFlags)
       pCurrent->m_RecurseLevels = pNew->dwRecurseLevels;

    //
    // Webcrawler flags.  Note:  The flags are not or'd with the current flags.
    // The caller must set all of the webcrawler flags they want to use.
    //

    if (SUBSINFO_WEBCRAWL & pNew->fUpdateFlags)
        pCurrent->m_RecurseFlags = pNew->fWebcrawlerFlags;

    //
    // Mail notification.
    //

    if (SUBSINFO_MAILNOT & pNew->fUpdateFlags)
        pCurrent->bMail = pNew->bMailNotification;
    else
        pCurrent->bMail = FALSE;

    //
    // Need password.
    //

    if (SUBSINFO_NEEDPASSWORD & pNew->fUpdateFlags)
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    else
        pCurrent->bNeedPassword = FALSE;
    
    //
    // User name.
    //

    if (SUBSINFO_USER & pNew->fUpdateFlags)
    {
        if (pNew->bstrUserName)
        {
            MyOleStrToStrN(pCurrent->username, MAX_USERNAME, pNew->bstrUserName);
        }
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    }
    
    //
    // Password.
    //

    if (SUBSINFO_PASSWORD & pNew->fUpdateFlags)
    {
        if (pNew->bstrPassword)
        {
            MyOleStrToStrN(pCurrent->password, MAX_PASSWORD, pNew->bstrPassword);
        }
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    }

    //
    // Friendly Name.
    //

    if (SUBSINFO_FRIENDLYNAME & pNew->fUpdateFlags)
    {
        if (pNew->bstrFriendlyName)
        {
            MyOleStrToStrN(pCurrent->m_Name, MAX_NAME, pNew->bstrFriendlyName);
        }
    }

    //
    // Gleam
    //

    if (SUBSINFO_GLEAM & pNew->fUpdateFlags)
    {
        pCurrent->bGleam = pNew->bGleam;
    }

    //
    // Changes only (notification only)
    //

    if (SUBSINFO_CHANGESONLY & pNew->fUpdateFlags)
    {
        pCurrent->bChangesOnly = pNew->bChangesOnly;
    }

    //
    // dwMaxSizeKB
    //
    if (SUBSINFO_MAXSIZEKB & pNew->fUpdateFlags)
    {
        pCurrent->m_SizeLimit = pNew->dwMaxSizeKB;
    }

    //
    // Task flags
    //
    if (SUBSINFO_TASKFLAGS & pNew->fUpdateFlags)
    {
        pCurrent->grfTaskTrigger = pNew->fTaskFlags;
    }

    return;
}

//
// CSubscriptionMgr::CountSubscriptions
// FEATURE: We could make this public if other people need it.  An enumerator
// would be more useful though...
//
HRESULT CSubscriptionMgr::CountSubscriptions(SUBSCRIPTIONTYPE subType, PDWORD pdwCount)
{
    HRESULT hr;
    IEnumSubscription *pes;

    ASSERT(NULL != pdwCount);

    *pdwCount = 0;

    hr = EnumSubscriptions(0, &pes);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONCOOKIE cookie;

        while (S_OK == pes->Next(1, &cookie, NULL))
        {
            ISubscriptionItem *psi;
            DWORD dwRet;

            if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &cookie, &psi)))
            {
                if (SUCCEEDED(ReadDWORD(psi, c_szPropChannel, &dwRet)) && dwRet)
                {
                    if (SUBSTYPE_CHANNEL == subType)
                        (*pdwCount)++;
                }
                else if (SUCCEEDED(ReadDWORD(psi, c_szPropDesktopComponent, &dwRet)) && dwRet)
                {
                    if (SUBSTYPE_DESKTOPURL == subType || SUBSTYPE_DESKTOPCHANNEL == subType)
                        (*pdwCount)++;
                }
                else
                {
                    if (SUBSTYPE_URL == subType)
                        (*pdwCount)++;
                }
                psi->Release();
            }
        }
    }

    return hr;
}

//
// CSubscriptionMgr::IsValidSubscriptionInfo
//

#define SUBSCRIPTIONSCHEDULE_MAX 4

BOOL CSubscriptionMgr::IsValidSubscriptionInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pSI)
{
    if (pSI->cbSize != sizeof(SUBSCRIPTIONINFO))
    {
        return FALSE;
    }
    else if (pSI->fUpdateFlags & ~SUBSINFO_ALLFLAGS)
    {
        return FALSE;
    }
    else if (pSI->pTrigger && ((TASK_TRIGGER*)(pSI->pTrigger))->cbTriggerSize &&
        (subType == SUBSTYPE_URL || subType == SUBSTYPE_DESKTOPURL)) // || pSI->schedule != SUBSSCHED_AUTO))
    {
        return FALSE;
    }
    else if (pSI->fUpdateFlags & SUBSINFO_SCHEDULE)
    {
        if (pSI->schedule > SUBSCRIPTIONSCHEDULE_MAX)
        {
            return FALSE;
        }
        if (pSI->schedule == SUBSSCHED_CUSTOM && pSI->customGroupCookie == CLSID_NULL)
        {
            return FALSE;
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** RemoveURLMapping ***
//
// Description:
//     Removes the cache and registry settings that wininet uses to map the 
//     given url to a local file.
//
////////////////////////////////////////////////////////////////////////////////

#define PRELOAD_REG_KEY \
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload")

void RemoveURLMapping(LPCWSTR pszURL)
{
    BYTE cei[MY_MAX_CACHE_ENTRY_INFO];
    DWORD cbcei = sizeof(cei);
    LPINTERNET_CACHE_ENTRY_INFOW pcei = (LPINTERNET_CACHE_ENTRY_INFOW)cei;
    
    //
    // Look up the url in the cache
    //
    if (GetUrlCacheEntryInfoExW(pszURL, pcei, &cbcei, NULL, 0, NULL, 0))
    {
        // 
        // see if it has a mapping because it is a preinstalled cache entry
        //
        if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
        {
            //
            // Clear the flag
            //
            pcei->CacheEntryType &= ~INSTALLED_CACHE_ENTRY;
            SetUrlCacheEntryInfoW(pszURL, pcei, CACHE_ENTRY_ATTRIBUTE_FC);

            //
            // Now remove the mapping from the registry
            //
            HKEY hk;
            if (RegOpenKeyEx(HKEY_CURRENT_USER, PRELOAD_REG_KEY, 0, KEY_WRITE, &hk) == ERROR_SUCCESS) 
            {
                RegDeleteValueW(hk, pszURL);
                RegCloseKey(hk);
            }
        }
    }
}

//
// CSubscriptionMgr::CreateSubscription
// entry point for creating a subscription
// flags:
//    CREATESUBS_FROMFAVORITES -- already exists in favorites, use alternate summary dialog
//                         that doesn't do AddToFavorites.  Valid only for channel or url.
//    CREATESUBS_INACTIVEPLATINUM -- when creating a channel subscription, show Activate Channel dialog
//                         valid only for channel subscriptions with CREATESUBS_FROMFAVORITES
//    CREATESUBS_ADDTOFAVORITES -- display summary dialog before wizard
//        default summary: for channel or url, use AddToFavorites from shdocvw
//                         for desktop item, just a confirmation dialog
//                         for other, no summary -- straight to wizard
//    CREATESUBS_NOUI -- totally silent
//    CREATESUBS_NOSAVE -- update subscription in memory buffer, not on disk (pInfo must be non-NULL)
//
STDMETHODIMP
CSubscriptionMgr::CreateSubscription (
    HWND hwnd,
    LPCWSTR pwszURL,
    LPCWSTR pwszFriendlyName,
    DWORD dwFlags,
    SUBSCRIPTIONTYPE subsType,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr = E_INVALIDARG;
    BOOL bAlready;

    if (IsFlagSet(dwFlags, CREATESUBS_NOUI) || !IsFlagSet (dwFlags, CREATESUBS_ADDTOFAVORITES))
    {    //no UI, so skip ATF dialog
        hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName, dwFlags,
            subsType, pInfo);

        if (hr == S_OK)
        {
            //
            // The user successfully subscribed to this URL so remove
            // mappings used for preinstalled content as this URL is now
            // "Activated"
            //
            RemoveURLMapping(pwszURL);
        }
    }
    else
    {
        switch (subsType)
        {
        case SUBSTYPE_URL:
        case SUBSTYPE_CHANNEL:
            hr = SHAddSubscribeFavorite (hwnd, pwszURL, pwszFriendlyName,
                                         dwFlags, subsType, pInfo);
            break;

        case SUBSTYPE_DESKTOPCHANNEL:
        case SUBSTYPE_DESKTOPURL:
            hr = IsSubscribed (pwszURL, &bAlready);
            if (SUCCEEDED (hr) && bAlready)
                break;  //don't display summary dialog since it has nothing useful for this case
            hr = CreateDesktopSubscription (hwnd, pwszURL, pwszFriendlyName,
                                            dwFlags, subsType, pInfo);
            break;

        default:    //SUBSTYPE_EXTERNAL -- don't know what kind of summary to show
            hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName, dwFlags,
                subsType, pInfo);
            break;
        }
    }

    return hr;
}


//
// CSubscriptionMgr::CreateSubscriptionNoSummary
// modify a SUBSCRIPTIONINFO interactively, using the wizard
// persists info to Subscriptions folder, unless SUBSINFO_NOSAVE passed
//
STDMETHODIMP
CSubscriptionMgr::CreateSubscriptionNoSummary (
    HWND hwnd,
    LPCWSTR pwszURL,
    LPCWSTR pwszFriendlyName,
    DWORD dwFlags,
    SUBSCRIPTIONTYPE subType,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr = S_OK;
    
    //
    // Validate the parameters.
    //
    if (!IS_VALID_SUBSCRIPTIONTYPE(subType)
        || !pwszURL
        || !pwszFriendlyName
        || (!pInfo && (dwFlags & CREATESUBS_NOSAVE))
        || (pInfo && !IsValidSubscriptionInfo(subType, pInfo)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // Fail if already subscribed and we aren't in no save or no UI mode.
    // Caller is responsible for UI.
    //
    BOOL fAlreadySubscribed;
    if ((FAILED(IsSubscribed(pwszURL, &fAlreadySubscribed)) || fAlreadySubscribed) &&
        (!(dwFlags & (CREATESUBS_NOSAVE | CREATESUBS_NOUI))))
    {
        return E_FAIL;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Currently cdfview is handling channel restrictions for 
    // but we should probably do it here.
    // Should we have a flag parameter to override this?
    //
    if (SUBSTYPE_URL == subType)
    {
        DWORD dwMaxCount = SHRestricted2W(REST_MaxSubscriptionCount, NULL, 0);
        DWORD dwCount;
        if (SHRestricted2W(REST_NoAddingSubscriptions, pwszURL, 0)
            || ((dwMaxCount > 0)
                && SUCCEEDED(CountSubscriptions(subType, &dwCount))
                && (dwCount >= dwMaxCount)))
        {
            if (!IsFlagSet(dwFlags, CREATESUBS_NOUI))
                SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
            return E_ACCESSDENIED;
        }
    }
    
    //
    // Get the subscription defaults and merge in the caller's info
    //
    OOEBuf subProps;
    GetDefaultOOEBuf(&subProps, subType);
    
    //this is (intentionally) duplicated below... it needs to be after the ChangeSubscriptionValues()
    //call, but we need to grab the url first to make sure it's subscribable.
    MyOleStrToStrN(subProps.m_URL, INTERNET_MAX_URL_LENGTH, pwszURL);

    // Does this mean we can't support plugin protocols?
    if (/*(subType != SUBSTYPE_EXTERNAL) &&*/ !IsHTTPPrefixed(subProps.m_URL))
    {
        return E_INVALIDARG;
    }

    if (pInfo)
    {
        ChangeSubscriptionValues(&subProps, pInfo);
        if (fAlreadySubscribed)
        {
            ReadCookieFromInetDB(subProps.m_URL, &subProps.m_Cookie);
            subProps.m_dwPropSheetFlags |= PSF_IS_ALREADY_SUBSCRIBED;
        }
    }

    // Disallow password caching if restriction is in place.  This both
    // skips the wizard page and prevents the caller's password from
    // being saved.
    if (SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        subProps.bNeedPassword = FALSE;
        subProps.username[0] = 0;
        subProps.password[0] = 0;
        subProps.dwFlags &= ~(PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
    }

    //the passed-in name and url override whatever's in the info buffer
    MyOleStrToStrN(subProps.m_URL, INTERNET_MAX_URL_LENGTH, pwszURL);
    MyOleStrToStrN(subProps.m_Name, MAX_NAME_QUICKLINK, pwszFriendlyName);

    //
    // If we're in UI mode, initialize the wizard
    //
    if (!IsFlagSet(dwFlags, CREATESUBS_NOUI))
    {
        hr = CreateWizard(hwnd, subType, &subProps);

    } // !NOUI

    //
    // If we're not in NOSAVE mode, then create/save the subscription
    //
    if (SUCCEEDED(hr))
    {
        if (!IsFlagSet(dwFlags, CREATESUBS_NOSAVE))
        {
            //
            // Create a new pidl with the user specified properties.
            //
            if (_pidl)
            {
                COfflineFolderEnum::FreePidl(_pidl);
                _pidl = NULL;
                SAFERELEASE(m_pUIHelper);
            }
            hr = CreateSubscriptionFromOOEBuf(&subProps, &_pidl);
            if (SUCCEEDED(hr))
            {
                ASSERT(_pidl);
                //
                // Send a notification that a subscription has changed.
                //
                _GenerateEvent(SHCNE_CREATE, (LPITEMIDLIST)_pidl, NULL);
            }
        } //!NOSAVE
        else if (S_OK == hr)
        {
            //in NOSAVE mode, so don't actually create subscription -- save it back
            //to passed-in buffer
            ASSERT (pInfo);
            pInfo->fUpdateFlags = SUBSINFO_ALLFLAGS;    //fill in all possible fields
            UpdateSubsInfoFromOOE (pInfo, &subProps);
        }
    }
    
    return hr;
}


STDMETHODIMP
CSubscriptionMgr::CreateDesktopSubscription (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszFriendlyName,
                        DWORD dwFlags, SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo)
{
    HRESULT hr;
    SUBSCRIPTIONINFO siTemp = { sizeof(SUBSCRIPTIONINFO), 0 };
    if (!pInfo)
        pInfo = &siTemp;    //make sure we have a valid buffer if caller doesn't give us one

    //make sure adminrestrictions allow this

    if (SHRestricted2W(REST_NoAddingChannels, pwszURL, 0))
        return E_FAIL;

    SUBSCRIBE_ADI_INFO parms = { this, pwszFriendlyName, pwszURL, pInfo, subsType, dwFlags };

    //make sure this url is subscribable; if not, show error dialog
    {
        TCHAR sz[MAX_URL];
        MyOleStrToStrN (sz, ARRAYSIZE(sz), pwszURL);

        if (!IsHTTPPrefixed (sz))
        {
            SGMessageBox(hwnd, IDS_HTTPONLY, MB_ICONINFORMATION | MB_OK);
            return E_INVALIDARG;
        }
    }

    INT_PTR iDlgResult = DialogBoxParam (MLGetHinst(), MAKEINTRESOURCE(IDD_DESKTOP_SUBSCRIPTION_SUMMARY),
                        hwnd, SummarizeDesktopSubscriptionDlgProc, (LPARAM)&parms);

    switch (iDlgResult)
    {
    case -1:
        hr = E_FAIL;
        break;
    case IDCANCEL:
        hr = S_FALSE;
        break;
    default:
        hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName,
                CREATESUBS_NOUI | dwFlags, subsType, pInfo);
        break;
    }

    return hr;
}


STDMETHODIMP
CSubscriptionMgr::GetDefaultInfo(
    SUBSCRIPTIONTYPE    subType,
    SUBSCRIPTIONINFO *pInfo
)
{
    //
    // Validate the parameters.
    //
    if (!IS_VALID_SUBSCRIPTIONTYPE(subType)
        || !pInfo 
        || (pInfo->cbSize != sizeof(SUBSCRIPTIONINFO)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    memset((void *)pInfo, 0, sizeof(SUBSCRIPTIONINFO));
    pInfo->cbSize = sizeof(SUBSCRIPTIONINFO);

    // Fill in default structure.  Note that lines are commented out
    // below to indicate the field is initialized to 0 without wasting
    // code (memset above already cleared structure out.)
    
    pInfo->fUpdateFlags = SUBSINFO_RECURSE | SUBSINFO_MAILNOT 
                        | SUBSINFO_WEBCRAWL 
                        /*| SUBSINFO_SCHEDULE */ | SUBSINFO_CHANGESONLY
                        | SUBSINFO_CHANNELFLAGS;
    pInfo->dwRecurseLevels = DEFAULTLEVEL;
    pInfo->schedule = SUBSSCHED_AUTO;
    
    switch (subType)
    {
        case SUBSTYPE_URL:
//            pInfo->bChangesOnly = FALSE;
//            pInfo->bMailNotification = FALSE;
//            pInfo->bPasswordNeeded = FALSE;
            pInfo->fWebcrawlerFlags = DEFAULTFLAGS;
            break;

        case SUBSTYPE_CHANNEL:
//            pInfo->bChangesOnly = FALSE;
//            pInfo->bMailNotification = FALSE;
            pInfo->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
            break;

        case SUBSTYPE_DESKTOPCHANNEL:
//          pInfo->bChangesOnly = FALSE;
//          pInfo->bMailNotification = FALSE;
            pInfo->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
            break;
            
        case SUBSTYPE_DESKTOPURL:
//          pInfo->bChangesOnly = FALSE;
//          pInfo->bMailNotification = FALSE;
            pInfo->fWebcrawlerFlags = DEFAULTFLAGS;
            break;
            
        default:
            return E_NOTIMPL;
    }
    
    return S_OK;
}

STDMETHODIMP
CSubscriptionMgr::GetSubscriptionInfo(
    LPCWSTR pwszURL,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr;

    //
    // Validate the parameters.
    //
    if (!pInfo 
        || !pwszURL
        || (pInfo->cbSize != sizeof(SUBSCRIPTIONINFO)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    BOOL    bSubscribe;
    hr = IsSubscribed(pwszURL, &bSubscribe);

    RETURN_ON_FAILURE(hr);
    if (!bSubscribe)
    {
        return E_FAIL;
    }


    // We cannot rely on the caller passing us a clean SUBSCRIPTIONINFO
    // structure.  We need to clean it ourselves.
    DWORD dwFlags = pInfo->fUpdateFlags;
    ZeroMemory(pInfo, sizeof(SUBSCRIPTIONINFO));
    pInfo->cbSize = sizeof(SUBSCRIPTIONINFO);
    pInfo->fUpdateFlags = dwFlags;

    OOEBuf ooeb;    // Alas, we need the code in UpdateSubsInfoFromOOE
    CopyToOOEBuf (&(_pidl->ooe), &ooeb);    //to work once for a buf and once for an entry, and it's
    UpdateSubsInfoFromOOE (pInfo, &ooeb);   //easier to convert entry->buf so we do that here.

    return S_OK;
}


void UpdateSubsInfoFromOOE (SUBSCRIPTIONINFO* pInfo, POOEBuf pooe)
{
    DWORD   dwFlags = pInfo->fUpdateFlags & SUBSINFO_ALLFLAGS;
    SUBSCRIPTIONTYPE subType = GetItemCategory(pooe);

    if (dwFlags & SUBSINFO_USER)
    {
        SAFEFREEBSTR (pInfo->bstrUserName);
        CreateBSTRFromTSTR(&(pInfo->bstrUserName), pooe->username);
    }
    if (dwFlags & SUBSINFO_PASSWORD)
    {
        SAFEFREEBSTR (pInfo->bstrPassword);
        CreateBSTRFromTSTR(&(pInfo->bstrPassword), pooe->password);
    }
    if (dwFlags & SUBSINFO_FRIENDLYNAME)
    {
        SAFEFREEBSTR (pInfo->bstrFriendlyName);
        CreateBSTRFromTSTR(&(pInfo->bstrFriendlyName), pooe->m_Name);
    }
    
    pInfo->fUpdateFlags = dwFlags;
    if (dwFlags & SUBSINFO_SCHEDULE)
    {
        pInfo->schedule = GetGroup(pooe);
        if (pInfo->schedule == SUBSSCHED_CUSTOM)
        {
            if (pooe->groupCookie != GUID_NULL)
            {
                pInfo->customGroupCookie = pooe->groupCookie;
            }
            else
            {
                GetItemSchedule(&pooe->m_Cookie, &pInfo->customGroupCookie);
                if (pInfo->customGroupCookie == GUID_NULL)
                {
                    pInfo->schedule = SUBSSCHED_MANUAL;
                }
            }
        }
    }
    
    if (PTASK_TRIGGER pInfoTrigger = (PTASK_TRIGGER)pInfo->pTrigger)
    {
        if (pInfoTrigger->cbTriggerSize == pooe->m_Trigger.cbTriggerSize)
            *(pInfoTrigger) = pooe->m_Trigger;
        else
            pInfoTrigger->cbTriggerSize = 0;
    }
    //otherwise, it's already null and we can't do anything about it... luckily, we'll never
    //have a trigger that we need to write back to a SUBSCRIPTIONINFO that didn't already have
    //one.

    if (dwFlags & SUBSINFO_RECURSE)
        pInfo->dwRecurseLevels = pooe->m_RecurseLevels;
    if (dwFlags & SUBSINFO_WEBCRAWL)
        pInfo->fWebcrawlerFlags = pooe->m_RecurseFlags;
    if (dwFlags & SUBSINFO_MAILNOT)
        pInfo->bMailNotification = pooe->bMail;
    if (dwFlags & SUBSINFO_GLEAM)
        pInfo->bGleam = pooe->bGleam;
    if (dwFlags & SUBSINFO_CHANGESONLY)
        pInfo->bChangesOnly = pooe->bChangesOnly;
    if (dwFlags & SUBSINFO_NEEDPASSWORD)
        pInfo->bNeedPassword = pooe->bNeedPassword;
    if (dwFlags & SUBSINFO_CHANNELFLAGS)
    {
        if ((subType==SUBSTYPE_CHANNEL)||(subType==SUBSTYPE_DESKTOPCHANNEL))
        {
            pInfo->fChannelFlags = pooe->fChannelFlags;
        }
        else
        {
            pInfo->fChannelFlags = 0;
            pInfo->fUpdateFlags &= (~SUBSINFO_CHANNELFLAGS);
        }
    }
    if (dwFlags & SUBSINFO_MAXSIZEKB)
        pInfo->dwMaxSizeKB = pooe->m_SizeLimit;


    if (dwFlags & SUBSINFO_TYPE)
    {
        pInfo->subType = GetItemCategory(pooe);
        ASSERT(IS_VALID_SUBSCRIPTIONTYPE(pInfo->subType));
    }

    if (dwFlags & SUBSINFO_TASKFLAGS)
    {
        pInfo->fTaskFlags = pooe->grfTaskTrigger;
    }

}


STDMETHODIMP
CSubscriptionMgr::UpdateSubscription(LPCWSTR pwszURL)
{
    ASSERT(pwszURL);
    BOOL    bSubscribe = FALSE;
    HRESULT hr = IsSubscribed(pwszURL, &bSubscribe);
    CLSID clsId;

    RETURN_ON_FAILURE(hr);
    if (!bSubscribe)
    {
        return E_INVALIDARG;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    clsId = _pidl->ooe.m_Cookie;    
    hr = SendUpdateRequests(NULL, &clsId, 1);
    _pidl->ooe.m_Cookie = clsId;

    return hr;
}

STDMETHODIMP
CSubscriptionMgr::UpdateAll()
{
    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    return SendUpdateRequests(NULL, NULL, 0);
}

HRESULT MergeOOEBuf(POOEBuf p1, POOEBuf p2, DWORD fMask)
{
    ASSERT(p1 && p2);
    DWORD   dwMask = p2->dwFlags & fMask;

    if (dwMask == 0)
        return S_OK;

    if (p1->clsidDest != p2->clsidDest)
        return E_INVALIDARG;

    if (dwMask & PROP_WEBCRAWL_COOKIE)
    {
        //  We shouldn't merge cookies.
    }

    if (dwMask & PROP_WEBCRAWL_SIZE)
    {
        p1->m_SizeLimit = p2->m_SizeLimit;
    }
    if (dwMask & PROP_WEBCRAWL_FLAGS)
    {
        p1->m_RecurseFlags = p2->m_RecurseFlags;
    }
    if (dwMask & PROP_WEBCRAWL_LEVEL)
    {
        p1->m_RecurseLevels = p2->m_RecurseLevels;
    }
    if (dwMask & PROP_WEBCRAWL_URL)
    {
        StrCpyN(p1->m_URL, p2->m_URL, ARRAYSIZE(p1->m_URL));
    }
    if (dwMask & PROP_WEBCRAWL_NAME)
    {
        StrCpyN(p1->m_Name, p2->m_Name, ARRAYSIZE(p1->m_Name));
    }

    if (dwMask & PROP_WEBCRAWL_PSWD)
    {
        StrCpyN(p1->password, p2->password, ARRAYSIZE(p1->password));
    }
    if (dwMask & PROP_WEBCRAWL_UNAME)
    {
        StrCpyN(p1->username, p2->username, ARRAYSIZE(p1->username));
    }
    if (dwMask & PROP_WEBCRAWL_DESKTOP)
    {
        p1->bDesktop = p2->bDesktop;
    }
    if (dwMask & PROP_WEBCRAWL_CHANNEL)
    {
        p1->bChannel = p2->bChannel;
    }
    if (dwMask & PROP_WEBCRAWL_EMAILNOTF)
    {
        p1->bMail = p2->bMail;
    }
    if (dwMask & PROP_WEBCRAWL_RESCH)
    {
        p1->grfTaskTrigger = p2->grfTaskTrigger;
        p1->groupCookie = p2->groupCookie;
        p1->fChannelFlags |= (p2->fChannelFlags & CHANNEL_AGENT_DYNAMIC_SCHEDULE);
    }
    if (dwMask & PROP_WEBCRAWL_LAST)
    {
        p1->m_LastUpdated = p2->m_LastUpdated;
    }
    if (dwMask & PROP_WEBCRAWL_STATUS)
    {
        p1->status = p2->status;
    }
    if (dwMask & PROP_WEBCRAWL_PRIORITY)
    {
        p1->m_Priority = p2->m_Priority;
    }
    if (dwMask & PROP_WEBCRAWL_GLEAM)
    {
        p1->bGleam = p2->bGleam;
    }
    if (dwMask & PROP_WEBCRAWL_CHANGESON